[
  {
    "sha": "cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYWJiNTY2MTIzNGY4ZDgzMmRiYzNiNjViZjgwYjBhY2MwMmRiMGEw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-02T19:18:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-02T20:17:49Z"
      },
      "message": "Disable certain false positive warnings for libsecp256k1 msvc build",
      "tree": {
        "sha": "45c4500d499354608c7cdeca9907c596130768a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45c4500d499354608c7cdeca9907c596130768a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e08f3193b543017702d000c2263bccbefa981c14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e08f3193b543017702d000c2263bccbefa981c14",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e08f3193b543017702d000c2263bccbefa981c14"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 5,
      "deletions": 4
    },
    "files": [
      {
        "sha": "f9b0a7975cb9198dc0a1b6375b5fffd46663ac76",
        "filename": "build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libsecp256k1/libsecp256k1.vcxproj?ref=cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "patch": "@@ -10,13 +10,14 @@\n   <ItemGroup>\n     <ClCompile Include=\"..\\..\\src\\secp256k1\\src\\secp256k1.c\" />\n   </ItemGroup>\n-    <ItemDefinitionGroup>\n+  <ItemDefinitionGroup>\n     <ClCompile>\n       <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;ENABLE_MODULE_EXTRAKEYS;ENABLE_MODULE_SCHNORRSIG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-       <AdditionalIncludeDirectories>..\\..\\src\\secp256k1;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n-     </ClCompile>\n+      <AdditionalIncludeDirectories>..\\..\\src\\secp256k1;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n+      <DisableSpecificWarnings>4146;4244;4267;4334</DisableSpecificWarnings>\n+    </ClCompile>\n   </ItemDefinitionGroup>\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n   <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n   <Import Project=\"..\\common.vcxproj\" />\n-</Project>\n\\ No newline at end of file\n+</Project>"
      }
    ]
  },
  {
    "sha": "bdca9bcb6c9379707d09c63f02326884befbefb2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGNhOWJjYjZjOTM3OTcwN2QwOWM2M2YwMjMyNjg4NGJlZmJlZmIy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-23T18:35:15Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-23T18:35:15Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 3967d96bf1..efad3506a8\n\nefad3506a8 Merge #906: Use modified divsteps with initial delta=1/2 for constant-time\ncc2c09e3a7 Merge #918: Clean up configuration in gen_context\n07067967ee add ECMULT_GEN_PREC_BITS to basic_config.h\na3aa2628c7 gen_context: Don't include basic-config.h\nbe0609fd54 Add unit tests for edge cases with delta=1/2 variant of divsteps\ncd393ce228 Optimization: only do 59 hddivsteps per iteration instead of 62\n277b224b6a Use modified divsteps with initial delta=1/2 for constant-time\n376ca366db Fix typo in explanation\n1e5d50fa93 Merge #889: fix uninitialized read in tests\nc083cc6e52 Merge #903: Make argument of fe_normalizes_to_zero{_var} const\n6e898534ff Merge #907: changed import to use brackets <> for openssl\n4504472269 changed import to use brackets <> for openssl as they are not local to the project\n26de4dfeb1 Merge #831: Safegcd inverses, drop Jacobi symbols, remove libgmp\n23c3fb629b Make argument of fe_normalizes_to_zero{_var} const\n24ad04fc06 Make scalar_inverse{,_var} benchmark scale with SECP256K1_BENCH_ITERS\nebc1af700f Optimization: track f,g limb count and pass to new variable-time update_fg_var\nb306935ac1 Optimization: use formulas instead of lookup tables for cancelling g bits\n9164a1b658 Optimization: special-case zero modulus limbs in modinv64\n1f233b3fa0 Remove num/gmp support\n20448b8d09 Remove unused Jacobi symbol support\n5437e7bdfb Remove unused scalar_sqr\naa9cc52180 Improve field/scalar inverse tests\n1e0e885c8a Make field/scalar code use the new modinv modules for inverses\n436281afdc Move secp256k1_fe_inverse{_var} to per-impl files\naa404d53be Move secp256k1_scalar_{inverse{_var},is_even} to per-impl files\n08d54964e5 Improve bounds checks in modinv modules\n151aac00d3 Add tests for modinv modules\nd8a92fcc4c Add extensive comments on the safegcd algorithm and implementation\n8e415acba2 Add safegcd based modular inverse modules\nde0a643c3d Add secp256k1_ctz{32,64}_var functions\n4c3ba88c3a Merge #901: ci: Switch all Linux builds to Debian and more improvements\n9361f360bb ci: Select number of parallel make jobs depending on CI environment\n28eccdf806 ci: Split output of logs into multiple sections\nc7f754fe4d ci: Run PRs on merge result instead of on the source branch\nb994a8be3c ci: Print information about binaries using \"file\"\nf24e122d13 ci: Switch all Linux builds to Debian\nebdba03cb5 Merge #891: build: Add workaround for automake 1.13 and older\n3a8b47bc6d Merge #894: ctime_test: move context randomization test to the end\n7d3497cdc4 ctime_test: move context randomization test to the end\n99a1cfec17 print warnings for conditional-uninitialized\n3d2cf6c5bd initialize variable in tests\nf329bba244 build: Add workaround for automake 1.13 and older\n24d1656c32 Merge #882: Use bit ops instead of int mult for constant-time logic in gej_add_ge\ne491d06b98 Use bit ops instead of int mult for constant-time logic in gej_add_ge\nf8c0b57e6b Merge #864: Add support for Cirrus CI\ncc2a5451dc ci: Refactor Nix shell files\n2480e55c8f ci: Remove support for Travis CI\n2b359f1c1d ci: Enable simple cache for brewing valgrind on macOS\n8c02e465c5 ci: Add support for Cirrus CI\n659d0d4798 Merge #880: Add parens around ROUND_TO_ALIGN's parameter.\nb6f649889a Add parens around ROUND_TO_ALIGN's parameter. This makes the macro robust against a hypothetical ROUND_TO_ALIGN(foo ? sizeA : size B) invocation.\na4abaab793 Merge #877: Add missing secp256k1_ge_set_gej_var decl.\n5671e5f3fd Merge #874: Remove underscores from header defs.\ndb726782fa Merge #878: Remove unused secp256k1_fe_inv_all_var\nb732701faa Merge #875: Avoid casting (void**) values.\n75d2ae149e Remove unused secp256k1_fe_inv_all_var\n482e4a9cfc Add missing secp256k1_ge_set_gej_var decl.\n2730618604 Avoid casting (void**) values. Replaced with an expression that only casts (void*) values.\nfb390c5299 Remove underscores from header defs. This makes them consistent with other files and avoids reserved identifiers.\nf2d9aeae6d Merge #862: Autoconf improvements\n328aaef22a Merge #845: Extract the secret key from a keypair\n3c15130709 Improve CC_FOR_BUILD detection\n47802a4762 Restructure and tidy configure.ac\n252c19dfc6 Ask brew for valgrind include path\n8c727b9087 Merge #860: fixed trivial typo\nb7bc3a4aaa fixed typo\n33cb3c2b1f Add secret key extraction from keypair to constant time tests\n36d9dc1e8e Add seckey extraction from keypair to the extrakeys tests\nfc96aa73f5 Add a function to extract the secretkey from a keypair\n98dac87839 Merge #858: Fix insecure links\n07aa4c70ff Fix insecure links\nb61f9da54e Merge #857: docs: fix simple typo, dependecy -> dependency\n18aadf9d28 docs: fix simple typo, dependecy -> dependency\n2d9e7175c6 Merge #852: Add sage script for generating scalar_split_lambda constants\ndc6e5c3a5c Merge #854: Rename msg32 to msghash32 in ecdsa_sign/verify and add explanation\n6e85d675aa Rename tweak to tweak32 in public API\nf587f04e35 Rename msg32 to msghash32 in ecdsa_sign/verify and add explanation\n329a2e0a3f sage: Add script for generating scalar_split_lambda constants\n8f0c6f1545 Merge #851: make test count iteration configurable by environment variable\nf4fa8d226a forbid a test iteration of 0 or less\nf554dfc708 sage: Reorganize files\n3a106966aa Merge #849: Convert Sage code to Python 3 (as used by Sage >= 9)\n13c88efed0 Convert Sage code to Python 3 (as used by Sage >= 9)\n0ce4554881 make test count iteration configurable by environment variable\n9e5939d284 Merge #835: Don't use reserved identifiers memczero and benchmark_verify_t\nd0a83f7328 Merge #839: Prevent arithmetic on NULL pointer if the scratch space is too small\n903b16aa6c Merge #840: Return NULL early in context_preallocated_create if flags invalid\n1f4dd03838 Typedef (u)int128_t only when they're not provided by the compiler\nebfa2058e9 Return NULL early in context_preallocated_create if flags invalid\n29a299e373 Run the undefined behaviour sanitizer on Travis\n7506e064d7 Prevent arithmetic on NULL pointer if the scratch space is too small\ne89278f211 Don't use reserved identifiers memczero and benchmark_verify_t\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: efad3506a8937162e8010f5839fdf3771dfcf516",
      "tree": {
        "sha": "f654bfaff4b5f042a6ecb001a5cf93fcb1dc8a0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f654bfaff4b5f042a6ecb001a5cf93fcb1dc8a0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdca9bcb6c9379707d09c63f02326884befbefb2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdca9bcb6c9379707d09c63f02326884befbefb2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bdca9bcb6c9379707d09c63f02326884befbefb2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdca9bcb6c9379707d09c63f02326884befbefb2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7"
      }
    ],
    "stats": {
      "total": 7321,
      "additions": 4865,
      "deletions": 2456
    },
    "files": [
      {
        "sha": "506a86033635412bf259eaa08010cde3708df49c",
        "filename": ".cirrus.yml",
        "status": "added",
        "additions": 198,
        "deletions": 0,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,198 @@\n+env:\n+  WIDEMUL: auto\n+  STATICPRECOMPUTATION: yes\n+  ECMULTGENPRECISION: auto\n+  ASM: no\n+  BUILD: check\n+  WITH_VALGRIND: yes\n+  RUN_VALGRIND: no\n+  EXTRAFLAGS:\n+  HOST:\n+  ECDH: no\n+  RECOVERY: no\n+  SCHNORRSIG: no\n+  EXPERIMENTAL: no\n+  CTIMETEST: yes\n+  BENCH: yes\n+  ITERS: 2\n+  MAKEFLAGS: -j2\n+\n+cat_logs_snippet: &CAT_LOGS\n+  always:\n+    cat_tests_log_script:\n+      - cat tests.log || true\n+    cat_exhaustive_tests_log_script:\n+      - cat exhaustive_tests.log || true\n+    cat_valgrind_ctime_test_log_script:\n+      - cat valgrind_ctime_test.log || true\n+    cat_bench_log_script:\n+      - cat bench.log || true\n+  on_failure:\n+    cat_config_log_script:\n+      - cat config.log || true\n+    cat_test_env_script:\n+      - cat test_env.log || true\n+    cat_ci_env_script:\n+      - env\n+\n+merge_base_script_snippet: &MERGE_BASE\n+  merge_base_script:\n+    - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n+    - git fetch $CIRRUS_REPO_CLONE_URL $CIRRUS_BASE_BRANCH\n+    - git config --global user.email \"ci@ci.ci\"\n+    - git config --global user.name \"ci\"\n+    - git merge FETCH_HEAD  # Merge base to detect silent merge conflicts\n+\n+task:\n+  name: \"x86_64: Linux (Debian stable)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    # Reduce number of CPUs to be able to do more builds in parallel.\n+    cpu: 1\n+    # More than enough for our scripts.\n+    memory: 1G\n+  matrix: &ENV_MATRIX\n+    - env: {WIDEMUL:  int64,  RECOVERY: yes}\n+    - env: {WIDEMUL:  int64,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128}\n+    - env: {WIDEMUL: int128,  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128,  ASM: x86_64}\n+    - env: {                  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {                  STATICPRECOMPUTATION: no}\n+    - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n+    - env: {CPPFLAGS: -DDETERMINISTIC}\n+    - env: {CFLAGS: -O0, CTIMETEST: no}\n+    - env:\n+        CFLAGS:  \"-fsanitize=undefined -fno-omit-frame-pointer\"\n+        LDFLAGS: \"-fsanitize=undefined -fno-omit-frame-pointer\"\n+        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n+        ASM: x86_64\n+        ECDH: yes\n+        RECOVERY: yes\n+        EXPERIMENTAL: yes\n+        SCHNORRSIG: yes\n+        CTIMETEST: no\n+    - env: { ECMULTGENPRECISION: 2 }\n+    - env: { ECMULTGENPRECISION: 8 }\n+    - env:\n+        RUN_VALGRIND: yes\n+        ASM: x86_64\n+        ECDH: yes\n+        RECOVERY: yes\n+        EXPERIMENTAL: yes\n+        SCHNORRSIG: yes\n+        EXTRAFLAGS: \"--disable-openssl-tests\"\n+        BUILD:\n+  matrix:\n+    - env:\n+        CC: gcc\n+    - env:\n+        CC: clang\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"i686: Linux (Debian stable)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    HOST: i686-linux-gnu\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+  matrix:\n+    - env:\n+        CC: i686-linux-gnu-gcc\n+    - env:\n+        CC: clang --target=i686-pc-linux-gnu -isystem /usr/i686-linux-gnu/include\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"x86_64: macOS Catalina\"\n+  macos_instance:\n+    image: catalina-base\n+  env:\n+    HOMEBREW_NO_AUTO_UPDATE: 1\n+    HOMEBREW_NO_INSTALL_CLEANUP: 1\n+    # Cirrus gives us a fixed number of 12 virtual CPUs. Not that we even have that many jobs at the moment...\n+    MAKEFLAGS: -j13\n+  matrix:\n+    << : *ENV_MATRIX\n+  matrix:\n+    - env:\n+        CC: gcc-9\n+    - env:\n+        CC: clang\n+  # Update Command Line Tools\n+  # Uncomment this if the Command Line Tools on the CirrusCI macOS image are too old to brew valgrind.\n+  # See https://apple.stackexchange.com/a/195963 for the implementation.\n+  ## update_clt_script:\n+  ##   - system_profiler SPSoftwareDataType\n+  ##   - touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress\n+  ##   - |-\n+  ##     PROD=$(softwareupdate -l | grep \"*.*Command Line\" | tail -n 1 | awk -F\"*\" '{print $2}' | sed -e 's/^ *//' | sed 's/Label: //g' | tr -d '\\n')\n+  ##   # For debugging\n+  ##   - softwareupdate -l && echo \"PROD: $PROD\"\n+  ##   - softwareupdate -i \"$PROD\" --verbose\n+  ##   - rm /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress\n+  ##\n+  brew_valgrind_pre_script:\n+    - brew config\n+    - brew tap --shallow LouisBrunner/valgrind\n+    # Fetch valgrind source but don't build it yet.\n+    - brew fetch --HEAD LouisBrunner/valgrind/valgrind\n+  brew_valgrind_cache:\n+    # This is $(brew --cellar valgrind) but command substition does not work here.\n+    folder: /usr/local/Cellar/valgrind\n+    # Rebuild cache if ...\n+    fingerprint_script:\n+      # ... macOS version changes:\n+      - sw_vers\n+      # ... brew changes:\n+      - brew config\n+      # ... valgrind changes:\n+      - git -C \"$(brew --cache)/valgrind--git\" rev-parse HEAD\n+    populate_script:\n+      # If there's no hit in the cache, build and install valgrind.\n+      - brew install --HEAD LouisBrunner/valgrind/valgrind\n+  brew_valgrind_post_script:\n+    # If we have restored valgrind from the cache, tell brew to create symlink to the PATH.\n+    # If we haven't restored from cached (and just run brew install), this is a no-op.\n+    - brew link valgrind\n+  brew_script:\n+    - brew install automake libtool gcc@9\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"s390x (big-endian): Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    QEMU_CMD: qemu-s390x\n+    HOST: s390x-linux-gnu\n+    BUILD:\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    # https://sourceware.org/bugzilla/show_bug.cgi?id=27008\n+    - rm /etc/ld.so.cache\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS"
      },
      {
        "sha": "ce8d6391b2f210318b156066d38a116b8970a502",
        "filename": ".travis.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 108,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "patch": "@@ -1,108 +0,0 @@\n-language: c\n-os:\n-  - linux\n-  - osx\n-\n-dist: bionic\n-# Valgrind currently supports upto macOS 10.13, the latest xcode of that version is 10.1\n-osx_image: xcode10.1\n-addons:\n-  apt:\n-    packages:\n-      - libgmp-dev\n-      - valgrind\n-      - libtool-bin\n-compiler:\n-  - clang\n-  - gcc\n-env:\n-  global:\n-    - WIDEMUL=auto  BIGNUM=auto  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  WITH_VALGRIND=yes RUN_VALGRIND=no EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n-  matrix:\n-    - WIDEMUL=int64   RECOVERY=yes\n-    - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128\n-    - WIDEMUL=int128  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128                    ASM=x86_64\n-    - BIGNUM=no\n-    - BIGNUM=no       RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - BIGNUM=no       STATICPRECOMPUTATION=no\n-    - BUILD=distcheck WITH_VALGRIND=no CTIMETEST=no BENCH=no\n-    - CPPFLAGS=-DDETERMINISTIC\n-    - CFLAGS=-O0 CTIMETEST=no\n-    - ECMULTGENPRECISION=2\n-    - ECMULTGENPRECISION=8\n-    - RUN_VALGRIND=yes BIGNUM=no ASM=x86_64 ECDH=yes  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes EXTRAFLAGS=\"--disable-openssl-tests\" BUILD=\n-matrix:\n-  fast_finish: true\n-  include:\n-    - compiler: clang\n-      os: linux\n-      env: HOST=i686-linux-gnu\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - libgmp-dev:i386\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    - compiler: clang\n-      env: HOST=i686-linux-gnu\n-      os: linux\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    - compiler: gcc\n-      env: HOST=i686-linux-gnu\n-      os: linux\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    - compiler: gcc\n-      os: linux\n-      env: HOST=i686-linux-gnu\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - libgmp-dev:i386\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    # S390x build (big endian system)\n-    - compiler: gcc\n-      env: HOST=s390x-unknown-linux-gnu ECDH=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes CTIMETEST=\n-      arch: s390x\n-\n-# We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n-# because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes.\n-# https://travis-ci.community/t/macos-build-fails-because-of-homebrew-bundle-unknown-command/7296\n-before_install:\n- - if [ \"${TRAVIS_OS_NAME}\" = \"osx\" ]; then HOMEBREW_NO_AUTO_UPDATE=1 brew install gmp valgrind gcc@9; fi\n-\n-before_script: ./autogen.sh\n-\n-# travis auto terminates jobs that go for 10 minutes without printing to stdout, but travis_wait doesn't work well with forking programs like valgrind (https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received https://github.com/bitcoin-core/secp256k1/pull/750#issuecomment-623476860)\n-script:\n-  - function keep_alive() { while true; do echo -en \"\\a\"; sleep 60; done }\n-  - keep_alive &\n-  - ./contrib/travis.sh\n-  - kill %keep_alive\n-\n-after_script:\n-    - cat ./tests.log\n-    - cat ./exhaustive_tests.log\n-    - cat ./valgrind_ctime_test.log\n-    - cat ./bench.log\n-    - $CC --version\n-    - valgrind --version"
      },
      {
        "sha": "58c9635e53e743c8b192b83e2301857ef766d15d",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -14,8 +14,6 @@ noinst_HEADERS += src/scalar_8x32_impl.h\n noinst_HEADERS += src/scalar_low_impl.h\n noinst_HEADERS += src/group.h\n noinst_HEADERS += src/group_impl.h\n-noinst_HEADERS += src/num_gmp.h\n-noinst_HEADERS += src/num_gmp_impl.h\n noinst_HEADERS += src/ecdsa.h\n noinst_HEADERS += src/ecdsa_impl.h\n noinst_HEADERS += src/eckey.h\n@@ -26,14 +24,16 @@ noinst_HEADERS += src/ecmult_const.h\n noinst_HEADERS += src/ecmult_const_impl.h\n noinst_HEADERS += src/ecmult_gen.h\n noinst_HEADERS += src/ecmult_gen_impl.h\n-noinst_HEADERS += src/num.h\n-noinst_HEADERS += src/num_impl.h\n noinst_HEADERS += src/field_10x26.h\n noinst_HEADERS += src/field_10x26_impl.h\n noinst_HEADERS += src/field_5x52.h\n noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n+noinst_HEADERS += src/modinv32.h\n+noinst_HEADERS += src/modinv32_impl.h\n+noinst_HEADERS += src/modinv64.h\n+noinst_HEADERS += src/modinv64_impl.h\n noinst_HEADERS += src/assumptions.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/scratch.h"
      },
      {
        "sha": "197a56fff842ad854cb26e089ac79b3f39e97dfc",
        "filename": "README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n+[![Build Status](https://api.cirrus-ci.com/github/bitcoin-core/secp256k1.svg?branch=master)](https://cirrus-ci.com/github/bitcoin-core/secp256k1)\n \n Optimized C library for ECDSA signatures and secret/public key operations on curve secp256k1.\n \n@@ -34,11 +34,11 @@ Implementation details\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n     * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n     * Using 10 26-bit limbs (including hand-optimized assembly for 32-bit ARM, by Wladimir J. van der Laan).\n-  * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n * Scalar operations\n   * Optimized implementation without data-dependent branches of arithmetic modulo the curve's order.\n     * Using 4 64-bit limbs (relying on __int128 support in the compiler).\n     * Using 8 32-bit limbs.\n+* Modular inverses (both field elements and scalars) based on [safegcd](https://gcd.cr.yp.to/index.html) with some modifications, and a variable-time variant (by Peter Dettman).\n * Group operations\n   * Point addition formula specifically simplified for the curve equation (y^2 = x^3 + 7).\n   * Use addition between points in Jacobian and affine coordinates where possible."
      },
      {
        "sha": "7bcbf3200cfa2851c739da25f5c15b6343e76f84",
        "filename": "build-aux/m4/ax_prog_cc_for_build.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/build-aux/m4/ax_prog_cc_for_build.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/build-aux/m4/ax_prog_cc_for_build.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_prog_cc_for_build.m4?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,5 +1,5 @@\n # ===========================================================================\n-#   http://www.gnu.org/software/autoconf-archive/ax_prog_cc_for_build.html\n+#   https://www.gnu.org/software/autoconf-archive/ax_prog_cc_for_build.html\n # ===========================================================================\n #\n # SYNOPSIS"
      },
      {
        "sha": "e57888ca18968e8d129a95eab586926a195de0ce",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -75,15 +75,10 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n fi\n ])\n \n-dnl\n-AC_DEFUN([SECP_GMP_CHECK],[\n-if test x\"$has_gmp\" != x\"yes\"; then\n+AC_DEFUN([SECP_VALGRIND_CHECK],[\n+if test x\"$has_valgrind\" != x\"yes\"; then\n   CPPFLAGS_TEMP=\"$CPPFLAGS\"\n-  CPPFLAGS=\"$GMP_CPPFLAGS $CPPFLAGS\"\n-  LIBS_TEMP=\"$LIBS\"\n-  LIBS=\"$GMP_LIBS $LIBS\"\n-  AC_CHECK_HEADER(gmp.h,[AC_CHECK_LIB(gmp, __gmpz_init,[has_gmp=yes; GMP_LIBS=\"$GMP_LIBS -lgmp\"; AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])])])\n-  CPPFLAGS=\"$CPPFLAGS_TEMP\"\n-  LIBS=\"$LIBS_TEMP\"\n+  CPPFLAGS=\"$VALGRIND_CPPFLAGS $CPPFLAGS\"\n+  AC_CHECK_HEADER([valgrind/memcheck.h], [has_valgrind=yes; AC_DEFINE(HAVE_VALGRIND,1,[Define this symbol if valgrind is installed])])\n fi\n ])"
      },
      {
        "sha": "f26ca98d1de39cf37248a0bbad65b221b5d4f615",
        "filename": "ci/cirrus.sh",
        "status": "renamed",
        "additions": 35,
        "deletions": 17,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/cirrus.sh?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -3,45 +3,63 @@\n set -e\n set -x\n \n-if [ \"$HOST\" = \"i686-linux-gnu\" ]\n-then\n-    export CC=\"$CC -m32\"\n-fi\n-if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] && [ \"$TRAVIS_COMPILER\" = \"gcc\" ]\n-then\n-    export CC=\"gcc-9\"\n-fi\n+export LC_ALL=C\n+\n+env >> test_env.log\n+\n+$CC -v || true\n+valgrind --version || true\n+\n+./autogen.sh\n \n ./configure \\\n     --enable-experimental=\"$EXPERIMENTAL\" \\\n-    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n+    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n     --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n     --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n     --with-valgrind=\"$WITH_VALGRIND\" \\\n     --host=\"$HOST\" $EXTRAFLAGS\n \n+# We have set \"-j<n>\" in MAKEFLAGS.\n+make\n+\n+# Print information about binaries so that we can see that the architecture is correct\n+file *tests || true\n+file bench_* || true\n+file .libs/* || true\n+\n if [ -n \"$BUILD\" ]\n then\n-    make -j2 \"$BUILD\"\n+    make \"$BUILD\"\n fi\n+\n if [ \"$RUN_VALGRIND\" = \"yes\" ]\n then\n-    make -j2\n-    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (http://valgrind.org/docs/manual/manual-core.html)\n+    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n     valgrind --error-exitcode=42 ./tests 16\n     valgrind --error-exitcode=42 ./exhaustive_tests\n fi\n+\n+if [ -n \"$QEMU_CMD\" ]\n+then\n+    $QEMU_CMD ./tests 16\n+    $QEMU_CMD ./exhaustive_tests\n+fi\n+\n if [ \"$BENCH\" = \"yes\" ]\n then\n+    # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n+    EXEC='./libtool --mode=execute'\n+    if [ -n \"$QEMU_CMD\" ]\n+    then\n+       EXEC=\"$EXEC $QEMU_CMD\"\n+    fi\n     if [ \"$RUN_VALGRIND\" = \"yes\" ]\n     then\n-        # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n-        EXEC='./libtool --mode=execute valgrind --error-exitcode=42'\n-    else\n-        EXEC=\n+        EXEC=\"$EXEC valgrind --error-exitcode=42\"\n     fi\n-    # This limits the iterations in the benchmarks below to ITER(set in .travis.yml) iterations.\n+    # This limits the iterations in the benchmarks below to ITER iterations.\n     export SECP256K1_BENCH_ITERS=\"$ITERS\"\n     {\n         $EXEC ./bench_ecmult",
        "previous_filename": "contrib/travis.sh"
      },
      {
        "sha": "5967cf8b311606f22ac453f501202ade99fc5ca0",
        "filename": "ci/linux-debian.Dockerfile",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/linux-debian.Dockerfile?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,13 @@\n+FROM debian:stable\n+\n+RUN dpkg --add-architecture i386\n+RUN dpkg --add-architecture s390x\n+RUN apt-get update\n+\n+# dkpg-dev: to make pkg-config work in cross-builds\n+RUN apt-get install --no-install-recommends --no-upgrade -y \\\n+        git ca-certificates \\\n+        make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n+        gcc clang libc6-dbg \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 \\\n+        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x"
      },
      {
        "sha": "1ed991afa771456838cb04c3b1e2cbfbea2359a9",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 147,
        "deletions": 132,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -14,17 +14,24 @@ AM_INIT_AUTOMAKE([foreign subdir-objects])\n : ${CFLAGS=\"-g\"}\n LT_INIT\n \n-dnl make the compilation flags quiet unless V=1 is used\n+# Make the compilation flags quiet unless V=1 is used.\n m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n \n PKG_PROG_PKG_CONFIG\n \n AC_PATH_TOOL(AR, ar)\n AC_PATH_TOOL(RANLIB, ranlib)\n AC_PATH_TOOL(STRIP, strip)\n-AX_PROG_CC_FOR_BUILD\n \n+# Save definition of AC_PROG_CC because AM_PROG_CC_C_O in automake<=1.13 will\n+# redefine AC_PROG_CC to exit with an error, which avoids the user calling it\n+# accidently and screwing up the effect of AM_PROG_CC_C_O. However, we'll need\n+# AC_PROG_CC later on in AX_PROG_CC_FOR_BUILD, where its usage is fine, and\n+# we'll carefully make sure not to call AC_PROG_CC anywhere else.\n+m4_copy([AC_PROG_CC], [saved_AC_PROG_CC])\n AM_PROG_CC_C_O\n+# Restore AC_PROG_CC\n+m4_rename_force([saved_AC_PROG_CC], [AC_PROG_CC])\n \n AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n@@ -37,25 +44,23 @@ case $host_os in\n      if  test x$cross_compiling != xyes; then\n        AC_PATH_PROG([BREW],brew,)\n        if test x$BREW != x; then\n-         dnl These Homebrew packages may be keg-only, meaning that they won't be found\n-         dnl in expected paths because they may conflict with system files. Ask\n-         dnl Homebrew where each one is located, then adjust paths accordingly.\n-\n+         # These Homebrew packages may be keg-only, meaning that they won't be found\n+         # in expected paths because they may conflict with system files. Ask\n+         # Homebrew where each one is located, then adjust paths accordingly.\n          openssl_prefix=`$BREW --prefix openssl 2>/dev/null`\n-         gmp_prefix=`$BREW --prefix gmp 2>/dev/null`\n+         valgrind_prefix=`$BREW --prefix valgrind 2>/dev/null`\n          if test x$openssl_prefix != x; then\n            PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n            export PKG_CONFIG_PATH\n            CRYPTO_CPPFLAGS=\"-I$openssl_prefix/include\"\n          fi\n-         if test x$gmp_prefix != x; then\n-           GMP_CPPFLAGS=\"-I$gmp_prefix/include\"\n-           GMP_LIBS=\"-L$gmp_prefix/lib\"\n+         if test x$valgrind_prefix != x; then\n+           VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n        else\n          AC_PATH_PROG([PORT],port,)\n-         dnl if homebrew isn't installed and macports is, add the macports default paths\n-         dnl as a last resort.\n+         # If homebrew isn't installed and macports is, add the macports default paths\n+         # as a last resort.\n          if test x$PORT != x; then\n            CPPFLAGS=\"$CPPFLAGS -isystem /opt/local/include\"\n            LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n@@ -77,6 +82,15 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n       CFLAGS=\"$saved_CFLAGS\"\n     ])\n \n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"-Wconditional-uninitialized $CFLAGS\"\n+AC_MSG_CHECKING([if ${CC} supports -Wconditional-uninitialized])\n+AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n+    [ AC_MSG_RESULT([yes]) ],\n+    [ AC_MSG_RESULT([no])\n+      CFLAGS=\"$saved_CFLAGS\"\n+    ])\n+\n saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n@@ -86,6 +100,10 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n       CFLAGS=\"$saved_CFLAGS\"\n     ])\n \n+###\n+### Define config arguments\n+###\n+\n AC_ARG_ENABLE(benchmark,\n     AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n@@ -146,13 +164,10 @@ AC_ARG_ENABLE(external_default_callbacks,\n     [use_external_default_callbacks=$enableval],\n     [use_external_default_callbacks=no])\n \n-dnl Test-only override of the (autodetected by the C code) \"widemul\" setting.\n-dnl Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n+# Test-only override of the (autodetected by the C code) \"widemul\" setting.\n+# Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n AC_ARG_WITH([test-override-wide-multiply], [] ,[set_widemul=$withval], [set_widemul=auto])\n \n-AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n-\n AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n [assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n@@ -177,15 +192,22 @@ AC_ARG_WITH([valgrind], [AS_HELP_STRING([--with-valgrind=yes|no|auto],\n )],\n [req_valgrind=$withval], [req_valgrind=auto])\n \n+###\n+### Handle config options (except for modules)\n+###\n+\n if test x\"$req_valgrind\" = x\"no\"; then\n   enable_valgrind=no\n else\n-  AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [\n+  SECP_VALGRIND_CHECK\n+  if test x\"$has_valgrind\" != x\"yes\"; then\n     if test x\"$req_valgrind\" = x\"yes\"; then\n       AC_MSG_ERROR([Valgrind support explicitly requested but valgrind/memcheck.h header not available])\n     fi\n     enable_valgrind=no\n-  ], [])\n+  else\n+    enable_valgrind=yes\n+  fi\n fi\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n@@ -197,61 +219,6 @@ else\n     CFLAGS=\"-O2 $CFLAGS\"\n fi\n \n-if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n-  # Temporarily switch to an environment for the native compiler\n-  save_cross_compiling=$cross_compiling\n-  cross_compiling=no\n-  SAVE_CC=\"$CC\"\n-  CC=\"$CC_FOR_BUILD\"\n-  SAVE_CFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$CFLAGS_FOR_BUILD\"\n-  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n-  CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n-  SAVE_LDFLAGS=\"$LDFLAGS\"\n-  LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n-\n-  warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n-  saved_CFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n-  AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n-  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-      [ AC_MSG_RESULT([yes]) ],\n-      [ AC_MSG_RESULT([no])\n-        CFLAGS=\"$saved_CFLAGS\"\n-      ])\n-\n-  AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n-  AC_RUN_IFELSE(\n-    [AC_LANG_PROGRAM([], [])],\n-    [working_native_cc=yes],\n-    [working_native_cc=no],[:])\n-\n-  CFLAGS_FOR_BUILD=\"$CFLAGS\"\n-\n-  # Restore the environment\n-  cross_compiling=$save_cross_compiling\n-  CC=\"$SAVE_CC\"\n-  CFLAGS=\"$SAVE_CFLAGS\"\n-  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n-  LDFLAGS=\"$SAVE_LDFLAGS\"\n-\n-  if test x\"$working_native_cc\" = x\"no\"; then\n-    AC_MSG_RESULT([no])\n-    set_precomp=no\n-    m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n-    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n-      AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n-    else\n-      AC_MSG_WARN([Disabling statically generated ecmult table because the native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n-    fi\n-  else\n-    AC_MSG_RESULT([yes])\n-    set_precomp=yes\n-  fi\n-else\n-  set_precomp=no\n-fi\n-\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -279,33 +246,7 @@ else\n   esac\n fi\n \n-if test x\"$req_bignum\" = x\"auto\"; then\n-  SECP_GMP_CHECK\n-  if test x\"$has_gmp\" = x\"yes\"; then\n-    set_bignum=gmp\n-  fi\n-\n-  if test x\"$set_bignum\" = x; then\n-    set_bignum=no\n-  fi\n-else\n-  set_bignum=$req_bignum\n-  case $set_bignum in\n-  gmp)\n-    SECP_GMP_CHECK\n-    if test x\"$has_gmp\" != x\"yes\"; then\n-      AC_MSG_ERROR([gmp bignum explicitly requested but libgmp not available])\n-    fi\n-    ;;\n-  no)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid bignum implementation selection])\n-    ;;\n-  esac\n-fi\n-\n-# select assembly optimization\n+# Select assembly optimization\n use_external_asm=no\n \n case $set_asm in\n@@ -322,7 +263,12 @@ no)\n   ;;\n esac\n \n-# select wide multiplication implementation\n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+\n+# Select wide multiplication implementation\n case $set_widemul in\n int128)\n   AC_DEFINE(USE_FORCE_WIDEMUL_INT128, 1, [Define this symbol to force the use of the (unsigned) __int128 based wide multiplication implementation])\n@@ -337,25 +283,7 @@ auto)\n   ;;\n esac\n \n-# select bignum implementation\n-case $set_bignum in\n-gmp)\n-  AC_DEFINE(HAVE_LIBGMP, 1, [Define this symbol if libgmp is installed])\n-  AC_DEFINE(USE_NUM_GMP, 1, [Define this symbol to use the gmp implementation for num])\n-  AC_DEFINE(USE_FIELD_INV_NUM, 1, [Define this symbol to use the num-based field inverse implementation])\n-  AC_DEFINE(USE_SCALAR_INV_NUM, 1, [Define this symbol to use the num-based scalar inverse implementation])\n-  ;;\n-no)\n-  AC_DEFINE(USE_NUM_NONE, 1, [Define this symbol to use no num implementation])\n-  AC_DEFINE(USE_FIELD_INV_BUILTIN, 1, [Define this symbol to use the native field inverse implementation])\n-  AC_DEFINE(USE_SCALAR_INV_BUILTIN, 1, [Define this symbol to use the native scalar inverse implementation])\n-  ;;\n-*)\n-  AC_MSG_ERROR([invalid bignum implementation])\n-  ;;\n-esac\n-\n-#set ecmult window size\n+# Set ecmult window size\n if test x\"$req_ecmult_window\" = x\"auto\"; then\n   set_ecmult_window=15\n else\n@@ -377,7 +305,7 @@ case $set_ecmult_window in\n   ;;\n esac\n \n-#set ecmult gen precision\n+# Set ecmult gen precision\n if test x\"$req_ecmult_gen_precision\" = x\"auto\"; then\n   set_ecmult_gen_precision=4\n else\n@@ -419,15 +347,93 @@ else\n   enable_openssl_tests=no\n fi\n \n-if test x\"$set_bignum\" = x\"gmp\"; then\n-  SECP_LIBS=\"$SECP_LIBS $GMP_LIBS\"\n-  SECP_INCLUDES=\"$SECP_INCLUDES $GMP_CPPFLAGS\"\n+if test x\"$enable_valgrind\" = x\"yes\"; then\n+  SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n+fi\n+\n+# Handle static precomputation (after everything which modifies CFLAGS and friends)\n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  if test x\"$cross_compiling\" = x\"no\"; then\n+    set_precomp=yes\n+    if test x\"${CC_FOR_BUILD+x}${CFLAGS_FOR_BUILD+x}${CPPFLAGS_FOR_BUILD+x}${LDFLAGS_FOR_BUILD+x}\" != x; then\n+      AC_MSG_WARN([CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD is set but ignored because we are not cross-compiling.])\n+    fi\n+    # If we're not cross-compiling, simply use the same compiler for building the static precompation code.\n+    CC_FOR_BUILD=\"$CC\"\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n+    CPPFLAGS_FOR_BUILD=\"$CPPFLAGS\"\n+    LDFLAGS_FOR_BUILD=\"$LDFLAGS\"\n+  else\n+    AX_PROG_CC_FOR_BUILD\n+\n+    # Temporarily switch to an environment for the native compiler\n+    save_cross_compiling=$cross_compiling\n+    cross_compiling=no\n+    SAVE_CC=\"$CC\"\n+    CC=\"$CC_FOR_BUILD\"\n+    SAVE_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n+    SAVE_CPPFLAGS=\"$CPPFLAGS\"\n+    CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+    SAVE_LDFLAGS=\"$LDFLAGS\"\n+    LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n+\n+    warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n+    saved_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n+    AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n+    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n+        [ AC_MSG_RESULT([yes]) ],\n+        [ AC_MSG_RESULT([no])\n+          CFLAGS=\"$saved_CFLAGS\"\n+        ])\n+\n+    AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n+    AC_RUN_IFELSE(\n+      [AC_LANG_PROGRAM([], [])],\n+      [working_native_cc=yes],\n+      [working_native_cc=no],[:])\n+\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n+\n+    # Restore the environment\n+    cross_compiling=$save_cross_compiling\n+    CC=\"$SAVE_CC\"\n+    CFLAGS=\"$SAVE_CFLAGS\"\n+    CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+    LDFLAGS=\"$SAVE_LDFLAGS\"\n+\n+    if test x\"$working_native_cc\" = x\"no\"; then\n+      AC_MSG_RESULT([no])\n+      set_precomp=no\n+      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n+      if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+        AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n+      else\n+        AC_MSG_WARN([Disabling statically generated ecmult table because the native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n+      fi\n+    else\n+      AC_MSG_RESULT([yes])\n+      set_precomp=yes\n+    fi\n+  fi\n+\n+  AC_SUBST(CC_FOR_BUILD)\n+  AC_SUBST(CFLAGS_FOR_BUILD)\n+  AC_SUBST(CPPFLAGS_FOR_BUILD)\n+  AC_SUBST(LDFLAGS_FOR_BUILD)\n+else\n+  set_precomp=no\n fi\n \n if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n \n+###\n+### Handle module options\n+###\n+\n if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n@@ -447,14 +453,14 @@ if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_EXTRAKEYS, 1, [Define this symbol to enable the extrakeys module])\n fi\n \n-if test x\"$use_external_asm\" = x\"yes\"; then\n-  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n-fi\n-\n if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n fi\n \n+###\n+### Check for --enable-experimental if necessary\n+###\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -474,6 +480,10 @@ else\n   fi\n fi\n \n+###\n+### Generate output\n+###\n+\n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n AC_SUBST(SECP_INCLUDES)\n@@ -492,7 +502,7 @@ AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" =\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n-dnl make sure nothing new is exported so that we don't break the cache\n+# Make sure nothing new is exported so that we don't break the cache.\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\"\n unset PKG_CONFIG_PATH\n PKG_CONFIG_PATH=\"$PKGCONFIG_PATH_TEMP\"\n@@ -513,10 +523,9 @@ echo \"  module extrakeys        = $enable_module_extrakeys\"\n echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n echo\n echo \"  asm                     = $set_asm\"\n-echo \"  bignum                  = $set_bignum\"\n echo \"  ecmult window size      = $set_ecmult_window\"\n echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n-dnl Hide test-only options unless they're used.\n+# Hide test-only options unless they're used.\n if test x\"$set_widemul\" != xauto; then\n echo \"  wide multiplication     = $set_widemul\"\n fi\n@@ -527,3 +536,9 @@ echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  CPPFLAGS                = $CPPFLAGS\"\n echo \"  LDFLAGS                 = $LDFLAGS\"\n echo\n+if test x\"$set_precomp\" = x\"yes\"; then\n+echo \"  CC_FOR_BUILD            = $CC_FOR_BUILD\"\n+echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n+echo \"  CPPFLAGS_FOR_BUILD      = $CPPFLAGS_FOR_BUILD\"\n+echo \"  LDFLAGS_FOR_BUILD       = $LDFLAGS_FOR_BUILD\"\n+fi"
      },
      {
        "sha": "c1627e37e9e11900796d426eae58056c525b1a11",
        "filename": "contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n #include <secp256k1.h>"
      },
      {
        "sha": "6b7255e28f5bc78ffdc48940821d8fed062eaa55",
        "filename": "contrib/lax_der_parsing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n /****\n  * Please do not link this file directly. It is not part of the libsecp256k1"
      },
      {
        "sha": "429760fbb6d19ab0afff7c36d4f37431b8ecd932",
        "filename": "contrib/lax_der_privatekey_parsing.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_privatekey_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_privatekey_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_privatekey_parsing.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014, 2015 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014, 2015 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n #include <secp256k1.h>"
      },
      {
        "sha": "602c7c556ad153a06459222663db08b1c4e8df7c",
        "filename": "contrib/lax_der_privatekey_parsing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_privatekey_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/contrib/lax_der_privatekey_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_privatekey_parsing.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014, 2015 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014, 2015 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n /****\n  * Please do not link this file directly. It is not part of the libsecp256k1"
      },
      {
        "sha": "3ae556f9a724011c4fa27b8e929e0f0e1e56e4f2",
        "filename": "doc/safegcd_implementation.md",
        "status": "added",
        "additions": 765,
        "deletions": 0,
        "changes": 765,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/doc/safegcd_implementation.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/doc/safegcd_implementation.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/safegcd_implementation.md?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,765 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper (section 11), at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in later\n+sections.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting less than *2<sup>N</sup>*\n+times *M* to cancel out *N* bits brings that up to *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and\n+dividing by *2<sup>N</sup>* at the end takes it to *(-2M,M)*. Another application of `update_de` would take that\n+to *(-3M,2M)*, and so forth. This progressive expansion of the variables' ranges can be\n+counteracted by incrementing *d* and *e* by *M* whenever they're negative:\n+\n+```python\n+    ...\n+    if d < 0:\n+        d += M\n+    if e < 0:\n+        e += M\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    ...\n+```\n+\n+With inputs in *(-2M,M)*, they will first be shifted into range *(-M,M)*, which means that the\n+output will again be in *(-2M,M)*, and this remains the case regardless of how many `update_de`\n+invocations there are. In what follows, we will try to make this more efficient.\n+\n+Note that increasing *d* by *M* is equal to incrementing *cd* by *u&thinsp;M* and *ce* by *q&thinsp;M*. Similarly,\n+increasing *e* by *M* is equal to incrementing *cd* by *v&thinsp;M* and *ce* by *r&thinsp;M*. So we could instead write:\n+\n+```python\n+    ...\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Perform the equivalent of incrementing d, e by M when they're negative.\n+    if d < 0:\n+        cd += u*M\n+        ce += q*M\n+    if e < 0:\n+        cd += v*M\n+        ce += r*M\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    ...\n+```\n+\n+Now note that we have two steps of corrections to *cd* and *ce* that add multiples of *M*: this\n+increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+one, but they can still be efficiently combined by only computing the bottom bits of *cd* and *ce*\n+at first, and using that to compute the final *md*, *me* values:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    md, me = 0, 0\n+    # Compute what multiples of M to add to cd and ce.\n+    if d < 0:\n+        md += u\n+        me += q\n+    if e < 0:\n+        md += v\n+        me += r\n+    # Compute bottom N bits of t*[d,e] + M*[md,me].\n+    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+    md -= (Mi * cd) % 2**N\n+    me -= (Mi * ce) % 2**N\n+    # Do the full computation.\n+    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+One last optimization: we can avoid the *md&thinsp;M* and *me&thinsp;M* multiplications in the bottom bits of *cd*\n+and *ce* by moving them to the *md* and *me* correction:\n+\n+```python\n+    ...\n+    # Compute bottom N bits of t*[d,e].\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+    # Note that this is not the same as {md = (-Mi * cd) % 2**N} etc. That would also result in N\n+    # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+    # previous md and me values, and thus would violate our bounds analysis.\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    ...\n+```\n+\n+The resulting function takes *d* and *e* in range *(-2M,M)* as inputs, and outputs values in the same\n+range. That also means that the *d* value at the end of `modinv` will be in that range, while we want\n+a result in *[0,M)*. To do that, we need a normalization function. It's easy to integrate the\n+conditional negation of *d* (based on the sign of *f*) into it as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+    assert sign == 1 or sign == -1\n+    # v in (-2*M,M)\n+    if v < 0:\n+        v += M\n+    # v in (-M,M). Now multiply v with sign (which can only be 1 or -1).\n+    if sign == -1:\n+        v = -v\n+    # v in (-M,M)\n+    if v < 0:\n+        v += M\n+    # v in [0,M)\n+    return v\n+```\n+\n+And calling it in `modinv` is simply:\n+\n+```python\n+   ...\n+   return normalize(f, d, M)\n+```\n+\n+\n+## 5. Constant-time operation\n+\n+The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+depends on the input data so far?\n+\n+- the number of iterations of the while *g &ne; 0* loop in `modinv`\n+- the branches inside `divsteps_n_matrix`\n+- the sign checks in `update_de`\n+- the sign checks in `normalize`\n+\n+To make the while loop in `modinv` constant time it can be replaced with a constant number of\n+iterations. The paper proves (Theorem 11.2) that *741* divsteps are sufficient for any *256*-bit\n+inputs, and [safegcd-bounds](https://github.com/sipa/safegcd-bounds) shows that the slightly better bound *724* is\n+sufficient even. Given that every loop iteration performs *N* divsteps, it will run a total of\n+*&lceil;724/N&rceil;* times.\n+\n+To deal with the branches in `divsteps_n_matrix` we will replace them with constant-time bitwise\n+operations (and hope the C compiler isn't smart enough to turn them back into branches; see\n+`valgrind_ctime_test.c` for automated tests that this isn't the case). To do so, observe that a\n+divstep can be written instead as (compare to the inner loop of `gcd` in section 1).\n+\n+```python\n+    x = -f if delta > 0 else f         # set x equal to (input) -f or f\n+    if g & 1:\n+        g += x                         # set g to (input) g-f or g+f\n+        if delta > 0:\n+            delta = -delta\n+            f += g                     # set f to (input) g (note that g was set to g-f before)\n+    delta += 1\n+    g >>= 1\n+```\n+\n+To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the\n+definition of negative numbers in two's complement, (*-v == ~v + 1*) holds for every number *v*. As\n+*-1* in two's complement is all *1* bits, bitflipping can be expressed as xor with *-1*. It follows\n+that *-v == (v ^ -1) - (-1)*. Thus, if we have a variable *c* that takes on values *0* or *-1*, then\n+*(v ^ c) - c* is *v* if *c=0* and *-v* if *c=-1*.\n+\n+Using this we can write:\n+\n+```python\n+    x = -f if delta > 0 else f\n+```\n+\n+in constant-time form as:\n+\n+```python\n+    c1 = (-delta) >> 63\n+    # Conditionally negate f based on c1:\n+    x = (f ^ c1) - c1\n+```\n+\n+To use that trick, we need a helper mask variable *c1* that resolves the condition *&delta;>0* to *-1*\n+(if true) or *0* (if false). We compute *c1* using right shifting, which is equivalent to dividing by\n+the specified power of *2* and rounding down (in Python, and also in C under the assumption of a typical two's complement system; see\n+`assumptions.h` for tests that this is the case). Right shifting by *63* thus maps all\n+numbers in range *[-2<sup>63</sup>,0)* to *-1*, and numbers in range *[0,2<sup>63</sup>)* to *0*.\n+\n+Using the facts that *x&0=0* and *x&(-1)=x* (on two's complement systems again), we can write:\n+\n+```python\n+    if g & 1:\n+        g += x\n+```\n+\n+as:\n+\n+```python\n+    # Compute c2=0 if g is even and c2=-1 if g is odd.\n+    c2 = -(g & 1)\n+    # This masks out x if g is even, and leaves x be if g is odd.\n+    g += x & c2\n+```\n+\n+Using the conditional negation trick again we can write:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            delta = -delta\n+```\n+\n+as:\n+\n+```python\n+    # Compute c3=-1 if g is odd and delta>0, and 0 otherwise.\n+    c3 = c1 & c2\n+    # Conditionally negate delta based on c3:\n+    delta = (delta ^ c3) - c3\n+```\n+\n+Finally:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            f += g\n+```\n+\n+becomes:\n+\n+```python\n+    f += g & c3\n+```\n+\n+It turns out that this can be implemented more efficiently by applying the substitution\n+*&eta;=-&delta;*. In this representation, negating *&delta;* corresponds to negating *&eta;*, and incrementing\n+*&delta;* corresponds to decrementing *&eta;*. This allows us to remove the negation in the *c1*\n+computation:\n+\n+```python\n+    # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+    c1 = eta >> 63\n+    x = (f ^ c1) - c1\n+    # Compute a mask c2 for odd g, and conditionally add x to g:\n+    c2 = -(g & 1)\n+    g += x & c2\n+    # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+    # and add g to f:\n+    c3 = c1 & c2\n+    eta = (eta ^ c3) - c3\n+    f += g & c3\n+    # Incrementing delta corresponds to decrementing eta.\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+A variant of divsteps with better worst-case performance can be used instead: starting *&delta;* at\n+*1/2* instead of *1*. This reduces the worst case number of iterations to *590* for *256*-bit inputs\n+(which can be shown using convex hull analysis). In this case, the substitution *&zeta;=-(&delta;+1/2)*\n+is used instead to keep the variable integral. Incrementing *&delta;* by *1* still translates to\n+decrementing *&zeta;* by *1*, but negating *&delta;* now corresponds to going from *&zeta;* to *-(&zeta;+1)*, or\n+*~&zeta;*. Doing that conditionally based on *c3* is simply:\n+\n+```python\n+    ...\n+    c3 = c1 & c2\n+    zeta ^= c3\n+    ...\n+```\n+\n+By replacing the loop in `divsteps_n_matrix` with a variant of the divstep code above (extended to\n+also apply all *f* operations to *u*, *v* and all *g* operations to *q*, *r*), a constant-time version of\n+`divsteps_n_matrix` is obtained. The full code will be in section 7.\n+\n+These bit fiddling tricks can also be used to make the conditional negations and additions in\n+`update_de` and `normalize` constant-time.\n+\n+\n+## 6. Variable-time optimizations\n+\n+In section 5, we modified the `divsteps_n_matrix` function (and a few others) to be constant time.\n+Constant time operations are only necessary when computing modular inverses of secret data. In\n+other cases, it slows down calculations unnecessarily. In this section, we will construct a\n+faster non-constant time `divsteps_n_matrix` function.\n+\n+To do so, first consider yet another way of writing the inner loop of divstep operations in\n+`gcd` from section 1. This decomposition is also explained in the paper in section 8.2. We use\n+the original version with initial *&delta;=1* and *&eta;=-&delta;* here.\n+\n+```python\n+for _ in range(N):\n+    if g & 1 and eta < 0:\n+        eta, f, g = -eta, g, -f\n+    if g & 1:\n+        g += f\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+Whenever *g* is even, the loop only shifts *g* down and decreases *&eta;*. When *g* ends in multiple zero\n+bits, these iterations can be consolidated into one step. This requires counting the bottom zero\n+bits efficiently, which is possible on most platforms; it is abstracted here as the function\n+`count_trailing_zeros`.\n+\n+```python\n+def count_trailing_zeros(v):\n+    \"\"\"For a non-zero value v, find z such that v=(d<<z) for some odd d.\"\"\"\n+    return (v & -v).bit_length() - 1\n+\n+i = N # divsteps left to do\n+while True:\n+    # Get rid of all bottom zeros at once. In the first iteration, g may be odd and the following\n+    # lines have no effect (until \"if eta < 0\").\n+    zeros = min(i, count_trailing_zeros(g))\n+    eta -= zeros\n+    g >>= zeros\n+    i -= zeros\n+    if i == 0:\n+        break\n+    # We know g is odd now\n+    if eta < 0:\n+        eta, f, g = -eta, g, -f\n+    g += f\n+    # g is even now, and the eta decrement and g shift will happen in the next loop.\n+```\n+\n+We can now remove multiple bottom *0* bits from *g* at once, but still need a full iteration whenever\n+there is a bottom *1* bit. In what follows, we will get rid of multiple *1* bits simultaneously as\n+well.\n+\n+Observe that as long as *&eta; &geq; 0*, the loop does not modify *f*. Instead, it cancels out bottom\n+bits of *g* and shifts them out, and decreases *&eta;* and *i* accordingly - interrupting only when *&eta;*\n+becomes negative, or when *i* reaches *0*. Combined, this is equivalent to adding a multiple of *f* to\n+*g* to cancel out multiple bottom bits, and then shifting them out.\n+\n+It is easy to find what that multiple is: we want a number *w* such that *g+w&thinsp;f* has a few bottom\n+zero bits. If that number of bits is *L*, we want *g+w&thinsp;f mod 2<sup>L</sup> = 0*, or *w = -g/f mod 2<sup>L</sup>*. Since *f*\n+is odd, such a *w* exists for any *L*. *L* cannot be more than *i* steps (as we'd finish the loop before\n+doing more) or more than *&eta;+1* steps (as we'd run `eta, f, g = -eta, g, f` at that point), but\n+apart from that, we're only limited by the complexity of computing *w*.\n+\n+This code demonstrates how to cancel up to 4 bits per step:\n+\n+```python\n+NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+i = N\n+while True:\n+    zeros = min(i, count_trailing_zeros(g))\n+    eta -= zeros\n+    g >>= zeros\n+    i -= zeros\n+    if i == 0:\n+        break\n+    # We know g is odd now\n+    if eta < 0:\n+        eta, f, g = -eta, g, f\n+    # Compute limit on number of bits to cancel\n+    limit = min(min(eta + 1, i), 4)\n+    # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+    # always odd, so its inverse modulo a power of two always exists.\n+    w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+    # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+    g += w * f\n+    assert g % (2**limit) == 0\n+    # The next iteration will now shift out at least limit bottom zero bits from g.\n+```\n+\n+By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+as a formula. Several formulas are known for computing modular inverses modulo powers of two;\n+some can be found in Hacker's Delight second edition by Henry S. Warren, Jr. pages 245-247.\n+Here we need the negated modular inverse, which is a simple transformation of those:\n+\n+- Instead of a 3-bit table:\n+  - *-f* or *f ^ 6*\n+- Instead of a 4-bit table:\n+  - *1 - f(f + 1)*\n+  - *-(f + (((f + 1) & 4) << 1))*\n+- For larger tables the following technique can be used: if *w=-1/f mod 2<sup>L</sup>*, then *w(w&thinsp;f+2)* is\n+  *-1/f mod 2<sup>2L</sup>*. This allows extending the previous formulas (or tables). In particular we\n+  have this 6-bit function (based on the 3-bit function above):\n+  - *f(f<sup>2</sup> - 2)*\n+\n+This loop, again extended to also handle *u*, *v*, *q*, and *r* alongside *f* and *g*, placed in\n+`divsteps_n_matrix`, gives a significantly faster, but non-constant time version.\n+\n+\n+## 7. Final Python version\n+\n+All together we need the following functions:\n+\n+- A way to compute the transition matrix in constant time, using the `divsteps_n_matrix` function\n+  from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+  section 5, extended to handle *u*, *v*, *q*, *r*:\n+\n+```python\n+def divsteps_n_matrix(zeta, f, g):\n+    \"\"\"Compute zeta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        c1 = zeta >> 63\n+        # Compute x, y, z as conditionally-negated versions of f, u, v.\n+        x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+        c2 = -(g & 1)\n+        # Conditionally add x, y, z to g, q, r.\n+        g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+        c1 &= c2                     # reusing c1 here for the earlier c3 variable\n+        zeta = (zeta ^ c1) - 1       # inlining the unconditional zeta decrement here\n+        # Conditionally add g, q, r to f, u, v.\n+        f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+        # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+        # by 2^N. Instead, shift f's coefficients u and v up.\n+        g, u, v = g >> 1, u << 1, v << 1\n+    return zeta, (u, v, q, r)\n+```\n+\n+- The functions to update *f* and *g*, and *d* and *e*, from section 2 and section 4, with the constant-time\n+  changes to `update_de` from section 5:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    return cf >> N, cg >> N\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    d_sign, e_sign = d >> 257, e >> 257\n+    md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    cd, ce = u*d + v*e + M*md, q*d + r*e + M*me\n+    return cd >> N, ce >> N\n+```\n+\n+- The `normalize` function from section 4, made constant time as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+    v_sign = v >> 257\n+    # Conditionally add M to v.\n+    v += M & v_sign\n+    c = (sign - 1) >> 1\n+    # Conditionally negate v.\n+    v = (v ^ c) - c\n+    v_sign = v >> 257\n+    # Conditionally add M to v again.\n+    v += M & v_sign\n+    return v\n+```\n+\n+- And finally the `modinv` function too, adapted to use *&zeta;* instead of *&delta;*, and using the fixed\n+  iteration count from section 5:\n+\n+```python\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    zeta, f, g, d, e = -1, M, x, 0, 1\n+    for _ in range((590 + N - 1) // N):\n+        zeta, t = divsteps_n_matrix(zeta, f % 2**N, g % 2**N)\n+        f, g = update_fg(f, g, t)\n+        d, e = update_de(d, e, t, M, Mi)\n+    return normalize(f, d, M)\n+```\n+\n+- To get a variable time version, replace the `divsteps_n_matrix` function with one that uses the\n+  divsteps loop from section 5, and a `modinv` version that calls it without the fixed iteration\n+  count:\n+\n+```python\n+NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+def divsteps_n_matrix_var(eta, f, g):\n+    \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1\n+    i = N\n+    while True:\n+        zeros = min(i, count_trailing_zeros(g))\n+        eta, i = eta - zeros, i - zeros\n+        g, u, v = g >> zeros, u << zeros, v << zeros\n+        if i == 0:\n+            break\n+        if eta < 0:\n+            eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+        limit = min(min(eta + 1, i), 4)\n+        w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+        g, q, r = g + w*f, q + w*u, r + w*v\n+    return eta, (u, v, q, r)\n+\n+def modinv_var(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    eta, f, g, d, e = -1, M, x, 0, 1\n+    while g != 0:\n+        eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+        f, g = update_fg(f, g, t)\n+        d, e = update_de(d, e, t, M, Mi)\n+    return normalize(f, d, Mi)\n+```"
      },
      {
        "sha": "d368488af21c4fc435b63b4dbcb7220aecb1d71c",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 27,
        "deletions": 20,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -11,7 +11,7 @@ extern \"C\" {\n  *\n  * 1. Context pointers go first, followed by output arguments, combined\n  *    output/input arguments, and finally input-only arguments.\n- * 2. Array lengths always immediately the follow the argument whose length\n+ * 2. Array lengths always immediately follow the argument whose length\n  *    they describe, even if this violates rule 1.\n  * 3. Within the OUT/OUTIN/IN groups, pointers to data that is typically generated\n  *    later go first. This means: signatures, public nonces, secret nonces,\n@@ -452,7 +452,14 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n  *           0: incorrect or unparseable signature\n  *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n  *  In:      sig:       the signature being verified (cannot be NULL)\n- *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n+ *           msghash32: the 32-byte message hash being verified (cannot be NULL).\n+ *                      The verifier must make sure to apply a cryptographic\n+ *                      hash function to the message by itself and not accept an\n+ *                      msghash32 value directly. Otherwise, it would be easy to\n+ *                      create a \"valid\" signature without knowledge of the\n+ *                      secret key. See also\n+ *                      https://bitcoin.stackexchange.com/a/81116/35586 for more\n+ *                      background on this topic.\n  *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)\n  *\n  * To avoid accepting malleable signatures, only ECDSA signatures in lower-S\n@@ -467,7 +474,7 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n     const secp256k1_context* ctx,\n     const secp256k1_ecdsa_signature *sig,\n-    const unsigned char *msg32,\n+    const unsigned char *msghash32,\n     const secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n@@ -532,20 +539,20 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n+ *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n+ *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n+ *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n  *\n  * The created signature is always in lower-S form. See\n  * secp256k1_ecdsa_signature_normalize for more details.\n  */\n SECP256K1_API int secp256k1_ecdsa_sign(\n     const secp256k1_context* ctx,\n     secp256k1_ecdsa_signature *sig,\n-    const unsigned char *msg32,\n+    const unsigned char *msghash32,\n     const unsigned char *seckey,\n     secp256k1_nonce_function noncefp,\n     const void *ndata\n@@ -626,23 +633,23 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n  *                  value if this function returns 0. (cannot be NULL)\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Same as secp256k1_ec_seckey_tweak_add, but DEPRECATED. Will be removed in\n  *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by adding tweak times the generator to it.\n@@ -654,15 +661,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n  *                  (cannot be NULL).\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n  *                  invalid value if this function returns 0 (cannot be NULL).\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a secret key by multiplying it by a tweak.\n@@ -673,23 +680,23 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n  *                  value if this function returns 0. (cannot be NULL)\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Same as secp256k1_ec_seckey_tweak_mul, but DEPRECATED. Will be removed in\n  *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by multiplying it by a tweak value.\n@@ -699,15 +706,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *                  (cannot be NULL).\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n  *                  invalid value if this function returns 0 (cannot be NULL).\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Updates the context randomization to protect against side-channel leakage."
      },
      {
        "sha": "6fc7b290f8cae62afaaf9e81b60ecc29a9341186",
        "filename": "include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_extrakeys.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -165,6 +165,19 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Get the secret key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: seckey: pointer to a 32-byte buffer for the secret key (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Get the public key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise."
      },
      {
        "sha": "aa16532ce86146ae202f2179cf4c69693b139ef4",
        "filename": "include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_recovery.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -71,17 +71,17 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n+ *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n+ *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n+ *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n  */\n SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n     const secp256k1_context* ctx,\n     secp256k1_ecdsa_recoverable_signature *sig,\n-    const unsigned char *msg32,\n+    const unsigned char *msghash32,\n     const unsigned char *seckey,\n     secp256k1_nonce_function noncefp,\n     const void *ndata\n@@ -91,16 +91,16 @@ SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n  *\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  Args:    ctx:        pointer to a context object, initialized for verification (cannot be NULL)\n- *  Out:     pubkey:     pointer to the recovered public key (cannot be NULL)\n- *  In:      sig:        pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n- *           msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for verification (cannot be NULL)\n+ *  Out:     pubkey:    pointer to the recovered public key (cannot be NULL)\n+ *  In:      sig:       pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n+ *           msghash32: the 32-byte message hash assumed to be signed (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n     const secp256k1_ecdsa_recoverable_signature *sig,\n-    const unsigned char *msg32\n+    const unsigned char *msghash32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n #ifdef __cplusplus"
      },
      {
        "sha": "01d15dcdeac56e11bc80c151a7b548ce74eb44d8",
        "filename": "sage/gen_exhaustive_groups.sage",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/gen_exhaustive_groups.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/gen_exhaustive_groups.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/gen_exhaustive_groups.sage?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,9 +1,4 @@\n-# Define field size and field\n-P = 2^256 - 2^32 - 977\n-F = GF(P)\n-BETA = F(0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee)\n-\n-assert(BETA != F(1) and BETA^3 == F(1))\n+load(\"secp256k1_params.sage\")\n \n orders_done = set()\n results = {}"
      },
      {
        "sha": "7d4359e0f6482f51994e5bae84fd2d5ca5d161ef",
        "filename": "sage/gen_split_lambda_constants.sage",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/gen_split_lambda_constants.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/gen_split_lambda_constants.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/gen_split_lambda_constants.sage?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,114 @@\n+\"\"\" Generates the constants used in secp256k1_scalar_split_lambda.\n+\n+See the comments for secp256k1_scalar_split_lambda in src/scalar_impl.h for detailed explanations.\n+\"\"\"\n+\n+load(\"secp256k1_params.sage\")\n+\n+def inf_norm(v):\n+    \"\"\"Returns the infinity norm of a vector.\"\"\"\n+    return max(map(abs, v))\n+\n+def gauss_reduction(i1, i2):\n+    v1, v2 = i1.copy(), i2.copy()\n+    while True:\n+        if inf_norm(v2) < inf_norm(v1):\n+            v1, v2 = v2, v1\n+        # This is essentially\n+        #    m = round((v1[0]*v2[0] + v1[1]*v2[1]) / (inf_norm(v1)**2))\n+        # (rounding to the nearest integer) without relying on floating point arithmetic.\n+        m = ((v1[0]*v2[0] + v1[1]*v2[1]) + (inf_norm(v1)**2) // 2) // (inf_norm(v1)**2)\n+        if m == 0:\n+            return v1, v2\n+        v2[0] -= m*v1[0]\n+        v2[1] -= m*v1[1]\n+\n+def find_split_constants_gauss():\n+    \"\"\"Find constants for secp256k1_scalar_split_lamdba using gauss reduction.\"\"\"\n+    (v11, v12), (v21, v22) = gauss_reduction([0, N], [1, int(LAMBDA)])\n+\n+    # We use related vectors in secp256k1_scalar_split_lambda.\n+    A1, B1 = -v21, -v11\n+    A2, B2 = v22, -v21\n+\n+    return A1, B1, A2, B2\n+\n+def find_split_constants_explicit_tof():\n+    \"\"\"Find constants for secp256k1_scalar_split_lamdba using the trace of Frobenius.\n+\n+    See Benjamin Smith: \"Easy scalar decompositions for efficient scalar multiplication on\n+    elliptic curves and genus 2 Jacobians\" (https://eprint.iacr.org/2013/672), Example 2\n+    \"\"\"\n+    assert P % 3 == 1 # The paper says P % 3 == 2 but that appears to be a mistake, see [10].\n+    assert C.j_invariant() == 0\n+\n+    t = C.trace_of_frobenius()\n+\n+    c = Integer(sqrt((4*P - t**2)/3))\n+    A1 = Integer((t - c)/2 - 1)\n+    B1 = c\n+\n+    A2 = Integer((t + c)/2 - 1)\n+    B2 = Integer(1 - (t - c)/2)\n+\n+    # We use a negated b values in secp256k1_scalar_split_lambda.\n+    B1, B2 = -B1, -B2\n+\n+    return A1, B1, A2, B2\n+\n+A1, B1, A2, B2 = find_split_constants_explicit_tof()\n+\n+# For extra fun, use an independent method to recompute the constants.\n+assert (A1, B1, A2, B2) == find_split_constants_gauss()\n+\n+# PHI : Z[l] -> Z_n where phi(a + b*l) == a + b*lambda mod n.\n+def PHI(a,b):\n+    return Z(a + LAMBDA*b)\n+\n+# Check that (A1, B1) and (A2, B2) are in the kernel of PHI.\n+assert PHI(A1, B1) == Z(0)\n+assert PHI(A2, B2) == Z(0)\n+\n+# Check that the parallelogram generated by (A1, A2) and (B1, B2)\n+# is a fundamental domain by containing exactly N points.\n+# Since the LHS is the determinant and N != 0, this also checks that\n+# (A1, A2) and (B1, B2) are linearly independent. By the previous\n+# assertions, (A1, A2) and (B1, B2) are a basis of the kernel.\n+assert A1*B2 - B1*A2 == N\n+\n+# Check that their components are short enough.\n+assert (A1 + A2)/2 < sqrt(N)\n+assert B1 < sqrt(N)\n+assert B2 < sqrt(N)\n+\n+G1 = round((2**384)*B2/N)\n+G2 = round((2**384)*(-B1)/N)\n+\n+def rnddiv2(v):\n+    if v & 1:\n+        v += 1\n+    return v >> 1\n+\n+def scalar_lambda_split(k):\n+    \"\"\"Equivalent to secp256k1_scalar_lambda_split().\"\"\"\n+    c1 = rnddiv2((k * G1) >> 383)\n+    c2 = rnddiv2((k * G2) >> 383)\n+    c1 = (c1 * -B1) % N\n+    c2 = (c2 * -B2) % N\n+    r2 = (c1 + c2) % N\n+    r1 = (k + r2 * -LAMBDA) % N\n+    return (r1, r2)\n+\n+# The result of scalar_lambda_split can depend on the representation of k (mod n).\n+SPECIAL = (2**383) // G2 + 1\n+assert scalar_lambda_split(SPECIAL) != scalar_lambda_split(SPECIAL + N)\n+\n+print('  A1     =', hex(A1))\n+print(' -B1     =', hex(-B1))\n+print('  A2     =', hex(A2))\n+print(' -B2     =', hex(-B2))\n+print('         =', hex(Z(-B2)))\n+print(' -LAMBDA =', hex(-LAMBDA))\n+\n+print('  G1     =', hex(G1))\n+print('  G2     =', hex(G2))"
      },
      {
        "sha": "b200bfeae3d1c6c32fd3fc7de6160ebc6bbb12e9",
        "filename": "sage/group_prover.sage",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/group_prover.sage?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -42,7 +42,7 @@\n #     as we assume that all constraints in it are complementary with each other.\n #\n # Based on the sage verification scripts used in the Explicit-Formulas Database\n-# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+# by Tanja Lange and others, see https://hyperelliptic.org/EFD\n \n class fastfrac:\n   \"\"\"Fractions over rings.\"\"\"\n@@ -65,7 +65,7 @@ class fastfrac:\n     return self.top in I and self.bot not in I\n \n   def reduce(self,assumeZero):\n-    zero = self.R.ideal(map(numerator, assumeZero))\n+    zero = self.R.ideal(list(map(numerator, assumeZero)))\n     return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n \n   def __add__(self,other):\n@@ -100,14 +100,19 @@ class fastfrac:\n     \"\"\"Multiply something else with a fraction.\"\"\"\n     return self.__mul__(other)\n \n-  def __div__(self,other):\n+  def __truediv__(self,other):\n     \"\"\"Divide two fractions.\"\"\"\n     if parent(other) == ZZ:\n       return fastfrac(self.R,self.top,self.bot * other)\n     if other.__class__ == fastfrac:\n       return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n     return NotImplemented\n \n+  # Compatibility wrapper for Sage versions based on Python 2\n+  def __div__(self,other):\n+     \"\"\"Divide two fractions.\"\"\"\n+     return self.__truediv__(other)\n+\n   def __pow__(self,other):\n     \"\"\"Compute a power of a fraction.\"\"\"\n     if parent(other) == ZZ:\n@@ -175,7 +180,7 @@ class constraints:\n \n def conflicts(R, con):\n   \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n-  zero = R.ideal(map(numerator, con.zero))\n+  zero = R.ideal(list(map(numerator, con.zero)))\n   if 1 in zero:\n     return True\n   # First a cheap check whether any of the individual nonzero terms conflict on\n@@ -195,7 +200,7 @@ def conflicts(R, con):\n \n def get_nonzero_set(R, assume):\n   \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n-  zero = R.ideal(map(numerator, assume.zero))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n   nonzero = set()\n   for nz in map(numerator, assume.nonzero):\n     for (f,n) in nz.factor():\n@@ -208,7 +213,7 @@ def get_nonzero_set(R, assume):\n \n def prove_nonzero(R, exprs, assume):\n   \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n-  zero = R.ideal(map(numerator, assume.zero))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n   nonzero = get_nonzero_set(R, assume)\n   expl = set()\n   ok = True\n@@ -250,7 +255,7 @@ def prove_zero(R, exprs, assume):\n   r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n   if not r:\n     return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n-  zero = R.ideal(map(numerator, assume.zero))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n   nonzero = prod(x for x in assume.nonzero)\n   expl = []\n   for expr in exprs:\n@@ -265,8 +270,8 @@ def describe_extra(R, assume, assumeExtra):\n   \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n   zerox = assume.zero.copy()\n   zerox.update(assumeExtra.zero)\n-  zero = R.ideal(map(numerator, assume.zero))\n-  zeroextra = R.ideal(map(numerator, zerox))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n+  zeroextra = R.ideal(list(map(numerator, zerox)))\n   nonzero = get_nonzero_set(R, assume)\n   ret = set()\n   # Iterate over the extra zero expressions"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "sage/prove_group_implementations.sage",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/prove_group_implementations.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/prove_group_implementations.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/prove_group_implementations.sage?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "previous_filename": "sage/secp256k1.sage"
      },
      {
        "sha": "4e000726ed36646a63cedb124aeae618bf5fa149",
        "filename": "sage/secp256k1_params.sage",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/secp256k1_params.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/secp256k1_params.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/secp256k1_params.sage?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,36 @@\n+\"\"\"Prime order of finite field underlying secp256k1 (2^256 - 2^32 - 977)\"\"\"\n+P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n+\n+\"\"\"Finite field underlying secp256k1\"\"\"\n+F = FiniteField(P)\n+\n+\"\"\"Elliptic curve secp256k1: y^2 = x^3 + 7\"\"\"\n+C = EllipticCurve([F(0), F(7)])\n+\n+\"\"\"Base point of secp256k1\"\"\"\n+G = C.lift_x(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798)\n+\n+\"\"\"Prime order of secp256k1\"\"\"\n+N = C.order()\n+\n+\"\"\"Finite field of scalars of secp256k1\"\"\"\n+Z = FiniteField(N)\n+\n+\"\"\" Beta value of secp256k1 non-trivial endomorphism: lambda * (x, y) = (beta * x, y)\"\"\"\n+BETA = F(2)^((P-1)/3)\n+\n+\"\"\" Lambda value of secp256k1 non-trivial endomorphism: lambda * (x, y) = (beta * x, y)\"\"\"\n+LAMBDA = Z(3)^((N-1)/3)\n+\n+assert is_prime(P)\n+assert is_prime(N)\n+\n+assert BETA != F(1)\n+assert BETA^3 == F(1)\n+assert BETA^2 + BETA + 1 == 0\n+\n+assert LAMBDA != Z(1)\n+assert LAMBDA^3 == Z(1)\n+assert LAMBDA^2 + LAMBDA + 1 == 0\n+\n+assert Integer(LAMBDA)*G == C(BETA*G[0], G[1])"
      },
      {
        "sha": "b770c6dafe2f024d089848dfd8351b599f4193aa",
        "filename": "sage/weierstrass_prover.sage",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/weierstrass_prover.sage?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -175,24 +175,24 @@ laws_jacobian_weierstrass = {\n def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n   \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n   F = Integers(p)\n-  print \"Formula %s on Z%i:\" % (name, p)\n+  print(\"Formula %s on Z%i:\" % (name, p))\n   points = []\n-  for x in xrange(0, p):\n-    for y in xrange(0, p):\n+  for x in range(0, p):\n+    for y in range(0, p):\n       point = affinepoint(F(x), F(y))\n       r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n       if r:\n         points.append(point)\n \n-  for za in xrange(1, p):\n-    for zb in xrange(1, p):\n+  for za in range(1, p):\n+    for zb in range(1, p):\n       for pa in points:\n         for pb in points:\n-          for ia in xrange(2):\n-            for ib in xrange(2):\n+          for ia in range(2):\n+            for ib in range(2):\n               pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n               pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n-              for branch in xrange(0, branches):\n+              for branch in range(0, branches):\n                 assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n                 pC.X = F(pC.X)\n                 pC.Y = F(pC.Y)\n@@ -206,13 +206,13 @@ def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n                     r, e = concrete_verify(assumeLaw)\n                     if r:\n                       if match:\n-                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                        print(\"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity))\n                       else:\n                         match = True\n                       r, e = concrete_verify(require)\n                       if not r:\n-                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n-  print\n+                        print(\"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e))\n+  print()\n \n \n def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n@@ -242,9 +242,9 @@ def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n   for key in laws_jacobian_weierstrass:\n     res[key] = []\n \n-  print (\"Formula \" + name + \":\")\n+  print(\"Formula \" + name + \":\")\n   count = 0\n-  for branch in xrange(branches):\n+  for branch in range(branches):\n     assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n     pC.X = lift(pC.X)\n     pC.Y = lift(pC.Y)\n@@ -255,10 +255,10 @@ def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n       res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n \n   for key in res:\n-    print \"  %s:\" % key\n+    print(\"  %s:\" % key)\n     val = res[key]\n     for x in val:\n       if x[0] is not None:\n-        print \"    branch %i: %s\" % (x[1], x[0])\n+        print(\"    branch %i: %s\" % (x[1], x[0]))\n \n-  print\n+  print()"
      },
      {
        "sha": "5f68cefc46cde0e8e5a110dd5909d9bc4e7a5950",
        "filename": "src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/asm/field_10x26_arm.s?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,9 +1,9 @@\n @ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n-/**********************************************************************\n- * Copyright (c) 2014 Wladimir J. van der Laan                        *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n /*\n ARM implementation of field_10x26 inner loops.\n "
      },
      {
        "sha": "6dc527b288939b9a8766f6af8a35def337c206d6",
        "filename": "src/assumptions.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/assumptions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/assumptions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/assumptions.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ASSUMPTIONS_H\n #define SECP256K1_ASSUMPTIONS_H"
      },
      {
        "sha": "6f7693cb8fd046a8b10ff22d6d97d8bb4a002053",
        "filename": "src/basic-config.h",
        "status": "modified",
        "additions": 6,
        "deletions": 23,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/basic-config.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,33 +1,16 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_BASIC_CONFIG_H\n #define SECP256K1_BASIC_CONFIG_H\n \n #ifdef USE_BASIC_CONFIG\n \n-#undef USE_ASM_X86_64\n-#undef USE_ECMULT_STATIC_PRECOMPUTATION\n-#undef USE_EXTERNAL_ASM\n-#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n-#undef USE_FIELD_INV_BUILTIN\n-#undef USE_FIELD_INV_NUM\n-#undef USE_NUM_GMP\n-#undef USE_NUM_NONE\n-#undef USE_SCALAR_INV_BUILTIN\n-#undef USE_SCALAR_INV_NUM\n-#undef USE_FORCE_WIDEMUL_INT64\n-#undef USE_FORCE_WIDEMUL_INT128\n-#undef ECMULT_WINDOW_SIZE\n-\n-#define USE_NUM_NONE 1\n-#define USE_FIELD_INV_BUILTIN 1\n-#define USE_SCALAR_INV_BUILTIN 1\n-#define USE_WIDEMUL_64 1\n #define ECMULT_WINDOW_SIZE 15\n+#define ECMULT_GEN_PREC_BITS 4\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "63c55df44d05954e2db3138f7879c42a7dfb2897",
        "filename": "src/bench.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_BENCH_H\n #define SECP256K1_BENCH_H"
      },
      {
        "sha": "ab4b8f4244f2b54539b0f4a5d5caf2cfd33a4055",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                  *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                   *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n "
      },
      {
        "sha": "204e85a5dde134360af66a0d2badfce953009029",
        "filename": "src/bench_ecmult.c",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,15 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2017 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2017 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n #include <stdio.h>\n \n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n #include \"hash_impl.h\"\n-#include \"num_impl.h\"\n #include \"field_impl.h\"\n #include \"group_impl.h\"\n #include \"scalar_impl.h\""
      },
      {
        "sha": "73b8a24ccbfaf6e4b432728248624f332a7adef3",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 11,
        "deletions": 62,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,16 +1,15 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n #include <stdio.h>\n \n #include \"include/secp256k1.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n #include \"hash_impl.h\"\n-#include \"num_impl.h\"\n #include \"field_impl.h\"\n #include \"group_impl.h\"\n #include \"scalar_impl.h\"\n@@ -99,15 +98,6 @@ void bench_scalar_negate(void* arg, int iters) {\n     }\n }\n \n-void bench_scalar_sqr(void* arg, int iters) {\n-    int i;\n-    bench_inv *data = (bench_inv*)arg;\n-\n-    for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_sqr(&data->scalar[0], &data->scalar[0]);\n-    }\n-}\n-\n void bench_scalar_mul(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n@@ -255,35 +245,17 @@ void bench_group_add_affine_var(void* arg, int iters) {\n     }\n }\n \n-void bench_group_jacobi_var(void* arg, int iters) {\n-    int i, j = 0;\n-    bench_inv *data = (bench_inv*)arg;\n-\n-    for (i = 0; i < iters; i++) {\n-        j += secp256k1_gej_has_quad_y_var(&data->gej[0]);\n-        /* Vary the Y and Z coordinates of the input (the X coordinate doesn't matter to\n-           secp256k1_gej_has_quad_y_var). Note that the resulting coordinates will\n-           generally not correspond to a point on the curve, but this is not a problem\n-           for the code being benchmarked here. Adding and normalizing have less\n-           overhead than EC operations (which could guarantee the point remains on the\n-           curve). */\n-        secp256k1_fe_add(&data->gej[0].y, &data->fe[1]);\n-        secp256k1_fe_add(&data->gej[0].z, &data->fe[2]);\n-        secp256k1_fe_normalize_var(&data->gej[0].y);\n-        secp256k1_fe_normalize_var(&data->gej[0].z);\n-    }\n-    CHECK(j <= iters);\n-}\n-\n void bench_group_to_affine_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; ++i) {\n         secp256k1_ge_set_gej_var(&data->ge[1], &data->gej[0]);\n         /* Use the output affine X/Y coordinates to vary the input X/Y/Z coordinates.\n-           Similar to bench_group_jacobi_var, this approach does not result in\n-           coordinates of points on the curve. */\n+           Note that the resulting coordinates will generally not correspond to a point\n+           on the curve, but this is not a problem for the code being benchmarked here.\n+           Adding and normalizing have less overhead than EC operations (which could\n+           guarantee the point remains on the curve). */\n         secp256k1_fe_add(&data->gej[0].x, &data->ge[1].y);\n         secp256k1_fe_add(&data->gej[0].y, &data->fe[2]);\n         secp256k1_fe_add(&data->gej[0].z, &data->ge[1].x);\n@@ -369,35 +341,16 @@ void bench_context_sign(void* arg, int iters) {\n     }\n }\n \n-#ifndef USE_NUM_NONE\n-void bench_num_jacobi(void* arg, int iters) {\n-    int i, j = 0;\n-    bench_inv *data = (bench_inv*)arg;\n-    secp256k1_num nx, na, norder;\n-\n-    secp256k1_scalar_get_num(&nx, &data->scalar[0]);\n-    secp256k1_scalar_order_get_num(&norder);\n-    secp256k1_scalar_get_num(&na, &data->scalar[1]);\n-\n-    for (i = 0; i < iters; i++) {\n-        j += secp256k1_num_jacobi(&nx, &norder);\n-        secp256k1_num_add(&nx, &nx, &na);\n-    }\n-    CHECK(j <= iters);\n-}\n-#endif\n-\n int main(int argc, char **argv) {\n     bench_inv data;\n     int iters = get_iters(20000);\n \n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, 2000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, 2000);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n@@ -411,7 +364,6 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n@@ -424,8 +376,5 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n \n-#ifndef USE_NUM_NONE\n-    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, iters*10);\n-#endif\n     return 0;\n }"
      },
      {
        "sha": "3f6270ce84fd5ad497c5a2904b0b8e026838feb4",
        "filename": "src/bench_recover.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_recovery.h\""
      },
      {
        "sha": "f7f591c41dcea51e3219b1eea959dc2958e46dde",
        "filename": "src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_schnorrsig.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                 *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n #include <stdlib.h>"
      },
      {
        "sha": "933f367c4b6a65a03699f31ae61d91e21ca0e370",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n@@ -12,11 +12,11 @@ typedef struct {\n     secp256k1_context* ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n-} bench_sign;\n+} bench_sign_data;\n \n static void bench_sign_setup(void* arg) {\n     int i;\n-    bench_sign *data = (bench_sign*)arg;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n \n     for (i = 0; i < 32; i++) {\n         data->msg[i] = i + 1;\n@@ -28,7 +28,7 @@ static void bench_sign_setup(void* arg) {\n \n static void bench_sign_run(void* arg, int iters) {\n     int i;\n-    bench_sign *data = (bench_sign*)arg;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n \n     unsigned char sig[74];\n     for (i = 0; i < iters; i++) {\n@@ -45,7 +45,7 @@ static void bench_sign_run(void* arg, int iters) {\n }\n \n int main(void) {\n-    bench_sign data;\n+    bench_sign_data data;\n \n     int iters = get_iters(20000);\n "
      },
      {
        "sha": "c56aefd3699c06d6bf5bf4022801387b7762ca64",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <stdio.h>\n #include <string.h>\n@@ -29,11 +29,11 @@ typedef struct {\n #ifdef ENABLE_OPENSSL_TESTS\n     EC_GROUP* ec_group;\n #endif\n-} benchmark_verify_t;\n+} bench_verify_data;\n \n-static void benchmark_verify(void* arg, int iters) {\n+static void bench_verify(void* arg, int iters) {\n     int i;\n-    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+    bench_verify_data* data = (bench_verify_data*)arg;\n \n     for (i = 0; i < iters; i++) {\n         secp256k1_pubkey pubkey;\n@@ -51,9 +51,9 @@ static void benchmark_verify(void* arg, int iters) {\n }\n \n #ifdef ENABLE_OPENSSL_TESTS\n-static void benchmark_verify_openssl(void* arg, int iters) {\n+static void bench_verify_openssl(void* arg, int iters) {\n     int i;\n-    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+    bench_verify_data* data = (bench_verify_data*)arg;\n \n     for (i = 0; i < iters; i++) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n@@ -84,7 +84,7 @@ int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n     secp256k1_ecdsa_signature sig;\n-    benchmark_verify_t data;\n+    bench_verify_data data;\n \n     int iters = get_iters(20000);\n \n@@ -103,10 +103,10 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n-    run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, iters);\n+    run_benchmark(\"ecdsa_verify\", bench_verify, NULL, NULL, &data, 10, iters);\n #ifdef ENABLE_OPENSSL_TESTS\n     data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, iters);\n+    run_benchmark(\"ecdsa_verify_openssl\", bench_verify_openssl, NULL, NULL, &data, 10, iters);\n     EC_GROUP_free(data.ec_group);\n #endif\n "
      },
      {
        "sha": "d5e54d8ce619736930a925eb9bdc6fd47ba6d513",
        "filename": "src/ecdsa.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECDSA_H\n #define SECP256K1_ECDSA_H"
      },
      {
        "sha": "156a33d1128656a00c510093bd3b7105ace7d942",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n \n #ifndef SECP256K1_ECDSA_IMPL_H"
      },
      {
        "sha": "5be3a64b84043cc50cc4e63bdcde8c64fd4fbfc8",
        "filename": "src/eckey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECKEY_H\n #define SECP256K1_ECKEY_H"
      },
      {
        "sha": "a39cb79653c381643de38c9fa69d60b1d2aa3da9",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECKEY_IMPL_H\n #define SECP256K1_ECKEY_IMPL_H"
      },
      {
        "sha": "7ab617e20e4217a2f60de46395e2f7ed842d1dd8",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_H\n #define SECP256K1_ECMULT_H\n \n-#include \"num.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"scratch.h\""
      },
      {
        "sha": "d6f0ea22275a699595f7f62260bf668299cde237",
        "filename": "src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_CONST_H\n #define SECP256K1_ECMULT_CONST_H"
      },
      {
        "sha": "0e1fb965cbdefc9d31b342f87095f83f027413b4",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                  *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                   *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_CONST_IMPL_H\n #define SECP256K1_ECMULT_CONST_IMPL_H"
      },
      {
        "sha": "539618dcbb8722edc40108f72a53002f5b770b82",
        "filename": "src/ecmult_gen.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_GEN_H\n #define SECP256K1_ECMULT_GEN_H"
      },
      {
        "sha": "384a67faeda7a6d4d2eb31af91315a5c8766284d",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n@@ -144,7 +144,7 @@ static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context *ctx, secp25\n              *    (https://cryptojedi.org/peter/data/chesrump-20130822.pdf) and\n              *   \"Cache Attacks and Countermeasures: the Case of AES\", RSA 2006,\n              *    by Dag Arne Osvik, Adi Shamir, and Eran Tromer\n-             *    (http://www.tau.ac.il/~tromer/papers/cache.pdf)\n+             *    (https://www.tau.ac.il/~tromer/papers/cache.pdf)\n              */\n             secp256k1_ge_storage_cmov(&adds, &(*ctx->prec)[j][i], i == bits);\n         }"
      },
      {
        "sha": "5c2edac68fc6926f80335baf3e112b2b9899a2df",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/*****************************************************************************\n- * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick *\n- * Distributed under the MIT software license, see the accompanying          *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.       *\n- *****************************************************************************/\n+/******************************************************************************\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick  *\n+ * Distributed under the MIT software license, see the accompanying           *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.       *\n+ ******************************************************************************/\n \n #ifndef SECP256K1_ECMULT_IMPL_H\n #define SECP256K1_ECMULT_IMPL_H\n@@ -595,11 +595,11 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n     scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n     state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n     state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n-    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n \n-    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL || state.pre_a_lam == NULL || state.ps == NULL) {\n         secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }"
      },
      {
        "sha": "854aaebabc966e506a38707d349130d5c7571a27",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 10,
        "deletions": 19,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_H\n #define SECP256K1_FIELD_H\n@@ -43,13 +43,12 @@ static void secp256k1_fe_normalize_weak(secp256k1_fe *r);\n /** Normalize a field element, without constant-time guarantee. */\n static void secp256k1_fe_normalize_var(secp256k1_fe *r);\n \n-/** Verify whether a field element represents zero i.e. would normalize to a zero value. The field\n- *  implementation may optionally normalize the input, but this should not be relied upon. */\n-static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r);\n+/** Verify whether a field element represents zero i.e. would normalize to a zero value. */\n+static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r);\n \n-/** Verify whether a field element represents zero i.e. would normalize to a zero value. The field\n- *  implementation may optionally normalize the input, but this should not be relied upon. */\n-static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r);\n+/** Verify whether a field element represents zero i.e. would normalize to a zero value,\n+ *  without constant-time guarantee. */\n+static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r);\n \n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n@@ -104,21 +103,13 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  itself. */\n static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n \n-/** Checks whether a field element is a quadratic residue. */\n-static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n-\n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a);\n \n /** Potentially faster version of secp256k1_fe_inv, without constant-time guarantee. */\n static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a);\n \n-/** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n- *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n- *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len);\n-\n /** Convert a field element to the storage type. */\n static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a);\n "
      },
      {
        "sha": "9eb65607f12cb2b86694e0a48dc9ce6f754ddd97",
        "filename": "src/field_10x26.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_10x26.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_10x26.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_H\n #define SECP256K1_FIELD_REPR_H"
      },
      {
        "sha": "7a38c117f194be718e6d8b81920dfa42e2a72e79",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 96,
        "deletions": 7,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,14 +1,15 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_IMPL_H\n #define SECP256K1_FIELD_REPR_IMPL_H\n \n #include \"util.h\"\n #include \"field.h\"\n+#include \"modinv32_impl.h\"\n \n #ifdef VERIFY\n static void secp256k1_fe_verify(const secp256k1_fe *a) {\n@@ -181,7 +182,7 @@ static void secp256k1_fe_normalize_var(secp256k1_fe *r) {\n #endif\n }\n \n-static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r) {\n     uint32_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4],\n              t5 = r->n[5], t6 = r->n[6], t7 = r->n[7], t8 = r->n[8], t9 = r->n[9];\n \n@@ -210,7 +211,7 @@ static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n     return (z0 == 0) | (z1 == 0x3FFFFFFUL);\n }\n \n-static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n     uint32_t t0, t1, t2, t3, t4, t5, t6, t7, t8, t9;\n     uint32_t z0, z1;\n     uint32_t x;\n@@ -1164,4 +1165,92 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #endif\n }\n \n+static void secp256k1_fe_from_signed30(secp256k1_fe *r, const secp256k1_modinv32_signed30 *a) {\n+    const uint32_t M26 = UINT32_MAX >> 6;\n+    const uint32_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4],\n+                   a5 = a->v[5], a6 = a->v[6], a7 = a->v[7], a8 = a->v[8];\n+\n+    /* The output from secp256k1_modinv32{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^30). The modulus is < 2^256, so the top limb must be below 2^(256-30*8).\n+     */\n+    VERIFY_CHECK(a0 >> 30 == 0);\n+    VERIFY_CHECK(a1 >> 30 == 0);\n+    VERIFY_CHECK(a2 >> 30 == 0);\n+    VERIFY_CHECK(a3 >> 30 == 0);\n+    VERIFY_CHECK(a4 >> 30 == 0);\n+    VERIFY_CHECK(a5 >> 30 == 0);\n+    VERIFY_CHECK(a6 >> 30 == 0);\n+    VERIFY_CHECK(a7 >> 30 == 0);\n+    VERIFY_CHECK(a8 >> 16 == 0);\n+\n+    r->n[0] =  a0                   & M26;\n+    r->n[1] = (a0 >> 26 | a1 <<  4) & M26;\n+    r->n[2] = (a1 >> 22 | a2 <<  8) & M26;\n+    r->n[3] = (a2 >> 18 | a3 << 12) & M26;\n+    r->n[4] = (a3 >> 14 | a4 << 16) & M26;\n+    r->n[5] = (a4 >> 10 | a5 << 20) & M26;\n+    r->n[6] = (a5 >>  6 | a6 << 24) & M26;\n+    r->n[7] = (a6 >>  2           ) & M26;\n+    r->n[8] = (a6 >> 28 | a7 <<  2) & M26;\n+    r->n[9] = (a7 >> 24 | a8 <<  6);\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+static void secp256k1_fe_to_signed30(secp256k1_modinv32_signed30 *r, const secp256k1_fe *a) {\n+    const uint32_t M30 = UINT32_MAX >> 2;\n+    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4],\n+                   a5 = a->n[5], a6 = a->n[6], a7 = a->n[7], a8 = a->n[8], a9 = a->n[9];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+#endif\n+\n+    r->v[0] = (a0       | a1 << 26) & M30;\n+    r->v[1] = (a1 >>  4 | a2 << 22) & M30;\n+    r->v[2] = (a2 >>  8 | a3 << 18) & M30;\n+    r->v[3] = (a3 >> 12 | a4 << 14) & M30;\n+    r->v[4] = (a4 >> 16 | a5 << 10) & M30;\n+    r->v[5] = (a5 >> 20 | a6 <<  6) & M30;\n+    r->v[6] = (a6 >> 24 | a7 <<  2\n+                        | a8 << 28) & M30;\n+    r->v[7] = (a8 >>  2 | a9 << 24) & M30;\n+    r->v[8] =  a9 >>  6;\n+}\n+\n+static const secp256k1_modinv32_modinfo secp256k1_const_modinfo_fe = {\n+    {{-0x3D1, -4, 0, 0, 0, 0, 0, 0, 65536}},\n+    0x2DDACACFL\n+};\n+\n+static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv32_signed30 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize(&tmp);\n+    secp256k1_fe_to_signed30(&s, &tmp);\n+    secp256k1_modinv32(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed30(r, &s);\n+\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+}\n+\n+static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv32_signed30 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    secp256k1_fe_to_signed30(&s, &tmp);\n+    secp256k1_modinv32_var(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed30(r, &s);\n+\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "50ee3f9ec96b746b6565ef1655440730802a552d",
        "filename": "src/field_5x52.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_H\n #define SECP256K1_FIELD_REPR_H"
      },
      {
        "sha": "a2118044ab381de4916a87d5accaedb2e1949539",
        "filename": "src/field_5x52_asm_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52_asm_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52_asm_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_asm_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2014 Diederik Huys, Pieter Wuille               *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2014 Diederik Huys, Pieter Wuille                *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n /**\n  * Changelog:"
      },
      {
        "sha": "60ded927f6e834ddb30d46e333abf36918349b8f",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 84,
        "deletions": 7,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_IMPL_H\n #define SECP256K1_FIELD_REPR_IMPL_H\n@@ -13,6 +13,7 @@\n \n #include \"util.h\"\n #include \"field.h\"\n+#include \"modinv64_impl.h\"\n \n #if defined(USE_ASM_X86_64)\n #include \"field_5x52_asm_impl.h\"\n@@ -161,7 +162,7 @@ static void secp256k1_fe_normalize_var(secp256k1_fe *r) {\n #endif\n }\n \n-static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r) {\n     uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];\n \n     /* z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P */\n@@ -184,7 +185,7 @@ static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n     return (z0 == 0) | (z1 == 0xFFFFFFFFFFFFFULL);\n }\n \n-static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n     uint64_t t0, t1, t2, t3, t4;\n     uint64_t z0, z1;\n     uint64_t x;\n@@ -498,4 +499,80 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #endif\n }\n \n+static void secp256k1_fe_from_signed62(secp256k1_fe *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t M52 = UINT64_MAX >> 12;\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n+\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n+\n+    r->n[0] =  a0                   & M52;\n+    r->n[1] = (a0 >> 52 | a1 << 10) & M52;\n+    r->n[2] = (a1 >> 42 | a2 << 20) & M52;\n+    r->n[3] = (a2 >> 32 | a3 << 30) & M52;\n+    r->n[4] = (a3 >> 22 | a4 << 40);\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+static void secp256k1_fe_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_fe *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+#endif\n+\n+    r->v[0] = (a0       | a1 << 52) & M62;\n+    r->v[1] = (a1 >> 10 | a2 << 42) & M62;\n+    r->v[2] = (a2 >> 20 | a3 << 32) & M62;\n+    r->v[3] = (a3 >> 30 | a4 << 22) & M62;\n+    r->v[4] =  a4 >> 40;\n+}\n+\n+static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_fe = {\n+    {{-0x1000003D1LL, 0, 0, 0, 256}},\n+    0x27C7F6E22DDACACFLL\n+};\n+\n+static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize(&tmp);\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+#endif\n+}\n+\n+static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+#endif\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "314002ee3950f1d4fe5b4a30699883c9b4f0e4ea",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_INNER5X52_IMPL_H\n #define SECP256K1_FIELD_INNER5X52_IMPL_H"
      },
      {
        "sha": "374284a1f4ce974cd551fd4e66b9d274381dc043",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 185,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_IMPL_H\n #define SECP256K1_FIELD_IMPL_H\n@@ -12,7 +12,6 @@\n #endif\n \n #include \"util.h\"\n-#include \"num.h\"\n \n #if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52_impl.h\"\n@@ -136,185 +135,6 @@ static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     return secp256k1_fe_equal(&t1, a);\n }\n \n-static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n-    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;\n-    int j;\n-\n-    /** The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n-     *  { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n-     *  [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n-     */\n-\n-    secp256k1_fe_sqr(&x2, a);\n-    secp256k1_fe_mul(&x2, &x2, a);\n-\n-    secp256k1_fe_sqr(&x3, &x2);\n-    secp256k1_fe_mul(&x3, &x3, a);\n-\n-    x6 = x3;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x6, &x6);\n-    }\n-    secp256k1_fe_mul(&x6, &x6, &x3);\n-\n-    x9 = x6;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x9, &x9);\n-    }\n-    secp256k1_fe_mul(&x9, &x9, &x3);\n-\n-    x11 = x9;\n-    for (j=0; j<2; j++) {\n-        secp256k1_fe_sqr(&x11, &x11);\n-    }\n-    secp256k1_fe_mul(&x11, &x11, &x2);\n-\n-    x22 = x11;\n-    for (j=0; j<11; j++) {\n-        secp256k1_fe_sqr(&x22, &x22);\n-    }\n-    secp256k1_fe_mul(&x22, &x22, &x11);\n-\n-    x44 = x22;\n-    for (j=0; j<22; j++) {\n-        secp256k1_fe_sqr(&x44, &x44);\n-    }\n-    secp256k1_fe_mul(&x44, &x44, &x22);\n-\n-    x88 = x44;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x88, &x88);\n-    }\n-    secp256k1_fe_mul(&x88, &x88, &x44);\n-\n-    x176 = x88;\n-    for (j=0; j<88; j++) {\n-        secp256k1_fe_sqr(&x176, &x176);\n-    }\n-    secp256k1_fe_mul(&x176, &x176, &x88);\n-\n-    x220 = x176;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x220, &x220);\n-    }\n-    secp256k1_fe_mul(&x220, &x220, &x44);\n-\n-    x223 = x220;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x223, &x223);\n-    }\n-    secp256k1_fe_mul(&x223, &x223, &x3);\n-\n-    /* The final result is then assembled using a sliding window over the blocks. */\n-\n-    t1 = x223;\n-    for (j=0; j<23; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(&t1, &t1, &x22);\n-    for (j=0; j<5; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(&t1, &t1, a);\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(&t1, &t1, &x2);\n-    for (j=0; j<2; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(r, a, &t1);\n-}\n-\n-static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a) {\n-#if defined(USE_FIELD_INV_BUILTIN)\n-    secp256k1_fe_inv(r, a);\n-#elif defined(USE_FIELD_INV_NUM)\n-    secp256k1_num n, m;\n-    static const secp256k1_fe negone = SECP256K1_FE_CONST(\n-        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n-        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFEUL, 0xFFFFFC2EUL\n-    );\n-    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n-    static const unsigned char prime[32] = {\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n-    };\n-    unsigned char b[32];\n-    int res;\n-    secp256k1_fe c = *a;\n-    secp256k1_fe_normalize_var(&c);\n-    secp256k1_fe_get_b32(b, &c);\n-    secp256k1_num_set_bin(&n, b, 32);\n-    secp256k1_num_set_bin(&m, prime, 32);\n-    secp256k1_num_mod_inverse(&n, &n, &m);\n-    secp256k1_num_get_bin(b, 32, &n);\n-    res = secp256k1_fe_set_b32(r, b);\n-    (void)res;\n-    VERIFY_CHECK(res);\n-    /* Verify the result is the (unique) valid inverse using non-GMP code. */\n-    secp256k1_fe_mul(&c, &c, r);\n-    secp256k1_fe_add(&c, &negone);\n-    CHECK(secp256k1_fe_normalizes_to_zero_var(&c));\n-#else\n-#error \"Please select field inverse implementation\"\n-#endif\n-}\n-\n-static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len) {\n-    secp256k1_fe u;\n-    size_t i;\n-    if (len < 1) {\n-        return;\n-    }\n-\n-    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n-\n-    r[0] = a[0];\n-\n-    i = 0;\n-    while (++i < len) {\n-        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n-    }\n-\n-    secp256k1_fe_inv_var(&u, &r[--i]);\n-\n-    while (i > 0) {\n-        size_t j = i--;\n-        secp256k1_fe_mul(&r[j], &r[i], &u);\n-        secp256k1_fe_mul(&u, &u, &a[j]);\n-    }\n-\n-    r[0] = u;\n-}\n-\n-static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n-#ifndef USE_NUM_NONE\n-    unsigned char b[32];\n-    secp256k1_num n;\n-    secp256k1_num m;\n-    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n-    static const unsigned char prime[32] = {\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n-    };\n-\n-    secp256k1_fe c = *a;\n-    secp256k1_fe_normalize_var(&c);\n-    secp256k1_fe_get_b32(b, &c);\n-    secp256k1_num_set_bin(&n, b, 32);\n-    secp256k1_num_set_bin(&m, prime, 32);\n-    return secp256k1_num_jacobi(&n, &m) >= 0;\n-#else\n-    secp256k1_fe r;\n-    return secp256k1_fe_sqrt(&r, a);\n-#endif\n-}\n-\n static const secp256k1_fe secp256k1_fe_one = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n \n #endif /* SECP256K1_FIELD_IMPL_H */"
      },
      {
        "sha": "024c55726170f044e1a760921389d0b7e150ac67",
        "filename": "src/gen_context.c",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_context.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,16 +1,17 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014, 2015 Thomas Daede, Cory Fields           *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014, 2015 Thomas Daede, Cory Fields            *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-// Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n-// ifndef guard so downstream users can define their own if they do not use autotools.\n+/* Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n+   ifndef guard so downstream users can define their own if they do not use autotools. */\n #if !defined(ECMULT_GEN_PREC_BITS)\n #include \"libsecp256k1-config.h\"\n #endif\n-#define USE_BASIC_CONFIG 1\n-#include \"basic-config.h\"\n+\n+/* We can't require the precomputed tables when creating them. */\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n \n #include \"include/secp256k1.h\"\n #include \"assumptions.h\"\n@@ -47,8 +48,8 @@ int main(int argc, char **argv) {\n         return -1;\n     }\n \n-    fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n-    fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n+    fprintf(fp, \"#ifndef SECP256K1_ECMULT_STATIC_CONTEXT_H\\n\");\n+    fprintf(fp, \"#define SECP256K1_ECMULT_STATIC_CONTEXT_H\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n     fprintf(fp, \"#if ECMULT_GEN_PREC_N != %d || ECMULT_GEN_PREC_G != %d\\n\", ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G);"
      },
      {
        "sha": "b9cd334dae26c7990ac43d93613b346132134a91",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 9,
        "deletions": 16,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_GROUP_H\n #define SECP256K1_GROUP_H\n \n-#include \"num.h\"\n #include \"field.h\"\n \n /** A group element of the secp256k1 curve, in affine coordinates. */\n@@ -43,12 +42,6 @@ typedef struct {\n /** Set a group element equal to the point with given X and Y coordinates */\n static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const secp256k1_fe *y);\n \n-/** Set a group element (affine) equal to the point with the given X coordinate\n- *  and a Y coordinate that is a quadratic residue modulo p. The return value\n- *  is true iff a coordinate with the given X coordinate exists.\n- */\n-static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n-\n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd);\n@@ -62,9 +55,12 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a);\n /** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n \n-/** Set a group element equal to another which is given in jacobian coordinates */\n+/** Set a group element equal to another which is given in jacobian coordinates. Constant time. */\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n+/** Set a group element equal to another which is given in jacobian coordinates. */\n+static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a);\n+\n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len);\n \n@@ -93,9 +89,6 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n-/** Check whether a group element's y coordinate is a quadratic residue. */\n-static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n-\n /** Set r equal to the double of a. Constant time. */\n static void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a);\n "
      },
      {
        "sha": "19ebd8f44ee384b9715704dc3eec48466f42458f",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 28,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_GROUP_IMPL_H\n #define SECP256K1_GROUP_IMPL_H\n \n-#include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n \n@@ -207,18 +206,14 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n     secp256k1_fe x2, x3;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_add(&x3, &secp256k1_fe_const_b);\n-    return secp256k1_fe_sqrt(&r->y, &x3);\n-}\n-\n-static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad(r, x)) {\n+    if (!secp256k1_fe_sqrt(&r->y, &x3)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -591,7 +586,7 @@ static void secp256k1_gej_add_ge(secp256k1_gej *r, const secp256k1_gej *a, const\n     secp256k1_fe_cmov(&n, &m, degenerate);              /* n = M^3 * Malt (2) */\n     secp256k1_fe_sqr(&t, &rr_alt);                      /* t = Ralt^2 (1) */\n     secp256k1_fe_mul(&r->z, &a->z, &m_alt);             /* r->z = Malt*Z (1) */\n-    infinity = secp256k1_fe_normalizes_to_zero(&r->z) * (1 - a->infinity);\n+    infinity = secp256k1_fe_normalizes_to_zero(&r->z) & ~a->infinity;\n     secp256k1_fe_mul_int(&r->z, 2);                     /* r->z = Z3 = 2*Malt*Z (2) */\n     secp256k1_fe_negate(&q, &q, 1);                     /* q = -Q (2) */\n     secp256k1_fe_add(&t, &q);                           /* t = Ralt^2-Q (3) */\n@@ -655,26 +650,12 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n     secp256k1_fe_mul(&r->x, &r->x, &beta);\n }\n \n-static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n-    secp256k1_fe yz;\n-\n-    if (a->infinity) {\n-        return 0;\n-    }\n-\n-    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n-     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n-       is */\n-    secp256k1_fe_mul(&yz, &a->y, &a->z);\n-    return secp256k1_fe_is_quad_var(&yz);\n-}\n-\n static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\n #ifdef EXHAUSTIVE_TEST_ORDER\n     secp256k1_gej out;\n     int i;\n \n-    /* A very simple EC multiplication ladder that avoids a dependecy on ecmult. */\n+    /* A very simple EC multiplication ladder that avoids a dependency on ecmult. */\n     secp256k1_gej_set_infinity(&out);\n     for (i = 0; i < 32; ++i) {\n         secp256k1_gej_double_var(&out, &out, NULL);"
      },
      {
        "sha": "0947a096943a9d7c3106fbcf61365eb26368ae29",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_HASH_H\n #define SECP256K1_HASH_H"
      },
      {
        "sha": "f8cd3a1634113eba4b692f73cc62e31248df0241",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_HASH_IMPL_H\n #define SECP256K1_HASH_IMPL_H"
      },
      {
        "sha": "0efdda9ab5e2ef2dddd974dcfd411de176da4b3f",
        "filename": "src/modinv32.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv32.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,42 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_H\n+#define SECP256K1_MODINV32_H\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"util.h\"\n+\n+/* A signed 30-bit limb representation of integers.\n+ *\n+ * Its value is sum(v[i] * 2^(30*i), i=0..8). */\n+typedef struct {\n+    int32_t v[9];\n+} secp256k1_modinv32_signed30;\n+\n+typedef struct {\n+    /* The modulus in signed30 notation, must be odd and in [3, 2^256]. */\n+    secp256k1_modinv32_signed30 modulus;\n+\n+    /* modulus^{-1} mod 2^30 */\n+    uint32_t modulus_inv30;\n+} secp256k1_modinv32_modinfo;\n+\n+/* Replace x with its modular inverse mod modinfo->modulus. x must be in range [0, modulus).\n+ * If x is zero, the result will be zero as well. If not, the inverse must exist (i.e., the gcd of\n+ * x and modulus must be 1). These rules are automatically satisfied if the modulus is prime.\n+ *\n+ * On output, all of x's limbs will be in [0, 2^30).\n+ */\n+static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n+\n+/* Same as secp256k1_modinv32_var, but constant time in x (not in the modulus). */\n+static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n+\n+#endif /* SECP256K1_MODINV32_H */"
      },
      {
        "sha": "661c5fc04c988372954ee4b09b4686651d481cba",
        "filename": "src/modinv32_impl.h",
        "status": "added",
        "additions": 587,
        "deletions": 0,
        "changes": 587,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv32_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,587 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+#include <stdlib.h>\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n+ */\n+\n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int alen, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        if (i < alen) c += (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    if (8 < alen) c += (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Return -1 for a<b*factor, 0 for a==b*factor, 1 for a>b*factor. A consists of alen limbs; b has 9. */\n+static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, int alen, const secp256k1_modinv32_signed30 *b, int32_t factor) {\n+    int i;\n+    secp256k1_modinv32_signed30 am, bm;\n+    secp256k1_modinv32_mul_30(&am, a, alen, 1); /* Normalize all but the top limb of a. */\n+    secp256k1_modinv32_mul_30(&bm, b, 9, factor);\n+    for (i = 0; i < 8; ++i) {\n+        /* Verify that all but the top limb of a and b are normalized. */\n+        VERIFY_CHECK(am.v[i] >> 30 == 0);\n+        VERIFY_CHECK(bm.v[i] >> 30 == 0);\n+    }\n+    for (i = 8; i >= 0; --i) {\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Take as input a signed30 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^30,2^30). The output will have limbs in range\n+ * [0,2^30). */\n+static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int32_t sign, const secp256k1_modinv32_modinfo *modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4],\n+            r5 = r->v[5], r6 = r->v[6], r7 = r->v[7], r8 = r->v[8];\n+    int32_t cond_add, cond_negate;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^30,2^30). */\n+    int i;\n+    for (i = 0; i < 9; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M30);\n+        VERIFY_CHECK(r->v[i] <= M30);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^30,2^30), this cannot overflow an int32_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r8 >> 31;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r5 += modinfo->modulus.v[5] & cond_add;\n+    r6 += modinfo->modulus.v[6] & cond_add;\n+    r7 += modinfo->modulus.v[7] & cond_add;\n+    r8 += modinfo->modulus.v[8] & cond_add;\n+    cond_negate = sign >> 31;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    r5 = (r5 ^ cond_negate) - cond_negate;\n+    r6 = (r6 ^ cond_negate) - cond_negate;\n+    r7 = (r7 ^ cond_negate) - cond_negate;\n+    r8 = (r8 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^30,2^30). */\n+    r1 += r0 >> 30; r0 &= M30;\n+    r2 += r1 >> 30; r1 &= M30;\n+    r3 += r2 >> 30; r2 &= M30;\n+    r4 += r3 >> 30; r3 &= M30;\n+    r5 += r4 >> 30; r4 &= M30;\n+    r6 += r5 >> 30; r5 &= M30;\n+    r7 += r6 >> 30; r6 &= M30;\n+    r8 += r7 >> 30; r7 &= M30;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing r to range\n+     * [0,modulus). */\n+    cond_add = r8 >> 31;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r5 += modinfo->modulus.v[5] & cond_add;\n+    r6 += modinfo->modulus.v[6] & cond_add;\n+    r7 += modinfo->modulus.v[7] & cond_add;\n+    r8 += modinfo->modulus.v[8] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 30; r0 &= M30;\n+    r2 += r1 >> 30; r1 &= M30;\n+    r3 += r2 >> 30; r2 &= M30;\n+    r4 += r3 >> 30; r3 &= M30;\n+    r5 += r4 >> 30; r4 &= M30;\n+    r6 += r5 >> 30; r5 &= M30;\n+    r7 += r6 >> 30; r6 &= M30;\n+    r8 += r7 >> 30; r7 &= M30;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+    r->v[5] = r5;\n+    r->v[6] = r6;\n+    r->v[7] = r7;\n+    r->v[8] = r8;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r0 >> 30 == 0);\n+    VERIFY_CHECK(r1 >> 30 == 0);\n+    VERIFY_CHECK(r2 >> 30 == 0);\n+    VERIFY_CHECK(r3 >> 30 == 0);\n+    VERIFY_CHECK(r4 >> 30 == 0);\n+    VERIFY_CHECK(r5 >> 30 == 0);\n+    VERIFY_CHECK(r6 >> 30 == 0);\n+    VERIFY_CHECK(r7 >> 30 == 0);\n+    VERIFY_CHECK(r8 >> 30 == 0);\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int32_t u, v, q, r;\n+} secp256k1_modinv32_trans2x2;\n+\n+/* Compute the transition matrix and zeta for 30 divsteps.\n+ *\n+ * Input:  zeta: initial zeta\n+ *         f0:   bottom limb of initial f\n+ *         g0:   bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final zeta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int32_t secp256k1_modinv32_divsteps_30(int32_t zeta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\n+    /* u,v,q,r are the elements of the transformation matrix being built up,\n+     * starting with the identity matrix. Semantically they are signed integers\n+     * in range [-2^30,2^30], but here represented as unsigned mod 2^32. This\n+     * permits left shifting (which is UB for negative numbers). The range\n+     * being inside [-2^31,2^31) means that casting to signed works correctly.\n+     */\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (zeta < 0) and for (g & 1). */\n+        c1 = zeta >> 31;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (zeta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally change zeta into -zeta-2 or zeta-1. */\n+        zeta = (zeta ^ c1) - 1;\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+        /* Bounds on zeta that follow from the bounds on iteration count (max 20*30 divsteps). */\n+        VERIFY_CHECK(zeta >= -601 && zeta <= 601);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int32_t)u;\n+    t->v = (int32_t)v;\n+    t->q = (int32_t)q;\n+    t->r = (int32_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 30 of them will have determinant 2^30. */\n+    VERIFY_CHECK((int64_t)t->u * t->r - (int64_t)t->v * t->q == ((int64_t)1) << 30);\n+    return zeta;\n+}\n+\n+/* Compute the transition matrix and eta for 30 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    /* Transformation matrix; see comments in secp256k1_modinv32_divsteps_30. */\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m;\n+    uint16_t w;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+         /* We're done once we've done 30 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+        /* Bounds on eta that follow from the bounds on iteration count (max 25*30 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint32_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        VERIFY_CHECK(limit > 0 && limit <= 30);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int32_t)u;\n+    t->v = (int32_t)v;\n+    t->q = (int32_t)q;\n+    t->r = (int32_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 30 of them will have determinant 2^30. */\n+    VERIFY_CHECK((int64_t)t->u * t->r - (int64_t)t->v * t->q == ((int64_t)1) << 30);\n+    return eta;\n+}\n+\n+/* Compute (t/2^30) * [d, e] mod modulus, where t is a transition matrix for 30 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^30,2^30).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const secp256k1_modinv32_trans2x2 *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    const int32_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int32_t di, ei, md, me, sd, se;\n+    int64_t cd, ce;\n+    int i;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+    VERIFY_CHECK((labs(u) + labs(v)) >= 0); /* |u|+|v| doesn't overflow */\n+    VERIFY_CHECK((labs(q) + labs(r)) >= 0); /* |q|+|r| doesn't overflow */\n+    VERIFY_CHECK((labs(u) + labs(v)) <= M30 + 1); /* |u|+|v| <= 2^30 */\n+    VERIFY_CHECK((labs(q) + labs(r)) <= M30 + 1); /* |q|+|r| <= 2^30 */\n+#endif\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d->v[8] >> 31;\n+    se = e->v[8] >> 31;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    di = d->v[0];\n+    ei = e->v[0];\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 30 zero bottom bits. */\n+    md -= (modinfo->modulus_inv30 * (uint32_t)cd + md) & M30;\n+    me -= (modinfo->modulus_inv30 * (uint32_t)ce + me) & M30;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int64_t)modinfo->modulus.v[0] * md;\n+    ce += (int64_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 30 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int32_t)cd & M30) == 0); cd >>= 30;\n+    VERIFY_CHECK(((int32_t)ce & M30) == 0); ce >>= 30;\n+    /* Now iteratively compute limb i=1..8 of t*[d,e]+modulus*[md,me], and store them in output\n+     * limb i-1 (shifting down by 30 bits). */\n+    for (i = 1; i < 9; ++i) {\n+        di = d->v[i];\n+        ei = e->v[i];\n+        cd += (int64_t)u * di + (int64_t)v * ei;\n+        ce += (int64_t)q * di + (int64_t)r * ei;\n+        cd += (int64_t)modinfo->modulus.v[i] * md;\n+        ce += (int64_t)modinfo->modulus.v[i] * me;\n+        d->v[i - 1] = (int32_t)cd & M30; cd >>= 30;\n+        e->v[i - 1] = (int32_t)ce & M30; ce >>= 30;\n+    }\n+    /* What remains is limb 9 of t*[d,e]+modulus*[md,me]; store it as output limb 8. */\n+    d->v[8] = (int32_t)cd;\n+    e->v[8] = (int32_t)ce;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+#endif\n+}\n+\n+/* Compute (t/2^30) * [f, g], where t is a transition matrix for 30 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv32_update_fg_30(secp256k1_modinv32_signed30 *f, secp256k1_modinv32_signed30 *g, const secp256k1_modinv32_trans2x2 *t) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    const int32_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int32_t fi, gi;\n+    int64_t cf, cg;\n+    int i;\n+    /* Start computing t*[f,g]. */\n+    fi = f->v[0];\n+    gi = g->v[0];\n+    cf = (int64_t)u * fi + (int64_t)v * gi;\n+    cg = (int64_t)q * fi + (int64_t)r * gi;\n+    /* Verify that the bottom 30 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int32_t)cf & M30) == 0); cf >>= 30;\n+    VERIFY_CHECK(((int32_t)cg & M30) == 0); cg >>= 30;\n+    /* Now iteratively compute limb i=1..8 of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by 30 bits). */\n+    for (i = 1; i < 9; ++i) {\n+        fi = f->v[i];\n+        gi = g->v[i];\n+        cf += (int64_t)u * fi + (int64_t)v * gi;\n+        cg += (int64_t)q * fi + (int64_t)r * gi;\n+        f->v[i - 1] = (int32_t)cf & M30; cf >>= 30;\n+        g->v[i - 1] = (int32_t)cg & M30; cg >>= 30;\n+    }\n+    /* What remains is limb 9 of t*[f,g]; store it as output limb 8. */\n+    f->v[8] = (int32_t)cf;\n+    g->v[8] = (int32_t)cg;\n+}\n+\n+/* Compute (t/2^30) * [f, g], where t is a transition matrix for 30 divsteps.\n+ *\n+ * Version that operates on a variable number of limbs in f and g.\n+ *\n+ * This implements the update_fg function from the explanation in modinv64_impl.h.\n+ */\n+static void secp256k1_modinv32_update_fg_30_var(int len, secp256k1_modinv32_signed30 *f, secp256k1_modinv32_signed30 *g, const secp256k1_modinv32_trans2x2 *t) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    const int32_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int32_t fi, gi;\n+    int64_t cf, cg;\n+    int i;\n+    VERIFY_CHECK(len > 0);\n+    /* Start computing t*[f,g]. */\n+    fi = f->v[0];\n+    gi = g->v[0];\n+    cf = (int64_t)u * fi + (int64_t)v * gi;\n+    cg = (int64_t)q * fi + (int64_t)r * gi;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int32_t)cf & M30) == 0); cf >>= 30;\n+    VERIFY_CHECK(((int32_t)cg & M30) == 0); cg >>= 30;\n+    /* Now iteratively compute limb i=1..len of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by 30 bits). */\n+    for (i = 1; i < len; ++i) {\n+        fi = f->v[i];\n+        gi = g->v[i];\n+        cf += (int64_t)u * fi + (int64_t)v * gi;\n+        cg += (int64_t)q * fi + (int64_t)r * gi;\n+        f->v[i - 1] = (int32_t)cf & M30; cf >>= 30;\n+        g->v[i - 1] = (int32_t)cg & M30; cg >>= 30;\n+    }\n+    /* What remains is limb (len) of t*[f,g]; store it as output limb (len-1). */\n+    f->v[len - 1] = (int32_t)cf;\n+    g->v[len - 1] = (int32_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, zeta=-1. */\n+    secp256k1_modinv32_signed30 d = {{0}};\n+    secp256k1_modinv32_signed30 e = {{1}};\n+    secp256k1_modinv32_signed30 f = modinfo->modulus;\n+    secp256k1_modinv32_signed30 g = *x;\n+    int i;\n+    int32_t zeta = -1; /* zeta = -(delta+1/2); delta is initially 1/2. */\n+\n+    /* Do 20 iterations of 30 divsteps each = 600 divsteps. 590 suffices for 256-bit inputs. */\n+    for (i = 0; i < 20; ++i) {\n+        /* Compute transition matrix and new zeta after 30 divsteps. */\n+        secp256k1_modinv32_trans2x2 t;\n+        zeta = secp256k1_modinv32_divsteps_30(zeta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv32_update_de_30(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv32_update_fg_30(&f, &g, &t);\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &SECP256K1_SIGNED30_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &SECP256K1_SIGNED30_ONE, -1) == 0 ||\n+                 secp256k1_modinv32_mul_cmp_30(&f, 9, &SECP256K1_SIGNED30_ONE, 1) == 0 ||\n+                 (secp256k1_modinv32_mul_cmp_30(x, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  secp256k1_modinv32_mul_cmp_30(&d, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  (secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv32_normalize_30(&d, f.v[8], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv32_signed30 d = {{0, 0, 0, 0, 0, 0, 0, 0, 0}};\n+    secp256k1_modinv32_signed30 e = {{1, 0, 0, 0, 0, 0, 0, 0, 0}};\n+    secp256k1_modinv32_signed30 f = modinfo->modulus;\n+    secp256k1_modinv32_signed30 g = *x;\n+#ifdef VERIFY\n+    int i = 0;\n+#endif\n+    int j, len = 9;\n+    int32_t eta = -1; /* eta = -delta; delta is initially 1 (faster for the variable-time code) */\n+    int32_t cond, fn, gn;\n+\n+    /* Do iterations of 30 divsteps each until g=0. */\n+    while (1) {\n+        /* Compute transition matrix and new eta after 30 divsteps. */\n+        secp256k1_modinv32_trans2x2 t;\n+        eta = secp256k1_modinv32_divsteps_30_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv32_update_de_30(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv32_update_fg_30_var(len, &f, &g, &t);\n+        /* If the bottom limb of g is 0, there is a chance g=0. */\n+        if (g.v[0] == 0) {\n+            cond = 0;\n+            /* Check if all other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= g.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) break;\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0 or -1. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int32_t)len - 2) >> 31;\n+        cond |= fn ^ (fn >> 31);\n+        cond |= gn ^ (gn >> 31);\n+        /* If so, reduce length, propagating the sign of f and g's top limb into the one below. */\n+        if (cond == 0) {\n+            f.v[len - 2] |= (uint32_t)fn << 30;\n+            g.v[len - 2] |= (uint32_t)gn << 30;\n+            --len;\n+        }\n+#ifdef VERIFY\n+        VERIFY_CHECK(++i < 25); /* We should never need more than 25*30 = 750 divsteps */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point g is 0 and (if g was not originally 0) f must now equal +/- GCD of\n+     * the initial f, g values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &SECP256K1_SIGNED30_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &SECP256K1_SIGNED30_ONE, -1) == 0 ||\n+                 secp256k1_modinv32_mul_cmp_30(&f, len, &SECP256K1_SIGNED30_ONE, 1) == 0 ||\n+                 (secp256k1_modinv32_mul_cmp_30(x, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  secp256k1_modinv32_mul_cmp_30(&d, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  (secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv32_normalize_30(&d, f.v[len - 1], modinfo);\n+    *x = d;\n+}\n+\n+#endif /* SECP256K1_MODINV32_IMPL_H */"
      },
      {
        "sha": "da506dfa9f722e2bc697209a7aeaf2ec574318b9",
        "filename": "src/modinv64.h",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv64.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,46 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_H\n+#define SECP256K1_MODINV64_H\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"util.h\"\n+\n+#ifndef SECP256K1_WIDEMUL_INT128\n+#error \"modinv64 requires 128-bit wide multiplication support\"\n+#endif\n+\n+/* A signed 62-bit limb representation of integers.\n+ *\n+ * Its value is sum(v[i] * 2^(62*i), i=0..4). */\n+typedef struct {\n+    int64_t v[5];\n+} secp256k1_modinv64_signed62;\n+\n+typedef struct {\n+    /* The modulus in signed62 notation, must be odd and in [3, 2^256]. */\n+    secp256k1_modinv64_signed62 modulus;\n+\n+    /* modulus^{-1} mod 2^62 */\n+    uint64_t modulus_inv62;\n+} secp256k1_modinv64_modinfo;\n+\n+/* Replace x with its modular inverse mod modinfo->modulus. x must be in range [0, modulus).\n+ * If x is zero, the result will be zero as well. If not, the inverse must exist (i.e., the gcd of\n+ * x and modulus must be 1). These rules are automatically satisfied if the modulus is prime.\n+ *\n+ * On output, all of x's limbs will be in [0, 2^62).\n+ */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n+\n+/* Same as secp256k1_modinv64_var, but constant time in x (not in the modulus). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n+\n+#endif /* SECP256K1_MODINV64_H */"
      },
      {
        "sha": "0743a9c8210d2d42af3535f9acbe96b5f4a3028d",
        "filename": "src/modinv64_impl.h",
        "status": "added",
        "additions": 593,
        "deletions": 0,
        "changes": 593,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modinv64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv64_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -0,0 +1,593 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) c += (int128_t)a->v[i] * factor;\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) c += (int128_t)a->v[4] * factor;\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Return -1 for a<b*factor, 0 for a==b*factor, 1 for a>b*factor. A has alen limbs; b has 5. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1); /* Normalize all but the top limb of a. */\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 0; i < 4; ++i) {\n+        /* Verify that all but the top limb of a and b are normalized. */\n+        VERIFY_CHECK(am.v[i] >> 62 == 0);\n+        VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+    }\n+    for (i = 4; i >= 0; --i) {\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r0 >> 62 == 0);\n+    VERIFY_CHECK(r1 >> 62 == 0);\n+    VERIFY_CHECK(r2 >> 62 == 0);\n+    VERIFY_CHECK(r3 >> 62 == 0);\n+    VERIFY_CHECK(r4 >> 62 == 0);\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 59 divsteps (where zeta=-(delta+1/2)).\n+ * Note that the transformation matrix is scaled by 2^62 and not 2^59.\n+ *\n+ * Input:  zeta: initial zeta\n+ *         f0:   bottom limb of initial f\n+ *         g0:   bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final zeta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_59(int64_t zeta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* u,v,q,r are the elements of the transformation matrix being built up,\n+     * starting with the identity matrix times 8 (because the caller expects\n+     * a result scaled by 2^62). Semantically they are signed integers\n+     * in range [-2^62,2^62], but here represented as unsigned mod 2^64. This\n+     * permits left shifting (which is UB for negative numbers). The range\n+     * being inside [-2^63,2^63) means that casting to signed works correctly.\n+     */\n+    uint64_t u = 8, v = 0, q = 0, r = 8;\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 3; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (zeta < 0) and for (g & 1). */\n+        c1 = zeta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (zeta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally change zeta into -zeta-2 or zeta-1. */\n+        zeta = (zeta ^ c1) - 1;\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+        /* Bounds on zeta that follow from the bounds on iteration count (max 10*59 divsteps). */\n+        VERIFY_CHECK(zeta >= -591 && zeta <= 591);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 59 of them will have determinant 2^59. Multiplying with the initial\n+     * 8*identity (which has determinant 2^6) means the overall outputs has determinant\n+     * 2^65. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 65);\n+    return zeta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time, eta=-delta).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */\n+    uint64_t u = 1, v = 0, q = 0, r = 1;\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* Bounds on eta that follow from the bounds on iteration count (max 12*62 divsteps). */\n+        VERIFY_CHECK(eta >= -745 && eta <= 745);\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;\n+        } else {\n+            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as\n+             * eta tends to be smaller here. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 4) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 15U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 4)\n+             * bits. */\n+            w = f + (((f + 1) & 4) << 1);\n+            w = (-w * g) & m;\n+        }\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 62 of them will have determinant 2^62. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 62);\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix scaled by 2^62.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(u) + secp256k1_modinv64_abs(v)) >= 0); /* |u|+|v| doesn't overflow */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(q) + secp256k1_modinv64_abs(r)) >= 0); /* |q|+|r| doesn't overflow */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(u) + secp256k1_modinv64_abs(v)) <= M62 + 1); /* |u|+|v| <= 2^62 */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(q) + secp256k1_modinv64_abs(r)) <= M62 + 1); /* |q|+|r| <= 2^62 */\n+#endif\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    if (modinfo->modulus.v[1]) { /* Optimize for the case where limb of modulus is zero. */\n+        cd += (int128_t)modinfo->modulus.v[1] * md;\n+        ce += (int128_t)modinfo->modulus.v[1] * me;\n+    }\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    if (modinfo->modulus.v[2]) { /* Optimize for the case where limb of modulus is zero. */\n+        cd += (int128_t)modinfo->modulus.v[2] * md;\n+        ce += (int128_t)modinfo->modulus.v[2] * me;\n+    }\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    if (modinfo->modulus.v[3]) { /* Optimize for the case where limb of modulus is zero. */\n+        cd += (int128_t)modinfo->modulus.v[3] * md;\n+        ce += (int128_t)modinfo->modulus.v[3] * me;\n+    }\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+#endif\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix scaled by 2^62.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * Version that operates on a variable number of limbs in f and g.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62_var(int len, secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t fi, gi;\n+    int128_t cf, cg;\n+    int i;\n+    VERIFY_CHECK(len > 0);\n+    /* Start computing t*[f,g]. */\n+    fi = f->v[0];\n+    gi = g->v[0];\n+    cf = (int128_t)u * fi + (int128_t)v * gi;\n+    cg = (int128_t)q * fi + (int128_t)r * gi;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Now iteratively compute limb i=1..len of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by 62 bits). */\n+    for (i = 1; i < len; ++i) {\n+        fi = f->v[i];\n+        gi = g->v[i];\n+        cf += (int128_t)u * fi + (int128_t)v * gi;\n+        cg += (int128_t)q * fi + (int128_t)r * gi;\n+        f->v[i - 1] = (int64_t)cf & M62; cf >>= 62;\n+        g->v[i - 1] = (int64_t)cg & M62; cg >>= 62;\n+    }\n+    /* What remains is limb (len) of t*[f,g]; store it as output limb (len-1). */\n+    f->v[len - 1] = (int64_t)cf;\n+    g->v[len - 1] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, zeta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t zeta = -1; /* zeta = -(delta+1/2); delta starts at 1/2. */\n+\n+    /* Do 10 iterations of 59 divsteps each = 590 divsteps. This suffices for 256-bit inputs. */\n+    for (i = 0; i < 10; ++i) {\n+        /* Compute transition matrix and new zeta after 59 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        zeta = secp256k1_modinv64_divsteps_59(zeta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &SECP256K1_SIGNED62_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &SECP256K1_SIGNED62_ONE, -1) == 0 ||\n+                 secp256k1_modinv64_mul_cmp_62(&f, 5, &SECP256K1_SIGNED62_ONE, 1) == 0 ||\n+                 (secp256k1_modinv64_mul_cmp_62(x, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  secp256k1_modinv64_mul_cmp_62(&d, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  (secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+#ifdef VERIFY\n+    int i = 0;\n+#endif\n+    int j, len = 5;\n+    int64_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int64_t cond, fn, gn;\n+\n+    /* Do iterations of 62 divsteps each until g=0. */\n+    while (1) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv64_update_fg_62_var(len, &f, &g, &t);\n+        /* If the bottom limb of g is zero, there is a chance that g=0. */\n+        if (g.v[0] == 0) {\n+            cond = 0;\n+            /* Check if the other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= g.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) break;\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0 or -1. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int64_t)len - 2) >> 63;\n+        cond |= fn ^ (fn >> 63);\n+        cond |= gn ^ (gn >> 63);\n+        /* If so, reduce length, propagating the sign of f and g's top limb into the one below. */\n+        if (cond == 0) {\n+            f.v[len - 2] |= (uint64_t)fn << 62;\n+            g.v[len - 2] |= (uint64_t)gn << 62;\n+            --len;\n+        }\n+#ifdef VERIFY\n+        VERIFY_CHECK(++i < 12); /* We should never need more than 12*62 = 744 divsteps */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point g is 0 and (if g was not originally 0) f must now equal +/- GCD of\n+     * the initial f, g values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &SECP256K1_SIGNED62_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &SECP256K1_SIGNED62_ONE, -1) == 0 ||\n+                 secp256k1_modinv64_mul_cmp_62(&f, len, &SECP256K1_SIGNED62_ONE, 1) == 0 ||\n+                 (secp256k1_modinv64_mul_cmp_62(x, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  secp256k1_modinv64_mul_cmp_62(&d, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  (secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[len - 1], modinfo);\n+    *x = d;\n+}\n+\n+#endif /* SECP256K1_MODINV64_IMPL_H */"
      },
      {
        "sha": "1ac67086beccac5d2e28f74f747d37f483492dc9",
        "filename": "src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/main_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_ECDH_MAIN_H\n #define SECP256K1_MODULE_ECDH_MAIN_H"
      },
      {
        "sha": "be07447a4b9957347f6b9661675590b8dc99158c",
        "filename": "src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/tests_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_ECDH_TESTS_H\n #define SECP256K1_MODULE_ECDH_TESTS_H"
      },
      {
        "sha": "7390b227182fe33181d111b580be47100d5558eb",
        "filename": "src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 8,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/main_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Jonas Nick                                      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n-#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#ifndef SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n+#define SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_extrakeys.h\"\n@@ -180,12 +180,22 @@ int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *ke\n \n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n     secp256k1_keypair_save(keypair, &sk, &pk);\n-    memczero(keypair, sizeof(*keypair), !ret);\n+    secp256k1_memczero(keypair, sizeof(*keypair), !ret);\n \n     secp256k1_scalar_clear(&sk);\n     return ret;\n }\n \n+int secp256k1_keypair_sec(const secp256k1_context* ctx, unsigned char *seckey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+    memset(seckey, 0, 32);\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(seckey, &keypair->data[0], 32);\n+    return 1;\n+}\n+\n int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);"
      },
      {
        "sha": "0aca4fb72d781095c243401bda4a4e70c83afcfb",
        "filename": "src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_exhaustive_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n-#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n+#ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n+#define SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n \n #include \"src/modules/extrakeys/main_impl.h\"\n #include \"include/secp256k1_extrakeys.h\""
      },
      {
        "sha": "9473a7dd4852e66f2ad7b30adbc10b41fabb4bb1",
        "filename": "src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 33,
        "deletions": 8,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Jonas Nick                                      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n-#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n+#ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n+#define SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n \n #include \"secp256k1_extrakeys.h\"\n \n@@ -311,6 +311,7 @@ void test_xonly_pubkey_tweak_recursive(void) {\n \n void test_keypair(void) {\n     unsigned char sk[32];\n+    unsigned char sk_tmp[32];\n     unsigned char zeros96[96] = { 0 };\n     unsigned char overflows[32];\n     secp256k1_keypair keypair;\n@@ -396,6 +397,28 @@ void test_keypair(void) {\n     CHECK(secp256k1_memcmp_var(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n     CHECK(pk_parity == pk_parity_tmp);\n \n+    /* Test keypair_seckey */\n+    ecount = 0;\n+    secp256k1_testrand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, &keypair) == 1);\n+    CHECK(secp256k1_keypair_sec(none, NULL, &keypair) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_memcmp_var(zeros96, sk_tmp, sizeof(sk_tmp)) == 0);\n+\n+    /* keypair returns the same seckey it got */\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, &keypair) == 1);\n+    CHECK(secp256k1_memcmp_var(sk, sk_tmp, sizeof(sk_tmp)) == 0);\n+\n+\n+    /* Using an invalid keypair is fine for keypair_seckey */\n+    memset(&keypair, 0, sizeof(keypair));\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, &keypair) == 1);\n+    CHECK(secp256k1_memcmp_var(zeros96, sk_tmp, sizeof(sk_tmp)) == 0);\n+\n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n     secp256k1_context_destroy(verify);\n@@ -484,6 +507,7 @@ void test_keypair_add(void) {\n         secp256k1_pubkey output_pk_xy;\n         secp256k1_pubkey output_pk_expected;\n         unsigned char pk32[32];\n+        unsigned char sk32[32];\n         int pk_parity;\n \n         secp256k1_testrand256(tweak);\n@@ -501,7 +525,8 @@ void test_keypair_add(void) {\n         CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n \n         /* Check that the secret key in the keypair is tweaked correctly */\n-        CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, &keypair.data[0]) == 1);\n+        CHECK(secp256k1_keypair_sec(none, sk32, &keypair) == 1);\n+        CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, sk32) == 1);\n         CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n     }\n     secp256k1_context_destroy(none);"
      },
      {
        "sha": "7a440a729bf9644162e94651e6c222972dc30ec1",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_RECOVERY_MAIN_H\n #define SECP256K1_MODULE_RECOVERY_MAIN_H\n@@ -120,34 +120,34 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n     return !secp256k1_gej_is_infinity(&qj);\n }\n \n-int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n+int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar r, s;\n     int ret, recid;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, &recid, msg32, seckey, noncefp, noncedata);\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, &recid, msghash32, seckey, noncefp, noncedata);\n     secp256k1_ecdsa_recoverable_signature_save(signature, &r, &s, recid);\n     return ret;\n }\n \n-int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msg32) {\n+int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msghash32) {\n     secp256k1_ge q;\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     int recid;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n     VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n-    secp256k1_scalar_set_b32(&m, msg32, NULL);\n+    secp256k1_scalar_set_b32(&m, msghash32, NULL);\n     if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);\n         return 1;"
      },
      {
        "sha": "0ba9409c691d0f251a55bbc699ac745712004edd",
        "filename": "src/modules/recovery/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_exhaustive_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2016 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n #define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H"
      },
      {
        "sha": "40dba87ce39a7b0463a8107dd6623fa1b8ac774a",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_RECOVERY_TESTS_H\n #define SECP256K1_MODULE_RECOVERY_TESTS_H"
      },
      {
        "sha": "22e1b33a5a48e63b0c701f243802d7d32e5b6dda",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                 *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n-#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#ifndef SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n+#define SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_schnorrsig.h\"\n@@ -179,7 +179,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n \n-    memczero(sig64, 64, !ret);\n+    secp256k1_memczero(sig64, 64, !ret);\n     secp256k1_scalar_clear(&k);\n     secp256k1_scalar_clear(&sk);\n     memset(seckey, 0, sizeof(seckey));"
      },
      {
        "sha": "b4a428729f9a0b823e5b005be7314521d601367c",
        "filename": "src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n-#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n+#ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n+#define SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n \n #include \"include/secp256k1_schnorrsig.h\"\n #include \"src/modules/schnorrsig/main_impl.h\""
      },
      {
        "sha": "338462fc9dfb944291ff8d6914859d03b70b1cdb",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n-#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+/***********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                 *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n+#define SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n \n #include \"secp256k1_schnorrsig.h\"\n "
      },
      {
        "sha": "49f2dd791d5696bf89a11caf5461e3f5b33aaca0",
        "filename": "src/num.h",
        "status": "removed",
        "additions": 0,
        "deletions": 74,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num.h?ref=6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "patch": "@@ -1,74 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_H\n-#define SECP256K1_NUM_H\n-\n-#ifndef USE_NUM_NONE\n-\n-#if defined HAVE_CONFIG_H\n-#include \"libsecp256k1-config.h\"\n-#endif\n-\n-#if defined(USE_NUM_GMP)\n-#include \"num_gmp.h\"\n-#else\n-#error \"Please select num implementation\"\n-#endif\n-\n-/** Copy a number. */\n-static void secp256k1_num_copy(secp256k1_num *r, const secp256k1_num *a);\n-\n-/** Convert a number's absolute value to a binary big-endian string.\n- *  There must be enough place. */\n-static void secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num *a);\n-\n-/** Set a number to the value of a binary big-endian string. */\n-static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsigned int alen);\n-\n-/** Compute a modular inverse. The input must be less than the modulus. */\n-static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n-\n-/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n-static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Compare the absolute value of two numbers. */\n-static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Test whether two number are equal (including sign). */\n-static int secp256k1_num_eq(const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Add two (signed) numbers. */\n-static void secp256k1_num_add(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Subtract two (signed) numbers. */\n-static void secp256k1_num_sub(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Multiply two (signed) numbers. */\n-static void secp256k1_num_mul(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Replace a number by its remainder modulo m. M's sign is ignored. The result is a number between 0 and m-1,\n-    even if r was negative. */\n-static void secp256k1_num_mod(secp256k1_num *r, const secp256k1_num *m);\n-\n-/** Right-shift the passed number by bits bits. */\n-static void secp256k1_num_shift(secp256k1_num *r, int bits);\n-\n-/** Check whether a number is zero. */\n-static int secp256k1_num_is_zero(const secp256k1_num *a);\n-\n-/** Check whether a number is one. */\n-static int secp256k1_num_is_one(const secp256k1_num *a);\n-\n-/** Check whether a number is strictly negative. */\n-static int secp256k1_num_is_neg(const secp256k1_num *a);\n-\n-/** Change a number's sign. */\n-static void secp256k1_num_negate(secp256k1_num *r);\n-\n-#endif\n-\n-#endif /* SECP256K1_NUM_H */"
      },
      {
        "sha": "3619844bd5127eb4018efc05e16e78ae9143a93a",
        "filename": "src/num_gmp.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num_gmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num_gmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp.h?ref=6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "patch": "@@ -1,20 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_REPR_H\n-#define SECP256K1_NUM_REPR_H\n-\n-#include <gmp.h>\n-\n-#define NUM_LIMBS ((256+GMP_NUMB_BITS-1)/GMP_NUMB_BITS)\n-\n-typedef struct {\n-    mp_limb_t data[2*NUM_LIMBS];\n-    int neg;\n-    int limbs;\n-} secp256k1_num;\n-\n-#endif /* SECP256K1_NUM_REPR_H */"
      },
      {
        "sha": "0ae2a8ba0ecb7b5b61aca0f94676dd7cbf86c437",
        "filename": "src/num_gmp_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 288,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp_impl.h?ref=6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "patch": "@@ -1,288 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_REPR_IMPL_H\n-#define SECP256K1_NUM_REPR_IMPL_H\n-\n-#include <string.h>\n-#include <stdlib.h>\n-#include <gmp.h>\n-\n-#include \"util.h\"\n-#include \"num.h\"\n-\n-#ifdef VERIFY\n-static void secp256k1_num_sanity(const secp256k1_num *a) {\n-    VERIFY_CHECK(a->limbs == 1 || (a->limbs > 1 && a->data[a->limbs-1] != 0));\n-}\n-#else\n-#define secp256k1_num_sanity(a) do { } while(0)\n-#endif\n-\n-static void secp256k1_num_copy(secp256k1_num *r, const secp256k1_num *a) {\n-    *r = *a;\n-}\n-\n-static void secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num *a) {\n-    unsigned char tmp[65];\n-    int len = 0;\n-    int shift = 0;\n-    if (a->limbs>1 || a->data[0] != 0) {\n-        len = mpn_get_str(tmp, 256, (mp_limb_t*)a->data, a->limbs);\n-    }\n-    while (shift < len && tmp[shift] == 0) shift++;\n-    VERIFY_CHECK(len-shift <= (int)rlen);\n-    memset(r, 0, rlen - len + shift);\n-    if (len > shift) {\n-        memcpy(r + rlen - len + shift, tmp + shift, len - shift);\n-    }\n-    memset(tmp, 0, sizeof(tmp));\n-}\n-\n-static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsigned int alen) {\n-    int len;\n-    VERIFY_CHECK(alen > 0);\n-    VERIFY_CHECK(alen <= 64);\n-    len = mpn_set_str(r->data, a, alen, 256);\n-    if (len == 0) {\n-        r->data[0] = 0;\n-        len = 1;\n-    }\n-    VERIFY_CHECK(len <= NUM_LIMBS*2);\n-    r->limbs = len;\n-    r->neg = 0;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-        r->limbs--;\n-    }\n-}\n-\n-static void secp256k1_num_add_abs(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    mp_limb_t c = mpn_add(r->data, a->data, a->limbs, b->data, b->limbs);\n-    r->limbs = a->limbs;\n-    if (c != 0) {\n-        VERIFY_CHECK(r->limbs < 2*NUM_LIMBS);\n-        r->data[r->limbs++] = c;\n-    }\n-}\n-\n-static void secp256k1_num_sub_abs(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    mp_limb_t c = mpn_sub(r->data, a->data, a->limbs, b->data, b->limbs);\n-    (void)c;\n-    VERIFY_CHECK(c == 0);\n-    r->limbs = a->limbs;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-        r->limbs--;\n-    }\n-}\n-\n-static void secp256k1_num_mod(secp256k1_num *r, const secp256k1_num *m) {\n-    secp256k1_num_sanity(r);\n-    secp256k1_num_sanity(m);\n-\n-    if (r->limbs >= m->limbs) {\n-        mp_limb_t t[2*NUM_LIMBS];\n-        mpn_tdiv_qr(t, r->data, 0, r->data, r->limbs, m->data, m->limbs);\n-        memset(t, 0, sizeof(t));\n-        r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-            r->limbs--;\n-        }\n-    }\n-\n-    if (r->neg && (r->limbs > 1 || r->data[0] != 0)) {\n-        secp256k1_num_sub_abs(r, m, r);\n-        r->neg = 0;\n-    }\n-}\n-\n-static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m) {\n-    int i;\n-    mp_limb_t g[NUM_LIMBS+1];\n-    mp_limb_t u[NUM_LIMBS+1];\n-    mp_limb_t v[NUM_LIMBS+1];\n-    mp_size_t sn;\n-    mp_size_t gn;\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(m);\n-\n-    /** mpn_gcdext computes: (G,S) = gcdext(U,V), where\n-     *  * G = gcd(U,V)\n-     *  * G = U*S + V*T\n-     *  * U has equal or more limbs than V, and V has no padding\n-     *  If we set U to be (a padded version of) a, and V = m:\n-     *    G = a*S + m*T\n-     *    G = a*S mod m\n-     *  Assuming G=1:\n-     *    S = 1/a mod m\n-     */\n-    VERIFY_CHECK(m->limbs <= NUM_LIMBS);\n-    VERIFY_CHECK(m->data[m->limbs-1] != 0);\n-    for (i = 0; i < m->limbs; i++) {\n-        u[i] = (i < a->limbs) ? a->data[i] : 0;\n-        v[i] = m->data[i];\n-    }\n-    sn = NUM_LIMBS+1;\n-    gn = mpn_gcdext(g, r->data, &sn, u, m->limbs, v, m->limbs);\n-    (void)gn;\n-    VERIFY_CHECK(gn == 1);\n-    VERIFY_CHECK(g[0] == 1);\n-    r->neg = a->neg ^ m->neg;\n-    if (sn < 0) {\n-        mpn_sub(r->data, m->data, m->limbs, r->data, -sn);\n-        r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-            r->limbs--;\n-        }\n-    } else {\n-        r->limbs = sn;\n-    }\n-    memset(g, 0, sizeof(g));\n-    memset(u, 0, sizeof(u));\n-    memset(v, 0, sizeof(v));\n-}\n-\n-static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n-    int ret;\n-    mpz_t ga, gb;\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n-\n-    mpz_inits(ga, gb, NULL);\n-\n-    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n-    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n-    if (a->neg) {\n-        mpz_neg(ga, ga);\n-    }\n-\n-    ret = mpz_jacobi(ga, gb);\n-\n-    mpz_clears(ga, gb, NULL);\n-\n-    return ret;\n-}\n-\n-static int secp256k1_num_is_one(const secp256k1_num *a) {\n-    return (a->limbs == 1 && a->data[0] == 1);\n-}\n-\n-static int secp256k1_num_is_zero(const secp256k1_num *a) {\n-    return (a->limbs == 1 && a->data[0] == 0);\n-}\n-\n-static int secp256k1_num_is_neg(const secp256k1_num *a) {\n-    return (a->limbs > 1 || a->data[0] != 0) && a->neg;\n-}\n-\n-static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b) {\n-    if (a->limbs > b->limbs) {\n-        return 1;\n-    }\n-    if (a->limbs < b->limbs) {\n-        return -1;\n-    }\n-    return mpn_cmp(a->data, b->data, a->limbs);\n-}\n-\n-static int secp256k1_num_eq(const secp256k1_num *a, const secp256k1_num *b) {\n-    if (a->limbs > b->limbs) {\n-        return 0;\n-    }\n-    if (a->limbs < b->limbs) {\n-        return 0;\n-    }\n-    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) {\n-        return 0;\n-    }\n-    return mpn_cmp(a->data, b->data, a->limbs) == 0;\n-}\n-\n-static void secp256k1_num_subadd(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b, int bneg) {\n-    if (!(b->neg ^ bneg ^ a->neg)) { /* a and b have the same sign */\n-        r->neg = a->neg;\n-        if (a->limbs >= b->limbs) {\n-            secp256k1_num_add_abs(r, a, b);\n-        } else {\n-            secp256k1_num_add_abs(r, b, a);\n-        }\n-    } else {\n-        if (secp256k1_num_cmp(a, b) > 0) {\n-            r->neg = a->neg;\n-            secp256k1_num_sub_abs(r, a, b);\n-        } else {\n-            r->neg = b->neg ^ bneg;\n-            secp256k1_num_sub_abs(r, b, a);\n-        }\n-    }\n-}\n-\n-static void secp256k1_num_add(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-    secp256k1_num_subadd(r, a, b, 0);\n-}\n-\n-static void secp256k1_num_sub(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-    secp256k1_num_subadd(r, a, b, 1);\n-}\n-\n-static void secp256k1_num_mul(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    mp_limb_t tmp[2*NUM_LIMBS+1];\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-\n-    VERIFY_CHECK(a->limbs + b->limbs <= 2*NUM_LIMBS+1);\n-    if ((a->limbs==1 && a->data[0]==0) || (b->limbs==1 && b->data[0]==0)) {\n-        r->limbs = 1;\n-        r->neg = 0;\n-        r->data[0] = 0;\n-        return;\n-    }\n-    if (a->limbs >= b->limbs) {\n-        mpn_mul(tmp, a->data, a->limbs, b->data, b->limbs);\n-    } else {\n-        mpn_mul(tmp, b->data, b->limbs, a->data, a->limbs);\n-    }\n-    r->limbs = a->limbs + b->limbs;\n-    if (r->limbs > 1 && tmp[r->limbs - 1]==0) {\n-        r->limbs--;\n-    }\n-    VERIFY_CHECK(r->limbs <= 2*NUM_LIMBS);\n-    mpn_copyi(r->data, tmp, r->limbs);\n-    r->neg = a->neg ^ b->neg;\n-    memset(tmp, 0, sizeof(tmp));\n-}\n-\n-static void secp256k1_num_shift(secp256k1_num *r, int bits) {\n-    if (bits % GMP_NUMB_BITS) {\n-        /* Shift within limbs. */\n-        mpn_rshift(r->data, r->data, r->limbs, bits % GMP_NUMB_BITS);\n-    }\n-    if (bits >= GMP_NUMB_BITS) {\n-        int i;\n-        /* Shift full limbs. */\n-        for (i = 0; i < r->limbs; i++) {\n-            int index = i + (bits / GMP_NUMB_BITS);\n-            if (index < r->limbs && index < 2*NUM_LIMBS) {\n-                r->data[i] = r->data[index];\n-            } else {\n-                r->data[i] = 0;\n-            }\n-        }\n-    }\n-    while (r->limbs>1 && r->data[r->limbs-1]==0) {\n-        r->limbs--;\n-    }\n-}\n-\n-static void secp256k1_num_negate(secp256k1_num *r) {\n-    r->neg ^= 1;\n-}\n-\n-#endif /* SECP256K1_NUM_REPR_IMPL_H */"
      },
      {
        "sha": "c45193b033dab813c0ec30697f23fd60098b8e9a",
        "filename": "src/num_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 24,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7/src/num_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_impl.h?ref=6c0259fc2f8bd34ba83ad10a6a11d6d99e8d1fc7",
        "patch": "@@ -1,24 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_IMPL_H\n-#define SECP256K1_NUM_IMPL_H\n-\n-#if defined HAVE_CONFIG_H\n-#include \"libsecp256k1-config.h\"\n-#endif\n-\n-#include \"num.h\"\n-\n-#if defined(USE_NUM_GMP)\n-#include \"num_gmp_impl.h\"\n-#elif defined(USE_NUM_NONE)\n-/* Nothing. */\n-#else\n-#error \"Please select num implementation\"\n-#endif\n-\n-#endif /* SECP256K1_NUM_IMPL_H */"
      },
      {
        "sha": "aaaa3d88277ad057c771480754c21f94c8eb9d7d",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 5,
        "deletions": 17,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_H\n #define SECP256K1_SCALAR_H\n \n-#include \"num.h\"\n #include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n@@ -63,9 +62,6 @@ static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a,\n  *  the low bits that were shifted off */\n static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n);\n \n-/** Compute the square of a scalar (modulo the group order). */\n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a);\n-\n /** Compute the inverse of a scalar (modulo the group order). */\n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *a);\n \n@@ -91,14 +87,6 @@ static int secp256k1_scalar_is_high(const secp256k1_scalar *a);\n  * Returns -1 if the number was negated, 1 otherwise */\n static int secp256k1_scalar_cond_negate(secp256k1_scalar *a, int flag);\n \n-#ifndef USE_NUM_NONE\n-/** Convert a scalar to a number. */\n-static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a);\n-\n-/** Get the order of the group as a number. */\n-static void secp256k1_scalar_order_get_num(secp256k1_num *r);\n-#endif\n-\n /** Compare two scalars. */\n static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b);\n "
      },
      {
        "sha": "700964291ee28695e80458c861f322e8698949b7",
        "filename": "src/scalar_4x64.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_4x64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_4x64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_H\n #define SECP256K1_SCALAR_REPR_H"
      },
      {
        "sha": "a1def26fca7afad330b62929db12e70ddbde7d50",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 81,
        "deletions": 171,
        "changes": 252,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,12 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include \"modinv64_impl.h\"\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)\n #define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)\n@@ -212,28 +214,6 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n     VERIFY_CHECK(c1 >= th); \\\n }\n \n-/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n-#define muladd2(a,b) { \\\n-    uint64_t tl, th, th2, tl2; \\\n-    { \\\n-        uint128_t t = (uint128_t)a * b; \\\n-        th = t >> 64;               /* at most 0xFFFFFFFFFFFFFFFE */ \\\n-        tl = t; \\\n-    } \\\n-    th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n-    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n-    tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n-    th2 += (tl2 < tl);              /* at most 0xFFFFFFFFFFFFFFFF */ \\\n-    c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n-    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n-    c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n-}\n-\n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n@@ -743,148 +723,10 @@ static void secp256k1_scalar_mul_512(uint64_t l[8], const secp256k1_scalar *a, c\n #endif\n }\n \n-static void secp256k1_scalar_sqr_512(uint64_t l[8], const secp256k1_scalar *a) {\n-#ifdef USE_ASM_X86_64\n-    __asm__ __volatile__(\n-    /* Preload */\n-    \"movq 0(%%rdi), %%r11\\n\"\n-    \"movq 8(%%rdi), %%r12\\n\"\n-    \"movq 16(%%rdi), %%r13\\n\"\n-    \"movq 24(%%rdi), %%r14\\n\"\n-    /* (rax,rdx) = a0 * a0 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r11\\n\"\n-    /* Extract l0 */\n-    \"movq %%rax, 0(%%rsi)\\n\"\n-    /* (r8,r9,r10) = (rdx,0) */\n-    \"movq %%rdx, %%r8\\n\"\n-    \"xorq %%r9, %%r9\\n\"\n-    \"xorq %%r10, %%r10\\n\"\n-    /* (r8,r9,r10) += 2 * a0 * a1 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r12\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    /* Extract l1 */\n-    \"movq %%r8, 8(%%rsi)\\n\"\n-    \"xorq %%r8, %%r8\\n\"\n-    /* (r9,r10,r8) += 2 * a0 * a2 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r13\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    /* (r9,r10,r8) += a1 * a1 */\n-    \"movq %%r12, %%rax\\n\"\n-    \"mulq %%r12\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    /* Extract l2 */\n-    \"movq %%r9, 16(%%rsi)\\n\"\n-    \"xorq %%r9, %%r9\\n\"\n-    /* (r10,r8,r9) += 2 * a0 * a3 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    /* (r10,r8,r9) += 2 * a1 * a2 */\n-    \"movq %%r12, %%rax\\n\"\n-    \"mulq %%r13\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    /* Extract l3 */\n-    \"movq %%r10, 24(%%rsi)\\n\"\n-    \"xorq %%r10, %%r10\\n\"\n-    /* (r8,r9,r10) += 2 * a1 * a3 */\n-    \"movq %%r12, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    /* (r8,r9,r10) += a2 * a2 */\n-    \"movq %%r13, %%rax\\n\"\n-    \"mulq %%r13\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    /* Extract l4 */\n-    \"movq %%r8, 32(%%rsi)\\n\"\n-    \"xorq %%r8, %%r8\\n\"\n-    /* (r9,r10,r8) += 2 * a2 * a3 */\n-    \"movq %%r13, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    /* Extract l5 */\n-    \"movq %%r9, 40(%%rsi)\\n\"\n-    /* (r10,r8) += a3 * a3 */\n-    \"movq %%r14, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    /* Extract l6 */\n-    \"movq %%r10, 48(%%rsi)\\n\"\n-    /* Extract l7 */\n-    \"movq %%r8, 56(%%rsi)\\n\"\n-    :\n-    : \"S\"(l), \"D\"(a->d)\n-    : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"cc\", \"memory\");\n-#else\n-    /* 160 bit accumulator. */\n-    uint64_t c0 = 0, c1 = 0;\n-    uint32_t c2 = 0;\n-\n-    /* l[0..7] = a[0..3] * b[0..3]. */\n-    muladd_fast(a->d[0], a->d[0]);\n-    extract_fast(l[0]);\n-    muladd2(a->d[0], a->d[1]);\n-    extract(l[1]);\n-    muladd2(a->d[0], a->d[2]);\n-    muladd(a->d[1], a->d[1]);\n-    extract(l[2]);\n-    muladd2(a->d[0], a->d[3]);\n-    muladd2(a->d[1], a->d[2]);\n-    extract(l[3]);\n-    muladd2(a->d[1], a->d[3]);\n-    muladd(a->d[2], a->d[2]);\n-    extract(l[4]);\n-    muladd2(a->d[2], a->d[3]);\n-    extract(l[5]);\n-    muladd_fast(a->d[3], a->d[3]);\n-    extract_fast(l[6]);\n-    VERIFY_CHECK(c1 == 0);\n-    l[7] = c0;\n-#endif\n-}\n-\n #undef sumadd\n #undef sumadd_fast\n #undef muladd\n #undef muladd_fast\n-#undef muladd2\n #undef extract\n #undef extract_fast\n \n@@ -906,12 +748,6 @@ static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n     return ret;\n }\n \n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n-    uint64_t l[8];\n-    secp256k1_scalar_sqr_512(l, a);\n-    secp256k1_scalar_reduce_512(r, l);\n-}\n-\n static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n     r1->d[0] = k->d[0];\n     r1->d[1] = k->d[1];\n@@ -955,4 +791,78 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n }\n \n+static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n+\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n+\n+    r->d[0] = a0      | a1 << 62;\n+    r->d[1] = a1 >> 2 | a2 << 60;\n+    r->d[2] = a2 >> 4 | a3 << 58;\n+    r->d[3] = a3 >> 6 | a4 << 56;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_scalar *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\n+#endif\n+\n+    r->v[0] =  a0                   & M62;\n+    r->v[1] = (a0 >> 62 | a1 <<  2) & M62;\n+    r->v[2] = (a1 >> 60 | a2 <<  4) & M62;\n+    r->v[3] = (a2 >> 58 | a3 <<  6) & M62;\n+    r->v[4] =  a3 >> 56;\n+}\n+\n+static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_scalar = {\n+    {{0x3FD25E8CD0364141LL, 0x2ABB739ABD2280EELL, -0x15LL, 0, 256}},\n+    0x34F20099AA774EC1LL\n+};\n+\n+static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv64_signed62 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed62(&s, x);\n+    secp256k1_modinv64(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv64_signed62 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed62(&s, x);\n+    secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(a->d[0] & 1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "17863ef93710bd8e6b3df64cf741207ed5452efd",
        "filename": "src/scalar_8x32.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_8x32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_8x32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_H\n #define SECP256K1_SCALAR_REPR_H"
      },
      {
        "sha": "62c7ae7156d37cfb57c580ab9e438ddea05f2fbd",
        "filename": "src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 95,
        "deletions": 94,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,12 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include \"modinv32_impl.h\"\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint32_t)0xD0364141UL)\n #define SECP256K1_N_1 ((uint32_t)0xBFD25E8CUL)\n@@ -291,28 +293,6 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n     VERIFY_CHECK(c1 >= th); \\\n }\n \n-/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n-#define muladd2(a,b) { \\\n-    uint32_t tl, th, th2, tl2; \\\n-    { \\\n-        uint64_t t = (uint64_t)a * b; \\\n-        th = t >> 32;               /* at most 0xFFFFFFFE */ \\\n-        tl = t; \\\n-    } \\\n-    th2 = th + th;                  /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n-    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n-    tl2 = tl + tl;                  /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n-    th2 += (tl2 < tl);              /* at most 0xFFFFFFFF */ \\\n-    c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n-    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n-    c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n-}\n-\n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n@@ -576,71 +556,10 @@ static void secp256k1_scalar_mul_512(uint32_t *l, const secp256k1_scalar *a, con\n     l[15] = c0;\n }\n \n-static void secp256k1_scalar_sqr_512(uint32_t *l, const secp256k1_scalar *a) {\n-    /* 96 bit accumulator. */\n-    uint32_t c0 = 0, c1 = 0, c2 = 0;\n-\n-    /* l[0..15] = a[0..7]^2. */\n-    muladd_fast(a->d[0], a->d[0]);\n-    extract_fast(l[0]);\n-    muladd2(a->d[0], a->d[1]);\n-    extract(l[1]);\n-    muladd2(a->d[0], a->d[2]);\n-    muladd(a->d[1], a->d[1]);\n-    extract(l[2]);\n-    muladd2(a->d[0], a->d[3]);\n-    muladd2(a->d[1], a->d[2]);\n-    extract(l[3]);\n-    muladd2(a->d[0], a->d[4]);\n-    muladd2(a->d[1], a->d[3]);\n-    muladd(a->d[2], a->d[2]);\n-    extract(l[4]);\n-    muladd2(a->d[0], a->d[5]);\n-    muladd2(a->d[1], a->d[4]);\n-    muladd2(a->d[2], a->d[3]);\n-    extract(l[5]);\n-    muladd2(a->d[0], a->d[6]);\n-    muladd2(a->d[1], a->d[5]);\n-    muladd2(a->d[2], a->d[4]);\n-    muladd(a->d[3], a->d[3]);\n-    extract(l[6]);\n-    muladd2(a->d[0], a->d[7]);\n-    muladd2(a->d[1], a->d[6]);\n-    muladd2(a->d[2], a->d[5]);\n-    muladd2(a->d[3], a->d[4]);\n-    extract(l[7]);\n-    muladd2(a->d[1], a->d[7]);\n-    muladd2(a->d[2], a->d[6]);\n-    muladd2(a->d[3], a->d[5]);\n-    muladd(a->d[4], a->d[4]);\n-    extract(l[8]);\n-    muladd2(a->d[2], a->d[7]);\n-    muladd2(a->d[3], a->d[6]);\n-    muladd2(a->d[4], a->d[5]);\n-    extract(l[9]);\n-    muladd2(a->d[3], a->d[7]);\n-    muladd2(a->d[4], a->d[6]);\n-    muladd(a->d[5], a->d[5]);\n-    extract(l[10]);\n-    muladd2(a->d[4], a->d[7]);\n-    muladd2(a->d[5], a->d[6]);\n-    extract(l[11]);\n-    muladd2(a->d[5], a->d[7]);\n-    muladd(a->d[6], a->d[6]);\n-    extract(l[12]);\n-    muladd2(a->d[6], a->d[7]);\n-    extract(l[13]);\n-    muladd_fast(a->d[7], a->d[7]);\n-    extract_fast(l[14]);\n-    VERIFY_CHECK(c1 == 0);\n-    l[15] = c0;\n-}\n-\n #undef sumadd\n #undef sumadd_fast\n #undef muladd\n #undef muladd_fast\n-#undef muladd2\n #undef extract\n #undef extract_fast\n \n@@ -666,12 +585,6 @@ static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n     return ret;\n }\n \n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n-    uint32_t l[16];\n-    secp256k1_scalar_sqr_512(l, a);\n-    secp256k1_scalar_reduce_512(r, l);\n-}\n-\n static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n     r1->d[0] = k->d[0];\n     r1->d[1] = k->d[1];\n@@ -731,4 +644,92 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[7] = (r->d[7] & mask0) | (a->d[7] & mask1);\n }\n \n+static void secp256k1_scalar_from_signed30(secp256k1_scalar *r, const secp256k1_modinv32_signed30 *a) {\n+    const uint32_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4],\n+                   a5 = a->v[5], a6 = a->v[6], a7 = a->v[7], a8 = a->v[8];\n+\n+    /* The output from secp256k1_modinv32{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^30). The modulus is < 2^256, so the top limb must be below 2^(256-30*8).\n+     */\n+    VERIFY_CHECK(a0 >> 30 == 0);\n+    VERIFY_CHECK(a1 >> 30 == 0);\n+    VERIFY_CHECK(a2 >> 30 == 0);\n+    VERIFY_CHECK(a3 >> 30 == 0);\n+    VERIFY_CHECK(a4 >> 30 == 0);\n+    VERIFY_CHECK(a5 >> 30 == 0);\n+    VERIFY_CHECK(a6 >> 30 == 0);\n+    VERIFY_CHECK(a7 >> 30 == 0);\n+    VERIFY_CHECK(a8 >> 16 == 0);\n+\n+    r->d[0] = a0       | a1 << 30;\n+    r->d[1] = a1 >>  2 | a2 << 28;\n+    r->d[2] = a2 >>  4 | a3 << 26;\n+    r->d[3] = a3 >>  6 | a4 << 24;\n+    r->d[4] = a4 >>  8 | a5 << 22;\n+    r->d[5] = a5 >> 10 | a6 << 20;\n+    r->d[6] = a6 >> 12 | a7 << 18;\n+    r->d[7] = a7 >> 14 | a8 << 16;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_to_signed30(secp256k1_modinv32_signed30 *r, const secp256k1_scalar *a) {\n+    const uint32_t M30 = UINT32_MAX >> 2;\n+    const uint32_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3],\n+                   a4 = a->d[4], a5 = a->d[5], a6 = a->d[6], a7 = a->d[7];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\n+#endif\n+\n+    r->v[0] =  a0                   & M30;\n+    r->v[1] = (a0 >> 30 | a1 <<  2) & M30;\n+    r->v[2] = (a1 >> 28 | a2 <<  4) & M30;\n+    r->v[3] = (a2 >> 26 | a3 <<  6) & M30;\n+    r->v[4] = (a3 >> 24 | a4 <<  8) & M30;\n+    r->v[5] = (a4 >> 22 | a5 << 10) & M30;\n+    r->v[6] = (a5 >> 20 | a6 << 12) & M30;\n+    r->v[7] = (a6 >> 18 | a7 << 14) & M30;\n+    r->v[8] =  a7 >> 16;\n+}\n+\n+static const secp256k1_modinv32_modinfo secp256k1_const_modinfo_scalar = {\n+    {{0x10364141L, 0x3F497A33L, 0x348A03BBL, 0x2BB739ABL, -0x146L, 0, 0, 0, 65536}},\n+    0x2A774EC1L\n+};\n+\n+static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv32_signed30 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed30(&s, x);\n+    secp256k1_modinv32(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed30(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv32_signed30 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed30(&s, x);\n+    secp256k1_modinv32_var(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed30(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(a->d[0] & 1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "e124474773c3e320867369ea1c161efb6d59562c",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 224,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n@@ -31,231 +31,12 @@\n static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n static const secp256k1_scalar secp256k1_scalar_zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n \n-#ifndef USE_NUM_NONE\n-static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a) {\n-    unsigned char c[32];\n-    secp256k1_scalar_get_b32(c, a);\n-    secp256k1_num_set_bin(r, c, 32);\n-}\n-\n-/** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */\n-static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n-#if defined(EXHAUSTIVE_TEST_ORDER)\n-    static const unsigned char order[32] = {\n-        0,0,0,0,0,0,0,0,\n-        0,0,0,0,0,0,0,0,\n-        0,0,0,0,0,0,0,0,\n-        0,0,0,0,0,0,0,EXHAUSTIVE_TEST_ORDER\n-    };\n-#else\n-    static const unsigned char order[32] = {\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n-        0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n-        0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n-    };\n-#endif\n-    secp256k1_num_set_bin(r, order, 32);\n-}\n-#endif\n-\n static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin) {\n     int overflow;\n     secp256k1_scalar_set_b32(r, bin, &overflow);\n     return (!overflow) & (!secp256k1_scalar_is_zero(r));\n }\n \n-static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-#if defined(EXHAUSTIVE_TEST_ORDER)\n-    int i;\n-    *r = 0;\n-    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n-        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n-            *r = i;\n-    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n-     * have a composite group order; fix it in exhaustive_tests.c). */\n-    VERIFY_CHECK(*r != 0);\n-}\n-#else\n-    secp256k1_scalar *t;\n-    int i;\n-    /* First compute xN as x ^ (2^N - 1) for some values of N,\n-     * and uM as x ^ M for some values of M. */\n-    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n-    secp256k1_scalar u2, u5, u9, u11, u13;\n-\n-    secp256k1_scalar_sqr(&u2, x);\n-    secp256k1_scalar_mul(&x2, &u2,  x);\n-    secp256k1_scalar_mul(&u5, &u2, &x2);\n-    secp256k1_scalar_mul(&x3, &u5,  &u2);\n-    secp256k1_scalar_mul(&u9, &x3, &u2);\n-    secp256k1_scalar_mul(&u11, &u9, &u2);\n-    secp256k1_scalar_mul(&u13, &u11, &u2);\n-\n-    secp256k1_scalar_sqr(&x6, &u13);\n-    secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &u11);\n-\n-    secp256k1_scalar_sqr(&x8, &x6);\n-    secp256k1_scalar_sqr(&x8, &x8);\n-    secp256k1_scalar_mul(&x8, &x8,  &x2);\n-\n-    secp256k1_scalar_sqr(&x14, &x8);\n-    for (i = 0; i < 5; i++) {\n-        secp256k1_scalar_sqr(&x14, &x14);\n-    }\n-    secp256k1_scalar_mul(&x14, &x14, &x6);\n-\n-    secp256k1_scalar_sqr(&x28, &x14);\n-    for (i = 0; i < 13; i++) {\n-        secp256k1_scalar_sqr(&x28, &x28);\n-    }\n-    secp256k1_scalar_mul(&x28, &x28, &x14);\n-\n-    secp256k1_scalar_sqr(&x56, &x28);\n-    for (i = 0; i < 27; i++) {\n-        secp256k1_scalar_sqr(&x56, &x56);\n-    }\n-    secp256k1_scalar_mul(&x56, &x56, &x28);\n-\n-    secp256k1_scalar_sqr(&x112, &x56);\n-    for (i = 0; i < 55; i++) {\n-        secp256k1_scalar_sqr(&x112, &x112);\n-    }\n-    secp256k1_scalar_mul(&x112, &x112, &x56);\n-\n-    secp256k1_scalar_sqr(&x126, &x112);\n-    for (i = 0; i < 13; i++) {\n-        secp256k1_scalar_sqr(&x126, &x126);\n-    }\n-    secp256k1_scalar_mul(&x126, &x126, &x14);\n-\n-    /* Then accumulate the final result (t starts at x126). */\n-    t = &x126;\n-    for (i = 0; i < 3; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 5; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n-    for (i = 0; i < 4; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 5; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 6; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 3; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 5; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n-    for (i = 0; i < 6; i++) { /* 000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 10; i++) { /* 0000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 9; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 5; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n-    for (i = 0; i < 6; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n-    for (i = 0; i < 4; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 5; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 6; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 10; i++) { /* 000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 4; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n-    for (i = 0; i < 6; i++) { /* 00000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(r, t, &x6); /* 111111 */\n-}\n-\n-SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n-    return !(a->d[0] & 1);\n-}\n-#endif\n-\n-static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-#if defined(USE_SCALAR_INV_BUILTIN)\n-    secp256k1_scalar_inverse(r, x);\n-#elif defined(USE_SCALAR_INV_NUM)\n-    unsigned char b[32];\n-    secp256k1_num n, m;\n-    secp256k1_scalar t = *x;\n-    secp256k1_scalar_get_b32(b, &t);\n-    secp256k1_num_set_bin(&n, b, 32);\n-    secp256k1_scalar_order_get_num(&m);\n-    secp256k1_num_mod_inverse(&n, &n, &m);\n-    secp256k1_num_get_bin(b, 32, &n);\n-    secp256k1_scalar_set_b32(r, b, NULL);\n-    /* Verify that the inverse was computed correctly, without GMP code. */\n-    secp256k1_scalar_mul(&t, &t, r);\n-    CHECK(secp256k1_scalar_is_one(&t));\n-#else\n-#error \"Please select scalar inverse implementation\"\n-#endif\n-}\n-\n /* These parameters are generated using sage/gen_exhaustive_groups.sage. */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 13"
      },
      {
        "sha": "67051bd30b788b59a45d6e044a41e1e075681c56",
        "filename": "src/scalar_low.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_H\n #define SECP256K1_SCALAR_REPR_H"
      },
      {
        "sha": "7176f0b2caeab0c8fbb7cd2b5d7755ff24260857",
        "filename": "src/scalar_low_impl.h",
        "status": "modified",
        "additions": 20,
        "deletions": 9,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n@@ -104,10 +104,6 @@ static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n     return ret;\n }\n \n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n-    *r = (*a * *a) % EXHAUSTIVE_TEST_ORDER;\n-}\n-\n static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n     *r1 = *a;\n     *r2 = 0;\n@@ -125,4 +121,19 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     *r = (*r & mask0) | (*a & mask1);\n }\n \n+static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n+        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n+            *r = i;\n+    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n+     * have a composite group order; fix it in exhaustive_tests.c). */\n+    VERIFY_CHECK(*r != 0);\n+}\n+\n+static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_scalar_inverse(r, x);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "9dcb7581f6fc426c4a29c1b0610c12506394921e",
        "filename": "src/scratch.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2017 Andrew Poelstra\t                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef _SECP256K1_SCRATCH_\n-#define _SECP256K1_SCRATCH_\n+/***********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_SCRATCH_H\n+#define SECP256K1_SCRATCH_H\n \n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */"
      },
      {
        "sha": "688e18eb6620889b1ac3de4c3e79d8f0e83408ba",
        "filename": "src/scratch_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2017 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_SCRATCH_IMPL_H_\n-#define _SECP256K1_SCRATCH_IMPL_H_\n+#ifndef SECP256K1_SCRATCH_IMPL_H\n+#define SECP256K1_SCRATCH_IMPL_H\n \n #include \"util.h\"\n #include \"scratch.h\""
      },
      {
        "sha": "aef3f99ac3b39e88d8665c24714235a237191c2d",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 41,
        "deletions": 40,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,15 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_preallocated.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n-#include \"num_impl.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -86,6 +85,8 @@ const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_pr\n \n size_t secp256k1_context_preallocated_size(unsigned int flags) {\n     size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    /* A return value of 0 is reserved as an indicator for errors when we call this function internally. */\n+    VERIFY_CHECK(ret != 0);\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&default_illegal_callback,\n@@ -122,21 +123,21 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     if (!secp256k1_selftest()) {\n         secp256k1_callback_call(&default_error_callback, \"self test failed\");\n     }\n-    VERIFY_CHECK(prealloc != NULL);\n+\n     prealloc_size = secp256k1_context_preallocated_size(flags);\n+    if (prealloc_size == 0) {\n+        return NULL;\n+    }\n+    VERIFY_CHECK(prealloc != NULL);\n     ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n-    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n-            secp256k1_callback_call(&ret->illegal_callback,\n-                                    \"Invalid flags\");\n-            return NULL;\n-    }\n-\n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n+    /* Flags have been checked by secp256k1_context_preallocated_size. */\n+    VERIFY_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_CONTEXT);\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n@@ -420,17 +421,17 @@ int secp256k1_ecdsa_signature_normalize(const secp256k1_context* ctx, secp256k1_\n     return ret;\n }\n \n-int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msg32, const secp256k1_pubkey *pubkey) {\n+int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey) {\n     secp256k1_ge q;\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n-    secp256k1_scalar_set_b32(&m, msg32, NULL);\n+    secp256k1_scalar_set_b32(&m, msghash32, NULL);\n     secp256k1_ecdsa_signature_load(ctx, &r, &s, sig);\n     return (!secp256k1_scalar_is_high(&s) &&\n             secp256k1_pubkey_load(ctx, &q, pubkey) &&\n@@ -531,16 +532,16 @@ static int secp256k1_ecdsa_sign_inner(const secp256k1_context* ctx, secp256k1_sc\n     return ret;\n }\n \n-int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n+int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar r, s;\n     int ret;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, NULL, msg32, seckey, noncefp, noncedata);\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, NULL, msghash32, seckey, noncefp, noncedata);\n     secp256k1_ecdsa_signature_save(signature, &r, &s);\n     return ret;\n }\n@@ -580,7 +581,7 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n \n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey);\n     secp256k1_pubkey_save(pubkey, &p);\n-    memczero(pubkey, sizeof(*pubkey), !ret);\n+    secp256k1_memczero(pubkey, sizeof(*pubkey), !ret);\n \n     secp256k1_scalar_clear(&seckey_scalar);\n     return ret;\n@@ -621,72 +622,72 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n }\n \n \n-static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n     int ret = 0;\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n     ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n     secp256k1_scalar_clear(&term);\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n     secp256k1_scalar sec;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak32);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n-    return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak);\n+int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n+    return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak32);\n }\n \n-static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak) {\n+static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n     return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n }\n \n-int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n-    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak);\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak32);\n     if (ret) {\n         secp256k1_pubkey_save(pubkey, &p);\n     }\n \n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n     secp256k1_scalar factor;\n     secp256k1_scalar sec;\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n-    secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n     ret &= (!overflow) & secp256k1_eckey_privkey_tweak_mul(&sec, &factor);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n@@ -697,21 +698,21 @@ int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *s\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n-    return secp256k1_ec_seckey_tweak_mul(ctx, seckey, tweak);\n+int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n+    return secp256k1_ec_seckey_tweak_mul(ctx, seckey, tweak32);\n }\n \n-int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     secp256k1_scalar factor;\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n-    secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n     if (ret) {"
      },
      {
        "sha": "52f1b8442e7124f3a2e39bfdc8db0072022c1d59",
        "filename": "src/selftest.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/selftest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/selftest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/selftest.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SELFTEST_H\n #define SECP256K1_SELFTEST_H"
      },
      {
        "sha": "667d1867bd61548fc063cf14c1be06e9c8e4e581",
        "filename": "src/testrand.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/testrand.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/testrand.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_TESTRAND_H\n #define SECP256K1_TESTRAND_H"
      },
      {
        "sha": "e643778f36b1e33fd38f3839dfd4e9b6915628af",
        "filename": "src/testrand_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand_impl.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_TESTRAND_IMPL_H\n #define SECP256K1_TESTRAND_IMPL_H"
      },
      {
        "sha": "a146394305cb67f07faa998b17fb3ba095a3d372",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 1257,
        "deletions": 472,
        "changes": 1729,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2"
      },
      {
        "sha": "2bb5381446ed2a70c2021fa6e240911592756839",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n /***********************************************************************\n- * Copyright (c) 2016 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+ * Copyright (c) 2016 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "f78846836cf25e5abc1bb44015a0ca7b17c5386d",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 80,
        "deletions": 9,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_UTIL_H\n #define SECP256K1_UTIL_H\n@@ -113,7 +113,7 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n #define ALIGNMENT 16\n #endif\n \n-#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+#define ROUND_TO_ALIGN(size) ((((size) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n \n /* Assume there is a contiguous memory object with bounds [base, base + max_size)\n  * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n@@ -141,7 +141,7 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n     VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n     VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n     ret = *prealloc_ptr;\n-    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    *prealloc_ptr = (unsigned char*)*prealloc_ptr + aligned_alloc_size;\n     return ret;\n }\n \n@@ -202,7 +202,7 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n #endif\n \n /* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n-static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n+static SECP256K1_INLINE void secp256k1_memczero(void *s, size_t len, int flag) {\n     unsigned char *p = (unsigned char *)s;\n     /* Access flag with a volatile-qualified lvalue.\n        This prevents clang from figuring out (after inlining) that flag can\n@@ -260,14 +260,85 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n # define SECP256K1_WIDEMUL_INT128 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n # define SECP256K1_WIDEMUL_INT64 1\n-#elif defined(__SIZEOF_INT128__)\n+#elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n # define SECP256K1_WIDEMUL_INT128 1\n #else\n # define SECP256K1_WIDEMUL_INT64 1\n #endif\n #if defined(SECP256K1_WIDEMUL_INT128)\n+# if !defined(UINT128_MAX) && defined(__SIZEOF_INT128__)\n SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n SECP256K1_GNUC_EXT typedef __int128 int128_t;\n+#define UINT128_MAX ((uint128_t)(-1))\n+#define INT128_MAX ((int128_t)(UINT128_MAX >> 1))\n+#define INT128_MIN (-INT128_MAX - 1)\n+/* No (U)INT128_C macros because compilers providing __int128 do not support 128-bit literals.  */\n+# endif\n+#endif\n+\n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x.\n+ * This function is only intended to be used as fallback for\n+ * secp256k1_ctz32_var, but permits it to be tested separately. */\n+static SECP256K1_INLINE int secp256k1_ctz32_var_debruijn(uint32_t x) {\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x.\n+ * This function is only intended to be used as fallback for\n+ * secp256k1_ctz64_var, but permits it to be tested separately. */\n+static SECP256K1_INLINE int secp256k1_ctz64_var_debruijn(uint64_t x) {\n+    static const uint8_t debruijn[64] = {\n+        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,\n+        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,\n+        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\n+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n+    };\n+    return debruijn[((x & -x) * 0x022FDD63CC95386D) >> 58];\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n #endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    return secp256k1_ctz32_var_debruijn(x);\n+#endif\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz64_var(uint64_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned long type is sufficient to represent the largest uint64_t, consider __builtin_ctzl. */\n+    if (((unsigned long)UINT64_MAX) == UINT64_MAX) {\n+        return __builtin_ctzl(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzll) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzll (the unsigned long long type is always at least 64 bits). */\n+    return __builtin_ctzll(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    return secp256k1_ctz64_var_debruijn(x);\n+#endif\n+}\n \n #endif /* SECP256K1_UTIL_H */"
      },
      {
        "sha": "cfca5a196e0cad9718451945d4169852f9956d0a",
        "filename": "src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 47,
        "deletions": 31,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdca9bcb6c9379707d09c63f02326884befbefb2/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdca9bcb6c9379707d09c63f02326884befbefb2/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/valgrind_ctime_test.c?ref=bdca9bcb6c9379707d09c63f02326884befbefb2",
        "patch": "@@ -1,10 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Gregory Maxwell                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Gregory Maxwell                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <valgrind/memcheck.h>\n+#include <stdio.h>\n+\n #include \"include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -25,16 +27,49 @@\n #include \"include/secp256k1_schnorrsig.h\"\n #endif\n \n+void run_tests(secp256k1_context *ctx, unsigned char *key);\n+\n int main(void) {\n     secp256k1_context* ctx;\n+    unsigned char key[32];\n+    int ret, i;\n+\n+    if (!RUNNING_ON_VALGRIND) {\n+        fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n+        fprintf(stderr, \"Usage: libtool --mode=execute valgrind ./valgrind_ctime_test\\n\");\n+        return 1;\n+    }\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN\n+                                   | SECP256K1_CONTEXT_VERIFY\n+                                   | SECP256K1_CONTEXT_DECLASSIFY);\n+    /** In theory, testing with a single secret input should be sufficient:\n+     *  If control flow depended on secrets the tool would generate an error.\n+     */\n+    for (i = 0; i < 32; i++) {\n+        key[i] = i + 65;\n+    }\n+\n+    run_tests(ctx, key);\n+\n+    /* Test context randomisation. Do this last because it leaves the context\n+     * tainted. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_context_randomize(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+\n+    secp256k1_context_destroy(ctx);\n+    return 0;\n+}\n+\n+void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     secp256k1_ecdsa_signature signature;\n     secp256k1_pubkey pubkey;\n     size_t siglen = 74;\n     size_t outputlen = 33;\n     int i;\n     int ret;\n     unsigned char msg[32];\n-    unsigned char key[32];\n     unsigned char sig[74];\n     unsigned char spubkey[33];\n #ifdef ENABLE_MODULE_RECOVERY\n@@ -45,26 +80,10 @@ int main(void) {\n     secp256k1_keypair keypair;\n #endif\n \n-    if (!RUNNING_ON_VALGRIND) {\n-        fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n-        fprintf(stderr, \"Usage: libtool --mode=execute valgrind ./valgrind_ctime_test\\n\");\n-        exit(1);\n-    }\n-\n-    /** In theory, testing with a single secret input should be sufficient:\n-     *  If control flow depended on secrets the tool would generate an error.\n-     */\n-    for (i = 0; i < 32; i++) {\n-        key[i] = i + 65;\n-    }\n     for (i = 0; i < 32; i++) {\n         msg[i] = i + 1;\n     }\n \n-    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN\n-                                   | SECP256K1_CONTEXT_VERIFY\n-                                   | SECP256K1_CONTEXT_DECLASSIFY);\n-\n     /* Test keygen. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_ec_pubkey_create(ctx, &pubkey, key);\n@@ -122,12 +141,6 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n \n-    /* Test context randomisation. Do this last because it leaves the context tainted. */\n-    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n-    ret = secp256k1_context_randomize(ctx, key);\n-    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n-    CHECK(ret);\n-\n     /* Test keypair_create and keypair_xonly_tweak_add. */\n #ifdef ENABLE_MODULE_EXTRAKEYS\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n@@ -140,6 +153,12 @@ int main(void) {\n     ret = secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_UNDEFINED(&keypair, sizeof(keypair));\n+    ret = secp256k1_keypair_sec(ctx, key, &keypair);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n #endif\n \n #ifdef ENABLE_MODULE_SCHNORRSIG\n@@ -151,7 +170,4 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n-\n-    secp256k1_context_destroy(ctx);\n-    return 0;\n }"
      }
    ]
  },
  {
    "sha": "a5a447a352463c7b75752aa08b6d9cb46aa051ea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNWE0NDdhMzUyNDYzYzdiNzU3NTJhYTA4YjZkOWNiNDZhYTA1MWVh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-23T18:35:15Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-23T18:35:15Z"
      },
      "message": "Update libsecp256k1 subtree to latest upstream master",
      "tree": {
        "sha": "16b3dcf91f6f1fe7b8e9ec62ed76b12631edbf6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/16b3dcf91f6f1fe7b8e9ec62ed76b12631edbf6f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a5a447a352463c7b75752aa08b6d9cb46aa051ea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5a447a352463c7b75752aa08b6d9cb46aa051ea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a5a447a352463c7b75752aa08b6d9cb46aa051ea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5a447a352463c7b75752aa08b6d9cb46aa051ea/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cabb5661234f8d832dbc3b65bf80b0acc02db0a0"
      },
      {
        "sha": "bdca9bcb6c9379707d09c63f02326884befbefb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdca9bcb6c9379707d09c63f02326884befbefb2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdca9bcb6c9379707d09c63f02326884befbefb2"
      }
    ],
    "stats": {
      "total": 7321,
      "additions": 4865,
      "deletions": 2456
    },
    "files": [
      {
        "sha": "506a86033635412bf259eaa08010cde3708df49c",
        "filename": "src/secp256k1/.cirrus.yml",
        "status": "added",
        "additions": 198,
        "deletions": 0,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.cirrus.yml?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,198 @@\n+env:\n+  WIDEMUL: auto\n+  STATICPRECOMPUTATION: yes\n+  ECMULTGENPRECISION: auto\n+  ASM: no\n+  BUILD: check\n+  WITH_VALGRIND: yes\n+  RUN_VALGRIND: no\n+  EXTRAFLAGS:\n+  HOST:\n+  ECDH: no\n+  RECOVERY: no\n+  SCHNORRSIG: no\n+  EXPERIMENTAL: no\n+  CTIMETEST: yes\n+  BENCH: yes\n+  ITERS: 2\n+  MAKEFLAGS: -j2\n+\n+cat_logs_snippet: &CAT_LOGS\n+  always:\n+    cat_tests_log_script:\n+      - cat tests.log || true\n+    cat_exhaustive_tests_log_script:\n+      - cat exhaustive_tests.log || true\n+    cat_valgrind_ctime_test_log_script:\n+      - cat valgrind_ctime_test.log || true\n+    cat_bench_log_script:\n+      - cat bench.log || true\n+  on_failure:\n+    cat_config_log_script:\n+      - cat config.log || true\n+    cat_test_env_script:\n+      - cat test_env.log || true\n+    cat_ci_env_script:\n+      - env\n+\n+merge_base_script_snippet: &MERGE_BASE\n+  merge_base_script:\n+    - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n+    - git fetch $CIRRUS_REPO_CLONE_URL $CIRRUS_BASE_BRANCH\n+    - git config --global user.email \"ci@ci.ci\"\n+    - git config --global user.name \"ci\"\n+    - git merge FETCH_HEAD  # Merge base to detect silent merge conflicts\n+\n+task:\n+  name: \"x86_64: Linux (Debian stable)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    # Reduce number of CPUs to be able to do more builds in parallel.\n+    cpu: 1\n+    # More than enough for our scripts.\n+    memory: 1G\n+  matrix: &ENV_MATRIX\n+    - env: {WIDEMUL:  int64,  RECOVERY: yes}\n+    - env: {WIDEMUL:  int64,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128}\n+    - env: {WIDEMUL: int128,  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128,  ASM: x86_64}\n+    - env: {                  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {                  STATICPRECOMPUTATION: no}\n+    - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n+    - env: {CPPFLAGS: -DDETERMINISTIC}\n+    - env: {CFLAGS: -O0, CTIMETEST: no}\n+    - env:\n+        CFLAGS:  \"-fsanitize=undefined -fno-omit-frame-pointer\"\n+        LDFLAGS: \"-fsanitize=undefined -fno-omit-frame-pointer\"\n+        UBSAN_OPTIONS: \"print_stacktrace=1:halt_on_error=1\"\n+        ASM: x86_64\n+        ECDH: yes\n+        RECOVERY: yes\n+        EXPERIMENTAL: yes\n+        SCHNORRSIG: yes\n+        CTIMETEST: no\n+    - env: { ECMULTGENPRECISION: 2 }\n+    - env: { ECMULTGENPRECISION: 8 }\n+    - env:\n+        RUN_VALGRIND: yes\n+        ASM: x86_64\n+        ECDH: yes\n+        RECOVERY: yes\n+        EXPERIMENTAL: yes\n+        SCHNORRSIG: yes\n+        EXTRAFLAGS: \"--disable-openssl-tests\"\n+        BUILD:\n+  matrix:\n+    - env:\n+        CC: gcc\n+    - env:\n+        CC: clang\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"i686: Linux (Debian stable)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    HOST: i686-linux-gnu\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+  matrix:\n+    - env:\n+        CC: i686-linux-gnu-gcc\n+    - env:\n+        CC: clang --target=i686-pc-linux-gnu -isystem /usr/i686-linux-gnu/include\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"x86_64: macOS Catalina\"\n+  macos_instance:\n+    image: catalina-base\n+  env:\n+    HOMEBREW_NO_AUTO_UPDATE: 1\n+    HOMEBREW_NO_INSTALL_CLEANUP: 1\n+    # Cirrus gives us a fixed number of 12 virtual CPUs. Not that we even have that many jobs at the moment...\n+    MAKEFLAGS: -j13\n+  matrix:\n+    << : *ENV_MATRIX\n+  matrix:\n+    - env:\n+        CC: gcc-9\n+    - env:\n+        CC: clang\n+  # Update Command Line Tools\n+  # Uncomment this if the Command Line Tools on the CirrusCI macOS image are too old to brew valgrind.\n+  # See https://apple.stackexchange.com/a/195963 for the implementation.\n+  ## update_clt_script:\n+  ##   - system_profiler SPSoftwareDataType\n+  ##   - touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress\n+  ##   - |-\n+  ##     PROD=$(softwareupdate -l | grep \"*.*Command Line\" | tail -n 1 | awk -F\"*\" '{print $2}' | sed -e 's/^ *//' | sed 's/Label: //g' | tr -d '\\n')\n+  ##   # For debugging\n+  ##   - softwareupdate -l && echo \"PROD: $PROD\"\n+  ##   - softwareupdate -i \"$PROD\" --verbose\n+  ##   - rm /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress\n+  ##\n+  brew_valgrind_pre_script:\n+    - brew config\n+    - brew tap --shallow LouisBrunner/valgrind\n+    # Fetch valgrind source but don't build it yet.\n+    - brew fetch --HEAD LouisBrunner/valgrind/valgrind\n+  brew_valgrind_cache:\n+    # This is $(brew --cellar valgrind) but command substition does not work here.\n+    folder: /usr/local/Cellar/valgrind\n+    # Rebuild cache if ...\n+    fingerprint_script:\n+      # ... macOS version changes:\n+      - sw_vers\n+      # ... brew changes:\n+      - brew config\n+      # ... valgrind changes:\n+      - git -C \"$(brew --cache)/valgrind--git\" rev-parse HEAD\n+    populate_script:\n+      # If there's no hit in the cache, build and install valgrind.\n+      - brew install --HEAD LouisBrunner/valgrind/valgrind\n+  brew_valgrind_post_script:\n+    # If we have restored valgrind from the cache, tell brew to create symlink to the PATH.\n+    # If we haven't restored from cached (and just run brew install), this is a no-op.\n+    - brew link valgrind\n+  brew_script:\n+    - brew install automake libtool gcc@9\n+  << : *MERGE_BASE\n+  test_script:\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS\n+\n+task:\n+  name: \"s390x (big-endian): Linux (Debian stable, QEMU)\"\n+  container:\n+    dockerfile: ci/linux-debian.Dockerfile\n+    cpu: 1\n+    memory: 1G\n+  env:\n+    QEMU_CMD: qemu-s390x\n+    HOST: s390x-linux-gnu\n+    BUILD:\n+    WITH_VALGRIND: no\n+    ECDH: yes\n+    RECOVERY: yes\n+    EXPERIMENTAL: yes\n+    SCHNORRSIG: yes\n+    CTIMETEST: no\n+  << : *MERGE_BASE\n+  test_script:\n+    # https://sourceware.org/bugzilla/show_bug.cgi?id=27008\n+    - rm /etc/ld.so.cache\n+    - ./ci/cirrus.sh\n+  << : *CAT_LOGS"
      },
      {
        "sha": "ce8d6391b2f210318b156066d38a116b8970a502",
        "filename": "src/secp256k1/.travis.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 108,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "patch": "@@ -1,108 +0,0 @@\n-language: c\n-os:\n-  - linux\n-  - osx\n-\n-dist: bionic\n-# Valgrind currently supports upto macOS 10.13, the latest xcode of that version is 10.1\n-osx_image: xcode10.1\n-addons:\n-  apt:\n-    packages:\n-      - libgmp-dev\n-      - valgrind\n-      - libtool-bin\n-compiler:\n-  - clang\n-  - gcc\n-env:\n-  global:\n-    - WIDEMUL=auto  BIGNUM=auto  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  WITH_VALGRIND=yes RUN_VALGRIND=no EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n-  matrix:\n-    - WIDEMUL=int64   RECOVERY=yes\n-    - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128\n-    - WIDEMUL=int128  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128                    ASM=x86_64\n-    - BIGNUM=no\n-    - BIGNUM=no       RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - BIGNUM=no       STATICPRECOMPUTATION=no\n-    - BUILD=distcheck WITH_VALGRIND=no CTIMETEST=no BENCH=no\n-    - CPPFLAGS=-DDETERMINISTIC\n-    - CFLAGS=-O0 CTIMETEST=no\n-    - ECMULTGENPRECISION=2\n-    - ECMULTGENPRECISION=8\n-    - RUN_VALGRIND=yes BIGNUM=no ASM=x86_64 ECDH=yes  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes EXTRAFLAGS=\"--disable-openssl-tests\" BUILD=\n-matrix:\n-  fast_finish: true\n-  include:\n-    - compiler: clang\n-      os: linux\n-      env: HOST=i686-linux-gnu\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - libgmp-dev:i386\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    - compiler: clang\n-      env: HOST=i686-linux-gnu\n-      os: linux\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    - compiler: gcc\n-      env: HOST=i686-linux-gnu\n-      os: linux\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    - compiler: gcc\n-      os: linux\n-      env: HOST=i686-linux-gnu\n-      addons:\n-        apt:\n-          packages:\n-            - gcc-multilib\n-            - libgmp-dev:i386\n-            - valgrind\n-            - libtool-bin\n-            - libc6-dbg:i386\n-    # S390x build (big endian system)\n-    - compiler: gcc\n-      env: HOST=s390x-unknown-linux-gnu ECDH=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes CTIMETEST=\n-      arch: s390x\n-\n-# We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n-# because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes.\n-# https://travis-ci.community/t/macos-build-fails-because-of-homebrew-bundle-unknown-command/7296\n-before_install:\n- - if [ \"${TRAVIS_OS_NAME}\" = \"osx\" ]; then HOMEBREW_NO_AUTO_UPDATE=1 brew install gmp valgrind gcc@9; fi\n-\n-before_script: ./autogen.sh\n-\n-# travis auto terminates jobs that go for 10 minutes without printing to stdout, but travis_wait doesn't work well with forking programs like valgrind (https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received https://github.com/bitcoin-core/secp256k1/pull/750#issuecomment-623476860)\n-script:\n-  - function keep_alive() { while true; do echo -en \"\\a\"; sleep 60; done }\n-  - keep_alive &\n-  - ./contrib/travis.sh\n-  - kill %keep_alive\n-\n-after_script:\n-    - cat ./tests.log\n-    - cat ./exhaustive_tests.log\n-    - cat ./valgrind_ctime_test.log\n-    - cat ./bench.log\n-    - $CC --version\n-    - valgrind --version"
      },
      {
        "sha": "58c9635e53e743c8b192b83e2301857ef766d15d",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -14,8 +14,6 @@ noinst_HEADERS += src/scalar_8x32_impl.h\n noinst_HEADERS += src/scalar_low_impl.h\n noinst_HEADERS += src/group.h\n noinst_HEADERS += src/group_impl.h\n-noinst_HEADERS += src/num_gmp.h\n-noinst_HEADERS += src/num_gmp_impl.h\n noinst_HEADERS += src/ecdsa.h\n noinst_HEADERS += src/ecdsa_impl.h\n noinst_HEADERS += src/eckey.h\n@@ -26,14 +24,16 @@ noinst_HEADERS += src/ecmult_const.h\n noinst_HEADERS += src/ecmult_const_impl.h\n noinst_HEADERS += src/ecmult_gen.h\n noinst_HEADERS += src/ecmult_gen_impl.h\n-noinst_HEADERS += src/num.h\n-noinst_HEADERS += src/num_impl.h\n noinst_HEADERS += src/field_10x26.h\n noinst_HEADERS += src/field_10x26_impl.h\n noinst_HEADERS += src/field_5x52.h\n noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n+noinst_HEADERS += src/modinv32.h\n+noinst_HEADERS += src/modinv32_impl.h\n+noinst_HEADERS += src/modinv64.h\n+noinst_HEADERS += src/modinv64_impl.h\n noinst_HEADERS += src/assumptions.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/scratch.h"
      },
      {
        "sha": "197a56fff842ad854cb26e089ac79b3f39e97dfc",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n+[![Build Status](https://api.cirrus-ci.com/github/bitcoin-core/secp256k1.svg?branch=master)](https://cirrus-ci.com/github/bitcoin-core/secp256k1)\n \n Optimized C library for ECDSA signatures and secret/public key operations on curve secp256k1.\n \n@@ -34,11 +34,11 @@ Implementation details\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n     * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n     * Using 10 26-bit limbs (including hand-optimized assembly for 32-bit ARM, by Wladimir J. van der Laan).\n-  * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n * Scalar operations\n   * Optimized implementation without data-dependent branches of arithmetic modulo the curve's order.\n     * Using 4 64-bit limbs (relying on __int128 support in the compiler).\n     * Using 8 32-bit limbs.\n+* Modular inverses (both field elements and scalars) based on [safegcd](https://gcd.cr.yp.to/index.html) with some modifications, and a variable-time variant (by Peter Dettman).\n * Group operations\n   * Point addition formula specifically simplified for the curve equation (y^2 = x^3 + 7).\n   * Use addition between points in Jacobian and affine coordinates where possible."
      },
      {
        "sha": "7bcbf3200cfa2851c739da25f5c15b6343e76f84",
        "filename": "src/secp256k1/build-aux/m4/ax_prog_cc_for_build.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/build-aux/m4/ax_prog_cc_for_build.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/build-aux/m4/ax_prog_cc_for_build.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/ax_prog_cc_for_build.m4?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,5 +1,5 @@\n # ===========================================================================\n-#   http://www.gnu.org/software/autoconf-archive/ax_prog_cc_for_build.html\n+#   https://www.gnu.org/software/autoconf-archive/ax_prog_cc_for_build.html\n # ===========================================================================\n #\n # SYNOPSIS"
      },
      {
        "sha": "e57888ca18968e8d129a95eab586926a195de0ce",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -75,15 +75,10 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n fi\n ])\n \n-dnl\n-AC_DEFUN([SECP_GMP_CHECK],[\n-if test x\"$has_gmp\" != x\"yes\"; then\n+AC_DEFUN([SECP_VALGRIND_CHECK],[\n+if test x\"$has_valgrind\" != x\"yes\"; then\n   CPPFLAGS_TEMP=\"$CPPFLAGS\"\n-  CPPFLAGS=\"$GMP_CPPFLAGS $CPPFLAGS\"\n-  LIBS_TEMP=\"$LIBS\"\n-  LIBS=\"$GMP_LIBS $LIBS\"\n-  AC_CHECK_HEADER(gmp.h,[AC_CHECK_LIB(gmp, __gmpz_init,[has_gmp=yes; GMP_LIBS=\"$GMP_LIBS -lgmp\"; AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])])])\n-  CPPFLAGS=\"$CPPFLAGS_TEMP\"\n-  LIBS=\"$LIBS_TEMP\"\n+  CPPFLAGS=\"$VALGRIND_CPPFLAGS $CPPFLAGS\"\n+  AC_CHECK_HEADER([valgrind/memcheck.h], [has_valgrind=yes; AC_DEFINE(HAVE_VALGRIND,1,[Define this symbol if valgrind is installed])])\n fi\n ])"
      },
      {
        "sha": "f26ca98d1de39cf37248a0bbad65b221b5d4f615",
        "filename": "src/secp256k1/ci/cirrus.sh",
        "status": "renamed",
        "additions": 35,
        "deletions": 17,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/cirrus.sh?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -3,45 +3,63 @@\n set -e\n set -x\n \n-if [ \"$HOST\" = \"i686-linux-gnu\" ]\n-then\n-    export CC=\"$CC -m32\"\n-fi\n-if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] && [ \"$TRAVIS_COMPILER\" = \"gcc\" ]\n-then\n-    export CC=\"gcc-9\"\n-fi\n+export LC_ALL=C\n+\n+env >> test_env.log\n+\n+$CC -v || true\n+valgrind --version || true\n+\n+./autogen.sh\n \n ./configure \\\n     --enable-experimental=\"$EXPERIMENTAL\" \\\n-    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n+    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n     --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n     --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n     --with-valgrind=\"$WITH_VALGRIND\" \\\n     --host=\"$HOST\" $EXTRAFLAGS\n \n+# We have set \"-j<n>\" in MAKEFLAGS.\n+make\n+\n+# Print information about binaries so that we can see that the architecture is correct\n+file *tests || true\n+file bench_* || true\n+file .libs/* || true\n+\n if [ -n \"$BUILD\" ]\n then\n-    make -j2 \"$BUILD\"\n+    make \"$BUILD\"\n fi\n+\n if [ \"$RUN_VALGRIND\" = \"yes\" ]\n then\n-    make -j2\n-    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (http://valgrind.org/docs/manual/manual-core.html)\n+    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (https://www.valgrind.org/docs/manual/manual-core.html)\n     valgrind --error-exitcode=42 ./tests 16\n     valgrind --error-exitcode=42 ./exhaustive_tests\n fi\n+\n+if [ -n \"$QEMU_CMD\" ]\n+then\n+    $QEMU_CMD ./tests 16\n+    $QEMU_CMD ./exhaustive_tests\n+fi\n+\n if [ \"$BENCH\" = \"yes\" ]\n then\n+    # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n+    EXEC='./libtool --mode=execute'\n+    if [ -n \"$QEMU_CMD\" ]\n+    then\n+       EXEC=\"$EXEC $QEMU_CMD\"\n+    fi\n     if [ \"$RUN_VALGRIND\" = \"yes\" ]\n     then\n-        # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n-        EXEC='./libtool --mode=execute valgrind --error-exitcode=42'\n-    else\n-        EXEC=\n+        EXEC=\"$EXEC valgrind --error-exitcode=42\"\n     fi\n-    # This limits the iterations in the benchmarks below to ITER(set in .travis.yml) iterations.\n+    # This limits the iterations in the benchmarks below to ITER iterations.\n     export SECP256K1_BENCH_ITERS=\"$ITERS\"\n     {\n         $EXEC ./bench_ecmult",
        "previous_filename": "src/secp256k1/contrib/travis.sh"
      },
      {
        "sha": "5967cf8b311606f22ac453f501202ade99fc5ca0",
        "filename": "src/secp256k1/ci/linux-debian.Dockerfile",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/linux-debian.Dockerfile?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,13 @@\n+FROM debian:stable\n+\n+RUN dpkg --add-architecture i386\n+RUN dpkg --add-architecture s390x\n+RUN apt-get update\n+\n+# dkpg-dev: to make pkg-config work in cross-builds\n+RUN apt-get install --no-install-recommends --no-upgrade -y \\\n+        git ca-certificates \\\n+        make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n+        gcc clang libc6-dbg \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 \\\n+        gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x"
      },
      {
        "sha": "1ed991afa771456838cb04c3b1e2cbfbea2359a9",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 147,
        "deletions": 132,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -14,17 +14,24 @@ AM_INIT_AUTOMAKE([foreign subdir-objects])\n : ${CFLAGS=\"-g\"}\n LT_INIT\n \n-dnl make the compilation flags quiet unless V=1 is used\n+# Make the compilation flags quiet unless V=1 is used.\n m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n \n PKG_PROG_PKG_CONFIG\n \n AC_PATH_TOOL(AR, ar)\n AC_PATH_TOOL(RANLIB, ranlib)\n AC_PATH_TOOL(STRIP, strip)\n-AX_PROG_CC_FOR_BUILD\n \n+# Save definition of AC_PROG_CC because AM_PROG_CC_C_O in automake<=1.13 will\n+# redefine AC_PROG_CC to exit with an error, which avoids the user calling it\n+# accidently and screwing up the effect of AM_PROG_CC_C_O. However, we'll need\n+# AC_PROG_CC later on in AX_PROG_CC_FOR_BUILD, where its usage is fine, and\n+# we'll carefully make sure not to call AC_PROG_CC anywhere else.\n+m4_copy([AC_PROG_CC], [saved_AC_PROG_CC])\n AM_PROG_CC_C_O\n+# Restore AC_PROG_CC\n+m4_rename_force([saved_AC_PROG_CC], [AC_PROG_CC])\n \n AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n@@ -37,25 +44,23 @@ case $host_os in\n      if  test x$cross_compiling != xyes; then\n        AC_PATH_PROG([BREW],brew,)\n        if test x$BREW != x; then\n-         dnl These Homebrew packages may be keg-only, meaning that they won't be found\n-         dnl in expected paths because they may conflict with system files. Ask\n-         dnl Homebrew where each one is located, then adjust paths accordingly.\n-\n+         # These Homebrew packages may be keg-only, meaning that they won't be found\n+         # in expected paths because they may conflict with system files. Ask\n+         # Homebrew where each one is located, then adjust paths accordingly.\n          openssl_prefix=`$BREW --prefix openssl 2>/dev/null`\n-         gmp_prefix=`$BREW --prefix gmp 2>/dev/null`\n+         valgrind_prefix=`$BREW --prefix valgrind 2>/dev/null`\n          if test x$openssl_prefix != x; then\n            PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n            export PKG_CONFIG_PATH\n            CRYPTO_CPPFLAGS=\"-I$openssl_prefix/include\"\n          fi\n-         if test x$gmp_prefix != x; then\n-           GMP_CPPFLAGS=\"-I$gmp_prefix/include\"\n-           GMP_LIBS=\"-L$gmp_prefix/lib\"\n+         if test x$valgrind_prefix != x; then\n+           VALGRIND_CPPFLAGS=\"-I$valgrind_prefix/include\"\n          fi\n        else\n          AC_PATH_PROG([PORT],port,)\n-         dnl if homebrew isn't installed and macports is, add the macports default paths\n-         dnl as a last resort.\n+         # If homebrew isn't installed and macports is, add the macports default paths\n+         # as a last resort.\n          if test x$PORT != x; then\n            CPPFLAGS=\"$CPPFLAGS -isystem /opt/local/include\"\n            LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n@@ -77,6 +82,15 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n       CFLAGS=\"$saved_CFLAGS\"\n     ])\n \n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"-Wconditional-uninitialized $CFLAGS\"\n+AC_MSG_CHECKING([if ${CC} supports -Wconditional-uninitialized])\n+AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n+    [ AC_MSG_RESULT([yes]) ],\n+    [ AC_MSG_RESULT([no])\n+      CFLAGS=\"$saved_CFLAGS\"\n+    ])\n+\n saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n@@ -86,6 +100,10 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n       CFLAGS=\"$saved_CFLAGS\"\n     ])\n \n+###\n+### Define config arguments\n+###\n+\n AC_ARG_ENABLE(benchmark,\n     AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n@@ -146,13 +164,10 @@ AC_ARG_ENABLE(external_default_callbacks,\n     [use_external_default_callbacks=$enableval],\n     [use_external_default_callbacks=no])\n \n-dnl Test-only override of the (autodetected by the C code) \"widemul\" setting.\n-dnl Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n+# Test-only override of the (autodetected by the C code) \"widemul\" setting.\n+# Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n AC_ARG_WITH([test-override-wide-multiply], [] ,[set_widemul=$withval], [set_widemul=auto])\n \n-AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n-\n AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n [assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n@@ -177,15 +192,22 @@ AC_ARG_WITH([valgrind], [AS_HELP_STRING([--with-valgrind=yes|no|auto],\n )],\n [req_valgrind=$withval], [req_valgrind=auto])\n \n+###\n+### Handle config options (except for modules)\n+###\n+\n if test x\"$req_valgrind\" = x\"no\"; then\n   enable_valgrind=no\n else\n-  AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [\n+  SECP_VALGRIND_CHECK\n+  if test x\"$has_valgrind\" != x\"yes\"; then\n     if test x\"$req_valgrind\" = x\"yes\"; then\n       AC_MSG_ERROR([Valgrind support explicitly requested but valgrind/memcheck.h header not available])\n     fi\n     enable_valgrind=no\n-  ], [])\n+  else\n+    enable_valgrind=yes\n+  fi\n fi\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n@@ -197,61 +219,6 @@ else\n     CFLAGS=\"-O2 $CFLAGS\"\n fi\n \n-if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n-  # Temporarily switch to an environment for the native compiler\n-  save_cross_compiling=$cross_compiling\n-  cross_compiling=no\n-  SAVE_CC=\"$CC\"\n-  CC=\"$CC_FOR_BUILD\"\n-  SAVE_CFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$CFLAGS_FOR_BUILD\"\n-  SAVE_CPPFLAGS=\"$CPPFLAGS\"\n-  CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n-  SAVE_LDFLAGS=\"$LDFLAGS\"\n-  LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n-\n-  warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n-  saved_CFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n-  AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n-  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n-      [ AC_MSG_RESULT([yes]) ],\n-      [ AC_MSG_RESULT([no])\n-        CFLAGS=\"$saved_CFLAGS\"\n-      ])\n-\n-  AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n-  AC_RUN_IFELSE(\n-    [AC_LANG_PROGRAM([], [])],\n-    [working_native_cc=yes],\n-    [working_native_cc=no],[:])\n-\n-  CFLAGS_FOR_BUILD=\"$CFLAGS\"\n-\n-  # Restore the environment\n-  cross_compiling=$save_cross_compiling\n-  CC=\"$SAVE_CC\"\n-  CFLAGS=\"$SAVE_CFLAGS\"\n-  CPPFLAGS=\"$SAVE_CPPFLAGS\"\n-  LDFLAGS=\"$SAVE_LDFLAGS\"\n-\n-  if test x\"$working_native_cc\" = x\"no\"; then\n-    AC_MSG_RESULT([no])\n-    set_precomp=no\n-    m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n-    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n-      AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n-    else\n-      AC_MSG_WARN([Disabling statically generated ecmult table because the native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n-    fi\n-  else\n-    AC_MSG_RESULT([yes])\n-    set_precomp=yes\n-  fi\n-else\n-  set_precomp=no\n-fi\n-\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -279,33 +246,7 @@ else\n   esac\n fi\n \n-if test x\"$req_bignum\" = x\"auto\"; then\n-  SECP_GMP_CHECK\n-  if test x\"$has_gmp\" = x\"yes\"; then\n-    set_bignum=gmp\n-  fi\n-\n-  if test x\"$set_bignum\" = x; then\n-    set_bignum=no\n-  fi\n-else\n-  set_bignum=$req_bignum\n-  case $set_bignum in\n-  gmp)\n-    SECP_GMP_CHECK\n-    if test x\"$has_gmp\" != x\"yes\"; then\n-      AC_MSG_ERROR([gmp bignum explicitly requested but libgmp not available])\n-    fi\n-    ;;\n-  no)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid bignum implementation selection])\n-    ;;\n-  esac\n-fi\n-\n-# select assembly optimization\n+# Select assembly optimization\n use_external_asm=no\n \n case $set_asm in\n@@ -322,7 +263,12 @@ no)\n   ;;\n esac\n \n-# select wide multiplication implementation\n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+\n+# Select wide multiplication implementation\n case $set_widemul in\n int128)\n   AC_DEFINE(USE_FORCE_WIDEMUL_INT128, 1, [Define this symbol to force the use of the (unsigned) __int128 based wide multiplication implementation])\n@@ -337,25 +283,7 @@ auto)\n   ;;\n esac\n \n-# select bignum implementation\n-case $set_bignum in\n-gmp)\n-  AC_DEFINE(HAVE_LIBGMP, 1, [Define this symbol if libgmp is installed])\n-  AC_DEFINE(USE_NUM_GMP, 1, [Define this symbol to use the gmp implementation for num])\n-  AC_DEFINE(USE_FIELD_INV_NUM, 1, [Define this symbol to use the num-based field inverse implementation])\n-  AC_DEFINE(USE_SCALAR_INV_NUM, 1, [Define this symbol to use the num-based scalar inverse implementation])\n-  ;;\n-no)\n-  AC_DEFINE(USE_NUM_NONE, 1, [Define this symbol to use no num implementation])\n-  AC_DEFINE(USE_FIELD_INV_BUILTIN, 1, [Define this symbol to use the native field inverse implementation])\n-  AC_DEFINE(USE_SCALAR_INV_BUILTIN, 1, [Define this symbol to use the native scalar inverse implementation])\n-  ;;\n-*)\n-  AC_MSG_ERROR([invalid bignum implementation])\n-  ;;\n-esac\n-\n-#set ecmult window size\n+# Set ecmult window size\n if test x\"$req_ecmult_window\" = x\"auto\"; then\n   set_ecmult_window=15\n else\n@@ -377,7 +305,7 @@ case $set_ecmult_window in\n   ;;\n esac\n \n-#set ecmult gen precision\n+# Set ecmult gen precision\n if test x\"$req_ecmult_gen_precision\" = x\"auto\"; then\n   set_ecmult_gen_precision=4\n else\n@@ -419,15 +347,93 @@ else\n   enable_openssl_tests=no\n fi\n \n-if test x\"$set_bignum\" = x\"gmp\"; then\n-  SECP_LIBS=\"$SECP_LIBS $GMP_LIBS\"\n-  SECP_INCLUDES=\"$SECP_INCLUDES $GMP_CPPFLAGS\"\n+if test x\"$enable_valgrind\" = x\"yes\"; then\n+  SECP_INCLUDES=\"$SECP_INCLUDES $VALGRIND_CPPFLAGS\"\n+fi\n+\n+# Handle static precomputation (after everything which modifies CFLAGS and friends)\n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  if test x\"$cross_compiling\" = x\"no\"; then\n+    set_precomp=yes\n+    if test x\"${CC_FOR_BUILD+x}${CFLAGS_FOR_BUILD+x}${CPPFLAGS_FOR_BUILD+x}${LDFLAGS_FOR_BUILD+x}\" != x; then\n+      AC_MSG_WARN([CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD is set but ignored because we are not cross-compiling.])\n+    fi\n+    # If we're not cross-compiling, simply use the same compiler for building the static precompation code.\n+    CC_FOR_BUILD=\"$CC\"\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n+    CPPFLAGS_FOR_BUILD=\"$CPPFLAGS\"\n+    LDFLAGS_FOR_BUILD=\"$LDFLAGS\"\n+  else\n+    AX_PROG_CC_FOR_BUILD\n+\n+    # Temporarily switch to an environment for the native compiler\n+    save_cross_compiling=$cross_compiling\n+    cross_compiling=no\n+    SAVE_CC=\"$CC\"\n+    CC=\"$CC_FOR_BUILD\"\n+    SAVE_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$CFLAGS_FOR_BUILD\"\n+    SAVE_CPPFLAGS=\"$CPPFLAGS\"\n+    CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+    SAVE_LDFLAGS=\"$LDFLAGS\"\n+    LDFLAGS=\"$LDFLAGS_FOR_BUILD\"\n+\n+    warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n+    saved_CFLAGS=\"$CFLAGS\"\n+    CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n+    AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n+    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n+        [ AC_MSG_RESULT([yes]) ],\n+        [ AC_MSG_RESULT([no])\n+          CFLAGS=\"$saved_CFLAGS\"\n+        ])\n+\n+    AC_MSG_CHECKING([for working native compiler: ${CC_FOR_BUILD}])\n+    AC_RUN_IFELSE(\n+      [AC_LANG_PROGRAM([], [])],\n+      [working_native_cc=yes],\n+      [working_native_cc=no],[:])\n+\n+    CFLAGS_FOR_BUILD=\"$CFLAGS\"\n+\n+    # Restore the environment\n+    cross_compiling=$save_cross_compiling\n+    CC=\"$SAVE_CC\"\n+    CFLAGS=\"$SAVE_CFLAGS\"\n+    CPPFLAGS=\"$SAVE_CPPFLAGS\"\n+    LDFLAGS=\"$SAVE_LDFLAGS\"\n+\n+    if test x\"$working_native_cc\" = x\"no\"; then\n+      AC_MSG_RESULT([no])\n+      set_precomp=no\n+      m4_define([please_set_for_build], [Please set CC_FOR_BUILD, CFLAGS_FOR_BUILD, CPPFLAGS_FOR_BUILD, and/or LDFLAGS_FOR_BUILD.])\n+      if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+        AC_MSG_ERROR([native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n+      else\n+        AC_MSG_WARN([Disabling statically generated ecmult table because the native compiler ${CC_FOR_BUILD} does not produce working binaries. please_set_for_build])\n+      fi\n+    else\n+      AC_MSG_RESULT([yes])\n+      set_precomp=yes\n+    fi\n+  fi\n+\n+  AC_SUBST(CC_FOR_BUILD)\n+  AC_SUBST(CFLAGS_FOR_BUILD)\n+  AC_SUBST(CPPFLAGS_FOR_BUILD)\n+  AC_SUBST(LDFLAGS_FOR_BUILD)\n+else\n+  set_precomp=no\n fi\n \n if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n \n+###\n+### Handle module options\n+###\n+\n if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n@@ -447,14 +453,14 @@ if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_EXTRAKEYS, 1, [Define this symbol to enable the extrakeys module])\n fi\n \n-if test x\"$use_external_asm\" = x\"yes\"; then\n-  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n-fi\n-\n if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n fi\n \n+###\n+### Check for --enable-experimental if necessary\n+###\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -474,6 +480,10 @@ else\n   fi\n fi\n \n+###\n+### Generate output\n+###\n+\n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n AC_SUBST(SECP_INCLUDES)\n@@ -492,7 +502,7 @@ AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" =\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n-dnl make sure nothing new is exported so that we don't break the cache\n+# Make sure nothing new is exported so that we don't break the cache.\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\"\n unset PKG_CONFIG_PATH\n PKG_CONFIG_PATH=\"$PKGCONFIG_PATH_TEMP\"\n@@ -513,10 +523,9 @@ echo \"  module extrakeys        = $enable_module_extrakeys\"\n echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n echo\n echo \"  asm                     = $set_asm\"\n-echo \"  bignum                  = $set_bignum\"\n echo \"  ecmult window size      = $set_ecmult_window\"\n echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n-dnl Hide test-only options unless they're used.\n+# Hide test-only options unless they're used.\n if test x\"$set_widemul\" != xauto; then\n echo \"  wide multiplication     = $set_widemul\"\n fi\n@@ -527,3 +536,9 @@ echo \"  CFLAGS                  = $CFLAGS\"\n echo \"  CPPFLAGS                = $CPPFLAGS\"\n echo \"  LDFLAGS                 = $LDFLAGS\"\n echo\n+if test x\"$set_precomp\" = x\"yes\"; then\n+echo \"  CC_FOR_BUILD            = $CC_FOR_BUILD\"\n+echo \"  CFLAGS_FOR_BUILD        = $CFLAGS_FOR_BUILD\"\n+echo \"  CPPFLAGS_FOR_BUILD      = $CPPFLAGS_FOR_BUILD\"\n+echo \"  LDFLAGS_FOR_BUILD       = $LDFLAGS_FOR_BUILD\"\n+fi"
      },
      {
        "sha": "c1627e37e9e11900796d426eae58056c525b1a11",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n #include <secp256k1.h>"
      },
      {
        "sha": "6b7255e28f5bc78ffdc48940821d8fed062eaa55",
        "filename": "src/secp256k1/contrib/lax_der_parsing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n /****\n  * Please do not link this file directly. It is not part of the libsecp256k1"
      },
      {
        "sha": "429760fbb6d19ab0afff7c36d4f37431b8ecd932",
        "filename": "src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_privatekey_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_privatekey_parsing.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014, 2015 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014, 2015 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n #include <secp256k1.h>"
      },
      {
        "sha": "602c7c556ad153a06459222663db08b1c4e8df7c",
        "filename": "src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/contrib/lax_der_privatekey_parsing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_privatekey_parsing.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014, 2015 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014, 2015 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n /****\n  * Please do not link this file directly. It is not part of the libsecp256k1"
      },
      {
        "sha": "3ae556f9a724011c4fa27b8e929e0f0e1e56e4f2",
        "filename": "src/secp256k1/doc/safegcd_implementation.md",
        "status": "added",
        "additions": 765,
        "deletions": 0,
        "changes": 765,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/doc/safegcd_implementation.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/doc/safegcd_implementation.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/doc/safegcd_implementation.md?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,765 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper (section 11), at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in later\n+sections.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting less than *2<sup>N</sup>*\n+times *M* to cancel out *N* bits brings that up to *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and\n+dividing by *2<sup>N</sup>* at the end takes it to *(-2M,M)*. Another application of `update_de` would take that\n+to *(-3M,2M)*, and so forth. This progressive expansion of the variables' ranges can be\n+counteracted by incrementing *d* and *e* by *M* whenever they're negative:\n+\n+```python\n+    ...\n+    if d < 0:\n+        d += M\n+    if e < 0:\n+        e += M\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    ...\n+```\n+\n+With inputs in *(-2M,M)*, they will first be shifted into range *(-M,M)*, which means that the\n+output will again be in *(-2M,M)*, and this remains the case regardless of how many `update_de`\n+invocations there are. In what follows, we will try to make this more efficient.\n+\n+Note that increasing *d* by *M* is equal to incrementing *cd* by *u&thinsp;M* and *ce* by *q&thinsp;M*. Similarly,\n+increasing *e* by *M* is equal to incrementing *cd* by *v&thinsp;M* and *ce* by *r&thinsp;M*. So we could instead write:\n+\n+```python\n+    ...\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Perform the equivalent of incrementing d, e by M when they're negative.\n+    if d < 0:\n+        cd += u*M\n+        ce += q*M\n+    if e < 0:\n+        cd += v*M\n+        ce += r*M\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    ...\n+```\n+\n+Now note that we have two steps of corrections to *cd* and *ce* that add multiples of *M*: this\n+increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+one, but they can still be efficiently combined by only computing the bottom bits of *cd* and *ce*\n+at first, and using that to compute the final *md*, *me* values:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    md, me = 0, 0\n+    # Compute what multiples of M to add to cd and ce.\n+    if d < 0:\n+        md += u\n+        me += q\n+    if e < 0:\n+        md += v\n+        me += r\n+    # Compute bottom N bits of t*[d,e] + M*[md,me].\n+    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+    md -= (Mi * cd) % 2**N\n+    me -= (Mi * ce) % 2**N\n+    # Do the full computation.\n+    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+One last optimization: we can avoid the *md&thinsp;M* and *me&thinsp;M* multiplications in the bottom bits of *cd*\n+and *ce* by moving them to the *md* and *me* correction:\n+\n+```python\n+    ...\n+    # Compute bottom N bits of t*[d,e].\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+    # Note that this is not the same as {md = (-Mi * cd) % 2**N} etc. That would also result in N\n+    # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+    # previous md and me values, and thus would violate our bounds analysis.\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    ...\n+```\n+\n+The resulting function takes *d* and *e* in range *(-2M,M)* as inputs, and outputs values in the same\n+range. That also means that the *d* value at the end of `modinv` will be in that range, while we want\n+a result in *[0,M)*. To do that, we need a normalization function. It's easy to integrate the\n+conditional negation of *d* (based on the sign of *f*) into it as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+    assert sign == 1 or sign == -1\n+    # v in (-2*M,M)\n+    if v < 0:\n+        v += M\n+    # v in (-M,M). Now multiply v with sign (which can only be 1 or -1).\n+    if sign == -1:\n+        v = -v\n+    # v in (-M,M)\n+    if v < 0:\n+        v += M\n+    # v in [0,M)\n+    return v\n+```\n+\n+And calling it in `modinv` is simply:\n+\n+```python\n+   ...\n+   return normalize(f, d, M)\n+```\n+\n+\n+## 5. Constant-time operation\n+\n+The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+depends on the input data so far?\n+\n+- the number of iterations of the while *g &ne; 0* loop in `modinv`\n+- the branches inside `divsteps_n_matrix`\n+- the sign checks in `update_de`\n+- the sign checks in `normalize`\n+\n+To make the while loop in `modinv` constant time it can be replaced with a constant number of\n+iterations. The paper proves (Theorem 11.2) that *741* divsteps are sufficient for any *256*-bit\n+inputs, and [safegcd-bounds](https://github.com/sipa/safegcd-bounds) shows that the slightly better bound *724* is\n+sufficient even. Given that every loop iteration performs *N* divsteps, it will run a total of\n+*&lceil;724/N&rceil;* times.\n+\n+To deal with the branches in `divsteps_n_matrix` we will replace them with constant-time bitwise\n+operations (and hope the C compiler isn't smart enough to turn them back into branches; see\n+`valgrind_ctime_test.c` for automated tests that this isn't the case). To do so, observe that a\n+divstep can be written instead as (compare to the inner loop of `gcd` in section 1).\n+\n+```python\n+    x = -f if delta > 0 else f         # set x equal to (input) -f or f\n+    if g & 1:\n+        g += x                         # set g to (input) g-f or g+f\n+        if delta > 0:\n+            delta = -delta\n+            f += g                     # set f to (input) g (note that g was set to g-f before)\n+    delta += 1\n+    g >>= 1\n+```\n+\n+To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the\n+definition of negative numbers in two's complement, (*-v == ~v + 1*) holds for every number *v*. As\n+*-1* in two's complement is all *1* bits, bitflipping can be expressed as xor with *-1*. It follows\n+that *-v == (v ^ -1) - (-1)*. Thus, if we have a variable *c* that takes on values *0* or *-1*, then\n+*(v ^ c) - c* is *v* if *c=0* and *-v* if *c=-1*.\n+\n+Using this we can write:\n+\n+```python\n+    x = -f if delta > 0 else f\n+```\n+\n+in constant-time form as:\n+\n+```python\n+    c1 = (-delta) >> 63\n+    # Conditionally negate f based on c1:\n+    x = (f ^ c1) - c1\n+```\n+\n+To use that trick, we need a helper mask variable *c1* that resolves the condition *&delta;>0* to *-1*\n+(if true) or *0* (if false). We compute *c1* using right shifting, which is equivalent to dividing by\n+the specified power of *2* and rounding down (in Python, and also in C under the assumption of a typical two's complement system; see\n+`assumptions.h` for tests that this is the case). Right shifting by *63* thus maps all\n+numbers in range *[-2<sup>63</sup>,0)* to *-1*, and numbers in range *[0,2<sup>63</sup>)* to *0*.\n+\n+Using the facts that *x&0=0* and *x&(-1)=x* (on two's complement systems again), we can write:\n+\n+```python\n+    if g & 1:\n+        g += x\n+```\n+\n+as:\n+\n+```python\n+    # Compute c2=0 if g is even and c2=-1 if g is odd.\n+    c2 = -(g & 1)\n+    # This masks out x if g is even, and leaves x be if g is odd.\n+    g += x & c2\n+```\n+\n+Using the conditional negation trick again we can write:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            delta = -delta\n+```\n+\n+as:\n+\n+```python\n+    # Compute c3=-1 if g is odd and delta>0, and 0 otherwise.\n+    c3 = c1 & c2\n+    # Conditionally negate delta based on c3:\n+    delta = (delta ^ c3) - c3\n+```\n+\n+Finally:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            f += g\n+```\n+\n+becomes:\n+\n+```python\n+    f += g & c3\n+```\n+\n+It turns out that this can be implemented more efficiently by applying the substitution\n+*&eta;=-&delta;*. In this representation, negating *&delta;* corresponds to negating *&eta;*, and incrementing\n+*&delta;* corresponds to decrementing *&eta;*. This allows us to remove the negation in the *c1*\n+computation:\n+\n+```python\n+    # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+    c1 = eta >> 63\n+    x = (f ^ c1) - c1\n+    # Compute a mask c2 for odd g, and conditionally add x to g:\n+    c2 = -(g & 1)\n+    g += x & c2\n+    # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+    # and add g to f:\n+    c3 = c1 & c2\n+    eta = (eta ^ c3) - c3\n+    f += g & c3\n+    # Incrementing delta corresponds to decrementing eta.\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+A variant of divsteps with better worst-case performance can be used instead: starting *&delta;* at\n+*1/2* instead of *1*. This reduces the worst case number of iterations to *590* for *256*-bit inputs\n+(which can be shown using convex hull analysis). In this case, the substitution *&zeta;=-(&delta;+1/2)*\n+is used instead to keep the variable integral. Incrementing *&delta;* by *1* still translates to\n+decrementing *&zeta;* by *1*, but negating *&delta;* now corresponds to going from *&zeta;* to *-(&zeta;+1)*, or\n+*~&zeta;*. Doing that conditionally based on *c3* is simply:\n+\n+```python\n+    ...\n+    c3 = c1 & c2\n+    zeta ^= c3\n+    ...\n+```\n+\n+By replacing the loop in `divsteps_n_matrix` with a variant of the divstep code above (extended to\n+also apply all *f* operations to *u*, *v* and all *g* operations to *q*, *r*), a constant-time version of\n+`divsteps_n_matrix` is obtained. The full code will be in section 7.\n+\n+These bit fiddling tricks can also be used to make the conditional negations and additions in\n+`update_de` and `normalize` constant-time.\n+\n+\n+## 6. Variable-time optimizations\n+\n+In section 5, we modified the `divsteps_n_matrix` function (and a few others) to be constant time.\n+Constant time operations are only necessary when computing modular inverses of secret data. In\n+other cases, it slows down calculations unnecessarily. In this section, we will construct a\n+faster non-constant time `divsteps_n_matrix` function.\n+\n+To do so, first consider yet another way of writing the inner loop of divstep operations in\n+`gcd` from section 1. This decomposition is also explained in the paper in section 8.2. We use\n+the original version with initial *&delta;=1* and *&eta;=-&delta;* here.\n+\n+```python\n+for _ in range(N):\n+    if g & 1 and eta < 0:\n+        eta, f, g = -eta, g, -f\n+    if g & 1:\n+        g += f\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+Whenever *g* is even, the loop only shifts *g* down and decreases *&eta;*. When *g* ends in multiple zero\n+bits, these iterations can be consolidated into one step. This requires counting the bottom zero\n+bits efficiently, which is possible on most platforms; it is abstracted here as the function\n+`count_trailing_zeros`.\n+\n+```python\n+def count_trailing_zeros(v):\n+    \"\"\"For a non-zero value v, find z such that v=(d<<z) for some odd d.\"\"\"\n+    return (v & -v).bit_length() - 1\n+\n+i = N # divsteps left to do\n+while True:\n+    # Get rid of all bottom zeros at once. In the first iteration, g may be odd and the following\n+    # lines have no effect (until \"if eta < 0\").\n+    zeros = min(i, count_trailing_zeros(g))\n+    eta -= zeros\n+    g >>= zeros\n+    i -= zeros\n+    if i == 0:\n+        break\n+    # We know g is odd now\n+    if eta < 0:\n+        eta, f, g = -eta, g, -f\n+    g += f\n+    # g is even now, and the eta decrement and g shift will happen in the next loop.\n+```\n+\n+We can now remove multiple bottom *0* bits from *g* at once, but still need a full iteration whenever\n+there is a bottom *1* bit. In what follows, we will get rid of multiple *1* bits simultaneously as\n+well.\n+\n+Observe that as long as *&eta; &geq; 0*, the loop does not modify *f*. Instead, it cancels out bottom\n+bits of *g* and shifts them out, and decreases *&eta;* and *i* accordingly - interrupting only when *&eta;*\n+becomes negative, or when *i* reaches *0*. Combined, this is equivalent to adding a multiple of *f* to\n+*g* to cancel out multiple bottom bits, and then shifting them out.\n+\n+It is easy to find what that multiple is: we want a number *w* such that *g+w&thinsp;f* has a few bottom\n+zero bits. If that number of bits is *L*, we want *g+w&thinsp;f mod 2<sup>L</sup> = 0*, or *w = -g/f mod 2<sup>L</sup>*. Since *f*\n+is odd, such a *w* exists for any *L*. *L* cannot be more than *i* steps (as we'd finish the loop before\n+doing more) or more than *&eta;+1* steps (as we'd run `eta, f, g = -eta, g, f` at that point), but\n+apart from that, we're only limited by the complexity of computing *w*.\n+\n+This code demonstrates how to cancel up to 4 bits per step:\n+\n+```python\n+NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+i = N\n+while True:\n+    zeros = min(i, count_trailing_zeros(g))\n+    eta -= zeros\n+    g >>= zeros\n+    i -= zeros\n+    if i == 0:\n+        break\n+    # We know g is odd now\n+    if eta < 0:\n+        eta, f, g = -eta, g, f\n+    # Compute limit on number of bits to cancel\n+    limit = min(min(eta + 1, i), 4)\n+    # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+    # always odd, so its inverse modulo a power of two always exists.\n+    w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+    # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+    g += w * f\n+    assert g % (2**limit) == 0\n+    # The next iteration will now shift out at least limit bottom zero bits from g.\n+```\n+\n+By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+as a formula. Several formulas are known for computing modular inverses modulo powers of two;\n+some can be found in Hacker's Delight second edition by Henry S. Warren, Jr. pages 245-247.\n+Here we need the negated modular inverse, which is a simple transformation of those:\n+\n+- Instead of a 3-bit table:\n+  - *-f* or *f ^ 6*\n+- Instead of a 4-bit table:\n+  - *1 - f(f + 1)*\n+  - *-(f + (((f + 1) & 4) << 1))*\n+- For larger tables the following technique can be used: if *w=-1/f mod 2<sup>L</sup>*, then *w(w&thinsp;f+2)* is\n+  *-1/f mod 2<sup>2L</sup>*. This allows extending the previous formulas (or tables). In particular we\n+  have this 6-bit function (based on the 3-bit function above):\n+  - *f(f<sup>2</sup> - 2)*\n+\n+This loop, again extended to also handle *u*, *v*, *q*, and *r* alongside *f* and *g*, placed in\n+`divsteps_n_matrix`, gives a significantly faster, but non-constant time version.\n+\n+\n+## 7. Final Python version\n+\n+All together we need the following functions:\n+\n+- A way to compute the transition matrix in constant time, using the `divsteps_n_matrix` function\n+  from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+  section 5, extended to handle *u*, *v*, *q*, *r*:\n+\n+```python\n+def divsteps_n_matrix(zeta, f, g):\n+    \"\"\"Compute zeta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        c1 = zeta >> 63\n+        # Compute x, y, z as conditionally-negated versions of f, u, v.\n+        x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+        c2 = -(g & 1)\n+        # Conditionally add x, y, z to g, q, r.\n+        g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+        c1 &= c2                     # reusing c1 here for the earlier c3 variable\n+        zeta = (zeta ^ c1) - 1       # inlining the unconditional zeta decrement here\n+        # Conditionally add g, q, r to f, u, v.\n+        f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+        # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+        # by 2^N. Instead, shift f's coefficients u and v up.\n+        g, u, v = g >> 1, u << 1, v << 1\n+    return zeta, (u, v, q, r)\n+```\n+\n+- The functions to update *f* and *g*, and *d* and *e*, from section 2 and section 4, with the constant-time\n+  changes to `update_de` from section 5:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    return cf >> N, cg >> N\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    d_sign, e_sign = d >> 257, e >> 257\n+    md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    cd, ce = u*d + v*e + M*md, q*d + r*e + M*me\n+    return cd >> N, ce >> N\n+```\n+\n+- The `normalize` function from section 4, made constant time as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+    v_sign = v >> 257\n+    # Conditionally add M to v.\n+    v += M & v_sign\n+    c = (sign - 1) >> 1\n+    # Conditionally negate v.\n+    v = (v ^ c) - c\n+    v_sign = v >> 257\n+    # Conditionally add M to v again.\n+    v += M & v_sign\n+    return v\n+```\n+\n+- And finally the `modinv` function too, adapted to use *&zeta;* instead of *&delta;*, and using the fixed\n+  iteration count from section 5:\n+\n+```python\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    zeta, f, g, d, e = -1, M, x, 0, 1\n+    for _ in range((590 + N - 1) // N):\n+        zeta, t = divsteps_n_matrix(zeta, f % 2**N, g % 2**N)\n+        f, g = update_fg(f, g, t)\n+        d, e = update_de(d, e, t, M, Mi)\n+    return normalize(f, d, M)\n+```\n+\n+- To get a variable time version, replace the `divsteps_n_matrix` function with one that uses the\n+  divsteps loop from section 5, and a `modinv` version that calls it without the fixed iteration\n+  count:\n+\n+```python\n+NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+def divsteps_n_matrix_var(eta, f, g):\n+    \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1\n+    i = N\n+    while True:\n+        zeros = min(i, count_trailing_zeros(g))\n+        eta, i = eta - zeros, i - zeros\n+        g, u, v = g >> zeros, u << zeros, v << zeros\n+        if i == 0:\n+            break\n+        if eta < 0:\n+            eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+        limit = min(min(eta + 1, i), 4)\n+        w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+        g, q, r = g + w*f, q + w*u, r + w*v\n+    return eta, (u, v, q, r)\n+\n+def modinv_var(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    eta, f, g, d, e = -1, M, x, 0, 1\n+    while g != 0:\n+        eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+        f, g = update_fg(f, g, t)\n+        d, e = update_de(d, e, t, M, Mi)\n+    return normalize(f, d, Mi)\n+```"
      },
      {
        "sha": "d368488af21c4fc435b63b4dbcb7220aecb1d71c",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 27,
        "deletions": 20,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -11,7 +11,7 @@ extern \"C\" {\n  *\n  * 1. Context pointers go first, followed by output arguments, combined\n  *    output/input arguments, and finally input-only arguments.\n- * 2. Array lengths always immediately the follow the argument whose length\n+ * 2. Array lengths always immediately follow the argument whose length\n  *    they describe, even if this violates rule 1.\n  * 3. Within the OUT/OUTIN/IN groups, pointers to data that is typically generated\n  *    later go first. This means: signatures, public nonces, secret nonces,\n@@ -452,7 +452,14 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n  *           0: incorrect or unparseable signature\n  *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n  *  In:      sig:       the signature being verified (cannot be NULL)\n- *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n+ *           msghash32: the 32-byte message hash being verified (cannot be NULL).\n+ *                      The verifier must make sure to apply a cryptographic\n+ *                      hash function to the message by itself and not accept an\n+ *                      msghash32 value directly. Otherwise, it would be easy to\n+ *                      create a \"valid\" signature without knowledge of the\n+ *                      secret key. See also\n+ *                      https://bitcoin.stackexchange.com/a/81116/35586 for more\n+ *                      background on this topic.\n  *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)\n  *\n  * To avoid accepting malleable signatures, only ECDSA signatures in lower-S\n@@ -467,7 +474,7 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n     const secp256k1_context* ctx,\n     const secp256k1_ecdsa_signature *sig,\n-    const unsigned char *msg32,\n+    const unsigned char *msghash32,\n     const secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n@@ -532,20 +539,20 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n+ *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n+ *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n+ *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n  *\n  * The created signature is always in lower-S form. See\n  * secp256k1_ecdsa_signature_normalize for more details.\n  */\n SECP256K1_API int secp256k1_ecdsa_sign(\n     const secp256k1_context* ctx,\n     secp256k1_ecdsa_signature *sig,\n-    const unsigned char *msg32,\n+    const unsigned char *msghash32,\n     const unsigned char *seckey,\n     secp256k1_nonce_function noncefp,\n     const void *ndata\n@@ -626,23 +633,23 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n  *                  value if this function returns 0. (cannot be NULL)\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Same as secp256k1_ec_seckey_tweak_add, but DEPRECATED. Will be removed in\n  *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by adding tweak times the generator to it.\n@@ -654,15 +661,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n  *                  (cannot be NULL).\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n  *                  invalid value if this function returns 0 (cannot be NULL).\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a secret key by multiplying it by a tweak.\n@@ -673,23 +680,23 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n  *                  value if this function returns 0. (cannot be NULL)\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Same as secp256k1_ec_seckey_tweak_mul, but DEPRECATED. Will be removed in\n  *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by multiplying it by a tweak value.\n@@ -699,15 +706,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *                  (cannot be NULL).\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n  *                  invalid value if this function returns 0 (cannot be NULL).\n- *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n  *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n-    const unsigned char *tweak\n+    const unsigned char *tweak32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Updates the context randomization to protect against side-channel leakage."
      },
      {
        "sha": "6fc7b290f8cae62afaaf9e81b60ecc29a9341186",
        "filename": "src/secp256k1/include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_extrakeys.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -165,6 +165,19 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Get the secret key from a keypair.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Out: seckey: pointer to a 32-byte buffer for the secret key (cannot be NULL)\n+ *  In: keypair: pointer to a keypair (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const secp256k1_keypair *keypair\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n /** Get the public key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise."
      },
      {
        "sha": "aa16532ce86146ae202f2179cf4c69693b139ef4",
        "filename": "src/secp256k1/include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_recovery.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -71,17 +71,17 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n+ *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n+ *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n+ *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n  */\n SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n     const secp256k1_context* ctx,\n     secp256k1_ecdsa_recoverable_signature *sig,\n-    const unsigned char *msg32,\n+    const unsigned char *msghash32,\n     const unsigned char *seckey,\n     secp256k1_nonce_function noncefp,\n     const void *ndata\n@@ -91,16 +91,16 @@ SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n  *\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  Args:    ctx:        pointer to a context object, initialized for verification (cannot be NULL)\n- *  Out:     pubkey:     pointer to the recovered public key (cannot be NULL)\n- *  In:      sig:        pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n- *           msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for verification (cannot be NULL)\n+ *  Out:     pubkey:    pointer to the recovered public key (cannot be NULL)\n+ *  In:      sig:       pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n+ *           msghash32: the 32-byte message hash assumed to be signed (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n     const secp256k1_ecdsa_recoverable_signature *sig,\n-    const unsigned char *msg32\n+    const unsigned char *msghash32\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n #ifdef __cplusplus"
      },
      {
        "sha": "01d15dcdeac56e11bc80c151a7b548ce74eb44d8",
        "filename": "src/secp256k1/sage/gen_exhaustive_groups.sage",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/gen_exhaustive_groups.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/gen_exhaustive_groups.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/gen_exhaustive_groups.sage?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,9 +1,4 @@\n-# Define field size and field\n-P = 2^256 - 2^32 - 977\n-F = GF(P)\n-BETA = F(0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee)\n-\n-assert(BETA != F(1) and BETA^3 == F(1))\n+load(\"secp256k1_params.sage\")\n \n orders_done = set()\n results = {}"
      },
      {
        "sha": "7d4359e0f6482f51994e5bae84fd2d5ca5d161ef",
        "filename": "src/secp256k1/sage/gen_split_lambda_constants.sage",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/gen_split_lambda_constants.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/gen_split_lambda_constants.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/gen_split_lambda_constants.sage?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,114 @@\n+\"\"\" Generates the constants used in secp256k1_scalar_split_lambda.\n+\n+See the comments for secp256k1_scalar_split_lambda in src/scalar_impl.h for detailed explanations.\n+\"\"\"\n+\n+load(\"secp256k1_params.sage\")\n+\n+def inf_norm(v):\n+    \"\"\"Returns the infinity norm of a vector.\"\"\"\n+    return max(map(abs, v))\n+\n+def gauss_reduction(i1, i2):\n+    v1, v2 = i1.copy(), i2.copy()\n+    while True:\n+        if inf_norm(v2) < inf_norm(v1):\n+            v1, v2 = v2, v1\n+        # This is essentially\n+        #    m = round((v1[0]*v2[0] + v1[1]*v2[1]) / (inf_norm(v1)**2))\n+        # (rounding to the nearest integer) without relying on floating point arithmetic.\n+        m = ((v1[0]*v2[0] + v1[1]*v2[1]) + (inf_norm(v1)**2) // 2) // (inf_norm(v1)**2)\n+        if m == 0:\n+            return v1, v2\n+        v2[0] -= m*v1[0]\n+        v2[1] -= m*v1[1]\n+\n+def find_split_constants_gauss():\n+    \"\"\"Find constants for secp256k1_scalar_split_lamdba using gauss reduction.\"\"\"\n+    (v11, v12), (v21, v22) = gauss_reduction([0, N], [1, int(LAMBDA)])\n+\n+    # We use related vectors in secp256k1_scalar_split_lambda.\n+    A1, B1 = -v21, -v11\n+    A2, B2 = v22, -v21\n+\n+    return A1, B1, A2, B2\n+\n+def find_split_constants_explicit_tof():\n+    \"\"\"Find constants for secp256k1_scalar_split_lamdba using the trace of Frobenius.\n+\n+    See Benjamin Smith: \"Easy scalar decompositions for efficient scalar multiplication on\n+    elliptic curves and genus 2 Jacobians\" (https://eprint.iacr.org/2013/672), Example 2\n+    \"\"\"\n+    assert P % 3 == 1 # The paper says P % 3 == 2 but that appears to be a mistake, see [10].\n+    assert C.j_invariant() == 0\n+\n+    t = C.trace_of_frobenius()\n+\n+    c = Integer(sqrt((4*P - t**2)/3))\n+    A1 = Integer((t - c)/2 - 1)\n+    B1 = c\n+\n+    A2 = Integer((t + c)/2 - 1)\n+    B2 = Integer(1 - (t - c)/2)\n+\n+    # We use a negated b values in secp256k1_scalar_split_lambda.\n+    B1, B2 = -B1, -B2\n+\n+    return A1, B1, A2, B2\n+\n+A1, B1, A2, B2 = find_split_constants_explicit_tof()\n+\n+# For extra fun, use an independent method to recompute the constants.\n+assert (A1, B1, A2, B2) == find_split_constants_gauss()\n+\n+# PHI : Z[l] -> Z_n where phi(a + b*l) == a + b*lambda mod n.\n+def PHI(a,b):\n+    return Z(a + LAMBDA*b)\n+\n+# Check that (A1, B1) and (A2, B2) are in the kernel of PHI.\n+assert PHI(A1, B1) == Z(0)\n+assert PHI(A2, B2) == Z(0)\n+\n+# Check that the parallelogram generated by (A1, A2) and (B1, B2)\n+# is a fundamental domain by containing exactly N points.\n+# Since the LHS is the determinant and N != 0, this also checks that\n+# (A1, A2) and (B1, B2) are linearly independent. By the previous\n+# assertions, (A1, A2) and (B1, B2) are a basis of the kernel.\n+assert A1*B2 - B1*A2 == N\n+\n+# Check that their components are short enough.\n+assert (A1 + A2)/2 < sqrt(N)\n+assert B1 < sqrt(N)\n+assert B2 < sqrt(N)\n+\n+G1 = round((2**384)*B2/N)\n+G2 = round((2**384)*(-B1)/N)\n+\n+def rnddiv2(v):\n+    if v & 1:\n+        v += 1\n+    return v >> 1\n+\n+def scalar_lambda_split(k):\n+    \"\"\"Equivalent to secp256k1_scalar_lambda_split().\"\"\"\n+    c1 = rnddiv2((k * G1) >> 383)\n+    c2 = rnddiv2((k * G2) >> 383)\n+    c1 = (c1 * -B1) % N\n+    c2 = (c2 * -B2) % N\n+    r2 = (c1 + c2) % N\n+    r1 = (k + r2 * -LAMBDA) % N\n+    return (r1, r2)\n+\n+# The result of scalar_lambda_split can depend on the representation of k (mod n).\n+SPECIAL = (2**383) // G2 + 1\n+assert scalar_lambda_split(SPECIAL) != scalar_lambda_split(SPECIAL + N)\n+\n+print('  A1     =', hex(A1))\n+print(' -B1     =', hex(-B1))\n+print('  A2     =', hex(A2))\n+print(' -B2     =', hex(-B2))\n+print('         =', hex(Z(-B2)))\n+print(' -LAMBDA =', hex(-LAMBDA))\n+\n+print('  G1     =', hex(G1))\n+print('  G2     =', hex(G2))"
      },
      {
        "sha": "b200bfeae3d1c6c32fd3fc7de6160ebc6bbb12e9",
        "filename": "src/secp256k1/sage/group_prover.sage",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/group_prover.sage?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -42,7 +42,7 @@\n #     as we assume that all constraints in it are complementary with each other.\n #\n # Based on the sage verification scripts used in the Explicit-Formulas Database\n-# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+# by Tanja Lange and others, see https://hyperelliptic.org/EFD\n \n class fastfrac:\n   \"\"\"Fractions over rings.\"\"\"\n@@ -65,7 +65,7 @@ class fastfrac:\n     return self.top in I and self.bot not in I\n \n   def reduce(self,assumeZero):\n-    zero = self.R.ideal(map(numerator, assumeZero))\n+    zero = self.R.ideal(list(map(numerator, assumeZero)))\n     return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n \n   def __add__(self,other):\n@@ -100,14 +100,19 @@ class fastfrac:\n     \"\"\"Multiply something else with a fraction.\"\"\"\n     return self.__mul__(other)\n \n-  def __div__(self,other):\n+  def __truediv__(self,other):\n     \"\"\"Divide two fractions.\"\"\"\n     if parent(other) == ZZ:\n       return fastfrac(self.R,self.top,self.bot * other)\n     if other.__class__ == fastfrac:\n       return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n     return NotImplemented\n \n+  # Compatibility wrapper for Sage versions based on Python 2\n+  def __div__(self,other):\n+     \"\"\"Divide two fractions.\"\"\"\n+     return self.__truediv__(other)\n+\n   def __pow__(self,other):\n     \"\"\"Compute a power of a fraction.\"\"\"\n     if parent(other) == ZZ:\n@@ -175,7 +180,7 @@ class constraints:\n \n def conflicts(R, con):\n   \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n-  zero = R.ideal(map(numerator, con.zero))\n+  zero = R.ideal(list(map(numerator, con.zero)))\n   if 1 in zero:\n     return True\n   # First a cheap check whether any of the individual nonzero terms conflict on\n@@ -195,7 +200,7 @@ def conflicts(R, con):\n \n def get_nonzero_set(R, assume):\n   \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n-  zero = R.ideal(map(numerator, assume.zero))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n   nonzero = set()\n   for nz in map(numerator, assume.nonzero):\n     for (f,n) in nz.factor():\n@@ -208,7 +213,7 @@ def get_nonzero_set(R, assume):\n \n def prove_nonzero(R, exprs, assume):\n   \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n-  zero = R.ideal(map(numerator, assume.zero))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n   nonzero = get_nonzero_set(R, assume)\n   expl = set()\n   ok = True\n@@ -250,7 +255,7 @@ def prove_zero(R, exprs, assume):\n   r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n   if not r:\n     return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n-  zero = R.ideal(map(numerator, assume.zero))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n   nonzero = prod(x for x in assume.nonzero)\n   expl = []\n   for expr in exprs:\n@@ -265,8 +270,8 @@ def describe_extra(R, assume, assumeExtra):\n   \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n   zerox = assume.zero.copy()\n   zerox.update(assumeExtra.zero)\n-  zero = R.ideal(map(numerator, assume.zero))\n-  zeroextra = R.ideal(map(numerator, zerox))\n+  zero = R.ideal(list(map(numerator, assume.zero)))\n+  zeroextra = R.ideal(list(map(numerator, zerox)))\n   nonzero = get_nonzero_set(R, assume)\n   ret = set()\n   # Iterate over the extra zero expressions"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "src/secp256k1/sage/prove_group_implementations.sage",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/prove_group_implementations.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/prove_group_implementations.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/prove_group_implementations.sage?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "previous_filename": "src/secp256k1/sage/secp256k1.sage"
      },
      {
        "sha": "4e000726ed36646a63cedb124aeae618bf5fa149",
        "filename": "src/secp256k1/sage/secp256k1_params.sage",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/secp256k1_params.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/secp256k1_params.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/secp256k1_params.sage?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,36 @@\n+\"\"\"Prime order of finite field underlying secp256k1 (2^256 - 2^32 - 977)\"\"\"\n+P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n+\n+\"\"\"Finite field underlying secp256k1\"\"\"\n+F = FiniteField(P)\n+\n+\"\"\"Elliptic curve secp256k1: y^2 = x^3 + 7\"\"\"\n+C = EllipticCurve([F(0), F(7)])\n+\n+\"\"\"Base point of secp256k1\"\"\"\n+G = C.lift_x(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798)\n+\n+\"\"\"Prime order of secp256k1\"\"\"\n+N = C.order()\n+\n+\"\"\"Finite field of scalars of secp256k1\"\"\"\n+Z = FiniteField(N)\n+\n+\"\"\" Beta value of secp256k1 non-trivial endomorphism: lambda * (x, y) = (beta * x, y)\"\"\"\n+BETA = F(2)^((P-1)/3)\n+\n+\"\"\" Lambda value of secp256k1 non-trivial endomorphism: lambda * (x, y) = (beta * x, y)\"\"\"\n+LAMBDA = Z(3)^((N-1)/3)\n+\n+assert is_prime(P)\n+assert is_prime(N)\n+\n+assert BETA != F(1)\n+assert BETA^3 == F(1)\n+assert BETA^2 + BETA + 1 == 0\n+\n+assert LAMBDA != Z(1)\n+assert LAMBDA^3 == Z(1)\n+assert LAMBDA^2 + LAMBDA + 1 == 0\n+\n+assert Integer(LAMBDA)*G == C(BETA*G[0], G[1])"
      },
      {
        "sha": "b770c6dafe2f024d089848dfd8351b599f4193aa",
        "filename": "src/secp256k1/sage/weierstrass_prover.sage",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/weierstrass_prover.sage?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -175,24 +175,24 @@ laws_jacobian_weierstrass = {\n def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n   \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n   F = Integers(p)\n-  print \"Formula %s on Z%i:\" % (name, p)\n+  print(\"Formula %s on Z%i:\" % (name, p))\n   points = []\n-  for x in xrange(0, p):\n-    for y in xrange(0, p):\n+  for x in range(0, p):\n+    for y in range(0, p):\n       point = affinepoint(F(x), F(y))\n       r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n       if r:\n         points.append(point)\n \n-  for za in xrange(1, p):\n-    for zb in xrange(1, p):\n+  for za in range(1, p):\n+    for zb in range(1, p):\n       for pa in points:\n         for pb in points:\n-          for ia in xrange(2):\n-            for ib in xrange(2):\n+          for ia in range(2):\n+            for ib in range(2):\n               pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n               pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n-              for branch in xrange(0, branches):\n+              for branch in range(0, branches):\n                 assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n                 pC.X = F(pC.X)\n                 pC.Y = F(pC.Y)\n@@ -206,13 +206,13 @@ def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n                     r, e = concrete_verify(assumeLaw)\n                     if r:\n                       if match:\n-                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                        print(\"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity))\n                       else:\n                         match = True\n                       r, e = concrete_verify(require)\n                       if not r:\n-                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n-  print\n+                        print(\"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e))\n+  print()\n \n \n def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n@@ -242,9 +242,9 @@ def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n   for key in laws_jacobian_weierstrass:\n     res[key] = []\n \n-  print (\"Formula \" + name + \":\")\n+  print(\"Formula \" + name + \":\")\n   count = 0\n-  for branch in xrange(branches):\n+  for branch in range(branches):\n     assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n     pC.X = lift(pC.X)\n     pC.Y = lift(pC.Y)\n@@ -255,10 +255,10 @@ def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n       res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n \n   for key in res:\n-    print \"  %s:\" % key\n+    print(\"  %s:\" % key)\n     val = res[key]\n     for x in val:\n       if x[0] is not None:\n-        print \"    branch %i: %s\" % (x[1], x[0])\n+        print(\"    branch %i: %s\" % (x[1], x[0]))\n \n-  print\n+  print()"
      },
      {
        "sha": "5f68cefc46cde0e8e5a110dd5909d9bc4e7a5950",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,9 +1,9 @@\n @ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n-/**********************************************************************\n- * Copyright (c) 2014 Wladimir J. van der Laan                        *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n /*\n ARM implementation of field_10x26 inner loops.\n "
      },
      {
        "sha": "6dc527b288939b9a8766f6af8a35def337c206d6",
        "filename": "src/secp256k1/src/assumptions.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/assumptions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/assumptions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/assumptions.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ASSUMPTIONS_H\n #define SECP256K1_ASSUMPTIONS_H"
      },
      {
        "sha": "6f7693cb8fd046a8b10ff22d6d97d8bb4a002053",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 6,
        "deletions": 23,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,33 +1,16 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_BASIC_CONFIG_H\n #define SECP256K1_BASIC_CONFIG_H\n \n #ifdef USE_BASIC_CONFIG\n \n-#undef USE_ASM_X86_64\n-#undef USE_ECMULT_STATIC_PRECOMPUTATION\n-#undef USE_EXTERNAL_ASM\n-#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n-#undef USE_FIELD_INV_BUILTIN\n-#undef USE_FIELD_INV_NUM\n-#undef USE_NUM_GMP\n-#undef USE_NUM_NONE\n-#undef USE_SCALAR_INV_BUILTIN\n-#undef USE_SCALAR_INV_NUM\n-#undef USE_FORCE_WIDEMUL_INT64\n-#undef USE_FORCE_WIDEMUL_INT128\n-#undef ECMULT_WINDOW_SIZE\n-\n-#define USE_NUM_NONE 1\n-#define USE_FIELD_INV_BUILTIN 1\n-#define USE_SCALAR_INV_BUILTIN 1\n-#define USE_WIDEMUL_64 1\n #define ECMULT_WINDOW_SIZE 15\n+#define ECMULT_GEN_PREC_BITS 4\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "63c55df44d05954e2db3138f7879c42a7dfb2897",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_BENCH_H\n #define SECP256K1_BENCH_H"
      },
      {
        "sha": "ab4b8f4244f2b54539b0f4a5d5caf2cfd33a4055",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                  *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                   *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n "
      },
      {
        "sha": "204e85a5dde134360af66a0d2badfce953009029",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,15 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2017 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2017 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n #include <stdio.h>\n \n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n #include \"hash_impl.h\"\n-#include \"num_impl.h\"\n #include \"field_impl.h\"\n #include \"group_impl.h\"\n #include \"scalar_impl.h\""
      },
      {
        "sha": "73b8a24ccbfaf6e4b432728248624f332a7adef3",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 11,
        "deletions": 62,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,16 +1,15 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n #include <stdio.h>\n \n #include \"include/secp256k1.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n #include \"hash_impl.h\"\n-#include \"num_impl.h\"\n #include \"field_impl.h\"\n #include \"group_impl.h\"\n #include \"scalar_impl.h\"\n@@ -99,15 +98,6 @@ void bench_scalar_negate(void* arg, int iters) {\n     }\n }\n \n-void bench_scalar_sqr(void* arg, int iters) {\n-    int i;\n-    bench_inv *data = (bench_inv*)arg;\n-\n-    for (i = 0; i < iters; i++) {\n-        secp256k1_scalar_sqr(&data->scalar[0], &data->scalar[0]);\n-    }\n-}\n-\n void bench_scalar_mul(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n@@ -255,35 +245,17 @@ void bench_group_add_affine_var(void* arg, int iters) {\n     }\n }\n \n-void bench_group_jacobi_var(void* arg, int iters) {\n-    int i, j = 0;\n-    bench_inv *data = (bench_inv*)arg;\n-\n-    for (i = 0; i < iters; i++) {\n-        j += secp256k1_gej_has_quad_y_var(&data->gej[0]);\n-        /* Vary the Y and Z coordinates of the input (the X coordinate doesn't matter to\n-           secp256k1_gej_has_quad_y_var). Note that the resulting coordinates will\n-           generally not correspond to a point on the curve, but this is not a problem\n-           for the code being benchmarked here. Adding and normalizing have less\n-           overhead than EC operations (which could guarantee the point remains on the\n-           curve). */\n-        secp256k1_fe_add(&data->gej[0].y, &data->fe[1]);\n-        secp256k1_fe_add(&data->gej[0].z, &data->fe[2]);\n-        secp256k1_fe_normalize_var(&data->gej[0].y);\n-        secp256k1_fe_normalize_var(&data->gej[0].z);\n-    }\n-    CHECK(j <= iters);\n-}\n-\n void bench_group_to_affine_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < iters; ++i) {\n         secp256k1_ge_set_gej_var(&data->ge[1], &data->gej[0]);\n         /* Use the output affine X/Y coordinates to vary the input X/Y/Z coordinates.\n-           Similar to bench_group_jacobi_var, this approach does not result in\n-           coordinates of points on the curve. */\n+           Note that the resulting coordinates will generally not correspond to a point\n+           on the curve, but this is not a problem for the code being benchmarked here.\n+           Adding and normalizing have less overhead than EC operations (which could\n+           guarantee the point remains on the curve). */\n         secp256k1_fe_add(&data->gej[0].x, &data->ge[1].y);\n         secp256k1_fe_add(&data->gej[0].y, &data->fe[2]);\n         secp256k1_fe_add(&data->gej[0].z, &data->ge[1].x);\n@@ -369,35 +341,16 @@ void bench_context_sign(void* arg, int iters) {\n     }\n }\n \n-#ifndef USE_NUM_NONE\n-void bench_num_jacobi(void* arg, int iters) {\n-    int i, j = 0;\n-    bench_inv *data = (bench_inv*)arg;\n-    secp256k1_num nx, na, norder;\n-\n-    secp256k1_scalar_get_num(&nx, &data->scalar[0]);\n-    secp256k1_scalar_order_get_num(&norder);\n-    secp256k1_scalar_get_num(&na, &data->scalar[1]);\n-\n-    for (i = 0; i < iters; i++) {\n-        j += secp256k1_num_jacobi(&nx, &norder);\n-        secp256k1_num_add(&nx, &nx, &na);\n-    }\n-    CHECK(j <= iters);\n-}\n-#endif\n-\n int main(int argc, char **argv) {\n     bench_inv data;\n     int iters = get_iters(20000);\n \n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, 2000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, 2000);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n@@ -411,7 +364,6 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"to_affine\")) run_benchmark(\"group_to_affine_var\", bench_group_to_affine_var, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n@@ -424,8 +376,5 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n \n-#ifndef USE_NUM_NONE\n-    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, iters*10);\n-#endif\n     return 0;\n }"
      },
      {
        "sha": "3f6270ce84fd5ad497c5a2904b0b8e026838feb4",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_recovery.h\""
      },
      {
        "sha": "f7f591c41dcea51e3219b1eea959dc2958e46dde",
        "filename": "src/secp256k1/src/bench_schnorrsig.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_schnorrsig.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_schnorrsig.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorrsig.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                 *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <string.h>\n #include <stdlib.h>"
      },
      {
        "sha": "933f367c4b6a65a03699f31ae61d91e21ca0e370",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include \"include/secp256k1.h\"\n #include \"util.h\"\n@@ -12,11 +12,11 @@ typedef struct {\n     secp256k1_context* ctx;\n     unsigned char msg[32];\n     unsigned char key[32];\n-} bench_sign;\n+} bench_sign_data;\n \n static void bench_sign_setup(void* arg) {\n     int i;\n-    bench_sign *data = (bench_sign*)arg;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n \n     for (i = 0; i < 32; i++) {\n         data->msg[i] = i + 1;\n@@ -28,7 +28,7 @@ static void bench_sign_setup(void* arg) {\n \n static void bench_sign_run(void* arg, int iters) {\n     int i;\n-    bench_sign *data = (bench_sign*)arg;\n+    bench_sign_data *data = (bench_sign_data*)arg;\n \n     unsigned char sig[74];\n     for (i = 0; i < iters; i++) {\n@@ -45,7 +45,7 @@ static void bench_sign_run(void* arg, int iters) {\n }\n \n int main(void) {\n-    bench_sign data;\n+    bench_sign_data data;\n \n     int iters = get_iters(20000);\n "
      },
      {
        "sha": "c56aefd3699c06d6bf5bf4022801387b7762ca64",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <stdio.h>\n #include <string.h>\n@@ -29,11 +29,11 @@ typedef struct {\n #ifdef ENABLE_OPENSSL_TESTS\n     EC_GROUP* ec_group;\n #endif\n-} benchmark_verify_t;\n+} bench_verify_data;\n \n-static void benchmark_verify(void* arg, int iters) {\n+static void bench_verify(void* arg, int iters) {\n     int i;\n-    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+    bench_verify_data* data = (bench_verify_data*)arg;\n \n     for (i = 0; i < iters; i++) {\n         secp256k1_pubkey pubkey;\n@@ -51,9 +51,9 @@ static void benchmark_verify(void* arg, int iters) {\n }\n \n #ifdef ENABLE_OPENSSL_TESTS\n-static void benchmark_verify_openssl(void* arg, int iters) {\n+static void bench_verify_openssl(void* arg, int iters) {\n     int i;\n-    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+    bench_verify_data* data = (bench_verify_data*)arg;\n \n     for (i = 0; i < iters; i++) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n@@ -84,7 +84,7 @@ int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n     secp256k1_ecdsa_signature sig;\n-    benchmark_verify_t data;\n+    bench_verify_data data;\n \n     int iters = get_iters(20000);\n \n@@ -103,10 +103,10 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n-    run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, iters);\n+    run_benchmark(\"ecdsa_verify\", bench_verify, NULL, NULL, &data, 10, iters);\n #ifdef ENABLE_OPENSSL_TESTS\n     data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, iters);\n+    run_benchmark(\"ecdsa_verify_openssl\", bench_verify_openssl, NULL, NULL, &data, 10, iters);\n     EC_GROUP_free(data.ec_group);\n #endif\n "
      },
      {
        "sha": "d5e54d8ce619736930a925eb9bdc6fd47ba6d513",
        "filename": "src/secp256k1/src/ecdsa.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECDSA_H\n #define SECP256K1_ECDSA_H"
      },
      {
        "sha": "156a33d1128656a00c510093bd3b7105ace7d942",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n \n #ifndef SECP256K1_ECDSA_IMPL_H"
      },
      {
        "sha": "5be3a64b84043cc50cc4e63bdcde8c64fd4fbfc8",
        "filename": "src/secp256k1/src/eckey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECKEY_H\n #define SECP256K1_ECKEY_H"
      },
      {
        "sha": "a39cb79653c381643de38c9fa69d60b1d2aa3da9",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECKEY_IMPL_H\n #define SECP256K1_ECKEY_IMPL_H"
      },
      {
        "sha": "7ab617e20e4217a2f60de46395e2f7ed842d1dd8",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_H\n #define SECP256K1_ECMULT_H\n \n-#include \"num.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"scratch.h\""
      },
      {
        "sha": "d6f0ea22275a699595f7f62260bf668299cde237",
        "filename": "src/secp256k1/src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_CONST_H\n #define SECP256K1_ECMULT_CONST_H"
      },
      {
        "sha": "0e1fb965cbdefc9d31b342f87095f83f027413b4",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                  *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Pieter Wuille, Andrew Poelstra                   *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_CONST_IMPL_H\n #define SECP256K1_ECMULT_CONST_IMPL_H"
      },
      {
        "sha": "539618dcbb8722edc40108f72a53002f5b770b82",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_GEN_H\n #define SECP256K1_ECMULT_GEN_H"
      },
      {
        "sha": "384a67faeda7a6d4d2eb31af91315a5c8766284d",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014, 2015 Pieter Wuille, Gregory Maxwell       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n@@ -144,7 +144,7 @@ static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context *ctx, secp25\n              *    (https://cryptojedi.org/peter/data/chesrump-20130822.pdf) and\n              *   \"Cache Attacks and Countermeasures: the Case of AES\", RSA 2006,\n              *    by Dag Arne Osvik, Adi Shamir, and Eran Tromer\n-             *    (http://www.tau.ac.il/~tromer/papers/cache.pdf)\n+             *    (https://www.tau.ac.il/~tromer/papers/cache.pdf)\n              */\n             secp256k1_ge_storage_cmov(&adds, &(*ctx->prec)[j][i], i == bits);\n         }"
      },
      {
        "sha": "5c2edac68fc6926f80335baf3e112b2b9899a2df",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/*****************************************************************************\n- * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick *\n- * Distributed under the MIT software license, see the accompanying          *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.       *\n- *****************************************************************************/\n+/******************************************************************************\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra, Jonas Nick  *\n+ * Distributed under the MIT software license, see the accompanying           *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.       *\n+ ******************************************************************************/\n \n #ifndef SECP256K1_ECMULT_IMPL_H\n #define SECP256K1_ECMULT_IMPL_H\n@@ -595,11 +595,11 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n     scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n     state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n     state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n-    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n \n-    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL || state.pre_a_lam == NULL || state.ps == NULL) {\n         secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }"
      },
      {
        "sha": "854aaebabc966e506a38707d349130d5c7571a27",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 10,
        "deletions": 19,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_H\n #define SECP256K1_FIELD_H\n@@ -43,13 +43,12 @@ static void secp256k1_fe_normalize_weak(secp256k1_fe *r);\n /** Normalize a field element, without constant-time guarantee. */\n static void secp256k1_fe_normalize_var(secp256k1_fe *r);\n \n-/** Verify whether a field element represents zero i.e. would normalize to a zero value. The field\n- *  implementation may optionally normalize the input, but this should not be relied upon. */\n-static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r);\n+/** Verify whether a field element represents zero i.e. would normalize to a zero value. */\n+static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r);\n \n-/** Verify whether a field element represents zero i.e. would normalize to a zero value. The field\n- *  implementation may optionally normalize the input, but this should not be relied upon. */\n-static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r);\n+/** Verify whether a field element represents zero i.e. would normalize to a zero value,\n+ *  without constant-time guarantee. */\n+static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r);\n \n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n@@ -104,21 +103,13 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  itself. */\n static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n \n-/** Checks whether a field element is a quadratic residue. */\n-static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n-\n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a);\n \n /** Potentially faster version of secp256k1_fe_inv, without constant-time guarantee. */\n static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a);\n \n-/** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n- *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n- *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len);\n-\n /** Convert a field element to the storage type. */\n static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a);\n "
      },
      {
        "sha": "9eb65607f12cb2b86694e0a48dc9ce6f754ddd97",
        "filename": "src/secp256k1/src/field_10x26.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_10x26.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_10x26.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_H\n #define SECP256K1_FIELD_REPR_H"
      },
      {
        "sha": "7a38c117f194be718e6d8b81920dfa42e2a72e79",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 96,
        "deletions": 7,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,14 +1,15 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_IMPL_H\n #define SECP256K1_FIELD_REPR_IMPL_H\n \n #include \"util.h\"\n #include \"field.h\"\n+#include \"modinv32_impl.h\"\n \n #ifdef VERIFY\n static void secp256k1_fe_verify(const secp256k1_fe *a) {\n@@ -181,7 +182,7 @@ static void secp256k1_fe_normalize_var(secp256k1_fe *r) {\n #endif\n }\n \n-static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r) {\n     uint32_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4],\n              t5 = r->n[5], t6 = r->n[6], t7 = r->n[7], t8 = r->n[8], t9 = r->n[9];\n \n@@ -210,7 +211,7 @@ static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n     return (z0 == 0) | (z1 == 0x3FFFFFFUL);\n }\n \n-static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n     uint32_t t0, t1, t2, t3, t4, t5, t6, t7, t8, t9;\n     uint32_t z0, z1;\n     uint32_t x;\n@@ -1164,4 +1165,92 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #endif\n }\n \n+static void secp256k1_fe_from_signed30(secp256k1_fe *r, const secp256k1_modinv32_signed30 *a) {\n+    const uint32_t M26 = UINT32_MAX >> 6;\n+    const uint32_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4],\n+                   a5 = a->v[5], a6 = a->v[6], a7 = a->v[7], a8 = a->v[8];\n+\n+    /* The output from secp256k1_modinv32{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^30). The modulus is < 2^256, so the top limb must be below 2^(256-30*8).\n+     */\n+    VERIFY_CHECK(a0 >> 30 == 0);\n+    VERIFY_CHECK(a1 >> 30 == 0);\n+    VERIFY_CHECK(a2 >> 30 == 0);\n+    VERIFY_CHECK(a3 >> 30 == 0);\n+    VERIFY_CHECK(a4 >> 30 == 0);\n+    VERIFY_CHECK(a5 >> 30 == 0);\n+    VERIFY_CHECK(a6 >> 30 == 0);\n+    VERIFY_CHECK(a7 >> 30 == 0);\n+    VERIFY_CHECK(a8 >> 16 == 0);\n+\n+    r->n[0] =  a0                   & M26;\n+    r->n[1] = (a0 >> 26 | a1 <<  4) & M26;\n+    r->n[2] = (a1 >> 22 | a2 <<  8) & M26;\n+    r->n[3] = (a2 >> 18 | a3 << 12) & M26;\n+    r->n[4] = (a3 >> 14 | a4 << 16) & M26;\n+    r->n[5] = (a4 >> 10 | a5 << 20) & M26;\n+    r->n[6] = (a5 >>  6 | a6 << 24) & M26;\n+    r->n[7] = (a6 >>  2           ) & M26;\n+    r->n[8] = (a6 >> 28 | a7 <<  2) & M26;\n+    r->n[9] = (a7 >> 24 | a8 <<  6);\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+static void secp256k1_fe_to_signed30(secp256k1_modinv32_signed30 *r, const secp256k1_fe *a) {\n+    const uint32_t M30 = UINT32_MAX >> 2;\n+    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4],\n+                   a5 = a->n[5], a6 = a->n[6], a7 = a->n[7], a8 = a->n[8], a9 = a->n[9];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+#endif\n+\n+    r->v[0] = (a0       | a1 << 26) & M30;\n+    r->v[1] = (a1 >>  4 | a2 << 22) & M30;\n+    r->v[2] = (a2 >>  8 | a3 << 18) & M30;\n+    r->v[3] = (a3 >> 12 | a4 << 14) & M30;\n+    r->v[4] = (a4 >> 16 | a5 << 10) & M30;\n+    r->v[5] = (a5 >> 20 | a6 <<  6) & M30;\n+    r->v[6] = (a6 >> 24 | a7 <<  2\n+                        | a8 << 28) & M30;\n+    r->v[7] = (a8 >>  2 | a9 << 24) & M30;\n+    r->v[8] =  a9 >>  6;\n+}\n+\n+static const secp256k1_modinv32_modinfo secp256k1_const_modinfo_fe = {\n+    {{-0x3D1, -4, 0, 0, 0, 0, 0, 0, 65536}},\n+    0x2DDACACFL\n+};\n+\n+static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv32_signed30 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize(&tmp);\n+    secp256k1_fe_to_signed30(&s, &tmp);\n+    secp256k1_modinv32(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed30(r, &s);\n+\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+}\n+\n+static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv32_signed30 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    secp256k1_fe_to_signed30(&s, &tmp);\n+    secp256k1_modinv32_var(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed30(r, &s);\n+\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "50ee3f9ec96b746b6565ef1655440730802a552d",
        "filename": "src/secp256k1/src/field_5x52.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_H\n #define SECP256K1_FIELD_REPR_H"
      },
      {
        "sha": "a2118044ab381de4916a87d5accaedb2e1949539",
        "filename": "src/secp256k1/src/field_5x52_asm_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52_asm_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52_asm_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_asm_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2014 Diederik Huys, Pieter Wuille               *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2014 Diederik Huys, Pieter Wuille                *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n /**\n  * Changelog:"
      },
      {
        "sha": "60ded927f6e834ddb30d46e333abf36918349b8f",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 84,
        "deletions": 7,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_REPR_IMPL_H\n #define SECP256K1_FIELD_REPR_IMPL_H\n@@ -13,6 +13,7 @@\n \n #include \"util.h\"\n #include \"field.h\"\n+#include \"modinv64_impl.h\"\n \n #if defined(USE_ASM_X86_64)\n #include \"field_5x52_asm_impl.h\"\n@@ -161,7 +162,7 @@ static void secp256k1_fe_normalize_var(secp256k1_fe *r) {\n #endif\n }\n \n-static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero(const secp256k1_fe *r) {\n     uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];\n \n     /* z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P */\n@@ -184,7 +185,7 @@ static int secp256k1_fe_normalizes_to_zero(secp256k1_fe *r) {\n     return (z0 == 0) | (z1 == 0xFFFFFFFFFFFFFULL);\n }\n \n-static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r) {\n+static int secp256k1_fe_normalizes_to_zero_var(const secp256k1_fe *r) {\n     uint64_t t0, t1, t2, t3, t4;\n     uint64_t z0, z1;\n     uint64_t x;\n@@ -498,4 +499,80 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #endif\n }\n \n+static void secp256k1_fe_from_signed62(secp256k1_fe *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t M52 = UINT64_MAX >> 12;\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n+\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n+\n+    r->n[0] =  a0                   & M52;\n+    r->n[1] = (a0 >> 52 | a1 << 10) & M52;\n+    r->n[2] = (a1 >> 42 | a2 << 20) & M52;\n+    r->n[3] = (a2 >> 32 | a3 << 30) & M52;\n+    r->n[4] = (a3 >> 22 | a4 << 40);\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+static void secp256k1_fe_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_fe *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+#endif\n+\n+    r->v[0] = (a0       | a1 << 52) & M62;\n+    r->v[1] = (a1 >> 10 | a2 << 42) & M62;\n+    r->v[2] = (a2 >> 20 | a3 << 32) & M62;\n+    r->v[3] = (a3 >> 30 | a4 << 22) & M62;\n+    r->v[4] =  a4 >> 40;\n+}\n+\n+static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_fe = {\n+    {{-0x1000003D1LL, 0, 0, 0, 256}},\n+    0x27C7F6E22DDACACFLL\n+};\n+\n+static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize(&tmp);\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+#endif\n+}\n+\n+static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n+#endif\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "314002ee3950f1d4fe5b4a30699883c9b4f0e4ea",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_INNER5X52_IMPL_H\n #define SECP256K1_FIELD_INNER5X52_IMPL_H"
      },
      {
        "sha": "374284a1f4ce974cd551fd4e66b9d274381dc043",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 185,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_FIELD_IMPL_H\n #define SECP256K1_FIELD_IMPL_H\n@@ -12,7 +12,6 @@\n #endif\n \n #include \"util.h\"\n-#include \"num.h\"\n \n #if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52_impl.h\"\n@@ -136,185 +135,6 @@ static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     return secp256k1_fe_equal(&t1, a);\n }\n \n-static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n-    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;\n-    int j;\n-\n-    /** The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n-     *  { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n-     *  [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n-     */\n-\n-    secp256k1_fe_sqr(&x2, a);\n-    secp256k1_fe_mul(&x2, &x2, a);\n-\n-    secp256k1_fe_sqr(&x3, &x2);\n-    secp256k1_fe_mul(&x3, &x3, a);\n-\n-    x6 = x3;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x6, &x6);\n-    }\n-    secp256k1_fe_mul(&x6, &x6, &x3);\n-\n-    x9 = x6;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x9, &x9);\n-    }\n-    secp256k1_fe_mul(&x9, &x9, &x3);\n-\n-    x11 = x9;\n-    for (j=0; j<2; j++) {\n-        secp256k1_fe_sqr(&x11, &x11);\n-    }\n-    secp256k1_fe_mul(&x11, &x11, &x2);\n-\n-    x22 = x11;\n-    for (j=0; j<11; j++) {\n-        secp256k1_fe_sqr(&x22, &x22);\n-    }\n-    secp256k1_fe_mul(&x22, &x22, &x11);\n-\n-    x44 = x22;\n-    for (j=0; j<22; j++) {\n-        secp256k1_fe_sqr(&x44, &x44);\n-    }\n-    secp256k1_fe_mul(&x44, &x44, &x22);\n-\n-    x88 = x44;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x88, &x88);\n-    }\n-    secp256k1_fe_mul(&x88, &x88, &x44);\n-\n-    x176 = x88;\n-    for (j=0; j<88; j++) {\n-        secp256k1_fe_sqr(&x176, &x176);\n-    }\n-    secp256k1_fe_mul(&x176, &x176, &x88);\n-\n-    x220 = x176;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x220, &x220);\n-    }\n-    secp256k1_fe_mul(&x220, &x220, &x44);\n-\n-    x223 = x220;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x223, &x223);\n-    }\n-    secp256k1_fe_mul(&x223, &x223, &x3);\n-\n-    /* The final result is then assembled using a sliding window over the blocks. */\n-\n-    t1 = x223;\n-    for (j=0; j<23; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(&t1, &t1, &x22);\n-    for (j=0; j<5; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(&t1, &t1, a);\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(&t1, &t1, &x2);\n-    for (j=0; j<2; j++) {\n-        secp256k1_fe_sqr(&t1, &t1);\n-    }\n-    secp256k1_fe_mul(r, a, &t1);\n-}\n-\n-static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a) {\n-#if defined(USE_FIELD_INV_BUILTIN)\n-    secp256k1_fe_inv(r, a);\n-#elif defined(USE_FIELD_INV_NUM)\n-    secp256k1_num n, m;\n-    static const secp256k1_fe negone = SECP256K1_FE_CONST(\n-        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n-        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFEUL, 0xFFFFFC2EUL\n-    );\n-    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n-    static const unsigned char prime[32] = {\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n-    };\n-    unsigned char b[32];\n-    int res;\n-    secp256k1_fe c = *a;\n-    secp256k1_fe_normalize_var(&c);\n-    secp256k1_fe_get_b32(b, &c);\n-    secp256k1_num_set_bin(&n, b, 32);\n-    secp256k1_num_set_bin(&m, prime, 32);\n-    secp256k1_num_mod_inverse(&n, &n, &m);\n-    secp256k1_num_get_bin(b, 32, &n);\n-    res = secp256k1_fe_set_b32(r, b);\n-    (void)res;\n-    VERIFY_CHECK(res);\n-    /* Verify the result is the (unique) valid inverse using non-GMP code. */\n-    secp256k1_fe_mul(&c, &c, r);\n-    secp256k1_fe_add(&c, &negone);\n-    CHECK(secp256k1_fe_normalizes_to_zero_var(&c));\n-#else\n-#error \"Please select field inverse implementation\"\n-#endif\n-}\n-\n-static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len) {\n-    secp256k1_fe u;\n-    size_t i;\n-    if (len < 1) {\n-        return;\n-    }\n-\n-    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n-\n-    r[0] = a[0];\n-\n-    i = 0;\n-    while (++i < len) {\n-        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n-    }\n-\n-    secp256k1_fe_inv_var(&u, &r[--i]);\n-\n-    while (i > 0) {\n-        size_t j = i--;\n-        secp256k1_fe_mul(&r[j], &r[i], &u);\n-        secp256k1_fe_mul(&u, &u, &a[j]);\n-    }\n-\n-    r[0] = u;\n-}\n-\n-static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n-#ifndef USE_NUM_NONE\n-    unsigned char b[32];\n-    secp256k1_num n;\n-    secp256k1_num m;\n-    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n-    static const unsigned char prime[32] = {\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n-    };\n-\n-    secp256k1_fe c = *a;\n-    secp256k1_fe_normalize_var(&c);\n-    secp256k1_fe_get_b32(b, &c);\n-    secp256k1_num_set_bin(&n, b, 32);\n-    secp256k1_num_set_bin(&m, prime, 32);\n-    return secp256k1_num_jacobi(&n, &m) >= 0;\n-#else\n-    secp256k1_fe r;\n-    return secp256k1_fe_sqrt(&r, a);\n-#endif\n-}\n-\n static const secp256k1_fe secp256k1_fe_one = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n \n #endif /* SECP256K1_FIELD_IMPL_H */"
      },
      {
        "sha": "024c55726170f044e1a760921389d0b7e150ac67",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,16 +1,17 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014, 2015 Thomas Daede, Cory Fields           *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014, 2015 Thomas Daede, Cory Fields            *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-// Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n-// ifndef guard so downstream users can define their own if they do not use autotools.\n+/* Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n+   ifndef guard so downstream users can define their own if they do not use autotools. */\n #if !defined(ECMULT_GEN_PREC_BITS)\n #include \"libsecp256k1-config.h\"\n #endif\n-#define USE_BASIC_CONFIG 1\n-#include \"basic-config.h\"\n+\n+/* We can't require the precomputed tables when creating them. */\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n \n #include \"include/secp256k1.h\"\n #include \"assumptions.h\"\n@@ -47,8 +48,8 @@ int main(int argc, char **argv) {\n         return -1;\n     }\n \n-    fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n-    fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n+    fprintf(fp, \"#ifndef SECP256K1_ECMULT_STATIC_CONTEXT_H\\n\");\n+    fprintf(fp, \"#define SECP256K1_ECMULT_STATIC_CONTEXT_H\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n     fprintf(fp, \"#if ECMULT_GEN_PREC_N != %d || ECMULT_GEN_PREC_G != %d\\n\", ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G);"
      },
      {
        "sha": "b9cd334dae26c7990ac43d93613b346132134a91",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 9,
        "deletions": 16,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_GROUP_H\n #define SECP256K1_GROUP_H\n \n-#include \"num.h\"\n #include \"field.h\"\n \n /** A group element of the secp256k1 curve, in affine coordinates. */\n@@ -43,12 +42,6 @@ typedef struct {\n /** Set a group element equal to the point with given X and Y coordinates */\n static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const secp256k1_fe *y);\n \n-/** Set a group element (affine) equal to the point with the given X coordinate\n- *  and a Y coordinate that is a quadratic residue modulo p. The return value\n- *  is true iff a coordinate with the given X coordinate exists.\n- */\n-static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n-\n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd);\n@@ -62,9 +55,12 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a);\n /** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n \n-/** Set a group element equal to another which is given in jacobian coordinates */\n+/** Set a group element equal to another which is given in jacobian coordinates. Constant time. */\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n+/** Set a group element equal to another which is given in jacobian coordinates. */\n+static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a);\n+\n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len);\n \n@@ -93,9 +89,6 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n-/** Check whether a group element's y coordinate is a quadratic residue. */\n-static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n-\n /** Set r equal to the double of a. Constant time. */\n static void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a);\n "
      },
      {
        "sha": "19ebd8f44ee384b9715704dc3eec48466f42458f",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 28,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_GROUP_IMPL_H\n #define SECP256K1_GROUP_IMPL_H\n \n-#include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n \n@@ -207,18 +206,14 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n     secp256k1_fe x2, x3;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n     secp256k1_fe_add(&x3, &secp256k1_fe_const_b);\n-    return secp256k1_fe_sqrt(&r->y, &x3);\n-}\n-\n-static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad(r, x)) {\n+    if (!secp256k1_fe_sqrt(&r->y, &x3)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -591,7 +586,7 @@ static void secp256k1_gej_add_ge(secp256k1_gej *r, const secp256k1_gej *a, const\n     secp256k1_fe_cmov(&n, &m, degenerate);              /* n = M^3 * Malt (2) */\n     secp256k1_fe_sqr(&t, &rr_alt);                      /* t = Ralt^2 (1) */\n     secp256k1_fe_mul(&r->z, &a->z, &m_alt);             /* r->z = Malt*Z (1) */\n-    infinity = secp256k1_fe_normalizes_to_zero(&r->z) * (1 - a->infinity);\n+    infinity = secp256k1_fe_normalizes_to_zero(&r->z) & ~a->infinity;\n     secp256k1_fe_mul_int(&r->z, 2);                     /* r->z = Z3 = 2*Malt*Z (2) */\n     secp256k1_fe_negate(&q, &q, 1);                     /* q = -Q (2) */\n     secp256k1_fe_add(&t, &q);                           /* t = Ralt^2-Q (3) */\n@@ -655,26 +650,12 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n     secp256k1_fe_mul(&r->x, &r->x, &beta);\n }\n \n-static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n-    secp256k1_fe yz;\n-\n-    if (a->infinity) {\n-        return 0;\n-    }\n-\n-    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n-     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n-       is */\n-    secp256k1_fe_mul(&yz, &a->y, &a->z);\n-    return secp256k1_fe_is_quad_var(&yz);\n-}\n-\n static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\n #ifdef EXHAUSTIVE_TEST_ORDER\n     secp256k1_gej out;\n     int i;\n \n-    /* A very simple EC multiplication ladder that avoids a dependecy on ecmult. */\n+    /* A very simple EC multiplication ladder that avoids a dependency on ecmult. */\n     secp256k1_gej_set_infinity(&out);\n     for (i = 0; i < 32; ++i) {\n         secp256k1_gej_double_var(&out, &out, NULL);"
      },
      {
        "sha": "0947a096943a9d7c3106fbcf61365eb26368ae29",
        "filename": "src/secp256k1/src/hash.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_HASH_H\n #define SECP256K1_HASH_H"
      },
      {
        "sha": "f8cd3a1634113eba4b692f73cc62e31248df0241",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_HASH_IMPL_H\n #define SECP256K1_HASH_IMPL_H"
      },
      {
        "sha": "0efdda9ab5e2ef2dddd974dcfd411de176da4b3f",
        "filename": "src/secp256k1/src/modinv32.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv32.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,42 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_H\n+#define SECP256K1_MODINV32_H\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"util.h\"\n+\n+/* A signed 30-bit limb representation of integers.\n+ *\n+ * Its value is sum(v[i] * 2^(30*i), i=0..8). */\n+typedef struct {\n+    int32_t v[9];\n+} secp256k1_modinv32_signed30;\n+\n+typedef struct {\n+    /* The modulus in signed30 notation, must be odd and in [3, 2^256]. */\n+    secp256k1_modinv32_signed30 modulus;\n+\n+    /* modulus^{-1} mod 2^30 */\n+    uint32_t modulus_inv30;\n+} secp256k1_modinv32_modinfo;\n+\n+/* Replace x with its modular inverse mod modinfo->modulus. x must be in range [0, modulus).\n+ * If x is zero, the result will be zero as well. If not, the inverse must exist (i.e., the gcd of\n+ * x and modulus must be 1). These rules are automatically satisfied if the modulus is prime.\n+ *\n+ * On output, all of x's limbs will be in [0, 2^30).\n+ */\n+static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n+\n+/* Same as secp256k1_modinv32_var, but constant time in x (not in the modulus). */\n+static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n+\n+#endif /* SECP256K1_MODINV32_H */"
      },
      {
        "sha": "661c5fc04c988372954ee4b09b4686651d481cba",
        "filename": "src/secp256k1/src/modinv32_impl.h",
        "status": "added",
        "additions": 587,
        "deletions": 0,
        "changes": 587,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv32_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,587 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+#include <stdlib.h>\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n+ */\n+\n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int alen, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        if (i < alen) c += (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    if (8 < alen) c += (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Return -1 for a<b*factor, 0 for a==b*factor, 1 for a>b*factor. A consists of alen limbs; b has 9. */\n+static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, int alen, const secp256k1_modinv32_signed30 *b, int32_t factor) {\n+    int i;\n+    secp256k1_modinv32_signed30 am, bm;\n+    secp256k1_modinv32_mul_30(&am, a, alen, 1); /* Normalize all but the top limb of a. */\n+    secp256k1_modinv32_mul_30(&bm, b, 9, factor);\n+    for (i = 0; i < 8; ++i) {\n+        /* Verify that all but the top limb of a and b are normalized. */\n+        VERIFY_CHECK(am.v[i] >> 30 == 0);\n+        VERIFY_CHECK(bm.v[i] >> 30 == 0);\n+    }\n+    for (i = 8; i >= 0; --i) {\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Take as input a signed30 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^30,2^30). The output will have limbs in range\n+ * [0,2^30). */\n+static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int32_t sign, const secp256k1_modinv32_modinfo *modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4],\n+            r5 = r->v[5], r6 = r->v[6], r7 = r->v[7], r8 = r->v[8];\n+    int32_t cond_add, cond_negate;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^30,2^30). */\n+    int i;\n+    for (i = 0; i < 9; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M30);\n+        VERIFY_CHECK(r->v[i] <= M30);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^30,2^30), this cannot overflow an int32_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r8 >> 31;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r5 += modinfo->modulus.v[5] & cond_add;\n+    r6 += modinfo->modulus.v[6] & cond_add;\n+    r7 += modinfo->modulus.v[7] & cond_add;\n+    r8 += modinfo->modulus.v[8] & cond_add;\n+    cond_negate = sign >> 31;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    r5 = (r5 ^ cond_negate) - cond_negate;\n+    r6 = (r6 ^ cond_negate) - cond_negate;\n+    r7 = (r7 ^ cond_negate) - cond_negate;\n+    r8 = (r8 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^30,2^30). */\n+    r1 += r0 >> 30; r0 &= M30;\n+    r2 += r1 >> 30; r1 &= M30;\n+    r3 += r2 >> 30; r2 &= M30;\n+    r4 += r3 >> 30; r3 &= M30;\n+    r5 += r4 >> 30; r4 &= M30;\n+    r6 += r5 >> 30; r5 &= M30;\n+    r7 += r6 >> 30; r6 &= M30;\n+    r8 += r7 >> 30; r7 &= M30;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing r to range\n+     * [0,modulus). */\n+    cond_add = r8 >> 31;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r5 += modinfo->modulus.v[5] & cond_add;\n+    r6 += modinfo->modulus.v[6] & cond_add;\n+    r7 += modinfo->modulus.v[7] & cond_add;\n+    r8 += modinfo->modulus.v[8] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 30; r0 &= M30;\n+    r2 += r1 >> 30; r1 &= M30;\n+    r3 += r2 >> 30; r2 &= M30;\n+    r4 += r3 >> 30; r3 &= M30;\n+    r5 += r4 >> 30; r4 &= M30;\n+    r6 += r5 >> 30; r5 &= M30;\n+    r7 += r6 >> 30; r6 &= M30;\n+    r8 += r7 >> 30; r7 &= M30;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+    r->v[5] = r5;\n+    r->v[6] = r6;\n+    r->v[7] = r7;\n+    r->v[8] = r8;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r0 >> 30 == 0);\n+    VERIFY_CHECK(r1 >> 30 == 0);\n+    VERIFY_CHECK(r2 >> 30 == 0);\n+    VERIFY_CHECK(r3 >> 30 == 0);\n+    VERIFY_CHECK(r4 >> 30 == 0);\n+    VERIFY_CHECK(r5 >> 30 == 0);\n+    VERIFY_CHECK(r6 >> 30 == 0);\n+    VERIFY_CHECK(r7 >> 30 == 0);\n+    VERIFY_CHECK(r8 >> 30 == 0);\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int32_t u, v, q, r;\n+} secp256k1_modinv32_trans2x2;\n+\n+/* Compute the transition matrix and zeta for 30 divsteps.\n+ *\n+ * Input:  zeta: initial zeta\n+ *         f0:   bottom limb of initial f\n+ *         g0:   bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final zeta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int32_t secp256k1_modinv32_divsteps_30(int32_t zeta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\n+    /* u,v,q,r are the elements of the transformation matrix being built up,\n+     * starting with the identity matrix. Semantically they are signed integers\n+     * in range [-2^30,2^30], but here represented as unsigned mod 2^32. This\n+     * permits left shifting (which is UB for negative numbers). The range\n+     * being inside [-2^31,2^31) means that casting to signed works correctly.\n+     */\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (zeta < 0) and for (g & 1). */\n+        c1 = zeta >> 31;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (zeta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally change zeta into -zeta-2 or zeta-1. */\n+        zeta = (zeta ^ c1) - 1;\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+        /* Bounds on zeta that follow from the bounds on iteration count (max 20*30 divsteps). */\n+        VERIFY_CHECK(zeta >= -601 && zeta <= 601);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int32_t)u;\n+    t->v = (int32_t)v;\n+    t->q = (int32_t)q;\n+    t->r = (int32_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 30 of them will have determinant 2^30. */\n+    VERIFY_CHECK((int64_t)t->u * t->r - (int64_t)t->v * t->q == ((int64_t)1) << 30);\n+    return zeta;\n+}\n+\n+/* Compute the transition matrix and eta for 30 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    /* Transformation matrix; see comments in secp256k1_modinv32_divsteps_30. */\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m;\n+    uint16_t w;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+         /* We're done once we've done 30 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+        /* Bounds on eta that follow from the bounds on iteration count (max 25*30 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint32_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        VERIFY_CHECK(limit > 0 && limit <= 30);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int32_t)u;\n+    t->v = (int32_t)v;\n+    t->q = (int32_t)q;\n+    t->r = (int32_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 30 of them will have determinant 2^30. */\n+    VERIFY_CHECK((int64_t)t->u * t->r - (int64_t)t->v * t->q == ((int64_t)1) << 30);\n+    return eta;\n+}\n+\n+/* Compute (t/2^30) * [d, e] mod modulus, where t is a transition matrix for 30 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^30,2^30).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const secp256k1_modinv32_trans2x2 *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    const int32_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int32_t di, ei, md, me, sd, se;\n+    int64_t cd, ce;\n+    int i;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+    VERIFY_CHECK((labs(u) + labs(v)) >= 0); /* |u|+|v| doesn't overflow */\n+    VERIFY_CHECK((labs(q) + labs(r)) >= 0); /* |q|+|r| doesn't overflow */\n+    VERIFY_CHECK((labs(u) + labs(v)) <= M30 + 1); /* |u|+|v| <= 2^30 */\n+    VERIFY_CHECK((labs(q) + labs(r)) <= M30 + 1); /* |q|+|r| <= 2^30 */\n+#endif\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d->v[8] >> 31;\n+    se = e->v[8] >> 31;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    di = d->v[0];\n+    ei = e->v[0];\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 30 zero bottom bits. */\n+    md -= (modinfo->modulus_inv30 * (uint32_t)cd + md) & M30;\n+    me -= (modinfo->modulus_inv30 * (uint32_t)ce + me) & M30;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int64_t)modinfo->modulus.v[0] * md;\n+    ce += (int64_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 30 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int32_t)cd & M30) == 0); cd >>= 30;\n+    VERIFY_CHECK(((int32_t)ce & M30) == 0); ce >>= 30;\n+    /* Now iteratively compute limb i=1..8 of t*[d,e]+modulus*[md,me], and store them in output\n+     * limb i-1 (shifting down by 30 bits). */\n+    for (i = 1; i < 9; ++i) {\n+        di = d->v[i];\n+        ei = e->v[i];\n+        cd += (int64_t)u * di + (int64_t)v * ei;\n+        ce += (int64_t)q * di + (int64_t)r * ei;\n+        cd += (int64_t)modinfo->modulus.v[i] * md;\n+        ce += (int64_t)modinfo->modulus.v[i] * me;\n+        d->v[i - 1] = (int32_t)cd & M30; cd >>= 30;\n+        e->v[i - 1] = (int32_t)ce & M30; ce >>= 30;\n+    }\n+    /* What remains is limb 9 of t*[d,e]+modulus*[md,me]; store it as output limb 8. */\n+    d->v[8] = (int32_t)cd;\n+    e->v[8] = (int32_t)ce;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(d, 9, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(e, 9, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+#endif\n+}\n+\n+/* Compute (t/2^30) * [f, g], where t is a transition matrix for 30 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv32_update_fg_30(secp256k1_modinv32_signed30 *f, secp256k1_modinv32_signed30 *g, const secp256k1_modinv32_trans2x2 *t) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    const int32_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int32_t fi, gi;\n+    int64_t cf, cg;\n+    int i;\n+    /* Start computing t*[f,g]. */\n+    fi = f->v[0];\n+    gi = g->v[0];\n+    cf = (int64_t)u * fi + (int64_t)v * gi;\n+    cg = (int64_t)q * fi + (int64_t)r * gi;\n+    /* Verify that the bottom 30 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int32_t)cf & M30) == 0); cf >>= 30;\n+    VERIFY_CHECK(((int32_t)cg & M30) == 0); cg >>= 30;\n+    /* Now iteratively compute limb i=1..8 of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by 30 bits). */\n+    for (i = 1; i < 9; ++i) {\n+        fi = f->v[i];\n+        gi = g->v[i];\n+        cf += (int64_t)u * fi + (int64_t)v * gi;\n+        cg += (int64_t)q * fi + (int64_t)r * gi;\n+        f->v[i - 1] = (int32_t)cf & M30; cf >>= 30;\n+        g->v[i - 1] = (int32_t)cg & M30; cg >>= 30;\n+    }\n+    /* What remains is limb 9 of t*[f,g]; store it as output limb 8. */\n+    f->v[8] = (int32_t)cf;\n+    g->v[8] = (int32_t)cg;\n+}\n+\n+/* Compute (t/2^30) * [f, g], where t is a transition matrix for 30 divsteps.\n+ *\n+ * Version that operates on a variable number of limbs in f and g.\n+ *\n+ * This implements the update_fg function from the explanation in modinv64_impl.h.\n+ */\n+static void secp256k1_modinv32_update_fg_30_var(int len, secp256k1_modinv32_signed30 *f, secp256k1_modinv32_signed30 *g, const secp256k1_modinv32_trans2x2 *t) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    const int32_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int32_t fi, gi;\n+    int64_t cf, cg;\n+    int i;\n+    VERIFY_CHECK(len > 0);\n+    /* Start computing t*[f,g]. */\n+    fi = f->v[0];\n+    gi = g->v[0];\n+    cf = (int64_t)u * fi + (int64_t)v * gi;\n+    cg = (int64_t)q * fi + (int64_t)r * gi;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int32_t)cf & M30) == 0); cf >>= 30;\n+    VERIFY_CHECK(((int32_t)cg & M30) == 0); cg >>= 30;\n+    /* Now iteratively compute limb i=1..len of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by 30 bits). */\n+    for (i = 1; i < len; ++i) {\n+        fi = f->v[i];\n+        gi = g->v[i];\n+        cf += (int64_t)u * fi + (int64_t)v * gi;\n+        cg += (int64_t)q * fi + (int64_t)r * gi;\n+        f->v[i - 1] = (int32_t)cf & M30; cf >>= 30;\n+        g->v[i - 1] = (int32_t)cg & M30; cg >>= 30;\n+    }\n+    /* What remains is limb (len) of t*[f,g]; store it as output limb (len-1). */\n+    f->v[len - 1] = (int32_t)cf;\n+    g->v[len - 1] = (int32_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, zeta=-1. */\n+    secp256k1_modinv32_signed30 d = {{0}};\n+    secp256k1_modinv32_signed30 e = {{1}};\n+    secp256k1_modinv32_signed30 f = modinfo->modulus;\n+    secp256k1_modinv32_signed30 g = *x;\n+    int i;\n+    int32_t zeta = -1; /* zeta = -(delta+1/2); delta is initially 1/2. */\n+\n+    /* Do 20 iterations of 30 divsteps each = 600 divsteps. 590 suffices for 256-bit inputs. */\n+    for (i = 0; i < 20; ++i) {\n+        /* Compute transition matrix and new zeta after 30 divsteps. */\n+        secp256k1_modinv32_trans2x2 t;\n+        zeta = secp256k1_modinv32_divsteps_30(zeta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv32_update_de_30(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv32_update_fg_30(&f, &g, &t);\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, 9, &SECP256K1_SIGNED30_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, 9, &SECP256K1_SIGNED30_ONE, -1) == 0 ||\n+                 secp256k1_modinv32_mul_cmp_30(&f, 9, &SECP256K1_SIGNED30_ONE, 1) == 0 ||\n+                 (secp256k1_modinv32_mul_cmp_30(x, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  secp256k1_modinv32_mul_cmp_30(&d, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  (secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv32_mul_cmp_30(&f, 9, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv32_normalize_30(&d, f.v[8], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv32_signed30 d = {{0, 0, 0, 0, 0, 0, 0, 0, 0}};\n+    secp256k1_modinv32_signed30 e = {{1, 0, 0, 0, 0, 0, 0, 0, 0}};\n+    secp256k1_modinv32_signed30 f = modinfo->modulus;\n+    secp256k1_modinv32_signed30 g = *x;\n+#ifdef VERIFY\n+    int i = 0;\n+#endif\n+    int j, len = 9;\n+    int32_t eta = -1; /* eta = -delta; delta is initially 1 (faster for the variable-time code) */\n+    int32_t cond, fn, gn;\n+\n+    /* Do iterations of 30 divsteps each until g=0. */\n+    while (1) {\n+        /* Compute transition matrix and new eta after 30 divsteps. */\n+        secp256k1_modinv32_trans2x2 t;\n+        eta = secp256k1_modinv32_divsteps_30_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv32_update_de_30(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv32_update_fg_30_var(len, &f, &g, &t);\n+        /* If the bottom limb of g is 0, there is a chance g=0. */\n+        if (g.v[0] == 0) {\n+            cond = 0;\n+            /* Check if all other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= g.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) break;\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0 or -1. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int32_t)len - 2) >> 31;\n+        cond |= fn ^ (fn >> 31);\n+        cond |= gn ^ (gn >> 31);\n+        /* If so, reduce length, propagating the sign of f and g's top limb into the one below. */\n+        if (cond == 0) {\n+            f.v[len - 2] |= (uint32_t)fn << 30;\n+            g.v[len - 2] |= (uint32_t)gn << 30;\n+            --len;\n+        }\n+#ifdef VERIFY\n+        VERIFY_CHECK(++i < 25); /* We should never need more than 25*30 = 750 divsteps */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point g is 0 and (if g was not originally 0) f must now equal +/- GCD of\n+     * the initial f, g values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &SECP256K1_SIGNED30_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &SECP256K1_SIGNED30_ONE, -1) == 0 ||\n+                 secp256k1_modinv32_mul_cmp_30(&f, len, &SECP256K1_SIGNED30_ONE, 1) == 0 ||\n+                 (secp256k1_modinv32_mul_cmp_30(x, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  secp256k1_modinv32_mul_cmp_30(&d, 9, &SECP256K1_SIGNED30_ONE, 0) == 0 &&\n+                  (secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv32_normalize_30(&d, f.v[len - 1], modinfo);\n+    *x = d;\n+}\n+\n+#endif /* SECP256K1_MODINV32_IMPL_H */"
      },
      {
        "sha": "da506dfa9f722e2bc697209a7aeaf2ec574318b9",
        "filename": "src/secp256k1/src/modinv64.h",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv64.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,46 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_H\n+#define SECP256K1_MODINV64_H\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"util.h\"\n+\n+#ifndef SECP256K1_WIDEMUL_INT128\n+#error \"modinv64 requires 128-bit wide multiplication support\"\n+#endif\n+\n+/* A signed 62-bit limb representation of integers.\n+ *\n+ * Its value is sum(v[i] * 2^(62*i), i=0..4). */\n+typedef struct {\n+    int64_t v[5];\n+} secp256k1_modinv64_signed62;\n+\n+typedef struct {\n+    /* The modulus in signed62 notation, must be odd and in [3, 2^256]. */\n+    secp256k1_modinv64_signed62 modulus;\n+\n+    /* modulus^{-1} mod 2^62 */\n+    uint64_t modulus_inv62;\n+} secp256k1_modinv64_modinfo;\n+\n+/* Replace x with its modular inverse mod modinfo->modulus. x must be in range [0, modulus).\n+ * If x is zero, the result will be zero as well. If not, the inverse must exist (i.e., the gcd of\n+ * x and modulus must be 1). These rules are automatically satisfied if the modulus is prime.\n+ *\n+ * On output, all of x's limbs will be in [0, 2^62).\n+ */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n+\n+/* Same as secp256k1_modinv64_var, but constant time in x (not in the modulus). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n+\n+#endif /* SECP256K1_MODINV64_H */"
      },
      {
        "sha": "0743a9c8210d2d42af3535f9acbe96b5f4a3028d",
        "filename": "src/secp256k1/src/modinv64_impl.h",
        "status": "added",
        "additions": 593,
        "deletions": 0,
        "changes": 593,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modinv64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv64_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -0,0 +1,593 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) c += (int128_t)a->v[i] * factor;\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) c += (int128_t)a->v[4] * factor;\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Return -1 for a<b*factor, 0 for a==b*factor, 1 for a>b*factor. A has alen limbs; b has 5. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1); /* Normalize all but the top limb of a. */\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 0; i < 4; ++i) {\n+        /* Verify that all but the top limb of a and b are normalized. */\n+        VERIFY_CHECK(am.v[i] >> 62 == 0);\n+        VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+    }\n+    for (i = 4; i >= 0; --i) {\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r0 >> 62 == 0);\n+    VERIFY_CHECK(r1 >> 62 == 0);\n+    VERIFY_CHECK(r2 >> 62 == 0);\n+    VERIFY_CHECK(r3 >> 62 == 0);\n+    VERIFY_CHECK(r4 >> 62 == 0);\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 59 divsteps (where zeta=-(delta+1/2)).\n+ * Note that the transformation matrix is scaled by 2^62 and not 2^59.\n+ *\n+ * Input:  zeta: initial zeta\n+ *         f0:   bottom limb of initial f\n+ *         g0:   bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final zeta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_59(int64_t zeta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* u,v,q,r are the elements of the transformation matrix being built up,\n+     * starting with the identity matrix times 8 (because the caller expects\n+     * a result scaled by 2^62). Semantically they are signed integers\n+     * in range [-2^62,2^62], but here represented as unsigned mod 2^64. This\n+     * permits left shifting (which is UB for negative numbers). The range\n+     * being inside [-2^63,2^63) means that casting to signed works correctly.\n+     */\n+    uint64_t u = 8, v = 0, q = 0, r = 8;\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 3; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (zeta < 0) and for (g & 1). */\n+        c1 = zeta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (zeta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally change zeta into -zeta-2 or zeta-1. */\n+        zeta = (zeta ^ c1) - 1;\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+        /* Bounds on zeta that follow from the bounds on iteration count (max 10*59 divsteps). */\n+        VERIFY_CHECK(zeta >= -591 && zeta <= 591);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 59 of them will have determinant 2^59. Multiplying with the initial\n+     * 8*identity (which has determinant 2^6) means the overall outputs has determinant\n+     * 2^65. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 65);\n+    return zeta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time, eta=-delta).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */\n+    uint64_t u = 1, v = 0, q = 0, r = 1;\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* Bounds on eta that follow from the bounds on iteration count (max 12*62 divsteps). */\n+        VERIFY_CHECK(eta >= -745 && eta <= 745);\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;\n+        } else {\n+            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as\n+             * eta tends to be smaller here. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 4) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 15U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 4)\n+             * bits. */\n+            w = f + (((f + 1) & 4) << 1);\n+            w = (-w * g) & m;\n+        }\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 62 of them will have determinant 2^62. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 62);\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix scaled by 2^62.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(u) + secp256k1_modinv64_abs(v)) >= 0); /* |u|+|v| doesn't overflow */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(q) + secp256k1_modinv64_abs(r)) >= 0); /* |q|+|r| doesn't overflow */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(u) + secp256k1_modinv64_abs(v)) <= M62 + 1); /* |u|+|v| <= 2^62 */\n+    VERIFY_CHECK((secp256k1_modinv64_abs(q) + secp256k1_modinv64_abs(r)) <= M62 + 1); /* |q|+|r| <= 2^62 */\n+#endif\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    if (modinfo->modulus.v[1]) { /* Optimize for the case where limb of modulus is zero. */\n+        cd += (int128_t)modinfo->modulus.v[1] * md;\n+        ce += (int128_t)modinfo->modulus.v[1] * me;\n+    }\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    if (modinfo->modulus.v[2]) { /* Optimize for the case where limb of modulus is zero. */\n+        cd += (int128_t)modinfo->modulus.v[2] * md;\n+        ce += (int128_t)modinfo->modulus.v[2] * me;\n+    }\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    if (modinfo->modulus.v[3]) { /* Optimize for the case where limb of modulus is zero. */\n+        cd += (int128_t)modinfo->modulus.v[3] * md;\n+        ce += (int128_t)modinfo->modulus.v[3] * me;\n+    }\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, -2) > 0); /* d > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, 1) < 0);  /* d <    modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, -2) > 0); /* e > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, 1) < 0);  /* e <    modulus */\n+#endif\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix scaled by 2^62.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * Version that operates on a variable number of limbs in f and g.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62_var(int len, secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t fi, gi;\n+    int128_t cf, cg;\n+    int i;\n+    VERIFY_CHECK(len > 0);\n+    /* Start computing t*[f,g]. */\n+    fi = f->v[0];\n+    gi = g->v[0];\n+    cf = (int128_t)u * fi + (int128_t)v * gi;\n+    cg = (int128_t)q * fi + (int128_t)r * gi;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Now iteratively compute limb i=1..len of t*[f,g], and store them in output limb i-1 (shifting\n+     * down by 62 bits). */\n+    for (i = 1; i < len; ++i) {\n+        fi = f->v[i];\n+        gi = g->v[i];\n+        cf += (int128_t)u * fi + (int128_t)v * gi;\n+        cg += (int128_t)q * fi + (int128_t)r * gi;\n+        f->v[i - 1] = (int64_t)cf & M62; cf >>= 62;\n+        g->v[i - 1] = (int64_t)cg & M62; cg >>= 62;\n+    }\n+    /* What remains is limb (len) of t*[f,g]; store it as output limb (len-1). */\n+    f->v[len - 1] = (int64_t)cf;\n+    g->v[len - 1] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, zeta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t zeta = -1; /* zeta = -(delta+1/2); delta starts at 1/2. */\n+\n+    /* Do 10 iterations of 59 divsteps each = 590 divsteps. This suffices for 256-bit inputs. */\n+    for (i = 0; i < 10; ++i) {\n+        /* Compute transition matrix and new zeta after 59 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        zeta = secp256k1_modinv64_divsteps_59(zeta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &SECP256K1_SIGNED62_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &SECP256K1_SIGNED62_ONE, -1) == 0 ||\n+                 secp256k1_modinv64_mul_cmp_62(&f, 5, &SECP256K1_SIGNED62_ONE, 1) == 0 ||\n+                 (secp256k1_modinv64_mul_cmp_62(x, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  secp256k1_modinv64_mul_cmp_62(&d, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  (secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+#ifdef VERIFY\n+    int i = 0;\n+#endif\n+    int j, len = 5;\n+    int64_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int64_t cond, fn, gn;\n+\n+    /* Do iterations of 62 divsteps each until g=0. */\n+    while (1) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+        secp256k1_modinv64_update_fg_62_var(len, &f, &g, &t);\n+        /* If the bottom limb of g is zero, there is a chance that g=0. */\n+        if (g.v[0] == 0) {\n+            cond = 0;\n+            /* Check if the other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= g.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) break;\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0 or -1. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int64_t)len - 2) >> 63;\n+        cond |= fn ^ (fn >> 63);\n+        cond |= gn ^ (gn >> 63);\n+        /* If so, reduce length, propagating the sign of f and g's top limb into the one below. */\n+        if (cond == 0) {\n+            f.v[len - 2] |= (uint64_t)fn << 62;\n+            g.v[len - 2] |= (uint64_t)gn << 62;\n+            --len;\n+        }\n+#ifdef VERIFY\n+        VERIFY_CHECK(++i < 12); /* We should never need more than 12*62 = 744 divsteps */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */\n+#endif\n+    }\n+\n+    /* At this point g is 0 and (if g was not originally 0) f must now equal +/- GCD of\n+     * the initial f, g values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+#ifdef VERIFY\n+    /* g == 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &SECP256K1_SIGNED62_ONE, 0) == 0);\n+    /* |f| == 1, or (x == 0 and d == 0 and |f|=modulus) */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &SECP256K1_SIGNED62_ONE, -1) == 0 ||\n+                 secp256k1_modinv64_mul_cmp_62(&f, len, &SECP256K1_SIGNED62_ONE, 1) == 0 ||\n+                 (secp256k1_modinv64_mul_cmp_62(x, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  secp256k1_modinv64_mul_cmp_62(&d, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&\n+                  (secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) == 0 ||\n+                   secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) == 0)));\n+#endif\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[len - 1], modinfo);\n+    *x = d;\n+}\n+\n+#endif /* SECP256K1_MODINV64_IMPL_H */"
      },
      {
        "sha": "1ac67086beccac5d2e28f74f747d37f483492dc9",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_ECDH_MAIN_H\n #define SECP256K1_MODULE_ECDH_MAIN_H"
      },
      {
        "sha": "be07447a4b9957347f6b9661675590b8dc99158c",
        "filename": "src/secp256k1/src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/tests_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_ECDH_TESTS_H\n #define SECP256K1_MODULE_ECDH_TESTS_H"
      },
      {
        "sha": "7390b227182fe33181d111b580be47100d5558eb",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 8,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Jonas Nick                                      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n-#define _SECP256K1_MODULE_EXTRAKEYS_MAIN_\n+#ifndef SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n+#define SECP256K1_MODULE_EXTRAKEYS_MAIN_H\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_extrakeys.h\"\n@@ -180,12 +180,22 @@ int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *ke\n \n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);\n     secp256k1_keypair_save(keypair, &sk, &pk);\n-    memczero(keypair, sizeof(*keypair), !ret);\n+    secp256k1_memczero(keypair, sizeof(*keypair), !ret);\n \n     secp256k1_scalar_clear(&sk);\n     return ret;\n }\n \n+int secp256k1_keypair_sec(const secp256k1_context* ctx, unsigned char *seckey, const secp256k1_keypair *keypair) {\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+    memset(seckey, 0, 32);\n+    ARG_CHECK(keypair != NULL);\n+\n+    memcpy(seckey, &keypair->data[0], 32);\n+    return 1;\n+}\n+\n int secp256k1_keypair_pub(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair) {\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);"
      },
      {
        "sha": "0aca4fb72d781095c243401bda4a4e70c83afcfb",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n-#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n+#ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n+#define SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_H\n \n #include \"src/modules/extrakeys/main_impl.h\"\n #include \"include/secp256k1_extrakeys.h\""
      },
      {
        "sha": "9473a7dd4852e66f2ad7b30adbc10b41fabb4bb1",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 33,
        "deletions": 8,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Jonas Nick                                      *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Jonas Nick                                       *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n-#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_\n+#ifndef SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n+#define SECP256K1_MODULE_EXTRAKEYS_TESTS_H\n \n #include \"secp256k1_extrakeys.h\"\n \n@@ -311,6 +311,7 @@ void test_xonly_pubkey_tweak_recursive(void) {\n \n void test_keypair(void) {\n     unsigned char sk[32];\n+    unsigned char sk_tmp[32];\n     unsigned char zeros96[96] = { 0 };\n     unsigned char overflows[32];\n     secp256k1_keypair keypair;\n@@ -396,6 +397,28 @@ void test_keypair(void) {\n     CHECK(secp256k1_memcmp_var(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n     CHECK(pk_parity == pk_parity_tmp);\n \n+    /* Test keypair_seckey */\n+    ecount = 0;\n+    secp256k1_testrand256(sk);\n+    CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, &keypair) == 1);\n+    CHECK(secp256k1_keypair_sec(none, NULL, &keypair) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_memcmp_var(zeros96, sk_tmp, sizeof(sk_tmp)) == 0);\n+\n+    /* keypair returns the same seckey it got */\n+    CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, &keypair) == 1);\n+    CHECK(secp256k1_memcmp_var(sk, sk_tmp, sizeof(sk_tmp)) == 0);\n+\n+\n+    /* Using an invalid keypair is fine for keypair_seckey */\n+    memset(&keypair, 0, sizeof(keypair));\n+    CHECK(secp256k1_keypair_sec(none, sk_tmp, &keypair) == 1);\n+    CHECK(secp256k1_memcmp_var(zeros96, sk_tmp, sizeof(sk_tmp)) == 0);\n+\n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n     secp256k1_context_destroy(verify);\n@@ -484,6 +507,7 @@ void test_keypair_add(void) {\n         secp256k1_pubkey output_pk_xy;\n         secp256k1_pubkey output_pk_expected;\n         unsigned char pk32[32];\n+        unsigned char sk32[32];\n         int pk_parity;\n \n         secp256k1_testrand256(tweak);\n@@ -501,7 +525,8 @@ void test_keypair_add(void) {\n         CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n \n         /* Check that the secret key in the keypair is tweaked correctly */\n-        CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, &keypair.data[0]) == 1);\n+        CHECK(secp256k1_keypair_sec(none, sk32, &keypair) == 1);\n+        CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, sk32) == 1);\n         CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n     }\n     secp256k1_context_destroy(none);"
      },
      {
        "sha": "7a440a729bf9644162e94651e6c222972dc30ec1",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_RECOVERY_MAIN_H\n #define SECP256K1_MODULE_RECOVERY_MAIN_H\n@@ -120,34 +120,34 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n     return !secp256k1_gej_is_infinity(&qj);\n }\n \n-int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n+int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar r, s;\n     int ret, recid;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, &recid, msg32, seckey, noncefp, noncedata);\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, &recid, msghash32, seckey, noncefp, noncedata);\n     secp256k1_ecdsa_recoverable_signature_save(signature, &r, &s, recid);\n     return ret;\n }\n \n-int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msg32) {\n+int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msghash32) {\n     secp256k1_ge q;\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     int recid;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n     VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n-    secp256k1_scalar_set_b32(&m, msg32, NULL);\n+    secp256k1_scalar_set_b32(&m, msghash32, NULL);\n     if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);\n         return 1;"
      },
      {
        "sha": "0ba9409c691d0f251a55bbc699ac745712004edd",
        "filename": "src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2016 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n #define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H"
      },
      {
        "sha": "40dba87ce39a7b0463a8107dd6623fa1b8ac774a",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_MODULE_RECOVERY_TESTS_H\n #define SECP256K1_MODULE_RECOVERY_TESTS_H"
      },
      {
        "sha": "22e1b33a5a48e63b0c701f243802d7d32e5b6dda",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                 *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n-#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#ifndef SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n+#define SECP256K1_MODULE_SCHNORRSIG_MAIN_H\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_schnorrsig.h\"\n@@ -179,7 +179,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n \n-    memczero(sig64, 64, !ret);\n+    secp256k1_memczero(sig64, 64, !ret);\n     secp256k1_scalar_clear(&k);\n     secp256k1_scalar_clear(&sk);\n     memset(seckey, 0, sizeof(seckey));"
      },
      {
        "sha": "b4a428729f9a0b823e5b005be7314521d601367c",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n-#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n+#ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n+#define SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_H\n \n #include \"include/secp256k1_schnorrsig.h\"\n #include \"src/modules/schnorrsig/main_impl.h\""
      },
      {
        "sha": "338462fc9dfb944291ff8d6914859d03b70b1cdb",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n-#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_\n+/***********************************************************************\n+ * Copyright (c) 2018-2020 Andrew Poelstra, Jonas Nick                 *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n+#define SECP256K1_MODULE_SCHNORRSIG_TESTS_H\n \n #include \"secp256k1_schnorrsig.h\"\n "
      },
      {
        "sha": "49f2dd791d5696bf89a11caf5461e3f5b33aaca0",
        "filename": "src/secp256k1/src/num.h",
        "status": "removed",
        "additions": 0,
        "deletions": 74,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num.h?ref=cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "patch": "@@ -1,74 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_H\n-#define SECP256K1_NUM_H\n-\n-#ifndef USE_NUM_NONE\n-\n-#if defined HAVE_CONFIG_H\n-#include \"libsecp256k1-config.h\"\n-#endif\n-\n-#if defined(USE_NUM_GMP)\n-#include \"num_gmp.h\"\n-#else\n-#error \"Please select num implementation\"\n-#endif\n-\n-/** Copy a number. */\n-static void secp256k1_num_copy(secp256k1_num *r, const secp256k1_num *a);\n-\n-/** Convert a number's absolute value to a binary big-endian string.\n- *  There must be enough place. */\n-static void secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num *a);\n-\n-/** Set a number to the value of a binary big-endian string. */\n-static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsigned int alen);\n-\n-/** Compute a modular inverse. The input must be less than the modulus. */\n-static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n-\n-/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n-static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Compare the absolute value of two numbers. */\n-static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Test whether two number are equal (including sign). */\n-static int secp256k1_num_eq(const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Add two (signed) numbers. */\n-static void secp256k1_num_add(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Subtract two (signed) numbers. */\n-static void secp256k1_num_sub(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Multiply two (signed) numbers. */\n-static void secp256k1_num_mul(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b);\n-\n-/** Replace a number by its remainder modulo m. M's sign is ignored. The result is a number between 0 and m-1,\n-    even if r was negative. */\n-static void secp256k1_num_mod(secp256k1_num *r, const secp256k1_num *m);\n-\n-/** Right-shift the passed number by bits bits. */\n-static void secp256k1_num_shift(secp256k1_num *r, int bits);\n-\n-/** Check whether a number is zero. */\n-static int secp256k1_num_is_zero(const secp256k1_num *a);\n-\n-/** Check whether a number is one. */\n-static int secp256k1_num_is_one(const secp256k1_num *a);\n-\n-/** Check whether a number is strictly negative. */\n-static int secp256k1_num_is_neg(const secp256k1_num *a);\n-\n-/** Change a number's sign. */\n-static void secp256k1_num_negate(secp256k1_num *r);\n-\n-#endif\n-\n-#endif /* SECP256K1_NUM_H */"
      },
      {
        "sha": "3619844bd5127eb4018efc05e16e78ae9143a93a",
        "filename": "src/secp256k1/src/num_gmp.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num_gmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num_gmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp.h?ref=cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "patch": "@@ -1,20 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_REPR_H\n-#define SECP256K1_NUM_REPR_H\n-\n-#include <gmp.h>\n-\n-#define NUM_LIMBS ((256+GMP_NUMB_BITS-1)/GMP_NUMB_BITS)\n-\n-typedef struct {\n-    mp_limb_t data[2*NUM_LIMBS];\n-    int neg;\n-    int limbs;\n-} secp256k1_num;\n-\n-#endif /* SECP256K1_NUM_REPR_H */"
      },
      {
        "sha": "0ae2a8ba0ecb7b5b61aca0f94676dd7cbf86c437",
        "filename": "src/secp256k1/src/num_gmp_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 288,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp_impl.h?ref=cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "patch": "@@ -1,288 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_REPR_IMPL_H\n-#define SECP256K1_NUM_REPR_IMPL_H\n-\n-#include <string.h>\n-#include <stdlib.h>\n-#include <gmp.h>\n-\n-#include \"util.h\"\n-#include \"num.h\"\n-\n-#ifdef VERIFY\n-static void secp256k1_num_sanity(const secp256k1_num *a) {\n-    VERIFY_CHECK(a->limbs == 1 || (a->limbs > 1 && a->data[a->limbs-1] != 0));\n-}\n-#else\n-#define secp256k1_num_sanity(a) do { } while(0)\n-#endif\n-\n-static void secp256k1_num_copy(secp256k1_num *r, const secp256k1_num *a) {\n-    *r = *a;\n-}\n-\n-static void secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num *a) {\n-    unsigned char tmp[65];\n-    int len = 0;\n-    int shift = 0;\n-    if (a->limbs>1 || a->data[0] != 0) {\n-        len = mpn_get_str(tmp, 256, (mp_limb_t*)a->data, a->limbs);\n-    }\n-    while (shift < len && tmp[shift] == 0) shift++;\n-    VERIFY_CHECK(len-shift <= (int)rlen);\n-    memset(r, 0, rlen - len + shift);\n-    if (len > shift) {\n-        memcpy(r + rlen - len + shift, tmp + shift, len - shift);\n-    }\n-    memset(tmp, 0, sizeof(tmp));\n-}\n-\n-static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsigned int alen) {\n-    int len;\n-    VERIFY_CHECK(alen > 0);\n-    VERIFY_CHECK(alen <= 64);\n-    len = mpn_set_str(r->data, a, alen, 256);\n-    if (len == 0) {\n-        r->data[0] = 0;\n-        len = 1;\n-    }\n-    VERIFY_CHECK(len <= NUM_LIMBS*2);\n-    r->limbs = len;\n-    r->neg = 0;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-        r->limbs--;\n-    }\n-}\n-\n-static void secp256k1_num_add_abs(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    mp_limb_t c = mpn_add(r->data, a->data, a->limbs, b->data, b->limbs);\n-    r->limbs = a->limbs;\n-    if (c != 0) {\n-        VERIFY_CHECK(r->limbs < 2*NUM_LIMBS);\n-        r->data[r->limbs++] = c;\n-    }\n-}\n-\n-static void secp256k1_num_sub_abs(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    mp_limb_t c = mpn_sub(r->data, a->data, a->limbs, b->data, b->limbs);\n-    (void)c;\n-    VERIFY_CHECK(c == 0);\n-    r->limbs = a->limbs;\n-    while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-        r->limbs--;\n-    }\n-}\n-\n-static void secp256k1_num_mod(secp256k1_num *r, const secp256k1_num *m) {\n-    secp256k1_num_sanity(r);\n-    secp256k1_num_sanity(m);\n-\n-    if (r->limbs >= m->limbs) {\n-        mp_limb_t t[2*NUM_LIMBS];\n-        mpn_tdiv_qr(t, r->data, 0, r->data, r->limbs, m->data, m->limbs);\n-        memset(t, 0, sizeof(t));\n-        r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-            r->limbs--;\n-        }\n-    }\n-\n-    if (r->neg && (r->limbs > 1 || r->data[0] != 0)) {\n-        secp256k1_num_sub_abs(r, m, r);\n-        r->neg = 0;\n-    }\n-}\n-\n-static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m) {\n-    int i;\n-    mp_limb_t g[NUM_LIMBS+1];\n-    mp_limb_t u[NUM_LIMBS+1];\n-    mp_limb_t v[NUM_LIMBS+1];\n-    mp_size_t sn;\n-    mp_size_t gn;\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(m);\n-\n-    /** mpn_gcdext computes: (G,S) = gcdext(U,V), where\n-     *  * G = gcd(U,V)\n-     *  * G = U*S + V*T\n-     *  * U has equal or more limbs than V, and V has no padding\n-     *  If we set U to be (a padded version of) a, and V = m:\n-     *    G = a*S + m*T\n-     *    G = a*S mod m\n-     *  Assuming G=1:\n-     *    S = 1/a mod m\n-     */\n-    VERIFY_CHECK(m->limbs <= NUM_LIMBS);\n-    VERIFY_CHECK(m->data[m->limbs-1] != 0);\n-    for (i = 0; i < m->limbs; i++) {\n-        u[i] = (i < a->limbs) ? a->data[i] : 0;\n-        v[i] = m->data[i];\n-    }\n-    sn = NUM_LIMBS+1;\n-    gn = mpn_gcdext(g, r->data, &sn, u, m->limbs, v, m->limbs);\n-    (void)gn;\n-    VERIFY_CHECK(gn == 1);\n-    VERIFY_CHECK(g[0] == 1);\n-    r->neg = a->neg ^ m->neg;\n-    if (sn < 0) {\n-        mpn_sub(r->data, m->data, m->limbs, r->data, -sn);\n-        r->limbs = m->limbs;\n-        while (r->limbs > 1 && r->data[r->limbs-1]==0) {\n-            r->limbs--;\n-        }\n-    } else {\n-        r->limbs = sn;\n-    }\n-    memset(g, 0, sizeof(g));\n-    memset(u, 0, sizeof(u));\n-    memset(v, 0, sizeof(v));\n-}\n-\n-static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n-    int ret;\n-    mpz_t ga, gb;\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n-\n-    mpz_inits(ga, gb, NULL);\n-\n-    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n-    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n-    if (a->neg) {\n-        mpz_neg(ga, ga);\n-    }\n-\n-    ret = mpz_jacobi(ga, gb);\n-\n-    mpz_clears(ga, gb, NULL);\n-\n-    return ret;\n-}\n-\n-static int secp256k1_num_is_one(const secp256k1_num *a) {\n-    return (a->limbs == 1 && a->data[0] == 1);\n-}\n-\n-static int secp256k1_num_is_zero(const secp256k1_num *a) {\n-    return (a->limbs == 1 && a->data[0] == 0);\n-}\n-\n-static int secp256k1_num_is_neg(const secp256k1_num *a) {\n-    return (a->limbs > 1 || a->data[0] != 0) && a->neg;\n-}\n-\n-static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b) {\n-    if (a->limbs > b->limbs) {\n-        return 1;\n-    }\n-    if (a->limbs < b->limbs) {\n-        return -1;\n-    }\n-    return mpn_cmp(a->data, b->data, a->limbs);\n-}\n-\n-static int secp256k1_num_eq(const secp256k1_num *a, const secp256k1_num *b) {\n-    if (a->limbs > b->limbs) {\n-        return 0;\n-    }\n-    if (a->limbs < b->limbs) {\n-        return 0;\n-    }\n-    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) {\n-        return 0;\n-    }\n-    return mpn_cmp(a->data, b->data, a->limbs) == 0;\n-}\n-\n-static void secp256k1_num_subadd(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b, int bneg) {\n-    if (!(b->neg ^ bneg ^ a->neg)) { /* a and b have the same sign */\n-        r->neg = a->neg;\n-        if (a->limbs >= b->limbs) {\n-            secp256k1_num_add_abs(r, a, b);\n-        } else {\n-            secp256k1_num_add_abs(r, b, a);\n-        }\n-    } else {\n-        if (secp256k1_num_cmp(a, b) > 0) {\n-            r->neg = a->neg;\n-            secp256k1_num_sub_abs(r, a, b);\n-        } else {\n-            r->neg = b->neg ^ bneg;\n-            secp256k1_num_sub_abs(r, b, a);\n-        }\n-    }\n-}\n-\n-static void secp256k1_num_add(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-    secp256k1_num_subadd(r, a, b, 0);\n-}\n-\n-static void secp256k1_num_sub(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-    secp256k1_num_subadd(r, a, b, 1);\n-}\n-\n-static void secp256k1_num_mul(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *b) {\n-    mp_limb_t tmp[2*NUM_LIMBS+1];\n-    secp256k1_num_sanity(a);\n-    secp256k1_num_sanity(b);\n-\n-    VERIFY_CHECK(a->limbs + b->limbs <= 2*NUM_LIMBS+1);\n-    if ((a->limbs==1 && a->data[0]==0) || (b->limbs==1 && b->data[0]==0)) {\n-        r->limbs = 1;\n-        r->neg = 0;\n-        r->data[0] = 0;\n-        return;\n-    }\n-    if (a->limbs >= b->limbs) {\n-        mpn_mul(tmp, a->data, a->limbs, b->data, b->limbs);\n-    } else {\n-        mpn_mul(tmp, b->data, b->limbs, a->data, a->limbs);\n-    }\n-    r->limbs = a->limbs + b->limbs;\n-    if (r->limbs > 1 && tmp[r->limbs - 1]==0) {\n-        r->limbs--;\n-    }\n-    VERIFY_CHECK(r->limbs <= 2*NUM_LIMBS);\n-    mpn_copyi(r->data, tmp, r->limbs);\n-    r->neg = a->neg ^ b->neg;\n-    memset(tmp, 0, sizeof(tmp));\n-}\n-\n-static void secp256k1_num_shift(secp256k1_num *r, int bits) {\n-    if (bits % GMP_NUMB_BITS) {\n-        /* Shift within limbs. */\n-        mpn_rshift(r->data, r->data, r->limbs, bits % GMP_NUMB_BITS);\n-    }\n-    if (bits >= GMP_NUMB_BITS) {\n-        int i;\n-        /* Shift full limbs. */\n-        for (i = 0; i < r->limbs; i++) {\n-            int index = i + (bits / GMP_NUMB_BITS);\n-            if (index < r->limbs && index < 2*NUM_LIMBS) {\n-                r->data[i] = r->data[index];\n-            } else {\n-                r->data[i] = 0;\n-            }\n-        }\n-    }\n-    while (r->limbs>1 && r->data[r->limbs-1]==0) {\n-        r->limbs--;\n-    }\n-}\n-\n-static void secp256k1_num_negate(secp256k1_num *r) {\n-    r->neg ^= 1;\n-}\n-\n-#endif /* SECP256K1_NUM_REPR_IMPL_H */"
      },
      {
        "sha": "c45193b033dab813c0ec30697f23fd60098b8e9a",
        "filename": "src/secp256k1/src/num_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 24,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cabb5661234f8d832dbc3b65bf80b0acc02db0a0/src/secp256k1/src/num_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_impl.h?ref=cabb5661234f8d832dbc3b65bf80b0acc02db0a0",
        "patch": "@@ -1,24 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_NUM_IMPL_H\n-#define SECP256K1_NUM_IMPL_H\n-\n-#if defined HAVE_CONFIG_H\n-#include \"libsecp256k1-config.h\"\n-#endif\n-\n-#include \"num.h\"\n-\n-#if defined(USE_NUM_GMP)\n-#include \"num_gmp_impl.h\"\n-#elif defined(USE_NUM_NONE)\n-/* Nothing. */\n-#else\n-#error \"Please select num implementation\"\n-#endif\n-\n-#endif /* SECP256K1_NUM_IMPL_H */"
      },
      {
        "sha": "aaaa3d88277ad057c771480754c21f94c8eb9d7d",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 5,
        "deletions": 17,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,13 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_H\n #define SECP256K1_SCALAR_H\n \n-#include \"num.h\"\n #include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n@@ -63,9 +62,6 @@ static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a,\n  *  the low bits that were shifted off */\n static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n);\n \n-/** Compute the square of a scalar (modulo the group order). */\n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a);\n-\n /** Compute the inverse of a scalar (modulo the group order). */\n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *a);\n \n@@ -91,14 +87,6 @@ static int secp256k1_scalar_is_high(const secp256k1_scalar *a);\n  * Returns -1 if the number was negated, 1 otherwise */\n static int secp256k1_scalar_cond_negate(secp256k1_scalar *a, int flag);\n \n-#ifndef USE_NUM_NONE\n-/** Convert a scalar to a number. */\n-static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a);\n-\n-/** Get the order of the group as a number. */\n-static void secp256k1_scalar_order_get_num(secp256k1_num *r);\n-#endif\n-\n /** Compare two scalars. */\n static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b);\n "
      },
      {
        "sha": "700964291ee28695e80458c861f322e8698949b7",
        "filename": "src/secp256k1/src/scalar_4x64.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_4x64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_4x64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_H\n #define SECP256K1_SCALAR_REPR_H"
      },
      {
        "sha": "a1def26fca7afad330b62929db12e70ddbde7d50",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 81,
        "deletions": 171,
        "changes": 252,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,12 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include \"modinv64_impl.h\"\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)\n #define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)\n@@ -212,28 +214,6 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n     VERIFY_CHECK(c1 >= th); \\\n }\n \n-/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n-#define muladd2(a,b) { \\\n-    uint64_t tl, th, th2, tl2; \\\n-    { \\\n-        uint128_t t = (uint128_t)a * b; \\\n-        th = t >> 64;               /* at most 0xFFFFFFFFFFFFFFFE */ \\\n-        tl = t; \\\n-    } \\\n-    th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n-    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n-    tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n-    th2 += (tl2 < tl);              /* at most 0xFFFFFFFFFFFFFFFF */ \\\n-    c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n-    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n-    c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n-}\n-\n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n@@ -743,148 +723,10 @@ static void secp256k1_scalar_mul_512(uint64_t l[8], const secp256k1_scalar *a, c\n #endif\n }\n \n-static void secp256k1_scalar_sqr_512(uint64_t l[8], const secp256k1_scalar *a) {\n-#ifdef USE_ASM_X86_64\n-    __asm__ __volatile__(\n-    /* Preload */\n-    \"movq 0(%%rdi), %%r11\\n\"\n-    \"movq 8(%%rdi), %%r12\\n\"\n-    \"movq 16(%%rdi), %%r13\\n\"\n-    \"movq 24(%%rdi), %%r14\\n\"\n-    /* (rax,rdx) = a0 * a0 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r11\\n\"\n-    /* Extract l0 */\n-    \"movq %%rax, 0(%%rsi)\\n\"\n-    /* (r8,r9,r10) = (rdx,0) */\n-    \"movq %%rdx, %%r8\\n\"\n-    \"xorq %%r9, %%r9\\n\"\n-    \"xorq %%r10, %%r10\\n\"\n-    /* (r8,r9,r10) += 2 * a0 * a1 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r12\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    /* Extract l1 */\n-    \"movq %%r8, 8(%%rsi)\\n\"\n-    \"xorq %%r8, %%r8\\n\"\n-    /* (r9,r10,r8) += 2 * a0 * a2 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r13\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    /* (r9,r10,r8) += a1 * a1 */\n-    \"movq %%r12, %%rax\\n\"\n-    \"mulq %%r12\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    /* Extract l2 */\n-    \"movq %%r9, 16(%%rsi)\\n\"\n-    \"xorq %%r9, %%r9\\n\"\n-    /* (r10,r8,r9) += 2 * a0 * a3 */\n-    \"movq %%r11, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    /* (r10,r8,r9) += 2 * a1 * a2 */\n-    \"movq %%r12, %%rax\\n\"\n-    \"mulq %%r13\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    \"adcq $0, %%r9\\n\"\n-    /* Extract l3 */\n-    \"movq %%r10, 24(%%rsi)\\n\"\n-    \"xorq %%r10, %%r10\\n\"\n-    /* (r8,r9,r10) += 2 * a1 * a3 */\n-    \"movq %%r12, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    /* (r8,r9,r10) += a2 * a2 */\n-    \"movq %%r13, %%rax\\n\"\n-    \"mulq %%r13\\n\"\n-    \"addq %%rax, %%r8\\n\"\n-    \"adcq %%rdx, %%r9\\n\"\n-    \"adcq $0, %%r10\\n\"\n-    /* Extract l4 */\n-    \"movq %%r8, 32(%%rsi)\\n\"\n-    \"xorq %%r8, %%r8\\n\"\n-    /* (r9,r10,r8) += 2 * a2 * a3 */\n-    \"movq %%r13, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    \"addq %%rax, %%r9\\n\"\n-    \"adcq %%rdx, %%r10\\n\"\n-    \"adcq $0, %%r8\\n\"\n-    /* Extract l5 */\n-    \"movq %%r9, 40(%%rsi)\\n\"\n-    /* (r10,r8) += a3 * a3 */\n-    \"movq %%r14, %%rax\\n\"\n-    \"mulq %%r14\\n\"\n-    \"addq %%rax, %%r10\\n\"\n-    \"adcq %%rdx, %%r8\\n\"\n-    /* Extract l6 */\n-    \"movq %%r10, 48(%%rsi)\\n\"\n-    /* Extract l7 */\n-    \"movq %%r8, 56(%%rsi)\\n\"\n-    :\n-    : \"S\"(l), \"D\"(a->d)\n-    : \"rax\", \"rdx\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"cc\", \"memory\");\n-#else\n-    /* 160 bit accumulator. */\n-    uint64_t c0 = 0, c1 = 0;\n-    uint32_t c2 = 0;\n-\n-    /* l[0..7] = a[0..3] * b[0..3]. */\n-    muladd_fast(a->d[0], a->d[0]);\n-    extract_fast(l[0]);\n-    muladd2(a->d[0], a->d[1]);\n-    extract(l[1]);\n-    muladd2(a->d[0], a->d[2]);\n-    muladd(a->d[1], a->d[1]);\n-    extract(l[2]);\n-    muladd2(a->d[0], a->d[3]);\n-    muladd2(a->d[1], a->d[2]);\n-    extract(l[3]);\n-    muladd2(a->d[1], a->d[3]);\n-    muladd(a->d[2], a->d[2]);\n-    extract(l[4]);\n-    muladd2(a->d[2], a->d[3]);\n-    extract(l[5]);\n-    muladd_fast(a->d[3], a->d[3]);\n-    extract_fast(l[6]);\n-    VERIFY_CHECK(c1 == 0);\n-    l[7] = c0;\n-#endif\n-}\n-\n #undef sumadd\n #undef sumadd_fast\n #undef muladd\n #undef muladd_fast\n-#undef muladd2\n #undef extract\n #undef extract_fast\n \n@@ -906,12 +748,6 @@ static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n     return ret;\n }\n \n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n-    uint64_t l[8];\n-    secp256k1_scalar_sqr_512(l, a);\n-    secp256k1_scalar_reduce_512(r, l);\n-}\n-\n static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n     r1->d[0] = k->d[0];\n     r1->d[1] = k->d[1];\n@@ -955,4 +791,78 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n }\n \n+static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n+\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n+\n+    r->d[0] = a0      | a1 << 62;\n+    r->d[1] = a1 >> 2 | a2 << 60;\n+    r->d[2] = a2 >> 4 | a3 << 58;\n+    r->d[3] = a3 >> 6 | a4 << 56;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_scalar *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\n+#endif\n+\n+    r->v[0] =  a0                   & M62;\n+    r->v[1] = (a0 >> 62 | a1 <<  2) & M62;\n+    r->v[2] = (a1 >> 60 | a2 <<  4) & M62;\n+    r->v[3] = (a2 >> 58 | a3 <<  6) & M62;\n+    r->v[4] =  a3 >> 56;\n+}\n+\n+static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_scalar = {\n+    {{0x3FD25E8CD0364141LL, 0x2ABB739ABD2280EELL, -0x15LL, 0, 256}},\n+    0x34F20099AA774EC1LL\n+};\n+\n+static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv64_signed62 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed62(&s, x);\n+    secp256k1_modinv64(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv64_signed62 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed62(&s, x);\n+    secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed62(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(a->d[0] & 1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "17863ef93710bd8e6b3df64cf741207ed5452efd",
        "filename": "src/secp256k1/src/scalar_8x32.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_8x32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_8x32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_H\n #define SECP256K1_SCALAR_REPR_H"
      },
      {
        "sha": "62c7ae7156d37cfb57c580ab9e438ddea05f2fbd",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 95,
        "deletions": 94,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,12 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n \n+#include \"modinv32_impl.h\"\n+\n /* Limbs of the secp256k1 order. */\n #define SECP256K1_N_0 ((uint32_t)0xD0364141UL)\n #define SECP256K1_N_1 ((uint32_t)0xBFD25E8CUL)\n@@ -291,28 +293,6 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n     VERIFY_CHECK(c1 >= th); \\\n }\n \n-/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n-#define muladd2(a,b) { \\\n-    uint32_t tl, th, th2, tl2; \\\n-    { \\\n-        uint64_t t = (uint64_t)a * b; \\\n-        th = t >> 32;               /* at most 0xFFFFFFFE */ \\\n-        tl = t; \\\n-    } \\\n-    th2 = th + th;                  /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n-    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n-    tl2 = tl + tl;                  /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n-    th2 += (tl2 < tl);              /* at most 0xFFFFFFFF */ \\\n-    c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n-    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n-    c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n-    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n-}\n-\n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n@@ -576,71 +556,10 @@ static void secp256k1_scalar_mul_512(uint32_t *l, const secp256k1_scalar *a, con\n     l[15] = c0;\n }\n \n-static void secp256k1_scalar_sqr_512(uint32_t *l, const secp256k1_scalar *a) {\n-    /* 96 bit accumulator. */\n-    uint32_t c0 = 0, c1 = 0, c2 = 0;\n-\n-    /* l[0..15] = a[0..7]^2. */\n-    muladd_fast(a->d[0], a->d[0]);\n-    extract_fast(l[0]);\n-    muladd2(a->d[0], a->d[1]);\n-    extract(l[1]);\n-    muladd2(a->d[0], a->d[2]);\n-    muladd(a->d[1], a->d[1]);\n-    extract(l[2]);\n-    muladd2(a->d[0], a->d[3]);\n-    muladd2(a->d[1], a->d[2]);\n-    extract(l[3]);\n-    muladd2(a->d[0], a->d[4]);\n-    muladd2(a->d[1], a->d[3]);\n-    muladd(a->d[2], a->d[2]);\n-    extract(l[4]);\n-    muladd2(a->d[0], a->d[5]);\n-    muladd2(a->d[1], a->d[4]);\n-    muladd2(a->d[2], a->d[3]);\n-    extract(l[5]);\n-    muladd2(a->d[0], a->d[6]);\n-    muladd2(a->d[1], a->d[5]);\n-    muladd2(a->d[2], a->d[4]);\n-    muladd(a->d[3], a->d[3]);\n-    extract(l[6]);\n-    muladd2(a->d[0], a->d[7]);\n-    muladd2(a->d[1], a->d[6]);\n-    muladd2(a->d[2], a->d[5]);\n-    muladd2(a->d[3], a->d[4]);\n-    extract(l[7]);\n-    muladd2(a->d[1], a->d[7]);\n-    muladd2(a->d[2], a->d[6]);\n-    muladd2(a->d[3], a->d[5]);\n-    muladd(a->d[4], a->d[4]);\n-    extract(l[8]);\n-    muladd2(a->d[2], a->d[7]);\n-    muladd2(a->d[3], a->d[6]);\n-    muladd2(a->d[4], a->d[5]);\n-    extract(l[9]);\n-    muladd2(a->d[3], a->d[7]);\n-    muladd2(a->d[4], a->d[6]);\n-    muladd(a->d[5], a->d[5]);\n-    extract(l[10]);\n-    muladd2(a->d[4], a->d[7]);\n-    muladd2(a->d[5], a->d[6]);\n-    extract(l[11]);\n-    muladd2(a->d[5], a->d[7]);\n-    muladd(a->d[6], a->d[6]);\n-    extract(l[12]);\n-    muladd2(a->d[6], a->d[7]);\n-    extract(l[13]);\n-    muladd_fast(a->d[7], a->d[7]);\n-    extract_fast(l[14]);\n-    VERIFY_CHECK(c1 == 0);\n-    l[15] = c0;\n-}\n-\n #undef sumadd\n #undef sumadd_fast\n #undef muladd\n #undef muladd_fast\n-#undef muladd2\n #undef extract\n #undef extract_fast\n \n@@ -666,12 +585,6 @@ static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n     return ret;\n }\n \n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n-    uint32_t l[16];\n-    secp256k1_scalar_sqr_512(l, a);\n-    secp256k1_scalar_reduce_512(r, l);\n-}\n-\n static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n     r1->d[0] = k->d[0];\n     r1->d[1] = k->d[1];\n@@ -731,4 +644,92 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[7] = (r->d[7] & mask0) | (a->d[7] & mask1);\n }\n \n+static void secp256k1_scalar_from_signed30(secp256k1_scalar *r, const secp256k1_modinv32_signed30 *a) {\n+    const uint32_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4],\n+                   a5 = a->v[5], a6 = a->v[6], a7 = a->v[7], a8 = a->v[8];\n+\n+    /* The output from secp256k1_modinv32{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^30). The modulus is < 2^256, so the top limb must be below 2^(256-30*8).\n+     */\n+    VERIFY_CHECK(a0 >> 30 == 0);\n+    VERIFY_CHECK(a1 >> 30 == 0);\n+    VERIFY_CHECK(a2 >> 30 == 0);\n+    VERIFY_CHECK(a3 >> 30 == 0);\n+    VERIFY_CHECK(a4 >> 30 == 0);\n+    VERIFY_CHECK(a5 >> 30 == 0);\n+    VERIFY_CHECK(a6 >> 30 == 0);\n+    VERIFY_CHECK(a7 >> 30 == 0);\n+    VERIFY_CHECK(a8 >> 16 == 0);\n+\n+    r->d[0] = a0       | a1 << 30;\n+    r->d[1] = a1 >>  2 | a2 << 28;\n+    r->d[2] = a2 >>  4 | a3 << 26;\n+    r->d[3] = a3 >>  6 | a4 << 24;\n+    r->d[4] = a4 >>  8 | a5 << 22;\n+    r->d[5] = a5 >> 10 | a6 << 20;\n+    r->d[6] = a6 >> 12 | a7 << 18;\n+    r->d[7] = a7 >> 14 | a8 << 16;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_to_signed30(secp256k1_modinv32_signed30 *r, const secp256k1_scalar *a) {\n+    const uint32_t M30 = UINT32_MAX >> 2;\n+    const uint32_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3],\n+                   a4 = a->d[4], a5 = a->d[5], a6 = a->d[6], a7 = a->d[7];\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\n+#endif\n+\n+    r->v[0] =  a0                   & M30;\n+    r->v[1] = (a0 >> 30 | a1 <<  2) & M30;\n+    r->v[2] = (a1 >> 28 | a2 <<  4) & M30;\n+    r->v[3] = (a2 >> 26 | a3 <<  6) & M30;\n+    r->v[4] = (a3 >> 24 | a4 <<  8) & M30;\n+    r->v[5] = (a4 >> 22 | a5 << 10) & M30;\n+    r->v[6] = (a5 >> 20 | a6 << 12) & M30;\n+    r->v[7] = (a6 >> 18 | a7 << 14) & M30;\n+    r->v[8] =  a7 >> 16;\n+}\n+\n+static const secp256k1_modinv32_modinfo secp256k1_const_modinfo_scalar = {\n+    {{0x10364141L, 0x3F497A33L, 0x348A03BBL, 0x2BB739ABL, -0x146L, 0, 0, 0, 65536}},\n+    0x2A774EC1L\n+};\n+\n+static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv32_signed30 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed30(&s, x);\n+    secp256k1_modinv32(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed30(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_modinv32_signed30 s;\n+#ifdef VERIFY\n+    int zero_in = secp256k1_scalar_is_zero(x);\n+#endif\n+    secp256k1_scalar_to_signed30(&s, x);\n+    secp256k1_modinv32_var(&s, &secp256k1_const_modinfo_scalar);\n+    secp256k1_scalar_from_signed30(r, &s);\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_is_zero(r) == zero_in);\n+#endif\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(a->d[0] & 1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "e124474773c3e320867369ea1c161efb6d59562c",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 224,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2014 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n@@ -31,231 +31,12 @@\n static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n static const secp256k1_scalar secp256k1_scalar_zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n \n-#ifndef USE_NUM_NONE\n-static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a) {\n-    unsigned char c[32];\n-    secp256k1_scalar_get_b32(c, a);\n-    secp256k1_num_set_bin(r, c, 32);\n-}\n-\n-/** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */\n-static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n-#if defined(EXHAUSTIVE_TEST_ORDER)\n-    static const unsigned char order[32] = {\n-        0,0,0,0,0,0,0,0,\n-        0,0,0,0,0,0,0,0,\n-        0,0,0,0,0,0,0,0,\n-        0,0,0,0,0,0,0,EXHAUSTIVE_TEST_ORDER\n-    };\n-#else\n-    static const unsigned char order[32] = {\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n-        0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n-        0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n-    };\n-#endif\n-    secp256k1_num_set_bin(r, order, 32);\n-}\n-#endif\n-\n static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin) {\n     int overflow;\n     secp256k1_scalar_set_b32(r, bin, &overflow);\n     return (!overflow) & (!secp256k1_scalar_is_zero(r));\n }\n \n-static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-#if defined(EXHAUSTIVE_TEST_ORDER)\n-    int i;\n-    *r = 0;\n-    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n-        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n-            *r = i;\n-    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n-     * have a composite group order; fix it in exhaustive_tests.c). */\n-    VERIFY_CHECK(*r != 0);\n-}\n-#else\n-    secp256k1_scalar *t;\n-    int i;\n-    /* First compute xN as x ^ (2^N - 1) for some values of N,\n-     * and uM as x ^ M for some values of M. */\n-    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n-    secp256k1_scalar u2, u5, u9, u11, u13;\n-\n-    secp256k1_scalar_sqr(&u2, x);\n-    secp256k1_scalar_mul(&x2, &u2,  x);\n-    secp256k1_scalar_mul(&u5, &u2, &x2);\n-    secp256k1_scalar_mul(&x3, &u5,  &u2);\n-    secp256k1_scalar_mul(&u9, &x3, &u2);\n-    secp256k1_scalar_mul(&u11, &u9, &u2);\n-    secp256k1_scalar_mul(&u13, &u11, &u2);\n-\n-    secp256k1_scalar_sqr(&x6, &u13);\n-    secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &u11);\n-\n-    secp256k1_scalar_sqr(&x8, &x6);\n-    secp256k1_scalar_sqr(&x8, &x8);\n-    secp256k1_scalar_mul(&x8, &x8,  &x2);\n-\n-    secp256k1_scalar_sqr(&x14, &x8);\n-    for (i = 0; i < 5; i++) {\n-        secp256k1_scalar_sqr(&x14, &x14);\n-    }\n-    secp256k1_scalar_mul(&x14, &x14, &x6);\n-\n-    secp256k1_scalar_sqr(&x28, &x14);\n-    for (i = 0; i < 13; i++) {\n-        secp256k1_scalar_sqr(&x28, &x28);\n-    }\n-    secp256k1_scalar_mul(&x28, &x28, &x14);\n-\n-    secp256k1_scalar_sqr(&x56, &x28);\n-    for (i = 0; i < 27; i++) {\n-        secp256k1_scalar_sqr(&x56, &x56);\n-    }\n-    secp256k1_scalar_mul(&x56, &x56, &x28);\n-\n-    secp256k1_scalar_sqr(&x112, &x56);\n-    for (i = 0; i < 55; i++) {\n-        secp256k1_scalar_sqr(&x112, &x112);\n-    }\n-    secp256k1_scalar_mul(&x112, &x112, &x56);\n-\n-    secp256k1_scalar_sqr(&x126, &x112);\n-    for (i = 0; i < 13; i++) {\n-        secp256k1_scalar_sqr(&x126, &x126);\n-    }\n-    secp256k1_scalar_mul(&x126, &x126, &x14);\n-\n-    /* Then accumulate the final result (t starts at x126). */\n-    t = &x126;\n-    for (i = 0; i < 3; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 5; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n-    for (i = 0; i < 4; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 5; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 6; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 3; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 5; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n-    for (i = 0; i < 6; i++) { /* 000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n-    for (i = 0; i < 10; i++) { /* 0000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 9; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 5; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n-    for (i = 0; i < 6; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n-    for (i = 0; i < 4; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 5; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 6; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 10; i++) { /* 000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n-    for (i = 0; i < 4; i++) {\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n-    for (i = 0; i < 6; i++) { /* 00000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(r, t, &x6); /* 111111 */\n-}\n-\n-SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n-    return !(a->d[0] & 1);\n-}\n-#endif\n-\n-static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-#if defined(USE_SCALAR_INV_BUILTIN)\n-    secp256k1_scalar_inverse(r, x);\n-#elif defined(USE_SCALAR_INV_NUM)\n-    unsigned char b[32];\n-    secp256k1_num n, m;\n-    secp256k1_scalar t = *x;\n-    secp256k1_scalar_get_b32(b, &t);\n-    secp256k1_num_set_bin(&n, b, 32);\n-    secp256k1_scalar_order_get_num(&m);\n-    secp256k1_num_mod_inverse(&n, &n, &m);\n-    secp256k1_num_get_bin(b, 32, &n);\n-    secp256k1_scalar_set_b32(r, b, NULL);\n-    /* Verify that the inverse was computed correctly, without GMP code. */\n-    secp256k1_scalar_mul(&t, &t, r);\n-    CHECK(secp256k1_scalar_is_one(&t));\n-#else\n-#error \"Please select scalar inverse implementation\"\n-#endif\n-}\n-\n /* These parameters are generated using sage/gen_exhaustive_groups.sage. */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 13"
      },
      {
        "sha": "67051bd30b788b59a45d6e044a41e1e075681c56",
        "filename": "src/secp256k1/src/scalar_low.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_H\n #define SECP256K1_SCALAR_REPR_H"
      },
      {
        "sha": "7176f0b2caeab0c8fbb7cd2b5d7755ff24260857",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "modified",
        "additions": 20,
        "deletions": 9,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2015 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SCALAR_REPR_IMPL_H\n #define SECP256K1_SCALAR_REPR_IMPL_H\n@@ -104,10 +104,6 @@ static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n     return ret;\n }\n \n-static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n-    *r = (*a * *a) % EXHAUSTIVE_TEST_ORDER;\n-}\n-\n static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n     *r1 = *a;\n     *r2 = 0;\n@@ -125,4 +121,19 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     *r = (*r & mask0) | (*a & mask1);\n }\n \n+static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n+        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n+            *r = i;\n+    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n+     * have a composite group order; fix it in exhaustive_tests.c). */\n+    VERIFY_CHECK(*r != 0);\n+}\n+\n+static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+    secp256k1_scalar_inverse(r, x);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "9dcb7581f6fc426c4a29c1b0610c12506394921e",
        "filename": "src/secp256k1/src/scratch.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2017 Andrew Poelstra\t                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef _SECP256K1_SCRATCH_\n-#define _SECP256K1_SCRATCH_\n+/***********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_SCRATCH_H\n+#define SECP256K1_SCRATCH_H\n \n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */"
      },
      {
        "sha": "688e18eb6620889b1ac3de4c3e79d8f0e83408ba",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,11 +1,11 @@\n-/**********************************************************************\n- * Copyright (c) 2017 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n-#ifndef _SECP256K1_SCRATCH_IMPL_H_\n-#define _SECP256K1_SCRATCH_IMPL_H_\n+#ifndef SECP256K1_SCRATCH_IMPL_H\n+#define SECP256K1_SCRATCH_IMPL_H\n \n #include \"util.h\"\n #include \"scratch.h\""
      },
      {
        "sha": "aef3f99ac3b39e88d8665c24714235a237191c2d",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 41,
        "deletions": 40,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,15 +1,14 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include \"include/secp256k1.h\"\n #include \"include/secp256k1_preallocated.h\"\n \n #include \"assumptions.h\"\n #include \"util.h\"\n-#include \"num_impl.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -86,6 +85,8 @@ const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_pr\n \n size_t secp256k1_context_preallocated_size(unsigned int flags) {\n     size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    /* A return value of 0 is reserved as an indicator for errors when we call this function internally. */\n+    VERIFY_CHECK(ret != 0);\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&default_illegal_callback,\n@@ -122,21 +123,21 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     if (!secp256k1_selftest()) {\n         secp256k1_callback_call(&default_error_callback, \"self test failed\");\n     }\n-    VERIFY_CHECK(prealloc != NULL);\n+\n     prealloc_size = secp256k1_context_preallocated_size(flags);\n+    if (prealloc_size == 0) {\n+        return NULL;\n+    }\n+    VERIFY_CHECK(prealloc != NULL);\n     ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n-    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n-            secp256k1_callback_call(&ret->illegal_callback,\n-                                    \"Invalid flags\");\n-            return NULL;\n-    }\n-\n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n+    /* Flags have been checked by secp256k1_context_preallocated_size. */\n+    VERIFY_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_CONTEXT);\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n@@ -420,17 +421,17 @@ int secp256k1_ecdsa_signature_normalize(const secp256k1_context* ctx, secp256k1_\n     return ret;\n }\n \n-int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msg32, const secp256k1_pubkey *pubkey) {\n+int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey) {\n     secp256k1_ge q;\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n-    secp256k1_scalar_set_b32(&m, msg32, NULL);\n+    secp256k1_scalar_set_b32(&m, msghash32, NULL);\n     secp256k1_ecdsa_signature_load(ctx, &r, &s, sig);\n     return (!secp256k1_scalar_is_high(&s) &&\n             secp256k1_pubkey_load(ctx, &q, pubkey) &&\n@@ -531,16 +532,16 @@ static int secp256k1_ecdsa_sign_inner(const secp256k1_context* ctx, secp256k1_sc\n     return ret;\n }\n \n-int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n+int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar r, s;\n     int ret;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, NULL, msg32, seckey, noncefp, noncedata);\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, NULL, msghash32, seckey, noncefp, noncedata);\n     secp256k1_ecdsa_signature_save(signature, &r, &s);\n     return ret;\n }\n@@ -580,7 +581,7 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n \n     ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey);\n     secp256k1_pubkey_save(pubkey, &p);\n-    memczero(pubkey, sizeof(*pubkey), !ret);\n+    secp256k1_memczero(pubkey, sizeof(*pubkey), !ret);\n \n     secp256k1_scalar_clear(&seckey_scalar);\n     return ret;\n@@ -621,72 +622,72 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n }\n \n \n-static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak) {\n+static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n     int ret = 0;\n \n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n     ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);\n     secp256k1_scalar_clear(&term);\n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n     secp256k1_scalar sec;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n-    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak);\n+    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak32);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n-    return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak);\n+int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n+    return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak32);\n }\n \n-static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak) {\n+static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n-    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n     return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n }\n \n-int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n-    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak);\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak32);\n     if (ret) {\n         secp256k1_pubkey_save(pubkey, &p);\n     }\n \n     return ret;\n }\n \n-int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n     secp256k1_scalar factor;\n     secp256k1_scalar sec;\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n-    secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n     ret &= (!overflow) & secp256k1_eckey_privkey_tweak_mul(&sec, &factor);\n     secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n@@ -697,21 +698,21 @@ int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *s\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n-    return secp256k1_ec_seckey_tweak_mul(ctx, seckey, tweak);\n+int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {\n+    return secp256k1_ec_seckey_tweak_mul(ctx, seckey, tweak32);\n }\n \n-int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n+int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     secp256k1_scalar factor;\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n-    ARG_CHECK(tweak != NULL);\n+    ARG_CHECK(tweak32 != NULL);\n \n-    secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n+    secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n     if (ret) {"
      },
      {
        "sha": "52f1b8442e7124f3a2e39bfdc8db0072022c1d59",
        "filename": "src/secp256k1/src/selftest.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/selftest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/selftest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/selftest.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_SELFTEST_H\n #define SECP256K1_SELFTEST_H"
      },
      {
        "sha": "667d1867bd61548fc063cf14c1be06e9c8e4e581",
        "filename": "src/secp256k1/src/testrand.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/testrand.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/testrand.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_TESTRAND_H\n #define SECP256K1_TESTRAND_H"
      },
      {
        "sha": "e643778f36b1e33fd38f3839dfd4e9b6915628af",
        "filename": "src/secp256k1/src/testrand_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand_impl.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013-2015 Pieter Wuille                               *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_TESTRAND_IMPL_H\n #define SECP256K1_TESTRAND_IMPL_H"
      },
      {
        "sha": "a146394305cb67f07faa998b17fb3ba095a3d372",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 1257,
        "deletions": 472,
        "changes": 1729,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea"
      },
      {
        "sha": "2bb5381446ed2a70c2021fa6e240911592756839",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n /***********************************************************************\n- * Copyright (c) 2016 Andrew Poelstra                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+ * Copyright (c) 2016 Andrew Poelstra                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "f78846836cf25e5abc1bb44015a0ca7b17c5386d",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 80,
        "deletions": 9,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,8 +1,8 @@\n-/**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2013, 2014 Pieter Wuille                              *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #ifndef SECP256K1_UTIL_H\n #define SECP256K1_UTIL_H\n@@ -113,7 +113,7 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n #define ALIGNMENT 16\n #endif\n \n-#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+#define ROUND_TO_ALIGN(size) ((((size) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n \n /* Assume there is a contiguous memory object with bounds [base, base + max_size)\n  * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n@@ -141,7 +141,7 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n     VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n     VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n     ret = *prealloc_ptr;\n-    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    *prealloc_ptr = (unsigned char*)*prealloc_ptr + aligned_alloc_size;\n     return ret;\n }\n \n@@ -202,7 +202,7 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n #endif\n \n /* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n-static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n+static SECP256K1_INLINE void secp256k1_memczero(void *s, size_t len, int flag) {\n     unsigned char *p = (unsigned char *)s;\n     /* Access flag with a volatile-qualified lvalue.\n        This prevents clang from figuring out (after inlining) that flag can\n@@ -260,14 +260,85 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n # define SECP256K1_WIDEMUL_INT128 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n # define SECP256K1_WIDEMUL_INT64 1\n-#elif defined(__SIZEOF_INT128__)\n+#elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n # define SECP256K1_WIDEMUL_INT128 1\n #else\n # define SECP256K1_WIDEMUL_INT64 1\n #endif\n #if defined(SECP256K1_WIDEMUL_INT128)\n+# if !defined(UINT128_MAX) && defined(__SIZEOF_INT128__)\n SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n SECP256K1_GNUC_EXT typedef __int128 int128_t;\n+#define UINT128_MAX ((uint128_t)(-1))\n+#define INT128_MAX ((int128_t)(UINT128_MAX >> 1))\n+#define INT128_MIN (-INT128_MAX - 1)\n+/* No (U)INT128_C macros because compilers providing __int128 do not support 128-bit literals.  */\n+# endif\n+#endif\n+\n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x.\n+ * This function is only intended to be used as fallback for\n+ * secp256k1_ctz32_var, but permits it to be tested separately. */\n+static SECP256K1_INLINE int secp256k1_ctz32_var_debruijn(uint32_t x) {\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x.\n+ * This function is only intended to be used as fallback for\n+ * secp256k1_ctz64_var, but permits it to be tested separately. */\n+static SECP256K1_INLINE int secp256k1_ctz64_var_debruijn(uint64_t x) {\n+    static const uint8_t debruijn[64] = {\n+        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,\n+        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,\n+        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\n+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n+    };\n+    return debruijn[((x & -x) * 0x022FDD63CC95386D) >> 58];\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n #endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    return secp256k1_ctz32_var_debruijn(x);\n+#endif\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz64_var(uint64_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned long type is sufficient to represent the largest uint64_t, consider __builtin_ctzl. */\n+    if (((unsigned long)UINT64_MAX) == UINT64_MAX) {\n+        return __builtin_ctzl(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzll) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzll (the unsigned long long type is always at least 64 bits). */\n+    return __builtin_ctzll(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    return secp256k1_ctz64_var_debruijn(x);\n+#endif\n+}\n \n #endif /* SECP256K1_UTIL_H */"
      },
      {
        "sha": "cfca5a196e0cad9718451945d4169852f9956d0a",
        "filename": "src/secp256k1/src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 47,
        "deletions": 31,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5a447a352463c7b75752aa08b6d9cb46aa051ea/src/secp256k1/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/valgrind_ctime_test.c?ref=a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "patch": "@@ -1,10 +1,12 @@\n-/**********************************************************************\n- * Copyright (c) 2020 Gregory Maxwell                                 *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n+/***********************************************************************\n+ * Copyright (c) 2020 Gregory Maxwell                                  *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n \n #include <valgrind/memcheck.h>\n+#include <stdio.h>\n+\n #include \"include/secp256k1.h\"\n #include \"assumptions.h\"\n #include \"util.h\"\n@@ -25,16 +27,49 @@\n #include \"include/secp256k1_schnorrsig.h\"\n #endif\n \n+void run_tests(secp256k1_context *ctx, unsigned char *key);\n+\n int main(void) {\n     secp256k1_context* ctx;\n+    unsigned char key[32];\n+    int ret, i;\n+\n+    if (!RUNNING_ON_VALGRIND) {\n+        fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n+        fprintf(stderr, \"Usage: libtool --mode=execute valgrind ./valgrind_ctime_test\\n\");\n+        return 1;\n+    }\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN\n+                                   | SECP256K1_CONTEXT_VERIFY\n+                                   | SECP256K1_CONTEXT_DECLASSIFY);\n+    /** In theory, testing with a single secret input should be sufficient:\n+     *  If control flow depended on secrets the tool would generate an error.\n+     */\n+    for (i = 0; i < 32; i++) {\n+        key[i] = i + 65;\n+    }\n+\n+    run_tests(ctx, key);\n+\n+    /* Test context randomisation. Do this last because it leaves the context\n+     * tainted. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_context_randomize(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+\n+    secp256k1_context_destroy(ctx);\n+    return 0;\n+}\n+\n+void run_tests(secp256k1_context *ctx, unsigned char *key) {\n     secp256k1_ecdsa_signature signature;\n     secp256k1_pubkey pubkey;\n     size_t siglen = 74;\n     size_t outputlen = 33;\n     int i;\n     int ret;\n     unsigned char msg[32];\n-    unsigned char key[32];\n     unsigned char sig[74];\n     unsigned char spubkey[33];\n #ifdef ENABLE_MODULE_RECOVERY\n@@ -45,26 +80,10 @@ int main(void) {\n     secp256k1_keypair keypair;\n #endif\n \n-    if (!RUNNING_ON_VALGRIND) {\n-        fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n-        fprintf(stderr, \"Usage: libtool --mode=execute valgrind ./valgrind_ctime_test\\n\");\n-        exit(1);\n-    }\n-\n-    /** In theory, testing with a single secret input should be sufficient:\n-     *  If control flow depended on secrets the tool would generate an error.\n-     */\n-    for (i = 0; i < 32; i++) {\n-        key[i] = i + 65;\n-    }\n     for (i = 0; i < 32; i++) {\n         msg[i] = i + 1;\n     }\n \n-    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN\n-                                   | SECP256K1_CONTEXT_VERIFY\n-                                   | SECP256K1_CONTEXT_DECLASSIFY);\n-\n     /* Test keygen. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_ec_pubkey_create(ctx, &pubkey, key);\n@@ -122,12 +141,6 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n \n-    /* Test context randomisation. Do this last because it leaves the context tainted. */\n-    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n-    ret = secp256k1_context_randomize(ctx, key);\n-    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n-    CHECK(ret);\n-\n     /* Test keypair_create and keypair_xonly_tweak_add. */\n #ifdef ENABLE_MODULE_EXTRAKEYS\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n@@ -140,6 +153,12 @@ int main(void) {\n     ret = secp256k1_keypair_xonly_tweak_add(ctx, &keypair, msg);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_UNDEFINED(&keypair, sizeof(keypair));\n+    ret = secp256k1_keypair_sec(ctx, key, &keypair);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n #endif\n \n #ifdef ENABLE_MODULE_SCHNORRSIG\n@@ -151,7 +170,4 @@ int main(void) {\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n-\n-    secp256k1_context_destroy(ctx);\n-    return 0;\n }"
      }
    ]
  },
  {
    "sha": "5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YzdlZTFiMmRhNmJmNzgzZDI3MDM0ZmNhOWRmZDNhNjRlZDUyNWNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-02T19:19:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-04-23T18:36:01Z"
      },
      "message": "libsecp256k1 no longer has --with-bignum= configure option",
      "tree": {
        "sha": "56a6a8555e2c56223f22b94083fcf18ca53a1750",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/56a6a8555e2c56223f22b94083fcf18ca53a1750"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5a447a352463c7b75752aa08b6d9cb46aa051ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a5a447a352463c7b75752aa08b6d9cb46aa051ea"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "2605b77e34a8db61b2a078332437ca5c5fef6487",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=5c7ee1b2da6bf783d27034fca9dfd3a64ed525cb",
        "patch": "@@ -1905,7 +1905,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      }
    ]
  }
]