[
  {
    "sha": "1ec7629b89583aeaece53704e12ff63dc35337a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZWM3NjI5Yjg5NTgzYWVhZWNlNTM3MDRlMTJmZjYzZGMzNTMzN2E1",
    "commit": {
      "author": {
        "name": "Oskar Fridell",
        "email": "oskar.fridell@ericsson.com",
        "date": "2018-10-30T10:17:07Z"
      },
      "committer": {
        "name": "Oskar Fridell",
        "email": "oskar.fridell@ericsson.com",
        "date": "2018-10-30T10:28:23Z"
      },
      "message": "Tests: Consistency changes in comments\n\nChange-Id: Iaf02afbcd37631667c6652602496c6f8d4b22a4d",
      "tree": {
        "sha": "fe0204d622005a555e0bca6d05ce5428917b706c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe0204d622005a555e0bca6d05ce5428917b706c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ec7629b89583aeaece53704e12ff63dc35337a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ec7629b89583aeaece53704e12ff63dc35337a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ec7629b89583aeaece53704e12ff63dc35337a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ec7629b89583aeaece53704e12ff63dc35337a5/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "29f429dc7d4c7e6cd012e749cadf89e3138bcab3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29f429dc7d4c7e6cd012e749cadf89e3138bcab3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29f429dc7d4c7e6cd012e749cadf89e3138bcab3"
      }
    ],
    "stats": {
      "total": 1026,
      "additions": 513,
      "deletions": 513
    },
    "files": [
      {
        "sha": "f902507b3c7bf543fbfae335f853e4bd8474286b",
        "filename": "test/functional/combine_logs.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/combine_logs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/combine_logs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/combine_logs.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -63,10 +63,10 @@ def get_log_events(source, logfile):\n             event = ''\n             timestamp = ''\n             for line in infile:\n-                # skip blank lines\n+                # Skip blank lines\n                 if line == '\\n':\n                     continue\n-                # if this line has a timestamp, it's the start of a new log event.\n+                # If this line has a timestamp, it's the start of a new log event.\n                 time_match = TIMESTAMP_PATTERN.match(line)\n                 if time_match:\n                     if event:\n@@ -78,7 +78,7 @@ def get_log_events(source, logfile):\n                         line = line.replace(timestamp, timestamp_micro)\n                         timestamp = timestamp_micro\n                     event = line\n-                # if it doesn't have a timestamp, it's a continuation line of the previous log.\n+                # If it doesn't have a timestamp, it's a continuation line of the previous log.\n                 else:\n                     # Add the line. Prefix with space equivalent to the source + timestamp so log lines are aligned\n                     event += \"                                   \" + line"
      },
      {
        "sha": "e4e0d0f44fb0df05b75a17e7f7aea6072c39cdd1",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -165,7 +165,7 @@ def run_test(self):\n         p2p1 = self.nodes[1].add_p2p_connection(BaseNode())\n         p2p2 = self.nodes[2].add_p2p_connection(BaseNode())\n \n-        # send header lists to all three nodes\n+        # Send header lists to all three nodes\n         p2p0.send_header_for_blocks(self.blocks[0:2000])\n         p2p0.send_header_for_blocks(self.blocks[2000:])\n         p2p1.send_header_for_blocks(self.blocks[0:2000])"
      },
      {
        "sha": "ce9bd95b2299c86c6c04ce30a254f2a4f0ff08cb",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -13,8 +13,8 @@\n from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, bytes_to_hex_str, get_bip9_status, satoshi_round, sync_blocks\n \n SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n-SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n-SEQUENCE_LOCKTIME_GRANULARITY = 9 # this is a bit-shift\n+SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # This means use time (0 means height)\n+SEQUENCE_LOCKTIME_GRANULARITY = 9 # This is a bit-shift\n SEQUENCE_LOCKTIME_MASK = 0x0000ffff\n \n # RPC error for non-BIP68 final transactions\n@@ -60,7 +60,7 @@ def run_test(self):\n     def test_disable_flag(self):\n         # Create some unconfirmed inputs\n         new_addr = self.nodes[0].getnewaddress()\n-        self.nodes[0].sendtoaddress(new_addr, 2) # send 2 BTC\n+        self.nodes[0].sendtoaddress(new_addr, 2) # Send 2 BTC\n \n         utxos = self.nodes[0].listunspent(0, 0)\n         assert(len(utxos) > 0)\n@@ -144,7 +144,7 @@ def test_sequence_lock_confirmed_inputs(self):\n             tx.nVersion = 2\n             value = 0\n             for j in range(num_inputs):\n-                sequence_value = 0xfffffffe # this disables sequence locks\n+                sequence_value = 0xfffffffe # This disables sequence locks\n \n                 # 50% chance we enable sequence locks\n                 if random.randint(0,1):\n@@ -164,12 +164,12 @@ def test_sequence_lock_confirmed_inputs(self):\n                     orig_time = self.get_median_time_past(utxos[j][\"confirmations\"])\n                     cur_time = self.get_median_time_past(0) # MTP of the tip\n \n-                    # can only timelock this input if it's not too old -- otherwise use height\n+                    # Can only timelock this input if it's not too old -- otherwise use height\n                     can_time_lock = True\n                     if ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY) >= SEQUENCE_LOCKTIME_MASK:\n                         can_time_lock = False\n \n-                    # if time-lockable, then 50% chance we make this a time lock\n+                    # If time-lockable, then 50% chance we make this a time lock\n                     if random.randint(0,1) and can_time_lock:\n                         # Find first time-lock value that fails, or latest one that succeeds\n                         time_delta = sequence_value << SEQUENCE_LOCKTIME_GRANULARITY\n@@ -344,7 +344,7 @@ def test_bip68_not_consensus(self):\n         tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n         tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n \n-        # sign tx2\n+        # Sign tx2\n         tx2_raw = self.nodes[0].signrawtransactionwithwallet(ToHex(tx2))[\"hex\"]\n         tx2 = FromHex(tx2, tx2_raw)\n         tx2.rehash()\n@@ -362,7 +362,7 @@ def test_bip68_not_consensus(self):\n \n         assert_raises_rpc_error(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx3))\n \n-        # make a block that violates bip68; ensure that the tip updates\n+        # Make a block that violates bip68; ensure that the tip updates\n         tip = int(self.nodes[0].getbestblockhash(), 16)\n         block = create_block(tip, create_coinbase(self.nodes[0].getblockcount()+1))\n         block.nVersion = 3\n@@ -376,7 +376,7 @@ def test_bip68_not_consensus(self):\n         assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n \n     def activateCSV(self):\n-        # activation should happen at block height 432 (3 periods)\n+        # Activation should happen at block height 432 (3 periods)\n         # getblockchaininfo will show CSV as active at block 431 (144 * 3 -1) since it's returning whether CSV is active for the next block.\n         min_activation_height = 432\n         height = self.nodes[0].getblockcount()"
      },
      {
        "sha": "23080c9b7d4186326ed37640edaf539c0a3af7c4",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -76,7 +76,7 @@ def set_test_params(self):\n         self.extra_args = [[]]\n \n     def run_test(self):\n-        node = self.nodes[0]  # convenience reference to the node\n+        node = self.nodes[0]  # Convenience reference to the node\n \n         self.bootstrap_p2p()  # Add one p2p connection to the node\n \n@@ -102,7 +102,7 @@ def run_test(self):\n             self.save_spendable_output()\n         self.sync_blocks(blocks)\n \n-        # collect spendable outputs now to avoid cluttering the code later on\n+        # Collect spendable outputs now to avoid cluttering the code later on\n         out = []\n         for i in range(33):\n             out.append(self.get_spendable_output())\n@@ -347,7 +347,7 @@ def run_test(self):\n         self.sync_blocks([b31], True)\n         self.save_spendable_output()\n \n-        # this goes over the limit because the coinbase has one sigop\n+        # This goes over the limit because the coinbase has one sigop\n         self.log.info(\"Reject a block with too many OP_CHECKMULTISIG sigops\")\n         too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n         b32 = self.next_block(32, spend=out[9], script=too_many_multisigs)\n@@ -388,7 +388,7 @@ def run_test(self):\n         #                                                                                     \\-> b38 (11/37)\n         #\n \n-        # save 37's spendable output, but then double-spend out11 to invalidate the block\n+        # Save 37's spendable output, but then double-spend out11 to invalidate the block\n         self.log.info(\"Reject a block spending transaction from a block which failed to connect\")\n         self.move_tip(35)\n         b37 = self.next_block(37, spend=out[11])\n@@ -397,7 +397,7 @@ def run_test(self):\n         b37 = self.update_block(37, [tx])\n         self.sync_blocks([b37], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n \n-        # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n+        # Attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n         self.move_tip(35)\n         b38 = self.next_block(38, spend=txout_b37)\n         self.sync_blocks([b38], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n@@ -473,7 +473,7 @@ def run_test(self):\n             tx = CTransaction()\n             tx.vout.append(CTxOut(1, CScript([OP_TRUE])))\n             tx.vin.append(CTxIn(lastOutpoint, b''))\n-            # second input is corresponding P2SH output from b39\n+            # Second input is corresponding P2SH output from b39\n             tx.vin.append(CTxIn(COutPoint(b39.vtx[i].sha256, 0), b''))\n             # Note: must pass the redeem_script (not p2sh_script) to the signature hash function\n             (sighash, err) = SignatureHash(redeem_script, tx, 1, SIGHASH_ALL)\n@@ -494,7 +494,7 @@ def run_test(self):\n         self.update_block(40, new_txs)\n         self.sync_blocks([b40], success=False, reject_reason='bad-blk-sigops', reconnect=True)\n \n-        # same as b40, but one less sigop\n+        # Same as b40, but one less sigop\n         self.log.info(\"Accept a block with the max number of P2SH sigops\")\n         self.move_tip(39)\n         b41 = self.next_block(41, spend=None)\n@@ -632,7 +632,7 @@ def run_test(self):\n         b54.solve()\n         self.sync_blocks([b54], False, request_block=False)\n \n-        # valid timestamp\n+        # Valid timestamp\n         self.move_tip(53)\n         b55 = self.next_block(55, spend=out[15])\n         b55.nTime = b35.nTime\n@@ -737,7 +737,7 @@ def run_test(self):\n         b59 = self.update_block(59, [tx])\n         self.sync_blocks([b59], success=False, reject_reason='bad-txns-in-belowout', reconnect=True)\n \n-        # reset to good chain\n+        # Reset to good chain\n         self.move_tip(57)\n         b60 = self.next_block(60, spend=out[17])\n         self.sync_blocks([b60], True)\n@@ -770,8 +770,8 @@ def run_test(self):\n         self.move_tip(60)\n         b62 = self.next_block(62)\n         tx = CTransaction()\n-        tx.nLockTime = 0xffffffff  # this locktime is non-final\n-        tx.vin.append(CTxIn(COutPoint(out[18].sha256, 0)))  # don't set nSequence\n+        tx.nLockTime = 0xffffffff  # This locktime is non-final\n+        tx.vin.append(CTxIn(COutPoint(out[18].sha256, 0)))  # Don't set nSequence\n         tx.vout.append(CTxOut(0, CScript([OP_TRUE])))\n         assert(tx.vin[0].nSequence < 0xffffffff)\n         tx.calc_sha256()\n@@ -810,14 +810,14 @@ def run_test(self):\n         self.move_tip(60)\n         regular_block = self.next_block(\"64a\", spend=out[18])\n \n-        # make it a \"broken_block,\" with non-canonical serialization\n+        # Make it a \"broken_block,\" with non-canonical serialization\n         b64a = CBrokenBlock(regular_block)\n         b64a.initialize(regular_block)\n         self.blocks[\"64a\"] = b64a\n         self.tip = b64a\n         tx = CTransaction()\n \n-        # use canonical serialization to calculate size\n+        # Use canonical serialization to calculate size\n         script_length = MAX_BLOCK_BASE_SIZE - len(b64a.normal_serialize()) - 69\n         script_output = CScript([b'\\x00' * script_length])\n         tx.vout.append(CTxOut(0, script_output))\n@@ -938,9 +938,9 @@ def run_test(self):\n         b72 = self.next_block(72)\n         tx1 = self.create_and_sign_transaction(out[21], 2)\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n-        b72 = self.update_block(72, [tx1, tx2])  # now tip is 72\n+        b72 = self.update_block(72, [tx1, tx2])  # Now tip is 72\n         b71 = copy.deepcopy(b72)\n-        b71.vtx.append(tx2)   # add duplicate tx2\n+        b71.vtx.append(tx2)   # Add duplicate tx2\n         self.block_heights[b71.sha256] = self.block_heights[b69.sha256] + 1  # b71 builds off b69\n         self.blocks[71] = b71\n \n@@ -1073,7 +1073,7 @@ def run_test(self):\n         b79 = self.update_block(79, [tx79])\n         self.sync_blocks([b79], True)\n \n-        # mempool should be empty\n+        # Mempool should be empty\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.move_tip(77)\n@@ -1082,14 +1082,14 @@ def run_test(self):\n         self.save_spendable_output()\n \n         b81 = self.next_block(81, spend=out[26])\n-        self.sync_blocks([b81], False, request_block=False)  # other chain is same length\n+        self.sync_blocks([b81], False, request_block=False)  # Other chain is same length\n         self.save_spendable_output()\n \n         b82 = self.next_block(82, spend=out[27])\n-        self.sync_blocks([b82], True)  # now this chain is longer, triggers re-org\n+        self.sync_blocks([b82], True)  # Now this chain is longer, triggers re-org\n         self.save_spendable_output()\n \n-        # now check that tx78 and tx79 have been put back into the peer's mempool\n+        # Now check that tx78 and tx79 have been put back into the peer's mempool\n         mempool = self.nodes[0].getrawmempool()\n         assert_equal(len(mempool), 2)\n         assert(tx78.hash in mempool)\n@@ -1142,21 +1142,21 @@ def run_test(self):\n \n         self.move_tip(83)\n         b85 = self.next_block(85, spend=out[29])\n-        self.sync_blocks([b85], False)  # other chain is same length\n+        self.sync_blocks([b85], False)  # Other chain is same length\n \n         b86 = self.next_block(86, spend=out[30])\n         self.sync_blocks([b86], True)\n \n         self.move_tip(84)\n         b87 = self.next_block(87, spend=out[30])\n-        self.sync_blocks([b87], False)  # other chain is same length\n+        self.sync_blocks([b87], False)  # Other chain is same length\n         self.save_spendable_output()\n \n         b88 = self.next_block(88, spend=out[31])\n         self.sync_blocks([b88], True)\n         self.save_spendable_output()\n \n-        # trying to spend the OP_RETURN output is rejected\n+        # Trying to spend the OP_RETURN output is rejected\n         b89a = self.next_block(\"89a\", spend=out[32])\n         tx = self.create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n         b89a = self.update_block(\"89a\", [tx])\n@@ -1184,14 +1184,14 @@ def run_test(self):\n         self.sync_blocks(blocks, True, timeout=180)\n         chain1_tip = i\n \n-        # now create alt chain of same length\n+        # Now create alt chain of same length\n         self.move_tip(88)\n         blocks2 = []\n         for i in range(89, LARGE_REORG_SIZE + 89):\n             blocks2.append(self.next_block(\"alt\" + str(i)))\n         self.sync_blocks(blocks2, False, request_block=False)\n \n-        # extend alt chain to trigger re-org\n+        # Extend alt chain to trigger re-org\n         block = self.next_block(\"alt\" + str(chain1_tip + 1))\n         self.sync_blocks([block], True, timeout=180)\n \n@@ -1209,11 +1209,11 @@ def add_transactions_to_block(self, block, tx_list):\n         [tx.rehash() for tx in tx_list]\n         block.vtx.extend(tx_list)\n \n-    # this is a little handier to use than the version in blocktools.py\n+    # This is a little handier to use than the version in blocktools.py\n     def create_tx(self, spend_tx, n, value, script=CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE])):\n         return create_tx_with_script(spend_tx, n, amount=value, script_pub_key=script)\n \n-    # sign a transaction, using the key we know about\n+    # Sign a transaction, using the key we know about\n     # this signs input 0 in tx, which is assumed to be spending output n in spend_tx\n     def sign_tx(self, tx, spend_tx):\n         scriptPubKey = bytearray(spend_tx.vout[0].scriptPubKey)\n@@ -1244,10 +1244,10 @@ def next_block(self, number, spend=None, additional_coinbase_value=0, script=CSc\n         if spend is None:\n             block = create_block(base_block_hash, coinbase, block_time)\n         else:\n-            coinbase.vout[0].nValue += spend.vout[0].nValue - 1  # all but one satoshi to fees\n+            coinbase.vout[0].nValue += spend.vout[0].nValue - 1  # All but one satoshi to fees\n             coinbase.rehash()\n             block = create_block(base_block_hash, coinbase, block_time)\n-            tx = self.create_tx(spend, 0, 1, script)  # spend 1 satoshi\n+            tx = self.create_tx(spend, 0, 1, script)  # Spend 1 satoshi\n             self.sign_tx(tx, spend)\n             self.add_transactions_to_block(block, [tx])\n             block.hashMerkleRoot = block.calc_merkle_root()\n@@ -1259,21 +1259,21 @@ def next_block(self, number, spend=None, additional_coinbase_value=0, script=CSc\n         self.blocks[number] = block\n         return block\n \n-    # save the current tip so it can be spent by a later block\n+    # Save the current tip so it can be spent by a later block\n     def save_spendable_output(self):\n         self.log.debug(\"saving spendable output %s\" % self.tip.vtx[0])\n         self.spendable_outputs.append(self.tip)\n \n-    # get an output that we previously marked as spendable\n+    # Get an output that we previously marked as spendable\n     def get_spendable_output(self):\n         self.log.debug(\"getting spendable output %s\" % self.spendable_outputs[0].vtx[0])\n         return self.spendable_outputs.pop(0).vtx[0]\n \n-    # move the tip back to a previous block\n+    # Move the tip back to a previous block\n     def move_tip(self, number):\n         self.tip = self.blocks[number]\n \n-    # adds transactions to the block and updates state\n+    # Adds transactions to the block and updates state\n     def update_block(self, block_number, new_transactions):\n         block = self.blocks[block_number]\n         self.add_transactions_to_block(block, new_transactions)"
      },
      {
        "sha": "896da30a143e25386bb9301bd7d45128de7f03f5",
        "filename": "test/functional/feature_config_args.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_config_args.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_config_args.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_config_args.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -30,7 +30,7 @@ def test_config_file_parser(self):\n         self.nodes[0].assert_start_raises_init_error(expected_msg='Error reading configuration file: parse error on line 1: nono, if you intended to specify a negated option, use nono=1 instead')\n \n         with open(inc_conf_file_path, 'w', encoding='utf-8') as conf:\n-            conf.write('')  # clear\n+            conf.write('')  # Clear\n \n     def run_test(self):\n         self.stop_node(0)"
      },
      {
        "sha": "f89feb092d51b5d6eeb6b54f7af0326049dd33a2",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -125,9 +125,9 @@ def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, address, locktim\n     for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n         locktime = relative_locktime(sdf, srhb, stf, srlb)\n         tx = create_transaction(node, bip112inputs[i], address, amount=Decimal(\"49.98\"))\n-        if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n+        if (varyOP_CSV):  # If varying OP_CSV, nSequence is fixed\n             tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n-        else:  # vary nSequence instead, OP_CSV is fixed\n+        else:  # Vary nSequence instead, OP_CSV is fixed\n             tx.vin[0].nSequence = locktime + locktime_delta\n         tx.nVersion = txversion\n         signtx = sign_transaction(node, tx)\n@@ -178,11 +178,11 @@ def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PDataStore())\n \n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n-        long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n-        self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n+        long_past_time = int(time.time()) - 600 * 1000  # Enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100)  # Enough so that the generated blocks will still all be before long_past_time\n         self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2 * 32 + 1)  # 82 blocks generated for inputs\n-        self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n-        self.tipheight = 82  # height of the next block to build\n+        self.nodes[0].setmocktime(0)  # Set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82  # Height of the next block to build\n         self.last_block_time = long_past_time\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n@@ -289,10 +289,10 @@ def run_test(self):\n         # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n         bip112txs_vary_nSequence_9_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 1, self.nodeaddress, -1)\n         bip112txs_vary_nSequence_9_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 2, self.nodeaddress, -1)\n-        # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        # Sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n         bip112txs_vary_OP_CSV_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 1, self.nodeaddress)\n         bip112txs_vary_OP_CSV_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 2, self.nodeaddress)\n-        # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n+        # Sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n         bip112txs_vary_OP_CSV_9_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 1, self.nodeaddress, -1)\n         bip112txs_vary_OP_CSV_9_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 2, self.nodeaddress, -1)\n         # -1 OP_CSV OP_DROP input\n@@ -305,17 +305,17 @@ def run_test(self):\n         self.log.info(\"Test version 1 txs\")\n \n         success_txs = []\n-        # add BIP113 tx and -1 CSV tx\n+        # Add BIP113 tx and -1 CSV tx\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n         success_txs.append(bip113signed1)\n         success_txs.append(bip112tx_special_v1)\n-        # add BIP 68 txs\n+        # Add BIP 68 txs\n         success_txs.extend(all_rlt_txs(bip68txs_v1))\n-        # add BIP 112 with seq=10 txs\n+        # Add BIP 112 with seq=10 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v1))\n-        # try BIP 112 with seq=9 txs\n+        # Try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n         self.sync_blocks([self.create_test_block(success_txs)])\n@@ -324,17 +324,17 @@ def run_test(self):\n         self.log.info(\"Test version 2 txs\")\n \n         success_txs = []\n-        # add BIP113 tx and -1 CSV tx\n+        # Add BIP113 tx and -1 CSV tx\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n         success_txs.append(bip113signed2)\n         success_txs.append(bip112tx_special_v2)\n-        # add BIP 68 txs\n+        # Add BIP 68 txs\n         success_txs.extend(all_rlt_txs(bip68txs_v2))\n-        # add BIP 112 with seq=10 txs\n+        # Add BIP 112 with seq=10 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v2))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_v2))\n-        # try BIP 112 with seq=9 txs\n+        # Try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n         self.sync_blocks([self.create_test_block(success_txs)])"
      },
      {
        "sha": "50d0f4e8505bfe79335defc04c91eb857da2ef67",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -184,7 +184,7 @@ def verify_utxo_hash(self):\n             try:\n                 nodei_utxo_hash = self.nodes[i].gettxoutsetinfo()['hash_serialized_2']\n             except OSError:\n-                # probably a crash on db flushing\n+                # Probably a crash on db flushing\n                 nodei_utxo_hash = self.restart_node(i, self.nodes[3].getbestblockhash())\n             assert_equal(nodei_utxo_hash, node3_utxo_hash)\n "
      },
      {
        "sha": "e1285ed24bab7c61b7d66045e1539114d7c87ee6",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -102,10 +102,10 @@ def split_inputs(from_node, txins, txouts, initial_split=False):\n def check_estimates(node, fees_seen):\n     \"\"\"Call estimatesmartfee and verify that the estimates meet certain invariants.\"\"\"\n \n-    delta = 1.0e-6  # account for rounding error\n+    delta = 1.0e-6  # Account for rounding error\n     last_feerate = float(max(fees_seen))\n     all_smart_estimates = [node.estimatesmartfee(i) for i in range(1, 26)]\n-    for i, e in enumerate(all_smart_estimates):  # estimate is for i+1\n+    for i, e in enumerate(all_smart_estimates):  # Estimate is for i+1\n         feerate = float(e[\"feerate\"])\n         assert_greater_than(feerate, 0)\n \n@@ -162,7 +162,7 @@ def transact_and_mine(self, numblocks, mining_node):\n             sync_mempools(self.nodes[0:3], wait=.1)\n             mined = mining_node.getblock(mining_node.generate(1)[0], True)[\"tx\"]\n             sync_blocks(self.nodes[0:3], wait=.1)\n-            # update which txouts are confirmed\n+            # Update which txouts are confirmed\n             newmem = []\n             for utx in self.memutxo:\n                 if utx[\"txid\"] in mined:"
      },
      {
        "sha": "9db1eb316b2c3aee50739f44a382ddf68e2d123f",
        "filename": "test/functional/feature_logging.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_logging.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_logging.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_logging.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -19,54 +19,54 @@ def relative_log_path(self, name):\n         return os.path.join(self.nodes[0].datadir, \"regtest\", name)\n \n     def run_test(self):\n-        # test default log file name\n+        # Test default log file name\n         default_log_path = self.relative_log_path(\"debug.log\")\n         assert os.path.isfile(default_log_path)\n \n-        # test alternative log file name in datadir\n+        # Test alternative log file name in datadir\n         self.restart_node(0, [\"-debuglogfile=foo.log\"])\n         assert os.path.isfile(self.relative_log_path(\"foo.log\"))\n \n-        # test alternative log file name outside datadir\n+        # Test alternative log file name outside datadir\n         tempname = os.path.join(self.options.tmpdir, \"foo.log\")\n         self.restart_node(0, [\"-debuglogfile=%s\" % tempname])\n         assert os.path.isfile(tempname)\n \n-        # check that invalid log (relative) will cause error\n+        # Check that invalid log (relative) will cause error\n         invdir = self.relative_log_path(\"foo\")\n         invalidname = os.path.join(\"foo\", \"foo.log\")\n         self.stop_node(0)\n         exp_stderr = \"Error: Could not open debug log file \\S+$\"\n         self.nodes[0].assert_start_raises_init_error([\"-debuglogfile=%s\" % (invalidname)], exp_stderr, match=ErrorMatch.FULL_REGEX)\n         assert not os.path.isfile(os.path.join(invdir, \"foo.log\"))\n \n-        # check that invalid log (relative) works after path exists\n+        # Check that invalid log (relative) works after path exists\n         self.stop_node(0)\n         os.mkdir(invdir)\n         self.start_node(0, [\"-debuglogfile=%s\" % (invalidname)])\n         assert os.path.isfile(os.path.join(invdir, \"foo.log\"))\n \n-        # check that invalid log (absolute) will cause error\n+        # Check that invalid log (absolute) will cause error\n         self.stop_node(0)\n         invdir = os.path.join(self.options.tmpdir, \"foo\")\n         invalidname = os.path.join(invdir, \"foo.log\")\n         self.nodes[0].assert_start_raises_init_error([\"-debuglogfile=%s\" % invalidname], exp_stderr, match=ErrorMatch.FULL_REGEX)\n         assert not os.path.isfile(os.path.join(invdir, \"foo.log\"))\n \n-        # check that invalid log (absolute) works after path exists\n+        # Check that invalid log (absolute) works after path exists\n         self.stop_node(0)\n         os.mkdir(invdir)\n         self.start_node(0, [\"-debuglogfile=%s\" % (invalidname)])\n         assert os.path.isfile(os.path.join(invdir, \"foo.log\"))\n \n-        # check that -nodebuglogfile disables logging\n+        # Check that -nodebuglogfile disables logging\n         self.stop_node(0)\n         os.unlink(default_log_path)\n         assert not os.path.isfile(default_log_path)\n         self.start_node(0, [\"-nodebuglogfile\"])\n         assert not os.path.isfile(default_log_path)\n \n-        # just sanity check no crash here\n+        # Just sanity check no crash here\n         self.stop_node(0)\n         self.start_node(0, [\"-debuglogfile=%s\" % os.devnull])\n "
      },
      {
        "sha": "24c26b10d0767fabbc44e211562e09c9d8d7fc47",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -37,32 +37,32 @@ def run_test(self):\n         block_count = 10\n         blocks = self.nodes[1].generatetoaddress(block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n \n-        # wait at most 10 seconds for expected number of files before reading the content\n+        # Wait at most 10 seconds for expected number of files before reading the content\n         wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n \n-        # directory content should equal the generated blocks hashes\n+        # Directory content should equal the generated blocks hashes\n         assert_equal(sorted(blocks), sorted(os.listdir(self.blocknotify_dir)))\n \n         if self.is_wallet_compiled():\n             self.log.info(\"test -walletnotify\")\n-            # wait at most 10 seconds for expected number of files before reading the content\n+            # Wait at most 10 seconds for expected number of files before reading the content\n             wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n-            # directory content should equal the generated transaction hashes\n+            # Directory content should equal the generated transaction hashes\n             txids_rpc = list(map(lambda t: t['txid'], self.nodes[1].listtransactions(\"*\", block_count)))\n             assert_equal(sorted(txids_rpc), sorted(os.listdir(self.walletnotify_dir)))\n             self.stop_node(1)\n             for tx_file in os.listdir(self.walletnotify_dir):\n                 os.remove(os.path.join(self.walletnotify_dir, tx_file))\n \n             self.log.info(\"test -walletnotify after rescan\")\n-            # restart node to rescan to force wallet notifications\n+            # Restart node to rescan to force wallet notifications\n             self.start_node(1)\n             connect_nodes_bi(self.nodes, 0, 1)\n \n             wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n-            # directory content should equal the generated transaction hashes\n+            # Directory content should equal the generated transaction hashes\n             txids_rpc = list(map(lambda t: t['txid'], self.nodes[1].listtransactions(\"*\", block_count)))\n             assert_equal(sorted(txids_rpc), sorted(os.listdir(self.walletnotify_dir)))\n "
      },
      {
        "sha": "819fbdb32775ceea5f3461254655b82c6a567dc3",
        "filename": "test/functional/feature_proxy.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_proxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_proxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_proxy.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -146,7 +146,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n         return rv\n \n     def run_test(self):\n-        # basic -proxy\n+        # Basic -proxy\n         self.node_test(self.nodes[0], [self.serv1, self.serv1, self.serv1, self.serv1], False)\n \n         # -proxy plus -onion\n@@ -159,7 +159,7 @@ def run_test(self):\n         assert_equal(len(credentials), len(rv))\n \n         if self.have_ipv6:\n-            # proxy on IPv6 localhost\n+            # Proxy on IPv6 localhost\n             self.node_test(self.nodes[3], [self.serv3, self.serv3, self.serv3, self.serv3], False, False)\n \n         def networks_dict(d):\n@@ -168,7 +168,7 @@ def networks_dict(d):\n                 r[x['name']] = x\n             return r\n \n-        # test RPC getnetworkinfo\n+        # Test RPC getnetworkinfo\n         n0 = networks_dict(self.nodes[0].getnetworkinfo())\n         for net in ['ipv4','ipv6','onion']:\n             assert_equal(n0[net]['proxy'], '%s:%i' % (self.conf1.addr))"
      },
      {
        "sha": "dace228ea4e5083f5a449bf983e76a699c21984d",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -228,13 +228,13 @@ def reorg_back(self):\n         assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n \n     def manual_test(self, node_number, use_timestamp):\n-        # at this point, node has 995 blocks and has not yet run in prune mode\n+        # At this point, node has 995 blocks and has not yet run in prune mode\n         self.start_node(node_number)\n         node = self.nodes[node_number]\n         assert_equal(node.getblockcount(), 995)\n         assert_raises_rpc_error(-1, \"not in prune mode\", node.pruneblockchain, 500)\n \n-        # now re-start in manual pruning mode\n+        # Now re-start in manual pruning mode\n         self.stop_node(node_number)\n         self.start_node(node_number, extra_args=[\"-prune=1\"])\n         node = self.nodes[node_number]\n@@ -264,21 +264,21 @@ def prune(index, expected_ret=None):\n         def has_block(index):\n             return os.path.isfile(os.path.join(self.nodes[node_number].datadir, \"regtest\", \"blocks\", \"blk{:05}.dat\".format(index)))\n \n-        # should not prune because chain tip of node 3 (995) < PruneAfterHeight (1000)\n+        # Should not prune because chain tip of node 3 (995) < PruneAfterHeight (1000)\n         assert_raises_rpc_error(-1, \"Blockchain is too short for pruning\", node.pruneblockchain, height(500))\n \n         # Save block transaction count before pruning, assert value\n         block1_details = node.getblock(node.getblockhash(1))\n         assert_equal(block1_details[\"nTx\"], len(block1_details[\"tx\"]))\n \n-        # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n+        # Mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n         node.generate(6)\n         assert_equal(node.getblockchaininfo()[\"blocks\"], 1001)\n \n         # Pruned block should still know the number of transactions\n         assert_equal(node.getblockheader(node.getblockhash(1))[\"nTx\"], block1_details[\"nTx\"])\n \n-        # negative heights should raise an exception\n+        # Negative heights should raise an exception\n         assert_raises_rpc_error(-8, \"Negative\", node.pruneblockchain, -10)\n \n         # height=100 too low to prune first block file so this is a no-op\n@@ -308,29 +308,29 @@ def has_block(index):\n         if not has_block(2):\n             raise AssertionError(\"blk00002.dat is still there, should be pruned by now\")\n \n-        # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n+        # Advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n         node.generate(288)\n         prune(1000)\n         if has_block(2):\n             raise AssertionError(\"blk00002.dat is still there, should be pruned by now\")\n         if has_block(3):\n             raise AssertionError(\"blk00003.dat is still there, should be pruned by now\")\n \n-        # stop node, start back up with auto-prune at 550MB, make sure still runs\n+        # Stop node, start back up with auto-prune at 550MB, make sure still runs\n         self.stop_node(node_number)\n         self.start_node(node_number, extra_args=[\"-prune=550\"])\n \n         self.log.info(\"Success\")\n \n     def wallet_test(self):\n-        # check that the pruning node's wallet is still in good shape\n+        # Check that the pruning node's wallet is still in good shape\n         self.log.info(\"Stop and start pruning node to trigger wallet rescan\")\n         self.stop_node(2)\n         self.start_node(2, extra_args=[\"-prune=550\"])\n         self.log.info(\"Success\")\n \n-        # check that wallet loads successfully when restarting a pruned node after IBD.\n-        # this was reported to fail in #7494.\n+        # Check that wallet loads successfully when restarting a pruned node after IBD.\n+        # This was reported to fail in #7494.\n         self.log.info(\"Syncing node 5 to test wallet\")\n         connect_nodes(self.nodes[0], 5)\n         nds = [self.nodes[0], self.nodes[5]]\n@@ -360,7 +360,7 @@ def run_test(self):\n         # Start by mining a simple chain that all nodes have\n         # N0=N1=N2 **...*(995)\n \n-        # stop manual-pruning node with 995 blocks\n+        # Stop manual-pruning node with 995 blocks\n         self.stop_node(3)\n         self.stop_node(4)\n \n@@ -376,12 +376,12 @@ def run_test(self):\n         # N1=N2 **...*+...+(1044)\n         # N0    **...**...**(1045)\n         #\n-        # reconnect nodes causing reorg on N1 and N2\n+        # Reconnect nodes causing reorg on N1 and N2\n         # N1=N2 **...*(1020) *...**(1045)\n         #                   \\\n         #                    +...+(1044)\n         #\n-        # repeat this process until you have 12 stale forks hanging off the\n+        # Repeat this process until you have 12 stale forks hanging off the\n         # main chain on N1 and N2\n         # N0    *************************...***************************(1320)\n         #"
      },
      {
        "sha": "28e6a7fdc7e83636775c7e560f2452e594fa5819",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -86,7 +86,7 @@ def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n         assert_raises_rpc_error(-26, error_msg, send_to_witness, use_p2wsh=1, node=node, utxo=getutxo(txid), pubkey=self.pubkey[0], encode_p2sh=False, amount=Decimal(\"49.998\"), sign=sign, insert_redeem_script=redeem_script)\n \n     def run_test(self):\n-        self.nodes[0].generate(161)  # block 161\n+        self.nodes[0].generate(161)  # Block 161\n \n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n@@ -102,7 +102,7 @@ def run_test(self):\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        self.nodes[0].generate(1)  # block 162\n+        self.nodes[0].generate(1)  # Block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n@@ -128,44 +128,44 @@ def run_test(self):\n                     wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n                     p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1)  # block 163\n+        self.nodes[0].generate(1)  # Block 163\n         sync_blocks(self.nodes)\n \n         # Make sure all nodes recognize the transactions as theirs\n         assert_equal(self.nodes[0].getbalance(), balance_presetup - 60 * 50 + 20 * Decimal(\"49.999\") + 50)\n         assert_equal(self.nodes[1].getbalance(), 20 * Decimal(\"49.999\"))\n         assert_equal(self.nodes[2].getbalance(), 20 * Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(260)  # block 423\n+        self.nodes[0].generate(260)  # Block 423\n         sync_blocks(self.nodes)\n \n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n-        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True)  # block 424\n-        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True)  # block 425\n-        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True)  # block 426\n-        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True)  # block 427\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True)  # Block 424\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True)  # Block 425\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True)  # Block 426\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True)  # Block 427\n \n         self.log.info(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V0][1], False)\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V1][1], False)\n \n-        self.nodes[2].generate(4)  # blocks 428-431\n+        self.nodes[2].generate(4)  # Blocks 428-431\n \n         self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n-        block = self.nodes[2].generate(1)  # block 432 (first block with new rules; 432 = 144 * 3)\n+        block = self.nodes[2].generate(1)  # Block 432 (first block with new rules; 432 = 144 * 3)\n         sync_blocks(self.nodes)\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n         segwit_tx_list = self.nodes[2].getblock(block[0])[\"tx\"]\n         assert_equal(len(segwit_tx_list), 5)\n \n         self.log.info(\"Verify default node can't accept txs with missing witness\")\n-        # unsigned, no scriptsig\n+        # Unsigned, no scriptsig\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V0][0], False)\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V1][0], False)\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False)\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False)\n-        # unsigned with redeem script\n+        # Unsigned with redeem script\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False, witness_script(False, self.pubkey[0]))\n         self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n \n@@ -187,15 +187,15 @@ def run_test(self):\n         self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)', p2sh_ids[NODE_2][WIT_V1][2], sign=False, redeem_script=witness_script(True, self.pubkey[2]))\n \n         self.log.info(\"Verify default node can now use witness txs\")\n-        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)  # block 432\n-        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True)  # block 433\n-        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)  # block 434\n-        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)  # block 435\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)  # Block 432\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True)  # Block 433\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)  # Block 434\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)  # Block 435\n \n         self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n-        assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n+        assert(tmpl['sizelimit'] >= 3999577)  # Actual maximum size is lower due to minimum mandatory non-witness data\n         assert(tmpl['weightlimit'] == 4000000)\n         assert(tmpl['sigoplimit'] == 80000)\n         assert(tmpl['transactions'][0]['txid'] == txid)\n@@ -307,15 +307,15 @@ def run_test(self):\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # p2sh multisig with compressed keys should always be spendable\n+                # P2SH multisig with compressed keys should always be spendable\n                 spendable_anytime.extend([p2sh])\n-                # bare multisig can be watched and signed, but is not treated as ours\n+                # Bare multisig can be watched and signed, but is not treated as ours\n                 solvable_after_importaddress.extend([bare])\n                 # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after direct importaddress\n                 spendable_after_importaddress.extend([p2wsh, p2sh_p2wsh])\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH and P2PK with compressed keys should always be spendable\n+                # Normal P2PKH and P2PK with compressed keys should always be spendable\n                 spendable_anytime.extend([p2pkh, p2pk])\n                 # P2SH_P2PK, P2SH_P2PKH with compressed keys are spendable after direct importaddress\n                 spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n@@ -326,15 +326,15 @@ def run_test(self):\n             v = self.nodes[0].getaddressinfo(i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n-                # p2sh multisig with uncompressed keys should always be spendable\n+                # P2SH multisig with uncompressed keys should always be spendable\n                 spendable_anytime.extend([p2sh])\n-                # bare multisig can be watched and signed, but is not treated as ours\n+                # Bare multisig can be watched and signed, but is not treated as ours\n                 solvable_after_importaddress.extend([bare])\n                 # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n                 unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH and P2PK with uncompressed keys should always be spendable\n+                # Normal P2PKH and P2PK with uncompressed keys should always be spendable\n                 spendable_anytime.extend([p2pkh, p2pk])\n                 # P2SH_P2PK and P2SH_P2PKH are spendable after direct importaddress\n                 spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n@@ -349,7 +349,7 @@ def run_test(self):\n                 solvable_after_importaddress.extend([bare, p2sh, p2wsh, p2sh_p2wsh])\n             else:\n                 [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n-                # normal P2PKH, P2PK, P2WPKH and P2SH_P2WPKH with compressed keys should always be seen\n+                # Normal P2PKH, P2PK, P2WPKH and P2SH_P2WPKH with compressed keys should always be seen\n                 solvable_anytime.extend([p2pkh, p2pk, p2wpkh, p2sh_p2wpkh])\n                 # P2SH_P2PK, P2SH_P2PKH with compressed keys are seen after direct importaddress\n                 solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n@@ -415,11 +415,11 @@ def run_test(self):\n         importlist.append(bytes_to_hex_str(p2wshop1))\n \n         for i in importlist:\n-            # import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n-            # exceptions and continue.\n+            # Import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n+            # Exceptions and continue.\n             try_rpc(-4, \"The wallet already contains the private key for this address or script\", self.nodes[0].importaddress, i, \"\", False, True)\n \n-        self.nodes[0].importaddress(script_to_p2sh(op0))  # import OP_0 as address only\n+        self.nodes[0].importaddress(script_to_p2sh(op0))  # Import OP_0 as address only\n         self.nodes[0].importaddress(multisig_without_privkey_address)  # Test multisig_without_privkey\n \n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n@@ -501,7 +501,7 @@ def run_test(self):\n         # Check that spendable outputs are really spendable\n         self.create_and_mine_tx_from_txids(spendable_txid)\n \n-        # import all the private keys so solvable addresses become spendable\n+        # Import all the private keys so solvable addresses become spendable\n         self.nodes[0].importprivkey(\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n         self.nodes[0].importprivkey(\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n         self.nodes[0].importprivkey(\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")"
      },
      {
        "sha": "4815e3bbf934d853f33c92467bcf228b87a43848",
        "filename": "test/functional/interface_http.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/interface_http.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/interface_http.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_http.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -20,7 +20,7 @@ def setup_network(self):\n     def run_test(self):\n \n         #################################################\n-        # lowlevel check for http persistent connection #\n+        # Lowlevel check for http persistent connection #\n         #################################################\n         url = urllib.parse.urlparse(self.nodes[0].url)\n         authpair = url.username + ':' + url.password\n@@ -33,41 +33,41 @@ def run_test(self):\n         assert(b'\"error\":null' in out1)\n         assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n \n-        #send 2nd request without closing connection\n+        # Send 2nd request without closing connection\n         conn.request('POST', '/', '{\"method\": \"getchaintips\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1) #must also response with a correct json-rpc message\n         assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n         conn.close()\n \n-        #same should be if we add keep-alive because this should be the std. behaviour\n+        # Same should be if we add keep-alive because this should be the std. behaviour\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpair), \"Connection\": \"keep-alive\"}\n \n         conn = http.client.HTTPConnection(url.hostname, url.port)\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n+        assert(conn.sock!=None) # According to http/1.1 connection must still be open!\n \n-        #send 2nd request without closing connection\n+        # Send 2nd request without closing connection\n         conn.request('POST', '/', '{\"method\": \"getchaintips\"}', headers)\n         out1 = conn.getresponse().read()\n-        assert(b'\"error\":null' in out1) #must also response with a correct json-rpc message\n-        assert(conn.sock!=None) #according to http/1.1 connection must still be open!\n+        assert(b'\"error\":null' in out1) # Must also response with a correct json-rpc message\n+        assert(conn.sock!=None) # According to http/1.1 connection must still be open!\n         conn.close()\n \n-        #now do the same with \"Connection: close\"\n+        # Now do the same with \"Connection: close\"\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpair), \"Connection\":\"close\"}\n \n         conn = http.client.HTTPConnection(url.hostname, url.port)\n         conn.connect()\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock==None) #now the connection must be closed after the response\n+        assert(conn.sock==None) # Now the connection must be closed after the response\n \n-        #node1 (2nd node) is running with disabled keep-alive option\n+        # Node1 (2nd node) is running with disabled keep-alive option\n         urlNode1 = urllib.parse.urlparse(self.nodes[1].url)\n         authpair = urlNode1.username + ':' + urlNode1.password\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpair)}\n@@ -78,7 +78,7 @@ def run_test(self):\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n \n-        #node2 (third node) is running with standard keep-alive parameters which means keep-alive is on\n+        # Node2 (third node) is running with standard keep-alive parameters which means keep-alive is on\n         urlNode2 = urllib.parse.urlparse(self.nodes[2].url)\n         authpair = urlNode2.username + ':' + urlNode2.password\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpair)}\n@@ -88,7 +88,7 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock!=None) #connection must be closed because bitcoind should use keep-alive by default\n+        assert(conn.sock!=None) # Connection must be closed because bitcoind should use keep-alive by default\n \n         # Check excessive request size\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)"
      },
      {
        "sha": "66073d5810a1345cbb61bf3f86415eb0e2826ba0",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -97,8 +97,8 @@ def run_test(self):\n         self.log.info(\"Load the transaction using the /tx URI\")\n \n         json_obj = self.test_rest_request(\"/tx/{}\".format(txid))\n-        spent = (json_obj['vin'][0]['txid'], json_obj['vin'][0]['vout'])  # get the vin to later check for utxo (should be spent by then)\n-        # get n of 0.1 outpoint\n+        spent = (json_obj['vin'][0]['txid'], json_obj['vin'][0]['vout'])  # Get the vin to later check for utxo (should be spent by then)\n+        # Get n of 0.1 outpoint\n         n, = filter_output_indices_by_value(json_obj['vout'], Decimal('0.1'))\n         spending = (txid, n)\n \n@@ -145,20 +145,20 @@ def run_test(self):\n         chain_height, = unpack(\"i\", output.read(4))\n         response_hash = binascii.hexlify(output.read(32)[::-1]).decode('ascii')\n \n-        assert_equal(bb_hash, response_hash)  # check if getutxo's chaintip during calculation was fine\n-        assert_equal(chain_height, 102)  # chain height must be 102\n+        assert_equal(bb_hash, response_hash)  # Check if getutxo's chaintip during calculation was fine\n+        assert_equal(chain_height, 102)  # Chain height must be 102\n \n         self.log.info(\"Test the /getutxos URI with and without /checkmempool\")\n         # Create a transaction, check that it's found with /checkmempool, but\n         # not found without. Then confirm the transaction and check that it's\n         # found with or without /checkmempool.\n \n-        # do a tx and don't sync\n+        # Do a tx and don't sync\n         txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n         json_obj = self.test_rest_request(\"/tx/{}\".format(txid))\n-        # get the spent output to later check for utxo (should be spent by then)\n+        # Get the spent output to later check for utxo (should be spent by then)\n         spent = (json_obj['vin'][0]['txid'], json_obj['vin'][0]['vout'])\n-        # get n of 0.1 outpoint\n+        # Get n of 0.1 outpoint\n         n, = filter_output_indices_by_value(json_obj['vout'], Decimal('0.1'))\n         spending = (txid, n)\n \n@@ -195,7 +195,7 @@ def run_test(self):\n         long_uri = '/'.join(['{}-{}'.format(txid, n_) for n_ in range(15)])\n         self.test_rest_request(\"/getutxos/checkmempool/{}\".format(long_uri), http_method='POST', status=200)\n \n-        self.nodes[0].generate(1)  # generate block to not affect upcoming tests\n+        self.nodes[0].generate(1)  # Generate block to not affect upcoming tests\n         self.sync_all()\n \n         self.log.info(\"Test the /block and /headers URIs\")\n@@ -230,8 +230,8 @@ def run_test(self):\n \n         # Compare with json block header\n         json_obj = self.test_rest_request(\"/headers/1/{}\".format(bb_hash))\n-        assert_equal(len(json_obj), 1)  # ensure that there is one header in the json response\n-        assert_equal(json_obj[0]['hash'], bb_hash)  # request/response hash should be the same\n+        assert_equal(len(json_obj), 1)  # Ensure that there is one header in the json response\n+        assert_equal(json_obj[0]['hash'], bb_hash)  # Request/response hash should be the same\n \n         # Compare with normal RPC block response\n         rpc_block_json = self.nodes[0].getblock(bb_hash)\n@@ -242,7 +242,7 @@ def run_test(self):\n         self.nodes[1].generate(5)\n         self.sync_all()\n         json_obj = self.test_rest_request(\"/headers/5/{}\".format(bb_hash))\n-        assert_equal(len(json_obj), 5)  # now we should have 5 header objects\n+        assert_equal(len(json_obj), 5)  # Now we should have 5 header objects\n \n         self.log.info(\"Test the /tx URI\")\n \n@@ -267,7 +267,7 @@ def run_test(self):\n         # Check that there are exactly 3 transactions in the TX memory pool before generating the block\n         json_obj = self.test_rest_request(\"/mempool/info\")\n         assert_equal(json_obj['size'], 3)\n-        # the size of the memory pool should be greater than 3x ~100 bytes\n+        # The size of the memory pool should be greater than 3x ~100 bytes\n         assert_greater_than(json_obj['bytes'], 300)\n \n         # Check that there are our submitted transactions in the TX memory pool"
      },
      {
        "sha": "f7041b449ff377523bd9f5cdd6787ae6690dff01",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -112,10 +112,10 @@ def run_test(self):\n         self.log.info('A transaction that conflicts with an unconfirmed tx')\n         # Send the transaction that replaces the mempool transaction and opts out of replaceability\n         node.sendrawtransaction(hexstring=bytes_to_hex_str(tx.serialize()), allowhighfees=True)\n-        # take original raw_tx_0\n+        # Take original raw_tx_0\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vout[0].nValue -= int(4 * fee * COIN)  # Set more fee\n-        # skip re-signing the tx\n+        # Skip re-signing the tx\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '18: txn-mempool-conflict'}],\n             rawtxs=[bytes_to_hex_str(tx.serialize())],\n@@ -125,7 +125,7 @@ def run_test(self):\n         self.log.info('A transaction with missing inputs, that never existed')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_0)))\n         tx.vin[0].prevout = COutPoint(hash=int('ff' * 32, 16), n=14)\n-        # skip re-signing the tx\n+        # Skip re-signing the tx\n         self.check_mempool_result(\n             result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'missing-inputs'}],\n             rawtxs=[bytes_to_hex_str(tx.serialize())],"
      },
      {
        "sha": "2aca027673733f4c0ef49381c7670b279df11779",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -34,9 +34,9 @@ def run_test(self):\n         inputs = [{ \"txid\" : us0[\"txid\"], \"vout\" : us0[\"vout\"]}]\n         outputs = {self.nodes[0].getnewaddress() : 0.0001}\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-        self.nodes[0].settxfee(relayfee) # specifically fund this tx with low fee\n+        self.nodes[0].settxfee(relayfee) # Specifically fund this tx with low fee\n         txF = self.nodes[0].fundrawtransaction(tx)\n-        self.nodes[0].settxfee(0) # return to automatic fee selection\n+        self.nodes[0].settxfee(0) # Return to automatic fee selection\n         txFS = self.nodes[0].signrawtransactionwithwallet(txF['hex'])\n         txid = self.nodes[0].sendrawtransaction(txFS['hex'])\n \n@@ -60,7 +60,7 @@ def run_test(self):\n         inputs = [{ \"txid\" : us0[\"txid\"], \"vout\" : us0[\"vout\"]}]\n         outputs = {self.nodes[0].getnewaddress() : 0.0001}\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-        # specifically fund this tx with a fee < mempoolminfee, >= than minrelaytxfee\n+        # Specifically fund this tx with a fee < mempoolminfee, >= than minrelaytxfee\n         txF = self.nodes[0].fundrawtransaction(tx, {'feeRate': relayfee})\n         txFS = self.nodes[0].signrawtransactionwithwallet(txF['hex'])\n         assert_raises_rpc_error(-26, \"mempool min fee not met\", self.nodes[0].sendrawtransaction, txFS['hex'])"
      },
      {
        "sha": "041798ee2f3453acc5ed719e47ef3901495eabb0",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -33,7 +33,7 @@ def chain_transaction(self, node, parent_txid, vout, value, fee, num_outputs):\n         signedtx = node.signrawtransactionwithwallet(rawtx)\n         txid = node.sendrawtransaction(signedtx['hex'])\n         fulltx = node.getrawtransaction(txid, 1)\n-        assert(len(fulltx['vout']) == num_outputs) # make sure we didn't generate a change output\n+        assert(len(fulltx['vout']) == num_outputs) # Make sure we didn't generate a change output\n         return (txid, send_value)\n \n     def run_test(self):"
      },
      {
        "sha": "6dade32b8d3014221ec4ad00f11a03e0b2aaebf4",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -111,7 +111,7 @@ def run_test(self):\n         wait_until(lambda: len(self.nodes[1].getrawmempool()) == 5)\n \n         self.log.debug(\"Prevent bitcoind from writing mempool.dat to disk. Verify that `savemempool` fails\")\n-        # to test the exception we are creating a tmp folder called mempool.dat.new\n+        # To test the exception we are creating a tmp folder called mempool.dat.new\n         # which is an implementation detail that could change and break this test\n         mempooldotnew1 = mempooldat1 + '.new'\n         os.mkdir(mempooldotnew1)"
      },
      {
        "sha": "2a4e6c7a2b97f78bea964d2c376907ca4e17bb41",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -93,7 +93,7 @@ def run_test(self):\n \n         self.sync_all()\n \n-        # mempool should be empty.\n+        # Mempool should be empty.\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n \n if __name__ == '__main__':"
      },
      {
        "sha": "97965c29d703ed7e5e3e4b691bff9d2929dd10bc",
        "filename": "test/functional/mempool_resurrect.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_resurrect.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_resurrect.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_resurrect.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -41,7 +41,7 @@ def run_test(self):\n \n         blocks.extend(self.nodes[0].generate(1))\n \n-        # mempool should be empty, all txns confirmed\n+        # Mempool should be empty, all txns confirmed\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)\n@@ -52,15 +52,15 @@ def run_test(self):\n         for node in self.nodes:\n             node.invalidateblock(blocks[0])\n \n-        # mempool should be empty, all txns confirmed\n+        # Mempool should be empty, all txns confirmed\n         assert_equal(set(self.nodes[0].getrawmempool()), set(spends1_id+spends2_id))\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)\n             assert(tx[\"confirmations\"] == 0)\n \n         # Generate another block, they should all get mined\n         self.nodes[0].generate(1)\n-        # mempool should be empty, all txns confirmed\n+        # Mempool should be empty, all txns confirmed\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n         for txid in spends1_id+spends2_id:\n             tx = self.nodes[0].gettransaction(txid)"
      },
      {
        "sha": "7d2a22ba8aa3b97b7a77ba4365b9636e53899a3f",
        "filename": "test/functional/mempool_spend_coinbase.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_spend_coinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mempool_spend_coinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spend_coinbase.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -38,13 +38,13 @@ def run_test(self):\n \n         spend_101_id = self.nodes[0].sendrawtransaction(spends_raw[0])\n \n-        # coinbase at height 102 should be too immature to spend\n+        # Coinbase at height 102 should be too immature to spend\n         assert_raises_rpc_error(-26,\"bad-txns-premature-spend-of-coinbase\", self.nodes[0].sendrawtransaction, spends_raw[1])\n \n-        # mempool should have just spend_101:\n+        # Mempool should have just spend_101:\n         assert_equal(self.nodes[0].getrawmempool(), [ spend_101_id ])\n \n-        # mine a block, spend_101 should get confirmed\n+        # Mine a block, spend_101 should get confirmed\n         self.nodes[0].generate(1)\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n "
      },
      {
        "sha": "edd6e4d4a867bec383e227e1f47ded239b2b2cd0",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -65,7 +65,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert 'coinbasetxn' not in tmpl\n \n         coinbase_tx = create_coinbase(height=int(tmpl[\"height\"]) + 1)\n-        # sequence numbers must not be max for nLockTime to have effect\n+        # Sequence numbers must not be max for nLockTime to have effect\n         coinbase_tx.vin[0].nSequence = 2 ** 32 - 2\n         coinbase_tx.rehash()\n \n@@ -127,7 +127,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n \n         self.log.info(\"getblocktemplate: Test bad bits\")\n         bad_block = copy.deepcopy(block)\n-        bad_block.nBits = 469762303  # impossible in the real world\n+        bad_block.nBits = 469762303  # Impossible in the real world\n         assert_template(node, bad_block, 'bad-diffbits')\n \n         self.log.info(\"getblocktemplate: Test bad merkle root\")\n@@ -214,7 +214,7 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n         assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=b2x(CBlockHeader(bad_block2).serialize())))\n         node.submitheader(hexdata=b2x(CBlockHeader(block).serialize()))\n         node.submitheader(hexdata=b2x(CBlockHeader(bad_block_root).serialize()))\n-        assert_equal(node.submitblock(hexdata=b2x(block.serialize())), 'duplicate')  # valid\n+        assert_equal(node.submitblock(hexdata=b2x(block.serialize())), 'duplicate')  # Valid\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "a0d97610584b650ce0cfdce3bdfd51f8403d9952",
        "filename": "test/functional/mining_getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mining_getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mining_getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_getblocktemplate_longpoll.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -14,11 +14,11 @@\n class LongpollThread(threading.Thread):\n     def __init__(self, node):\n         threading.Thread.__init__(self)\n-        # query current longpollid\n+        # Query current longpollid\n         template = node.getblocktemplate()\n         self.longpollid = template['longpollid']\n-        # create a new connection to the node, we can't use the same\n-        # connection from two threads\n+        # Create a new connection to the node, we can't use the same\n+        # Connection from two threads\n         self.node = get_rpc_proxy(node.url, 1, timeout=600, coveragedir=node.coverage_dir)\n \n     def run(self):\n@@ -36,38 +36,38 @@ def run_test(self):\n         self.nodes[0].generate(10)\n         template = self.nodes[0].getblocktemplate()\n         longpollid = template['longpollid']\n-        # longpollid should not change between successive invocations if nothing else happens\n+        # Longpollid should not change between successive invocations if nothing else happens\n         template2 = self.nodes[0].getblocktemplate()\n         assert(template2['longpollid'] == longpollid)\n \n         # Test 1: test that the longpolling wait if we do nothing\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n-        # check that thread still lives\n-        thr.join(5)  # wait 5 seconds or until thread exits\n+        # Check that thread still lives\n+        thr.join(5)  # Wait 5 seconds or until thread exits\n         assert(thr.is_alive())\n \n         # Test 2: test that longpoll will terminate if another node generates a block\n-        self.nodes[1].generate(1)  # generate a block on another node\n-        # check that thread will exit now that new transaction entered mempool\n-        thr.join(5)  # wait 5 seconds or until thread exits\n+        self.nodes[1].generate(1)  # Generate a block on another node\n+        # Check that thread will exit now that new transaction entered mempool\n+        thr.join(5)  # Wait 5 seconds or until thread exits\n         assert(not thr.is_alive())\n \n         # Test 3: test that longpoll will terminate if we generate a block ourselves\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n-        self.nodes[0].generate(1)  # generate a block on another node\n-        thr.join(5)  # wait 5 seconds or until thread exits\n+        self.nodes[0].generate(1)  # Generate a block on another node\n+        thr.join(5)  # Wait 5 seconds or until thread exits\n         assert(not thr.is_alive())\n \n         # Test 4: test that introducing a new transaction into the mempool will terminate the longpoll\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n-        # generate a random transaction and submit it\n+        # Generate a random transaction and submit it\n         min_relay_fee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n-        # min_relay_fee is fee per 1000 bytes, which should be more than enough.\n+        # Min_relay_fee is fee per 1000 bytes, which should be more than enough.\n         (txid, txhex, fee) = random_transaction(self.nodes, Decimal(\"1.1\"), min_relay_fee, Decimal(\"0.001\"), 20)\n-        # after one minute, every 10 seconds the mempool is probed, so in 80 seconds it should have returned\n+        # After one minute, every 10 seconds the mempool is probed, so in 80 seconds it should have returned\n         thr.join(60 + 20)\n         assert(not thr.is_alive())\n "
      },
      {
        "sha": "9e3a60678cf986dc36eb7781802d9797715d4944",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -45,7 +45,7 @@ def run_test(self):\n \n         utxo_count = 90\n         utxos = create_confirmed_utxos(self.relayfee, self.nodes[0], utxo_count)\n-        base_fee = self.relayfee*100 # our transactions are smaller than 100kb\n+        base_fee = self.relayfee*100 # Our transactions are smaller than 100kb\n         txids = []\n \n         # Create 3 batches of transactions at 3 different fee rate levels\n@@ -67,8 +67,8 @@ def run_test(self):\n                 sizes[i] += mempool[j]['size']\n             assert(sizes[i] > MAX_BLOCK_BASE_SIZE) # Fail => raise utxo_count\n \n-        # add a fee delta to something in the cheapest bucket and make sure it gets mined\n-        # also check that a different entry in the cheapest bucket is NOT mined\n+        # Add a fee delta to something in the cheapest bucket and make sure it gets mined.\n+        # Also check that a different entry in the cheapest bucket is NOT mined\n         self.nodes[0].prioritisetransaction(txid=txids[0][0], fee_delta=int(3*base_fee*COIN))\n \n         self.nodes[0].generate(1)"
      },
      {
        "sha": "ee57e161728051d1c6943af1dcd17f44fc384e95",
        "filename": "test/functional/p2p_disconnect_ban.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_disconnect_ban.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -21,10 +21,10 @@ def run_test(self):\n         self.log.info(\"Test setban and listbanned RPCs\")\n \n         self.log.info(\"setban: successfully ban single IP address\")\n-        assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n+        assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # Node1 should have 2 connections to node0 at this point\n         self.nodes[1].setban(\"127.0.0.1\", \"add\")\n         wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n-        assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n+        assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # All nodes must be disconnected at this point\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n \n         self.log.info(\"clearbanned: successfully clear ban list\")\n@@ -38,7 +38,7 @@ def run_test(self):\n \n         self.log.info(\"setban: fail to ban an invalid subnet\")\n         assert_raises_rpc_error(-30, \"Error: Invalid IP/Subnet\", self.nodes[1].setban, \"127.0.0.1/42\", \"add\")\n-        assert_equal(len(self.nodes[1].listbanned()), 1)  # still only one banned ip because 127.0.0.1 is within the range of 127.0.0.0/24\n+        assert_equal(len(self.nodes[1].listbanned()), 1)  # Still only one banned ip because 127.0.0.1 is within the range of 127.0.0.0/24\n \n         self.log.info(\"setban remove: fail to unban a non-banned subnet\")\n         assert_raises_rpc_error(-30, \"Error: Unban failed\", self.nodes[1].setban, \"127.0.0.1\", \"remove\")\n@@ -56,8 +56,8 @@ def run_test(self):\n         # Set the mocktime so we can control when bans expire\n         old_time = int(time.time())\n         self.nodes[1].setmocktime(old_time)\n-        self.nodes[1].setban(\"192.168.0.1\", \"add\", 1)  # ban for 1 seconds\n-        self.nodes[1].setban(\"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/19\", \"add\", 1000)  # ban for 1000 seconds\n+        self.nodes[1].setban(\"192.168.0.1\", \"add\", 1)  # Ban for 1 seconds\n+        self.nodes[1].setban(\"2001:4d48:ac57:400:cacf:e9ff:fe1d:9c63/19\", \"add\", 1000)  # Ban for 1000 seconds\n         listBeforeShutdown = self.nodes[1].listbanned()\n         assert_equal(\"192.168.0.1/32\", listBeforeShutdown[2]['address'])\n         # Move time forward by 3 seconds so the third ban has expired\n@@ -93,7 +93,7 @@ def run_test(self):\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n \n         self.log.info(\"disconnectnode: successfully reconnect node\")\n-        connect_nodes_bi(self.nodes, 0, 1)  # reconnect the node\n+        connect_nodes_bi(self.nodes, 0, 1)  # Reconnect the node\n         assert_equal(len(self.nodes[0].getpeerinfo()), 2)\n         assert [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n "
      },
      {
        "sha": "c2ca8d3bddea8e51127b9e0b75c2f34a23e05e98",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -26,7 +26,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         # Add p2p connection to node0\n-        node = self.nodes[0]  # convenience reference to the node\n+        node = self.nodes[0]  # Convenience reference to the node\n         node.add_p2p_connection(P2PDataStore())\n \n         best_block = node.getblock(node.getbestblockhash())"
      },
      {
        "sha": "0cfbbf2c39fbc33a9fce3dedd9a9e807054084e6",
        "filename": "test/functional/p2p_invalid_locator.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_invalid_locator.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_invalid_locator.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_locator.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -16,7 +16,7 @@ def set_test_params(self):\n         self.setup_clean_chain = False\n \n     def run_test(self):\n-        node = self.nodes[0]  # convenience reference to the node\n+        node = self.nodes[0]  # Convenience reference to the node\n         node.generatetoaddress(1, node.get_deterministic_priv_key().address)  # Get node out of IBD\n \n         self.log.info('Test max locator size')"
      },
      {
        "sha": "39a0f49222035cae6bb2ae6d034b9bb784a2e2ca",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -42,7 +42,7 @@ def reconnect_p2p(self, **kwargs):\n         self.bootstrap_p2p(**kwargs)\n \n     def run_test(self):\n-        node = self.nodes[0]  # convenience reference to the node\n+        node = self.nodes[0]  # Convenience reference to the node\n \n         self.bootstrap_p2p()  # Add one p2p connection to the node\n "
      },
      {
        "sha": "1ccc91e41e68a9ab79b07726f3adf55fece84e69",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -57,7 +57,7 @@ def on_blocktxn(self, message): self.bad_message(message)\n # Node that never sends a version. We'll use this to send a bunch of messages\n # anyway, and eventually get disconnected.\n class CNodeNoVersionBan(CLazyNode):\n-    # send a bunch of veracks without sending a message. This should get us disconnected.\n+    # Send a bunch of veracks without sending a message. This should get us disconnected.\n     # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n     def on_open(self):\n         super().on_open()"
      },
      {
        "sha": "659611da72ed850feedf990e0c93c44c6b08a358",
        "filename": "test/functional/p2p_mempool.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_mempool.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -23,11 +23,11 @@ def run_test(self):\n         # Add a p2p connection\n         self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        #request mempool\n+        # Request mempool\n         self.nodes[0].p2p.send_message(msg_mempool())\n         self.nodes[0].p2p.wait_for_disconnect()\n \n-        #mininode must be disconnected at this point\n+        # Mininode must be disconnected at this point\n         assert_equal(len(self.nodes[0].getpeerinfo()), 0)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "b3ad839456085c3feb38aa128ef00ea5e54c039f",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -63,11 +63,11 @@ def run_test(self):\n         sync_blocks([self.nodes[0], self.nodes[1]])\n \n         self.log.info(\"Make sure we can max retrieve block at tip-288.\")\n-        node.send_getdata_for_block(blocks[1])  # last block in valid range\n+        node.send_getdata_for_block(blocks[1])  # Last block in valid range\n         node.wait_for_block(int(blocks[1], 16), timeout=3)\n \n         self.log.info(\"Requesting block at height 2 (tip-289) must fail (ignored).\")\n-        node.send_getdata_for_block(blocks[0])  # first block outside of the 288+2 limit\n+        node.send_getdata_for_block(blocks[0])  # First block outside of the 288+2 limit\n         node.wait_for_disconnect(5)\n \n         self.log.info(\"Check local address relay, do a fresh connection.\")\n@@ -82,32 +82,32 @@ def run_test(self):\n         self.nodes[0].disconnect_p2ps()\n         node1.wait_for_disconnect()\n \n-        # connect unsynced node 2 with pruned NODE_NETWORK_LIMITED peer\n-        # because node 2 is in IBD and node 0 is a NODE_NETWORK_LIMITED peer, sync must not be possible\n+        # Connect unsynced node 2 with pruned NODE_NETWORK_LIMITED peer.\n+        # Because node 2 is in IBD and node 0 is a NODE_NETWORK_LIMITED peer, sync must not be possible\n         connect_nodes_bi(self.nodes, 0, 2)\n         try:\n             sync_blocks([self.nodes[0], self.nodes[2]], timeout=5)\n         except:\n             pass\n-        # node2 must remain at height 0\n+        # Node2 must remain at height 0\n         assert_equal(self.nodes[2].getblockheader(self.nodes[2].getbestblockhash())['height'], 0)\n \n-        # now connect also to node 1 (non pruned)\n+        # Now connect also to node 1 (non pruned)\n         connect_nodes_bi(self.nodes, 1, 2)\n \n-        # sync must be possible\n+        # Sync must be possible\n         sync_blocks(self.nodes)\n \n-        # disconnect all peers\n+        # Disconnect all peers\n         self.disconnect_all()\n \n-        # mine 10 blocks on node 0 (pruned node)\n+        # Mine 10 blocks on node 0 (pruned node)\n         self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n \n-        # connect node1 (non pruned) with node0 (pruned) and check if the can sync\n+        # Connect node1 (non pruned) with node0 (pruned) and check if the can sync\n         connect_nodes_bi(self.nodes, 0, 1)\n \n-        # sync must be possible, node 1 is no longer in IBD and should therefore connect to node 0 (NODE_NETWORK_LIMITED)\n+        # Sync must be possible, node 1 is no longer in IBD and should therefore connect to node 0 (NODE_NETWORK_LIMITED)\n         sync_blocks([self.nodes[0], self.nodes[1]])\n \n if __name__ == '__main__':"
      },
      {
        "sha": "1ce8d1ca8576a0f6d91bb8c2ddebd42f69c8bc11",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -114,7 +114,7 @@ def get_virtual_size(witness_block):\n     Virtual size is base + witness/4.\"\"\"\n     base_size = len(witness_block.serialize(with_witness=False))\n     total_size = len(witness_block.serialize(with_witness=True))\n-    # the \"+3\" is so we round up\n+    # The \"+3\" is so we round up\n     vsize = int((3 * base_size + total_size + 3) / 4)\n     return vsize\n \n@@ -300,10 +300,10 @@ def test_non_witness_transaction(self):\n         block = self.build_next_block(version=1)\n         block.solve()\n         self.test_node.send_message(msg_block(block))\n-        self.test_node.sync_with_ping()  # make sure the block was processed\n+        self.test_node.sync_with_ping()  # Make sure the block was processed\n         txid = block.vtx[0].sha256\n \n-        self.nodes[0].generate(99)  # let the block mature\n+        self.nodes[0].generate(99)  # Let the block mature\n \n         # Create a transaction that spends the coinbase\n         tx = CTransaction()\n@@ -316,7 +316,7 @@ def test_non_witness_transaction(self):\n         assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n \n         self.test_node.send_message(msg_witness_tx(tx))\n-        self.test_node.sync_with_ping()  # make sure the tx was processed\n+        self.test_node.sync_with_ping()  # Make sure the tx was processed\n         assert(tx.hash in self.nodes[0].getrawmempool())\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n@@ -462,7 +462,7 @@ def test_v0_outputs_arent_spendable(self):\n         witness, and so can't be spent before segwit activation (the point at which\n         blocks are permitted to contain witnesses).\"\"\"\n \n-        # node2 doesn't need to be connected for this test.\n+        # Node2 doesn't need to be connected for this test.\n         # (If it's connected, node0 may propagate an invalid block to it over\n         # compact blocks and the nodes would have inconsistent tips.)\n         disconnect_nodes(self.nodes[0], 2)\n@@ -586,7 +586,7 @@ def test_getblocktemplate_before_lockin(self):\n                 script = get_witness_script(witness_root, 0)\n                 assert_equal(witness_commitment, bytes_to_hex_str(script))\n \n-        # undo mocktime\n+        # Undo mocktime\n         self.nodes[0].setmocktime(0)\n         self.nodes[2].setmocktime(0)\n \n@@ -743,7 +743,7 @@ def test_p2sh_witness(self):\n         p2wsh_pubkey = CScript([OP_0, witness_hash])\n         p2sh_witness_hash = hash160(p2wsh_pubkey)\n         script_pubkey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n-        script_sig = CScript([p2wsh_pubkey])  # a push of the redeem script\n+        script_sig = CScript([p2wsh_pubkey])  # A push of the redeem script\n \n         # Fund the P2SH output\n         tx = CTransaction()\n@@ -1018,7 +1018,7 @@ def test_submit_block(self):\n         # Try using a custom nonce and then don't supply it.\n         # This shouldn't possibly work.\n         add_witness_commitment(block, nonce=1)\n-        block.vtx[0].wit = CTxWitness()  # drop the nonce\n+        block.vtx[0].wit = CTxWitness()  # Drop the nonce\n         block.solve()\n         self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n         assert(self.nodes[0].getbestblockhash() != block.hash)\n@@ -1060,7 +1060,7 @@ def test_extra_witness_data(self):\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 2000, script_pubkey))\n-        tx.vout.append(CTxOut(1000, CScript([OP_TRUE])))  # non-witness output\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE])))  # Non-witness output\n         tx.wit.vtxinwit.append(CTxInWitness())\n         tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n         tx.rehash()\n@@ -1081,8 +1081,8 @@ def test_extra_witness_data(self):\n         # Now try extra witness/signature data on an input that DOES require a\n         # witness\n         tx2 = CTransaction()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))  # witness output\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\"))  # non-witness\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))  # Witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\"))  # Non-witness\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.extend([CTxInWitness(), CTxInWitness()])\n         tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program]\n@@ -1355,7 +1355,7 @@ def test_tx_relay_after_segwit_activation(self):\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n-        self.old_node.wait_for_inv([CInv(1, tx2.sha256)])  # wait until tx2 was inv'ed\n+        self.old_node.wait_for_inv([CInv(1, tx2.sha256)])  # Wait until tx2 was inv'ed\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n         self.old_node.wait_for_inv([CInv(1, tx3.sha256)])\n \n@@ -1386,7 +1386,7 @@ def test_segwit_versions(self):\n         Future segwit version transactions are non-standard, but valid in blocks.\n         Can run this before and after segwit activation.\"\"\"\n \n-        NUM_SEGWIT_VERSIONS = 17  # will test OP_0, OP1, ..., OP_16\n+        NUM_SEGWIT_VERSIONS = 17  # Will test OP_0, OP1, ..., OP_16\n         if len(self.utxo) < NUM_SEGWIT_VERSIONS:\n             tx = CTransaction()\n             tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n@@ -1435,7 +1435,7 @@ def test_segwit_versions(self):\n         # checked with fRequireStandard\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=False)\n-        temp_utxo.pop()  # last entry in temp_utxo was the output we just spent\n+        temp_utxo.pop()  # Last entry in temp_utxo was the output we just spent\n         temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n         # Spend everything in temp_utxo back to an OP_TRUE output.\n@@ -1644,7 +1644,7 @@ def test_signature_version_1(self):\n \n                 # Too-small input value\n                 sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n-                block.vtx.pop()  # remove last tx\n+                block.vtx.pop()  # Remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n@@ -1977,7 +1977,7 @@ def test_witness_sigops(self):\n         extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n \n         # We chose the number of checkmultisigs/checksigs to make this work:\n-        assert(extra_sigops_available < 100)  # steer clear of MAX_OPS_PER_SCRIPT\n+        assert(extra_sigops_available < 100)  # Steer clear of MAX_OPS_PER_SCRIPT\n \n         # This script, when spent with the first\n         # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,"
      },
      {
        "sha": "f8a4d04fc123b59813eb45e75962ed9f8b8fa1d7",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -165,7 +165,7 @@ def on_headers(self, message):\n             self.block_announced = True\n             for x in message.headers:\n                 x.calc_sha256()\n-                # append because headers may be announced over multiple messages.\n+                # Append because headers may be announced over multiple messages.\n                 self.recent_headers_announced.append(x.sha256)\n             self.last_blockhash_announced = message.headers[-1].sha256\n \n@@ -289,17 +289,17 @@ def test_nonnull_locators(self, test_node, inv_node):\n             test_node.check_last_inv_announcement(inv=[tip])\n             # Try a few different responses; none should affect next announcement\n             if i == 0:\n-                # first request the block\n+                # First request the block\n                 test_node.send_get_data([tip])\n                 test_node.wait_for_block(tip)\n             elif i == 1:\n-                # next try requesting header and block\n+                # Next try requesting header and block\n                 test_node.send_get_headers(locator=[old_tip], hashstop=tip)\n                 test_node.send_get_data([tip])\n                 test_node.wait_for_block(tip)\n-                test_node.clear_block_announcements()  # since we requested headers...\n+                test_node.clear_block_announcements()  # Since we requested headers...\n             elif i == 2:\n-                # this time announce own block via headers\n+                # This time announce own block via headers\n                 inv_node.clear_block_announcements()\n                 height = self.nodes[0].getblockcount()\n                 last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n@@ -309,7 +309,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 test_node.send_header_for_blocks([new_block])\n                 test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_message(msg_block(new_block))\n-                test_node.sync_with_ping()  # make sure this block is processed\n+                test_node.sync_with_ping()  # Make sure this block is processed\n                 wait_until(lambda: inv_node.block_announced, timeout=60, lock=mininode_lock)\n                 inv_node.clear_block_announcements()\n                 test_node.clear_block_announcements()\n@@ -467,7 +467,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n         test_node.last_message.pop(\"getdata\", None)\n         test_node.send_header_for_blocks(blocks)\n         test_node.sync_with_ping()\n-        # should not have received any getdata messages\n+        # Should not have received any getdata messages\n         with mininode_lock:\n             assert \"getdata\" not in test_node.last_message\n "
      },
      {
        "sha": "4e633ebfe38a222f33dd2c680ad06bcda51505d9",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -87,7 +87,7 @@ def run_test(self):\n \n         # 2. Send one block that builds on each tip.\n         # This should be accepted by node0\n-        blocks_h2 = []  # the height 2 blocks on each node's chain\n+        blocks_h2 = []  # The height 2 blocks on each node's chain\n         block_time = int(time.time()) + 1\n         for i in range(2):\n             blocks_h2.append(create_block(tips[i], create_coinbase(2), block_time))"
      },
      {
        "sha": "3cf6e131bb59cb25a1ac1f99d813b5a5f0fe7d62",
        "filename": "test/functional/rpc_bind.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_bind.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_bind.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_bind.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -51,13 +51,13 @@ def run_allowip_test(self, allow_ips, rpchost, rpcport):\n         base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n         self.nodes[0].rpchost = None\n         self.start_nodes([base_args])\n-        # connect to node through non-loopback interface\n+        # Connect to node through non-loopback interface\n         node = get_rpc_proxy(rpc_url(self.nodes[0].datadir, 0, \"%s:%d\" % (rpchost, rpcport)), 0, coveragedir=self.options.coveragedir)\n         node.getnetworkinfo()\n         self.stop_nodes()\n \n     def run_test(self):\n-        # due to OS-specific network stats queries, this test works only on Linux\n+        # Due to OS-specific network stats queries, this test works only on Linux\n         if sum([self.options.run_ipv4, self.options.run_ipv6, self.options.run_nonloopback]) > 1:\n             raise AssertionError(\"Only one of --ipv4, --ipv6 and --nonloopback can be set\")\n \n@@ -88,33 +88,33 @@ def run_test(self):\n \n     def _run_loopback_tests(self):\n         if self.options.run_ipv4:\n-            # check only IPv4 localhost (explicit)\n+            # Check only IPv4 localhost (explicit)\n             self.run_bind_test(['127.0.0.1'], '127.0.0.1', ['127.0.0.1'],\n                 [('127.0.0.1', self.defaultport)])\n-            # check only IPv4 localhost (explicit) with alternative port\n+            # Check only IPv4 localhost (explicit) with alternative port\n             self.run_bind_test(['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171'],\n                 [('127.0.0.1', 32171)])\n-            # check only IPv4 localhost (explicit) with multiple alternative ports on same host\n+            # Check only IPv4 localhost (explicit) with multiple alternative ports on same host\n             self.run_bind_test(['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171', '127.0.0.1:32172'],\n                 [('127.0.0.1', 32171), ('127.0.0.1', 32172)])\n         else:\n-            # check default without rpcallowip (IPv4 and IPv6 localhost)\n+            # Check default without rpcallowip (IPv4 and IPv6 localhost)\n             self.run_bind_test(None, '127.0.0.1', [],\n                 [('127.0.0.1', self.defaultport), ('::1', self.defaultport)])\n-            # check default with rpcallowip (IPv6 any)\n+            # Check default with rpcallowip (IPv6 any)\n             self.run_bind_test(['127.0.0.1'], '127.0.0.1', [],\n                 [('::0', self.defaultport)])\n-            # check only IPv6 localhost (explicit)\n+            # Check only IPv6 localhost (explicit)\n             self.run_bind_test(['[::1]'], '[::1]', ['[::1]'],\n                 [('::1', self.defaultport)])\n-            # check both IPv4 and IPv6 localhost (explicit)\n+            # Check both IPv4 and IPv6 localhost (explicit)\n             self.run_bind_test(['127.0.0.1'], '127.0.0.1', ['127.0.0.1', '[::1]'],\n                 [('127.0.0.1', self.defaultport), ('::1', self.defaultport)])\n \n     def _run_nonloopback_tests(self):\n         self.log.info(\"Using interface %s for testing\" % self.non_loopback_ip)\n \n-        # check only non-loopback interface\n+        # Check only non-loopback interface\n         self.run_bind_test([self.non_loopback_ip], self.non_loopback_ip, [self.non_loopback_ip],\n             [(self.non_loopback_ip, self.defaultport)])\n "
      },
      {
        "sha": "285208829a74b90a47f9adb96e6fc27fb0641d37",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -82,7 +82,7 @@ def _test_getblockchaininfo(self):\n         ]\n         res = self.nodes[0].getblockchaininfo()\n \n-        # result should have these additional pruning keys if manual pruning is enabled\n+        # Result should have these additional pruning keys if manual pruning is enabled\n         assert_equal(sorted(res.keys()), sorted(['pruneheight', 'automatic_pruning'] + keys))\n \n         # size_on_disk should be > 0\n@@ -91,21 +91,21 @@ def _test_getblockchaininfo(self):\n         # pruneheight should be greater or equal to 0\n         assert_greater_than_or_equal(res['pruneheight'], 0)\n \n-        # check other pruning fields given that prune=1\n+        # Check other pruning fields given that prune=1\n         assert res['pruned']\n         assert not res['automatic_pruning']\n \n         self.restart_node(0, ['-stopatheight=207'])\n         res = self.nodes[0].getblockchaininfo()\n-        # should have exact keys\n+        # Should have exact keys\n         assert_equal(sorted(res.keys()), keys)\n \n         self.restart_node(0, ['-stopatheight=207', '-prune=550'])\n         res = self.nodes[0].getblockchaininfo()\n-        # result should have these additional pruning keys if prune=550\n+        # Result should have these additional pruning keys if prune=550\n         assert_equal(sorted(res.keys()), sorted(['pruneheight', 'automatic_pruning', 'prune_target_size'] + keys))\n \n-        # check related fields\n+        # Check related fields\n         assert res['pruned']\n         assert_equal(res['pruneheight'], 0)\n         assert res['automatic_pruning']\n@@ -136,7 +136,7 @@ def _test_getchaintxstats(self):\n         chaintxstats = self.nodes[0].getchaintxstats(1)\n         # 200 txs plus genesis tx\n         assert_equal(chaintxstats['txcount'], 201)\n-        # tx rate should be 1 per 10 minutes, or 1/600\n+        # Tx rate should be 1 per 10 minutes, or 1/600\n         # we have to round because of binary math\n         assert_equal(round(chaintxstats['txrate'] * 600, 10), Decimal(1))\n "
      },
      {
        "sha": "f2959f26bf692d96abf2446375a349b26b713c0c",
        "filename": "test/functional/rpc_createmultisig.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_createmultisig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_createmultisig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_createmultisig.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -61,9 +61,9 @@ def do_multisig(self):\n         madd = msig[\"address\"]\n         mredeem = msig[\"redeemScript\"]\n         if self.output_type == 'bech32':\n-            assert madd[0:4] == \"bcrt\"  # actually a bech32 address\n+            assert madd[0:4] == \"bcrt\"  # Actually a bech32 address\n \n-        # compare against addmultisigaddress\n+        # Compare against addmultisigaddress\n         msigw = node1.addmultisigaddress(self.nsigs, self.pub, None, self.output_type)\n         maddw = msigw[\"address\"]\n         mredeemw = msigw[\"redeemScript\"]"
      },
      {
        "sha": "c59ac04762b0d1adff77bc10bb5e9b95ad265c10",
        "filename": "test/functional/rpc_decodescript.py",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_decodescript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_decodescript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_decodescript.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -21,7 +21,7 @@ def decodescript_script_sig(self):\n         public_key = '03b0da749730dc9b4b1f4a14d6902877a92541f5368778853d9c4a0cb7802dcfb2'\n         push_public_key = '21' + public_key\n \n-        # below are test cases for all of the standard transaction types\n+        # Below are test cases for all of the standard transaction types\n \n         # 1) P2PK scriptSig\n         # the scriptSig of a public key scriptPubKey simply pushes a signature onto the stack\n@@ -57,7 +57,7 @@ def decodescript_script_pub_key(self):\n         push_uncompressed_public_key = '41' + uncompressed_public_key\n         p2wsh_p2pk_script_hash = 'd8590cf8ea0674cf3d49fd7ca249b85ef7485dea62c138468bddeb20cd6519f7'\n \n-        # below are test cases for all of the standard transaction types\n+        # Below are test cases for all of the standard transaction types\n \n         # 1) P2PK scriptPubKey\n         # <pubkey> OP_CHECKSIG\n@@ -80,7 +80,7 @@ def decodescript_script_pub_key(self):\n         multisig_script = '52' + push_public_key + push_public_key + push_public_key + '53ae'\n         rpc_result = self.nodes[0].decodescript(multisig_script)\n         assert_equal('2 ' + public_key + ' ' + public_key + ' ' + public_key +  ' 3 OP_CHECKMULTISIG', rpc_result['asm'])\n-        # multisig in P2WSH\n+        # Multisig in P2WSH\n         multisig_script_hash = bytes_to_hex_str(sha256(hex_str_to_bytes(multisig_script)))\n         assert_equal('0 ' + multisig_script_hash, rpc_result['segwit']['asm'])\n \n@@ -126,7 +126,7 @@ def decodescript_script_pub_key(self):\n         # <pubkey> OP_CHECKSIG\n         rpc_result = self.nodes[0].decodescript(push_uncompressed_public_key + 'ac')\n         assert_equal(uncompressed_public_key + ' OP_CHECKSIG', rpc_result['asm'])\n-        # uncompressed pubkeys are invalid for checksigs in segwit scripts.\n+        # Uncompressed pubkeys are invalid for checksigs in segwit scripts.\n         # decodescript should not return a P2WPKH equivalent.\n         assert 'segwit' not in rpc_result\n \n@@ -137,16 +137,16 @@ def decodescript_script_pub_key(self):\n         # with an uncompressed pubkey in them.\n         rpc_result = self.nodes[0].decodescript('52' + push_public_key + push_uncompressed_public_key +'52ae')\n         assert_equal('2 ' + public_key + ' ' + uncompressed_public_key + ' 2 OP_CHECKMULTISIG', rpc_result['asm'])\n-        # uncompressed pubkeys are invalid for checksigs in segwit scripts.\n+        # Uncompressed pubkeys are invalid for checksigs in segwit scripts.\n         # decodescript should not return a P2WPKH equivalent.\n         assert 'segwit' not in rpc_result\n \n         # 9) P2WPKH scriptpubkey\n         # 0 <PubKeyHash>\n         rpc_result = self.nodes[0].decodescript('00' + push_public_key_hash)\n         assert_equal('0 ' + public_key_hash, rpc_result['asm'])\n-        # segwit scripts do not work nested into each other.\n-        # a nested segwit script should not be returned in the results.\n+        # Segwit scripts do not work nested into each other.\n+        # A nested segwit script should not be returned in the results.\n         assert 'segwit' not in rpc_result\n \n         # 10) P2WSH scriptpubkey\n@@ -155,8 +155,8 @@ def decodescript_script_pub_key(self):\n         # for the purpose of this test.\n         rpc_result = self.nodes[0].decodescript('0020' + p2wsh_p2pk_script_hash)\n         assert_equal('0 ' + p2wsh_p2pk_script_hash, rpc_result['asm'])\n-        # segwit scripts do not work nested into each other.\n-        # a nested segwit script should not be returned in the results.\n+        # Segwit scripts do not work nested into each other.\n+        # A nested segwit script should not be returned in the results.\n         assert 'segwit' not in rpc_result\n \n     def decoderawtransaction_asm_sighashtype(self):\n@@ -165,14 +165,14 @@ def decoderawtransaction_asm_sighashtype(self):\n         This test is in with the \"decodescript\" tests because they are testing the same \"asm\" script decodes.\n         \"\"\"\n \n-        # this test case uses a random plain vanilla mainnet transaction with a single P2PKH input and output\n+        # This test case uses a random plain vanilla mainnet transaction with a single P2PKH input and output\n         tx = '0100000001696a20784a2c70143f634e95227dbdfdf0ecd51647052e70854512235f5986ca010000008a47304402207174775824bec6c2700023309a168231ec80b82c6069282f5133e6f11cbb04460220570edc55c7c5da2ca687ebd0372d3546ebc3f810516a002350cac72dfe192dfb014104d3f898e6487787910a690410b7a917ef198905c27fb9d3b0a42da12aceae0544fc7088d239d9a48f2828a15a09e84043001f27cc80d162cb95404e1210161536ffffffff0100e1f505000000001976a914eb6c6e0cdb2d256a32d97b8df1fc75d1920d9bca88ac00000000'\n         rpc_result = self.nodes[0].decoderawtransaction(tx)\n         assert_equal('304402207174775824bec6c2700023309a168231ec80b82c6069282f5133e6f11cbb04460220570edc55c7c5da2ca687ebd0372d3546ebc3f810516a002350cac72dfe192dfb[ALL] 04d3f898e6487787910a690410b7a917ef198905c27fb9d3b0a42da12aceae0544fc7088d239d9a48f2828a15a09e84043001f27cc80d162cb95404e1210161536', rpc_result['vin'][0]['scriptSig']['asm'])\n \n-        # this test case uses a mainnet transaction that has a P2SH input and both P2PKH and P2SH outputs.\n-        # it's from James D'Angelo's awesome introductory videos about multisig: https://www.youtube.com/watch?v=zIbUSaZBJgU and https://www.youtube.com/watch?v=OSA1pwlaypc\n-        # verify that we have not altered scriptPubKey decoding.\n+        # This test case uses a mainnet transaction that has a P2SH input and both P2PKH and P2SH outputs.\n+        # It's from James D'Angelo's awesome introductory videos about multisig: https://www.youtube.com/watch?v=zIbUSaZBJgU and https://www.youtube.com/watch?v=OSA1pwlaypc\n+        # Verify that we have not altered scriptPubKey decoding.\n         tx = '01000000018d1f5635abd06e2c7e2ddf58dc85b3de111e4ad6e0ab51bb0dcf5e84126d927300000000fdfe0000483045022100ae3b4e589dfc9d48cb82d41008dc5fa6a86f94d5c54f9935531924602730ab8002202f88cf464414c4ed9fa11b773c5ee944f66e9b05cc1e51d97abc22ce098937ea01483045022100b44883be035600e9328a01b66c7d8439b74db64187e76b99a68f7893b701d5380220225bf286493e4c4adcf928c40f785422572eb232f84a0b83b0dea823c3a19c75014c695221020743d44be989540d27b1b4bbbcfd17721c337cb6bc9af20eb8a32520b393532f2102c0120a1dda9e51a938d39ddd9fe0ebc45ea97e1d27a7cbd671d5431416d3dd87210213820eb3d5f509d7438c9eeecb4157b2f595105e7cd564b3cdbb9ead3da41eed53aeffffffff02611e0000000000001976a914dc863734a218bfe83ef770ee9d41a27f824a6e5688acee2a02000000000017a9142a5edea39971049a540474c6a99edf0aa4074c588700000000'\n         rpc_result = self.nodes[0].decoderawtransaction(tx)\n         assert_equal('8e3730608c3b0bb5df54f09076e196bc292a8e39a78e73b44b6ba08c78f5cbb0', rpc_result['txid'])\n@@ -182,18 +182,18 @@ def decoderawtransaction_asm_sighashtype(self):\n         txSave = CTransaction()\n         txSave.deserialize(BytesIO(hex_str_to_bytes(tx)))\n \n-        # make sure that a specifically crafted op_return value will not pass all the IsDERSignature checks and then get decoded as a sighash type\n+        # Make sure that a specifically crafted op_return value will not pass all the IsDERSignature checks and then get decoded as a sighash type\n         tx = '01000000015ded05872fdbda629c7d3d02b194763ce3b9b1535ea884e3c8e765d42e316724020000006b48304502204c10d4064885c42638cbff3585915b322de33762598321145ba033fc796971e2022100bb153ad3baa8b757e30a2175bd32852d2e1cb9080f84d7e32fcdfd667934ef1b012103163c0ff73511ea1743fb5b98384a2ff09dd06949488028fd819f4d83f56264efffffffff0200000000000000000b6a0930060201000201000180380100000000001976a9141cabd296e753837c086da7a45a6c2fe0d49d7b7b88ac00000000'\n         rpc_result = self.nodes[0].decoderawtransaction(tx)\n         assert_equal('OP_RETURN 300602010002010001', rpc_result['vout'][0]['scriptPubKey']['asm'])\n \n-        # verify that we have not altered scriptPubKey processing even of a specially crafted P2PKH pubkeyhash and P2SH redeem script hash that is made to pass the der signature checks\n+        # Verify that we have not altered scriptPubKey processing even of a specially crafted P2PKH pubkeyhash and P2SH redeem script hash that is made to pass the der signature checks\n         tx = '01000000018d1f5635abd06e2c7e2ddf58dc85b3de111e4ad6e0ab51bb0dcf5e84126d927300000000fdfe0000483045022100ae3b4e589dfc9d48cb82d41008dc5fa6a86f94d5c54f9935531924602730ab8002202f88cf464414c4ed9fa11b773c5ee944f66e9b05cc1e51d97abc22ce098937ea01483045022100b44883be035600e9328a01b66c7d8439b74db64187e76b99a68f7893b701d5380220225bf286493e4c4adcf928c40f785422572eb232f84a0b83b0dea823c3a19c75014c695221020743d44be989540d27b1b4bbbcfd17721c337cb6bc9af20eb8a32520b393532f2102c0120a1dda9e51a938d39ddd9fe0ebc45ea97e1d27a7cbd671d5431416d3dd87210213820eb3d5f509d7438c9eeecb4157b2f595105e7cd564b3cdbb9ead3da41eed53aeffffffff02611e0000000000001976a914301102070101010101010102060101010101010188acee2a02000000000017a91430110207010101010101010206010101010101018700000000'\n         rpc_result = self.nodes[0].decoderawtransaction(tx)\n         assert_equal('OP_DUP OP_HASH160 3011020701010101010101020601010101010101 OP_EQUALVERIFY OP_CHECKSIG', rpc_result['vout'][0]['scriptPubKey']['asm'])\n         assert_equal('OP_HASH160 3011020701010101010101020601010101010101 OP_EQUAL', rpc_result['vout'][1]['scriptPubKey']['asm'])\n \n-        # some more full transaction tests of varying specific scriptSigs. used instead of\n+        # Some more full transaction tests of varying specific scriptSigs. Used instead of\n         # tests in decodescript_script_sig because the decodescript RPC is specifically\n         # for working on scriptPubKeys (argh!).\n         push_signature = bytes_to_hex_str(txSave.vin[0].scriptSig)[2:(0x48*2+4)]\n@@ -209,7 +209,7 @@ def decoderawtransaction_asm_sighashtype(self):\n         rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n         assert_equal(signature_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n-        # make sure that the sighash decodes come out correctly for a more complex / lesser used case.\n+        # Make sure that the sighash decodes come out correctly for a more complex / lesser used case.\n         txSave.vin[0].scriptSig = hex_str_to_bytes(push_signature_2)\n         rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n         assert_equal(signature_2_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n@@ -220,7 +220,7 @@ def decoderawtransaction_asm_sighashtype(self):\n         assert_equal('0 ' + signature_sighash_decoded + ' ' + signature_2_sighash_decoded, rpc_result['vin'][0]['scriptSig']['asm'])\n \n         # 3) test a scriptSig that contains more than push operations.\n-        # in fact, it contains an OP_RETURN with data specially crafted to cause improper decode if the code does not catch it.\n+        # In fact, it contains an OP_RETURN with data specially crafted to cause improper decode if the code does not catch it.\n         txSave.vin[0].scriptSig = hex_str_to_bytes('6a143011020701010101010101020601010101010101')\n         rpc_result = self.nodes[0].decoderawtransaction(bytes_to_hex_str(txSave.serialize()))\n         assert_equal('OP_RETURN 3011020701010101010101020601010101010101', rpc_result['vin'][0]['scriptSig']['asm'])"
      },
      {
        "sha": "8e8de61e78404dd9d59aab95750ffdd5c4ecf8aa",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 61,
        "deletions": 61,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -47,7 +47,7 @@ def run_test(self):\n         for node in self.nodes:\n             node.settxfee(min_relay_tx_fee)\n \n-        # if the fee's positive delta is higher than this value tests will fail,\n+        # If the fee's positive delta is higher than this value tests will fail,\n         # neg. delta always fail the tests.\n         # The size of the signature of every input may be at most 2 bytes larger\n         # than a minimum sized signature.\n@@ -60,7 +60,7 @@ def run_test(self):\n         self.nodes[0].generate(121)\n         self.sync_all()\n \n-        # ensure that setting changePosition in fundraw with an exact match is handled properly\n+        # Ensure that setting changePosition in fundraw with an exact match is handled properly\n         rawmatch = self.nodes[2].createrawtransaction([], {self.nodes[2].getnewaddress():50})\n         rawmatch = self.nodes[2].fundrawtransaction(rawmatch, {\"changePosition\":1, \"subtractFeeFromOutputs\":[0]})\n         assert_equal(rawmatch[\"changepos\"], -1)\n@@ -85,7 +85,7 @@ def run_test(self):\n         self.sync_all()\n \n         ###############\n-        # simple test #\n+        # Simple test #\n         ###############\n         inputs  = [ ]\n         outputs = { self.nodes[0].getnewaddress() : 1.0 }\n@@ -97,7 +97,7 @@ def run_test(self):\n         assert(len(dec_tx['vin']) > 0) #test that we have enough inputs\n \n         ##############################\n-        # simple test with two coins #\n+        # Simple test with two coins #\n         ##############################\n         inputs  = [ ]\n         outputs = { self.nodes[0].getnewaddress() : 2.2 }\n@@ -110,7 +110,7 @@ def run_test(self):\n         assert(len(dec_tx['vin']) > 0) #test if we have enough inputs\n \n         ##############################\n-        # simple test with two coins #\n+        # Simple test with two coins #\n         ##############################\n         inputs  = [ ]\n         outputs = { self.nodes[0].getnewaddress() : 2.6 }\n@@ -125,7 +125,7 @@ def run_test(self):\n \n \n         ################################\n-        # simple test with two outputs #\n+        # Simple test with two outputs #\n         ################################\n         inputs  = [ ]\n         outputs = { self.nodes[0].getnewaddress() : 2.6, self.nodes[1].getnewaddress() : 2.5 }\n@@ -144,7 +144,7 @@ def run_test(self):\n \n \n         #########################################################################\n-        # test a fundrawtransaction with a VIN greater than the required amount #\n+        # Test a fundrawtransaction with a VIN greater than the required amount #\n         #########################################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 5)\n \n@@ -165,7 +165,7 @@ def run_test(self):\n \n \n         #####################################################################\n-        # test a fundrawtransaction with which will not get a change output #\n+        # Test a fundrawtransaction with which will not get a change output #\n         #####################################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 5)\n \n@@ -187,7 +187,7 @@ def run_test(self):\n \n \n         ####################################################\n-        # test a fundrawtransaction with an invalid option #\n+        # Test a fundrawtransaction with an invalid option #\n         ####################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 5)\n \n@@ -203,7 +203,7 @@ def run_test(self):\n         assert_raises_rpc_error(-3, \"Unexpected key reserveChangeKey\", lambda: self.nodes[2].fundrawtransaction(hexstring=rawtx, options={'reserveChangeKey': True}))\n \n         ############################################################\n-        # test a fundrawtransaction with an invalid change address #\n+        # Test a fundrawtransaction with an invalid change address #\n         ############################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 5)\n \n@@ -216,7 +216,7 @@ def run_test(self):\n         assert_raises_rpc_error(-5, \"changeAddress must be a valid bitcoin address\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':'foobar'})\n \n         ############################################################\n-        # test a fundrawtransaction with a provided change address #\n+        # Test a fundrawtransaction with a provided change address #\n         ############################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 5)\n \n@@ -234,7 +234,7 @@ def run_test(self):\n         assert_equal(change, out['scriptPubKey']['addresses'][0])\n \n         #########################################################\n-        # test a fundrawtransaction with a provided change type #\n+        # Test a fundrawtransaction with a provided change type #\n         #########################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 5)\n \n@@ -248,7 +248,7 @@ def run_test(self):\n         assert_equal('witness_v0_keyhash', dec_tx['vout'][rawtx['changepos']]['scriptPubKey']['type'])\n \n         #########################################################################\n-        # test a fundrawtransaction with a VIN smaller than the required amount #\n+        # Test a fundrawtransaction with a VIN smaller than the required amount #\n         #########################################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 1)\n \n@@ -283,7 +283,7 @@ def run_test(self):\n \n \n         ###########################################\n-        # test a fundrawtransaction with two VINs #\n+        # Test a fundrawtransaction with two VINs #\n         ###########################################\n         utx = get_unspent(self.nodes[2].listunspent(), 1)\n         utx2 = get_unspent(self.nodes[2].listunspent(), 5)\n@@ -316,7 +316,7 @@ def run_test(self):\n         assert_equal(matchingIns, 2) #we now must see two vins identical to vins given as params\n \n         #########################################################\n-        # test a fundrawtransaction with two VINs and two vOUTs #\n+        # Test a fundrawtransaction with two VINs and two vOUTs #\n         #########################################################\n         utx = get_unspent(self.nodes[2].listunspent(), 1)\n         utx2 = get_unspent(self.nodes[2].listunspent(), 5)\n@@ -341,7 +341,7 @@ def run_test(self):\n         assert_equal(len(dec_tx['vout']), 3)\n \n         ##############################################\n-        # test a fundrawtransaction with invalid vin #\n+        # Test a fundrawtransaction with invalid vin #\n         ##############################################\n         inputs  = [ {'txid' : \"1c7f966dab21119bac53213a2bc7532bff1fa844c124fd750a7d0b1332440bd1\", 'vout' : 0} ] #invalid vin!\n         outputs = { self.nodes[0].getnewaddress() : 1.0}\n@@ -351,41 +351,41 @@ def run_test(self):\n         assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[2].fundrawtransaction, rawtx)\n \n         ############################################################\n-        #compare fee of a standard pubkeyhash transaction\n+        # Compare fee of a standard pubkeyhash transaction\n         inputs = []\n         outputs = {self.nodes[1].getnewaddress():1.1}\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n \n-        #create same transaction over sendtoaddress\n+        # Create same transaction over sendtoaddress\n         txId = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1.1)\n         signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n \n-        #compare fee\n+        # Compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n         ############################################################\n-        #compare fee of a standard pubkeyhash transaction with multiple outputs\n+        # Compare fee of a standard pubkeyhash transaction with multiple outputs\n         inputs = []\n         outputs = {self.nodes[1].getnewaddress():1.1,self.nodes[1].getnewaddress():1.2,self.nodes[1].getnewaddress():0.1,self.nodes[1].getnewaddress():1.3,self.nodes[1].getnewaddress():0.2,self.nodes[1].getnewaddress():0.3}\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n-        #create same transaction over sendtoaddress\n+        # Create same transaction over sendtoaddress\n         txId = self.nodes[0].sendmany(\"\", outputs)\n         signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n \n-        #compare fee\n+        # Compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n \n         ############################################################\n-        #compare fee of a 2of2 multisig p2sh transaction\n+        # Compare fee of a 2of2 multisig p2sh transaction\n \n-        # create 2of2 addr\n+        # Create 2of2 addr\n         addr1 = self.nodes[1].getnewaddress()\n         addr2 = self.nodes[1].getnewaddress()\n \n@@ -399,20 +399,20 @@ def run_test(self):\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n \n-        #create same transaction over sendtoaddress\n+        # Create same transaction over sendtoaddress\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.1)\n         signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n \n-        #compare fee\n+        # Compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n \n         ############################################################\n-        #compare fee of a standard pubkeyhash transaction\n+        # Compare fee of a standard pubkeyhash transaction\n \n-        # create 4of5 addr\n+        # Create 4of5 addr\n         addr1 = self.nodes[1].getnewaddress()\n         addr2 = self.nodes[1].getnewaddress()\n         addr3 = self.nodes[1].getnewaddress()\n@@ -432,20 +432,20 @@ def run_test(self):\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n \n-        #create same transaction over sendtoaddress\n+        # Create same transaction over sendtoaddress\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.1)\n         signedFee = self.nodes[0].getrawmempool(True)[txId]['fee']\n \n-        #compare fee\n+        # Compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance)\n         ############################################################\n \n \n         ############################################################\n-        # spend a 2of2 multisig transaction over fundraw\n+        # Spend a 2of2 multisig transaction over fundraw\n \n-        # create 2of2 addr\n+        # Create 2of2 addr\n         addr1 = self.nodes[2].getnewaddress()\n         addr2 = self.nodes[2].getnewaddress()\n \n@@ -455,7 +455,7 @@ def run_test(self):\n         mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n \n \n-        # send 1.2 BTC to msig addr\n+        # Send 1.2 BTC to msig addr\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n         self.sync_all()\n         self.nodes[1].generate(1)\n@@ -473,11 +473,11 @@ def run_test(self):\n         self.nodes[1].generate(1)\n         self.sync_all()\n \n-        # make sure funds are received at node1\n+        # Make sure funds are received at node1\n         assert_equal(oldBalance+Decimal('1.10000000'), self.nodes[1].getbalance())\n \n         ############################################################\n-        # locked wallet test\n+        # Locked wallet test\n         self.nodes[1].encryptwallet(\"test\")\n         self.stop_nodes()\n \n@@ -496,17 +496,17 @@ def run_test(self):\n         self.nodes[0].lockunspent(False, [{\"txid\": watchonly_txid, \"vout\": watchonly_vout}])\n         self.sync_all()\n \n-        # drain the keypool\n+        # Drain the keypool\n         self.nodes[1].getnewaddress()\n         self.nodes[1].getrawchangeaddress()\n         inputs = []\n         outputs = {self.nodes[0].getnewaddress():1.1}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n-        # fund a transaction that requires a new key for the change output\n+        # Fund a transaction that requires a new key for the change output\n         # creating the key must be impossible because the wallet is locked\n         assert_raises_rpc_error(-4, \"Keypool ran out, please call keypoolrefill first\", self.nodes[1].fundrawtransaction, rawtx)\n \n-        #refill the keypool\n+        # Refill the keypool\n         self.nodes[1].walletpassphrase(\"test\", 100)\n         self.nodes[1].keypoolrefill(8) #need to refill the keypool to get an internal change address\n         self.nodes[1].walletlock()\n@@ -520,22 +520,22 @@ def run_test(self):\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n \n-        #now we need to unlock\n+        # Now we need to unlock\n         self.nodes[1].walletpassphrase(\"test\", 600)\n         signedTx = self.nodes[1].signrawtransactionwithwallet(fundedTx['hex'])\n         txId = self.nodes[1].sendrawtransaction(signedTx['hex'])\n         self.nodes[1].generate(1)\n         self.sync_all()\n \n-        # make sure funds are received at node1\n+        # Make sure funds are received at node1\n         assert_equal(oldBalance+Decimal('51.10000000'), self.nodes[0].getbalance())\n \n \n         ###############################################\n-        # multiple (~19) inputs tx test | Compare fee #\n+        # Multiple (~19) inputs tx test | Compare fee #\n         ###############################################\n \n-        #empty node1, send some small coins from node0 to node1\n+        # Empty node1, send some small coins from node0 to node1\n         self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n         self.sync_all()\n         self.nodes[0].generate(1)\n@@ -546,26 +546,26 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        #fund a tx with ~20 small inputs\n+        # Fund a tx with ~20 small inputs\n         inputs = []\n         outputs = {self.nodes[0].getnewaddress():0.15,self.nodes[0].getnewaddress():0.04}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n \n-        #create same transaction over sendtoaddress\n+        # Create same transaction over sendtoaddress\n         txId = self.nodes[1].sendmany(\"\", outputs)\n         signedFee = self.nodes[1].getrawmempool(True)[txId]['fee']\n \n-        #compare fee\n+        # Compare fee\n         feeDelta = Decimal(fundedTx['fee']) - Decimal(signedFee)\n         assert(feeDelta >= 0 and feeDelta <= feeTolerance*19) #~19 inputs\n \n \n         #############################################\n-        # multiple (~19) inputs tx test | sign/send #\n+        # Multiple (~19) inputs tx test | sign/send #\n         #############################################\n \n-        #again, empty node1, send some small coins from node0 to node1\n+        # Again, empty node1, send some small coins from node0 to node1\n         self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n         self.sync_all()\n         self.nodes[0].generate(1)\n@@ -576,7 +576,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        #fund a tx with ~20 small inputs\n+        # Fund a tx with ~20 small inputs\n         oldBalance = self.nodes[0].getbalance()\n \n         inputs = []\n@@ -591,7 +591,7 @@ def run_test(self):\n         assert_equal(oldBalance+Decimal('50.19000000'), self.nodes[0].getbalance()) #0.19+block reward\n \n         #####################################################\n-        # test fundrawtransaction with OP_RETURN and no vin #\n+        # Test fundrawtransaction with OP_RETURN and no vin #\n         #####################################################\n \n         rawtx   = \"0100000000010000000000000000066a047465737400000000\"\n@@ -608,7 +608,7 @@ def run_test(self):\n \n \n         ##################################################\n-        # test a fundrawtransaction using only watchonly #\n+        # Test a fundrawtransaction using only watchonly #\n         ##################################################\n \n         inputs = []\n@@ -624,7 +624,7 @@ def run_test(self):\n         assert_greater_than(result[\"changepos\"], -1)\n \n         ###############################################################\n-        # test fundrawtransaction using the entirety of watched funds #\n+        # Test fundrawtransaction using the entirety of watched funds #\n         ###############################################################\n \n         inputs = []\n@@ -692,9 +692,9 @@ def run_test(self):\n         outputs = {self.nodes[2].getnewaddress(): 1}\n         rawtx = self.nodes[3].createrawtransaction(inputs, outputs)\n \n-        result = [self.nodes[3].fundrawtransaction(rawtx), # uses min_relay_tx_fee (set by settxfee)\n-                  self.nodes[3].fundrawtransaction(rawtx, {\"subtractFeeFromOutputs\": []}), # empty subtraction list\n-                  self.nodes[3].fundrawtransaction(rawtx, {\"subtractFeeFromOutputs\": [0]}), # uses min_relay_tx_fee (set by settxfee)\n+        result = [self.nodes[3].fundrawtransaction(rawtx), # Uses min_relay_tx_fee (set by settxfee)\n+                  self.nodes[3].fundrawtransaction(rawtx, {\"subtractFeeFromOutputs\": []}), # Empty subtraction list\n+                  self.nodes[3].fundrawtransaction(rawtx, {\"subtractFeeFromOutputs\": [0]}), # Uses min_relay_tx_fee (set by settxfee)\n                   self.nodes[3].fundrawtransaction(rawtx, {\"feeRate\": 2*min_relay_tx_fee}),\n                   self.nodes[3].fundrawtransaction(rawtx, {\"feeRate\": 2*min_relay_tx_fee, \"subtractFeeFromOutputs\": [0]})]\n \n@@ -716,7 +716,7 @@ def run_test(self):\n         rawtx = self.nodes[3].createrawtransaction(inputs, outputs)\n \n         result = [self.nodes[3].fundrawtransaction(rawtx),\n-                  # split the fee between outputs 0, 2, and 3, but not output 1\n+                  # Split the fee between outputs 0, 2, and 3, but not output 1\n                   self.nodes[3].fundrawtransaction(rawtx, {\"subtractFeeFromOutputs\": [0, 2, 3]})]\n \n         dec_tx = [self.nodes[3].decoderawtransaction(result[0]['hex']),\n@@ -729,25 +729,25 @@ def run_test(self):\n         # List of differences in output amounts between normal and subtractFee transactions\n         share = [o0 - o1 for o0, o1 in zip(output[0], output[1])]\n \n-        # output 1 is the same in both transactions\n+        # Output 1 is the same in both transactions\n         assert_equal(share[1], 0)\n \n-        # the other 3 outputs are smaller as a result of subtractFeeFromOutputs\n+        # The other 3 outputs are smaller as a result of subtractFeeFromOutputs\n         assert_greater_than(share[0], 0)\n         assert_greater_than(share[2], 0)\n         assert_greater_than(share[3], 0)\n \n-        # outputs 2 and 3 take the same share of the fee\n+        # Outputs 2 and 3 take the same share of the fee\n         assert_equal(share[2], share[3])\n \n-        # output 0 takes at least as much share of the fee, and no more than 2 satoshis more, than outputs 2 and 3\n+        # Output 0 takes at least as much share of the fee, and no more than 2 satoshis more, than outputs 2 and 3\n         assert_greater_than_or_equal(share[0], share[2])\n         assert_greater_than_or_equal(share[2] + Decimal(2e-8), share[0])\n \n-        # the fee is the same in both transactions\n+        # The fee is the same in both transactions\n         assert_equal(result[0]['fee'], result[1]['fee'])\n \n-        # the total subtracted from the outputs is equal to the fee\n+        # The total subtracted from the outputs is equal to the fee\n         assert_equal(share[0] + share[2] + share[3], result[0]['fee'])\n \n if __name__ == '__main__':"
      },
      {
        "sha": "03029703a8c84279607aef4cf22b97962790a308",
        "filename": "test/functional/rpc_help.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_help.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_help.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_help.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -15,16 +15,16 @@ def set_test_params(self):\n     def run_test(self):\n         node = self.nodes[0]\n \n-        # wrong argument count\n+        # Wrong argument count\n         assert_raises_rpc_error(-1, 'help', node.help, 'foo', 'bar')\n \n-        # invalid argument\n+        # Invalid argument\n         assert_raises_rpc_error(-1, 'JSON value is not a string as expected', node.help, 0)\n \n-        # help of unknown command\n+        # Help of unknown command\n         assert_equal(node.help('foo'), 'help: unknown command: foo')\n \n-        # command titles\n+        # Command titles\n         titles = [line[3:-3] for line in node.help().splitlines() if line.startswith('==')]\n \n         components = ['Blockchain', 'Control', 'Generating', 'Mining', 'Network', 'Rawtransactions', 'Util']"
      },
      {
        "sha": "354de162610314c61600630d095e46732ba95962",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -58,7 +58,7 @@ def _test_getnettotals(self):\n         assert_greater_than_or_equal(peers_sent, net_totals_before['totalbytessent'])\n         assert_greater_than_or_equal(net_totals_after['totalbytessent'], peers_sent)\n \n-        # test getnettotals and getpeerinfo by doing a ping\n+        # Test getnettotals and getpeerinfo by doing a ping\n         # the bytes sent/received should change\n         # note ping and pong are 32 bytes each\n         self.nodes[0].ping()\n@@ -86,19 +86,19 @@ def _test_getnetworkinginfo(self):\n \n     def _test_getaddednodeinfo(self):\n         assert_equal(self.nodes[0].getaddednodeinfo(), [])\n-        # add a node (node2) to node0\n+        # Add a node (node2) to node0\n         ip_port = \"127.0.0.1:{}\".format(p2p_port(2))\n         self.nodes[0].addnode(ip_port, 'add')\n-        # check that the node has indeed been added\n+        # Check that the node has indeed been added\n         added_nodes = self.nodes[0].getaddednodeinfo(ip_port)\n         assert_equal(len(added_nodes), 1)\n         assert_equal(added_nodes[0]['addednode'], ip_port)\n-        # check that a non-existent node returns an error\n+        # Check that a non-existent node returns an error\n         assert_raises_rpc_error(-24, \"Node has not been added\", self.nodes[0].getaddednodeinfo, '1.1.1.1')\n \n     def _test_getpeerinfo(self):\n         peer_info = [x.getpeerinfo() for x in self.nodes]\n-        # check both sides of bidirectional connection between nodes\n+        # Check both sides of bidirectional connection between nodes\n         # the address bound to on one side will be the source address for the other node\n         assert_equal(peer_info[0][0]['addrbind'], peer_info[1][0]['addr'])\n         assert_equal(peer_info[1][0]['addrbind'], peer_info[0][0]['addr'])\n@@ -108,7 +108,7 @@ def _test_getpeerinfo(self):\n     def _test_getnodeaddresses(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        # send some addresses to the node via the p2p message addr\n+        # Send some addresses to the node via the p2p message addr\n         msg = msg_addr()\n         imported_addrs = []\n         for i in range(256):\n@@ -122,7 +122,7 @@ def _test_getnodeaddresses(self):\n             msg.addrs.append(addr)\n         self.nodes[0].p2p.send_and_ping(msg)\n \n-        # obtain addresses via rpc call and check they were ones sent in before\n+        # Obtain addresses via rpc call and check they were ones sent in before\n         REQUEST_COUNT = 10\n         node_addresses = self.nodes[0].getnodeaddresses(REQUEST_COUNT)\n         assert_equal(len(node_addresses), REQUEST_COUNT)"
      },
      {
        "sha": "35096a5274983dd0b2c646825b22425b2d2599f0",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -72,7 +72,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getbestblockhash(), hashC)\n         self.log.info(\"Make Node1 prefer block C\")\n         self.nodes[1].preciousblock(hashC)\n-        sync_blocks(self.nodes[0:2])  # wait because node 1 may not have downloaded hashC\n+        sync_blocks(self.nodes[0:2])  # Wait because node 1 may not have downloaded hashC\n         assert_equal(self.nodes[1].getbestblockhash(), hashC)\n         self.log.info(\"Make Node1 prefer block G again\")\n         self.nodes[1].preciousblock(hashG)"
      },
      {
        "sha": "13311f6cdff593f0e27d09892abed6340fa05b10",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -47,7 +47,7 @@ def run_test(self):\n         p2pkh = self.nodes[1].getnewaddress(\"\", \"legacy\")\n         p2sh_p2wpkh = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n \n-        # fund those addresses\n+        # Fund those addresses\n         rawtx = self.nodes[0].createrawtransaction([], {p2sh:10, p2wsh:10, p2wpkh:10, p2sh_p2wsh:10, p2sh_p2wpkh:10, p2pkh:10})\n         rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n         signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n@@ -77,24 +77,24 @@ def run_test(self):\n             elif out['scriptPubKey']['addresses'][0] == p2pkh:\n                 p2pkh_pos = out['n']\n \n-        # spend single key from node 1\n+        # Spend single key from node 1\n         rawtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n         walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(rawtx)\n         assert_equal(walletprocesspsbt_out['complete'], True)\n         self.nodes[1].sendrawtransaction(self.nodes[1].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n \n-        # partially sign multisig things with node 1\n+        # Partially sign multisig things with node 1\n         psbtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos},{\"txid\":txid,\"vout\":p2sh_p2wsh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n         walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(psbtx)\n         psbtx = walletprocesspsbt_out['psbt']\n         assert_equal(walletprocesspsbt_out['complete'], False)\n \n-        # partially sign with node 2. This should be complete and sendable\n+        # Partially sign with node 2. This should be complete and sendable\n         walletprocesspsbt_out = self.nodes[2].walletprocesspsbt(psbtx)\n         assert_equal(walletprocesspsbt_out['complete'], True)\n         self.nodes[2].sendrawtransaction(self.nodes[2].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n \n-        # check that walletprocesspsbt fails to decode a non-psbt\n+        # Check that walletprocesspsbt fails to decode a non-psbt\n         rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wpkh_pos}], {self.nodes[1].getnewaddress():9.99})\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletprocesspsbt, rawtx)\n "
      },
      {
        "sha": "9dd93b01e3d000221e88f8654255a829168586ae",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -210,7 +210,7 @@ def run_test(self):\n         # getrawtransaction with block hash #\n         #####################################\n \n-        # make a tx by sending then generate 2 blocks; block1 has the tx in it\n+        # Make a tx by sending then generate 2 blocks; block1 has the tx in it\n         tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n         block1, block2 = self.nodes[2].generate(2)\n         self.sync_all()\n@@ -254,10 +254,10 @@ def run_test(self):\n \n         mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr1])['address']\n \n-        #use balance deltas instead of absolute values\n+        # Use balance deltas instead of absolute values\n         bal = self.nodes[2].getbalance()\n \n-        # send 1.2 BTC to msig adr\n+        # Send 1.2 BTC to msig adr\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n         self.sync_all()\n         self.nodes[0].generate(1)\n@@ -331,7 +331,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        assert_equal(self.nodes[2].getbalance(), bal) # the funds of a 2of2 multisig tx should not be marked as spendable\n+        assert_equal(self.nodes[2].getbalance(), bal) # The funds of a 2of2 multisig tx should not be marked as spendable\n \n         txDetails = self.nodes[0].gettransaction(txId, True)\n         rawTx2 = self.nodes[0].decoderawtransaction(txDetails['hex'])\n@@ -362,41 +362,41 @@ def run_test(self):\n         assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n \n         # decoderawtransaction tests\n-        # witness transaction\n+        # Witness transaction\n         encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # decode as witness transaction\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # Decode as witness transaction\n         assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n-        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # force decode as non-witness transaction\n-        # non-witness transaction\n+        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # Force decode as non-witness transaction\n+        # Non-witness transaction\n         encrawtx = \"01000000010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f505000000000000000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False) # decode as non-witness transaction\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False) # Decode as non-witness transaction\n         assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n \n         # getrawtransaction tests\n-        # 1. valid parameters - only supply txid\n+        # 1. Valid parameters - only supply txid\n         txHash = rawTx[\"hash\"]\n         assert_equal(self.nodes[0].getrawtransaction(txHash), rawTxSigned['hex'])\n \n-        # 2. valid parameters - supply txid and 0 for non-verbose\n+        # 2. Valid parameters - supply txid and 0 for non-verbose\n         assert_equal(self.nodes[0].getrawtransaction(txHash, 0), rawTxSigned['hex'])\n \n-        # 3. valid parameters - supply txid and False for non-verbose\n+        # 3. Valid parameters - supply txid and False for non-verbose\n         assert_equal(self.nodes[0].getrawtransaction(txHash, False), rawTxSigned['hex'])\n \n-        # 4. valid parameters - supply txid and 1 for verbose.\n+        # 4. Valid parameters - supply txid and 1 for verbose.\n         # We only check the \"hex\" field of the output so we don't need to update this test every time the output format changes.\n         assert_equal(self.nodes[0].getrawtransaction(txHash, 1)[\"hex\"], rawTxSigned['hex'])\n \n-        # 5. valid parameters - supply txid and True for non-verbose\n+        # 5. Valid parameters - supply txid and True for non-verbose\n         assert_equal(self.nodes[0].getrawtransaction(txHash, True)[\"hex\"], rawTxSigned['hex'])\n \n-        # 6. invalid parameters - supply txid and string \"Flase\"\n+        # 6. Invalid parameters - supply txid and string \"Flase\"\n         assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txHash, \"Flase\")\n \n-        # 7. invalid parameters - supply txid and empty array\n+        # 7. Invalid parameters - supply txid and empty array\n         assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txHash, [])\n \n-        # 8. invalid parameters - supply txid and empty dict\n+        # 8. Invalid parameters - supply txid and empty dict\n         assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txHash, {})\n \n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 1000}]\n@@ -405,12 +405,12 @@ def run_test(self):\n         decrawtx= self.nodes[0].decoderawtransaction(rawtx)\n         assert_equal(decrawtx['vin'][0]['sequence'], 1000)\n \n-        # 9. invalid parameters - sequence number out of range\n+        # 9. Invalid parameters - sequence number out of range\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : -1}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n         assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n \n-        # 10. invalid parameters - sequence number out of range\n+        # 10. Invalid parameters - sequence number out of range\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967296}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n         assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)"
      },
      {
        "sha": "260b301fe29c1dc35efbf4ae1d5c715a92c18b99",
        "filename": "test/functional/rpc_users.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_users.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/rpc_users.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_users.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -57,13 +57,13 @@ def run_test(self):\n         ##################################################\n         url = urllib.parse.urlparse(self.nodes[0].url)\n \n-        #Old authpair\n+        # Old authpair\n         authpair = url.username + ':' + url.password\n \n-        #New authpair generated via share/rpcauth tool\n+        # New authpair generated via share/rpcauth tool\n         password = \"cA773lm788buwYe4g4WT+05pKyNruVKjQ25x3n0DQcM=\"\n \n-        #Second authpair with different username\n+        # Second authpair with different username\n         password2 = \"8/F3uMDw4KSEbw96U3CA1C4X05dkHDN2BPFjTgZW4KI=\"\n         authpairnew = \"rt:\"+password\n \n@@ -77,7 +77,7 @@ def run_test(self):\n         assert_equal(resp.status, 200)\n         conn.close()\n \n-        #Use new authpair to confirm both work\n+        # Use new authpair to confirm both work\n         self.log.info('Correct...')\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n \n@@ -88,7 +88,7 @@ def run_test(self):\n         assert_equal(resp.status, 200)\n         conn.close()\n \n-        #Wrong login name with rt's password\n+        # Wrong login name with rt's password\n         self.log.info('Wrong...')\n         authpairnew = \"rtwrong:\"+password\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n@@ -100,7 +100,7 @@ def run_test(self):\n         assert_equal(resp.status, 401)\n         conn.close()\n \n-        #Wrong password for rt\n+        # Wrong password for rt\n         self.log.info('Wrong...')\n         authpairnew = \"rt:\"+password+\"wrong\"\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n@@ -112,7 +112,7 @@ def run_test(self):\n         assert_equal(resp.status, 401)\n         conn.close()\n \n-        #Correct for rt2\n+        # Correct for rt2\n         self.log.info('Correct...')\n         authpairnew = \"rt2:\"+password2\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n@@ -124,7 +124,7 @@ def run_test(self):\n         assert_equal(resp.status, 200)\n         conn.close()\n \n-        #Wrong password for rt2\n+        # Wrong password for rt2\n         self.log.info('Wrong...')\n         authpairnew = \"rt2:\"+password2+\"wrong\"\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n@@ -136,7 +136,7 @@ def run_test(self):\n         assert_equal(resp.status, 401)\n         conn.close()\n \n-        #Correct for randomly generated user\n+        # Correct for randomly generated user\n         self.log.info('Correct...')\n         authpairnew = self.user+\":\"+self.password\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n@@ -148,7 +148,7 @@ def run_test(self):\n         assert_equal(resp.status, 200)\n         conn.close()\n \n-        #Wrong password for randomly generated user\n+        # Wrong password for randomly generated user\n         self.log.info('Wrong...')\n         authpairnew = self.user+\":\"+self.password+\"Wrong\"\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpairnew)}\n@@ -178,7 +178,7 @@ def run_test(self):\n         assert_equal(resp.status, 200)\n         conn.close()\n \n-        #Wrong login name with rpcuser's password\n+        # Wrong login name with rpcuser's password\n         rpcuserauthpair = \"rpcuserwrong:rpcpassword\"\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(rpcuserauthpair)}\n \n@@ -189,7 +189,7 @@ def run_test(self):\n         assert_equal(resp.status, 401)\n         conn.close()\n \n-        #Wrong password for rpcuser\n+        # Wrong password for rpcuser\n         self.log.info('Wrong...')\n         rpcuserauthpair = \"rpcuser:rpcpasswordwrong\"\n         headers = {\"Authorization\": \"Basic \" + str_to_b64str(rpcuserauthpair)}"
      },
      {
        "sha": "dc035488c606b49b674cc1fb8d9f779f9274bc61",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -58,7 +58,7 @@\n         stderr_mode = ctypes.c_int32()\n         kernel32.GetConsoleMode(stderr, ctypes.byref(stderr_mode))\n         kernel32.SetConsoleMode(stderr, stderr_mode.value | ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n-    # primitive formatting on supported\n+    # Primitive formatting on supported\n     # terminal via ANSI escape sequences:\n     BOLD = ('\\033[0m', '\\033[1m')\n     GREEN = ('\\033[0m', '\\033[0;32m')\n@@ -227,7 +227,7 @@ def main():\n     parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n     args, unknown_args = parser.parse_known_args()\n \n-    # args to be passed on always start with two dashes; tests are the remaining unknown args\n+    # Args to be passed on always start with two dashes; tests are the remaining unknown args\n     tests = [arg for arg in unknown_args if arg[:2] != \"--\"]\n     passon_args = [arg for arg in unknown_args if arg[:2] == \"--\"]\n "
      },
      {
        "sha": "5b9d71478f6f7430f2520ac22e98ca4e121adf60",
        "filename": "test/functional/wallet_abandonconflict.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_abandonconflict.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -52,7 +52,7 @@ def run_test(self):\n         nC = next(i for i, vout in enumerate(self.nodes[0].getrawtransaction(txC, 1)[\"vout\"]) if vout[\"value\"] == Decimal(\"10\"))\n \n         inputs =[]\n-        # spend 10btc outputs from txA and txB\n+        # Spend 10btc outputs from txA and txB\n         inputs.append({\"txid\":txA, \"vout\":nA})\n         inputs.append({\"txid\":txB, \"vout\":nB})\n         outputs = {}\n@@ -79,7 +79,7 @@ def run_test(self):\n         inputs = [ {\"txid\":txABC2, \"vout\":0} ]\n         outputs = { self.nodes[0].getnewaddress(): signed3_change }\n         signed3 = self.nodes[0].signrawtransactionwithwallet(self.nodes[0].createrawtransaction(inputs, outputs))\n-        # note tx is never directly referenced, only abandoned as a child of the above\n+        # Note tx is never directly referenced, only abandoned as a child of the above\n         self.nodes[0].sendrawtransaction(signed3[\"hex\"])\n \n         # In mempool txs from self should increase balance from change"
      },
      {
        "sha": "a9e14481f86e410b18c86820d65ed3ce01077e9c",
        "filename": "test/functional/wallet_address_types.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_address_types.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -240,7 +240,7 @@ def run_test(self):\n                 to_node %= 4\n                 assert_equal(unconf_balances[to_node], to_send * 10 * (2 + n))\n \n-            # node5 collects fee and block subsidy to keep accounting simple\n+            # Node5 collects fee and block subsidy to keep accounting simple\n             self.nodes[5].generate(1)\n             sync_blocks(self.nodes)\n "
      },
      {
        "sha": "1072058bb87c66fb952556fb2d7a24688fd44337",
        "filename": "test/functional/wallet_backup.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_backup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_backup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_backup.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -42,7 +42,7 @@ class WalletBackupTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = True\n-        # nodes 1, 2,3 are spenders, let's give them a keypool=100\n+        # Nodes 1, 2,3 are spenders, let's give them a keypool=100\n         self.extra_args = [[\"-keypool=100\"], [\"-keypool=100\"], [\"-keypool=100\"], []]\n \n     def skip_test_if_missing_module(self):"
      },
      {
        "sha": "a810d88559cee2eda6c6f58d9d4a0363720fa413",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -74,7 +74,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getbalance(\"*\", 1, True), 50)\n         assert_equal(self.nodes[0].getbalance(minconf=1), 50)\n \n-        # first argument of getbalance must be excluded or set to \"*\"\n+        # First argument of getbalance must be excluded or set to \"*\"\n         assert_raises_rpc_error(-32, \"dummy first argument must be excluded or set to \\\"*\\\"\", self.nodes[0].getbalance, \"\")\n \n         # Check that only first and second nodes have UTXOs\n@@ -102,19 +102,19 @@ def run_test(self):\n         assert_greater_than(memory_after['locked']['used'], memory_before['locked']['used'])\n \n         self.log.info(\"test gettxout (second part)\")\n-        # utxo spent in mempool should be visible if you exclude mempool\n+        # UTXO spent in mempool should be visible if you exclude mempool\n         # but invisible if you include mempool\n         txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index, False)\n         assert_equal(txout['value'], 50)\n         txout = self.nodes[0].gettxout(confirmed_txid, confirmed_index, True)\n         assert txout is None\n-        # new utxo from mempool should be invisible if you exclude mempool\n+        # New UTXO from mempool should be invisible if you exclude mempool\n         # but visible if you include mempool\n         txout = self.nodes[0].gettxout(mempool_txid, 0, False)\n         assert txout is None\n         txout1 = self.nodes[0].gettxout(mempool_txid, 0, True)\n         txout2 = self.nodes[0].gettxout(mempool_txid, 1, True)\n-        # note the mempool tx will have randomly assigned indices\n+        # Note the mempool tx will have randomly assigned indices\n         # but 10 will go to node2 and the rest will go to node0\n         balance = self.nodes[0].getbalance()\n         assert_equal(set([txout1['value'], txout2['value']]), set([10, balance]))\n@@ -161,7 +161,7 @@ def run_test(self):\n         self.nodes[1].generate(100)\n         self.sync_all([self.nodes[0:3]])\n \n-        # node0 should end up with 100 btc in block rewards plus fees, but\n+        # Node0 should end up with 100 btc in block rewards plus fees, but\n         # minus the 21 plus fees sent to node2\n         assert_equal(self.nodes[0].getbalance(), 100 - 21)\n         assert_equal(self.nodes[2].getbalance(), 21)\n@@ -172,7 +172,7 @@ def run_test(self):\n         node0utxos = self.nodes[0].listunspent(1)\n         assert_equal(len(node0utxos), 2)\n \n-        # create both transactions\n+        # Create both transactions\n         txns_to_send = []\n         for utxo in node0utxos:\n             inputs = []\n@@ -253,7 +253,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getwalletinfo()[\"unconfirmed_balance\"], 1)\n         assert_equal(self.nodes[0].getunconfirmedbalance(), 1)\n \n-        # check if we can list zero value tx as available coins\n+        # Check if we can list zero value tx as available coins\n         # 1. create raw_tx\n         # 2. hex-changed one output to 0.0\n         # 3. sign and send\n@@ -262,25 +262,25 @@ def run_test(self):\n         inputs = [{\"txid\": usp['txid'], \"vout\": usp['vout']}]\n         outputs = {self.nodes[1].getnewaddress(): 49.998, self.nodes[0].getnewaddress(): 11.11}\n \n-        raw_tx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\")  # replace 11.11 with 0.0 (int32)\n+        raw_tx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\")  # Replace 11.11 with 0.0 (int32)\n         signed_raw_tx = self.nodes[1].signrawtransactionwithwallet(raw_tx)\n         decoded_raw_tx = self.nodes[1].decoderawtransaction(signed_raw_tx['hex'])\n         zero_value_txid = decoded_raw_tx['txid']\n         self.nodes[1].sendrawtransaction(signed_raw_tx['hex'])\n \n         self.sync_all()\n-        self.nodes[1].generate(1)  # mine a block\n+        self.nodes[1].generate(1)  # Mine a block\n         self.sync_all()\n \n-        unspent_txs = self.nodes[0].listunspent()  # zero value tx must be in listunspents output\n+        unspent_txs = self.nodes[0].listunspent()  # Zero value tx must be in listunspents output\n         found = False\n         for uTx in unspent_txs:\n             if uTx['txid'] == zero_value_txid:\n                 found = True\n                 assert_equal(uTx['amount'], Decimal('0'))\n         assert(found)\n \n-        # do some -walletbroadcast tests\n+        # Do some -walletbroadcast tests\n         self.stop_nodes()\n         self.start_node(0, [\"-walletbroadcast=0\"])\n         self.start_node(1, [\"-walletbroadcast=0\"])\n@@ -292,22 +292,22 @@ def run_test(self):\n \n         txid_not_broadcast = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n         tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n-        self.nodes[1].generate(1)  # mine a block, tx should not be in there\n+        self.nodes[1].generate(1)  # Mine a block, tx should not be in there\n         self.sync_all([self.nodes[0:3]])\n-        assert_equal(self.nodes[2].getbalance(), node_2_bal)  # should not be changed because tx was not broadcasted\n+        assert_equal(self.nodes[2].getbalance(), node_2_bal)  # Should not be changed because tx was not broadcasted\n \n-        # now broadcast from another node, mine a block, sync, and check the balance\n+        # Now broadcast from another node, mine a block, sync, and check the balance\n         self.nodes[1].sendrawtransaction(tx_obj_not_broadcast['hex'])\n         self.nodes[1].generate(1)\n         self.sync_all([self.nodes[0:3]])\n         node_2_bal += 2\n         tx_obj_not_broadcast = self.nodes[0].gettransaction(txid_not_broadcast)\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n \n-        # create another tx\n+        # Create another tx\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n \n-        # restart the nodes with -walletbroadcast=1\n+        # Restart the nodes with -walletbroadcast=1\n         self.stop_nodes()\n         self.start_node(0)\n         self.start_node(1)\n@@ -321,10 +321,10 @@ def run_test(self):\n         sync_blocks(self.nodes[0:3])\n         node_2_bal += 2\n \n-        # tx should be added to balance because after restarting the nodes tx should be broadcast\n+        # Tx should be added to balance because after restarting the nodes tx should be broadcast\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n \n-        # send a tx with value in a string (PR#6380 +)\n+        # Send a tx with value in a string (PR#6380 +)\n         txid = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"2\")\n         tx_obj = self.nodes[0].gettransaction(txid)\n         assert_equal(tx_obj['amount'], Decimal('-2'))\n@@ -333,7 +333,7 @@ def run_test(self):\n         tx_obj = self.nodes[0].gettransaction(txid)\n         assert_equal(tx_obj['amount'], Decimal('-0.0001'))\n \n-        # check if JSON parser can handle scientific notation in strings\n+        # Check if JSON parser can handle scientific notation in strings\n         txid = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"1e-4\")\n         tx_obj = self.nodes[0].gettransaction(txid)\n         assert_equal(tx_obj['amount'], Decimal('-0.0001'))\n@@ -380,7 +380,7 @@ def run_test(self):\n         # Check that the txid and balance is found by node1\n         self.nodes[1].gettransaction(coinbase_txid)\n \n-        # check if wallet or blockchain maintenance changes the balance\n+        # Check if wallet or blockchain maintenance changes the balance\n         self.sync_all([self.nodes[0:3]])\n         blocks = self.nodes[0].generate(2)\n         self.sync_all([self.nodes[0:3]])\n@@ -392,33 +392,33 @@ def run_test(self):\n         #   - False: unicode directly as UTF-8\n         for mode in [True, False]:\n             self.nodes[0].rpc.ensure_ascii = mode\n-            # unicode check: Basic Multilingual Plane, Supplementary Plane respectively\n+            # Unicode check: Basic Multilingual Plane, Supplementary Plane respectively\n             for label in [u'\u0440\u044b\u0431\u0430', u'\ud834\udd61']:\n                 addr = self.nodes[0].getnewaddress()\n                 self.nodes[0].setlabel(addr, label)\n                 assert_equal(self.nodes[0].getaddressinfo(addr)['label'], label)\n                 assert(label in self.nodes[0].listlabels())\n-        self.nodes[0].rpc.ensure_ascii = True  # restore to default\n+        self.nodes[0].rpc.ensure_ascii = True  # Restore to default\n \n-        # maintenance tests\n+        # Maintenance tests\n         maintenance = [\n             '-rescan',\n             '-reindex',\n             '-zapwallettxes=1',\n             '-zapwallettxes=2',\n-            # disabled until issue is fixed: https://github.com/bitcoin/bitcoin/issues/7463\n+            # Disabled until issue is fixed: https://github.com/bitcoin/bitcoin/issues/7463\n             # '-salvagewallet',\n         ]\n         chainlimit = 6\n         for m in maintenance:\n             self.log.info(\"check \" + m)\n             self.stop_nodes()\n-            # set lower ancestor limit for later\n+            # Set lower ancestor limit for later\n             self.start_node(0, [m, \"-limitancestorcount=\" + str(chainlimit)])\n             self.start_node(1, [m, \"-limitancestorcount=\" + str(chainlimit)])\n             self.start_node(2, [m, \"-limitancestorcount=\" + str(chainlimit)])\n             if m == '-reindex':\n-                # reindex will leave rpc warm up \"early\"; Wait for it to finish\n+                # Reindex will leave rpc warm up \"early\"; Wait for it to finish\n                 wait_until(lambda: [block_count] * 3 == [self.nodes[i].getblockcount() for i in range(3)])\n             assert_equal(balance_nodes, [self.nodes[i].getbalance() for i in range(3)])\n \n@@ -466,7 +466,7 @@ def run_test(self):\n         self.stop_node(0)\n         self.start_node(0, extra_args=[\"-walletrejectlongchains\", \"-limitancestorcount=\" + str(2 * chainlimit)])\n \n-        # wait for loadmempool\n+        # Wait for loadmempool\n         timeout = 10\n         while (timeout > 0 and len(self.nodes[0].getrawmempool()) < chainlimit * 2):\n             time.sleep(0.5)"
      },
      {
        "sha": "00ec29c30f6b20d155cccb3ae00f166f478a02df",
        "filename": "test/functional/wallet_bumpfee.py",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_bumpfee.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -47,7 +47,7 @@ def run_test(self):\n         peer_node, rbf_node = self.nodes\n         rbf_node_address = rbf_node.getnewaddress()\n \n-        # fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n+        # Fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n         self.log.info(\"Mining blocks...\")\n         peer_node.generate(110)\n         self.sync_all()\n@@ -84,15 +84,15 @@ def test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address):\n     bumped_tx = rbf_node.bumpfee(rbfid)\n     assert_equal(bumped_tx[\"errors\"], [])\n     assert bumped_tx[\"fee\"] - abs(rbftx[\"fee\"]) > 0\n-    # check that bumped_tx propagates, original tx was evicted and has a wallet conflict\n+    # Check that bumped_tx propagates, original tx was evicted and has a wallet conflict\n     sync_mempools((rbf_node, peer_node))\n     assert bumped_tx[\"txid\"] in rbf_node.getrawmempool()\n     assert bumped_tx[\"txid\"] in peer_node.getrawmempool()\n     assert rbfid not in rbf_node.getrawmempool()\n     assert rbfid not in peer_node.getrawmempool()\n     oldwtx = rbf_node.gettransaction(rbfid)\n     assert len(oldwtx[\"walletconflicts\"]) > 0\n-    # check wallet transaction replaces and replaced_by values\n+    # Check wallet transaction replaces and replaced_by values\n     bumpedwtx = rbf_node.gettransaction(bumped_tx[\"txid\"])\n     assert_equal(oldwtx[\"replaced_by_txid\"], bumped_tx[\"txid\"])\n     assert_equal(bumpedwtx[\"replaces_txid\"], rbfid)\n@@ -129,13 +129,13 @@ def test_segwit_bumpfee_succeeds(rbf_node, dest_address):\n \n \n def test_nonrbf_bumpfee_fails(peer_node, dest_address):\n-    # cannot replace a non RBF transaction (from node which did not enable RBF)\n+    # Cannot replace a non RBF transaction (from node which did not enable RBF)\n     not_rbfid = peer_node.sendtoaddress(dest_address, Decimal(\"0.00090000\"))\n     assert_raises_rpc_error(-4, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n \n \n def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n-    # cannot bump fee unless the tx has only inputs that we own.\n+    # Cannot bump fee unless the tx has only inputs that we own.\n     # here, the rbftx has a peer_node coin and then adds a rbf_node input\n     # Note that this test depends upon the RPC code checking input ownership prior to change outputs\n     # (since it can't use fundrawtransaction, it lacks a proper change output)\n@@ -156,7 +156,7 @@ def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n \n \n def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address):\n-    # cannot bump fee if the transaction has a descendant\n+    # Cannot bump fee if the transaction has a descendant\n     # parent is send-to-self, so we don't have to check which output is change when creating the child tx\n     parent_id = spend_one_input(rbf_node, rbf_node_address)\n     tx = rbf_node.createrawtransaction([{\"txid\": parent_id, \"vout\": 0}], {dest_address: 0.00020000})\n@@ -166,7 +166,7 @@ def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address)\n \n \n def test_small_output_fails(rbf_node, dest_address):\n-    # cannot bump fee with a too-small output\n+    # Cannot bump fee with a too-small output\n     rbfid = spend_one_input(rbf_node, dest_address)\n     rbf_node.bumpfee(rbfid, {\"totalFee\": 50000})\n \n@@ -175,7 +175,7 @@ def test_small_output_fails(rbf_node, dest_address):\n \n \n def test_dust_to_fee(rbf_node, dest_address):\n-    # check that if output is reduced to dust, it will be converted to fee\n+    # Check that if output is reduced to dust, it will be converted to fee\n     # the bumped tx sets fee=49,900, but it converts to 50,000\n     rbfid = spend_one_input(rbf_node, dest_address)\n     fulltx = rbf_node.getrawtransaction(rbfid, 1)\n@@ -186,13 +186,13 @@ def test_dust_to_fee(rbf_node, dest_address):\n     full_bumped_tx = rbf_node.getrawtransaction(bumped_tx[\"txid\"], 1)\n     assert_equal(bumped_tx[\"fee\"], Decimal(\"0.00050000\"))\n     assert_equal(len(fulltx[\"vout\"]), 2)\n-    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  # change output is eliminated\n+    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  # Change output is eliminated\n \n \n def test_settxfee(rbf_node, dest_address):\n     assert_raises_rpc_error(-8, \"txfee cannot be less than min relay tx fee\", rbf_node.settxfee, Decimal('0.000005'))\n     assert_raises_rpc_error(-8, \"txfee cannot be less than wallet min fee\", rbf_node.settxfee, Decimal('0.000015'))\n-    # check that bumpfee reacts correctly to the use of settxfee (paytxfee)\n+    # Check that bumpfee reacts correctly to the use of settxfee (paytxfee)\n     rbfid = spend_one_input(rbf_node, dest_address)\n     requested_feerate = Decimal(\"0.00025000\")\n     rbf_node.settxfee(requested_feerate)\n@@ -201,39 +201,39 @@ def test_settxfee(rbf_node, dest_address):\n     # Assert that the difference between the requested feerate and the actual\n     # feerate of the bumped transaction is small.\n     assert_greater_than(Decimal(\"0.00001000\"), abs(requested_feerate - actual_feerate))\n-    rbf_node.settxfee(Decimal(\"0.00000000\"))  # unset paytxfee\n+    rbf_node.settxfee(Decimal(\"0.00000000\"))  # Unset paytxfee\n \n \n def test_rebumping(rbf_node, dest_address):\n-    # check that re-bumping the original tx fails, but bumping the bumper succeeds\n+    # Check that re-bumping the original tx fails, but bumping the bumper succeeds\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 2000})\n     assert_raises_rpc_error(-4, \"already bumped\", rbf_node.bumpfee, rbfid, {\"totalFee\": 3000})\n     rbf_node.bumpfee(bumped[\"txid\"], {\"totalFee\": 3000})\n \n \n def test_rebumping_not_replaceable(rbf_node, dest_address):\n-    # check that re-bumping a non-replaceable bump tx fails\n+    # Check that re-bumping a non-replaceable bump tx fails\n     rbfid = spend_one_input(rbf_node, dest_address)\n     bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 10000, \"replaceable\": False})\n     assert_raises_rpc_error(-4, \"Transaction is not BIP 125 replaceable\", rbf_node.bumpfee, bumped[\"txid\"],\n                             {\"totalFee\": 20000})\n \n \n def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n-    # check that unconfirmed outputs from bumped transactions are not spendable\n+    # Check that unconfirmed outputs from bumped transactions are not spendable\n     rbfid = spend_one_input(rbf_node, rbf_node_address)\n     rbftx = rbf_node.gettransaction(rbfid)[\"hex\"]\n     assert rbfid in rbf_node.getrawmempool()\n     bumpid = rbf_node.bumpfee(rbfid)[\"txid\"]\n     assert bumpid in rbf_node.getrawmempool()\n     assert rbfid not in rbf_node.getrawmempool()\n \n-    # check that outputs from the bump transaction are not spendable\n+    # Check that outputs from the bump transaction are not spendable\n     # due to the replaces_txid check in CWallet::AvailableCoins\n     assert_equal([t for t in rbf_node.listunspent(minconf=0, include_unsafe=False) if t[\"txid\"] == bumpid], [])\n \n-    # submit a block with the rbf tx to clear the bump tx out of the mempool,\n+    # Submit a block with the rbf tx to clear the bump tx out of the mempool,\n     # then invalidate the block so the rbf tx will be put back in the mempool.\n     # This makes it possible to check whether the rbf tx outputs are\n     # spendable before the rbf tx is confirmed.\n@@ -247,12 +247,12 @@ def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n     assert bumpid not in rbf_node.getrawmempool()\n     assert rbfid in rbf_node.getrawmempool()\n \n-    # check that outputs from the rbf tx are not spendable before the\n+    # Check that outputs from the rbf tx are not spendable before the\n     # transaction is confirmed, due to the replaced_by_txid check in\n     # CWallet::AvailableCoins\n     assert_equal([t for t in rbf_node.listunspent(minconf=0, include_unsafe=False) if t[\"txid\"] == rbfid], [])\n \n-    # check that the main output from the rbf tx is spendable after confirmed\n+    # Check that the main output from the rbf tx is spendable after confirmed\n     rbf_node.generate(1)\n     assert_equal(\n         sum(1 for t in rbf_node.listunspent(minconf=0, include_unsafe=False)"
      },
      {
        "sha": "02c2ee918a0d4afdd339c6dbf80f2568edab99c2",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -26,9 +26,9 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n         found_addr_rsv = 0\n         hd_master_addr_ret = None\n         for line in inputfile:\n-            # only read non comment lines\n+            # Only read non comment lines\n             if line[0] != \"#\" and len(line) > 10:\n-                # split out some data\n+                # Split out some data\n                 key_date_label, comment = line.split(\"#\")\n                 key_date_label = key_date_label.split(\" \")\n                 # key = key_date_label[0]\n@@ -45,19 +45,19 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                 addr = addr_keypath.split(\" \")[0]\n                 keypath = None\n                 if keytype == \"inactivehdseed=1\":\n-                    # ensure the old master is still available\n+                    # Ensure the old master is still available\n                     assert (hd_master_addr_old == addr)\n                 elif keytype == \"hdseed=1\":\n-                    # ensure we have generated a new hd master key\n+                    # Ensure we have generated a new hd master key\n                     assert (hd_master_addr_old != addr)\n                     hd_master_addr_ret = addr\n                 elif keytype == \"script=1\":\n-                    # scripts don't have keypaths\n+                    # Scripts don't have keypaths\n                     keypath = None\n                 else:\n                     keypath = addr_keypath.rstrip().split(\"hdkeypath=\")[1]\n \n-                # count key types\n+                # Count key types\n                 for addrObj in addrs:\n                     if addrObj['address'] == addr.split(\",\")[0] and addrObj['hdkeypath'] == keypath and keytype == \"label=\":\n                         if addr.startswith('m') or addr.startswith('n'):\n@@ -76,7 +76,7 @@ def read_dump(file_name, addrs, script_addrs, hd_master_addr_old):\n                         found_addr_rsv += 1\n                         break\n \n-                # count scripts\n+                # Count scripts\n                 for script_addr in script_addrs:\n                     if script_addr == addr.rstrip() and keytype == \"script=1\":\n                         found_script_addr += 1\n@@ -102,7 +102,7 @@ def run_test(self):\n         wallet_unenc_dump = os.path.join(self.nodes[0].datadir, \"wallet.unencrypted.dump\")\n         wallet_enc_dump = os.path.join(self.nodes[0].datadir, \"wallet.encrypted.dump\")\n \n-        # generate 30 addresses to compare against the dump\n+        # Generate 30 addresses to compare against the dump\n         # - 10 legacy P2PKH\n         # - 10 P2SH-segwit\n         # - 10 bech32\n@@ -111,7 +111,7 @@ def run_test(self):\n         for address_type in ['legacy', 'p2sh-segwit', 'bech32']:\n             for i in range(0, test_addr_count):\n                 addr = self.nodes[0].getnewaddress(address_type=address_type)\n-                vaddr = self.nodes[0].getaddressinfo(addr)  # required to get hd keypath\n+                vaddr = self.nodes[0].getaddressinfo(addr)  # Required to get hd keypath\n                 addrs.append(vaddr)\n \n         # Test scripts dump by adding a 1-of-1 multisig address\n@@ -122,20 +122,20 @@ def run_test(self):\n         # its capacity\n         self.nodes[0].keypoolrefill()\n \n-        # dump unencrypted wallet\n+        # Dump unencrypted wallet\n         result = self.nodes[0].dumpwallet(wallet_unenc_dump)\n         assert_equal(result['filename'], wallet_unenc_dump)\n \n         found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, hd_master_addr_unenc = \\\n             read_dump(wallet_unenc_dump, addrs, [multisig_addr], None)\n-        assert_equal(found_legacy_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_bech32_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_script_addr, 1)  # all scripts must be in the dump\n+        assert_equal(found_legacy_addr, test_addr_count)  # All keys must be in the dump\n+        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # All keys must be in the dump\n+        assert_equal(found_bech32_addr, test_addr_count)  # All keys must be in the dump\n+        assert_equal(found_script_addr, 1)  # All scripts must be in the dump\n         assert_equal(found_addr_chg, 0)  # 0 blocks where mined\n         assert_equal(found_addr_rsv, 90 * 2)  # 90 keys plus 100% internal keys\n \n-        # encrypt wallet, restart, unlock and dump\n+        # Encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:\n@@ -144,11 +144,11 @@ def run_test(self):\n \n         found_legacy_addr, found_p2sh_segwit_addr, found_bech32_addr, found_script_addr, found_addr_chg, found_addr_rsv, _ = \\\n             read_dump(wallet_enc_dump, addrs, [multisig_addr], hd_master_addr_unenc)\n-        assert_equal(found_legacy_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # all keys must be in the dump\n-        assert_equal(found_bech32_addr, test_addr_count)  # all keys must be in the dump\n+        assert_equal(found_legacy_addr, test_addr_count)  # All keys must be in the dump\n+        assert_equal(found_p2sh_segwit_addr, test_addr_count)  # All keys must be in the dump\n+        assert_equal(found_bech32_addr, test_addr_count)  # All keys must be in the dump\n         assert_equal(found_script_addr, 1)\n-        assert_equal(found_addr_chg, 90 * 2)  # old reserve keys are marked as change now\n+        assert_equal(found_addr_chg, 90 * 2)  # Old reserve keys are marked as change now\n         assert_equal(found_addr_rsv, 90 * 2)\n \n         # Overwriting should fail"
      },
      {
        "sha": "32c7b537e4c8b77927d4a1cb3c7e3d2239c99004",
        "filename": "test/functional/wallet_fallbackfee.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_fallbackfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_fallbackfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_fallbackfee.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -17,10 +17,10 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         self.nodes[0].generate(101)\n \n-        # sending a transaction without fee estimations must be possible by default on regtest\n+        # Sending a transaction without fee estimations must be possible by default on regtest\n         self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n \n-        # test sending a tx with disabled fallback fee (must fail)\n+        # Test sending a tx with disabled fallback fee (must fail)\n         self.restart_node(0, extra_args=[\"-fallbackfee=0\"])\n         assert_raises_rpc_error(-4, \"Fee estimation failed\", lambda: self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1))\n         assert_raises_rpc_error(-4, \"Fee estimation failed\", lambda: self.nodes[0].fundrawtransaction(self.nodes[0].createrawtransaction([], {self.nodes[0].getnewaddress(): 1})))"
      },
      {
        "sha": "723c96a0f7c7445e4e6b55ce22351262eb6e1966",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         # txid1 should have 1 input and 2 outputs\n         assert_equal(1, len(tx1[\"vin\"]))\n         assert_equal(2, len(tx1[\"vout\"]))\n-        # one output should be 0.2, the other should be ~0.3\n+        # One output should be 0.2, the other should be ~0.3\n         v = [vout[\"value\"] for vout in tx1[\"vout\"]]\n         v.sort()\n         assert_approx(v[0], 0.2)\n@@ -62,7 +62,7 @@ def run_test(self):\n         # txid2 should have 2 inputs and 2 outputs\n         assert_equal(2, len(tx2[\"vin\"]))\n         assert_equal(2, len(tx2[\"vout\"]))\n-        # one output should be 0.2, the other should be ~1.3\n+        # One output should be 0.2, the other should be ~1.3\n         v = [vout[\"value\"] for vout in tx2[\"vout\"]]\n         v.sort()\n         assert_approx(v[0], 0.2)"
      },
      {
        "sha": "8588a30c175d491a5749c9416ce6b4e72953ec9c",
        "filename": "test/functional/wallet_hd.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_hd.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -30,7 +30,7 @@ def run_test(self):\n         assert_equal(masterkeyid, self.nodes[1].getwalletinfo()['hdmasterkeyid'])\n         assert_equal(len(masterkeyid), 40)\n \n-        # create an internal key\n+        # Create an internal key\n         change_addr = self.nodes[1].getrawchangeaddress()\n         change_addrV= self.nodes[1].getaddressinfo(change_addr)\n         assert_equal(change_addrV[\"hdkeypath\"], \"m/0'/1'/0'\") #first internal child key\n@@ -59,7 +59,7 @@ def run_test(self):\n         self.nodes[0].sendtoaddress(non_hd_add, 1)\n         self.nodes[0].generate(1)\n \n-        # create an internal key (again)\n+        # Create an internal key (again)\n         change_addr = self.nodes[1].getrawchangeaddress()\n         change_addrV= self.nodes[1].getaddressinfo(change_addr)\n         assert_equal(change_addrV[\"hdkeypath\"], \"m/0'/1'/1'\") #second internal child key\n@@ -69,7 +69,7 @@ def run_test(self):\n \n         self.log.info(\"Restore backup ...\")\n         self.stop_node(1)\n-        # we need to delete the complete regtest directory\n+        # We need to delete the complete regtest directory\n         # otherwise node1 would auto-recover all funds in flag the keypool keys as used\n         shutil.rmtree(os.path.join(self.nodes[1].datadir, \"regtest\", \"blocks\"))\n         shutil.rmtree(os.path.join(self.nodes[1].datadir, \"regtest\", \"chainstate\"))\n@@ -111,7 +111,7 @@ def run_test(self):\n         assert_equal(out['stop_height'], self.nodes[1].getblockcount())\n         assert_equal(self.nodes[1].getbalance(), NUM_HD_ADDS + 1)\n \n-        # send a tx and make sure its using the internal chain for the changeoutput\n+        # Send a tx and make sure its using the internal chain for the changeoutput\n         txid = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         outs = self.nodes[1].decoderawtransaction(self.nodes[1].gettransaction(txid)['hex'])['vout']\n         keypath = \"\""
      },
      {
        "sha": "fda949fcae7ed51c466f9447b84300e1329452b7",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -34,13 +34,13 @@ def run_test (self):\n \n         node0_address1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n \n-        #Check only one address\n+        # Check only one address\n         assert_equal(node0_address1['ismine'], True)\n \n-        #Node 1 sync test\n+        # Node 1 sync test\n         assert_equal(self.nodes[1].getblockcount(),1)\n \n-        #Address Test - before import\n+        # Address Test - before import\n         address_info = self.nodes[1].getaddressinfo(node0_address1['address'])\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n@@ -438,7 +438,7 @@ def run_test (self):\n         watchonly_timestamp = timestamp\n \n \n-        # restart nodes to check for proper serialization/deserialization of watch only address\n+        # Restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n         address_assert = self.nodes[1].getaddressinfo(watchonly_address)"
      },
      {
        "sha": "a9f1f5375656e6a15ba0b5e737fadaba9e434852",
        "filename": "test/functional/wallet_importprunedfunds.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importprunedfunds.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -25,11 +25,11 @@ def run_test(self):\n \n         self.sync_all()\n \n-        # address\n+        # Address\n         address1 = self.nodes[0].getnewaddress()\n-        # pubkey\n+        # Pubkey\n         address2 = self.nodes[0].getnewaddress()\n-        # privkey\n+        # Privkey\n         address3 = self.nodes[0].getnewaddress()\n         address3_privkey = self.nodes[0].dumpprivkey(address3)  # Using privkey\n "
      },
      {
        "sha": "add321c6fbdcb26ce1bfde208f4fc5574aaac6bf",
        "filename": "test/functional/wallet_keypool.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -35,45 +35,45 @@ def run_test(self):\n         assert(addr_data['hdseedid'] == wallet_info['hdseedid'])\n         assert_raises_rpc_error(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n \n-        # put six (plus 2) new keys in the keypool (100% external-, +100% internal-keys, 1 in min)\n+        # Put six (plus 2) new keys in the keypool (100% external-, +100% internal-keys, 1 in min)\n         nodes[0].walletpassphrase('test', 12000)\n         nodes[0].keypoolrefill(6)\n         nodes[0].walletlock()\n         wi = nodes[0].getwalletinfo()\n         assert_equal(wi['keypoolsize_hd_internal'], 6)\n         assert_equal(wi['keypoolsize'], 6)\n \n-        # drain the internal keys\n+        # Drain the internal keys\n         nodes[0].getrawchangeaddress()\n         nodes[0].getrawchangeaddress()\n         nodes[0].getrawchangeaddress()\n         nodes[0].getrawchangeaddress()\n         nodes[0].getrawchangeaddress()\n         nodes[0].getrawchangeaddress()\n         addr = set()\n-        # the next one should fail\n+        # The next one should fail\n         assert_raises_rpc_error(-12, \"Keypool ran out\", nodes[0].getrawchangeaddress)\n \n-        # drain the external keys\n+        # Drain the external keys\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n         addr.add(nodes[0].getnewaddress())\n         assert(len(addr) == 6)\n-        # the next one should fail\n+        # The next one should fail\n         assert_raises_rpc_error(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n \n-        # refill keypool with three new addresses\n+        # Refill keypool with three new addresses\n         nodes[0].walletpassphrase('test', 1)\n         nodes[0].keypoolrefill(3)\n \n-        # test walletpassphrase timeout\n+        # Test walletpassphrase timeout\n         time.sleep(1.1)\n         assert_equal(nodes[0].getwalletinfo()[\"unlocked_until\"], 0)\n \n-        # drain the keypool\n+        # Drain the keypool\n         for _ in range(3):\n             nodes[0].getnewaddress()\n         assert_raises_rpc_error(-12, \"Keypool ran out\", nodes[0].getnewaddress)"
      },
      {
        "sha": "8b67bdc3fbc870e3ed28f3979ae4f0f3da4a96cf",
        "filename": "test/functional/wallet_labels.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_labels.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_labels.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_labels.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -33,11 +33,11 @@ def run_test(self):\n         node.generatetoaddress(nblocks=101, address=node.getnewaddress(label='coinbase'))\n         assert_equal(node.getbalance(), 100)\n \n-        # there should be 2 address groups\n+        # There should be 2 address groups\n         # each with 1 address with a balance of 50 Bitcoins\n         address_groups = node.listaddressgroupings()\n         assert_equal(len(address_groups), 2)\n-        # the addresses aren't linked now, but will be after we send to the\n+        # The addresses aren't linked now, but will be after we send to the\n         # common address\n         linked_addresses = set()\n         for address_group in address_groups:\n@@ -47,14 +47,14 @@ def run_test(self):\n             assert_equal(address_group[0][2], 'coinbase')\n             linked_addresses.add(address_group[0][0])\n \n-        # send 50 from each address to a third address not in this wallet\n+        # Send 50 from each address to a third address not in this wallet\n         common_address = \"msf4WtN1YQKXvNtvdFYt9JBnUD2FB41kjr\"\n         node.sendmany(\n             amounts={common_address: 100},\n             subtractfeefrom=[common_address],\n             minconf=1,\n         )\n-        # there should be 1 address group, with the previously\n+        # There should be 1 address group, with the previously\n         # unlinked addresses now linked (they both have 0 balance)\n         address_groups = node.listaddressgroupings()\n         assert_equal(len(address_groups), 1)\n@@ -64,8 +64,8 @@ def run_test(self):\n \n         node.generate(1)\n \n-        # we want to reset so that the \"\" label has what's expected.\n-        # otherwise we're off by exactly the fee amount as that's mined\n+        # We want to reset so that the \"\" label has what's expected.\n+        # Otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n         amount_to_send = 1.0\n "
      },
      {
        "sha": "e9fc53329c59f3dc838c6af726871a69bf5ec86c",
        "filename": "test/functional/wallet_listreceivedby.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_listreceivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_listreceivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listreceivedby.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -96,7 +96,7 @@ def run_test(self):\n         assert_equal(len(res), 3 + self.num_cb_reward_addresses)  # Became 3 entries\n \n         # Not on random addr\n-        other_addr = self.nodes[0].getnewaddress()  # note on node[0]! just a random addr\n+        other_addr = self.nodes[0].getnewaddress()  # Note on node[0]! just a random addr\n         res = self.nodes[1].listreceivedbyaddress(0, True, True, other_addr)\n         assert_equal(len(res), 0)\n \n@@ -126,7 +126,7 @@ def run_test(self):\n \n         self.log.info(\"listreceivedbylabel + getreceivedbylabel Test\")\n \n-        # set pre-state\n+        # Set pre-state\n         label = ''\n         address = self.nodes[1].getnewaddress()\n         assert_equal(self.nodes[1].getaddressinfo(address)['label'], label)"
      },
      {
        "sha": "42327c9cc352d5f730125e482606b5bfa192d30a",
        "filename": "test/functional/wallet_listsinceblock.py",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listsinceblock.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -90,10 +90,10 @@ def test_reorg(self):\n         # Split network into two\n         self.split_network()\n \n-        # send to nodes[0] from nodes[2]\n+        # Send to nodes[0] from nodes[2]\n         senttx = self.nodes[2].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n \n-        # generate on both sides\n+        # Generate on both sides\n         lastblockhash = self.nodes[1].generate(6)[5]\n         self.nodes[2].generate(7)\n         self.log.info('lastblockhash=%s' % (lastblockhash))\n@@ -146,13 +146,13 @@ def test_double_spend(self):\n         # Split network into two\n         self.split_network()\n \n-        # share utxo between nodes[1] and nodes[2]\n+        # Share utxo between nodes[1] and nodes[2]\n         utxos = self.nodes[2].listunspent()\n         utxo = utxos[0]\n         privkey = self.nodes[2].dumpprivkey(utxo['address'])\n         self.nodes[1].importprivkey(privkey)\n \n-        # send from nodes[1] using utxo to nodes[0]\n+        # Send from nodes[1] using utxo to nodes[0]\n         change = '%.8f' % (float(utxo['amount']) - 1.0003)\n         recipient_dict = {\n             self.nodes[0].getnewaddress(): 1,\n@@ -166,7 +166,7 @@ def test_double_spend(self):\n             self.nodes[1].signrawtransactionwithwallet(\n                 self.nodes[1].createrawtransaction(utxo_dicts, recipient_dict))['hex'])\n \n-        # send from nodes[2] using utxo to nodes[3]\n+        # Send from nodes[2] using utxo to nodes[3]\n         recipient_dict2 = {\n             self.nodes[3].getnewaddress(): 1,\n             self.nodes[2].getnewaddress(): change,\n@@ -175,22 +175,22 @@ def test_double_spend(self):\n             self.nodes[2].signrawtransactionwithwallet(\n                 self.nodes[2].createrawtransaction(utxo_dicts, recipient_dict2))['hex'])\n \n-        # generate on both sides\n+        # Generate on both sides\n         lastblockhash = self.nodes[1].generate(3)[2]\n         self.nodes[2].generate(4)\n \n         self.join_network()\n \n         self.sync_all()\n \n-        # gettransaction should work for txid1\n+        # Gettransaction should work for txid1\n         assert self.nodes[0].gettransaction(txid1)['txid'] == txid1, \"gettransaction failed to find txid1\"\n \n         # listsinceblock(lastblockhash) should now include txid1, as seen from nodes[0]\n         lsbres = self.nodes[0].listsinceblock(lastblockhash)\n         assert any(tx['txid'] == txid1 for tx in lsbres['removed'])\n \n-        # but it should not include 'removed' if include_removed=false\n+        # But it should not include 'removed' if include_removed=false\n         lsbres2 = self.nodes[0].listsinceblock(blockhash=lastblockhash, include_removed=False)\n         assert 'removed' not in lsbres2\n \n@@ -225,7 +225,7 @@ def test_double_send(self):\n         # Split network into two\n         self.split_network()\n \n-        # create and sign a transaction\n+        # Create and sign a transaction\n         utxos = self.nodes[2].listunspent()\n         utxo = utxos[0]\n         change = '%.8f' % (float(utxo['amount']) - 1.0003)\n@@ -243,18 +243,18 @@ def test_double_send(self):\n \n         signedtx = signedtxres['hex']\n \n-        # send from nodes[1]; this will end up in aa1\n+        # Send from nodes[1]; this will end up in aa1\n         txid1 = self.nodes[1].sendrawtransaction(signedtx)\n \n-        # generate bb1-bb2 on right side\n+        # Generate bb1-bb2 on right side\n         self.nodes[2].generate(2)\n \n-        # send from nodes[2]; this will end up in bb3\n+        # Send from nodes[2]; this will end up in bb3\n         txid2 = self.nodes[2].sendrawtransaction(signedtx)\n \n         assert_equal(txid1, txid2)\n \n-        # generate on both sides\n+        # Generate on both sides\n         lastblockhash = self.nodes[1].generate(3)[2]\n         self.nodes[2].generate(2)\n \n@@ -271,12 +271,12 @@ def test_double_send(self):\n         assert any(tx['txid'] == txid1 for tx in lsbres['transactions'])\n         assert any(tx['txid'] == txid1 for tx in lsbres['removed'])\n \n-        # find transaction and ensure confirmations is valid\n+        # Find transaction and ensure confirmations is valid\n         for tx in lsbres['transactions']:\n             if tx['txid'] == txid1:\n                 assert_equal(tx['confirmations'], 2)\n \n-        # the same check for the removed array; confirmations should STILL be 2\n+        # The same check for the removed array; confirmations should STILL be 2\n         for tx in lsbres['removed']:\n             if tx['txid'] == txid1:\n                 assert_equal(tx['confirmations'], 2)"
      },
      {
        "sha": "60f6c5db6fa8813b2f90d9c2c7a5c4b574e3eb6e",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -40,7 +40,7 @@ def run_test(self):\n         assert_array_result(self.nodes[1].listtransactions(),\n                             {\"txid\": txid},\n                             {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n-        # mine a block, confirmations should change:\n+        # Mine a block, confirmations should change:\n         self.nodes[0].generate(1)\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n@@ -181,7 +181,7 @@ def get_unconfirmed_utxo_entry(node, txid_to_match):\n \n         # Replace tx3, and check that tx4 becomes unknown\n         tx3_b = tx3_modified\n-        tx3_b.vout[0].nValue -= int(Decimal(\"0.004\") * COIN)  # bump the fee\n+        tx3_b.vout[0].nValue -= int(Decimal(\"0.004\") * COIN)  # Bump the fee\n         tx3_b = bytes_to_hex_str(tx3_b.serialize())\n         tx3_b_signed = self.nodes[0].signrawtransactionwithwallet(tx3_b)['hex']\n         txid_3b = self.nodes[0].sendrawtransaction(tx3_b_signed, True)"
      },
      {
        "sha": "afd842284ba398853a59bb5766a110e3092ffdee",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -41,26 +41,26 @@ def wallet_file(name):\n \n         assert_equal(self.nodes[0].listwalletdir(), { 'wallets': [{ 'name': '' }] })\n \n-        # check wallet.dat is created\n+        # Check wallet.dat is created\n         self.stop_nodes()\n         assert_equal(os.path.isfile(wallet_dir('wallet.dat')), True)\n \n-        # create symlink to verify wallet directory path can be referenced\n+        # Create symlink to verify wallet directory path can be referenced\n         # through symlink\n         os.mkdir(wallet_dir('w7'))\n         os.symlink('w7', wallet_dir('w7_symlink'))\n \n-        # rename wallet.dat to make sure plain wallet file paths (as opposed to\n+        # Rename wallet.dat to make sure plain wallet file paths (as opposed to\n         # directory paths) can be loaded\n         os.rename(wallet_dir(\"wallet.dat\"), wallet_dir(\"w8\"))\n \n-        # create another dummy wallet for use in testing backups later\n+        # Create another dummy wallet for use in testing backups later\n         self.start_node(0, [])\n         self.stop_nodes()\n         empty_wallet = os.path.join(self.options.tmpdir, 'empty.dat')\n         os.rename(wallet_dir(\"wallet.dat\"), empty_wallet)\n \n-        # restart node with a mix of wallet names:\n+        # Restart node with a mix of wallet names:\n         #   w1, w2, w3 - to verify new wallets created when non-existing paths specified\n         #   w          - to verify wallet name matching works when one wallet path is prefix of another\n         #   sub/w5     - to verify relative wallet path is created correctly\n@@ -75,34 +75,34 @@ def wallet_file(name):\n \n         assert_equal(set(node.listwallets()), set(wallet_names))\n \n-        # check that all requested wallets were created\n+        # Check that all requested wallets were created\n         self.stop_node(0)\n         for wallet_name in wallet_names:\n             assert_equal(os.path.isfile(wallet_file(wallet_name)), True)\n \n-        # should not initialize if wallet path can't be created\n+        # Should not initialize if wallet path can't be created\n         exp_stderr = \"boost::filesystem::create_directory:\"\n         self.nodes[0].assert_start_raises_init_error(['-wallet=wallet.dat/bad'], exp_stderr, match=ErrorMatch.PARTIAL_REGEX)\n \n         self.nodes[0].assert_start_raises_init_error(['-walletdir=wallets'], 'Error: Specified -walletdir \"wallets\" does not exist')\n         self.nodes[0].assert_start_raises_init_error(['-walletdir=wallets'], 'Error: Specified -walletdir \"wallets\" is a relative path', cwd=data_dir())\n         self.nodes[0].assert_start_raises_init_error(['-walletdir=debug.log'], 'Error: Specified -walletdir \"debug.log\" is not a directory', cwd=data_dir())\n \n-        # should not initialize if there are duplicate wallets\n+        # Should not initialize if there are duplicate wallets\n         self.nodes[0].assert_start_raises_init_error(['-wallet=w1', '-wallet=w1'], 'Error: Error loading wallet w1. Duplicate -wallet filename specified.')\n \n-        # should not initialize if one wallet is a copy of another\n+        # Should not initialize if one wallet is a copy of another\n         shutil.copyfile(wallet_dir('w8'), wallet_dir('w8_copy'))\n         exp_stderr = \"BerkeleyBatch: Can't open database w8_copy \\(duplicates fileid \\w+ from w8\\)\"\n         self.nodes[0].assert_start_raises_init_error(['-wallet=w8', '-wallet=w8_copy'], exp_stderr, match=ErrorMatch.PARTIAL_REGEX)\n \n-        # should not initialize if wallet file is a symlink\n+        # Should not initialize if wallet file is a symlink\n         os.symlink('w8', wallet_dir('w8_symlink'))\n         self.nodes[0].assert_start_raises_init_error(['-wallet=w8_symlink'], 'Error: Invalid -wallet path \\'w8_symlink\\'\\. .*', match=ErrorMatch.FULL_REGEX)\n \n-        # should not initialize if the specified walletdir does not exist\n+        # Should not initialize if the specified walletdir does not exist\n         self.nodes[0].assert_start_raises_init_error(['-walletdir=bad'], 'Error: Specified -walletdir \"bad\" does not exist')\n-        # should not initialize if the specified walletdir is not a directory\n+        # Should not initialize if the specified walletdir is not a directory\n         not_a_dir = wallet_dir('notadir')\n         open(not_a_dir, 'a', encoding=\"utf8\").close()\n         self.nodes[0].assert_start_raises_init_error(['-walletdir=' + not_a_dir], 'Error: Specified -walletdir \"' + not_a_dir + '\" is not a directory')\n@@ -120,15 +120,15 @@ def wallet_file(name):\n         self.nodes[0].assert_start_raises_init_error(['-upgradewallet', '-wallet=w1', '-wallet=w2'], \"Error: -upgradewallet is only allowed with a single wallet file\")\n         self.nodes[0].assert_start_raises_init_error(['-upgradewallet=1', '-wallet=w1', '-wallet=w2'], \"Error: -upgradewallet is only allowed with a single wallet file\")\n \n-        # if wallets/ doesn't exist, datadir should be the default wallet dir\n+        # If wallets/ doesn't exist, datadir should be the default wallet dir\n         wallet_dir2 = data_dir('walletdir')\n         os.rename(wallet_dir(), wallet_dir2)\n         self.start_node(0, ['-wallet=w4', '-wallet=w5'])\n         assert_equal(set(node.listwallets()), {\"w4\", \"w5\"})\n         w5 = wallet(\"w5\")\n         node.generatetoaddress(nblocks=1, address=w5.getnewaddress())\n \n-        # now if wallets/ exists again, but the rootdir is specified as the walletdir, w4 and w5 should still be loaded\n+        # Now if wallets/ exists again, but the rootdir is specified as the walletdir, w4 and w5 should still be loaded\n         os.rename(wallet_dir2, wallet_dir())\n         self.restart_node(0, ['-wallet=w4', '-wallet=w5', '-walletdir=' + data_dir()])\n         assert_equal(set(node.listwallets()), {\"w4\", \"w5\"})\n@@ -149,17 +149,17 @@ def wallet_file(name):\n         wallets = [wallet(w) for w in wallet_names]\n         wallet_bad = wallet(\"bad\")\n \n-        # check wallet names and balances\n+        # Check wallet names and balances\n         node.generatetoaddress(nblocks=1, address=wallets[0].getnewaddress())\n         for wallet_name, wallet in zip(wallet_names, wallets):\n             info = wallet.getwalletinfo()\n             assert_equal(info['immature_balance'], 50 if wallet is wallets[0] else 0)\n             assert_equal(info['walletname'], wallet_name)\n \n-        # accessing invalid wallet fails\n+        # Accessing invalid wallet fails\n         assert_raises_rpc_error(-18, \"Requested wallet does not exist or is not loaded\", wallet_bad.getwalletinfo)\n \n-        # accessing wallet RPC without using wallet endpoint fails\n+        # Accessing wallet RPC without using wallet endpoint fails\n         assert_raises_rpc_error(-19, \"Wallet file not specified\", node.getwalletinfo)\n \n         w1, w2, w3, w4, *_ = wallets"
      },
      {
        "sha": "251e5b24420fb6b2849d3214e6fdcefbb80d0922",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -41,7 +41,7 @@ def run_test(self):\n         starting_balance = 1250\n         for i in range(4):\n             assert_equal(self.nodes[i].getbalance(), starting_balance)\n-            self.nodes[i].getnewaddress()  # bug workaround, coins generated assigned to first getnewaddress!\n+            self.nodes[i].getnewaddress()  # Bug workaround, coins generated assigned to first getnewaddress!\n \n         self.nodes[0].settxfee(.001)\n "
      },
      {
        "sha": "19713b724ca8139692a7f940cd92d4455d49956c",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ec7629b89583aeaece53704e12ff63dc35337a5/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=1ec7629b89583aeaece53704e12ff63dc35337a5",
        "patch": "@@ -36,7 +36,7 @@ def run_test(self):\n         starting_balance = 1250\n         for i in range(4):\n             assert_equal(self.nodes[i].getbalance(), starting_balance)\n-            self.nodes[i].getnewaddress(\"\")  # bug workaround, coins generated assigned to first getnewaddress!\n+            self.nodes[i].getnewaddress(\"\")  # Bug workaround, coins generated assigned to first getnewaddress!\n \n         # Assign coins to foo and bar addresses:\n         node0_address_foo = self.nodes[0].getnewaddress()"
      }
    ]
  }
]