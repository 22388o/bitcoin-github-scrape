[
  {
    "sha": "045eeb887092a631d49194e743859b1da84c1d5d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNDVlZWI4ODcwOTJhNjMxZDQ5MTk0ZTc0Mzg1OWIxZGE4NGMxZDVk",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-10-20T17:27:55Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-03-19T16:05:35Z"
      },
      "message": "Rename account to label where appropriate\n\nThis change only updates strings and adds RPC aliases, but should simplify the\nimplementation of address labels in\nhttps://github.com/bitcoin/bitcoin/pull/7729, by getting renaming out of the\nway and letting it focus on semantics.\n\nThe difference between accounts and labels is that labels apply only to\naddresses, while accounts apply to both addresses and transactions\n(transactions have \"from\" and \"to\" accounts). The code associating accounts\nwith transactions is clumsy and unreliable so we would like get rid of it.",
      "tree": {
        "sha": "f51ebb3d012ec3912ac85e63d8cf68e0146c116c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f51ebb3d012ec3912ac85e63d8cf68e0146c116c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/045eeb887092a631d49194e743859b1da84c1d5d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/045eeb887092a631d49194e743859b1da84c1d5d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/045eeb887092a631d49194e743859b1da84c1d5d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/045eeb887092a631d49194e743859b1da84c1d5d/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c39dd2ef59c986576726cc356a27165486fd0d65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c39dd2ef59c986576726cc356a27165486fd0d65",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c39dd2ef59c986576726cc356a27165486fd0d65"
      }
    ],
    "stats": {
      "total": 484,
      "additions": 253,
      "deletions": 231
    },
    "files": [
      {
        "sha": "b183ee0a594f1e2936fb87a0b615749713f87aec",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -63,6 +63,16 @@ RPC changes\n \n - The `createrawtransaction` RPC will now accept an array or dictionary (kept for compatibility) for the `outputs` parameter. This means the order of transaction outputs can be specified by the client.\n - The `fundrawtransaction` RPC will reject the previously deprecated `reserveChangeKey` option.\n+- Wallet `getnewaddress` and `addmultisigaddress` RPC `account` named\n+  parameters have been renamed to `label` with no change in behavior.\n+- Wallet `getlabeladdress`, `getreceivedbylabel`, `listreceivedbylabel`, and\n+  `setlabel` RPCs have been added to replace `getaccountaddress`,\n+  `getreceivedbyaccount`, `listreceivedbyaccount`, and `setaccount` RPCs,\n+  which are now deprecated. There is no change in behavior between the\n+  new RPCs and deprecated RPCs.\n+- Wallet `listreceivedbylabel`, `listreceivedbyaccount` and `listunspent` RPCs\n+  add `label` fields to returned JSON objects that previously only had\n+  `account` fields.\n \n External wallet files\n ---------------------"
      },
      {
        "sha": "1d0b66dfd8629a9e1aeee3db6d9f41d707a9795f",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -634,8 +634,6 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, const SendCoinsRecipient& r\n     payment.add_transactions(transaction.data(), transaction.size());\n \n     // Create a new refund address, or re-use:\n-    QString account = tr(\"Refund from %1\").arg(recipient.authenticatedMerchant);\n-    std::string strAccount = account.toStdString();\n     CPubKey newKey;\n     if (wallet->GetKeyFromPool(newKey)) {\n         // BIP70 requests encode the scriptPubKey directly, so we are not restricted to address\n@@ -646,7 +644,8 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, const SendCoinsRecipient& r\n         const OutputType change_type = wallet->m_default_change_type != OutputType::NONE ? wallet->m_default_change_type : wallet->m_default_address_type;\n         wallet->LearnRelatedScripts(newKey, change_type);\n         CTxDestination dest = GetDestinationForKey(newKey, change_type);\n-        wallet->SetAddressBook(dest, strAccount, \"refund\");\n+        std::string label = tr(\"Refund from %1\").arg(recipient.authenticatedMerchant).toStdString();\n+        wallet->SetAddressBook(dest, label, \"refund\");\n \n         CScript s = GetScriptForDestination(dest);\n         payments::Output* refund_to = payment.add_refund_to();"
      },
      {
        "sha": "e12685da650be6975dcbfc3c137b13186efeb676",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -40,13 +40,17 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"settxfee\", 0, \"amount\" },\n     { \"getreceivedbyaddress\", 1, \"minconf\" },\n     { \"getreceivedbyaccount\", 1, \"minconf\" },\n+    { \"getreceivedbylabel\", 1, \"minconf\" },\n     { \"listreceivedbyaddress\", 0, \"minconf\" },\n     { \"listreceivedbyaddress\", 1, \"include_empty\" },\n     { \"listreceivedbyaddress\", 2, \"include_watchonly\" },\n     { \"listreceivedbyaddress\", 3, \"address_filter\" },\n     { \"listreceivedbyaccount\", 0, \"minconf\" },\n     { \"listreceivedbyaccount\", 1, \"include_empty\" },\n     { \"listreceivedbyaccount\", 2, \"include_watchonly\" },\n+    { \"listreceivedbylabel\", 0, \"minconf\" },\n+    { \"listreceivedbylabel\", 1, \"include_empty\" },\n+    { \"listreceivedbylabel\", 2, \"include_watchonly\" },\n     { \"getbalance\", 1, \"minconf\" },\n     { \"getbalance\", 2, \"include_watchonly\" },\n     { \"getblockhash\", 0, \"height\" },"
      },
      {
        "sha": "ff63bf49016e97e46c4648255cc07621934ccdda",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -76,7 +76,7 @@ enum RPCErrorCode\n     //! Wallet errors\n     RPC_WALLET_ERROR                = -4,  //!< Unspecified problem with wallet (key not found etc.)\n     RPC_WALLET_INSUFFICIENT_FUNDS   = -6,  //!< Not enough funds in wallet or account\n-    RPC_WALLET_INVALID_ACCOUNT_NAME = -11, //!< Invalid account name\n+    RPC_WALLET_INVALID_LABEL_NAME   = -11, //!< Invalid label name\n     RPC_WALLET_KEYPOOL_RAN_OUT      = -12, //!< Keypool ran out, call keypoolrefill first\n     RPC_WALLET_UNLOCK_NEEDED        = -13, //!< Enter the wallet passphrase with walletpassphrase first\n     RPC_WALLET_PASSPHRASE_INCORRECT = -14, //!< The wallet passphrase entered was incorrect\n@@ -85,6 +85,9 @@ enum RPCErrorCode\n     RPC_WALLET_ALREADY_UNLOCKED     = -17, //!< Wallet is already unlocked\n     RPC_WALLET_NOT_FOUND            = -18, //!< Invalid wallet specified\n     RPC_WALLET_NOT_SPECIFIED        = -19, //!< No wallet specified (error when there are multiple wallets loaded)\n+\n+    //! Backwards compatible aliases\n+    RPC_WALLET_INVALID_ACCOUNT_NAME = RPC_WALLET_INVALID_LABEL_NAME,\n };\n \n UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id);"
      },
      {
        "sha": "7c173278c59c18c9d40fac65a6fa80eb26fafbb5",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 100,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -124,12 +124,12 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n         entry.pushKV(item.first, item.second);\n }\n \n-std::string AccountFromValue(const UniValue& value)\n+std::string LabelFromValue(const UniValue& value)\n {\n-    std::string strAccount = value.get_str();\n-    if (strAccount == \"*\")\n-        throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid account name\");\n-    return strAccount;\n+    std::string label = value.get_str();\n+    if (label == \"*\")\n+        throw JSONRPCError(RPC_WALLET_INVALID_LABEL_NAME, \"Invalid label name\");\n+    return label;\n }\n \n UniValue getnewaddress(const JSONRPCRequest& request)\n@@ -141,12 +141,12 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getnewaddress ( \\\"account\\\" \\\"address_type\\\" )\\n\"\n+            \"getnewaddress ( \\\"label\\\" \\\"address_type\\\" )\\n\"\n             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n-            \"If 'account' is specified (DEPRECATED), it is added to the address book \\n\"\n-            \"so payments received with the address will be credited to 'account'.\\n\"\n+            \"If 'label' is specified, it is added to the address book \\n\"\n+            \"so payments received with the address will be associated with 'label'.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"        (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n\"\n+            \"1. \\\"label\\\"          (string, optional) The label name for the address to be linked to. If not provided, the default label \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created if there is no label by the given name.\\n\"\n             \"2. \\\"address_type\\\"   (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -addresstype.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"address\\\"    (string) The new bitcoin address\\n\"\n@@ -157,10 +157,10 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    // Parse the account first so we don't generate a key if there's an error\n-    std::string strAccount;\n+    // Parse the label first so we don't generate a key if there's an error\n+    std::string label;\n     if (!request.params[0].isNull())\n-        strAccount = AccountFromValue(request.params[0]);\n+        label = LabelFromValue(request.params[0]);\n \n     OutputType output_type = pwallet->m_default_address_type;\n     if (!request.params[1].isNull()) {\n@@ -182,23 +182,23 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n     pwallet->LearnRelatedScripts(newKey, output_type);\n     CTxDestination dest = GetDestinationForKey(newKey, output_type);\n \n-    pwallet->SetAddressBook(dest, strAccount, \"receive\");\n+    pwallet->SetAddressBook(dest, label, \"receive\");\n \n     return EncodeDestination(dest);\n }\n \n \n-CTxDestination GetAccountDestination(CWallet* const pwallet, std::string strAccount, bool bForceNew=false)\n+CTxDestination GetLabelDestination(CWallet* const pwallet, const std::string& label, bool bForceNew=false)\n {\n     CTxDestination dest;\n-    if (!pwallet->GetAccountDestination(dest, strAccount, bForceNew)) {\n+    if (!pwallet->GetLabelDestination(dest, label, bForceNew)) {\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     }\n \n     return dest;\n }\n \n-UniValue getaccountaddress(const JSONRPCRequest& request)\n+UniValue getlabeladdress(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -207,27 +207,27 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"getaccountaddress \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\\n\"\n+            \"getlabeladdress \\\"label\\\"\\n\"\n+            \"\\nReturns the current Bitcoin address for receiving payments to this label.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"       (string, required) The account name for the address. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.\\n\"\n+            \"1. \\\"label\\\"         (string, required) The label name for the address. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created and a new address created  if there is no label by the given name.\\n\"\n             \"\\nResult:\\n\"\n-            \"\\\"address\\\"          (string) The account bitcoin address\\n\"\n+            \"\\\"address\\\"          (string) The label bitcoin address\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaccountaddress\", \"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"\\\"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n-            + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n+            + HelpExampleCli(\"getlabeladdress\", \"\")\n+            + HelpExampleCli(\"getlabeladdress\", \"\\\"\\\"\")\n+            + HelpExampleCli(\"getlabeladdress\", \"\\\"mylabel\\\"\")\n+            + HelpExampleRpc(\"getlabeladdress\", \"\\\"mylabel\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    // Parse the account first so we don't generate a key if there's an error\n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    // Parse the label first so we don't generate a key if there's an error\n+    std::string label = LabelFromValue(request.params[0]);\n \n     UniValue ret(UniValue::VSTR);\n \n-    ret = EncodeDestination(GetAccountDestination(pwallet, strAccount));\n+    ret = EncodeDestination(GetLabelDestination(pwallet, label));\n     return ret;\n }\n \n@@ -281,7 +281,7 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n }\n \n \n-UniValue setaccount(const JSONRPCRequest& request)\n+UniValue setlabel(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -290,14 +290,14 @@ UniValue setaccount(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"setaccount \\\"address\\\" \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Sets the account associated with the given address.\\n\"\n+            \"setlabel \\\"address\\\" \\\"label\\\"\\n\"\n+            \"\\nSets the label associated with the given address.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address to be associated with an account.\\n\"\n-            \"2. \\\"account\\\"         (string, required) The account to assign the address to.\\n\"\n+            \"1. \\\"address\\\"         (string, required) The bitcoin address to be associated with a label.\\n\"\n+            \"2. \\\"label\\\"           (string, required) The label to assign the address to.\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"tabby\\\"\")\n-            + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"tabby\\\"\")\n+            + HelpExampleCli(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"tabby\\\"\")\n+            + HelpExampleRpc(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"tabby\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n@@ -307,23 +307,23 @@ UniValue setaccount(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     }\n \n-    std::string strAccount;\n+    std::string label;\n     if (!request.params[1].isNull())\n-        strAccount = AccountFromValue(request.params[1]);\n+        label = LabelFromValue(request.params[1]);\n \n-    // Only add the account if the address is yours.\n+    // Only add the label if the address is yours.\n     if (IsMine(*pwallet, dest)) {\n-        // Detect when changing the account of an address that is the 'unused current key' of another account:\n+        // Detect when changing the label of an address that is the 'unused current key' of another label:\n         if (pwallet->mapAddressBook.count(dest)) {\n-            std::string strOldAccount = pwallet->mapAddressBook[dest].name;\n-            if (dest == GetAccountDestination(pwallet, strOldAccount)) {\n-                GetAccountDestination(pwallet, strOldAccount, true);\n+            std::string old_label = pwallet->mapAddressBook[dest].name;\n+            if (dest == GetLabelDestination(pwallet, old_label)) {\n+                GetLabelDestination(pwallet, old_label, true);\n             }\n         }\n-        pwallet->SetAddressBook(dest, strAccount, \"receive\");\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n     }\n     else\n-        throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n+        throw JSONRPCError(RPC_MISC_ERROR, \"setlabel can only be used with own address\");\n \n     return NullUniValue;\n }\n@@ -390,7 +390,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = LabelFromValue(request.params[0]);\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n@@ -552,7 +552,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n             \"    [\\n\"\n             \"      \\\"address\\\",            (string) The bitcoin address\\n\"\n             \"      amount,                 (numeric) The amount in \" + CURRENCY_UNIT + \"\\n\"\n-            \"      \\\"account\\\"             (string, optional) DEPRECATED. The account\\n\"\n+            \"      \\\"label\\\"               (string, optional) The label\\n\"\n             \"    ]\\n\"\n             \"    ,...\\n\"\n             \"  ]\\n\"\n@@ -720,7 +720,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n }\n \n \n-UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n+UniValue getreceivedbylabel(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -729,22 +729,22 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getreceivedbyaccount \\\"account\\\" ( minconf )\\n\"\n-            \"\\nDEPRECATED. Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\\n\"\n+            \"getreceivedbylabel \\\"label\\\" ( minconf )\\n\"\n+            \"\\nReturns the total amount received by addresses with <label> in transactions with at least [minconf] confirmations.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"      (string, required) The selected account, may be the default account using \\\"\\\".\\n\"\n+            \"1. \\\"label\\\"        (string, required) The selected label, may be the default label using \\\"\\\".\\n\"\n             \"2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n             \"\\nResult:\\n\"\n-            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this account.\\n\"\n+            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this label.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nAmount received by the default account with at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"\\\"\") +\n-            \"\\nAmount received at the tabby account including unconfirmed amounts with zero confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 0\") +\n+            \"\\nAmount received by the default label with at least 1 confirmation\\n\"\n+            + HelpExampleCli(\"getreceivedbylabel\", \"\\\"\\\"\") +\n+            \"\\nAmount received at the tabby label including unconfirmed amounts with zero confirmations\\n\"\n+            + HelpExampleCli(\"getreceivedbylabel\", \"\\\"tabby\\\" 0\") +\n             \"\\nThe amount with at least 6 confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 6\") +\n+            + HelpExampleCli(\"getreceivedbylabel\", \"\\\"tabby\\\" 6\") +\n             \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\")\n+            + HelpExampleRpc(\"getreceivedbylabel\", \"\\\"tabby\\\", 6\")\n         );\n \n     ObserveSafeMode();\n@@ -760,9 +760,9 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n         nMinDepth = request.params[1].get_int();\n \n-    // Get the set of pub keys assigned to account\n-    std::string strAccount = AccountFromValue(request.params[0]);\n-    std::set<CTxDestination> setAddress = pwallet->GetAccountAddresses(strAccount);\n+    // Get the set of pub keys assigned to label\n+    std::string label = LabelFromValue(request.params[0]);\n+    std::set<CTxDestination> setAddress = pwallet->GetLabelAddresses(label);\n \n     // Tally\n     CAmount nAmount = 0;\n@@ -920,8 +920,8 @@ UniValue movecmd(const JSONRPCRequest& request)\n     ObserveSafeMode();\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strFrom = AccountFromValue(request.params[0]);\n-    std::string strTo = AccountFromValue(request.params[1]);\n+    std::string strFrom = LabelFromValue(request.params[0]);\n+    std::string strTo = LabelFromValue(request.params[1]);\n     CAmount nAmount = AmountFromValue(request.params[2]);\n     if (nAmount <= 0)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n@@ -984,7 +984,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = LabelFromValue(request.params[0]);\n     CTxDestination dest = DecodeDestination(request.params[1].get_str());\n     if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -1076,7 +1076,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n \n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = LabelFromValue(request.params[0]);\n     UniValue sendTo = request.params[1].get_obj();\n     int nMinDepth = 1;\n     if (!request.params[2].isNull())\n@@ -1171,12 +1171,12 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n-        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" \\\"address_type\\\" )\\n\"\n+        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"label\\\" \\\"address_type\\\" )\\n\"\n             \"\\nAdd a nrequired-to-sign multisignature address to the wallet. Requires a new wallet backup.\\n\"\n             \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n             \"This functionality is only intended for use with non-watchonly addresses.\\n\"\n             \"See `importaddress` for watchonly p2sh address support.\\n\"\n-            \"If 'account' is specified (DEPRECATED), assign address to that account.\\n\"\n+            \"If 'label' is specified, assign address to that label.\\n\"\n \n             \"\\nArguments:\\n\"\n             \"1. nrequired                      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n@@ -1185,7 +1185,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n             \"       \\\"address\\\"                  (string) bitcoin address or hex-encoded public key\\n\"\n             \"       ...,\\n\"\n             \"     ]\\n\"\n-            \"3. \\\"account\\\"                      (string, optional) DEPRECATED. An account to assign the addresses to.\\n\"\n+            \"3. \\\"label\\\"                        (string, optional) A label to assign the addresses to.\\n\"\n             \"4. \\\"address_type\\\"                 (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -addresstype.\\n\"\n \n             \"\\nResult:\\n\"\n@@ -1204,9 +1204,9 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strAccount;\n+    std::string label;\n     if (!request.params[2].isNull())\n-        strAccount = AccountFromValue(request.params[2]);\n+        label = LabelFromValue(request.params[2]);\n \n     int required = request.params[0].get_int();\n \n@@ -1233,7 +1233,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     CScript inner = CreateMultisigRedeemscript(required, pubkeys);\n     pwallet->AddCScript(inner);\n     CTxDestination dest = pwallet->AddAndGetDestinationForScript(inner, output_type);\n-    pwallet->SetAddressBook(dest, strAccount, \"send\");\n+    pwallet->SetAddressBook(dest, label, \"send\");\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"address\", EncodeDestination(dest));\n@@ -1385,14 +1385,14 @@ struct tallyitem\n     }\n };\n \n-UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByAccounts)\n+UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool by_label)\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n     if (!params[0].isNull())\n         nMinDepth = params[0].get_int();\n \n-    // Whether to include empty accounts\n+    // Whether to include empty labels\n     bool fIncludeEmpty = false;\n     if (!params[1].isNull())\n         fIncludeEmpty = params[1].get_bool();\n@@ -1404,7 +1404,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n     bool has_filtered_address = false;\n     CTxDestination filtered_address = CNoDestination();\n-    if (!fByAccounts && params.size() > 3) {\n+    if (!by_label && params.size() > 3) {\n         if (!IsValidDestinationString(params[3].get_str())) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"address_filter parameter was invalid\");\n         }\n@@ -1449,7 +1449,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n     // Reply\n     UniValue ret(UniValue::VARR);\n-    std::map<std::string, tallyitem> mapAccountTally;\n+    std::map<std::string, tallyitem> label_tally;\n \n     // Create mapAddressBook iterator\n     // If we aren't filtering, go from begin() to end()\n@@ -1466,7 +1466,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n     for (auto item_it = start; item_it != end; ++item_it)\n     {\n         const CTxDestination& address = item_it->first;\n-        const std::string& strAccount = item_it->second.name;\n+        const std::string& label = item_it->second.name;\n         auto it = mapTally.find(address);\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n@@ -1481,9 +1481,9 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             fIsWatchonly = (*it).second.fIsWatchonly;\n         }\n \n-        if (fByAccounts)\n+        if (by_label)\n         {\n-            tallyitem& _item = mapAccountTally[strAccount];\n+            tallyitem& _item = label_tally[label];\n             _item.nAmount += nAmount;\n             _item.nConf = std::min(_item.nConf, nConf);\n             _item.fIsWatchonly = fIsWatchonly;\n@@ -1494,11 +1494,10 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             if(fIsWatchonly)\n                 obj.pushKV(\"involvesWatchonly\", true);\n             obj.pushKV(\"address\",       EncodeDestination(address));\n-            obj.pushKV(\"account\",       strAccount);\n+            obj.pushKV(\"account\",       label);\n             obj.pushKV(\"amount\",        ValueFromAmount(nAmount));\n             obj.pushKV(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf));\n-            if (!fByAccounts)\n-                obj.pushKV(\"label\", strAccount);\n+            obj.pushKV(\"label\", label);\n             UniValue transactions(UniValue::VARR);\n             if (it != mapTally.end())\n             {\n@@ -1512,9 +1511,9 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n         }\n     }\n \n-    if (fByAccounts)\n+    if (by_label)\n     {\n-        for (const auto& entry : mapAccountTally)\n+        for (const auto& entry : label_tally)\n         {\n             CAmount nAmount = entry.second.nAmount;\n             int nConf = entry.second.nConf;\n@@ -1524,6 +1523,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             obj.pushKV(\"account\",       entry.first);\n             obj.pushKV(\"amount\",        ValueFromAmount(nAmount));\n             obj.pushKV(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf));\n+            obj.pushKV(\"label\",         entry.first);\n             ret.push_back(obj);\n         }\n     }\n@@ -1552,10 +1552,10 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n             \"  {\\n\"\n             \"    \\\"involvesWatchonly\\\" : true,        (bool) Only returned if imported addresses were involved in transaction\\n\"\n             \"    \\\"address\\\" : \\\"receivingaddress\\\",  (string) The receiving address\\n\"\n-            \"    \\\"account\\\" : \\\"accountname\\\",       (string) DEPRECATED. The account of the receiving address. The default account is \\\"\\\".\\n\"\n+            \"    \\\"account\\\" : \\\"accountname\\\",       (string) DEPRECATED. Backwards compatible alias for label.\\n\"\n             \"    \\\"amount\\\" : x.xxx,                  (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n             \"    \\\"confirmations\\\" : n,               (numeric) The number of confirmations of the most recent transaction included\\n\"\n-            \"    \\\"label\\\" : \\\"label\\\",               (string) A comment for the address/transaction, if any\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\",               (string) The label of the receiving address. The default label is \\\"\\\".\\n\"\n             \"    \\\"txids\\\": [\\n\"\n             \"       n,                                (numeric) The ids of transactions received with the address \\n\"\n             \"       ...\\n\"\n@@ -1582,7 +1582,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n     return ListReceived(pwallet, request.params, false);\n }\n \n-UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n+UniValue listreceivedbylabel(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -1591,29 +1591,29 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() > 3)\n         throw std::runtime_error(\n-            \"listreceivedbyaccount ( minconf include_empty include_watchonly)\\n\"\n-            \"\\nDEPRECATED. List balances by account.\\n\"\n+            \"listreceivedbylabel ( minconf include_empty include_watchonly)\\n\"\n+            \"\\nList received transactions by label.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n-            \"2. include_empty     (bool, optional, default=false) Whether to include accounts that haven't received any payments.\\n\"\n+            \"2. include_empty     (bool, optional, default=false) Whether to include labels that haven't received any payments.\\n\"\n             \"3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').\\n\"\n \n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"involvesWatchonly\\\" : true,   (bool) Only returned if imported addresses were involved in transaction\\n\"\n-            \"    \\\"account\\\" : \\\"accountname\\\",  (string) The account name of the receiving account\\n\"\n-            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount received by addresses with this account\\n\"\n+            \"    \\\"account\\\" : \\\"accountname\\\",  (string) DEPRECATED. Backwards compatible alias for label.\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount received by addresses with this label\\n\"\n             \"    \\\"confirmations\\\" : n,          (numeric) The number of confirmations of the most recent transaction included\\n\"\n-            \"    \\\"label\\\" : \\\"label\\\"           (string) A comment for the address/transaction, if any\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\"           (string) The label of the receiving address. The default label is \\\"\\\".\\n\"\n             \"  }\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n \n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"\")\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n+            + HelpExampleCli(\"listreceivedbylabel\", \"\")\n+            + HelpExampleCli(\"listreceivedbylabel\", \"6 true\")\n+            + HelpExampleRpc(\"listreceivedbylabel\", \"6, true, true\")\n         );\n \n     ObserveSafeMode();\n@@ -2935,7 +2935,8 @@ UniValue listunspent(const JSONRPCRequest& request)\n             \"    \\\"txid\\\" : \\\"txid\\\",          (string) the transaction id \\n\"\n             \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n             \"    \\\"address\\\" : \\\"address\\\",    (string) the bitcoin address\\n\"\n-            \"    \\\"account\\\" : \\\"account\\\",    (string) DEPRECATED. The associated account, or \\\"\\\" for the default account\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\",        (string) The associated label, or \\\"\\\" for the default label\\n\"\n+            \"    \\\"account\\\" : \\\"account\\\",    (string) DEPRECATED. Backwards compatible alias for label.\\n\"\n             \"    \\\"scriptPubKey\\\" : \\\"key\\\",   (string) the script key\\n\"\n             \"    \\\"amount\\\" : x.xxx,         (numeric) the transaction output amount in \" + CURRENCY_UNIT + \"\\n\"\n             \"    \\\"confirmations\\\" : n,      (numeric) The number of confirmations\\n\"\n@@ -3039,6 +3040,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n             entry.pushKV(\"address\", EncodeDestination(address));\n \n             if (pwallet->mapAddressBook.count(address)) {\n+                entry.pushKV(\"label\", pwallet->mapAddressBook[address].name);\n                 entry.pushKV(\"account\", pwallet->mapAddressBook[address].name);\n             }\n \n@@ -3834,21 +3836,23 @@ static const CRPCCommand commands[] =\n     { \"hidden\",             \"resendwallettransactions\",         &resendwallettransactions,      {} },\n     { \"wallet\",             \"abandontransaction\",               &abandontransaction,            {\"txid\"} },\n     { \"wallet\",             \"abortrescan\",                      &abortrescan,                   {} },\n-    { \"wallet\",             \"addmultisigaddress\",               &addmultisigaddress,            {\"nrequired\",\"keys\",\"account\",\"address_type\"} },\n+    { \"wallet\",             \"addmultisigaddress\",               &addmultisigaddress,            {\"nrequired\",\"keys\",\"label|account\",\"address_type\"} },\n     { \"hidden\",             \"addwitnessaddress\",                &addwitnessaddress,             {\"address\",\"p2sh\"} },\n     { \"wallet\",             \"backupwallet\",                     &backupwallet,                  {\"destination\"} },\n     { \"wallet\",             \"bumpfee\",                          &bumpfee,                       {\"txid\", \"options\"} },\n     { \"wallet\",             \"dumpprivkey\",                      &dumpprivkey,                   {\"address\"}  },\n     { \"wallet\",             \"dumpwallet\",                       &dumpwallet,                    {\"filename\"} },\n     { \"wallet\",             \"encryptwallet\",                    &encryptwallet,                 {\"passphrase\"} },\n-    { \"wallet\",             \"getaccountaddress\",                &getaccountaddress,             {\"account\"} },\n+    { \"wallet\",             \"getlabeladdress\",                  &getlabeladdress,               {\"label\"} },\n+    { \"wallet\",             \"getaccountaddress\",                &getlabeladdress,               {\"account\"} },\n     { \"wallet\",             \"getaccount\",                       &getaccount,                    {\"address\"} },\n     { \"wallet\",             \"getaddressesbyaccount\",            &getaddressesbyaccount,         {\"account\"} },\n     { \"wallet\",             \"getaddressinfo\",                   &getaddressinfo,                {\"address\"} },\n     { \"wallet\",             \"getbalance\",                       &getbalance,                    {\"account\",\"minconf\",\"include_watchonly\"} },\n-    { \"wallet\",             \"getnewaddress\",                    &getnewaddress,                 {\"account\",\"address_type\"} },\n+    { \"wallet\",             \"getnewaddress\",                    &getnewaddress,                 {\"label|account\",\"address_type\"} },\n     { \"wallet\",             \"getrawchangeaddress\",              &getrawchangeaddress,           {\"address_type\"} },\n-    { \"wallet\",             \"getreceivedbyaccount\",             &getreceivedbyaccount,          {\"account\",\"minconf\"} },\n+    { \"wallet\",             \"getreceivedbylabel\",               &getreceivedbylabel,            {\"label\",\"minconf\"} },\n+    { \"wallet\",             \"getreceivedbyaccount\",             &getreceivedbylabel,            {\"account\",\"minconf\"} },\n     { \"wallet\",             \"getreceivedbyaddress\",             &getreceivedbyaddress,          {\"address\",\"minconf\"} },\n     { \"wallet\",             \"gettransaction\",                   &gettransaction,                {\"txid\",\"include_watchonly\"} },\n     { \"wallet\",             \"getunconfirmedbalance\",            &getunconfirmedbalance,         {} },\n@@ -3863,7 +3867,8 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listaccounts\",                     &listaccounts,                  {\"minconf\",\"include_watchonly\"} },\n     { \"wallet\",             \"listaddressgroupings\",             &listaddressgroupings,          {} },\n     { \"wallet\",             \"listlockunspent\",                  &listlockunspent,               {} },\n-    { \"wallet\",             \"listreceivedbyaccount\",            &listreceivedbyaccount,         {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listreceivedbylabel\",              &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listreceivedbyaccount\",            &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"listreceivedbyaddress\",            &listreceivedbyaddress,         {\"minconf\",\"include_empty\",\"include_watchonly\",\"address_filter\"} },\n     { \"wallet\",             \"listsinceblock\",                   &listsinceblock,                {\"blockhash\",\"target_confirmations\",\"include_watchonly\",\"include_removed\"} },\n     { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"account\",\"count\",\"skip\",\"include_watchonly\"} },\n@@ -3874,7 +3879,8 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"sendfrom\",                         &sendfrom,                      {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },\n     { \"wallet\",             \"sendmany\",                         &sendmany,                      {\"fromaccount\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n     { \"wallet\",             \"sendtoaddress\",                    &sendtoaddress,                 {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n-    { \"wallet\",             \"setaccount\",                       &setaccount,                    {\"address\",\"account\"} },\n+    { \"wallet\",             \"setlabel\",                         &setlabel,                      {\"address\",\"label\"} },\n+    { \"wallet\",             \"setaccount\",                       &setlabel,                      {\"address\",\"account\"} },\n     { \"wallet\",             \"settxfee\",                         &settxfee,                      {\"amount\"} },\n     { \"wallet\",             \"signmessage\",                      &signmessage,                   {\"address\",\"message\"} },\n     { \"wallet\",             \"signrawtransactionwithwallet\",     &signrawtransactionwithwallet,  {\"hexstring\",\"prevtxs\",\"sighashtype\"} },"
      },
      {
        "sha": "4cd083a9c4858536761bbba955805aa58fef19a1",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -809,12 +809,12 @@ bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmoun\n     return true;\n }\n \n-bool CWallet::GetAccountDestination(CTxDestination &dest, std::string strAccount, bool bForceNew)\n+bool CWallet::GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew)\n {\n     CWalletDB walletdb(*dbw);\n \n     CAccount account;\n-    walletdb.ReadAccount(strAccount, account);\n+    walletdb.ReadAccount(label, account);\n \n     if (!bForceNew) {\n         if (!account.vchPubKey.IsValid())\n@@ -840,8 +840,8 @@ bool CWallet::GetAccountDestination(CTxDestination &dest, std::string strAccount\n \n         LearnRelatedScripts(account.vchPubKey, m_default_address_type);\n         dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n-        SetAddressBook(dest, strAccount, \"receive\");\n-        walletdb.WriteAccount(strAccount, account);\n+        SetAddressBook(dest, label, \"receive\");\n+        walletdb.WriteAccount(label, account);\n     } else {\n         dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n     }\n@@ -2220,7 +2220,7 @@ CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, cons\n         for (const CTxOut& out : wtx.tx->vout) {\n             if (outgoing && IsChange(out)) {\n                 debit -= out.nValue;\n-            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetAccountName(out.scriptPubKey))) {\n+            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetLabelName(out.scriptPubKey))) {\n                 balance += out.nValue;\n             }\n         }\n@@ -3251,7 +3251,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n     return CWalletDB(*dbw).EraseName(EncodeDestination(address));\n }\n \n-const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n+const std::string& CWallet::GetLabelName(const CScript& scriptPubKey) const\n {\n     CTxDestination address;\n     if (ExtractDestination(scriptPubKey, address) && !scriptPubKey.IsUnspendable()) {\n@@ -3261,9 +3261,9 @@ const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n         }\n     }\n     // A scriptPubKey that doesn't have an entry in the address book is\n-    // associated with the default account (\"\").\n-    const static std::string DEFAULT_ACCOUNT_NAME;\n-    return DEFAULT_ACCOUNT_NAME;\n+    // associated with the default label (\"\").\n+    const static std::string DEFAULT_LABEL_NAME;\n+    return DEFAULT_LABEL_NAME;\n }\n \n /**\n@@ -3619,15 +3619,15 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n     return ret;\n }\n \n-std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n+std::set<CTxDestination> CWallet::GetLabelAddresses(const std::string& label) const\n {\n     LOCK(cs_wallet);\n     std::set<CTxDestination> result;\n     for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n         const std::string& strName = item.second.name;\n-        if (strName == strAccount)\n+        if (strName == label)\n             result.insert(address);\n     }\n     return result;"
      },
      {
        "sha": "34902ec85ea2e642b51b489757f6266b2aefcdc2",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -929,7 +929,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     int64_t IncOrderPosNext(CWalletDB *pwalletdb = nullptr);\n     DBErrors ReorderTransactions();\n     bool AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment = \"\");\n-    bool GetAccountDestination(CTxDestination &dest, std::string strAccount, bool bForceNew = false);\n+    bool GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew = false);\n \n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose=true);\n@@ -1007,7 +1007,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::set< std::set<CTxDestination> > GetAddressGroupings();\n     std::map<CTxDestination, CAmount> GetAddressBalances();\n \n-    std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n+    std::set<CTxDestination> GetLabelAddresses(const std::string& label) const;\n \n     isminetype IsMine(const CTxIn& txin) const;\n     /**\n@@ -1037,7 +1037,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     bool DelAddressBook(const CTxDestination& address);\n \n-    const std::string& GetAccountName(const CScript& scriptPubKey) const;\n+    const std::string& GetLabelName(const CScript& scriptPubKey) const;\n \n     void Inventory(const uint256 &hash) override\n     {"
      },
      {
        "sha": "b2695e681f78a02c4462e5cb78ee64c7bfb58a13",
        "filename": "test/functional/wallet_accounts.py",
        "status": "modified",
        "additions": 82,
        "deletions": 82,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/test/functional/wallet_accounts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/test/functional/wallet_accounts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_accounts.py?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -2,21 +2,21 @@\n # Copyright (c) 2016-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test account RPCs.\n+\"\"\"Test label RPCs.\n \n RPCs tested are:\n-    - getaccountaddress\n+    - getlabeladdress\n     - getaddressesbyaccount\n     - listaddressgroupings\n-    - setaccount\n+    - setlabel\n     - sendfrom (with account arguments)\n     - move (with account arguments)\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n \n-class WalletAccountsTest(BitcoinTestFramework):\n+class WalletLabelsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n@@ -68,97 +68,97 @@ def run_test(self):\n \n         node.generate(1)\n \n-        # we want to reset so that the \"\" account has what's expected.\n+        # we want to reset so that the \"\" label has what's expected.\n         # otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n         node.sendfrom(\"\", common_address, fee)\n         amount_to_send = 1.0\n \n-        # Create accounts and make sure subsequent account API calls\n-        # recognize the account/address associations.\n-        accounts = [Account(name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n-        for account in accounts:\n-            account.add_receive_address(node.getaccountaddress(account.name))\n-            account.verify(node)\n+        # Create labels and make sure subsequent label API calls\n+        # recognize the label/address associations.\n+        labels = [Label(name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n+        for label in labels:\n+            label.add_receive_address(node.getlabeladdress(label.name))\n+            label.verify(node)\n \n-        # Send a transaction to each account, and make sure this forces\n-        # getaccountaddress to generate a new receiving address.\n-        for account in accounts:\n-            node.sendtoaddress(account.receive_address, amount_to_send)\n-            account.add_receive_address(node.getaccountaddress(account.name))\n-            account.verify(node)\n+        # Send a transaction to each label, and make sure this forces\n+        # getlabeladdress to generate a new receiving address.\n+        for label in labels:\n+            node.sendtoaddress(label.receive_address, amount_to_send)\n+            label.add_receive_address(node.getlabeladdress(label.name))\n+            label.verify(node)\n \n         # Check the amounts received.\n         node.generate(1)\n-        for account in accounts:\n+        for label in labels:\n             assert_equal(\n-                node.getreceivedbyaddress(account.addresses[0]), amount_to_send)\n-            assert_equal(node.getreceivedbyaccount(account.name), amount_to_send)\n-        \n-        # Check that sendfrom account reduces listaccounts balances.\n-        for i, account in enumerate(accounts):\n-            to_account = accounts[(i+1) % len(accounts)]\n-            node.sendfrom(account.name, to_account.receive_address, amount_to_send)\n+                node.getreceivedbyaddress(label.addresses[0]), amount_to_send)\n+            assert_equal(node.getreceivedbylabel(label.name), amount_to_send)\n+\n+        # Check that sendfrom label reduces listaccounts balances.\n+        for i, label in enumerate(labels):\n+            to_label = labels[(i+1) % len(labels)]\n+            node.sendfrom(label.name, to_label.receive_address, amount_to_send)\n         node.generate(1)\n-        for account in accounts:\n-            account.add_receive_address(node.getaccountaddress(account.name))\n-            account.verify(node)\n-            assert_equal(node.getreceivedbyaccount(account.name), 2)\n-            node.move(account.name, \"\", node.getbalance(account.name))\n-            account.verify(node)\n+        for label in labels:\n+            label.add_receive_address(node.getlabeladdress(label.name))\n+            label.verify(node)\n+            assert_equal(node.getreceivedbylabel(label.name), 2)\n+            node.move(label.name, \"\", node.getbalance(label.name))\n+            label.verify(node)\n         node.generate(101)\n         expected_account_balances = {\"\": 5200}\n-        for account in accounts:\n-            expected_account_balances[account.name] = 0\n+        for label in labels:\n+            expected_account_balances[label.name] = 0\n         assert_equal(node.listaccounts(), expected_account_balances)\n         assert_equal(node.getbalance(\"\"), 5200)\n-        \n-        # Check that setaccount can assign an account to a new unused address.\n-        for account in accounts:\n-            address = node.getaccountaddress(\"\")\n-            node.setaccount(address, account.name)\n-            account.add_address(address)\n-            account.verify(node)\n+\n+        # Check that setlabel can assign a label to a new unused address.\n+        for label in labels:\n+            address = node.getlabeladdress(\"\")\n+            node.setlabel(address, label.name)\n+            label.add_address(address)\n+            label.verify(node)\n             assert(address not in node.getaddressesbyaccount(\"\"))\n-        \n-        # Check that addmultisigaddress can assign accounts.\n-        for account in accounts:\n+\n+        # Check that addmultisigaddress can assign labels.\n+        for label in labels:\n             addresses = []\n             for x in range(10):\n                 addresses.append(node.getnewaddress())\n-            multisig_address = node.addmultisigaddress(5, addresses, account.name)['address']\n-            account.add_address(multisig_address)\n-            account.verify(node)\n+            multisig_address = node.addmultisigaddress(5, addresses, label.name)['address']\n+            label.add_address(multisig_address)\n+            label.verify(node)\n             node.sendfrom(\"\", multisig_address, 50)\n         node.generate(101)\n-        for account in accounts:\n-            assert_equal(node.getbalance(account.name), 50)\n+        for label in labels:\n+            assert_equal(node.getbalance(label.name), 50)\n \n-        # Check that setaccount can change the account of an address from a\n-        # different account.\n-        change_account(node, accounts[0].addresses[0], accounts[0], accounts[1])\n+        # Check that setlabel can change the label of an address from a\n+        # different label.\n+        change_label(node, labels[0].addresses[0], labels[0], labels[1])\n \n-        # Check that setaccount can change the account of an address which\n-        # is the receiving address of a different account.\n-        change_account(node, accounts[0].receive_address, accounts[0], accounts[1])\n+        # Check that setlabel can change the label of an address which\n+        # is the receiving address of a different label.\n+        change_label(node, labels[0].receive_address, labels[0], labels[1])\n \n-        # Check that setaccount can set the account of an address already\n-        # in the account. This is a no-op.\n-        change_account(node, accounts[2].addresses[0], accounts[2], accounts[2])\n+        # Check that setlabel can set the label of an address already\n+        # in the label. This is a no-op.\n+        change_label(node, labels[2].addresses[0], labels[2], labels[2])\n \n-        # Check that setaccount can set the account of an address which is\n-        # already the receiving address of the account. It would probably make\n+        # Check that setlabel can set the label of an address which is\n+        # already the receiving address of the label. It would probably make\n         # sense for this to be a no-op, but right now it resets the receiving\n-        # address, causing getaccountaddress to return a brand new address.\n-        change_account(node, accounts[2].receive_address, accounts[2], accounts[2])\n+        # address, causing getlabeladdress to return a brand new address.\n+        change_label(node, labels[2].receive_address, labels[2], labels[2])\n \n-class Account:\n+class Label:\n     def __init__(self, name):\n-        # Account name\n+        # Label name\n         self.name = name\n-        # Current receiving address associated with this account.\n+        # Current receiving address associated with this label.\n         self.receive_address = None\n-        # List of all addresses assigned with this account\n+        # List of all addresses assigned with this label\n         self.addresses = []\n \n     def add_address(self, address):\n@@ -172,7 +172,7 @@ def add_receive_address(self, address):\n     def verify(self, node):\n         if self.receive_address is not None:\n             assert self.receive_address in self.addresses\n-            assert_equal(node.getaccountaddress(self.name), self.receive_address)\n+            assert_equal(node.getlabeladdress(self.name), self.receive_address)\n \n         for address in self.addresses:\n             assert_equal(node.getaccount(address), self.name)\n@@ -181,26 +181,26 @@ def verify(self, node):\n             set(node.getaddressesbyaccount(self.name)), set(self.addresses))\n \n \n-def change_account(node, address, old_account, new_account):\n-    assert_equal(address in old_account.addresses, True)\n-    node.setaccount(address, new_account.name)\n+def change_label(node, address, old_label, new_label):\n+    assert_equal(address in old_label.addresses, True)\n+    node.setlabel(address, new_label.name)\n \n-    old_account.addresses.remove(address)\n-    new_account.add_address(address)\n+    old_label.addresses.remove(address)\n+    new_label.add_address(address)\n \n-    # Calling setaccount on an address which was previously the receiving\n-    # address of a different account should reset the receiving address of\n-    # the old account, causing getaccountaddress to return a brand new\n+    # Calling setlabel on an address which was previously the receiving\n+    # address of a different label should reset the receiving address of\n+    # the old label, causing getlabeladdress to return a brand new\n     # address.\n-    if address == old_account.receive_address:\n-        new_address = node.getaccountaddress(old_account.name)\n-        assert_equal(new_address not in old_account.addresses, True)\n-        assert_equal(new_address not in new_account.addresses, True)\n-        old_account.add_receive_address(new_address)\n+    if address == old_label.receive_address:\n+        new_address = node.getlabeladdress(old_label.name)\n+        assert_equal(new_address not in old_label.addresses, True)\n+        assert_equal(new_address not in new_label.addresses, True)\n+        old_label.add_receive_address(new_address)\n \n-    old_account.verify(node)\n-    new_account.verify(node)\n+    old_label.verify(node)\n+    new_label.verify(node)\n \n \n if __name__ == '__main__':\n-    WalletAccountsTest().main()\n+    WalletLabelsTest().main()"
      },
      {
        "sha": "b66e9b5d91bbbb00269cb7ad7fe03dc66ba43d94",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -78,7 +78,7 @@ def check(self, txid=None, amount=None, confirmations=None):\n \n         if txid is not None:\n             tx, = [tx for tx in txs if tx[\"txid\"] == txid]\n-            assert_equal(tx[\"account\"], self.label)\n+            assert_equal(tx[\"label\"], self.label)\n             assert_equal(tx[\"address\"], self.address[\"address\"])\n             assert_equal(tx[\"amount\"], amount)\n             assert_equal(tx[\"category\"], \"receive\")"
      },
      {
        "sha": "a4754852edd98ac2e2e8bc818d1737e6ebec76d7",
        "filename": "test/functional/wallet_listreceivedby.py",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/045eeb887092a631d49194e743859b1da84c1d5d/test/functional/wallet_listreceivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/045eeb887092a631d49194e743859b1da84c1d5d/test/functional/wallet_listreceivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listreceivedby.py?ref=045eeb887092a631d49194e743859b1da84c1d5d",
        "patch": "@@ -36,23 +36,23 @@ def run_test(self):\n         self.sync_all()\n         assert_array_result(self.nodes[1].listreceivedbyaddress(),\n                             {\"address\": addr},\n-                            {\"address\": addr, \"account\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 10, \"txids\": [txid, ]})\n+                            {\"address\": addr, \"label\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 10, \"txids\": [txid, ]})\n         # With min confidence < 10\n         assert_array_result(self.nodes[1].listreceivedbyaddress(5),\n                             {\"address\": addr},\n-                            {\"address\": addr, \"account\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 10, \"txids\": [txid, ]})\n+                            {\"address\": addr, \"label\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 10, \"txids\": [txid, ]})\n         # With min confidence > 10, should not find Tx\n         assert_array_result(self.nodes[1].listreceivedbyaddress(11), {\"address\": addr}, {}, True)\n \n         # Empty Tx\n         empty_addr = self.nodes[1].getnewaddress()\n         assert_array_result(self.nodes[1].listreceivedbyaddress(0, True),\n                             {\"address\": empty_addr},\n-                            {\"address\": empty_addr, \"account\": \"\", \"amount\": 0, \"confirmations\": 0, \"txids\": []})\n+                            {\"address\": empty_addr, \"label\": \"\", \"amount\": 0, \"confirmations\": 0, \"txids\": []})\n \n         #Test Address filtering\n         #Only on addr\n-        expected = {\"address\":addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]}\n+        expected = {\"address\":addr, \"label\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]}\n         res = self.nodes[1].listreceivedbyaddress(minconf=0, include_empty=True, include_watchonly=True, address_filter=addr)\n         assert_array_result(res, {\"address\":addr}, expected)\n         assert_equal(len(res), 1)\n@@ -66,12 +66,12 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n         #Same test as above should still pass\n-        expected = {\"address\":addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":11, \"txids\":[txid,]}\n+        expected = {\"address\":addr, \"label\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":11, \"txids\":[txid,]}\n         res = self.nodes[1].listreceivedbyaddress(0, True, True, addr)\n         assert_array_result(res, {\"address\":addr}, expected)\n         assert_equal(len(res), 1)\n         #Same test as above but with other_addr should still pass\n-        expected = {\"address\":other_addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":1, \"txids\":[txid2,]}\n+        expected = {\"address\":other_addr, \"label\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":1, \"txids\":[txid2,]}\n         res = self.nodes[1].listreceivedbyaddress(0, True, True, other_addr)\n         assert_array_result(res, {\"address\":other_addr}, expected)\n         assert_equal(len(res), 1)\n@@ -108,46 +108,46 @@ def run_test(self):\n         # Trying to getreceivedby for an address the wallet doesn't own should return an error\n         assert_raises_rpc_error(-4, \"Address not found in wallet\", self.nodes[0].getreceivedbyaddress, addr)\n \n-        self.log.info(\"listreceivedbyaccount + getreceivedbyaccount Test\")\n+        self.log.info(\"listreceivedbylabel + getreceivedbylabel Test\")\n \n         # set pre-state\n         addrArr = self.nodes[1].getnewaddress()\n-        account = self.nodes[1].getaccount(addrArr)\n-        received_by_account_json = [r for r in self.nodes[1].listreceivedbyaccount() if r[\"account\"] == account][0]\n-        balance_by_account = self.nodes[1].getreceivedbyaccount(account)\n+        label = self.nodes[1].getaccount(addrArr)\n+        received_by_label_json = [r for r in self.nodes[1].listreceivedbylabel() if r[\"label\"] == label][0]\n+        balance_by_label = self.nodes[1].getreceivedbylabel(label)\n \n         txid = self.nodes[0].sendtoaddress(addr, 0.1)\n         self.sync_all()\n \n-        # listreceivedbyaccount should return received_by_account_json because of 0 confirmations\n-        assert_array_result(self.nodes[1].listreceivedbyaccount(),\n-                            {\"account\": account},\n-                            received_by_account_json)\n+        # listreceivedbylabel should return received_by_label_json because of 0 confirmations\n+        assert_array_result(self.nodes[1].listreceivedbylabel(),\n+                            {\"label\": label},\n+                            received_by_label_json)\n \n         # getreceivedbyaddress should return same balance because of 0 confirmations\n-        balance = self.nodes[1].getreceivedbyaccount(account)\n-        assert_equal(balance, balance_by_account)\n+        balance = self.nodes[1].getreceivedbylabel(label)\n+        assert_equal(balance, balance_by_label)\n \n         self.nodes[1].generate(10)\n         self.sync_all()\n-        # listreceivedbyaccount should return updated account balance\n-        assert_array_result(self.nodes[1].listreceivedbyaccount(),\n-                            {\"account\": account},\n-                            {\"account\": received_by_account_json[\"account\"], \"amount\": (received_by_account_json[\"amount\"] + Decimal(\"0.1\"))})\n+        # listreceivedbylabel should return updated received list\n+        assert_array_result(self.nodes[1].listreceivedbylabel(),\n+                            {\"label\": label},\n+                            {\"label\": received_by_label_json[\"label\"], \"amount\": (received_by_label_json[\"amount\"] + Decimal(\"0.1\"))})\n \n-        # getreceivedbyaddress should return updates balance\n-        balance = self.nodes[1].getreceivedbyaccount(account)\n-        assert_equal(balance, balance_by_account + Decimal(\"0.1\"))\n+        # getreceivedbylabel should return updated receive total\n+        balance = self.nodes[1].getreceivedbylabel(label)\n+        assert_equal(balance, balance_by_label + Decimal(\"0.1\"))\n \n-        # Create a new account named \"mynewaccount\" that has a 0 balance\n-        self.nodes[1].getaccountaddress(\"mynewaccount\")\n-        received_by_account_json = [r for r in self.nodes[1].listreceivedbyaccount(0, True) if r[\"account\"] == \"mynewaccount\"][0]\n+        # Create a new label named \"mynewlabel\" that has a 0 balance\n+        self.nodes[1].getlabeladdress(\"mynewlabel\")\n+        received_by_label_json = [r for r in self.nodes[1].listreceivedbylabel(0, True) if r[\"label\"] == \"mynewlabel\"][0]\n \n-        # Test includeempty of listreceivedbyaccount\n-        assert_equal(received_by_account_json[\"amount\"], Decimal(\"0.0\"))\n+        # Test includeempty of listreceivedbylabel\n+        assert_equal(received_by_label_json[\"amount\"], Decimal(\"0.0\"))\n \n-        # Test getreceivedbyaccount for 0 amount accounts\n-        balance = self.nodes[1].getreceivedbyaccount(\"mynewaccount\")\n+        # Test getreceivedbylabel for 0 amount labels\n+        balance = self.nodes[1].getreceivedbylabel(\"mynewlabel\")\n         assert_equal(balance, Decimal(\"0.0\"))\n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "d2527bd54e994747d9e24043c91d46c7219d46ac",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMjUyN2JkNTRlOTk0NzQ3ZDllMjQwNDNjOTFkNDZjNzIxOWQ0NmFj",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-10-20T17:27:55Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-03-19T16:05:35Z"
      },
      "message": "Rename wallet_accounts.py test\n\nThis is a separate commit because changing the test at the same time as\nrenaming it breaks git (and github) rename detection.",
      "tree": {
        "sha": "2ebe66500b64aa9a08a387416f2a48b46334061a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ebe66500b64aa9a08a387416f2a48b46334061a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2527bd54e994747d9e24043c91d46c7219d46ac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2527bd54e994747d9e24043c91d46c7219d46ac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2527bd54e994747d9e24043c91d46c7219d46ac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2527bd54e994747d9e24043c91d46c7219d46ac/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "045eeb887092a631d49194e743859b1da84c1d5d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/045eeb887092a631d49194e743859b1da84c1d5d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/045eeb887092a631d49194e743859b1da84c1d5d"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a2eaf99146607f96daf7224c1de7d02f3855692a",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2527bd54e994747d9e24043c91d46c7219d46ac/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2527bd54e994747d9e24043c91d46c7219d46ac/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=d2527bd54e994747d9e24043c91d46c7219d46ac",
        "patch": "@@ -67,7 +67,7 @@\n     'feature_segwit.py',\n     # vv Tests less than 2m vv\n     'wallet_basic.py',\n-    'wallet_accounts.py',\n+    'wallet_labels.py',\n     'p2p_segwit.py',\n     'wallet_dump.py',\n     'rpc_listtransactions.py',"
      },
      {
        "sha": "b2695e681f78a02c4462e5cb78ee64c7bfb58a13",
        "filename": "test/functional/wallet_labels.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2527bd54e994747d9e24043c91d46c7219d46ac/test/functional/wallet_labels.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2527bd54e994747d9e24043c91d46c7219d46ac/test/functional/wallet_labels.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_labels.py?ref=d2527bd54e994747d9e24043c91d46c7219d46ac",
        "previous_filename": "test/functional/wallet_accounts.py"
      }
    ]
  }
]