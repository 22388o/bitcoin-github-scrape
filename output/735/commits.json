[
  {
    "sha": "67a42f929b1434f647c63922fd02dc2b93b28060",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2N2E0MmY5MjliMTQzNGY2NDdjNjM5MjJmZDAyZGMyYjkzYjI4MDYw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-01-03T22:33:31Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-01-06T17:55:37Z"
      },
      "message": "Network stack refactor\n\nThis introduces CNetAddr and CService, respectively wrapping an\n(IPv6) IP address and an IP+port combination. This functionality used\nto be part of CAddress, which also contains network flags and\nconnection attempt information. These extra fields are however not\nalways necessary.\n\nThese classes, along with logic for creating connections and doing\nname lookups, are moved to netbase.{h,cpp}, which does not depend on\nheaders.h.\n\nFurthermore, CNetAddr is mostly IPv6-ready, though IPv6\nfunctionality is not yet enabled for the application itself.",
      "tree": {
        "sha": "9c4313e815bd77e817f2dc5b796347d343458d0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c4313e815bd77e817f2dc5b796347d343458d0e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67a42f929b1434f647c63922fd02dc2b93b28060",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67a42f929b1434f647c63922fd02dc2b93b28060",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/67a42f929b1434f647c63922fd02dc2b93b28060",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67a42f929b1434f647c63922fd02dc2b93b28060/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7486c64dd8436febbe59e82dbb875e83ad6b5194",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7486c64dd8436febbe59e82dbb875e83ad6b5194",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7486c64dd8436febbe59e82dbb875e83ad6b5194"
      }
    ],
    "stats": {
      "total": 1587,
      "additions": 1041,
      "deletions": 546
    },
    "files": [
      {
        "sha": "71ee1fee6ee6d4d1b8138c71010638e0e3ddab3f",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -97,6 +97,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/base58.h \\\n     src/bignum.h \\\n     src/checkpoints.h \\\n+    src/compat.h \\\n     src/util.h \\\n     src/uint256.h \\\n     src/serialize.h \\\n@@ -156,6 +157,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/editaddressdialog.cpp \\\n     src/qt/bitcoinaddressvalidator.cpp \\\n     src/util.cpp \\\n+    src/netbase.cpp \\\n     src/key.cpp \\\n     src/script.cpp \\\n     src/main.cpp \\"
      },
      {
        "sha": "5c1fcc3d6eeb10e7fdada068f7415116a5c3d581",
        "filename": "src/compat.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -0,0 +1,42 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2011 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef _BITCOIN_COMPAT_H\n+#define _BITCOIN_COMPAT_H 1\n+\n+typedef u_int SOCKET;\n+#ifdef WIN32\n+#define MSG_NOSIGNAL        0\n+#define MSG_DONTWAIT        0\n+typedef int socklen_t;\n+#else\n+#include \"errno.h\"\n+#define WSAGetLastError()   errno\n+#define WSAEINVAL           EINVAL\n+#define WSAEALREADY         EALREADY\n+#define WSAEWOULDBLOCK      EWOULDBLOCK\n+#define WSAEMSGSIZE         EMSGSIZE\n+#define WSAEINTR            EINTR\n+#define WSAEINPROGRESS      EINPROGRESS\n+#define WSAEADDRINUSE       EADDRINUSE\n+#define WSAENOTSOCK         EBADF\n+#define INVALID_SOCKET      (SOCKET)(~0)\n+#define SOCKET_ERROR        -1\n+#endif\n+\n+inline int myclosesocket(SOCKET& hSocket)\n+{\n+    if (hSocket == INVALID_SOCKET)\n+        return WSAENOTSOCK;\n+#ifdef WIN32\n+    int ret = closesocket(hSocket);\n+#else\n+    int ret = close(hSocket);\n+#endif\n+    hSocket = INVALID_SOCKET;\n+    return ret;\n+}\n+#define closesocket(s)      myclosesocket(s)\n+\n+#endif"
      },
      {
        "sha": "6a2a3e4ca48d15dce642437563feeafd961bf716",
        "filename": "src/headers.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/headers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/headers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/headers.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -12,7 +12,7 @@\n #ifdef _WIN32_WINNT\n #undef _WIN32_WINNT\n #endif\n-#define _WIN32_WINNT 0x0500\n+#define _WIN32_WINNT 0x0501\n #ifdef _WIN32_IE\n #undef _WIN32_IE\n #endif"
      },
      {
        "sha": "7c33448971da8e7e9a3fbfd852453686cfc7e0da",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -470,7 +470,7 @@ bool AppInit2(int argc, char* argv[])\n         }\n     }\n \n-    bool fTor = (fUseProxy && addrProxy.port == htons(9050));\n+    bool fTor = (fUseProxy && addrProxy.GetPort() == 9050);\n     if (fTor)\n     {\n         // Use SoftSetArg here so user can override any of these if they wish."
      },
      {
        "sha": "8805c7fd5b14582d3882e919e00fb39c5638b767",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 17,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -22,22 +22,25 @@ void ThreadIRCSeed2(void* parg);\n #pragma pack(push, 1)\n struct ircaddr\n {\n-    int ip;\n+    struct in_addr ip;\n     short port;\n };\n #pragma pack(pop)\n \n-string EncodeAddress(const CAddress& addr)\n+string EncodeAddress(const CService& addr)\n {\n     struct ircaddr tmp;\n-    tmp.ip    = addr.ip;\n-    tmp.port  = addr.port;\n+    if (addr.GetInAddr(&tmp.ip))\n+    {\n+        tmp.port = htons(addr.GetPort());\n \n-    vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n-    return string(\"u\") + EncodeBase58Check(vch);\n+        vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n+        return string(\"u\") + EncodeBase58Check(vch);\n+    }\n+    return \"\";\n }\n \n-bool DecodeAddress(string str, CAddress& addr)\n+bool DecodeAddress(string str, CService& addr)\n {\n     vector<unsigned char> vch;\n     if (!DecodeBase58Check(str.substr(1), vch))\n@@ -48,7 +51,7 @@ bool DecodeAddress(string str, CAddress& addr)\n         return false;\n     memcpy(&tmp, &vch[0], sizeof(tmp));\n \n-    addr = CAddress(tmp.ip, ntohs(tmp.port), NODE_NETWORK);\n+    addr = CService(tmp.ip, ntohs(tmp.port));\n     return true;\n }\n \n@@ -204,7 +207,7 @@ bool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n     }\n }\n \n-bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n+bool GetIPFromIRC(SOCKET hSocket, string strMyName, CNetAddr& ipRet)\n {\n     Send(hSocket, strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str());\n \n@@ -227,10 +230,10 @@ bool GetIPFromIRC(SOCKET hSocket, string strMyName, unsigned int& ipRet)\n     printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n     if (fUseProxy)\n         return false;\n-    CAddress addr(strHost, 0, true);\n+    CNetAddr addr(strHost, true);\n     if (!addr.IsValid())\n         return false;\n-    ipRet = addr.ip;\n+    ipRet = addr;\n \n     return true;\n }\n@@ -267,9 +270,9 @@ void ThreadIRCSeed2(void* parg)\n \n     while (!fShutdown)\n     {\n-        CAddress addrConnect(\"92.243.23.21\", 6667); // irc.lfnet.org\n+        CService addrConnect(\"92.243.23.21\", 6667); // irc.lfnet.org\n \n-        CAddress addrIRC(\"irc.lfnet.org\", 6667, true);\n+        CService addrIRC(\"irc.lfnet.org\", 6667, true);\n         if (addrIRC.IsValid())\n             addrConnect = addrIRC;\n \n@@ -325,15 +328,15 @@ void ThreadIRCSeed2(void* parg)\n         Sleep(500);\n \n         // Get our external IP from the IRC server and re-nick before joining the channel\n-        CAddress addrFromIRC;\n-        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC.ip))\n+        CNetAddr addrFromIRC;\n+        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n         {\n-            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToStringIP().c_str());\n+            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n             if (!fUseProxy && addrFromIRC.IsRoutable())\n             {\n                 // IRC lets you to re-nick\n                 fGotExternalIP = true;\n-                addrLocalHost.ip = addrFromIRC.ip;\n+                addrLocalHost.SetIP(addrFromIRC);\n                 strMyName = EncodeAddress(addrLocalHost);\n                 Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n             }"
      },
      {
        "sha": "9a3ce653909f332cb3da6889dcedfbcb0304e944",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -1931,7 +1931,7 @@ unsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n \n bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n {\n-    static map<unsigned int, vector<unsigned char> > mapReuseKey;\n+    static map<CService, vector<unsigned char> > mapReuseKey;\n     RandAddSeedPerfmon();\n     if (fDebug) {\n         printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n@@ -1987,7 +1987,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n-        AddTimeData(pfrom->addr.ip, nTime);\n+        AddTimeData(pfrom->addr, nTime);\n \n         // Change version\n         if (pfrom->nVersion >= 209)\n@@ -2093,7 +2093,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     static uint256 hashSalt;\n                     if (hashSalt == 0)\n                         RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n-                    uint256 hashRand = hashSalt ^ (((int64)addr.ip)<<32) ^ ((GetTime()+addr.ip)/(24*60*60));\n+                    int64 hashAddr = addr.GetHash();\n+                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                     hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                     multimap<uint256, CNode*> mapMix;\n                     BOOST_FOREACH(CNode* pnode, vNodes)\n@@ -2392,12 +2393,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         /// we have a chance to check the order here\n \n         // Keep giving the same key to the same ip until they use it\n-        if (!mapReuseKey.count(pfrom->addr.ip))\n-            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr.ip], true);\n+        if (!mapReuseKey.count(pfrom->addr))\n+            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n \n         // Send back approval of order and pubkey to use\n         CScript scriptPubKey;\n-        scriptPubKey << mapReuseKey[pfrom->addr.ip] << OP_CHECKSIG;\n+        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n         pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n     }\n "
      },
      {
        "sha": "d837691f89d7723241e764ed5aa429cb4e6df8d8",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -33,6 +33,7 @@ HEADERS = \\\n     base58.h \\\n     bignum.h \\\n     checkpoints.h \\\n+    compat.h \\\n     crypter.h \\\n     db.h \\\n     headers.h \\\n@@ -63,6 +64,7 @@ LIBS += -l mingwthrd -l kernel32 -l user32 -l gdi32 -l comdlg32 -l winspool -l w\n \n OBJS= \\\n     obj/checkpoints.o \\\n+    obj/netbase.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "ac1e4c75fd2067ee725b0d6706c6138c15409328",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -30,6 +30,7 @@ HEADERS = \\\n     base58.h \\\n     bignum.h \\\n     checkpoints.h \\\n+    compat.h \\\n     crypter.h \\\n     db.h \\\n     headers.h \\\n@@ -60,6 +61,7 @@ LIBS += -l kernel32 -l user32 -l gdi32 -l comdlg32 -l winspool -l winmm -l shell\n \n OBJS= \\\n     obj/checkpoints.o \\\n+    obj/netbase.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "4c124e6f33568550251426224c9a9c04d73d0b50",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -51,6 +51,7 @@ HEADERS = \\\n     base58.h \\\n     bignum.h \\\n     checkpoints.h \\\n+    compat.h \\\n     crypter.h \\\n     db.h \\\n     headers.h \\\n@@ -72,6 +73,7 @@ HEADERS = \\\n \n OBJS= \\\n     obj/checkpoints.o \\\n+    obj/netbase.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "8b41b74a1b26f48936a65e862e62e46eaca37f6b",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -88,6 +88,7 @@ HEADERS = \\\n     base58.h \\\n     bignum.h \\\n     checkpoints.h \\\n+    compat.h \\\n     crypter.h \\\n     db.h \\\n     headers.h \\\n@@ -109,6 +110,7 @@ HEADERS = \\\n \n OBJS= \\\n     obj/checkpoints.o \\\n+    obj/netbase.o \\\n     obj/crypter.o \\\n     obj/key.o \\\n     obj/db.o \\"
      },
      {
        "sha": "72897687ef865a1641b83bea9b0ecda368bf671c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 258,
        "changes": 308,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -45,7 +45,7 @@ bool OpenNetworkConnection(const CAddress& addrConnect);\n bool fClient = false;\n bool fAllowDNS = false;\n uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);\n-CAddress addrLocalHost(\"0.0.0.0\", 0, false, nLocalServices);\n+CAddress addrLocalHost(CService(\"0.0.0.0\", 0), nLocalServices);\n static CNode* pnodeLocalHost = NULL;\n uint64 nLocalHostNonce = 0;\n array<int, 10> vnThreadsRunning;\n@@ -60,10 +60,6 @@ deque<pair<int64, CInv> > vRelayExpiration;\n CCriticalSection cs_mapRelay;\n map<CInv, int64> mapAlreadyAskedFor;\n \n-// Settings\n-int fUseProxy = false;\n-int nConnectTimeout = 5000;\n-CAddress addrProxy(\"127.0.0.1\",9050);\n \n \n \n@@ -88,213 +84,7 @@ void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n \n \n \n-bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout)\n-{\n-    hSocketRet = INVALID_SOCKET;\n-\n-    SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n-    if (hSocket == INVALID_SOCKET)\n-        return false;\n-#ifdef SO_NOSIGPIPE\n-    int set = 1;\n-    setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n-#endif\n-\n-    bool fProxy = (fUseProxy && addrConnect.IsRoutable());\n-    struct sockaddr_in sockaddr = (fProxy ? addrProxy.GetSockAddr() : addrConnect.GetSockAddr());\n-\n-#ifdef WIN32\n-    u_long fNonblock = 1;\n-    if (ioctlsocket(hSocket, FIONBIO, &fNonblock) == SOCKET_ERROR)\n-#else\n-    int fFlags = fcntl(hSocket, F_GETFL, 0);\n-    if (fcntl(hSocket, F_SETFL, fFlags | O_NONBLOCK) == -1)\n-#endif\n-    {\n-        closesocket(hSocket);\n-        return false;\n-    }\n-\n-\n-    if (connect(hSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n-    {\n-        // WSAEINVAL is here because some legacy version of winsock uses it\n-        if (WSAGetLastError() == WSAEINPROGRESS || WSAGetLastError() == WSAEWOULDBLOCK || WSAGetLastError() == WSAEINVAL)\n-        {\n-            struct timeval timeout;\n-            timeout.tv_sec  = nTimeout / 1000;\n-            timeout.tv_usec = (nTimeout % 1000) * 1000;\n-\n-            fd_set fdset;\n-            FD_ZERO(&fdset);\n-            FD_SET(hSocket, &fdset);\n-            int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n-            if (nRet == 0)\n-            {\n-                printf(\"connection timeout\\n\");\n-                closesocket(hSocket);\n-                return false;\n-            }\n-            if (nRet == SOCKET_ERROR)\n-            {\n-                printf(\"select() for connection failed: %i\\n\",WSAGetLastError());\n-                closesocket(hSocket);\n-                return false;\n-            }\n-            socklen_t nRetSize = sizeof(nRet);\n-#ifdef WIN32\n-            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (char*)(&nRet), &nRetSize) == SOCKET_ERROR)\n-#else\n-            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, &nRet, &nRetSize) == SOCKET_ERROR)\n-#endif\n-            {\n-                printf(\"getsockopt() for connection failed: %i\\n\",WSAGetLastError());\n-                closesocket(hSocket);\n-                return false;\n-            }\n-            if (nRet != 0)\n-            {\n-                printf(\"connect() failed after select(): %s\\n\",strerror(nRet));\n-                closesocket(hSocket);\n-                return false;\n-            }\n-        }\n-#ifdef WIN32\n-        else if (WSAGetLastError() != WSAEISCONN)\n-#else\n-        else\n-#endif\n-        {\n-            printf(\"connect() failed: %i\\n\",WSAGetLastError());\n-            closesocket(hSocket);\n-            return false;\n-        }\n-    }\n-\n-    /*\n-    this isn't even strictly necessary\n-    CNode::ConnectNode immediately turns the socket back to non-blocking\n-    but we'll turn it back to blocking just in case\n-    */\n-#ifdef WIN32\n-    fNonblock = 0;\n-    if (ioctlsocket(hSocket, FIONBIO, &fNonblock) == SOCKET_ERROR)\n-#else\n-    fFlags = fcntl(hSocket, F_GETFL, 0);\n-    if (fcntl(hSocket, F_SETFL, fFlags & !O_NONBLOCK) == SOCKET_ERROR)\n-#endif\n-    {\n-        closesocket(hSocket);\n-        return false;\n-    }\n-\n-    if (fProxy)\n-    {\n-        printf(\"proxy connecting %s\\n\", addrConnect.ToString().c_str());\n-        char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n-        memcpy(pszSocks4IP + 2, &addrConnect.port, 2);\n-        memcpy(pszSocks4IP + 4, &addrConnect.ip, 4);\n-        char* pszSocks4 = pszSocks4IP;\n-        int nSize = sizeof(pszSocks4IP);\n-\n-        int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n-        if (ret != nSize)\n-        {\n-            closesocket(hSocket);\n-            return error(\"Error sending to proxy\");\n-        }\n-        char pchRet[8];\n-        if (recv(hSocket, pchRet, 8, 0) != 8)\n-        {\n-            closesocket(hSocket);\n-            return error(\"Error reading proxy response\");\n-        }\n-        if (pchRet[1] != 0x5a)\n-        {\n-            closesocket(hSocket);\n-            if (pchRet[1] != 0x5b)\n-                printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n-            return false;\n-        }\n-        printf(\"proxy connected %s\\n\", addrConnect.ToString().c_str());\n-    }\n-\n-    hSocketRet = hSocket;\n-    return true;\n-}\n-\n-// portDefault is in host order\n-bool Lookup(const char *pszName, vector<CAddress>& vaddr, int nServices, int nMaxSolutions, bool fAllowLookup, int portDefault, bool fAllowPort)\n-{\n-    vaddr.clear();\n-    if (pszName[0] == 0)\n-        return false;\n-    int port = portDefault;\n-    char psz[256];\n-    char *pszHost = psz;\n-    strlcpy(psz, pszName, sizeof(psz));\n-    if (fAllowPort)\n-    {\n-        char* pszColon = strrchr(psz+1,':');\n-        char *pszPortEnd = NULL;\n-        int portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n-        if (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n-        {\n-            if (psz[0] == '[' && pszColon[-1] == ']')\n-            {\n-                // Future: enable IPv6 colon-notation inside []\n-                pszHost = psz+1;\n-                pszColon[-1] = 0;\n-            }\n-            else\n-                pszColon[0] = 0;\n-            port = portParsed;\n-            if (port < 0 || port > std::numeric_limits<unsigned short>::max())\n-                port = std::numeric_limits<unsigned short>::max();\n-        }\n-    }\n-\n-    unsigned int addrIP = inet_addr(pszHost);\n-    if (addrIP != INADDR_NONE)\n-    {\n-        // valid IP address passed\n-        vaddr.push_back(CAddress(addrIP, port, nServices));\n-        return true;\n-    }\n-\n-    if (!fAllowLookup)\n-        return false;\n-\n-    struct hostent* phostent = gethostbyname(pszHost);\n-    if (!phostent)\n-        return false;\n-\n-    if (phostent->h_addrtype != AF_INET)\n-        return false;\n-\n-    char** ppAddr = phostent->h_addr_list;\n-    while (*ppAddr != NULL && vaddr.size() != nMaxSolutions)\n-    {\n-        CAddress addr(((struct in_addr*)ppAddr[0])->s_addr, port, nServices);\n-        if (addr.IsValid())\n-            vaddr.push_back(addr);\n-        ppAddr++;\n-    }\n-\n-    return (vaddr.size() > 0);\n-}\n-\n-// portDefault is in host order\n-bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup, int portDefault, bool fAllowPort)\n-{\n-    vector<CAddress> vaddr;\n-    bool fRet = Lookup(pszName, vaddr, nServices, 1, fAllowLookup, portDefault, fAllowPort);\n-    if (fRet)\n-        addr = vaddr[0];\n-    return fRet;\n-}\n-\n-bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const char* pszKeyword, unsigned int& ipRet)\n+bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const char* pszKeyword, CNetAddr& ipRet)\n {\n     SOCKET hSocket;\n     if (!ConnectSocket(addrConnect, hSocket))\n@@ -328,11 +118,11 @@ bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const cha\n             strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n             while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                 strLine.resize(strLine.size()-1);\n-            CAddress addr(strLine,0,true);\n+            CService addr(strLine,0,true);\n             printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n-            if (addr.ip == 0 || addr.ip == INADDR_NONE || !addr.IsRoutable())\n+            if (!addr.IsValid() || !addr.IsRoutable())\n                 return false;\n-            ipRet = addr.ip;\n+            ipRet.SetIP(addr);\n             return true;\n         }\n     }\n@@ -341,7 +131,7 @@ bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const cha\n }\n \n // We now get our external IP from the IRC server first and only use this as a backup\n-bool GetMyExternalIP(unsigned int& ipRet)\n+bool GetMyExternalIP(CNetAddr& ipRet)\n {\n     CAddress addrConnect;\n     const char* pszGet;\n@@ -363,7 +153,7 @@ bool GetMyExternalIP(unsigned int& ipRet)\n \n             if (nLookup == 1)\n             {\n-                CAddress addrIP(\"checkip.dyndns.org\", 80, true);\n+                CService addrIP(\"checkip.dyndns.org\", 80, true);\n                 if (addrIP.IsValid())\n                     addrConnect = addrIP;\n             }\n@@ -382,7 +172,7 @@ bool GetMyExternalIP(unsigned int& ipRet)\n \n             if (nLookup == 1)\n             {\n-                CAddress addrIP(\"www.showmyip.com\", 80, true);\n+                CService addrIP(\"www.showmyip.com\", 80, true);\n                 if (addrIP.IsValid())\n                     addrConnect = addrIP;\n             }\n@@ -417,7 +207,7 @@ void ThreadGetMyExternalIP(void* parg)\n     }\n \n     // Fallback in case IRC fails to get it\n-    if (GetMyExternalIP(addrLocalHost.ip))\n+    if (GetMyExternalIP(addrLocalHost))\n     {\n         printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n         if (addrLocalHost.IsRoutable())\n@@ -441,7 +231,7 @@ bool AddAddress(CAddress addr, int64 nTimePenalty, CAddrDB *pAddrDB)\n {\n     if (!addr.IsRoutable())\n         return false;\n-    if (addr.ip == addrLocalHost.ip)\n+    if ((CService)addr == (CService)addrLocalHost)\n         return false;\n     addr.nTime = max((int64)0, (int64)addr.nTime - nTimePenalty);\n     bool fUpdated = false;\n@@ -494,7 +284,7 @@ bool AddAddress(CAddress addr, int64 nTimePenalty, CAddrDB *pAddrDB)\n     return fNew;\n }\n \n-void AddressCurrentlyConnected(const CAddress& addr)\n+void AddressCurrentlyConnected(const CService& addr)\n {\n     CAddress *paddrFound = NULL;\n \n@@ -624,35 +414,35 @@ void CNode::CancelSubscribe(unsigned int nChannel)\n \n \n \n-CNode* FindNode(unsigned int ip)\n+CNode* FindNode(const CNetAddr& ip)\n {\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n         BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (pnode->addr.ip == ip)\n+            if ((CNetAddr)pnode->addr == ip)\n                 return (pnode);\n     }\n     return NULL;\n }\n \n-CNode* FindNode(CAddress addr)\n+CNode* FindNode(const CService& addr)\n {\n     CRITICAL_BLOCK(cs_vNodes)\n     {\n         BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (pnode->addr == addr)\n+            if ((CService)pnode->addr == addr)\n                 return (pnode);\n     }\n     return NULL;\n }\n \n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n {\n-    if (addrConnect.ip == addrLocalHost.ip)\n+    if ((CNetAddr)addrConnect == (CNetAddr)addrLocalHost)\n         return NULL;\n \n     // Look for an existing connection\n-    CNode* pnode = FindNode(addrConnect.ip);\n+    CNode* pnode = FindNode((CService)addrConnect);\n     if (pnode)\n     {\n         if (nTimeout != 0)\n@@ -746,20 +536,20 @@ void CNode::PushVersion()\n \n \n \n-std::map<unsigned int, int64> CNode::setBanned;\n+std::map<CNetAddr, int64> CNode::setBanned;\n CCriticalSection CNode::cs_setBanned;\n \n void CNode::ClearBanned()\n {\n     setBanned.clear();\n }\n \n-bool CNode::IsBanned(unsigned int ip)\n+bool CNode::IsBanned(CNetAddr ip)\n {\n     bool fResult = false;\n     CRITICAL_BLOCK(cs_setBanned)\n     {\n-        std::map<unsigned int, int64>::iterator i = setBanned.find(ip);\n+        std::map<CNetAddr, int64>::iterator i = setBanned.find(ip);\n         if (i != setBanned.end())\n         {\n             int64 t = (*i).second;\n@@ -783,8 +573,8 @@ bool CNode::Misbehaving(int howmuch)\n     {\n         int64 banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n         CRITICAL_BLOCK(cs_setBanned)\n-            if (setBanned[addr.ip] < banTime)\n-                setBanned[addr.ip] = banTime;\n+            if (setBanned[addr] < banTime)\n+                setBanned[addr] = banTime;\n         CloseSocketDisconnect();\n         printf(\"Disconnected %s for misbehavior (score=%d)\\n\", addr.ToString().c_str(), nMisbehavior);\n         return true;\n@@ -962,7 +752,7 @@ void ThreadSocketHandler2(void* parg)\n             {\n                 closesocket(hSocket);\n             }\n-            else if (CNode::IsBanned(addr.ip))\n+            else if (CNode::IsBanned(addr))\n             {\n                 printf(\"connetion from %s dropped (banned)\\n\", addr.ToString().c_str());\n                 closesocket(hSocket);\n@@ -1277,15 +1067,16 @@ void ThreadDNSAddressSeed2(void* parg)\n         printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n         for (int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n-            vector<CAddress> vaddr;\n-            if (Lookup(strDNSSeed[seed_idx], vaddr, NODE_NETWORK, -1, true))\n+            vector<CNetAddr> vaddr;\n+            if (LookupHost(strDNSSeed[seed_idx], vaddr))\n             {\n                 CAddrDB addrDB;\n                 addrDB.TxnBegin();\n-                BOOST_FOREACH (CAddress& addr, vaddr)\n+                BOOST_FOREACH (CNetAddr& ip, vaddr)\n                 {\n-                    if (addr.GetByte(3) != 127)\n+                    if (ip.IsRoutable())\n                     {\n+                        CAddress addr(CService(ip, GetDefaultPort()), NODE_NETWORK);\n                         addr.nTime = 0;\n                         AddAddress(addr, 0, &addrDB);\n                         found++;\n@@ -1470,8 +1261,8 @@ void ThreadOpenConnections2(void* parg)\n         CRITICAL_BLOCK(cs_mapAddresses)\n         {\n             // Add seed nodes if IRC isn't working\n-            bool fTOR = (fUseProxy && addrProxy.port == htons(9050));\n-            if (mapAddresses.empty() && (GetTime() - nStart > 60 || fUseProxy) && !fTestNet)\n+            bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n+            if (mapAddresses.empty() && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n                 fAddSeeds = true;\n         }\n \n@@ -1484,8 +1275,9 @@ void ThreadOpenConnections2(void* parg)\n                 // Seed nodes are given a random 'last seen time' of between one and two\n                 // weeks ago.\n                 const int64 nOneWeek = 7*24*60*60;\n-                CAddress addr;\n-                addr.ip = pnSeed[i];\n+                struct in_addr ip;\n+                memcpy(&ip, &pnSeed[i], sizeof(ip));\n+                CAddress addr(CService(ip, GetDefaultPort()));\n                 addr.nTime = GetTime()-GetRand(nOneWeek)-nOneWeek;\n                 AddAddress(addr);\n             }\n@@ -1499,10 +1291,10 @@ void ThreadOpenConnections2(void* parg)\n \n         // Only connect to one address per a.b.?.? range.\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n-        set<unsigned int> setConnected;\n+        set<vector<unsigned char> > setConnected;\n         CRITICAL_BLOCK(cs_vNodes)\n             BOOST_FOREACH(CNode* pnode, vNodes)\n-                setConnected.insert(pnode->addr.ip & 0x0000ffff);\n+                setConnected.insert(pnode->addr.GetGroup());\n \n         int64 nANow = GetAdjustedTime();\n \n@@ -1511,14 +1303,14 @@ void ThreadOpenConnections2(void* parg)\n             BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n             {\n                 const CAddress& addr = item.second;\n-                if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.ip & 0x0000ffff))\n+                if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.GetGroup()))\n                     continue;\n                 int64 nSinceLastSeen = nANow - addr.nTime;\n                 int64 nSinceLastTry = nANow - addr.nLastTry;\n \n                 // Randomize the order in a deterministic way, putting the standard port first\n-                int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.ip * 7789) % (2 * 60 * 60);\n-                if (addr.port != htons(GetDefaultPort()))\n+                int64 nRandomizer = (uint64)(nStart * 4951 + addr.nLastTry * 9567851 + addr.GetHash()) % (2 * 60 * 60);\n+                if (addr.GetPort() != GetDefaultPort())\n                     nRandomizer += 2 * 60 * 60;\n \n                 // Last seen  Base retry frequency\n@@ -1573,8 +1365,8 @@ bool OpenNetworkConnection(const CAddress& addrConnect)\n     //\n     if (fShutdown)\n         return false;\n-    if (addrConnect.ip == addrLocalHost.ip || !addrConnect.IsIPv4() ||\n-        FindNode(addrConnect.ip) || CNode::IsBanned(addrConnect.ip))\n+    if ((CNetAddr)addrConnect == (CNetAddr)addrLocalHost || !addrConnect.IsIPv4() ||\n+        FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect))\n         return false;\n \n     vnThreadsRunning[1]--;\n@@ -1676,7 +1468,7 @@ bool BindListenPort(string& strError)\n {\n     strError = \"\";\n     int nOne = 1;\n-    addrLocalHost.port = htons(GetListenPort());\n+    addrLocalHost.SetPort(GetListenPort());\n \n #ifdef WIN32\n     // Initialize Windows Sockets\n@@ -1755,19 +1547,19 @@ bool BindListenPort(string& strError)\n void StartNode(void* parg)\n {\n     if (pnodeLocalHost == NULL)\n-        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(\"127.0.0.1\", 0, false, nLocalServices));\n+        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n \n #ifdef WIN32\n     // Get local host ip\n     char pszHostName[1000] = \"\";\n     if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n     {\n-        vector<CAddress> vaddr;\n-        if (Lookup(pszHostName, vaddr, nLocalServices, -1, true))\n-            BOOST_FOREACH (const CAddress &addr, vaddr)\n-                if (addr.GetByte(3) != 127)\n+        vector<CNetAddr> vaddr;\n+        if (LookupHost(pszHostName, vaddr))\n+            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n+                if (!addr.IsLocal())\n                 {\n-                    addrLocalHost = addr;\n+                    addrLocalHost.SetIP(addr);\n                     break;\n                 }\n     }\n@@ -1790,8 +1582,8 @@ void StartNode(void* parg)\n                     printf(\"ipv4 %s: %s\\n\", ifa->ifa_name, pszIP);\n \n                 // Take the first IP that isn't loopback 127.x.x.x\n-                CAddress addr(*(unsigned int*)&s4->sin_addr, GetListenPort(), nLocalServices);\n-                if (addr.IsValid() && addr.GetByte(3) != 127)\n+                CAddress addr(CService(s4->sin_addr, GetListenPort()), nLocalServices);\n+                if (addr.IsValid() && !addr.IsLocal())\n                 {\n                     addrLocalHost = addr;\n                     break;\n@@ -1812,7 +1604,7 @@ void StartNode(void* parg)\n     if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n     {\n         // Proxies can't take incoming connections\n-        addrLocalHost.ip = CAddress(\"0.0.0.0\").ip;\n+        addrLocalHost.SetIP(CNetAddr(\"0.0.0.0\"));\n         printf(\"addrLocalHost = %s\\n\", addrLocalHost.ToString().c_str());\n     }\n     else"
      },
      {
        "sha": "61daf0378ce60cf871fa9727960c723bf0a1fb5c",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 7,
        "deletions": 13,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -14,28 +14,26 @@\n #include <arpa/inet.h>\n #endif\n \n+#include \"netbase.h\"\n #include \"protocol.h\"\n \n class CAddrDB;\n class CRequestTracker;\n class CNode;\n class CBlockIndex;\n extern int nBestHeight;\n-extern int nConnectTimeout;\n \n \n \n inline unsigned int ReceiveBufferSize() { return 1000*GetArg(\"-maxreceivebuffer\", 10*1000); }\n inline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 10*1000); }\n static const unsigned int PUBLISH_HOPS = 5;\n \n-bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet, int nTimeout=nConnectTimeout);\n-bool Lookup(const char *pszName, std::vector<CAddress>& vaddr, int nServices, int nMaxSolutions, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n-bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n-bool GetMyExternalIP(unsigned int& ipRet);\n+bool GetMyExternalIP(CNetAddr& ipRet);\n bool AddAddress(CAddress addr, int64 nTimePenalty=0, CAddrDB *pAddrDB=NULL);\n-void AddressCurrentlyConnected(const CAddress& addr);\n-CNode* FindNode(unsigned int ip);\n+void AddressCurrentlyConnected(const CService& addr);\n+CNode* FindNode(const CNetAddr& ip);\n+CNode* FindNode(const CService& ip);\n CNode* ConnectNode(CAddress addrConnect, int64 nTimeout=0);\n void AbandonRequests(void (*fn)(void*, CDataStream&), void* param1);\n bool AnySubscribed(unsigned int nChannel);\n@@ -88,9 +86,6 @@ extern std::deque<std::pair<int64, CInv> > vRelayExpiration;\n extern CCriticalSection cs_mapRelay;\n extern std::map<CInv, int64> mapAlreadyAskedFor;\n \n-// Settings\n-extern int fUseProxy;\n-extern CAddress addrProxy;\n \n \n \n@@ -126,7 +121,7 @@ class CNode\n \n     // Denial-of-service detection/prevention\n     // Key is ip address, value is banned-until-time\n-    static std::map<unsigned int, int64> setBanned;\n+    static std::map<CNetAddr, int64> setBanned;\n     static CCriticalSection cs_setBanned;\n     int nMisbehavior;\n \n@@ -355,7 +350,6 @@ class CNode\n \n \n \n-\n     void PushVersion();\n \n \n@@ -581,7 +575,7 @@ class CNode\n     // between nodes running old code and nodes running\n     // new code.\n     static void ClearBanned(); // needed for unit testing\n-    static bool IsBanned(unsigned int ip);\n+    static bool IsBanned(CNetAddr ip);\n     bool Misbehaving(int howmuch); // 1 == a little, 100 == a lot\n };\n "
      },
      {
        "sha": "2c4df7faf8422e2a992165e1e3351e41ea958dda",
        "filename": "src/netbase.cpp",
        "status": "added",
        "additions": 715,
        "deletions": 0,
        "changes": 715,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -0,0 +1,715 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2011 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"netbase.h\"\n+#include \"util.h\"\n+\n+#ifndef WIN32\n+#include <sys/fcntl.h>\n+#endif\n+\n+#include \"strlcpy.h\"\n+\n+using namespace std;\n+\n+// Settings\n+int fUseProxy = false;\n+CService addrProxy(\"127.0.0.1\",9050);\n+int nConnectTimeout = 5000;\n+\n+\n+static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n+\n+bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, int nMaxSolutions, bool fAllowLookup)\n+{\n+    vIP.clear();\n+    struct addrinfo aiHint = {};\n+    aiHint.ai_socktype = SOCK_STREAM;\n+    aiHint.ai_protocol = IPPROTO_TCP;\n+#ifdef WIN32\n+#  ifdef USE_IPV6\n+    aiHint.ai_family = AF_UNSPEC;\n+    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n+#  else\n+    aiHint.ai_family = AF_INET;\n+    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n+#  endif\n+#else\n+#  ifdef USE_IPV6\n+    aiHint.ai_family = AF_UNSPEC;\n+    aiHint.ai_flags = AI_ADDRCONFIG | (fAllowLookup ? 0 : AI_NUMERICHOST);\n+#  else\n+    aiHint.ai_family = AF_INET;\n+    aiHint.ai_flags = AI_ADDRCONFIG | (fAllowLookup ? 0 : AI_NUMERICHOST);\n+#  endif\n+#endif\n+    struct addrinfo *aiRes = NULL;\n+    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n+    if (nErr)\n+        return false;\n+\n+    struct addrinfo *aiTrav = aiRes;\n+    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n+    {\n+        if (aiTrav->ai_family == AF_INET)\n+        {\n+            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n+            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n+        }\n+\n+#ifdef USE_IPV6\n+        if (aiTrav->ai_family == AF_INET6)\n+        {\n+            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n+            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n+        }\n+#endif\n+\n+        aiTrav = aiTrav->ai_next;\n+    }\n+\n+    freeaddrinfo(aiRes);\n+\n+    return (vIP.size() > 0);\n+}\n+\n+bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, int nMaxSolutions, bool fAllowLookup)\n+{\n+    if (pszName[0] == 0)\n+        return false;\n+    char psz[256];\n+    char *pszHost = psz;\n+    strlcpy(psz, pszName, sizeof(psz));\n+    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n+    {\n+        pszHost = psz+1;\n+        psz[strlen(psz)-1] = 0;\n+    }\n+\n+    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n+}\n+\n+bool LookupHostNumeric(const char *pszName, std::vector<CNetAddr>& vIP, int nMaxSolutions)\n+{\n+    return LookupHost(pszName, vIP, nMaxSolutions, false);\n+}\n+\n+bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n+{\n+    if (pszName[0] == 0)\n+        return false;\n+    int port = portDefault;\n+    char psz[256];\n+    char *pszHost = psz;\n+    strlcpy(psz, pszName, sizeof(psz));\n+    char* pszColon = strrchr(psz+1,':');\n+    char *pszPortEnd = NULL;\n+    int portParsed = pszColon ? strtoul(pszColon+1, &pszPortEnd, 10) : 0;\n+    if (pszColon && pszPortEnd && pszPortEnd[0] == 0)\n+    {\n+        if (psz[0] == '[' && pszColon[-1] == ']')\n+        {\n+            pszHost = psz+1;\n+            pszColon[-1] = 0;\n+        }\n+        else\n+            pszColon[0] = 0;\n+        if (port >= 0 && port <= USHRT_MAX)\n+            port = portParsed;\n+    }\n+    else\n+    {\n+        if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n+        {\n+            pszHost = psz+1;\n+            psz[strlen(psz)-1] = 0;\n+        }\n+\n+    }\n+\n+    std::vector<CNetAddr> vIP;\n+    bool fRet = LookupIntern(pszHost, vIP, 1, fAllowLookup);\n+    if (!fRet)\n+        return false;\n+    addr = CService(vIP[0], port);\n+    return true;\n+}\n+\n+bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n+{\n+    return Lookup(pszName, addr, portDefault, false);\n+}\n+\n+bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n+{\n+    hSocketRet = INVALID_SOCKET;\n+\n+    SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    if (hSocket == INVALID_SOCKET)\n+        return false;\n+#ifdef SO_NOSIGPIPE\n+    int set = 1;\n+    setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n+#endif\n+\n+    bool fProxy = (fUseProxy && addrDest.IsRoutable());\n+    struct sockaddr_in sockaddr;\n+    if (fProxy)\n+        addrProxy.GetSockAddr(&sockaddr);\n+    else\n+        addrDest.GetSockAddr(&sockaddr);\n+\n+#ifdef WIN32\n+    u_long fNonblock = 1;\n+    if (ioctlsocket(hSocket, FIONBIO, &fNonblock) == SOCKET_ERROR)\n+#else\n+    int fFlags = fcntl(hSocket, F_GETFL, 0);\n+    if (fcntl(hSocket, F_SETFL, fFlags | O_NONBLOCK) == -1)\n+#endif\n+    {\n+        closesocket(hSocket);\n+        return false;\n+    }\n+\n+\n+    if (connect(hSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)\n+    {\n+        // WSAEINVAL is here because some legacy version of winsock uses it\n+        if (WSAGetLastError() == WSAEINPROGRESS || WSAGetLastError() == WSAEWOULDBLOCK || WSAGetLastError() == WSAEINVAL)\n+        {\n+            struct timeval timeout;\n+            timeout.tv_sec  = nTimeout / 1000;\n+            timeout.tv_usec = (nTimeout % 1000) * 1000;\n+\n+            fd_set fdset;\n+            FD_ZERO(&fdset);\n+            FD_SET(hSocket, &fdset);\n+            int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n+            if (nRet == 0)\n+            {\n+                printf(\"connection timeout\\n\");\n+                closesocket(hSocket);\n+                return false;\n+            }\n+            if (nRet == SOCKET_ERROR)\n+            {\n+                printf(\"select() for connection failed: %i\\n\",WSAGetLastError());\n+                closesocket(hSocket);\n+                return false;\n+            }\n+            socklen_t nRetSize = sizeof(nRet);\n+#ifdef WIN32\n+            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (char*)(&nRet), &nRetSize) == SOCKET_ERROR)\n+#else\n+            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, &nRet, &nRetSize) == SOCKET_ERROR)\n+#endif\n+            {\n+                printf(\"getsockopt() for connection failed: %i\\n\",WSAGetLastError());\n+                closesocket(hSocket);\n+                return false;\n+            }\n+            if (nRet != 0)\n+            {\n+                printf(\"connect() failed after select(): %s\\n\",strerror(nRet));\n+                closesocket(hSocket);\n+                return false;\n+            }\n+        }\n+#ifdef WIN32\n+        else if (WSAGetLastError() != WSAEISCONN)\n+#else\n+        else\n+#endif\n+        {\n+            printf(\"connect() failed: %i\\n\",WSAGetLastError());\n+            closesocket(hSocket);\n+            return false;\n+        }\n+    }\n+\n+    // this isn't even strictly necessary\n+    // CNode::ConnectNode immediately turns the socket back to non-blocking\n+    // but we'll turn it back to blocking just in case\n+#ifdef WIN32\n+    fNonblock = 0;\n+    if (ioctlsocket(hSocket, FIONBIO, &fNonblock) == SOCKET_ERROR)\n+#else\n+    fFlags = fcntl(hSocket, F_GETFL, 0);\n+    if (fcntl(hSocket, F_SETFL, fFlags & !O_NONBLOCK) == SOCKET_ERROR)\n+#endif\n+    {\n+        closesocket(hSocket);\n+        return false;\n+    }\n+\n+    if (fProxy)\n+    {\n+        printf(\"proxy connecting %s\\n\", addrDest.ToString().c_str());\n+        char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n+        struct sockaddr_in addr;\n+        addrDest.GetSockAddr(&addr);\n+        memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n+        memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n+        char* pszSocks4 = pszSocks4IP;\n+        int nSize = sizeof(pszSocks4IP);\n+\n+        int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n+        if (ret != nSize)\n+        {\n+            closesocket(hSocket);\n+            return error(\"Error sending to proxy\");\n+        }\n+        char pchRet[8];\n+        if (recv(hSocket, pchRet, 8, 0) != 8)\n+        {\n+            closesocket(hSocket);\n+            return error(\"Error reading proxy response\");\n+        }\n+        if (pchRet[1] != 0x5a)\n+        {\n+            closesocket(hSocket);\n+            if (pchRet[1] != 0x5b)\n+                printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n+            return false;\n+        }\n+        printf(\"proxy connected %s\\n\", addrDest.ToString().c_str());\n+    }\n+\n+    hSocketRet = hSocket;\n+    return true;\n+}\n+\n+void CNetAddr::Init()\n+{\n+    memset(ip, 0, 16);\n+}\n+\n+void CNetAddr::SetIP(const CNetAddr& ipIn)\n+{\n+    memcpy(ip, ipIn.ip, sizeof(ip));\n+}\n+\n+CNetAddr::CNetAddr()\n+{\n+    Init();\n+}\n+\n+CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n+{\n+    memcpy(ip,    pchIPv4, 12);\n+    memcpy(ip+12, &ipv4Addr, 4);\n+}\n+\n+#ifdef USE_IPV6\n+CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr)\n+{\n+    memcpy(ip, &ipv6Addr, 16);\n+}\n+#endif\n+\n+CNetAddr::CNetAddr(const char *pszIp, bool fAllowLookup)\n+{\n+    Init();\n+    std::vector<CNetAddr> vIP;\n+    if (LookupHost(pszIp, vIP, 1, fAllowLookup))\n+        *this = vIP[0];\n+}\n+\n+CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n+{\n+    Init();\n+    std::vector<CNetAddr> vIP;\n+    if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n+        *this = vIP[0];\n+}\n+\n+int CNetAddr::GetByte(int n) const\n+{\n+    return ip[15-n];\n+}\n+\n+bool CNetAddr::IsIPv4() const\n+{\n+    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC1918() const\n+{\n+    return IsIPv4() && (\n+        GetByte(3) == 10 || \n+        (GetByte(3) == 192 && GetByte(2) == 168) || \n+        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+}\n+\n+bool CNetAddr::IsRFC3927() const\n+{\n+    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+}\n+\n+bool CNetAddr::IsRFC3849() const\n+{\n+    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n+}\n+\n+bool CNetAddr::IsRFC3964() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n+}\n+\n+bool CNetAddr::IsRFC6052() const\n+{\n+    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n+    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4380() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4862() const\n+{\n+    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n+    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4193() const\n+{\n+    return ((GetByte(15) & 0xFE) == 0xFC);\n+}\n+\n+bool CNetAddr::IsRFC6145() const\n+{\n+    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n+    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4843() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && GetByte(12) & 0xF0 == 0x10);\n+}\n+\n+bool CNetAddr::IsLocal() const\n+{\n+    // IPv4 loopback\n+   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+       return true;\n+\n+   // IPv6 loopback (::1/128)\n+   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n+   if (memcmp(ip, pchLocal, 16) == 0)\n+       return true;\n+\n+   return false;\n+}\n+\n+bool CNetAddr::IsMulticast() const\n+{\n+    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n+           || (GetByte(15) == 0xFF);\n+}\n+\n+bool CNetAddr::IsValid() const\n+{\n+    // Clean up 3-byte shifted addresses caused by garbage in size field\n+    // of addr messages from versions before 0.2.9 checksum.\n+    // Two consecutive addr messages look like this:\n+    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n+    // so if the first length field is garbled, it reads the second batch\n+    // of addr misaligned by 3 bytes.\n+    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+        return false;\n+\n+    // unspecified IPv6 address (::/128)\n+    unsigned char ipNone[16] = {};\n+    if (memcmp(ip, ipNone, 16) == 0)\n+        return false;\n+\n+    // documentation IPv6 address\n+    if (IsRFC3849())\n+        return false;\n+\n+    if (IsIPv4())\n+    {\n+        // INADDR_NONE\n+        uint32_t ipNone = INADDR_NONE;\n+        if (memcmp(ip+12, &ipNone, 4) == 0)\n+            return false;\n+\n+        // 0\n+        ipNone = 0;\n+        if (memcmp(ip+12, &ipNone, 4) == 0)\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool CNetAddr::IsRoutable() const\n+{\n+    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || IsRFC4193() || IsRFC4843() || IsLocal());\n+}\n+\n+std::string CNetAddr::ToStringIP() const\n+{\n+    if (IsIPv4())\n+        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+    else\n+        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n+                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n+                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n+                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+}\n+\n+std::string CNetAddr::ToString() const\n+{\n+    return ToStringIP();\n+}\n+\n+bool operator==(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) == 0);\n+}\n+\n+bool operator!=(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) != 0);\n+}\n+\n+bool operator<(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) < 0);\n+}\n+\n+bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n+{\n+    if (!IsIPv4())\n+        return false;\n+    memcpy(pipv4Addr, ip+12, 4);\n+    return true;\n+}\n+\n+#ifdef USE_IPV6\n+bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n+{\n+    memcpy(pipv6Addr, ip, 16);\n+    return true;\n+}\n+#endif\n+\n+// get canonical identifier of an address' group\n+// no two connections will be attempted to addresses with the same group\n+std::vector<unsigned char> CNetAddr::GetGroup() const\n+{\n+    std::vector<unsigned char> vchRet;\n+    int nClass = 0; // 0=IPv6, 1=IPv4, 255=unroutable\n+    int nStartByte = 0;\n+    int nBits = 16;\n+\n+    // for unroutable addresses, each address is considered different\n+    if (!IsRoutable())\n+    {\n+        nClass = 255;\n+        nBits = 128;\n+    }\n+    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n+    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n+    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n+    {\n+        nClass = 1;\n+        nStartByte = 12;\n+    }\n+    // for 6to4 tunneled addresses, use the encapsulated IPv4 address\n+    else if (IsRFC3964())\n+    {\n+        nClass = 1;\n+        nStartByte = 2;\n+    }\n+    // for Teredo-tunneled IPv6 addresses, use the encapsulated IPv4 address\n+    else if (IsRFC4380())\n+    {\n+        vchRet.push_back(1);\n+        vchRet.push_back(GetByte(3) ^ 0xFF);\n+        vchRet.push_back(GetByte(2) ^ 0xFF);\n+        return vchRet;\n+    }\n+    // for he.net, use /36 groups\n+    else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n+        nBits = 36;\n+    // for the rest of the IPv6 network, use /32 groups\n+    else\n+        nBits = 32;\n+\n+    vchRet.push_back(nClass);\n+    while (nBits >= 8)\n+    {\n+        vchRet.push_back(GetByte(15 - nStartByte));\n+        nStartByte++;\n+        nBits -= 8;\n+    }\n+    if (nBits > 0)\n+        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n+\n+    return vchRet;\n+}\n+\n+int64 CNetAddr::GetHash() const\n+{\n+    uint256 hash = Hash(&ip[0], &ip[16]);\n+    int64 nRet;\n+    memcpy(&nRet, &hash, sizeof(nRet));\n+    return nRet;\n+}\n+\n+void CNetAddr::print() const\n+{\n+    printf(\"CNetAddr(%s)\\n\", ToString().c_str());\n+}\n+\n+void CService::Init()\n+{\n+    port = 0;\n+}\n+\n+CService::CService()\n+{\n+    Init();\n+}\n+\n+CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n+{\n+}\n+\n+#ifdef USE_IPV6\n+CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n+{\n+}\n+#endif\n+\n+CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n+{\n+    assert(addr.sin_family == AF_INET);\n+}\n+\n+#ifdef USE_IPV6\n+CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr), port(ntohs(addr.sin6_port))\n+{\n+   assert(addr.sin6_family == AF_INET6);\n+}\n+#endif\n+\n+CService::CService(const char *pszIpPort, bool fAllowLookup)\n+{\n+    Init();\n+    CService ip;\n+    if (Lookup(pszIpPort, ip, 0, fAllowLookup))\n+        *this = ip;\n+}\n+\n+CService::CService(const char *pszIp, int portIn, bool fAllowLookup)\n+{\n+    std::vector<CNetAddr> ip;\n+    if (LookupHost(pszIp, ip, 1, fAllowLookup))\n+        *this = CService(ip[0], portIn);\n+}\n+\n+CService::CService(const std::string &strIpPort, bool fAllowLookup)\n+{\n+    Init();\n+    CService ip;\n+    if (Lookup(strIpPort.c_str(), ip, 0, fAllowLookup))\n+        *this = ip;\n+}\n+\n+CService::CService(const std::string &strIp, int portIn, bool fAllowLookup)\n+{\n+    std::vector<CNetAddr> ip;\n+    if (LookupHost(strIp.c_str(), ip, 1, fAllowLookup))\n+        *this = CService(ip[0], portIn);\n+}\n+\n+unsigned short CService::GetPort() const\n+{\n+    return port;\n+}\n+\n+bool operator==(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a == (CNetAddr)b && a.port == b.port;\n+}\n+\n+bool operator!=(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a != (CNetAddr)b || a.port != b.port;\n+}\n+\n+bool operator<(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n+}\n+\n+bool CService::GetSockAddr(struct sockaddr_in* paddr) const\n+{\n+    if (!IsIPv4())\n+        return false;\n+    memset(paddr, 0, sizeof(struct sockaddr_in));\n+    if (!GetInAddr(&paddr->sin_addr))\n+        return false;\n+    paddr->sin_family = AF_INET;\n+    paddr->sin_port = htons(port);\n+    return true;\n+}\n+\n+#ifdef USE_IPV6\n+bool CService::GetSockAddr6(struct sockaddr_in6* paddr) const\n+{\n+    memset(paddr, 0, sizeof(struct sockaddr_in6));\n+    if (!GetIn6Addr(&paddr->sin6_addr))\n+        return false;\n+    paddr->sin6_family = AF_INET6;\n+    paddr->sin6_port = htons(port);\n+    return true;\n+}\n+#endif\n+\n+std::vector<unsigned char> CService::GetKey() const\n+{\n+     std::vector<unsigned char> vKey;\n+     vKey.resize(18);\n+     memcpy(&vKey[0], ip, 16);\n+     vKey[16] = port / 0x100;\n+     vKey[17] = port & 0x0FF;\n+     return vKey;\n+}\n+\n+std::string CService::ToStringPort() const\n+{\n+    return strprintf(\":%i\", port);\n+}\n+\n+std::string CService::ToStringIPPort() const\n+{\n+    return ToStringIP() + ToStringPort();\n+}\n+\n+std::string CService::ToString() const\n+{\n+    return ToStringIPPort();\n+}\n+\n+void CService::print() const\n+{\n+    printf(\"CService(%s)\\n\", ToString().c_str());\n+}\n+\n+void CService::SetPort(unsigned short portIn)\n+{\n+    port = portIn;\n+}"
      },
      {
        "sha": "6f06f8fe08ca76e439455c480f785270d4e57158",
        "filename": "src/netbase.h",
        "status": "added",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -0,0 +1,138 @@\n+// Copyright (c) 2011 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_NETBASE_H\n+#define BITCOIN_NETBASE_H\n+\n+#include <string>\n+#include <vector>\n+\n+#ifdef WIN32\n+#define _WIN32_WINNT 0x0501\n+#include <winsock2.h>\n+#include <mswsock.h>\n+#include <ws2tcpip.h>\n+#else\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <net/if.h>\n+#include <ifaddrs.h>\n+#endif\n+#ifdef BSD\n+#include <netinet/in.h>\n+#endif\n+\n+#include \"serialize.h\"\n+#include \"compat.h\"\n+\n+extern int nConnectTimeout;\n+\n+\n+// IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96))\n+class CNetAddr\n+{\n+    protected:\n+        unsigned char ip[16]; // in network byte order\n+\n+    public:\n+        CNetAddr();\n+        CNetAddr(const struct in_addr& ipv4Addr);\n+        CNetAddr(const char *pszIp, bool fAllowLookup = false);\n+        CNetAddr(const std::string &strIp, bool fAllowLookup = false);\n+        void Init();\n+        void SetIP(const CNetAddr& ip);\n+        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n+        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n+        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n+        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n+        bool IsRFC3964() const; // IPv6 6to4 tunneling (2002::/16)\n+        bool IsRFC4193() const; // IPv6 unique local (FC00::/15)\n+        bool IsRFC4380() const; // IPv6 Teredo tunneling (2001::/32)\n+        bool IsRFC4843() const; // IPv6 ORCHID (2001:10::/28)\n+        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n+        bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)\n+        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n+        bool IsLocal() const;\n+        bool IsRoutable() const;\n+        bool IsValid() const;\n+        bool IsMulticast() const;\n+        std::string ToString() const;\n+        std::string ToStringIP() const;\n+        int GetByte(int n) const;\n+        int64 GetHash() const;\n+        bool GetInAddr(struct in_addr* pipv4Addr) const;\n+        std::vector<unsigned char> GetGroup() const;\n+        void print() const;\n+\n+#ifdef USE_IPV6\n+        CNetAddr(const struct in6_addr& pipv6Addr);\n+        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n+#endif\n+\n+        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator!=(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n+\n+        IMPLEMENT_SERIALIZE\n+            (\n+             READWRITE(FLATDATA(ip));\n+            )\n+};\n+\n+class CService : public CNetAddr\n+{\n+    protected:\n+        unsigned short port; // host order\n+\n+    public:\n+        CService();\n+        CService(const CNetAddr& ip, unsigned short port);\n+        CService(const struct in_addr& ipv4Addr, unsigned short port);\n+        CService(const struct sockaddr_in& addr);\n+        CService(const char *pszIp, int port, bool fAllowLookup = false);\n+        CService(const char *pszIpPort, bool fAllowLookup = false);\n+        CService(const std::string& strIp, int port, bool fAllowLookup = false);\n+        CService(const std::string& strIpPort, bool fAllowLookup = false);\n+        void Init();\n+        void SetPort(unsigned short portIn);\n+        unsigned short GetPort() const;\n+        bool GetSockAddr(struct sockaddr_in* paddr) const;\n+        friend bool operator==(const CService& a, const CService& b);\n+        friend bool operator!=(const CService& a, const CService& b);\n+        friend bool operator<(const CService& a, const CService& b);\n+        std::vector<unsigned char> GetKey() const;\n+        std::string ToString() const;\n+        std::string ToStringPort() const;\n+        std::string ToStringIPPort() const;\n+        void print() const;\n+\n+#ifdef USE_IPV6\n+        CService(const struct in6_addr& ipv6Addr, unsigned short port);\n+        bool GetSockAddr6(struct sockaddr_in6* paddr) const;\n+        CService(const struct sockaddr_in6& addr);\n+#endif\n+\n+        IMPLEMENT_SERIALIZE\n+            (\n+             CService* pthis = const_cast<CService*>(this);\n+             READWRITE(FLATDATA(ip));\n+             unsigned short portN = htons(port);\n+             READWRITE(portN);\n+             if (fRead)\n+                 pthis->port = ntohs(portN);\n+            )\n+};\n+\n+bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, int nMaxSolutions = 0, bool fAllowLookup = true);\n+bool LookupHostNumeric(const char *pszName, std::vector<CNetAddr>& vIP, int nMaxSolutions = 0);\n+bool Lookup(const char *pszName, CService& addr, int portDefault = 0, bool fAllowLookup = true);\n+bool LookupNumeric(const char *pszName, CService& addr, int portDefault = 0);\n+bool ConnectSocket(const CService &addr, SOCKET& hSocketRet, int nTimeout = nConnectTimeout);\n+\n+// Settings\n+extern int fUseProxy;\n+extern CService addrProxy;\n+\n+#endif"
      },
      {
        "sha": "45f08082e9310df9d6976bfb1e3dbcd39f87e3b6",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 167,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -5,16 +5,12 @@\n \n #include \"protocol.h\"\n #include \"util.h\"\n+#include \"netbase.h\"\n \n #ifndef WIN32\n # include <arpa/inet.h>\n #endif\n \n-// Prototypes from net.h, but that header (currently) stinks, can't #include it without breaking things\n-bool Lookup(const char *pszName, std::vector<CAddress>& vaddr, int nServices, int nMaxSolutions, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n-bool Lookup(const char *pszName, CAddress& addr, int nServices, bool fAllowLookup = false, int portDefault = 0, bool fAllowPort = false);\n-\n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n static const char* ppszTypeName[] =\n {\n     \"ERROR\",\n@@ -77,185 +73,26 @@ bool CMessageHeader::IsValid() const\n     return true;\n }\n \n-CAddress::CAddress()\n-{\n-    Init();\n-}\n-\n-CAddress::CAddress(unsigned int ipIn, unsigned short portIn, uint64 nServicesIn)\n-{\n-    Init();\n-    ip = ipIn;\n-    port = htons(portIn == 0 ? GetDefaultPort() : portIn);\n-    nServices = nServicesIn;\n-}\n-\n-CAddress::CAddress(const struct sockaddr_in& sockaddr, uint64 nServicesIn)\n-{\n-    Init();\n-    ip = sockaddr.sin_addr.s_addr;\n-    port = sockaddr.sin_port;\n-    nServices = nServicesIn;\n-}\n-\n-CAddress::CAddress(const char* pszIn, int portIn, bool fNameLookup, uint64 nServicesIn)\n-{\n-    Init();\n-    Lookup(pszIn, *this, nServicesIn, fNameLookup, portIn);\n-}\n \n-CAddress::CAddress(const char* pszIn, bool fNameLookup, uint64 nServicesIn)\n-{\n-    Init();\n-    Lookup(pszIn, *this, nServicesIn, fNameLookup, 0, true);\n-}\n \n-CAddress::CAddress(std::string strIn, int portIn, bool fNameLookup, uint64 nServicesIn)\n+CAddress::CAddress() : CService()\n {\n     Init();\n-    Lookup(strIn.c_str(), *this, nServicesIn, fNameLookup, portIn);\n }\n \n-CAddress::CAddress(std::string strIn, bool fNameLookup, uint64 nServicesIn)\n+CAddress::CAddress(CService ipIn, uint64 nServicesIn) : CService(ipIn)\n {\n     Init();\n-    Lookup(strIn.c_str(), *this, nServicesIn, fNameLookup, 0, true);\n+    nServices = nServicesIn;\n }\n \n void CAddress::Init()\n {\n     nServices = NODE_NETWORK;\n-    memcpy(pchReserved, pchIPv4, sizeof(pchReserved));\n-    ip = INADDR_NONE;\n-    port = htons(GetDefaultPort());\n     nTime = 100000000;\n     nLastTry = 0;\n }\n \n-bool operator==(const CAddress& a, const CAddress& b)\n-{\n-    return (memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved)) == 0 &&\n-            a.ip   == b.ip &&\n-            a.port == b.port);\n-}\n-\n-bool operator!=(const CAddress& a, const CAddress& b)\n-{\n-    return (!(a == b));\n-}\n-\n-bool operator<(const CAddress& a, const CAddress& b)\n-{\n-    int ret = memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved));\n-    if (ret < 0)\n-        return true;\n-    else if (ret == 0)\n-    {\n-        if (ntohl(a.ip) < ntohl(b.ip))\n-            return true;\n-        else if (a.ip == b.ip)\n-            return ntohs(a.port) < ntohs(b.port);\n-    }\n-    return false;\n-}\n-\n-std::vector<unsigned char> CAddress::GetKey() const\n-{\n-    CDataStream ss;\n-    ss.reserve(18);\n-    ss << FLATDATA(pchReserved) << ip << port;\n-\n-    #if defined(_MSC_VER) && _MSC_VER < 1300\n-    return std::vector<unsigned char>((unsigned char*)&ss.begin()[0], (unsigned char*)&ss.end()[0]);\n-    #else\n-    return std::vector<unsigned char>(ss.begin(), ss.end());\n-    #endif\n-}\n-\n-struct sockaddr_in CAddress::GetSockAddr() const\n-{\n-    struct sockaddr_in sockaddr;\n-    memset(&sockaddr, 0, sizeof(sockaddr));\n-    sockaddr.sin_family = AF_INET;\n-    sockaddr.sin_addr.s_addr = ip;\n-    sockaddr.sin_port = port;\n-    return sockaddr;\n-}\n-\n-bool CAddress::IsIPv4() const\n-{\n-    return (memcmp(pchReserved, pchIPv4, sizeof(pchIPv4)) == 0);\n-}\n-\n-bool CAddress::IsRFC1918() const\n-{\n-  return IsIPv4() && (GetByte(3) == 10 ||\n-    (GetByte(3) == 192 && GetByte(2) == 168) ||\n-    (GetByte(3) == 172 &&\n-      (GetByte(2) >= 16 && GetByte(2) <= 31)));\n-}\n-\n-bool CAddress::IsRFC3927() const\n-{\n-  return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n-}\n-\n-bool CAddress::IsLocal() const\n-{\n-  return IsIPv4() && (GetByte(3) == 127 ||\n-      GetByte(3) == 0);\n-}\n-\n-bool CAddress::IsRoutable() const\n-{\n-    return IsValid() &&\n-        !(IsRFC1918() || IsRFC3927() || IsLocal());\n-}\n-\n-bool CAddress::IsValid() const\n-{\n-    // Clean up 3-byte shifted addresses caused by garbage in size field\n-    // of addr messages from versions before 0.2.9 checksum.\n-    // Two consecutive addr messages look like this:\n-    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n-    // so if the first length field is garbled, it reads the second batch\n-    // of addr misaligned by 3 bytes.\n-    if (memcmp(pchReserved, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n-        return false;\n-\n-    return (ip != 0 && ip != INADDR_NONE && port != htons(std::numeric_limits<unsigned short>::max()));\n-}\n-\n-unsigned char CAddress::GetByte(int n) const\n-{\n-    return ((unsigned char*)&ip)[3-n];\n-}\n-\n-std::string CAddress::ToStringIPPort() const\n-{\n-    return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n-}\n-\n-std::string CAddress::ToStringIP() const\n-{\n-    return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n-}\n-\n-std::string CAddress::ToStringPort() const\n-{\n-    return strprintf(\"%u\", ntohs(port));\n-}\n-\n-std::string CAddress::ToString() const\n-{\n-    return strprintf(\"%u.%u.%u.%u:%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));\n-}\n-\n-void CAddress::print() const\n-{\n-    printf(\"CAddress(%s)\\n\", ToString().c_str());\n-}\n-\n CInv::CInv()\n {\n     type = 0;\n@@ -310,3 +147,4 @@ void CInv::print() const\n {\n     printf(\"CInv(%s)\\n\", ToString().c_str());\n }\n+"
      },
      {
        "sha": "67e20d94e13eed83c8ae11c30ca959e43d7ae924",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 8,
        "deletions": 31,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -11,6 +11,8 @@\n #define __INCLUDED_PROTOCOL_H__\n \n #include \"serialize.h\"\n+#include \"netbase.h\"\n+#include \"util.h\"\n #include <string>\n #include \"uint256.h\"\n \n@@ -61,58 +63,33 @@ enum\n     NODE_NETWORK = (1 << 0),\n };\n \n-class CAddress\n+class CAddress : public CService\n {\n     public:\n         CAddress();\n-        CAddress(unsigned int ipIn, unsigned short portIn=0, uint64 nServicesIn=NODE_NETWORK);\n-        explicit CAddress(const struct sockaddr_in& sockaddr, uint64 nServicesIn=NODE_NETWORK);\n-        explicit CAddress(const char* pszIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK);\n-        explicit CAddress(const char* pszIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK);\n-        explicit CAddress(std::string strIn, int portIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK);\n-        explicit CAddress(std::string strIn, bool fNameLookup = false, uint64 nServicesIn=NODE_NETWORK);\n+        CAddress(CService ipIn, uint64 nServicesIn=NODE_NETWORK);\n \n         void Init();\n \n         IMPLEMENT_SERIALIZE\n             (\n+             CAddress* pthis = const_cast<CAddress*>(this);\n+             CService* pip = (CService*)pthis;\n              if (fRead)\n-             const_cast<CAddress*>(this)->Init();\n+                 pthis->Init();\n              if (nType & SER_DISK)\n              READWRITE(nVersion);\n              if ((nType & SER_DISK) || (nVersion >= 31402 && !(nType & SER_GETHASH)))\n              READWRITE(nTime);\n              READWRITE(nServices);\n-             READWRITE(FLATDATA(pchReserved)); // for IPv6\n-             READWRITE(ip);\n-             READWRITE(port);\n+             READWRITE(*pip);\n             )\n \n-        friend bool operator==(const CAddress& a, const CAddress& b);\n-        friend bool operator!=(const CAddress& a, const CAddress& b);\n-        friend bool operator<(const CAddress& a, const CAddress& b);\n-\n-        std::vector<unsigned char> GetKey() const;\n-        struct sockaddr_in GetSockAddr() const;\n-        bool IsIPv4() const;\n-        bool IsRFC1918() const;\n-        bool IsRFC3927() const;\n-        bool IsLocal() const;\n-        bool IsRoutable() const;\n-        bool IsValid() const;\n-        unsigned char GetByte(int n) const;\n-        std::string ToStringIPPort() const;\n-        std::string ToStringIP() const;\n-        std::string ToStringPort() const;\n-        std::string ToString() const;\n         void print() const;\n \n     // TODO: make private (improves encapsulation)\n     public:\n         uint64 nServices;\n-        unsigned char pchReserved[12];\n-        unsigned int ip;\n-        unsigned short port;\n \n         // disk and network only\n         unsigned int nTime;"
      },
      {
        "sha": "3237845c2cb451fdec91c2af8f90f97aa211f7bd",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -88,9 +88,9 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             {\n                 // Use CAddress to parse and check IP\n                 CAddress addr(value.toString().toStdString() + \":1\");\n-                if (addr.ip != INADDR_NONE)\n+                if (addr.IsValid())\n                 {\n-                    addrProxy.ip = addr.ip;\n+                    addrProxy.SetIP(addr);\n                     walletdb.WriteSetting(\"addrProxy\", addrProxy);\n                 }\n                 else\n@@ -104,7 +104,7 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n                 int nPort = atoi(value.toString().toAscii().data());\n                 if (nPort > 0 && nPort < std::numeric_limits<unsigned short>::max())\n                 {\n-                    addrProxy.port = htons(nPort);\n+                    addrProxy.SetPort(nPort);\n                     walletdb.WriteSetting(\"addrProxy\", addrProxy);\n                 }\n                 else"
      },
      {
        "sha": "f29f036eb328a0dee936c96e0097c8fd1a346dcb",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 18,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -10,40 +10,47 @@\n #include \"net.h\"\n #include \"util.h\"\n \n-using namespace std;\n+#include <stdint.h>\n+\n+CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), GetDefaultPort());\n+}\n \n BOOST_AUTO_TEST_SUITE(DoS_tests)\n \n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     CNode::ClearBanned();\n-    CAddress addr1(0xa0b0c001);\n+    CAddress addr1(ip(0xa0b0c001));\n     CNode dummyNode1(INVALID_SOCKET, addr1, true);\n     dummyNode1.Misbehaving(100); // Should get banned\n-    BOOST_CHECK(CNode::IsBanned(addr1.ip));\n-    BOOST_CHECK(!CNode::IsBanned(addr1.ip|0x0000ff00)); // Different ip, not banned\n+    BOOST_CHECK(CNode::IsBanned(addr1));\n+    BOOST_CHECK(!CNode::IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different ip, not banned\n \n-    CAddress addr2(0xa0b0c002);\n+    CAddress addr2(ip(0xa0b0c002));\n     CNode dummyNode2(INVALID_SOCKET, addr2, true);\n     dummyNode2.Misbehaving(50);\n-    BOOST_CHECK(!CNode::IsBanned(addr2.ip)); // 2 not banned yet...\n-    BOOST_CHECK(CNode::IsBanned(addr1.ip));  // ... but 1 still should be\n+    BOOST_CHECK(!CNode::IsBanned(addr2)); // 2 not banned yet...\n+    BOOST_CHECK(CNode::IsBanned(addr1));  // ... but 1 still should be\n     dummyNode2.Misbehaving(50);\n-    BOOST_CHECK(CNode::IsBanned(addr2.ip));\n+    BOOST_CHECK(CNode::IsBanned(addr2));\n }    \n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n {\n     CNode::ClearBanned();\n     mapArgs[\"-banscore\"] = \"111\"; // because 11 is my favorite number\n-    CAddress addr1(0xa0b0c001);\n+    CAddress addr1(ip(0xa0b0c001));\n     CNode dummyNode1(INVALID_SOCKET, addr1, true);\n     dummyNode1.Misbehaving(100);\n-    BOOST_CHECK(!CNode::IsBanned(addr1.ip));\n+    BOOST_CHECK(!CNode::IsBanned(addr1));\n     dummyNode1.Misbehaving(10);\n-    BOOST_CHECK(!CNode::IsBanned(addr1.ip));\n+    BOOST_CHECK(!CNode::IsBanned(addr1));\n     dummyNode1.Misbehaving(1);\n-    BOOST_CHECK(CNode::IsBanned(addr1.ip));\n+    BOOST_CHECK(CNode::IsBanned(addr1));\n     mapArgs[\"-banscore\"] = \"100\";\n }\n \n@@ -53,20 +60,20 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     int64 nStartTime = GetTime();\n     SetMockTime(nStartTime); // Overrides future calls to GetTime()\n \n-    CAddress addr(0xa0b0c001);\n+    CAddress addr(ip(0xa0b0c001));\n     CNode dummyNode(INVALID_SOCKET, addr, true);\n \n     dummyNode.Misbehaving(100);\n-    BOOST_CHECK(CNode::IsBanned(addr.ip));\n+    BOOST_CHECK(CNode::IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);\n-    BOOST_CHECK(CNode::IsBanned(addr.ip));\n+    BOOST_CHECK(CNode::IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60*24+1);\n-    BOOST_CHECK(!CNode::IsBanned(addr.ip));\n-}    \n+    BOOST_CHECK(!CNode::IsBanned(addr));\n+}\n \n-static bool CheckNBits(unsigned int nbits1, int64 time1, unsigned int nbits2, int64 time2)\n+static bool CheckNBits(unsigned int nbits1, int64 time1, unsigned int nbits2, int64 time2)\\\n {\n     if (time1 > time2)\n         return CheckNBits(nbits2, time2, nbits1, time1);"
      },
      {
        "sha": "0d274085759b6d0e7819e3eb30b5890cdcb548eb",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -623,7 +623,7 @@ inline const uint256 operator-(const uint256& a, const uint256& b)      { return\n \n \n \n-\n+#ifdef TEST_UINT256\n \n inline int Testuint256AdHoc(std::vector<std::string> vArg)\n {\n@@ -756,3 +756,5 @@ inline int Testuint256AdHoc(std::vector<std::string> vArg)\n }\n \n #endif\n+\n+#endif"
      },
      {
        "sha": "ac7bacb7f5e455f9d611b9280807c064be89b056",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -948,12 +948,12 @@ int64 GetAdjustedTime()\n     return GetTime() + nTimeOffset;\n }\n \n-void AddTimeData(unsigned int ip, int64 nTime)\n+void AddTimeData(const CNetAddr& ip, int64 nTime)\n {\n     int64 nOffsetSample = nTime - GetTime();\n \n     // Ignore duplicates\n-    static set<unsigned int> setKnown;\n+    static set<CNetAddr> setKnown;\n     if (!setKnown.insert(ip).second)\n         return;\n \n@@ -1008,7 +1008,6 @@ void AddTimeData(unsigned int ip, int64 nTime)\n \n \n \n-\n string FormatVersion(int nVersion)\n {\n     if (nVersion%100 == 0)\n@@ -1178,3 +1177,4 @@ bool CCriticalSection::TryEnter(const char*, const char*, int)\n }\n \n #endif /* DEBUG_LOCKORDER */\n+"
      },
      {
        "sha": "1c24ed71e96d097afb062c6eccbf750f3d2955e9",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 27,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67a42f929b1434f647c63922fd02dc2b93b28060/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67a42f929b1434f647c63922fd02dc2b93b28060/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=67a42f929b1434f647c63922fd02dc2b93b28060",
        "patch": "@@ -24,6 +24,7 @@\n #include <openssl/sha.h>\n #include <openssl/ripemd.h>\n \n+#include \"netbase.h\"\n \n typedef long long  int64;\n typedef unsigned long long  uint64;\n@@ -79,20 +80,7 @@ T* alignup(T* p)\n #define S_IWUSR             0200\n #endif\n #define unlink              _unlink\n-typedef int socklen_t;\n #else\n-#define WSAGetLastError()   errno\n-#define WSAEINVAL           EINVAL\n-#define WSAEALREADY         EALREADY\n-#define WSAEWOULDBLOCK      EWOULDBLOCK\n-#define WSAEMSGSIZE         EMSGSIZE\n-#define WSAEINTR            EINTR\n-#define WSAEINPROGRESS      EINPROGRESS\n-#define WSAEADDRINUSE       EADDRINUSE\n-#define WSAENOTSOCK         EBADF\n-#define INVALID_SOCKET      (SOCKET)(~0)\n-#define SOCKET_ERROR        -1\n-typedef u_int SOCKET;\n #define _vsnprintf(a,b,c,d) vsnprintf(a,b,c,d)\n #define strlwr(psz)         to_lower(psz)\n #define _strlwr(psz)        to_lower(psz)\n@@ -104,19 +92,6 @@ inline void Sleep(int64 n)\n }\n #endif\n \n-inline int myclosesocket(SOCKET& hSocket)\n-{\n-    if (hSocket == INVALID_SOCKET)\n-        return WSAENOTSOCK;\n-#ifdef WIN32\n-    int ret = closesocket(hSocket);\n-#else\n-    int ret = close(hSocket);\n-#endif\n-    hSocket = INVALID_SOCKET;\n-    return ret;\n-}\n-#define closesocket(s)      myclosesocket(s)\n #if !defined(QT_GUI)\n inline const char* _(const char* psz)\n {\n@@ -187,9 +162,9 @@ uint64 GetRand(uint64 nMax);\n int64 GetTime();\n void SetMockTime(int64 nMockTimeIn);\n int64 GetAdjustedTime();\n-void AddTimeData(unsigned int ip, int64 nTime);\n std::string FormatFullVersion();\n std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments);\n+void AddTimeData(const CNetAddr& ip, int64 nTime);\n \n \n \n@@ -745,3 +720,4 @@ inline uint32_t ByteReverse(uint32_t value)\n }\n \n #endif\n+"
      }
    ]
  }
]