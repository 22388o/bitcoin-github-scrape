[
  {
    "sha": "9b92538adebd30353ffc1a427bc20ab0c3fc75f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YjkyNTM4YWRlYmQzMDM1M2ZmYzFhNDI3YmMyMGFiMGMzZmM3NWYx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-11T17:52:49Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2019-08-26T23:27:58Z"
      },
      "message": "Remove unused fScriptChecks parameter from CheckInputs\n\nfScriptChecks = false just short-circuits the entire function, so\npassing it in is entirely useless.",
      "tree": {
        "sha": "66f0268baf5e213a7817fb79981a0338407b9775",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66f0268baf5e213a7817fb79981a0338407b9775"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b92538adebd30353ffc1a427bc20ab0c3fc75f1",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJdZGsAAAoJEG7l83hfeLNFeEUH+gKTv4MK2c9T6g4cervz16xn\nNUbTc079texYgw6ryJImj5ardrwMfh9cfFWjer1c/8qjdYK8AHc9zkwetYxZLgKZ\nu8i4BTu3DYt+7KLKOSk6wG448rp1SDCIOCv34oUg6sG/KuGN6Sdhi6EiVilCpyvX\n6XDmqsJdcESla6VckynvNa4KOD/3wXLzuERBd5aejS23i/KaRhSV29TILkOOZGlb\n66lH80I1tvACIkBIEmdkgFU5fOg4jVetl3Ojs4xX62tUhCDm2Y3E5PE5PvglQEMp\nj89bR79IdwQAkrR/GkMAPyeUeM9bMuy3iqjuHwsjq8RrMyfyHJKeXb03VCpnWi8=\n=XotI\n-----END PGP SIGNATURE-----",
        "payload": "tree 66f0268baf5e213a7817fb79981a0338407b9775\nparent 48e5bfe2240596eb6d2ae64d4daf727fd886a696\nauthor Matt Corallo <git@bluematt.me> 1526061169 -0400\ncommitter Ben Woosley <ben.woosley@gmail.com> 1566862078 -0700\n\nRemove unused fScriptChecks parameter from CheckInputs\n\nfScriptChecks = false just short-circuits the entire function, so\npassing it in is entirely useless.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b92538adebd30353ffc1a427bc20ab0c3fc75f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b92538adebd30353ffc1a427bc20ab0c3fc75f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b92538adebd30353ffc1a427bc20ab0c3fc75f1/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "48e5bfe2240596eb6d2ae64d4daf727fd886a696",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48e5bfe2240596eb6d2ae64d4daf727fd886a696",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/48e5bfe2240596eb6d2ae64d4daf727fd886a696"
      }
    ],
    "stats": {
      "total": 186,
      "additions": 91,
      "deletions": 95
    },
    "files": [
      {
        "sha": "193858cca9c38941fb0774f023751e1f40ea5030",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b92538adebd30353ffc1a427bc20ab0c3fc75f1/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b92538adebd30353ffc1a427bc20ab0c3fc75f1/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=9b92538adebd30353ffc1a427bc20ab0c3fc75f1",
        "patch": "@@ -13,7 +13,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n \n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n@@ -125,7 +125,7 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n             // WITNESS requires P2SH\n             test_flags |= SCRIPT_VERIFY_P2SH;\n         }\n-        bool ret = CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, nullptr);\n+        bool ret = CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, nullptr);\n         // CheckInputs should succeed iff test_flags doesn't intersect with\n         // failing_flags\n         bool expected_return_value = !(test_flags & failing_flags);\n@@ -135,13 +135,13 @@ static void ValidateCheckInputsForAllFlags(const CTransaction &tx, uint32_t fail\n         if (ret && add_to_cache) {\n             // Check that we get a cache hit if the tx was valid\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK(scriptchecks.empty());\n         } else {\n             // Check that we get script executions to check, if the transaction\n             // was invalid, or we didn't add to cache.\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, &::ChainstateActive().CoinsTip(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n         }\n     }\n@@ -204,13 +204,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(spend_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n@@ -272,7 +272,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_cltv_tx), state, ::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -300,7 +300,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(CTransaction(invalid_with_csv_tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n@@ -362,12 +362,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(CTransaction(tx), state, &::ChainstateActive().CoinsTip(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      },
      {
        "sha": "c1646743f6a2717f1ade16f8c3e5f9dc2440ecc2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 81,
        "deletions": 85,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b92538adebd30353ffc1a427bc20ab0c3fc75f1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b92538adebd30353ffc1a427bc20ab0c3fc75f1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=9b92538adebd30353ffc1a427bc20ab0c3fc75f1",
        "patch": "@@ -184,7 +184,7 @@ std::unique_ptr<CBlockTreeDB> pblocktree;\n // See definition for documentation\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const FlatFilePos &pos, bool fReadOnly = false);\n static FlatFileSeq BlockFileSeq();\n static FlatFileSeq UndoFileSeq();\n@@ -425,7 +425,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n         }\n     }\n \n-    return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n+    return CheckInputs(tx, state, view, flags, cacheSigStore, true, txdata);\n }\n \n /**\n@@ -773,15 +773,17 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n \n         // Check against previous transactions\n-        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n+        // The first loop above does all the inexpensive checks.\n+        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n+        // Helps prevent CPU exhaustion denial-of-service attacks.\n         PrecomputedTransactionData txdata(tx);\n-        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, false, txdata)) {\n+        if (!CheckInputs(tx, state, view, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n             CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n+            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, stateDummy, view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n                         state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n@@ -1298,90 +1300,79 @@ void InitScriptExecutionCache() {\n  *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (!tx.IsCoinBase())\n-    {\n-        if (pvChecks)\n-            pvChecks->reserve(tx.vin.size());\n-\n-        // The first loop above does all the inexpensive checks.\n-        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n-        // Helps prevent CPU exhaustion attacks.\n-\n-        // Skip script verification when connecting blocks under the\n-        // assumevalid block. Assuming the assumevalid block is valid this\n-        // is safe because block merkle hashes are still computed and checked,\n-        // Of course, if an assumed valid block is invalid due to false scriptSigs\n-        // this optimization would allow an invalid chain to be accepted.\n-        if (fScriptChecks) {\n-            // First check if script executions have been cached with the same\n-            // flags. Note that this assumes that the inputs provided are\n-            // correct (ie that the transaction hash which is in tx's prevouts\n-            // properly commits to the scriptPubKey in the inputs view of that\n-            // transaction).\n-            uint256 hashCacheEntry;\n-            // We only use the first 19 bytes of nonce to avoid a second SHA\n-            // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n-            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n-            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n-            AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n-            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n-                return true;\n-            }\n-\n-            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-                const COutPoint &prevout = tx.vin[i].prevout;\n-                const Coin& coin = inputs.AccessCoin(prevout);\n-                assert(!coin.IsSpent());\n-\n-                // We very carefully only pass in things to CScriptCheck which\n-                // are clearly committed to by tx' witness hash. This provides\n-                // a sanity check that our caching is not introducing consensus\n-                // failures through additional data in, eg, the coins being\n-                // spent being checked as a part of CScriptCheck.\n-\n-                // Verify signature\n-                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n-                if (pvChecks) {\n-                    pvChecks->push_back(CScriptCheck());\n-                    check.swap(pvChecks->back());\n-                } else if (!check()) {\n-                    if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n-                        // Check whether the failure was caused by a\n-                        // non-mandatory script verification check, such as\n-                        // non-standard DER encodings or non-null dummy\n-                        // arguments; if so, ensure we return NOT_STANDARD\n-                        // instead of CONSENSUS to avoid downstream users\n-                        // splitting the network between upgraded and\n-                        // non-upgraded nodes by banning CONSENSUS-failing\n-                        // data providers.\n-                        CScriptCheck check2(coin.out, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n-                        if (check2())\n-                            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n-                    }\n-                    // MANDATORY flag failures correspond to\n-                    // ValidationInvalidReason::CONSENSUS. Because CONSENSUS\n-                    // failures are the most serious case of validation\n-                    // failures, we may need to consider using\n-                    // RECENT_CONSENSUS_CHANGE for any script failure that\n-                    // could be due to non-upgraded nodes which we may want to\n-                    // support, to avoid splitting the network (but this\n-                    // depends on the details of how net_processing handles\n-                    // such errors).\n-                    return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n-                }\n-            }\n+    if (tx.IsCoinBase()) return true;\n+\n+    if (pvChecks) {\n+        pvChecks->reserve(tx.vin.size());\n+    }\n+\n+    // First check if script executions have been cached with the same\n+    // flags. Note that this assumes that the inputs provided are\n+    // correct (ie that the transaction hash which is in tx's prevouts\n+    // properly commits to the scriptPubKey in the inputs view of that\n+    // transaction).\n+    uint256 hashCacheEntry;\n+    // We only use the first 19 bytes of nonce to avoid a second SHA\n+    // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n+    static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n+    CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n+    AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n+    if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n+        return true;\n+    }\n \n-            if (cacheFullScriptStore && !pvChecks) {\n-                // We executed all of the provided scripts, and were told to\n-                // cache the result. Do so now.\n-                scriptExecutionCache.insert(hashCacheEntry);\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        const COutPoint &prevout = tx.vin[i].prevout;\n+        const Coin& coin = inputs.AccessCoin(prevout);\n+        assert(!coin.IsSpent());\n+\n+        // We very carefully only pass in things to CScriptCheck which\n+        // are clearly committed to by tx' witness hash. This provides\n+        // a sanity check that our caching is not introducing consensus\n+        // failures through additional data in, eg, the coins being\n+        // spent being checked as a part of CScriptCheck.\n+\n+        // Verify signature\n+        CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n+        if (pvChecks) {\n+            pvChecks->push_back(CScriptCheck());\n+            check.swap(pvChecks->back());\n+        } else if (!check()) {\n+            if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n+                // Check whether the failure was caused by a\n+                // non-mandatory script verification check, such as\n+                // non-standard DER encodings or non-null dummy\n+                // arguments; if so, ensure we return NOT_STANDARD\n+                // instead of CONSENSUS to avoid downstream users\n+                // splitting the network between upgraded and\n+                // non-upgraded nodes by banning CONSENSUS-failing\n+                // data providers.\n+                CScriptCheck check2(coin.out, tx, i,\n+                        flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n+                if (check2())\n+                    return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n             }\n+            // MANDATORY flag failures correspond to\n+            // ValidationInvalidReason::CONSENSUS. Because CONSENSUS\n+            // failures are the most serious case of validation\n+            // failures, we may need to consider using\n+            // RECENT_CONSENSUS_CHANGE for any script failure that\n+            // could be due to non-upgraded nodes which we may want to\n+            // support, to avoid splitting the network (but this\n+            // depends on the details of how net_processing handles\n+            // such errors).\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n         }\n     }\n \n+    if (cacheFullScriptStore && !pvChecks) {\n+        // We executed all of the provided scripts, and were told to\n+        // cache the result. Do so now.\n+        scriptExecutionCache.insert(hashCacheEntry);\n+    }\n+\n     return true;\n }\n \n@@ -1769,6 +1760,11 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n+                // Script verification is skipped when connecting blocks under the\n+                // assumevalid block. Assuming the assumevalid block is valid this\n+                // is safe because block merkle hashes are still computed and checked,\n+                // Of course, if an assumed valid block is invalid due to false scriptSigs\n+                // this optimization would allow an invalid chain to be accepted.\n                 // The equivalent time check discourages hash power from extorting the network via DOS attack\n                 //  into accepting an invalid block through telling users they must manually set assumevalid.\n                 //  Requiring a software change or burying the invalid block, regardless of the setting, makes\n@@ -1952,7 +1948,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         {\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n+            if (fScriptChecks && !CheckInputs(tx, state, view, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr)) {\n                 if (state.GetReason() == ValidationInvalidReason::TX_NOT_STANDARD) {\n                     // CheckInputs may return NOT_STANDARD for extra flags we passed,\n                     // but we can't return that, as it's not defined for a block, so"
      }
    ]
  }
]