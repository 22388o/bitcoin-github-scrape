[
  {
    "sha": "1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYTZlYWQzZDUzNTM0ZGY4Zjc0MTBjYzYwNDZmODNlNmI5YjQxYmJk",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:06:49Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T16:44:46Z"
      },
      "message": "Drop return argument from CValidationState::Invalid\n\nIt's false in every case.",
      "tree": {
        "sha": "c376f05cce2204f20b21769120ee6ba32559b751",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c376f05cce2204f20b21769120ee6ba32559b751"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJaeIoAAAoJEG7l83hfeLNF5okH/R8agIlSCxj7+c2keDErzRPO\nNsPJlZIjLxCWpRQgRwXItC0XyZooMr8l77Nl8c1J+q2Uqvg6TrW0advBID44wfZR\njhubhwvf81RucKviHF1Ld8v7oBB8c4TzBxrabm4y8HMtWR8kOd8j6XsUZbNQJp5m\nlfY0mkSKuiUCHrdTlWP0PV3eyLIfOaBRB/yZVx/OGh31GdfqGBrJ5u1EJo6QSv/Z\nFzZx6Ickm0y9vFnccN0JIEzucXP0bs4n7GgqODjp0WAUKaOXEoe8xmQCLzUvWpNB\nNUJxALzteyNm3/1j4rvNN5iLBs54Ft8lZWStkpAX3ogsQbzjeK5kfDi20K2aV4A=\n=SoPk\n-----END PGP SIGNATURE-----",
        "payload": "tree c376f05cce2204f20b21769120ee6ba32559b751\nparent d32528e733f2711b34dbc41fbb2bb0f153bf7e9a\nauthor Ben Woosley <ben.woosley@gmail.com> 1517843209 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1517849086 -0500\n\nDrop return argument from CValidationState::Invalid\n\nIt's false in every case.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d32528e733f2711b34dbc41fbb2bb0f153bf7e9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d32528e733f2711b34dbc41fbb2bb0f153bf7e9a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d32528e733f2711b34dbc41fbb2bb0f153bf7e9a"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 18,
      "deletions": 19
    },
    "files": [
      {
        "sha": "b8c48a1d4eadcaafac9b388e266cb271fc183986",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
        "patch": "@@ -221,8 +221,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(false,\n-                REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "b83b65d546ef834448e82fbc31b8fc99795efed2",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
        "patch": "@@ -51,10 +51,9 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return ret;\n     }\n-    bool Invalid(bool ret = false,\n-                 unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n+    bool Invalid(unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(0, false, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "50bbe01488a3d4aa6d96842edbb26ecc16863fab",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 14,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
        "patch": "@@ -351,7 +351,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n \n     CBlockIndex* tip = chainActive.Tip();\n     assert(tip != nullptr);\n-    \n+\n     CBlockIndex index;\n     index.pprev = tip;\n     // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n@@ -576,7 +576,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -616,7 +616,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -645,7 +645,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Invalid(REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -679,7 +679,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Invalid(REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n@@ -726,8 +726,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(false,\n-                REJECT_HIGHFEE, \"absurdly-high-fee\",\n+            return state.Invalid(REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n@@ -1412,7 +1411,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Invalid(REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -3002,7 +3001,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n+            return state.Invalid(state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3112,18 +3111,18 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.Invalid(REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3230,8 +3229,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n             pindex = miSelf->second;\n             if (ppindex)\n                 *ppindex = pindex;\n-            if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+            if (pindex->nStatus & BLOCK_FAILED_MASK) {\n+              error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n+              return state.Invalid(0, \"duplicate\");\n+            }\n             return true;\n         }\n "
      }
    ]
  },
  {
    "sha": "d754cc953e140afd5eadeef21ef641900339d9f5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNzU0Y2M5NTNlMTQwYWZkNWVhZGVlZjIxZWY2NDE5MDAzMzlkOWY1",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:18:34Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T16:44:58Z"
      },
      "message": "Drop return argument from CValidationState::DoS\n\nIt was always false. Note error() always returns false.",
      "tree": {
        "sha": "d243f7de8872b72e9fa862f827b214004679896c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d243f7de8872b72e9fa862f827b214004679896c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d754cc953e140afd5eadeef21ef641900339d9f5",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJaeIoKAAoJEG7l83hfeLNF2HoH/0KIKlv76zgV+jZ3kkF3ZXUs\nbtuyUU7tddVQbk4AUNHRmFUY6SVNFsgcUVbrDhnHPZ/k2mUzOQ0sJGckQrlvnwBQ\nBI7qE4vGb1gOuDHOiKssroxdJeNj/CeKr4p1eF/+SzPAOfL66MMvoCcshZZKCvnV\nVFY/YAtrAKFpMftukxehVHZ/6TEcutZuzyQE48M0crIoOtUVt0NSpq1wRqGGewJ7\n+Q3ONL2rmM06Q/UUHOMkyyQFpokeNDvemxWLH8CHip1Y0alhzRB0BpqkkH7yUC4h\nQka3qwt/FptnE4mMF3qCbh7oW8+vRBpV93BmlDZ3XOHQLGEGM1seXFDq3Ddr3WU=\n=wxnv\n-----END PGP SIGNATURE-----",
        "payload": "tree d243f7de8872b72e9fa862f827b214004679896c\nparent 1a6ead3d53534df8f7410cc6046f83e6b9b41bbd\nauthor Ben Woosley <ben.woosley@gmail.com> 1517843914 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1517849098 -0500\n\nDrop return argument from CValidationState::DoS\n\nIt was always false. Note error() always returns false.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d754cc953e140afd5eadeef21ef641900339d9f5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d754cc953e140afd5eadeef21ef641900339d9f5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d754cc953e140afd5eadeef21ef641900339d9f5/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a6ead3d53534df8f7410cc6046f83e6b9b41bbd"
      }
    ],
    "stats": {
      "total": 163,
      "additions": 83,
      "deletions": 80
    },
    "files": [
      {
        "sha": "2e1b558ae826be9fb9b647d54ce93c76222a2850",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d754cc953e140afd5eadeef21ef641900339d9f5/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d754cc953e140afd5eadeef21ef641900339d9f5/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=d754cc953e140afd5eadeef21ef641900339d9f5",
        "patch": "@@ -160,24 +160,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.DoS(10, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.DoS(10, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -186,20 +186,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.DoS(10, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;\n@@ -209,7 +209,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -228,20 +228,20 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "4f7c8d8a8d818274908fb79b1c72fa1da8e132e4",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d754cc953e140afd5eadeef21ef641900339d9f5/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d754cc953e140afd5eadeef21ef641900339d9f5/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=d754cc953e140afd5eadeef21ef641900339d9f5",
        "patch": "@@ -37,23 +37,22 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n-             unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n+    bool DoS(int level, unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n              bool corruptionIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n         if (mode == MODE_ERROR)\n-            return ret;\n+            return false;\n         nDoS += level;\n         mode = MODE_INVALID;\n-        return ret;\n+        return false;\n     }\n     bool Invalid(unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, false, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(0, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "48e605f2d155c1b098a16bff71d59a5258a8e8d2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 62,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d754cc953e140afd5eadeef21ef641900339d9f5/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d754cc953e140afd5eadeef21ef641900339d9f5/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d754cc953e140afd5eadeef21ef641900339d9f5",
        "patch": "@@ -555,24 +555,24 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n+        return state.DoS(100, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        return state.DoS(0, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n+        return state.DoS(0, REJECT_NONSTANDARD, reason);\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.DoS(0, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n@@ -668,7 +668,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.DoS(0, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         } // end LOCK(pool.cs)\n \n@@ -683,7 +683,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.DoS(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -712,17 +712,17 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n+            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n+            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -737,7 +737,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.DoS(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -749,8 +749,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, false,\n-                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.DoS(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n                                            hashAncestor.ToString()));\n@@ -803,8 +802,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, false,\n-                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n@@ -832,8 +830,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, false,\n-                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.DoS(0, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n@@ -852,8 +849,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, false,\n-                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.DoS(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n                 }\n@@ -864,8 +860,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, false,\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -875,8 +870,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, false,\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n@@ -966,7 +960,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1420,7 +1414,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.DoS(100, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1872,8 +1866,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                     REJECT_INVALID, \"bad-txns-BIP30\");\n+                    error(\"ConnectBlock(): tried to overwrite transaction\");\n+                    return state.DoS(100, REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -1916,8 +1910,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, error(\"%s: accumulated fee in the block out of range.\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n+                error(\"%s: accumulated fee in the block out of range.\", __func__);\n+                return state.DoS(100, REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -1929,8 +1923,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n+                error(\"%s: contains a non-BIP68-final transaction\", __func__);\n+                return state.DoS(100, REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -1939,9 +1933,10 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * p2sh (when P2SH enabled in flags and excludes coinbase)\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n-        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n-                             REJECT_INVALID, \"bad-blk-sigops\");\n+        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n+            error(\"ConnectBlock(): too many sigops\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\");\n+        }\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n@@ -1964,14 +1959,16 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", (unsigned)block.vtx.size(), MILLI * (nTime3 - nTime2), MILLI * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : MILLI * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * MICRO, nTimeConnect * MILLI / nBlocksTotal);\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n-    if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100,\n-                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n-                               block.vtx[0]->GetValueOut(), blockReward),\n-                               REJECT_INVALID, \"bad-cb-amount\");\n-\n-    if (!control.Wait())\n-        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+    if (block.vtx[0]->GetValueOut() > blockReward) {\n+        error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n+              block.vtx[0]->GetValueOut(), blockReward);\n+        return state.DoS(100, REJECT_INVALID, \"bad-cb-amount\");\n+    }\n+\n+    if (!control.Wait()) {\n+        error(\"%s: CheckQueue failed\", __func__);\n+        return state.DoS(100, REJECT_INVALID, \"block-validation-failed\");\n+    }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -2950,7 +2947,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.DoS(50, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n \n     return true;\n }\n@@ -2972,13 +2969,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -2989,14 +2986,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n@@ -3010,7 +3007,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3097,16 +3094,18 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n         // Don't accept any forks from the main chain prior to last checkpoint.\n         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n-        if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+        if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n+            error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n+            return state.DoS(100, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+        }\n     }\n \n     // Check timestamp against prev\n@@ -3151,7 +3150,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.DoS(10, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n         }\n     }\n \n@@ -3161,7 +3160,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3183,11 +3182,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));\n+                return state.DoS(100, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.DoS(100, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3197,7 +3196,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.DoS(100, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3209,7 +3208,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3242,11 +3241,15 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+        if (mi == mapBlockIndex.end()) {\n+            error(\"%s: prev block not found\", __func__);\n+            return state.DoS(10, 0, \"prev-blk-not-found\");\n+        }\n         pindexPrev = (*mi).second;\n-        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+        if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n+            error(\"%s: prev block invalid\", __func__);\n+            return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n+        }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3260,7 +3263,8 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    error(\"%s: prev block invalid\", __func__);\n+                    return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTQ4ZjU2ODdiMDZlZjdkNTk0YWU0MGNhZDk4NGNmY2FjYjBkOGEz",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:20:54Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T16:44:58Z"
      },
      "message": "Drop unused default arguments to CValidationState::DoS and ::Invalid",
      "tree": {
        "sha": "81f73094bdb4b60137774e2cb33a0c2be9bc9634",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/81f73094bdb4b60137774e2cb33a0c2be9bc9634"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJaeIoKAAoJEG7l83hfeLNFd30H/33h5g/iZIUCa2zW+hbZzltt\n4FnAIbrPV8Vjg673C+CeNVFYEiddLkF49XqVZkkYQscPjIFYS+z3nucy1b51law4\nMwqxhfQZYQOPV6RfL0Pl3xJQmrNXm3aJTLmfixJFRjbUtruTXMXTo43y0BqZ0N0C\ngxH/pzmo2ha10nTkdKD/tUhTt+qp0RQBS9vQAPukBHZBNoLoj1MtZjtiPGOWiS9q\nUdAnzS7AKwONPPmId8xSANV5M1UJDJZBAgw95SMKFKW7pBwH/P2Zr61rUJYETPUi\ns5w782tmIO9Uc6t+Gxl6gL4hs3EEyDMYCa9mNAPvXS4uK/z8UI9W4UJ0jDAaztE=\n=g/1/\n-----END PGP SIGNATURE-----",
        "payload": "tree 81f73094bdb4b60137774e2cb33a0c2be9bc9634\nparent d754cc953e140afd5eadeef21ef641900339d9f5\nauthor Ben Woosley <ben.woosley@gmail.com> 1517844054 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1517849098 -0500\n\nDrop unused default arguments to CValidationState::DoS and ::Invalid\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d754cc953e140afd5eadeef21ef641900339d9f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d754cc953e140afd5eadeef21ef641900339d9f5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d754cc953e140afd5eadeef21ef641900339d9f5"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "1b8b7c8435d01e6922776eaf954cff5bb282ba81",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
        "patch": "@@ -37,7 +37,7 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n+    bool DoS(int level, unsigned int chRejectCodeIn, const std::string &strRejectReasonIn,\n              bool corruptionIn=false,\n              const std::string &strDebugMessageIn=\"\") {\n         chRejectCode = chRejectCodeIn;\n@@ -50,7 +50,7 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return false;\n     }\n-    bool Invalid(unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n+    bool Invalid(unsigned int _chRejectCode, const std::string &_strRejectReason,\n                  const std::string &_strDebugMessage=\"\") {\n         return DoS(0, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }"
      }
    ]
  },
  {
    "sha": "32005810b2bc88b3e0132f863622684f71f24033",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMjAwNTgxMGIyYmM4OGIzZTAxMzJmODYzNjIyNjg0ZjcxZjI0MDMz",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:26:41Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T16:45:25Z"
      },
      "message": "Make the level explicit for CValidationState::Invalid",
      "tree": {
        "sha": "9b0a365049095abc9b5e36bfb3ef63dcea0a1983",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b0a365049095abc9b5e36bfb3ef63dcea0a1983"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32005810b2bc88b3e0132f863622684f71f24033",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJaeIolAAoJEG7l83hfeLNF0L4H/jEgtR+mzvRbUPxYkEtoWFg5\nEsXL9C8kGqFiqJioxKLFrzrT/OZrhXrvuqTz3FkQ8ToEL7VxH2wkgHBfaYh66l1g\ngnz5UP693Uta1gpgsWAygIdxLNwvPE0JgcKe6/o/ClnJzX1IZDHB1eHwXFQTD6bK\nsPVGKugxuyx5PwXl7pAxRISG4npG07jnw6kqGWoqoUQCjunXFIRPQTde4x+fSaNN\nzpk8SgaegzViwcxhsdPBb0bMvDFw/3Qu/jrxOynJj20NHCTtNRfWzXyZZ2mAzk5o\nHIlSyNQQLvwxjEaZ5VdCI6CsOdV5fYtDc3OJLM4r8kkqBHG14mFAiCD+JiXYzY8=\n=6mVc\n-----END PGP SIGNATURE-----",
        "payload": "tree 9b0a365049095abc9b5e36bfb3ef63dcea0a1983\nparent 5e48f5687b06ef7d594ae40cad984cfcacb0d8a3\nauthor Ben Woosley <ben.woosley@gmail.com> 1517844401 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1517849125 -0500\n\nMake the level explicit for CValidationState::Invalid\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32005810b2bc88b3e0132f863622684f71f24033",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32005810b2bc88b3e0132f863622684f71f24033",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32005810b2bc88b3e0132f863622684f71f24033/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5e48f5687b06ef7d594ae40cad984cfcacb0d8a3"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 15,
      "deletions": 15
    },
    "files": [
      {
        "sha": "5264bc2ea63e4bfe1a2f5d009545b4283921ba6a",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32005810b2bc88b3e0132f863622684f71f24033/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32005810b2bc88b3e0132f863622684f71f24033/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=32005810b2bc88b3e0132f863622684f71f24033",
        "patch": "@@ -221,7 +221,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(0, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "a429dde0115786019a2ad16622c6e46ee77b5897",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32005810b2bc88b3e0132f863622684f71f24033/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32005810b2bc88b3e0132f863622684f71f24033/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=32005810b2bc88b3e0132f863622684f71f24033",
        "patch": "@@ -50,9 +50,9 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return false;\n     }\n-    bool Invalid(unsigned int _chRejectCode, const std::string &_strRejectReason,\n+    bool Invalid(int level, unsigned int _chRejectCode, const std::string &_strRejectReason,\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(level, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "f4f9639b969205794b3e0733088962fc86d0b616",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32005810b2bc88b3e0132f863622684f71f24033/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32005810b2bc88b3e0132f863622684f71f24033/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=32005810b2bc88b3e0132f863622684f71f24033",
        "patch": "@@ -576,7 +576,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(0, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -616,7 +616,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(0, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -645,14 +645,14 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Invalid(0, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n                 if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n+                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid(0, )\n             }\n         }\n \n@@ -679,7 +679,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Invalid(0, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n@@ -726,7 +726,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(REJECT_HIGHFEE, \"absurdly-high-fee\",\n+            return state.Invalid(0, REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n@@ -1405,7 +1405,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Invalid(0, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -2998,7 +2998,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(state.GetRejectCode(), state.GetRejectReason(),\n+            return state.Invalid(0, state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3110,18 +3110,18 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(0, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(0, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.Invalid(0, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3230,7 +3230,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n               error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n-              return state.Invalid(0, \"duplicate\");\n+              return state.Invalid(0, 0, \"duplicate\");\n             }\n             return true;\n         }"
      }
    ]
  },
  {
    "sha": "6d4d5f74618e0807e447c7dd6a08661ce7f45394",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDRkNWY3NDYxOGUwODA3ZTQ0N2M3ZGQ2YTA4NjYxY2U3ZjQ1Mzk0",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:35:45Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T16:45:25Z"
      },
      "message": "Introduce CValidationState::Corrupt and privatize ::DoS\n\n::Invalid, and ::Corrupt together encode the possiblyCorrupt argument into\na method-level concern. This makes the interface more explicit by making\nthis literal argument self-explanatory, and by not separating the\nmessage strings.",
      "tree": {
        "sha": "fd09eb0dea072a94b58ff183366b1c85979b39eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fd09eb0dea072a94b58ff183366b1c85979b39eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d4d5f74618e0807e447c7dd6a08661ce7f45394",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJaeIolAAoJEG7l83hfeLNFzpkH/0VZkLAWLP6UKa9+LyuWbcB9\nsWxTcINGkwc2IHQJaI4lwxt71vklWwBnbpZIH7yAV/9tiq08DVcOJqA1Gyait7cS\nKoSQ740e1EnsQavTkvNf1kKngNpUkZO1KtA62GDBO0+4Uhr+hPWRE5uditkwPoND\nNyYpvbLL6OEO8T6M0v6vQbP8Dv1PDmetqvMU9sCHyYAn2K4qBYBZtXiybqeTTATq\nlJuYagT4snC2eYIuiY4a24b/9mOBQPAJON784WcqAePjW3uVe5i1xF25XB95we3s\nL9ID3k/VB2A46aTn6nQpZfgztko+mNvChPn/na4VAwRdFu3/6cvf5TP+/ku4cXo=\n=hKF2\n-----END PGP SIGNATURE-----",
        "payload": "tree fd09eb0dea072a94b58ff183366b1c85979b39eb\nparent 32005810b2bc88b3e0132f863622684f71f24033\nauthor Ben Woosley <ben.woosley@gmail.com> 1517844945 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1517849125 -0500\n\nIntroduce CValidationState::Corrupt and privatize ::DoS\n\n::Invalid, and ::Corrupt together encode the possiblyCorrupt argument into\na method-level concern. This makes the interface more explicit by making\nthis literal argument self-explanatory, and by not separating the\nmessage strings.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d4d5f74618e0807e447c7dd6a08661ce7f45394",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d4d5f74618e0807e447c7dd6a08661ce7f45394",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d4d5f74618e0807e447c7dd6a08661ce7f45394/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "32005810b2bc88b3e0132f863622684f71f24033",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32005810b2bc88b3e0132f863622684f71f24033",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/32005810b2bc88b3e0132f863622684f71f24033"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 71,
      "deletions": 60
    },
    "files": [
      {
        "sha": "6fd841c3153043332f37da29799f1e0d89d72c06",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d4d5f74618e0807e447c7dd6a08661ce7f45394/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d4d5f74618e0807e447c7dd6a08661ce7f45394/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=6d4d5f74618e0807e447c7dd6a08661ce7f45394",
        "patch": "@@ -160,24 +160,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.Invalid(10, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.Invalid(10, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -186,20 +186,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.Invalid(100, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-length\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.Invalid(10, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;\n@@ -209,7 +209,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.Invalid(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -228,20 +228,20 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.Invalid(100, REJECT_INVALID, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "49d5912a67014291c7cf360239a51c6937045eeb",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d4d5f74618e0807e447c7dd6a08661ce7f45394/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d4d5f74618e0807e447c7dd6a08661ce7f45394/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=6d4d5f74618e0807e447c7dd6a08661ce7f45394",
        "patch": "@@ -35,10 +35,9 @@ class CValidationState {\n     unsigned int chRejectCode;\n     bool corruptionPossible;\n     std::string strDebugMessage;\n-public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, unsigned int chRejectCodeIn, const std::string &strRejectReasonIn,\n-             bool corruptionIn=false,\n+\n+    bool DoS(int level, unsigned int chRejectCodeIn, bool corruptionIn,\n+             const std::string &strRejectReasonIn,\n              const std::string &strDebugMessageIn=\"\") {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n@@ -50,9 +49,17 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return false;\n     }\n+\n+public:\n+    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+\n     bool Invalid(int level, unsigned int _chRejectCode, const std::string &_strRejectReason,\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(level, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(level, _chRejectCode, false, _strRejectReason, _strDebugMessage);\n+    }\n+    bool Corrupt(int level, unsigned int _chRejectCode, const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\") {\n+        return DoS(level, _chRejectCode, true, _strRejectReason, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "c92ebf27456694cb9cedd3900a2f4844404791ec",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 42,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d4d5f74618e0807e447c7dd6a08661ce7f45394/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d4d5f74618e0807e447c7dd6a08661ce7f45394/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6d4d5f74618e0807e447c7dd6a08661ce7f45394",
        "patch": "@@ -555,24 +555,24 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, REJECT_INVALID, \"coinbase\");\n+        return state.Invalid(100, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        return state.Corrupt(0, REJECT_NONSTANDARD, \"no-witness-yet\");\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, REJECT_NONSTANDARD, reason);\n+        return state.Invalid(0, REJECT_NONSTANDARD, reason);\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, REJECT_NONSTANDARD, \"non-final\");\n+        return state.Invalid(0, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n@@ -668,7 +668,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.Invalid(0, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         } // end LOCK(pool.cs)\n \n@@ -683,7 +683,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.Corrupt(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -712,17 +712,18 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.Invalid(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n+            return state.Invalid(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\",\n+                strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n+            return state.Invalid(0, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -737,7 +738,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.Invalid(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -749,7 +750,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.Invalid(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n                                  strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n                                            hashAncestor.ToString()));\n@@ -802,7 +803,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.Invalid(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n@@ -830,7 +831,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.Invalid(0, REJECT_NONSTANDARD, \"too many potential replacements\",\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n@@ -849,7 +850,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.Invalid(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n                 }\n@@ -860,7 +861,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.Invalid(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -870,7 +871,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.Invalid(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n@@ -960,7 +961,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.Invalid(0, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1414,7 +1415,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Invalid(100, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1867,7 +1868,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n                     error(\"ConnectBlock(): tried to overwrite transaction\");\n-                    return state.DoS(100, REJECT_INVALID, \"bad-txns-BIP30\");\n+                    return state.Invalid(100, REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -1911,7 +1912,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n                 error(\"%s: accumulated fee in the block out of range.\", __func__);\n-                return state.DoS(100, REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n+                return state.Invalid(100, REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -1924,7 +1925,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n                 error(\"%s: contains a non-BIP68-final transaction\", __func__);\n-                return state.DoS(100, REJECT_INVALID, \"bad-txns-nonfinal\");\n+                return state.Invalid(100, REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -1935,7 +1936,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n             error(\"ConnectBlock(): too many sigops\");\n-            return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-blk-sigops\");\n         }\n \n         txdata.emplace_back(tx);\n@@ -1962,12 +1963,12 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     if (block.vtx[0]->GetValueOut() > blockReward) {\n         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n               block.vtx[0]->GetValueOut(), blockReward);\n-        return state.DoS(100, REJECT_INVALID, \"bad-cb-amount\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-cb-amount\");\n     }\n \n     if (!control.Wait()) {\n         error(\"%s: CheckQueue failed\", __func__);\n-        return state.DoS(100, REJECT_INVALID, \"block-validation-failed\");\n+        return state.Invalid(100, REJECT_INVALID, \"block-validation-failed\");\n     }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n@@ -2947,7 +2948,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.Invalid(50, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -2969,13 +2970,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.Corrupt(100, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.Corrupt(100, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -2986,14 +2987,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n@@ -3007,7 +3008,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3094,7 +3095,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.Invalid(100, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3104,7 +3105,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n             error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n-            return state.DoS(100, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.Invalid(100, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n         }\n     }\n \n@@ -3150,7 +3151,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.Invalid(10, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3160,7 +3161,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3182,11 +3183,13 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));\n+                return state.Corrupt(100, REJECT_INVALID, \"bad-witness-nonce-size\",\n+                    strprintf(\"%s : invalid witness nonce size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.Corrupt(100, REJECT_INVALID, \"bad-witness-merkle-match\",\n+                    strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3196,7 +3199,8 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.Corrupt(100, REJECT_INVALID, \"unexpected-witness\",\n+                    strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3208,7 +3212,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Invalid(100, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3243,12 +3247,12 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end()) {\n             error(\"%s: prev block not found\", __func__);\n-            return state.DoS(10, 0, \"prev-blk-not-found\");\n+            return state.Invalid(10, 0, \"prev-blk-not-found\");\n         }\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n             error(\"%s: prev block invalid\", __func__);\n-            return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n+            return state.Invalid(100, REJECT_INVALID, \"bad-prevblk\");\n         }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n@@ -3264,7 +3268,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         invalid_walk = invalid_walk->pprev;\n                     }\n                     error(\"%s: prev block invalid\", __func__);\n-                    return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n+                    return state.Invalid(100, REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  }
]