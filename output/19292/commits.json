[
  {
    "sha": "a389ed52e8f4939ab5b4adcf93dcb7783d9006f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMzg5ZWQ1MmU4ZjQ5MzlhYjViNGFkY2Y5M2RjYjc3ODNkOTAwNmYx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T19:42:53Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-17T14:29:27Z"
      },
      "message": "walletdb: refactor Read, Write, Erase, and Exists into non-template func\n\nIn order to override these later, the specific details of how the Read,\nWrite, Erase, and Exists functions interact with the actual database\nfile need to go into functions that are not templated.",
      "tree": {
        "sha": "1ef234d91e7b2d9da3cfaa3862c1b4d07b188431",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ef234d91e7b2d9da3cfaa3862c1b4d07b188431"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39bd9ddb8783807b9cde6288233e86ad7c85d61f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39bd9ddb8783807b9cde6288233e86ad7c85d61f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39bd9ddb8783807b9cde6288233e86ad7c85d61f"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 77,
      "deletions": 33
    },
    "files": [
      {
        "sha": "125bf004e44126529c70f8d706d674310d0f49f0",
        "filename": "src/wallet/bdb.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1/src/wallet/bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1/src/wallet/bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.cpp?ref=a389ed52e8f4939ab5b4adcf93dcb7783d9006f1",
        "patch": "@@ -803,3 +803,67 @@ std::string BerkeleyDatabaseVersion()\n {\n     return DbEnv::version(nullptr, nullptr, nullptr);\n }\n+\n+bool BerkeleyBatch::ReadKey(CDataStream& key, CDataStream& value)\n+{\n+    if (!pdb)\n+        return false;\n+\n+    // Key\n+    SafeDbt datKey(key.data(), key.size());\n+\n+    // Read\n+    SafeDbt datValue;\n+    int ret = pdb->get(activeTxn, datKey, datValue, 0);\n+    if (ret == 0 && datValue.get_data() != nullptr) {\n+        value.write((char*)datValue.get_data(), datValue.get_size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool BerkeleyBatch::WriteKey(CDataStream& key, CDataStream& value, bool overwrite)\n+{\n+    if (!pdb)\n+        return true;\n+    if (fReadOnly)\n+        assert(!\"Write called on database in read-only mode\");\n+\n+    // Key\n+    SafeDbt datKey(key.data(), key.size());\n+\n+    // Value\n+    SafeDbt datValue(value.data(), value.size());\n+\n+    // Write\n+    int ret = pdb->put(activeTxn, datKey, datValue, (overwrite ? 0 : DB_NOOVERWRITE));\n+    return (ret == 0);\n+}\n+\n+bool BerkeleyBatch::EraseKey(CDataStream& key)\n+{\n+    if (!pdb)\n+        return false;\n+    if (fReadOnly)\n+        assert(!\"Erase called on database in read-only mode\");\n+\n+    // Key\n+    SafeDbt datKey(key.data(), key.size());\n+\n+    // Erase\n+    int ret = pdb->del(activeTxn, datKey, 0);\n+    return (ret == 0 || ret == DB_NOTFOUND);\n+}\n+\n+bool BerkeleyBatch::HasKey(CDataStream& key)\n+{\n+    if (!pdb)\n+        return false;\n+\n+    // Key\n+    SafeDbt datKey(key.data(), key.size());\n+\n+    // Exists\n+    int ret = pdb->exists(activeTxn, datKey, 0);\n+    return ret == 0;\n+}"
      },
      {
        "sha": "1e717b95bef5561ab7d9ab07faaa2ac6657e008f",
        "filename": "src/wallet/bdb.h",
        "status": "modified",
        "additions": 13,
        "deletions": 33,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a389ed52e8f4939ab5b4adcf93dcb7783d9006f1/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=a389ed52e8f4939ab5b4adcf93dcb7783d9006f1",
        "patch": "@@ -207,6 +207,12 @@ class BerkeleyBatch\n         operator Dbt*();\n     };\n \n+private:\n+    bool ReadKey(CDataStream& key, CDataStream& value);\n+    bool WriteKey(CDataStream& key, CDataStream& value, bool overwrite=true);\n+    bool EraseKey(CDataStream& key);\n+    bool HasKey(CDataStream& key);\n+\n protected:\n     Db* pdb;\n     std::string strFile;\n@@ -236,91 +242,65 @@ class BerkeleyBatch\n     template <typename K, typename T>\n     bool Read(const K& key, T& value)\n     {\n-        if (!pdb)\n-            return false;\n-\n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(1000);\n         ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n \n-        // Read\n-        SafeDbt datValue;\n-        int ret = pdb->get(activeTxn, datKey, datValue, 0);\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         bool success = false;\n-        if (datValue.get_data() != nullptr) {\n+        bool ret = ReadKey(ssKey, ssValue);\n+        if (ret) {\n             // Unserialize value\n             try {\n-                CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n                 ssValue >> value;\n                 success = true;\n             } catch (const std::exception&) {\n                 // In this case success remains 'false'\n             }\n         }\n-        return ret == 0 && success;\n+        return ret && success;\n     }\n \n     template <typename K, typename T>\n     bool Write(const K& key, const T& value, bool fOverwrite = true)\n     {\n-        if (!pdb)\n-            return true;\n-        if (fReadOnly)\n-            assert(!\"Write called on database in read-only mode\");\n-\n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(1000);\n         ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n \n         // Value\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         ssValue.reserve(10000);\n         ssValue << value;\n-        SafeDbt datValue(ssValue.data(), ssValue.size());\n \n         // Write\n-        int ret = pdb->put(activeTxn, datKey, datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n-        return (ret == 0);\n+        return WriteKey(ssKey, ssValue, fOverwrite);\n     }\n \n     template <typename K>\n     bool Erase(const K& key)\n     {\n-        if (!pdb)\n-            return false;\n-        if (fReadOnly)\n-            assert(!\"Erase called on database in read-only mode\");\n-\n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(1000);\n         ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n \n         // Erase\n-        int ret = pdb->del(activeTxn, datKey, 0);\n-        return (ret == 0 || ret == DB_NOTFOUND);\n+        return EraseKey(ssKey);\n     }\n \n     template <typename K>\n     bool Exists(const K& key)\n     {\n-        if (!pdb)\n-            return false;\n-\n         // Key\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(1000);\n         ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n \n         // Exists\n-        int ret = pdb->exists(activeTxn, datKey, 0);\n-        return (ret == 0);\n+        return HasKey(ssKey);\n     }\n \n     Dbc* GetCursor();"
      }
    ]
  }
]