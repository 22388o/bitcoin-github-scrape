[
  {
    "sha": "341735eb8f42e898cf9d4d130709471e5d01abe2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDE3MzVlYjhmNDJlODk4Y2Y5ZDRkMTMwNzA5NDcxZTVkMDFhYmUy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-07-11T22:02:35Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Headers-first synchronization\n\nMany changes:\n* Do not use 'getblocks', but 'getheaders', and use it to build a headers tree.\n* Blocks are fetched in parallel from all available outbound peers, using a\n  limited moving window. When one peer stalls the movement of the window, it is\n  disconnected.\n* No more orphan blocks. At all. We only ever request a block for which we have\n  verified the headers, and store it to disk immediately. This means that a\n  disk-fill attack would require PoW.\n* Require protocol version 31800 for every peer (released in december 2010).\n* No more syncnode (we sync from everyone we can, though limited to 1 during\n  initial *headers* sync).\n* Introduce some extra named constants, comments and asserts.",
      "tree": {
        "sha": "7986b1d3056a776e3423d75353b3282a99edbd44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7986b1d3056a776e3423d75353b3282a99edbd44"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/341735eb8f42e898cf9d4d130709471e5d01abe2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/341735eb8f42e898cf9d4d130709471e5d01abe2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/341735eb8f42e898cf9d4d130709471e5d01abe2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/341735eb8f42e898cf9d4d130709471e5d01abe2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "992ab87114b8c9ea8230e97a9c8d8bd71939074d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/992ab87114b8c9ea8230e97a9c8d8bd71939074d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/992ab87114b8c9ea8230e97a9c8d8bd71939074d"
      }
    ],
    "stats": {
      "total": 745,
      "additions": 375,
      "deletions": 370
    },
    "files": [
      {
        "sha": "4e6a466c6a38087d58ac81432f7c94e8b39679f0",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 25,
        "deletions": 7,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -49,12 +49,29 @@ struct CDiskBlockPos\n };\n \n enum BlockStatus {\n+    // Unused.\n     BLOCK_VALID_UNKNOWN      =    0,\n-    BLOCK_VALID_HEADER       =    1, // parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n-    BLOCK_VALID_TREE         =    2, // parent found, difficulty matches, timestamp >= median previous, checkpoint\n-    BLOCK_VALID_TRANSACTIONS =    3, // only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids, sigops, size, merkle root\n-    BLOCK_VALID_CHAIN        =    4, // outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30\n-    BLOCK_VALID_SCRIPTS      =    5, // scripts/signatures ok\n+\n+    // Parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n+    BLOCK_VALID_HEADER       =    1,\n+\n+    // All parent headers found, difficulty matches, timestamp >= median previous, checkpoint. Implies all parents\n+    // are also at least TREE.\n+    BLOCK_VALID_TREE         =    2,\n+\n+    // Only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids,\n+    // sigops, size, merkle root. Implies all parents are at least TREE but not necessarily TRANSACTIONS. When all\n+    // parent blocks also have TRANSACTIONS, CBlockIndex::nChainTx will be set.\n+    BLOCK_VALID_TRANSACTIONS =    3,\n+\n+    // Outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30.\n+    // Implies all parents are also at least CHAIN.\n+    BLOCK_VALID_CHAIN        =    4,\n+\n+    // Scripts & signatures ok. Implies all parents are also at least SCRIPTS.\n+    BLOCK_VALID_SCRIPTS      =    5,\n+\n+    // All validity bits.\n     BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n                                  BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n \n@@ -103,7 +120,8 @@ class CBlockIndex\n     // Note: in a potential headers-first mode, this number cannot be relied upon\n     unsigned int nTx;\n \n-    // (memory only) Number of transactions in the chain up to and including this block\n+    // (memory only) Number of transactions in the chain up to and including this block.\n+    // This value will be non-zero only if and only if transactions for this block and all its parents are available.\n     unsigned int nChainTx; // change to 64-bit type when necessary; won't happen before 2030\n \n     // Verification status of this block. See enum BlockStatus\n@@ -146,7 +164,7 @@ class CBlockIndex\n         SetNull();\n     }\n \n-    CBlockIndex(CBlockHeader& block)\n+    CBlockIndex(const CBlockHeader& block)\n     {\n         SetNull();\n "
      },
      {
        "sha": "816cab7e1f9909e5e982255b6b010024078c8047",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 334,
        "deletions": 274,
        "changes": 608,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -56,14 +56,6 @@ CFeeRate minRelayTxFee = CFeeRate(1000);\n \n CTxMemPool mempool(::minRelayTxFee);\n \n-struct COrphanBlock {\n-    uint256 hashBlock;\n-    uint256 hashPrev;\n-    vector<unsigned char> vchBlock;\n-};\n-map<uint256, COrphanBlock*> mapOrphanBlocks;\n-multimap<uint256, COrphanBlock*> mapOrphanBlocksByPrev;\n-\n struct COrphanTx {\n     CTransaction tx;\n     NodeId fromPeer;\n@@ -106,6 +98,12 @@ namespace {\n     // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n     // as good as our current tip. Entries may be failed, though.\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n+    // Best header we've seen so far (used for getheaders queries' starting points).\n+    CBlockIndex *pindexBestHeader = NULL;\n+    // Number of nodes with fSyncStarted.\n+    int nSyncStarted = 0;\n+    // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n+    multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     CBlockFileInfo infoLastBlockFile;\n@@ -125,11 +123,10 @@ namespace {\n     // Protected by cs_main.\n     struct QueuedBlock {\n         uint256 hash;\n+        CBlockIndex *pindex;  // Optional.\n         int64_t nTime;  // Time of \"getdata\" request in microseconds.\n-        int nQueuedBefore;  // Number of blocks in flight at the time of request.\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n-    map<uint256, pair<NodeId, list<uint256>::iterator> > mapBlocksToDownload;\n \n } // anon namespace\n \n@@ -220,22 +217,24 @@ struct CNodeState {\n     CBlockIndex *pindexBestKnownBlock;\n     // The hash of the last unknown block this peer has announced.\n     uint256 hashLastUnknownBlock;\n+    // The last full block we both have.\n+    CBlockIndex *pindexLastCommonBlock;\n+    // Whether we've started headers synchronization with this peer.\n+    bool fSyncStarted;\n+    // Since when we're stalling block download progress (in microseconds), or 0.\n+    int64_t nStallingSince;\n     list<QueuedBlock> vBlocksInFlight;\n     int nBlocksInFlight;\n-    list<uint256> vBlocksToDownload;\n-    int nBlocksToDownload;\n-    int64_t nLastBlockReceive;\n-    int64_t nLastBlockProcess;\n \n     CNodeState() {\n         nMisbehavior = 0;\n         fShouldBan = false;\n         pindexBestKnownBlock = NULL;\n         hashLastUnknownBlock = uint256(0);\n-        nBlocksToDownload = 0;\n+        pindexLastCommonBlock = NULL;\n+        fSyncStarted = false;\n+        nStallingSince = 0;\n         nBlocksInFlight = 0;\n-        nLastBlockReceive = 0;\n-        nLastBlockProcess = 0;\n     }\n };\n \n@@ -266,64 +265,37 @@ void FinalizeNode(NodeId nodeid) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n \n+    if (state->fSyncStarted)\n+        nSyncStarted--;\n+\n     BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight)\n         mapBlocksInFlight.erase(entry.hash);\n-    BOOST_FOREACH(const uint256& hash, state->vBlocksToDownload)\n-        mapBlocksToDownload.erase(hash);\n     EraseOrphansFor(nodeid);\n \n     mapNodeState.erase(nodeid);\n }\n \n // Requires cs_main.\n-void MarkBlockAsReceived(const uint256 &hash, NodeId nodeFrom = -1) {\n-    map<uint256, pair<NodeId, list<uint256>::iterator> >::iterator itToDownload = mapBlocksToDownload.find(hash);\n-    if (itToDownload != mapBlocksToDownload.end()) {\n-        CNodeState *state = State(itToDownload->second.first);\n-        state->vBlocksToDownload.erase(itToDownload->second.second);\n-        state->nBlocksToDownload--;\n-        mapBlocksToDownload.erase(itToDownload);\n-    }\n-\n+void MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n         state->nBlocksInFlight--;\n-        if (itInFlight->second.first == nodeFrom)\n-            state->nLastBlockReceive = GetTimeMicros();\n+        state->nStallingSince = 0;\n         mapBlocksInFlight.erase(itInFlight);\n     }\n }\n \n // Requires cs_main.\n-bool AddBlockToQueue(NodeId nodeid, const uint256 &hash) {\n-    if (mapBlocksToDownload.count(hash) || mapBlocksInFlight.count(hash))\n-        return false;\n-\n-    CNodeState *state = State(nodeid);\n-    if (state == NULL)\n-        return false;\n-\n-    list<uint256>::iterator it = state->vBlocksToDownload.insert(state->vBlocksToDownload.end(), hash);\n-    state->nBlocksToDownload++;\n-    if (state->nBlocksToDownload > 5000)\n-        Misbehaving(nodeid, 10);\n-    mapBlocksToDownload[hash] = std::make_pair(nodeid, it);\n-    return true;\n-}\n-\n-// Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256 &hash) {\n+void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, CBlockIndex *pindex = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n-    QueuedBlock newentry = {hash, GetTimeMicros(), state->nBlocksInFlight};\n-    if (state->nBlocksInFlight == 0)\n-        state->nLastBlockReceive = newentry.nTime; // Reset when a first request is sent.\n+    QueuedBlock newentry = {hash, pindex, GetTimeMicros()};\n     list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(), newentry);\n     state->nBlocksInFlight++;\n     mapBlocksInFlight[hash] = std::make_pair(nodeid, it);\n@@ -362,6 +334,103 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n+/** Find the last common ancestor two blocks have.\n+ *  Both pa and pb must be non-NULL. */\n+CBlockIndex* LastCommonAncestor(CBlockIndex* pa, CBlockIndex* pb) {\n+    if (pa->nHeight > pb->nHeight) {\n+        pa = pa->GetAncestor(pb->nHeight);\n+    } else if (pb->nHeight > pa->nHeight) {\n+        pb = pb->GetAncestor(pa->nHeight);\n+    }\n+\n+    while (pa != pb && pa && pb) {\n+        pa = pa->pprev;\n+        pb = pb->pprev;\n+    }\n+\n+    // Eventually all chain branches meet at the genesis block.\n+    assert(pa == pb);\n+    return pa;\n+}\n+\n+/** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n+ *  at most count entries. */\n+void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBlockIndex*>& vBlocks, NodeId& nodeStaller) {\n+    if (count == 0)\n+        return;\n+\n+    vBlocks.reserve(vBlocks.size() + count);\n+    CNodeState *state = State(nodeid);\n+    assert(state != NULL);\n+\n+    // Make sure pindexBestKnownBlock is up to date, we'll need it.\n+    ProcessBlockAvailability(nodeid);\n+\n+    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n+        // This peer has nothing interesting.\n+        return;\n+    }\n+\n+    if (state->pindexLastCommonBlock == NULL) {\n+        // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n+        // Guessing wrong in either direction is not a problem.\n+        state->pindexLastCommonBlock = chainActive[std::min(state->pindexBestKnownBlock->nHeight, chainActive.Height())];\n+    }\n+\n+    // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n+    // of their current tip anymore. Go back enough to fix that.\n+    state->pindexLastCommonBlock = LastCommonAncestor(state->pindexLastCommonBlock, state->pindexBestKnownBlock);\n+    if (state->pindexLastCommonBlock == state->pindexBestKnownBlock)\n+        return;\n+\n+    std::vector<CBlockIndex*> vToFetch;\n+    CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n+    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond our\n+    // current tip. The +1 is so we can detect stalling, namely if we would be able to download that next block if the\n+    // window were 1 larger.\n+    int nMaxHeight = std::min<int>(state->pindexBestKnownBlock->nHeight, chainActive.Height() + BLOCK_DOWNLOAD_WINDOW + 1);\n+    NodeId waitingfor = -1;\n+    while (pindexWalk->nHeight < nMaxHeight) {\n+        // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n+        // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n+        // as iterating over ~100 CBlockIndex* entries anyway.\n+        int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n+        vToFetch.resize(nToFetch);\n+        pindexWalk = state->pindexBestKnownBlock->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        vToFetch[nToFetch - 1] = pindexWalk;\n+        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n+            vToFetch[i - 1] = vToFetch[i]->pprev;\n+        }\n+\n+        // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n+        // are not yet downloaded and not in flight to vBlocks. In the mean time, update\n+        // pindexLastCommonBlock as long as all ancestors are already downloaded.\n+        BOOST_FOREACH(CBlockIndex* pindex, vToFetch) {\n+            if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+                if (pindex->nChainTx)\n+                    state->pindexLastCommonBlock = pindex;\n+            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+                // The block is not already downloaded, and not yet in flight.\n+                if (pindex->nHeight > chainActive.Height() + (int)BLOCK_DOWNLOAD_WINDOW) {\n+                    // We reached the end of the window.\n+                    if (vBlocks.size() == 0 && waitingfor != nodeid) {\n+                        // We aren't able to fetch anything, but we would be if the download window was one larger.\n+                        nodeStaller = waitingfor;\n+                    }\n+                    return;\n+                }\n+                vBlocks.push_back(pindex);\n+                if (vBlocks.size() == count) {\n+                    return;\n+                }\n+            } else if (waitingfor == -1) {\n+                // This is the first already-in-flight block.\n+                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n+            }\n+        }\n+    }\n+}\n+\n } // anon namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n@@ -1086,46 +1155,6 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n     return true;\n }\n \n-uint256 static GetOrphanRoot(const uint256& hash)\n-{\n-    map<uint256, COrphanBlock*>::iterator it = mapOrphanBlocks.find(hash);\n-    if (it == mapOrphanBlocks.end())\n-        return hash;\n-\n-    // Work back to the first block in the orphan chain\n-    do {\n-        map<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocks.find(it->second->hashPrev);\n-        if (it2 == mapOrphanBlocks.end())\n-            return it->first;\n-        it = it2;\n-    } while(true);\n-}\n-\n-// Remove a random orphan block (which does not have any dependent orphans).\n-void static PruneOrphanBlocks()\n-{\n-    if (mapOrphanBlocksByPrev.size() <= (size_t)std::max((int64_t)0, GetArg(\"-maxorphanblocks\", DEFAULT_MAX_ORPHAN_BLOCKS)))\n-        return;\n-\n-    // Pick a random orphan block.\n-    int pos = insecure_rand() % mapOrphanBlocksByPrev.size();\n-    std::multimap<uint256, COrphanBlock*>::iterator it = mapOrphanBlocksByPrev.begin();\n-    while (pos--) it++;\n-\n-    // As long as this block has other orphans depending on it, move to one of those successors.\n-    do {\n-        std::multimap<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocksByPrev.find(it->second->hashBlock);\n-        if (it2 == mapOrphanBlocksByPrev.end())\n-            break;\n-        it = it2;\n-    } while(1);\n-\n-    uint256 hash = it->second->hashBlock;\n-    delete it->second;\n-    mapOrphanBlocksByPrev.erase(it);\n-    mapOrphanBlocks.erase(hash);\n-}\n-\n CAmount GetBlockValue(int nHeight, const CAmount& nFees)\n {\n     int64_t nSubsidy = 50 * COIN;\n@@ -1664,11 +1693,6 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     if (fJustCheck)\n         return true;\n \n-    // Correct transaction counts.\n-    pindex->nTx = block.vtx.size();\n-    if (pindex->pprev)\n-        pindex->nChainTx = pindex->pprev->nChainTx + block.vtx.size();\n-\n     // Write undo information to disk\n     if (pindex->GetUndoPos().IsNull() || !pindex->IsValid(BLOCK_VALID_SCRIPTS))\n     {\n@@ -1900,6 +1924,8 @@ static CBlockIndex* FindMostWorkChain() {\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n+            assert(pindexTest->nStatus & BLOCK_HAVE_DATA);\n+            assert(pindexTest->nChainTx || pindexTest->nHeight == 0);\n             if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n                 // Candidate has an invalid ancestor, remove entire chain from the set.\n                 if (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n@@ -2032,7 +2058,7 @@ bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n     return true;\n }\n \n-CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n+CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n {\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n@@ -2043,10 +2069,10 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n     assert(pindexNew);\n-    {\n-         LOCK(cs_nBlockSequenceId);\n-         pindexNew->nSequenceId = nBlockSequenceId++;\n-    }\n+    // We assign the sequence id to blocks only when the full data is available,\n+    // to avoid miners withholding blocks but broadcasting headers, to get a\n+    // competitive advantage.\n+    pindexNew->nSequenceId = 0;\n     BlockMap::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n@@ -2058,6 +2084,11 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n     }\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + pindexNew->GetBlockWork();\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n+    if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n+        pindexBestHeader = pindexNew;\n+\n+    // Ok if it fails, we'll download the header again next time.\n+    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew));\n \n     return pindexNew;\n }\n@@ -2066,30 +2097,45 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos)\n {\n     pindexNew->nTx = block.vtx.size();\n-    if (pindexNew->pprev) {\n-        // Not the genesis block.\n-        if (pindexNew->pprev->nChainTx) {\n-            // This parent's block's total number transactions is known, so compute outs.\n-            pindexNew->nChainTx = pindexNew->pprev->nChainTx + pindexNew->nTx;\n-        } else {\n-            // The total number of transactions isn't known yet.\n-            // We will compute it when the block is connected.\n-            pindexNew->nChainTx = 0;\n-        }\n-    } else {\n-        // Genesis block.\n-        pindexNew->nChainTx = pindexNew->nTx;\n-    }\n+    pindexNew->nChainTx = 0;\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n     pindexNew->nStatus |= BLOCK_HAVE_DATA;\n+    pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n+    {\n+         LOCK(cs_nBlockSequenceId);\n+         pindexNew->nSequenceId = nBlockSequenceId++;\n+    }\n \n-    if (pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS))\n-        setBlockIndexValid.insert(pindexNew);\n+    if (pindexNew->pprev == NULL || pindexNew->pprev->nChainTx) {\n+        // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n+        deque<CBlockIndex*> queue;\n+        queue.push_back(pindexNew);\n \n-    if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-        return state.Abort(\"Failed to write block index\");\n+        // Recursively process any descendant blocks that now may be eligible to be connected.\n+        while (!queue.empty()) {\n+            CBlockIndex *pindex = queue.front();\n+            queue.pop_front();\n+            pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n+            setBlockIndexValid.insert(pindex);\n+            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n+            while (range.first != range.second) {\n+                std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n+                queue.push_back(it->second);\n+                range.first++;\n+                mapBlocksUnlinked.erase(it);\n+            }\n+            if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex)))\n+                return state.Abort(\"Failed to write block index\");\n+        }\n+    } else {\n+        if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {\n+            mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n+        }\n+        if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n+            return state.Abort(\"Failed to write block index\");\n+    }\n \n     return true;\n }\n@@ -2205,12 +2251,31 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool f\n \n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n-    // These are checks that are independent of context\n-    // that can be verified before saving an orphan block.\n+    // These are checks that are independent of context.\n \n     if (!CheckBlockHeader(block, state, fCheckPOW))\n         return false;\n \n+    // Check the merkle root.\n+    if (fCheckMerkleRoot) {\n+        bool mutated;\n+        uint256 hashMerkleRoot2 = block.BuildMerkleTree(&mutated);\n+        if (block.hashMerkleRoot != hashMerkleRoot2)\n+            return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n+                             REJECT_INVALID, \"bad-txnmrklroot\", true);\n+\n+        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n+        // of transactions in a block without affecting the merkle root of a block,\n+        // while still invalidating it.\n+        if (mutated)\n+            return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n+                             REJECT_INVALID, \"bad-txns-duplicate\", true);\n+    }\n+\n+    // All potential-corruption validation must be done before we do any\n+    // transaction validation, as otherwise we may mark the header as invalid\n+    // because we receive the wrong transactions for it.\n+\n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n         return state.DoS(100, error(\"CheckBlock() : size limits failed\"),\n@@ -2230,15 +2295,6 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         if (!CheckTransaction(tx, state))\n             return error(\"CheckBlock() : CheckTransaction failed\");\n \n-    // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n-    // of transactions in a block without affecting the merkle root of a block,\n-    // while still invalidating it.\n-    bool mutated;\n-    uint256 hashMerkleRoot2 = block.BuildMerkleTree(&mutated);\n-    if (mutated)\n-        return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n-                         REJECT_INVALID, \"bad-txns-duplicate\", true);\n-\n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n     {\n@@ -2248,25 +2304,24 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         return state.DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"),\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n-    // Check merkle root\n-    if (fCheckMerkleRoot && block.hashMerkleRoot != hashMerkleRoot2)\n-        return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n-                         REJECT_INVALID, \"bad-txnmrklroot\", true);\n-\n     return true;\n }\n \n-bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex** ppindex)\n+bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = NULL;\n     if (miSelf != mapBlockIndex.end()) {\n+        // Block header is already known.\n         pindex = miSelf->second;\n+        if (ppindex)\n+            *ppindex = pindex;\n         if (pindex->nStatus & BLOCK_FAILED_MASK)\n             return state.Invalid(error(\"%s : block is marked invalid\", __func__), 0, \"duplicate\");\n+        return true;\n     }\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n@@ -2344,6 +2399,12 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     if (!AcceptBlockHeader(block, state, &pindex))\n         return false;\n \n+    if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+        // TODO: deal better with duplicate blocks.\n+        // return state.DoS(20, error(\"AcceptBlock() : already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n+        return true;\n+    }\n+\n     if (!CheckBlock(block, state)) {\n         if (state.IsInvalid() && !state.CorruptionPossible()) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n@@ -2456,93 +2517,26 @@ void CBlockIndex::BuildSkip()\n         pskip = pprev->GetAncestor(GetSkipHeight(nHeight));\n }\n \n-void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd)\n-{\n-    AssertLockHeld(cs_main);\n-    // Filter out duplicate requests\n-    if (pindexBegin == pnode->pindexLastGetBlocksBegin && hashEnd == pnode->hashLastGetBlocksEnd)\n-        return;\n-    pnode->pindexLastGetBlocksBegin = pindexBegin;\n-    pnode->hashLastGetBlocksEnd = hashEnd;\n-\n-    pnode->PushMessage(\"getblocks\", chainActive.GetLocator(pindexBegin), hashEnd);\n-}\n-\n bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n {\n-    // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-\n-    {\n-    LOCK(cs_main);\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString()), 0, \"duplicate\");\n-    if (mapOrphanBlocks.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString()), 0, \"duplicate\");\n-\n     // Preliminary checks\n-    if (!CheckBlock(*pblock, state))\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    bool checked = CheckBlock(*pblock, state);\n \n-    // If we don't already have its previous block (with full data), shunt it off to holding area until we get it\n-    BlockMap::iterator it = mapBlockIndex.find(pblock->hashPrevBlock);\n-    if (pblock->hashPrevBlock != 0 && (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)))\n     {\n-        LogPrintf(\"ProcessBlock: ORPHAN BLOCK %lu, prev=%s\\n\", (unsigned long)mapOrphanBlocks.size(), pblock->hashPrevBlock.ToString());\n-\n-        // Accept orphans as long as there is a node to request its parents from\n-        if (pfrom) {\n-            PruneOrphanBlocks();\n-            COrphanBlock* pblock2 = new COrphanBlock();\n-            {\n-                CDataStream ss(SER_DISK, CLIENT_VERSION);\n-                ss << *pblock;\n-                pblock2->vchBlock = std::vector<unsigned char>(ss.begin(), ss.end());\n-            }\n-            pblock2->hashBlock = hash;\n-            pblock2->hashPrev = pblock->hashPrevBlock;\n-            mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-            mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrev, pblock2));\n-\n-            // Ask this guy to fill in what we're missing\n-            PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(hash));\n+        LOCK(cs_main);\n+        MarkBlockAsReceived(pblock->GetHash());\n+        if (!checked) {\n+            return error(\"ProcessBlock() : CheckBlock FAILED\");\n         }\n-        return true;\n-    }\n \n-    // Store to disk\n-    CBlockIndex *pindex = NULL;\n-    bool ret = AcceptBlock(*pblock, state, &pindex, dbp);\n-    if (!ret)\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n-\n-    // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n-    {\n-        uint256 hashPrev = vWorkQueue[i];\n-        for (multimap<uint256, COrphanBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n-             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n-             ++mi)\n-        {\n-            CBlock block;\n-            {\n-                CDataStream ss(mi->second->vchBlock, SER_DISK, CLIENT_VERSION);\n-                ss >> block;\n-            }\n-            block.BuildMerkleTree();\n-            // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan resolution (that is, feeding people an invalid block based on LegitBlockX in order to get anyone relaying LegitBlockX banned)\n-            CValidationState stateDummy;\n-            CBlockIndex *pindexChild = NULL;\n-            if (AcceptBlock(block, stateDummy, &pindexChild))\n-                vWorkQueue.push_back(mi->second->hashBlock);\n-            mapOrphanBlocks.erase(mi->second->hashBlock);\n-            delete mi->second;\n+        // Store to disk\n+        CBlockIndex *pindex = NULL;\n+        bool ret = AcceptBlock(*pblock, state, &pindex, dbp);\n+        if (pindex && pfrom) {\n+            mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n         }\n-        mapOrphanBlocksByPrev.erase(hashPrev);\n-    }\n-\n+        if (!ret)\n+            return error(\"ProcessBlock() : AcceptBlock FAILED\");\n     }\n \n     if (!ActivateBestChain(state, pblock))\n@@ -2808,13 +2802,26 @@ bool static LoadBlockIndexDB()\n     {\n         CBlockIndex* pindex = item.second;\n         pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + pindex->GetBlockWork();\n-        pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS))\n+        if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+            if (pindex->pprev) {\n+                if (pindex->pprev->nChainTx) {\n+                    pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n+                } else {\n+                    pindex->nChainTx = 0;\n+                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));\n+                }\n+            } else {\n+                pindex->nChainTx = pindex->nTx;\n+            }\n+        }\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))\n             setBlockIndexValid.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n             pindex->BuildSkip();\n+        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n+            pindexBestHeader = pindex;\n     }\n \n     // Load block file info\n@@ -3226,8 +3233,7 @@ bool static AlreadyHave(const CInv& inv)\n                 pcoinsTip->HaveCoins(inv.hash);\n         }\n     case MSG_BLOCK:\n-        return mapBlockIndex.count(inv.hash) ||\n-               mapOrphanBlocks.count(inv.hash);\n+        return mapBlockIndex.count(inv.hash);\n     }\n     // Don't know what it is, just say we already got one\n     return true;\n@@ -3375,10 +3381,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         return true;\n     }\n \n-    {\n-        LOCK(cs_main);\n-        State(pfrom->GetId())->nLastBlockProcess = GetTimeMicros();\n-    }\n \n \n \n@@ -3587,6 +3589,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         LOCK(cs_main);\n \n+        std::vector<CInv> vToFetch;\n+\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n             const CInv &inv = vInv[nInv];\n@@ -3597,19 +3601,29 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             bool fAlreadyHave = AlreadyHave(inv);\n             LogPrint(\"net\", \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n \n-            if (!fAlreadyHave) {\n-                if (!fImporting && !fReindex) {\n-                    if (inv.type == MSG_BLOCK)\n-                        AddBlockToQueue(pfrom->GetId(), inv.hash);\n-                    else\n-                        pfrom->AskFor(inv);\n-                }\n-            } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n-                PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(inv.hash));\n-            }\n+            if (!fAlreadyHave && !fImporting && !fReindex && inv.type != MSG_BLOCK)\n+                pfrom->AskFor(inv);\n \n-            if (inv.type == MSG_BLOCK)\n+            if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n+                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                    // First request the headers preceeding the announced block. In the normal fully-synced\n+                    // case where a new block is announced that succeeds the current tip (no reorganization),\n+                    // there are no such headers.\n+                    // Secondly, and only when we are close to being synced, we request the announced block directly,\n+                    // to avoid an extra round-trip. Note that we must *first* ask for the headers, so by the\n+                    // time the block arrives, the header chain leading up to it is already validated. Not\n+                    // doing this will result in the received block being rejected as an orphan in case it is\n+                    // not a direct successor.\n+                    pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexBestHeader), inv.hash);\n+                    if (chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - Params().TargetSpacing() * 20) {\n+                        vToFetch.push_back(inv);\n+                        // Mark block as in flight already, even though the actual \"getdata\" message only goes out\n+                        // later (within the same cs_main lock, though).\n+                        MarkBlockAsInFlight(pfrom->GetId(), inv.hash);\n+                    }\n+                }\n+            }\n \n             // Track requests for our stuff\n             g_signals.Inventory(inv.hash);\n@@ -3619,6 +3633,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 return error(\"send buffer size() = %u\", pfrom->nSendSize);\n             }\n         }\n+\n+        if (!vToFetch.empty())\n+            pfrom->PushMessage(\"getdata\", vToFetch);\n     }\n \n \n@@ -3706,7 +3723,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n-        int nLimit = 2000;\n+        int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n@@ -3826,22 +3843,66 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == \"headers\" && !fImporting && !fReindex) // Ignore headers received while importing\n+    {\n+        std::vector<CBlockHeader> headers;\n+\n+        // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n+        unsigned int nCount = ReadCompactSize(vRecv);\n+        if (nCount > MAX_HEADERS_RESULTS) {\n+            Misbehaving(pfrom->GetId(), 20);\n+            return error(\"headers message size = %u\", nCount);\n+        }\n+        headers.resize(nCount);\n+        for (unsigned int n = 0; n < nCount; n++) {\n+            vRecv >> headers[n];\n+            ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n+        }\n+\n+        LOCK(cs_main);\n+\n+        if (nCount == 0) {\n+            // Nothing interesting. Stop asking this peers for more headers.\n+            return true;\n+        }\n+\n+        CBlockIndex *pindexLast = NULL;\n+        BOOST_FOREACH(const CBlockHeader& header, headers) {\n+            CValidationState state;\n+            if (pindexLast != NULL && header.hashPrevBlock != pindexLast->GetBlockHash()) {\n+                Misbehaving(pfrom->GetId(), 20);\n+                return error(\"non-continuous headers sequence\");\n+            }\n+            if (!AcceptBlockHeader(header, state, &pindexLast)) {\n+                int nDoS;\n+                if (state.IsInvalid(nDoS)) {\n+                    if (nDoS > 0)\n+                        Misbehaving(pfrom->GetId(), nDoS);\n+                    return error(\"invalid header received\");\n+                }\n+            }\n+        }\n+\n+        if (pindexLast)\n+            UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+\n+        if (nCount == MAX_HEADERS_RESULTS && pindexLast) {\n+            // Headers message had its maximum size; the peer may have more headers.\n+            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n+            // from there instead.\n+            pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256(0));\n+        }\n+    }\n+\n     else if (strCommand == \"block\" && !fImporting && !fReindex) // Ignore blocks received while importing\n     {\n         CBlock block;\n         vRecv >> block;\n \n-        LogPrint(\"net\", \"received block %s peer=%d\\n\", block.GetHash().ToString(), pfrom->id);\n-\n         CInv inv(MSG_BLOCK, block.GetHash());\n-        pfrom->AddInventoryKnown(inv);\n+        LogPrint(\"net\", \"received block %s peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n \n-        {\n-            LOCK(cs_main);\n-            // Remember who we got this block from.\n-            mapBlockSource[inv.hash] = pfrom->GetId();\n-            MarkBlockAsReceived(inv.hash, pfrom->GetId());\n-        }\n+        pfrom->AddInventoryKnown(inv);\n \n         CValidationState state;\n         ProcessBlock(state, pfrom, &block);\n@@ -4323,9 +4384,17 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         state.rejects.clear();\n \n         // Start block sync\n-        if (pto->fStartSync && !fImporting && !fReindex) {\n-            pto->fStartSync = false;\n-            PushGetBlocks(pto, chainActive.Tip(), uint256(0));\n+        if (pindexBestHeader == NULL)\n+            pindexBestHeader = chainActive.Tip();\n+        bool fFetch = !pto->fInbound || (pindexBestHeader && (state.pindexLastCommonBlock ? state.pindexLastCommonBlock->nHeight : 0) + 144 > pindexBestHeader->nHeight);\n+        if (!state.fSyncStarted && !pto->fClient && fFetch && !fImporting && !fReindex) {\n+            // Only actively request headers from a single peer, unless we're close to today.\n+            if (nSyncStarted == 0 || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n+                state.fSyncStarted = true;\n+                nSyncStarted++;\n+                CBlockIndex *pindexStart = pindexBestHeader->pprev ? pindexBestHeader->pprev : pindexBestHeader;\n+                pto->PushMessage(\"getheaders\", chainActive.GetLocator(pindexStart), uint256(0));\n+            }\n         }\n \n         // Resend wallet transactions that haven't gotten in a block yet\n@@ -4384,35 +4453,32 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         if (!vInv.empty())\n             pto->PushMessage(\"inv\", vInv);\n \n-\n-        // Detect stalled peers. Require that blocks are in flight, we haven't\n-        // received a (requested) block in one minute, and that all blocks are\n-        // in flight for over two minutes, since we first had a chance to\n-        // process an incoming block.\n+        // Detect whether we're stalling\n         int64_t nNow = GetTimeMicros();\n-        if (!pto->fDisconnect && state.nBlocksInFlight &&\n-            state.nLastBlockReceive < state.nLastBlockProcess - BLOCK_DOWNLOAD_TIMEOUT*1000000 &&\n-            state.vBlocksInFlight.front().nTime < state.nLastBlockProcess - 2*BLOCK_DOWNLOAD_TIMEOUT*1000000) {\n-            LogPrintf(\"Peer %s is stalling block download, disconnecting\\n\", state.name);\n+        if (!pto->fDisconnect && state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+            // Stalling only triggers when the block download window cannot move. During normal steady state,\n+            // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n+            // should only happen during initial block download.\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n             pto->fDisconnect = true;\n         }\n \n-        // Update knowledge of peer's block availability.\n-        ProcessBlockAvailability(pto->GetId());\n-\n         //\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        while (!pto->fDisconnect && state.nBlocksToDownload && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            uint256 hash = state.vBlocksToDownload.front();\n-            vGetData.push_back(CInv(MSG_BLOCK, hash));\n-            MarkBlockAsInFlight(pto->GetId(), hash);\n-            LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", hash.ToString(), pto->id);\n-            if (vGetData.size() >= 1000)\n-            {\n-                pto->PushMessage(\"getdata\", vGetData);\n-                vGetData.clear();\n+        if (!pto->fDisconnect && !pto->fClient && fFetch && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            vector<CBlockIndex*> vToDownload;\n+            NodeId staller = -1;\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n+            BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n+                vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", pindex->GetBlockHash().ToString(), pto->id);\n+            }\n+            if (state.nBlocksInFlight == 0 && staller != -1) {\n+                if (State(staller)->nStallingSince == 0)\n+                    State(staller)->nStallingSince = nNow;\n             }\n         }\n \n@@ -4519,12 +4585,6 @@ class CMainCleanup\n             delete (*it1).second;\n         mapBlockIndex.clear();\n \n-        // orphan blocks\n-        std::map<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocks.begin();\n-        for (; it2 != mapOrphanBlocks.end(); it2++)\n-            delete (*it2).second;\n-        mapOrphanBlocks.clear();\n-\n         // orphan transactions\n         mapOrphanTransactions.clear();\n         mapOrphanTransactionsByPrev.clear();"
      },
      {
        "sha": "674f2fe4a4f7f4f1cb2bfb8fad46bffa1333e4fa",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -72,9 +72,17 @@ static const int MAX_SCRIPTCHECK_THREADS = 16;\n /** -par default (number of script-checking threads, 0 = auto) */\n static const int DEFAULT_SCRIPTCHECK_THREADS = 0;\n /** Number of blocks that can be requested at any given time from a single peer. */\n-static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 128;\n-/** Timeout in seconds before considering a block download peer unresponsive. */\n-static const unsigned int BLOCK_DOWNLOAD_TIMEOUT = 60;\n+static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16;\n+/** Timeout in seconds during which a peer must stall block download progress before being disconnected. */\n+static const unsigned int BLOCK_STALLING_TIMEOUT = 2;\n+/** Number of headers sent in one getheaders result. We rely on the assumption that if a peer sends\n+ *  less than this number, we reached their tip. Changing this value is a protocol upgrade. */\n+static const unsigned int MAX_HEADERS_RESULTS = 2000;\n+/** Size of the \"block download window\": how far ahead of our current height do we fetch?\n+ *  Larger windows tolerate larger download speed differences between peer, but increase the potential\n+ *  degree of disordering of blocks on disk (which make reindexing and in the future perhaps pruning\n+ *  harder). We'll probably want to make this a per-peer adaptive value at some point. */\n+static const unsigned int BLOCK_DOWNLOAD_WINDOW = 1024;\n \n /** \"reject\" message codes **/\n static const unsigned char REJECT_MALFORMED = 0x01;\n@@ -137,8 +145,6 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n \n-void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd);\n-\n /** Process an incoming block */\n bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n /** Check whether enough disk space is available for an incoming block */\n@@ -439,17 +445,14 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n // Apply the effects of this block (with given index) on the UTXO set represented by coins\n bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n \n-// Add this block to the block index, and if necessary, switch the active block chain to this\n-bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos);\n-\n // Context-independent validity checks\n bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);\n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n // Store block on disk\n // if dbp is provided, the file is known to already reside on disk\n bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n-bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n+bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n \n \n "
      },
      {
        "sha": "50b435cf14da8c09d28de52e13e0223ffaef8674",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 50,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -73,7 +73,6 @@ map<CNetAddr, LocalServiceInfo> mapLocalHost;\n static bool vfReachable[NET_MAX] = {};\n static bool vfLimited[NET_MAX] = {};\n static CNode* pnodeLocalHost = NULL;\n-static CNode* pnodeSync = NULL;\n uint64_t nLocalHostNonce = 0;\n static std::vector<ListenSocket> vhListenSocket;\n CAddrMan addrman;\n@@ -519,10 +518,6 @@ void CNode::CloseSocketDisconnect()\n     TRY_LOCK(cs_vRecvMsg, lockRecv);\n     if (lockRecv)\n         vRecvMsg.clear();\n-\n-    // if this was the sync node, we'll need a new one\n-    if (this == pnodeSync)\n-        pnodeSync = NULL;\n }\n \n void CNode::PushVersion()\n@@ -615,7 +610,6 @@ void CNode::copyStats(CNodeStats &stats)\n     X(nSendBytes);\n     X(nRecvBytes);\n     X(fWhitelisted);\n-    stats.fSyncNode = (this == pnodeSync);\n \n     // It is common for nodes with good ping times to suddenly become lagged,\n     // due to a new block arriving or other large transfer.\n@@ -1487,61 +1481,20 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n }\n \n \n-// for now, use a very simple selection metric: the node from which we received\n-// most recently\n-static int64_t NodeSyncScore(const CNode *pnode) {\n-    return pnode->nLastRecv;\n-}\n-\n-void static StartSync(const vector<CNode*> &vNodes) {\n-    CNode *pnodeNewSync = NULL;\n-    int64_t nBestScore = 0;\n-\n-    int nBestHeight = g_signals.GetHeight().get_value_or(0);\n-\n-    // Iterate over all nodes\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n-        // check preconditions for allowing a sync\n-        if (!pnode->fClient && !pnode->fOneShot &&\n-            !pnode->fDisconnect && pnode->fSuccessfullyConnected &&\n-            (pnode->nStartingHeight > (nBestHeight - 144)) &&\n-            (pnode->nVersion < NOBLKS_VERSION_START || pnode->nVersion >= NOBLKS_VERSION_END)) {\n-            // if ok, compare node's score with the best so far\n-            int64_t nScore = NodeSyncScore(pnode);\n-            if (pnodeNewSync == NULL || nScore > nBestScore) {\n-                pnodeNewSync = pnode;\n-                nBestScore = nScore;\n-            }\n-        }\n-    }\n-    // if a new sync candidate was found, start sync!\n-    if (pnodeNewSync) {\n-        pnodeNewSync->fStartSync = true;\n-        pnodeSync = pnodeNewSync;\n-    }\n-}\n-\n void ThreadMessageHandler()\n {\n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n     while (true)\n     {\n-        bool fHaveSyncNode = false;\n-\n         vector<CNode*> vNodesCopy;\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n             BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n                 pnode->AddRef();\n-                if (pnode == pnodeSync)\n-                    fHaveSyncNode = true;\n             }\n         }\n \n-        if (!fHaveSyncNode)\n-            StartSync(vNodesCopy);\n-\n         // Poll the connected nodes for messages\n         CNode* pnodeTrickle = NULL;\n         if (!vNodesCopy.empty())\n@@ -2078,10 +2031,7 @@ CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fIn\n     nSendSize = 0;\n     nSendOffset = 0;\n     hashContinue = 0;\n-    pindexLastGetBlocksBegin = 0;\n-    hashLastGetBlocksEnd = 0;\n     nStartingHeight = -1;\n-    fStartSync = false;\n     fGetAddr = false;\n     fRelayTxes = false;\n     setInventoryKnown.max_size(SendBufferSize() / 1000);"
      },
      {
        "sha": "18da24183f6e718e3162f2062ba301f374eae434",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -158,7 +158,6 @@ class CNodeStats\n     int nStartingHeight;\n     uint64_t nSendBytes;\n     uint64_t nRecvBytes;\n-    bool fSyncNode;\n     bool fWhitelisted;\n     double dPingTime;\n     double dPingWait;\n@@ -276,10 +275,7 @@ class CNode\n \n public:\n     uint256 hashContinue;\n-    CBlockIndex* pindexLastGetBlocksBegin;\n-    uint256 hashLastGetBlocksEnd;\n     int nStartingHeight;\n-    bool fStartSync;\n \n     // flood relay\n     std::vector<CAddress> vAddrToSend;"
      },
      {
        "sha": "898df2b080b302706fa607d9d87a7fa7a6228ab2",
        "filename": "src/qt/forms/rpcconsole.ui",
        "status": "modified",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/qt/forms/rpcconsole.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/qt/forms/rpcconsole.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/rpcconsole.ui?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -836,29 +836,6 @@\n             </property>\n            </widget>\n           </item>\n-          <item row=\"4\" column=\"0\">\n-           <widget class=\"QLabel\" name=\"label_25\">\n-            <property name=\"text\">\n-             <string>Sync Node</string>\n-            </property>\n-           </widget>\n-          </item>\n-          <item row=\"4\" column=\"2\">\n-           <widget class=\"QLabel\" name=\"peerSyncNode\">\n-            <property name=\"cursor\">\n-             <cursorShape>IBeamCursor</cursorShape>\n-            </property>\n-            <property name=\"text\">\n-             <string>N/A</string>\n-            </property>\n-            <property name=\"textFormat\">\n-             <enum>Qt::PlainText</enum>\n-            </property>\n-            <property name=\"textInteractionFlags\">\n-             <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n-            </property>\n-           </widget>\n-          </item>\n           <item row=\"5\" column=\"0\">\n            <widget class=\"QLabel\" name=\"label_29\">\n             <property name=\"text\">"
      },
      {
        "sha": "2d2d448b49f46b694eaa07fa19cf790c3c309921",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -611,7 +611,6 @@ void RPCConsole::updateNodeDetail(const CNodeCombinedStats *stats)\n     ui->peerSubversion->setText(QString::fromStdString(stats->nodeStats.cleanSubVer));\n     ui->peerDirection->setText(stats->nodeStats.fInbound ? tr(\"Inbound\") : tr(\"Outbound\"));\n     ui->peerHeight->setText(QString(\"%1\").arg(stats->nodeStats.nStartingHeight));\n-    ui->peerSyncNode->setText(stats->nodeStats.fSyncNode ? tr(\"Yes\") : tr(\"No\"));\n \n     // This check fails for example if the lock was busy and\n     // nodeStateStats couldn't be fetched."
      },
      {
        "sha": "3bc4bb30c3df2206a871aaf051fb4ac2f6c486d9",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -139,7 +139,6 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             obj.push_back(Pair(\"banscore\", statestats.nMisbehavior));\n             obj.push_back(Pair(\"syncheight\", statestats.nSyncHeight));\n         }\n-        obj.push_back(Pair(\"syncnode\", stats.fSyncNode));\n         obj.push_back(Pair(\"whitelisted\", stats.fWhitelisted));\n \n         ret.push_back(obj);"
      },
      {
        "sha": "a1e440de24ddd152ecaa4b9a19f7e4500310c465",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/341735eb8f42e898cf9d4d130709471e5d01abe2/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/341735eb8f42e898cf9d4d130709471e5d01abe2/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=341735eb8f42e898cf9d4d130709471e5d01abe2",
        "patch": "@@ -33,8 +33,11 @@ static const int PROTOCOL_VERSION = 70002;\n // initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;\n \n+// In this version, 'getheaders' was introduced.\n+static const int GETHEADERS_VERSION = 31800;\n+\n // disconnect from peers older than this proto version\n-static const int MIN_PEER_PROTO_VERSION = 209;\n+static const int MIN_PEER_PROTO_VERSION = GETHEADERS_VERSION;\n \n // nTime field added to CAddress, starting with this version;\n // if possible, avoid requesting addresses nodes older than this"
      }
    ]
  },
  {
    "sha": "ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZDZlNjAxNzEyN2VjMmEzYThkMWE3MWFhYWI3YTZlOTQ1YzViMGY5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-07-11T22:03:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "RPC additions after headers-first",
      "tree": {
        "sha": "355891e570b9ad12a522d35a43b707923b9e0ea3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/355891e570b9ad12a522d35a43b707923b9e0ea3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "341735eb8f42e898cf9d4d130709471e5d01abe2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/341735eb8f42e898cf9d4d130709471e5d01abe2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/341735eb8f42e898cf9d4d130709471e5d01abe2"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 27,
      "deletions": 4
    },
    "files": [
      {
        "sha": "604ca670ef38ded2f7a49b10123a706dac095970",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
        "patch": "@@ -41,6 +41,7 @@ CCriticalSection cs_main;\n \n BlockMap mapBlockIndex;\n CChain chainActive;\n+CBlockIndex *pindexBestHeader = NULL;\n int64_t nTimeBestReceived = 0;\n CWaitableCriticalSection csBestBlock;\n CConditionVariable cvBlockChange;\n@@ -51,6 +52,7 @@ bool fTxIndex = false;\n bool fIsBareMultisigStd = true;\n unsigned int nCoinCacheSize = 5000;\n \n+\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n CFeeRate minRelayTxFee = CFeeRate(1000);\n \n@@ -98,8 +100,6 @@ namespace {\n     // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n     // as good as our current tip. Entries may be failed, though.\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n-    // Best header we've seen so far (used for getheaders queries' starting points).\n-    CBlockIndex *pindexBestHeader = NULL;\n     // Number of nodes with fSyncStarted.\n     int nSyncStarted = 0;\n     // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n@@ -440,6 +440,11 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n+    stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n+    BOOST_FOREACH(const QueuedBlock& queue, state->vBlocksInFlight) {\n+        if (queue.pindex)\n+            stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n+    }\n     return true;\n }\n "
      },
      {
        "sha": "7939b087ecc13bf6d27e7134d1beb00df0365eea",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
        "patch": "@@ -118,6 +118,9 @@ extern bool fIsBareMultisigStd;\n extern unsigned int nCoinCacheSize;\n extern CFeeRate minRelayTxFee;\n \n+// Best header we've seen so far (used for getheaders queries' starting points).\n+extern CBlockIndex *pindexBestHeader;\n+\n // Minimum disk space required - used in CheckDiskSpace()\n static const uint64_t nMinDiskSpace = 52428800;\n \n@@ -199,6 +202,8 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n struct CNodeStateStats {\n     int nMisbehavior;\n     int nSyncHeight;\n+    int nCommonHeight;\n+    std::vector<int> vHeightInFlight;\n };\n \n struct CDiskTxPos : public CDiskBlockPos"
      },
      {
        "sha": "5beac0512ab0f5d7ffca7c04eade1f64f31efc1a",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
        "patch": "@@ -445,6 +445,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n             \"{\\n\"\n             \"  \\\"chain\\\": \\\"xxxx\\\",        (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\n             \"  \\\"blocks\\\": xxxxxx,         (numeric) the current number of blocks processed in the server\\n\"\n+            \"  \\\"headers\\\": xxxxxx,        (numeric) the current number of headers we have validated\\n\"\n             \"  \\\"bestblockhash\\\": \\\"...\\\", (string) the hash of the currently best block\\n\"\n             \"  \\\"difficulty\\\": xxxxxx,     (numeric) the current difficulty\\n\"\n             \"  \\\"verificationprogress\\\": xxxx, (numeric) estimate of verification progress [0..1]\\n\"\n@@ -458,6 +459,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n     Object obj;\n     obj.push_back(Pair(\"chain\",                 Params().NetworkIDString()));\n     obj.push_back(Pair(\"blocks\",                (int)chainActive.Height()));\n+    obj.push_back(Pair(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1));\n     obj.push_back(Pair(\"bestblockhash\",         chainActive.Tip()->GetBlockHash().GetHex()));\n     obj.push_back(Pair(\"difficulty\",            (double)GetDifficulty()));\n     obj.push_back(Pair(\"verificationprogress\",  Checkpoints::GuessVerificationProgress(chainActive.Tip())));"
      },
      {
        "sha": "12dcd5b5401f7142d39b89ba2d8085dd0bf83d0f",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
        "patch": "@@ -97,7 +97,12 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             \"    \\\"inbound\\\": true|false,     (boolean) Inbound (true) or Outbound (false)\\n\"\n             \"    \\\"startingheight\\\": n,       (numeric) The starting height (block) of the peer\\n\"\n             \"    \\\"banscore\\\": n,             (numeric) The ban score\\n\"\n-            \"    \\\"syncnode\\\": true|false     (boolean) if sync node\\n\"\n+            \"    \\\"synced_headers\\\": n,       (numeric) The last header we have in common with this peer\\n\"\n+            \"    \\\"synced_blocks\\\": n,        (numeric) The last block we have in common with this peer\\n\"\n+            \"    \\\"inflight\\\": [\\n\"\n+            \"       n,                        (numeric) The heights of blocks we're currently asking from this peer\\n\"\n+            \"       ...\\n\"\n+            \"    ]\\n\"\n             \"  }\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n@@ -137,7 +142,13 @@ Value getpeerinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"startingheight\", stats.nStartingHeight));\n         if (fStateStats) {\n             obj.push_back(Pair(\"banscore\", statestats.nMisbehavior));\n-            obj.push_back(Pair(\"syncheight\", statestats.nSyncHeight));\n+            obj.push_back(Pair(\"synced_headers\", statestats.nSyncHeight));\n+            obj.push_back(Pair(\"synced_blocks\", statestats.nCommonHeight));\n+            Array heights;\n+            BOOST_FOREACH(int height, statestats.vHeightInFlight) {\n+                heights.push_back(height);\n+            }\n+            obj.push_back(Pair(\"inflight\", heights));\n         }\n         obj.push_back(Pair(\"whitelisted\", stats.fWhitelisted));\n "
      }
    ]
  },
  {
    "sha": "f244c99c96636136678f17e7ef3952a864613ad0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMjQ0Yzk5Yzk2NjM2MTM2Njc4ZjE3ZTdlZjM5NTJhODY0NjEzYWQw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-09-06T19:16:25Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Remove CheckMinWork, as we always know all parent headers",
      "tree": {
        "sha": "46fe2c8f9c9b9f5d16e8b9804e9c3c1d3b4a6e45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/46fe2c8f9c9b9f5d16e8b9804e9c3c1d3b4a6e45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f244c99c96636136678f17e7ef3952a864613ad0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f244c99c96636136678f17e7ef3952a864613ad0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f244c99c96636136678f17e7ef3952a864613ad0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f244c99c96636136678f17e7ef3952a864613ad0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ad6e6017127ec2a3a8d1a71aaab7a6e945c5b0f9"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 0,
      "deletions": 97
    },
    "files": [
      {
        "sha": "dba4292f50dbaa5c64d7ce750e33e5d373e92fa2",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f244c99c96636136678f17e7ef3952a864613ad0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f244c99c96636136678f17e7ef3952a864613ad0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f244c99c96636136678f17e7ef3952a864613ad0",
        "patch": "@@ -2329,23 +2329,6 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n         return true;\n     }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n-    if (pcheckpoint && block.hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n-    {\n-        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64_t deltaTime = block.GetBlockTime() - pcheckpoint->GetBlockTime();\n-        if (deltaTime < 0)\n-        {\n-            return state.DoS(100, error(\"%s : block with timestamp before last checkpoint\", __func__),\n-                             REJECT_CHECKPOINT, \"time-too-old\");\n-        }\n-        if (!CheckMinWork(block.nBits, pcheckpoint->nBits, deltaTime))\n-        {\n-            return state.DoS(100, error(\"%s : block with too little proof-of-work\", __func__),\n-                             REJECT_INVALID, \"bad-diffbits\");\n-        }\n-    }\n-\n     // Get prev block index\n     CBlockIndex* pindexPrev = NULL;\n     int nHeight = 0;"
      },
      {
        "sha": "75fbfc6a6d5088b11ed3cffcdec4c76dcc507cb8",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 33,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f244c99c96636136678f17e7ef3952a864613ad0/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f244c99c96636136678f17e7ef3952a864613ad0/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=f244c99c96636136678f17e7ef3952a864613ad0",
        "patch": "@@ -98,39 +98,6 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n     return true;\n }\n \n-//\n-// true if nBits is greater than the minimum amount of work that could\n-// possibly be required deltaTime after minimum work required was nBase\n-//\n-bool CheckMinWork(unsigned int nBits, unsigned int nBase, int64_t deltaTime)\n-{\n-    bool fOverflow = false;\n-    uint256 bnNewBlock;\n-    bnNewBlock.SetCompact(nBits, NULL, &fOverflow);\n-    if (fOverflow)\n-        return false;\n-\n-    const uint256 &bnLimit = Params().ProofOfWorkLimit();\n-    // Testnet has min-difficulty blocks\n-    // after Params().TargetSpacing()*2 time between blocks:\n-    if (Params().AllowMinDifficultyBlocks() && deltaTime > Params().TargetSpacing()*2)\n-        return bnNewBlock <= bnLimit;\n-\n-    uint256 bnResult;\n-    bnResult.SetCompact(nBase);\n-    while (deltaTime > 0 && bnResult < bnLimit)\n-    {\n-        // Maximum 400% adjustment...\n-        bnResult *= 4;\n-        // ... in best-case exactly 4-times-normal target time\n-        deltaTime -= Params().TargetTimespan()*4;\n-    }\n-    if (bnResult > bnLimit)\n-        bnResult = bnLimit;\n-\n-    return bnNewBlock <= bnResult;\n-}\n-\n void UpdateTime(CBlockHeader* pblock, const CBlockIndex* pindexPrev)\n {\n     pblock->nTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());"
      },
      {
        "sha": "233d1f37953f60798474bbc74529434b3b7bcef4",
        "filename": "src/pow.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f244c99c96636136678f17e7ef3952a864613ad0/src/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f244c99c96636136678f17e7ef3952a864613ad0/src/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.h?ref=f244c99c96636136678f17e7ef3952a864613ad0",
        "patch": "@@ -16,8 +16,6 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n \n /** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n-/** Check the work is more than the minimum a received block needs, without knowing its direct parent */\n-bool CheckMinWork(unsigned int nBits, unsigned int nBase, int64_t deltaTime);\n \n void UpdateTime(CBlockHeader* block, const CBlockIndex* pindexPrev);\n "
      },
      {
        "sha": "f9746fdaa5c657b31d565c340cf1c2f93ee6e990",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 45,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f244c99c96636136678f17e7ef3952a864613ad0/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f244c99c96636136678f17e7ef3952a864613ad0/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=f244c99c96636136678f17e7ef3952a864613ad0",
        "patch": "@@ -106,51 +106,6 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     BOOST_CHECK(!CNode::IsBanned(addr));\n }\n \n-static bool CheckNBits(unsigned int nbits1, int64_t time1, unsigned int nbits2, int64_t time2)\\\n-{\n-    if (time1 > time2)\n-        return CheckNBits(nbits2, time2, nbits1, time1);\n-    int64_t deltaTime = time2-time1;\n-\n-    return CheckMinWork(nbits2, nbits1, deltaTime);\n-}\n-\n-BOOST_AUTO_TEST_CASE(DoS_checknbits)\n-{\n-    using namespace boost::assign; // for 'map_list_of()'\n-\n-    // Timestamps,nBits from the bitcoin block chain.\n-    // These are the block-chain checkpoint blocks\n-    typedef std::map<int64_t, unsigned int> BlockData;\n-    BlockData chainData =\n-        map_list_of(1239852051,486604799)(1262749024,486594666)\n-        (1279305360,469854461)(1280200847,469830746)(1281678674,469809688)\n-        (1296207707,453179945)(1302624061,453036989)(1309640330,437004818)\n-        (1313172719,436789733);\n-\n-    // Make sure CheckNBits considers every combination of block-chain-lock-in-points\n-    // \"sane\":\n-    BOOST_FOREACH(const BlockData::value_type& i, chainData)\n-    {\n-        BOOST_FOREACH(const BlockData::value_type& j, chainData)\n-        {\n-            BOOST_CHECK(CheckNBits(i.second, i.first, j.second, j.first));\n-        }\n-    }\n-\n-    // Test a couple of insane combinations:\n-    BlockData::value_type firstcheck = *(chainData.begin());\n-    BlockData::value_type lastcheck = *(chainData.rbegin());\n-\n-    // First checkpoint difficulty at or a while after the last checkpoint time should fail when\n-    // compared to last checkpoint\n-    BOOST_CHECK(!CheckNBits(firstcheck.second, lastcheck.first+60*10, lastcheck.second, lastcheck.first));\n-    BOOST_CHECK(!CheckNBits(firstcheck.second, lastcheck.first+60*60*24*14, lastcheck.second, lastcheck.first));\n-\n-    // ... but OK if enough time passed for difficulty to adjust downward:\n-    BOOST_CHECK(CheckNBits(firstcheck.second, lastcheck.first+60*60*24*365*4, lastcheck.second, lastcheck.first));\n-}\n-\n CTransaction RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;"
      }
    ]
  },
  {
    "sha": "4c93322923130b1554937de44545d949c54a6e39",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzkzMzIyOTIzMTMwYjE1NTQ5MzdkZTQ0NTQ1ZDk0OWM1NGE2ZTM5",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2014-09-02T10:16:32Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Improve getheaders (sending) logging",
      "tree": {
        "sha": "92ebef71fee8703aba1b1f55e8a37eb1f7543024",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92ebef71fee8703aba1b1f55e8a37eb1f7543024"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c93322923130b1554937de44545d949c54a6e39",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c93322923130b1554937de44545d949c54a6e39",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c93322923130b1554937de44545d949c54a6e39",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c93322923130b1554937de44545d949c54a6e39/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f244c99c96636136678f17e7ef3952a864613ad0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f244c99c96636136678f17e7ef3952a864613ad0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f244c99c96636136678f17e7ef3952a864613ad0"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 4,
      "deletions": 1
    },
    "files": [
      {
        "sha": "f032882ff89f7b37f17d36585a46f7bd82b3e96d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c93322923130b1554937de44545d949c54a6e39/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c93322923130b1554937de44545d949c54a6e39/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4c93322923130b1554937de44545d949c54a6e39",
        "patch": "@@ -3610,6 +3610,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // later (within the same cs_main lock, though).\n                         MarkBlockAsInFlight(pfrom->GetId(), inv.hash);\n                     }\n+                    LogPrint(\"net\", \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n                 }\n             }\n \n@@ -3712,7 +3713,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString());\n+        LogPrint(\"net\", \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString(), pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -3878,6 +3879,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n+            LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n             pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256(0));\n         }\n     }\n@@ -4381,6 +4383,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 state.fSyncStarted = true;\n                 nSyncStarted++;\n                 CBlockIndex *pindexStart = pindexBestHeader->pprev ? pindexBestHeader->pprev : pindexBestHeader;\n+                LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n                 pto->PushMessage(\"getheaders\", chainActive.GetLocator(pindexStart), uint256(0));\n             }\n         }"
      }
    ]
  },
  {
    "sha": "1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYmNlZTY3ZWU3ODBiYzQ0ZDIyYjJlNDQ3ODNhMDRiYzMzMGQ0ZjFm",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2014-09-03T18:31:01Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Better logging of stalling",
      "tree": {
        "sha": "cd476bd99731b3e4deaba904a6f341718693a63f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd476bd99731b3e4deaba904a6f341718693a63f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bcee67ee780bc44d22b2e44783a04bc330d4f1f/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c93322923130b1554937de44545d949c54a6e39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c93322923130b1554937de44545d949c54a6e39",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c93322923130b1554937de44545d949c54a6e39"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "c5ad82c14e89bcd1b6d1f62c35883ed7db1d8af1",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1bcee67ee780bc44d22b2e44783a04bc330d4f1f/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1bcee67ee780bc44d22b2e44783a04bc330d4f1f/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
        "patch": "@@ -4468,8 +4468,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", pindex->GetBlockHash().ToString(), pto->id);\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n-                if (State(staller)->nStallingSince == 0)\n+                if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n+                    LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);\n+                }\n             }\n         }\n "
      }
    ]
  },
  {
    "sha": "1af838b3393ac3d4f6b75ef56f907cb760695952",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYWY4MzhiMzM5M2FjM2Q0ZjZiNzVlZjU2ZjkwN2NiNzYwNjk1OTUy",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2014-09-05T15:32:22Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Add height to \"Requesting block\" debug",
      "tree": {
        "sha": "0322fbbf47b6bd8c233fbb3d2f366758db83e1fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0322fbbf47b6bd8c233fbb3d2f366758db83e1fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1af838b3393ac3d4f6b75ef56f907cb760695952",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af838b3393ac3d4f6b75ef56f907cb760695952",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1af838b3393ac3d4f6b75ef56f907cb760695952",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af838b3393ac3d4f6b75ef56f907cb760695952/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bcee67ee780bc44d22b2e44783a04bc330d4f1f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1bcee67ee780bc44d22b2e44783a04bc330d4f1f"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a2e50b29349555c9b7e8952af27c401fc7b4f49a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af838b3393ac3d4f6b75ef56f907cb760695952/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af838b3393ac3d4f6b75ef56f907cb760695952/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1af838b3393ac3d4f6b75ef56f907cb760695952",
        "patch": "@@ -4465,7 +4465,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n                 vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n-                LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", pindex->GetBlockHash().ToString(), pto->id);\n+                LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                    pindex->nHeight, pto->id);\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {"
      }
    ]
  },
  {
    "sha": "e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTdiZDU4MzkyYmI4MWQ1MzQzZDBiNzNlNGFhNmIxMTNmNTgyOGY5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-06T06:31:33Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Rename setBlockIndexValid to setBlockIndexCandidates",
      "tree": {
        "sha": "1b24457ce3a839c55d89ea7c31a1e57252f777e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1b24457ce3a839c55d89ea7c31a1e57252f777e2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e17bd58392bb81d5343d0b73e4aa6b113f5828f9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1af838b3393ac3d4f6b75ef56f907cb760695952",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af838b3393ac3d4f6b75ef56f907cb760695952",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1af838b3393ac3d4f6b75ef56f907cb760695952"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 15,
      "deletions": 15
    },
    "files": [
      {
        "sha": "bb16b716dcbe70ee0055ca6f2a50213ee45a1539",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e17bd58392bb81d5343d0b73e4aa6b113f5828f9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e17bd58392bb81d5343d0b73e4aa6b113f5828f9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
        "patch": "@@ -99,7 +99,7 @@ namespace {\n \n     // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n     // as good as our current tip. Entries may be failed, though.\n-    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n+    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n     // Number of nodes with fSyncStarted.\n     int nSyncStarted = 0;\n     // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n@@ -1318,7 +1318,7 @@ void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state\n     if (!state.CorruptionPossible()) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n-        setBlockIndexValid.erase(pindex);\n+        setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n     }\n }\n@@ -1918,8 +1918,8 @@ static CBlockIndex* FindMostWorkChain() {\n \n         // Find the best candidate header.\n         {\n-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n-            if (it == setBlockIndexValid.rend())\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();\n+            if (it == setBlockIndexCandidates.rend())\n                 return NULL;\n             pindexNew = *it;\n         }\n@@ -1938,10 +1938,10 @@ static CBlockIndex* FindMostWorkChain() {\n                 CBlockIndex *pindexFailed = pindexNew;\n                 while (pindexTest != pindexFailed) {\n                     pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n-                    setBlockIndexValid.erase(pindexFailed);\n+                    setBlockIndexCandidates.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n                 }\n-                setBlockIndexValid.erase(pindexTest);\n+                setBlockIndexCandidates.erase(pindexTest);\n                 fInvalidAncestor = true;\n                 break;\n             }\n@@ -1990,15 +1990,15 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n                 return false;\n             }\n         } else {\n-            // Delete all entries in setBlockIndexValid that are worse than our new current block.\n+            // Delete all entries in setBlockIndexCandidates that are worse than our new current block.\n             // Note that we can't delete the current block itself, as we may need to return to it later in case a\n             // reorganization to a better block fails.\n-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexValid.begin();\n-            while (setBlockIndexValid.value_comp()(*it, chainActive.Tip())) {\n-                setBlockIndexValid.erase(it++);\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();\n+            while (setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {\n+                setBlockIndexCandidates.erase(it++);\n             }\n-            // Either the current tip or a successor of it we're working towards is left in setBlockIndexValid.\n-            assert(!setBlockIndexValid.empty());\n+            // Either the current tip or a successor of it we're working towards is left in setBlockIndexCandidates.\n+            assert(!setBlockIndexCandidates.empty());\n             if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {\n                 // We're in a better position than we were. Return temporarily to release the lock.\n                 break;\n@@ -2123,7 +2123,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n             CBlockIndex *pindex = queue.front();\n             queue.pop_front();\n             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-            setBlockIndexValid.insert(pindex);\n+            setBlockIndexCandidates.insert(pindex);\n             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n@@ -2803,7 +2803,7 @@ bool static LoadBlockIndexDB()\n             }\n         }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))\n-            setBlockIndexValid.insert(pindex);\n+            setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n@@ -2947,7 +2947,7 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n void UnloadBlockIndex()\n {\n     mapBlockIndex.clear();\n-    setBlockIndexValid.clear();\n+    setBlockIndexCandidates.clear();\n     chainActive.SetTip(NULL);\n     pindexBestInvalid = NULL;\n }"
      }
    ]
  },
  {
    "sha": "ad96e7ccd94679d9125a436ceb5b476aacdfca82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZDk2ZTdjY2Q5NDY3OWQ5MTI1YTQzNmNlYjViNDc2YWFjZGZjYTgy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-10-07T16:06:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Make -reindex cope with out-of-order blocks\n\nRemember out-of-order block headers along with disk positions. This is\nlikely the simplest and least-impact way to make -reindex work with\nheaders first.\n\nBased on top of #4468.",
      "tree": {
        "sha": "d13b3705ce0c51478907f0d680af112b6f5ac006",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d13b3705ce0c51478907f0d680af112b6f5ac006"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ad96e7ccd94679d9125a436ceb5b476aacdfca82",
      "comment_count": 3,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad96e7ccd94679d9125a436ceb5b476aacdfca82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ad96e7ccd94679d9125a436ceb5b476aacdfca82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad96e7ccd94679d9125a436ceb5b476aacdfca82/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e17bd58392bb81d5343d0b73e4aa6b113f5828f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e17bd58392bb81d5343d0b73e4aa6b113f5828f9"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 54,
      "deletions": 8
    },
    "files": [
      {
        "sha": "ad133e1bb81813a3d1ae65e3d7811b2fb9402330",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 8,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ad96e7ccd94679d9125a436ceb5b476aacdfca82/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ad96e7ccd94679d9125a436ceb5b476aacdfca82/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=ad96e7ccd94679d9125a436ceb5b476aacdfca82",
        "patch": "@@ -3070,6 +3070,8 @@ void PrintBlockTree()\n \n bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n {\n+    // Map of disk positions for blocks with unknown parent (only used for reindex)\n+    static std::multimap<uint256, CDiskBlockPos> mapBlocksUnknownParent;\n     int64_t nStart = GetTimeMillis();\n \n     int nLoaded = 0;\n@@ -3112,20 +3114,64 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n             try {\n                 // read block\n                 uint64_t nBlockPos = blkdat.GetPos();\n+                if (nBlockPos < nStartByte) // skip already indexed part\n+                    continue;\n+                if (dbp)\n+                    dbp->nPos = nBlockPos;\n                 blkdat.SetLimit(nBlockPos + nSize);\n+\n+                // read block header\n+                CBlockHeader blockhdr;\n+                blkdat >> blockhdr;\n+                nRewind = blkdat.GetPos();\n+\n+                // process block header\n+                uint256 hash = blockhdr.GetHash();\n+                if (hash != Params().HashGenesisBlock() && mapBlockIndex.find(blockhdr.hashPrevBlock) == mapBlockIndex.end()) {\n+                    LogPrint(\"reindex\", \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n+                            blockhdr.hashPrevBlock.ToString());\n+                    if (dbp)\n+                        mapBlocksUnknownParent.insert(std::make_pair(blockhdr.hashPrevBlock, *dbp));\n+                    // TODO a slight optimization would be: blkdat.Skip(nSize - 80)\n+                    continue;\n+                }\n+\n+                // read block\n+                blkdat.SetPos(nBlockPos);\n                 CBlock block;\n                 blkdat >> block;\n                 nRewind = blkdat.GetPos();\n \n                 // process block\n-                if (nBlockPos >= nStartByte) {\n-                    if (dbp)\n-                        dbp->nPos = nBlockPos;\n-                    CValidationState state;\n-                    if (ProcessBlock(state, NULL, &block, dbp))\n-                        nLoaded++;\n-                    if (state.IsError())\n-                        break;\n+                CValidationState state;\n+                if (ProcessBlock(state, NULL, &block, dbp))\n+                    nLoaded++;\n+                if (state.IsError())\n+                    break;\n+\n+                // Recursively process earlier encountered successors of this block\n+                deque<uint256> queue;\n+                queue.push_back(hash);\n+                while (!queue.empty()) {\n+                    uint256 head = queue.front();\n+                    queue.pop_front();\n+                    std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);\n+                    while (range.first != range.second) {\n+                        std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;\n+                        if (ReadBlockFromDisk(block, it->second))\n+                        {\n+                            LogPrintf(\"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),\n+                                    head.ToString());\n+                            CValidationState dummy;\n+                            if (ProcessBlock(dummy, NULL, &block, &it->second))\n+                            {\n+                                nLoaded++;\n+                                queue.push_back(block.GetHash());\n+                            }\n+                        }\n+                        range.first++;\n+                        mapBlocksUnknownParent.erase(it);\n+                    }\n                 }\n             } catch (std::exception &e) {\n                 LogPrintf(\"%s : Deserialize or I/O error - %s\", __func__, e.what());"
      }
    ]
  },
  {
    "sha": "16d5194165c8c83492b95f431a664d98c40ff254",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNmQ1MTk0MTY1YzhjODM0OTJiOTVmNDMxYTY2NGQ5OGM0MGZmMjU0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-07T19:15:32Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Skip reindexed blocks individually\n\nInstead of skipping to the last reindexed block in each file (which could\njump over processed out-of-order blocks), just skip each already processed\nblock individually.",
      "tree": {
        "sha": "4254323afb8db2c4940e305569f6a4eec98815c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4254323afb8db2c4940e305569f6a4eec98815c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/16d5194165c8c83492b95f431a664d98c40ff254",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16d5194165c8c83492b95f431a664d98c40ff254",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/16d5194165c8c83492b95f431a664d98c40ff254",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16d5194165c8c83492b95f431a664d98c40ff254/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ad96e7ccd94679d9125a436ceb5b476aacdfca82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad96e7ccd94679d9125a436ceb5b476aacdfca82",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ad96e7ccd94679d9125a436ceb5b476aacdfca82"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 16,
      "deletions": 33
    },
    "files": [
      {
        "sha": "908f4c95b62f9f0a36de2dea9cf84788f14d1bdd",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 33,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16d5194165c8c83492b95f431a664d98c40ff254/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16d5194165c8c83492b95f431a664d98c40ff254/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=16d5194165c8c83492b95f431a664d98c40ff254",
        "patch": "@@ -3078,15 +3078,6 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n     try {\n         // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor\n         CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n-        uint64_t nStartByte = 0;\n-        if (dbp) {\n-            // (try to) skip already indexed part\n-            CBlockFileInfo info;\n-            if (pblocktree->ReadBlockFileInfo(dbp->nFile, info)) {\n-                nStartByte = info.nSize;\n-                blkdat.Seek(info.nSize);\n-            }\n-        }\n         uint64_t nRewind = blkdat.GetPos();\n         while (!blkdat.eof()) {\n             boost::this_thread::interruption_point();\n@@ -3114,40 +3105,32 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n             try {\n                 // read block\n                 uint64_t nBlockPos = blkdat.GetPos();\n-                if (nBlockPos < nStartByte) // skip already indexed part\n-                    continue;\n                 if (dbp)\n                     dbp->nPos = nBlockPos;\n                 blkdat.SetLimit(nBlockPos + nSize);\n-\n-                // read block header\n-                CBlockHeader blockhdr;\n-                blkdat >> blockhdr;\n+                blkdat.SetPos(nBlockPos);\n+                CBlock block;\n+                blkdat >> block;\n                 nRewind = blkdat.GetPos();\n \n-                // process block header\n-                uint256 hash = blockhdr.GetHash();\n-                if (hash != Params().HashGenesisBlock() && mapBlockIndex.find(blockhdr.hashPrevBlock) == mapBlockIndex.end()) {\n+                // detect out of order blocks, and store them for later\n+                uint256 hash = block.GetHash();\n+                if (hash != Params().HashGenesisBlock() && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {\n                     LogPrint(\"reindex\", \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n-                            blockhdr.hashPrevBlock.ToString());\n+                            block.hashPrevBlock.ToString());\n                     if (dbp)\n-                        mapBlocksUnknownParent.insert(std::make_pair(blockhdr.hashPrevBlock, *dbp));\n-                    // TODO a slight optimization would be: blkdat.Skip(nSize - 80)\n+                        mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n                     continue;\n                 }\n \n-                // read block\n-                blkdat.SetPos(nBlockPos);\n-                CBlock block;\n-                blkdat >> block;\n-                nRewind = blkdat.GetPos();\n-\n-                // process block\n-                CValidationState state;\n-                if (ProcessBlock(state, NULL, &block, dbp))\n-                    nLoaded++;\n-                if (state.IsError())\n-                    break;\n+                // process in case the block isn't known yet\n+                if (mapBlockIndex.count(hash) == 0) {\n+                    CValidationState state;\n+                    if (ProcessBlock(state, NULL, &block, dbp))\n+                        nLoaded++;\n+                    if (state.IsError())\n+                        break;\n+                }\n \n                 // Recursively process earlier encountered successors of this block\n                 deque<uint256> queue;"
      }
    ]
  },
  {
    "sha": "afc32c5eeada01b141706e32f0405bdb86c00f04",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZmMzMmM1ZWVhZGEwMWIxNDE3MDZlMzJmMDQwNWJkYjg2YzAwZjA0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-10T20:13:47Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:42:01Z"
      },
      "message": "Fix rebuild-chainstate feature and improve its performance\n\nPrevious refactorings broke the ability to rebuild the chainstate by deleting the chainstate\ndirectory, resulting in an incorrect \"Incorrect or no genesis block found\" error message. Fix\nthat.\n\nAlso, improve the performance of ActivateBestBlockStep by using the skiplist to only discover\na few potential blocks to connect at a time, instead of all blocks forever - as we likely bail\nout after connecting a single one anyway.",
      "tree": {
        "sha": "5916cc76e2170cd23e9c87f73e9e576326581741",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5916cc76e2170cd23e9c87f73e9e576326581741"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afc32c5eeada01b141706e32f0405bdb86c00f04",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afc32c5eeada01b141706e32f0405bdb86c00f04",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/afc32c5eeada01b141706e32f0405bdb86c00f04",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afc32c5eeada01b141706e32f0405bdb86c00f04/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "16d5194165c8c83492b95f431a664d98c40ff254",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16d5194165c8c83492b95f431a664d98c40ff254",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/16d5194165c8c83492b95f431a664d98c40ff254"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 15,
      "deletions": 4
    },
    "files": [
      {
        "sha": "55991ac9b32b67072257ae511f7eaa331fcec716",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afc32c5eeada01b141706e32f0405bdb86c00f04/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afc32c5eeada01b141706e32f0405bdb86c00f04/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=afc32c5eeada01b141706e32f0405bdb86c00f04",
        "patch": "@@ -974,7 +974,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && chainActive.Genesis() == NULL)\n+                if (!mapBlockIndex.empty() && mapBlockIndex.count(Params().HashGenesisBlock()) == 0)\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n \n                 // Initialize the block index (no-op if non-empty database was already loaded)"
      },
      {
        "sha": "0612f584ac1fef551ee54f3162aab67513b839ae",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afc32c5eeada01b141706e32f0405bdb86c00f04/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afc32c5eeada01b141706e32f0405bdb86c00f04/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=afc32c5eeada01b141706e32f0405bdb86c00f04",
        "patch": "@@ -1968,12 +1968,20 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n \n     // Build list of new blocks to connect.\n     std::vector<CBlockIndex*> vpindexToConnect;\n-    vpindexToConnect.reserve(pindexMostWork->nHeight - (pindexFork ? pindexFork->nHeight : -1));\n-    CBlockIndex *pindexIter = pindexMostWork;\n-    while (pindexIter && pindexIter != pindexFork) {\n+    bool fContinue = true;\n+    int nHeight = pindexFork ? pindexFork->nHeight : -1;\n+    while (fContinue && nHeight != pindexMostWork->nHeight) {\n+    // Don't iterate the entire list of potential improvements toward the best tip, as we likely only need\n+    // a few blocks along the way.\n+    int nTargetHeight = std::min(nHeight + 32, pindexMostWork->nHeight);\n+    vpindexToConnect.clear();\n+    vpindexToConnect.reserve(nTargetHeight - nHeight);\n+    CBlockIndex *pindexIter = pindexMostWork->GetAncestor(nTargetHeight);\n+    while (pindexIter && pindexIter->nHeight != nHeight) {\n         vpindexToConnect.push_back(pindexIter);\n         pindexIter = pindexIter->pprev;\n     }\n+    nHeight = nTargetHeight;\n \n     // Connect new blocks.\n     BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n@@ -1984,6 +1992,7 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n                     InvalidChainFound(vpindexToConnect.back());\n                 state = CValidationState();\n                 fInvalidFound = true;\n+                fContinue = false;\n                 break;\n             } else {\n                 // A system error occurred (disk space, database error, ...).\n@@ -2001,10 +2010,12 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n             assert(!setBlockIndexCandidates.empty());\n             if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {\n                 // We're in a better position than we were. Return temporarily to release the lock.\n+                fContinue = false;\n                 break;\n             }\n         }\n     }\n+    }\n \n     // Callbacks/notifications for a new best chain.\n     if (fInvalidFound)"
      }
    ]
  },
  {
    "sha": "e11b2ce4c63b87efa60b163b50d155969ccd7e08",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTFiMmNlNGM2M2I4N2VmYTYwYjE2M2I1MGQxNTU5NjljY2Q3ZTA4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T22:41:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-14T23:13:42Z"
      },
      "message": "Fix large reorgs",
      "tree": {
        "sha": "f55b59c79cdbf0665b78cee616ca2776019cad8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f55b59c79cdbf0665b78cee616ca2776019cad8f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e11b2ce4c63b87efa60b163b50d155969ccd7e08",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e11b2ce4c63b87efa60b163b50d155969ccd7e08",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e11b2ce4c63b87efa60b163b50d155969ccd7e08",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e11b2ce4c63b87efa60b163b50d155969ccd7e08/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "afc32c5eeada01b141706e32f0405bdb86c00f04",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afc32c5eeada01b141706e32f0405bdb86c00f04",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/afc32c5eeada01b141706e32f0405bdb86c00f04"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 7,
      "deletions": 6
    },
    "files": [
      {
        "sha": "15363d09a66ef9b5adcb4d05142a60b19054cfd7",
        "filename": "qa/pull-tester/run-bitcoind-for-test.sh.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e11b2ce4c63b87efa60b163b50d155969ccd7e08/qa/pull-tester/run-bitcoind-for-test.sh.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e11b2ce4c63b87efa60b163b50d155969ccd7e08/qa/pull-tester/run-bitcoind-for-test.sh.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/run-bitcoind-for-test.sh.in?ref=e11b2ce4c63b87efa60b163b50d155969ccd7e08",
        "patch": "@@ -10,7 +10,7 @@ touch \"$DATADIR/regtest/debug.log\"\n tail -q -n 1 -F \"$DATADIR/regtest/debug.log\" | grep -m 1 -q \"Done loading\" &\n WAITER=$!\n PORT=`expr 10000 + $$ % 55536`\n-\"@abs_top_builddir@/src/bitcoind@EXEEXT@\" -connect=0.0.0.0 -datadir=\"$DATADIR\" -rpcuser=user -rpcpassword=pass -listen -keypool=3 -debug -debug=net -logtimestamps -port=$PORT -whitelist=127.0.0.1 -regtest -rpcport=`expr $PORT + 1` &\n+\"@abs_top_builddir@/src/bitcoind@EXEEXT@\" -connect=0.0.0.0 -datadir=\"$DATADIR\" -rpcuser=user -rpcpassword=pass -listen -keypool=3 -debug -debug=net -logtimestamps -checkmempool=0 -port=$PORT -whitelist=127.0.0.1 -regtest -rpcport=`expr $PORT + 1` &\n BITCOIND=$!\n \n #Install a watchdog."
      },
      {
        "sha": "f5fd7561c669e1cfeebf32edf6702a25f8890aab",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e11b2ce4c63b87efa60b163b50d155969ccd7e08/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e11b2ce4c63b87efa60b163b50d155969ccd7e08/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e11b2ce4c63b87efa60b163b50d155969ccd7e08",
        "patch": "@@ -385,10 +385,11 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n \n     std::vector<CBlockIndex*> vToFetch;\n     CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n-    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond our\n-    // current tip. The +1 is so we can detect stalling, namely if we would be able to download that next block if the\n-    // window were 1 larger.\n-    int nMaxHeight = std::min<int>(state->pindexBestKnownBlock->nHeight, chainActive.Height() + BLOCK_DOWNLOAD_WINDOW + 1);\n+    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n+    // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n+    // download that next block if the window were 1 larger.\n+    int nWindowEnd = state->pindexLastCommonBlock->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(state->pindexBestKnownBlock->nHeight, nWindowEnd + 1);\n     NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n@@ -411,7 +412,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n-                if (pindex->nHeight > chainActive.Height() + (int)BLOCK_DOWNLOAD_WINDOW) {\n+                if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n                     if (vBlocks.size() == 0 && waitingfor != nodeid) {\n                         // We aren't able to fetch anything, but we would be if the download window was one larger."
      }
    ]
  }
]