laanwj,2018-02-13T11:46:04Z,"@MeshCollider A question about this code - what is supposed to be the semantics of `LockDirectory` if it's called with the same directory multiple times? I understand that the map is just to hold on to the per-directory lock, but right now, if it happens to be called multiple times it will try to re-lock the same lock again\*. We don't check if it already exists, and emplace will return the curren",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365243439,365243439,
laanwj,2018-02-13T11:53:36Z,"Also (as noted by goatpig on IRC) this function is currently not thread-safe. That's no issue right now for 0.16, I think, as this is only used by the init thread at init time, but will be with dynamic loading of wallets.",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365245110,365245110,
laanwj,2018-02-13T13:13:50Z,"@MeshCollider I've added a unit test, test_LockDirectory. Can you please verify I'm testing the intended behavior of the function?",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365262878,365262878,
laanwj,2018-02-13T14:02:12Z,"So this is interesting: my test already found a divergence between the behavior on Linux and Windows. \n\nOn Linux, \n- Another lock on the directory from the same thread succeeds\n- Another lock on the directory from a different thread within the same process succeeds\n\nOn Windows, both cases fail:\n```\ntest/util_tests.cpp(655): error: in ""util_tests/test_LockDirectory"": check LockDirec",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365275126,365275126,
ryanofsky,2018-02-13T15:17:21Z,"> On Windows, both cases fail:\n\nI guess this is due to inconsistent behavior of try_lock. Probably best not to rely on this behavior. Maybe we should replace:\n\n```c++\nlock = locks.emplace(...).first->second;\nif (!lock->try_lock()) {\n    return false;\n}\n```\n\nwith something like:\n\n```c++\nauto inserted = locks.emplace(...);\nif (inserted.second && !inserted.first.second->",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365297403,365297403,
laanwj,2018-02-13T15:25:20Z,"> I guess this is due to inconsistent behavior of try_lock. Probably best not to rely on this behavior. Maybe we should replace:\n\nI agree  - I think we shouldn't insert locks that aren't held into the map at all. This makes it possible to use 'already in map' as early-out.\n\nWhile implementing and testing this, I ran into something really frustrating, I found the `FILE* file = fsbridge::fop",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365299935,365299935,
laanwj,2018-02-13T16:00:28Z,"Pushed a new commit, which hopefully fixes the tests on windows:\n\n### util: Fix multiple use of LockDirectory\n    \nThis commit fixes problems with calling LockDirectory multiple times on the same directory, or from multiple threads.\n    \n- Protect the locks map using a mutex\n- Make sure that only locks that are successfully acquired (and when not probing) are inserted in the map\n- ",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365311724,365311724,
laanwj,2018-02-14T07:48:21Z,"added commit:\n- e548d69: lockname is a parameter to inner functions instead of a constant\n\nsquashed e548d69 [2018_01_openbsd_util_fix_v0](https://github.com/laanwj/bitcoin/tree/2018_01_openbsd_util_fix_v0) -> 6a0a3d7",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365522517,365522517,
laanwj,2018-02-14T08:11:50Z,"Hmm though it compiles, the new test is failing on OpenBSD, which was the original goal of this PR. Talking about scope drift. Will investigate :)\n```\nunknown location(0): fatal error in ""test_LockDirectory"": signal: generated by kill() (or family); uid=0; pid=0\ntest/util_tests.cpp(666): last checkpoint\n```\n\nFixed: this had to do with different handling of SIGCHLD on BSD versus Linux.",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365527136,365527136,
meshcollider,2018-02-15T02:05:54Z,"> I've added a unit test, test_LockDirectory. Can you please verify I'm testing the intended behavior of the function?\n\nLGTM, yep. Ugh OS inconsistencies make things like this so fun. Code changes look good though. cfields changes too, utACK",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365805878,365805878,
laanwj,2018-02-15T09:49:57Z,"Now that I had to add `ReleaseDirectoryLocks()` for testing anyhow, I'm going to extend the cross-process test to see if locks are given up as expected when the map is cleared, or when using probe-only.",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365875935,365875935,
laanwj,2018-02-15T10:18:23Z,"In the new commit I added unit tests for lock probing, to see if `ReleaseDirectoryLocks()` succesfully releases the lock, and whether exiting the child prices releases the lock. At least locally this all passes, let's see what Travis makes of it.\n",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365883346,365883346,
laanwj,2018-02-15T12:38:06Z,"> Whoa, sneaky. Yes, that's possible. Let's try the tests that by using an already-existing directory with an existing lock file, without that fopen part.\n\nTo check this, I applied the following patch, removing all manual file and directory handling:\n```patch\ndiff --git a/src/test/util_tests.cpp b/src/test/util_tests.cpp\nindex 4b2da3e..80d76e6 100644\n--- a/src/test/util_tests.cpp\n+++",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365915178,365915178,
Sjors,2018-02-15T13:19:05Z,`make check` is still happy on MacOS (46d46323).,https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365924663,365924663,
laanwj,2018-02-15T15:27:57Z,"squashed into two commits (one that makes the changes to LockDatadirectory, one that adds the unit test)\n46d4632 [2018_01_openbsd_util_fix_v1](https://github.com/laanwj/bitcoin/tree/2018_01_openbsd_util_fix_v1) â†’ 1d4cbd2",https://github.com/bitcoin/bitcoin/pull/12422#issuecomment-365961484,365961484,
laanwj,2018-02-13T16:08:47Z,"It think this explicit unlock is unnecessary now, as the lock will fall out of scope when `locks.emplace` is not called to move it to the map.",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r167914138,167914138,src/util.cpp
bpay,2018-02-13T18:58:14Z,std::lock_guard should suffice for this,https://github.com/bitcoin/bitcoin/pull/12422#discussion_r167966315,167966315,src/util.cpp
ryanofsky,2018-02-13T22:46:25Z,"Maybe define TestOtherThread as a lambda instead of an external function. TestOther code would seem easier to understand in the context where it launches instead of out here. Also this would allow test case to be self contained and not need external LOCKNAME/TestOther declarations.\n",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168027391,168027391,src/test/util_tests.cpp
laanwj,2018-02-14T07:08:40Z,"Conceptually I do prefer (especially) the TestOtherProcess code to be in a self-contained function instead of in-line, because the stuff runs in a separate process. Also making the separate-process test work on windows (not going to do so in this pull) would involve some factoring in that direction anyhow.\nIf the LOCKNAME constant is a problem it could be passed in as parameter.\n",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168091131,168091131,src/test/util_tests.cpp
laanwj,2018-02-14T07:26:29Z,"But yeah I do see the argument for making it self-contained, too. Really not sure here...\n\nEdit: however, unlike for the thread, inlining TestOtherProcess won't put the code in a context where it's easier to understand, but at the beginning of the function in ` fork()` else.",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168093502,168093502,src/test/util_tests.cpp
theuni,2018-02-14T21:14:54Z,"Maybe note that this just working around the lack of [std::map::try_emplace](http://en.cppreference.com/w/cpp/container/map/try_emplace), which was added in c++17.\n\nEdit: Heh, they even use this exact construction as an example:\n> Unlike insert or emplace, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values a",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168311689,168311689,src/util.cpp
theuni,2018-02-15T01:16:14Z,"May as well bail early if the fopen fails, we're just going to end up in a boost exception.",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168360648,168360648,src/util.cpp
theuni,2018-02-15T01:18:42Z,"I realize it isn't a regression, but this really needs to be logged.",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168360991,168360991,src/util.cpp
theuni,2018-02-15T01:20:46Z,"In the probe_only case, this won't be unlocked when ```lock``` destructs, as interprocess::file_lock isn't RAII. Was it intended to work that way?",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168361288,168361288,src/util.cpp
laanwj,2018-02-15T09:17:29Z,"Eh are you sure? the whole intent of keeping the things in a std::map is that they get unlocked when they are destructed. Anecdotally this seems to work on windows, at least, the call to `ReleaseDirectoryLocks()` seems to release the locks. I can try further.\n\nEdit: shouldn't `-daemon` be broken if true? It's what uses `probe_only` to probe (acquire and release) the lock from the parent proces",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168415708,168415708,src/util.cpp
laanwj,2018-02-15T09:19:10Z,"In both cases it's used, it's logged in the caller function, so I think that is redundant?",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168416118,168416118,src/util.cpp
laanwj,2018-02-15T09:21:15Z,"I played with that thought, but decided against it - that would just add extra code for an error case that is handled by boost, later?",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168416619,168416619,src/util.cpp
laanwj,2018-02-15T10:31:19Z,"The documentation is confusing here (http://www.boost.org/doc/libs/1_66_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.file_lock):\n\n> A file locking is a class that has process lifetime. This means that if a process holding a file lock ends or crashes, the operating system will automatically unlock it. This feature is very useful in some situati",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168435190,168435190,src/util.cpp
theuni,2018-02-15T11:58:21Z,"Grr, the ""theuni requested changes"" is a bit overstated... There are a few fixes here and I can't produce any real-world issues, so utACK from me for 0.16 for the sake of not dragging it out.\n\n----\n\nFurther discussion for master, or 0.16 if you still feel like messing with it:\n\n\nStrange, your tests results (RAII behavior) don't line up with what I see from the docs/code. I'll play wi",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168454821,168454821,src/util.cpp
laanwj,2018-02-15T12:05:58Z,"> Is it possible that it was the fclose rather than the fopen? Because that would explain everything neatly, I think. In the probe_only case, You create a lock, lock it, then destroy it. Then on the next invocation you fopen/fclose it, which basically gives a clean start before you create a new lock, lock again, etc.\n\nWhoa, sneaky. Yes, that's possible. Let's try the tests that by using an alr",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168456466,168456466,src/util.cpp
laanwj,2018-02-15T17:02:54Z,"I'm a bit confused here, to be honest. Does `try_emplace` avoid constructing the object entirely if it already exists in the map?",https://github.com/bitcoin/bitcoin/pull/12422#discussion_r168541842,168541842,src/util.cpp
