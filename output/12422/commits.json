[
  {
    "sha": "fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzg4OGJmY2FjYjg3NWM0NWJjOGY5ZDdjYTEzNTdhYjcwYTMwNDkw",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2018-02-13T13:12:30Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2018-02-15T15:24:45Z"
      },
      "message": "util: Fix multiple use of LockDirectory\n\nThis commit fixes problems with calling LockDirectory multiple times on\nthe same directory, or from multiple threads. It also fixes the build on\nOpenBSD.\n\n- Wrap the boost::interprocess::file_lock in a std::unique_ptr inside\n  the map that keeps track of per-directory locks. This fixes a build\n  issue with the clang 4.0.0+boost-1.58.0p8 version combo on OpenBSD\n  6.2, and should have no observable effect otherwise.\n\n- Protect the locks map using a mutex.\n\n- Make sure that only locks that are successfully acquired are inserted\n  in the map.\n\n- Open the lock file for appending only if we know we don't have the\n  lock yet - The `FILE* file = fsbridge::fopen(pathLockFile, \"a\");`\n  wipes the 'we own this lock' administration, likely because it opens\n  a new fd for the locked file then closes it.",
      "tree": {
        "sha": "569fcde0c6b00df3b90bcc5a4cb5139452cfa596",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/569fcde0c6b00df3b90bcc5a4cb5139452cfa596"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc888bfcacb875c45bc8f9d7ca1357ab70a30490/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4f4f51f1a940a239c9b406fe3b362bf3303cbce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4f4f51f1a940a239c9b406fe3b362bf3303cbce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4f4f51f1a940a239c9b406fe3b362bf3303cbce"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 20,
      "deletions": 6
    },
    "files": [
      {
        "sha": "49f40dc942296201af6cc5d5ad1543a43b67c329",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 6,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc888bfcacb875c45bc8f9d7ca1357ab70a30490/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc888bfcacb875c45bc8f9d7ca1357ab70a30490/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
        "patch": "@@ -375,18 +375,32 @@ int LogPrintStr(const std::string &str)\n \n bool LockDirectory(const fs::path& directory, const std::string lockfile_name, bool probe_only)\n {\n+    // A map that contains all the currently held directory locks. After\n+    // successful locking, these will be held here until the global\n+    // destructor cleans them up and thus automatically unlocks them.\n+    static std::map<std::string, std::unique_ptr<boost::interprocess::file_lock>> locks;\n+    // Protect the map with a mutex\n+    static std::mutex cs;\n+    std::lock_guard<std::mutex> ulock(cs);\n     fs::path pathLockFile = directory / lockfile_name;\n-    FILE* file = fsbridge::fopen(pathLockFile, \"a\"); // empty lock file; created if it doesn't exist.\n+\n+    // If a lock for this directory already exists in the map, don't try to re-lock it\n+    if (locks.count(pathLockFile.string())) {\n+        return true;\n+    }\n+\n+    // Create empty lock file if it doesn't exist.\n+    FILE* file = fsbridge::fopen(pathLockFile, \"a\");\n     if (file) fclose(file);\n \n     try {\n-        static std::map<std::string, boost::interprocess::file_lock> locks;\n-        boost::interprocess::file_lock& lock = locks.emplace(pathLockFile.string(), pathLockFile.string().c_str()).first->second;\n-        if (!lock.try_lock()) {\n+        auto lock = MakeUnique<boost::interprocess::file_lock>(pathLockFile.string().c_str());\n+        if (!lock->try_lock()) {\n             return false;\n         }\n-        if (probe_only) {\n-            lock.unlock();\n+        if (!probe_only) {\n+            // Lock successful and we're not just probing, put it into the map\n+            locks.emplace(pathLockFile.string(), std::move(lock));\n         }\n     } catch (const boost::interprocess::interprocess_exception& e) {\n         return error(\"Error while attempting to lock directory %s: %s\", directory.string(), e.what());"
      }
    ]
  },
  {
    "sha": "1d4cbd26e4220982f7f2f60e447199d6f62ae254",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZDRjYmQyNmU0MjIwOTgyZjdmMmY2MGU0NDcxOTlkNmY2MmFlMjU0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2018-02-13T12:53:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2018-02-15T15:25:13Z"
      },
      "message": "test: Add unit test for LockDirectory\n\nAdd a unit test for LockDirectory, introduced in #11281.",
      "tree": {
        "sha": "4c8f244dacd9238dd810b5821175bb72b1d49808",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c8f244dacd9238dd810b5821175bb72b1d49808"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1d4cbd26e4220982f7f2f60e447199d6f62ae254",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d4cbd26e4220982f7f2f60e447199d6f62ae254",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1d4cbd26e4220982f7f2f60e447199d6f62ae254",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d4cbd26e4220982f7f2f60e447199d6f62ae254/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc888bfcacb875c45bc8f9d7ca1357ab70a30490",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc888bfcacb875c45bc8f9d7ca1357ab70a30490"
      }
    ],
    "stats": {
      "total": 163,
      "additions": 154,
      "deletions": 9
    },
    "files": [
      {
        "sha": "4b2da3e2193a7490f5a20b3c6bf9bac528b88396",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 130,
        "deletions": 0,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d4cbd26e4220982f7f2f60e447199d6f62ae254/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d4cbd26e4220982f7f2f60e447199d6f62ae254/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=1d4cbd26e4220982f7f2f60e447199d6f62ae254",
        "patch": "@@ -13,6 +13,10 @@\n \n #include <stdint.h>\n #include <vector>\n+#ifndef WIN32\n+#include <sys/types.h>\n+#include <sys/wait.h>\n+#endif\n \n #include <boost/test/unit_test.hpp>\n \n@@ -603,4 +607,130 @@ BOOST_AUTO_TEST_CASE(test_ParseFixedPoint)\n     BOOST_CHECK(!ParseFixedPoint(\"1.\", 8, &amount));\n }\n \n+static void TestOtherThread(fs::path dirname, std::string lockname, bool *result)\n+{\n+    *result = LockDirectory(dirname, lockname);\n+}\n+\n+#ifndef WIN32 // Cannot do this test on WIN32 due to lack of fork()\n+static constexpr char LockCommand = 'L';\n+static constexpr char UnlockCommand = 'U';\n+static constexpr char ExitCommand = 'X';\n+\n+static void TestOtherProcess(fs::path dirname, std::string lockname, int fd)\n+{\n+    char ch;\n+    int rv;\n+    while (true) {\n+        rv = read(fd, &ch, 1); // Wait for command\n+        assert(rv == 1);\n+        switch(ch) {\n+        case LockCommand:\n+            ch = LockDirectory(dirname, lockname);\n+            rv = write(fd, &ch, 1);\n+            assert(rv == 1);\n+            break;\n+        case UnlockCommand:\n+            ReleaseDirectoryLocks();\n+            ch = true; // Always succeeds\n+            rv = write(fd, &ch, 1);\n+            break;\n+        case ExitCommand:\n+            close(fd);\n+            exit(0);\n+        default:\n+            assert(0);\n+        }\n+    }\n+}\n+#endif\n+\n+BOOST_AUTO_TEST_CASE(test_LockDirectory)\n+{\n+    fs::path dirname = fs::temp_directory_path() / fs::unique_path();\n+    const std::string lockname = \".lock\";\n+#ifndef WIN32\n+    // Revert SIGCHLD to default, otherwise boost.test will catch and fail on\n+    // it: there is BOOST_TEST_IGNORE_SIGCHLD but that only works when defined\n+    // at build-time of the boost library\n+    void (*old_handler)(int) = signal(SIGCHLD, SIG_DFL);\n+\n+    // Fork another process for testing before creating the lock, so that we\n+    // won't fork while holding the lock (which might be undefined, and is not\n+    // relevant as test case as that is avoided with -daemonize).\n+    int fd[2];\n+    BOOST_CHECK_EQUAL(socketpair(AF_UNIX, SOCK_STREAM, 0, fd), 0);\n+    pid_t pid = fork();\n+    if (!pid) {\n+        BOOST_CHECK_EQUAL(close(fd[1]), 0); // Child: close parent end\n+        TestOtherProcess(dirname, lockname, fd[0]);\n+    }\n+    BOOST_CHECK_EQUAL(close(fd[0]), 0); // Parent: close child end\n+#endif\n+    // Lock on non-existent directory should fail\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname), false);\n+\n+    fs::create_directories(dirname);\n+\n+    // Probing lock on new directory should succeed\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname, true), true);\n+\n+    // Persistent lock on new directory should succeed\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname), true);\n+\n+    // Another lock on the directory from the same thread should succeed\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname), true);\n+\n+    // Another lock on the directory from a different thread within the same process should succeed\n+    bool threadresult;\n+    std::thread thr(TestOtherThread, dirname, lockname, &threadresult);\n+    thr.join();\n+    BOOST_CHECK_EQUAL(threadresult, true);\n+#ifndef WIN32\n+    // Try to aquire lock in child process while we're holding it, this should fail.\n+    char ch;\n+    BOOST_CHECK_EQUAL(write(fd[1], &LockCommand, 1), 1);\n+    BOOST_CHECK_EQUAL(read(fd[1], &ch, 1), 1);\n+    BOOST_CHECK_EQUAL((bool)ch, false);\n+\n+    // Give up our lock\n+    ReleaseDirectoryLocks();\n+    // Probing lock from our side now should succeed, but not hold on to the lock.\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname, true), true);\n+\n+    // Try to acquire the lock in the child process, this should be succesful.\n+    BOOST_CHECK_EQUAL(write(fd[1], &LockCommand, 1), 1);\n+    BOOST_CHECK_EQUAL(read(fd[1], &ch, 1), 1);\n+    BOOST_CHECK_EQUAL((bool)ch, true);\n+\n+    // When we try to probe the lock now, it should fail.\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname, true), false);\n+\n+    // Unlock the lock in the child process\n+    BOOST_CHECK_EQUAL(write(fd[1], &UnlockCommand, 1), 1);\n+    BOOST_CHECK_EQUAL(read(fd[1], &ch, 1), 1);\n+    BOOST_CHECK_EQUAL((bool)ch, true);\n+\n+    // When we try to probe the lock now, it should succeed.\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname, true), true);\n+\n+    // Re-lock the lock in the child process, then wait for it to exit, check\n+    // successful return. After that, we check that exiting the process\n+    // has released the lock as we would expect by probing it.\n+    int processstatus;\n+    BOOST_CHECK_EQUAL(write(fd[1], &LockCommand, 1), 1);\n+    BOOST_CHECK_EQUAL(write(fd[1], &ExitCommand, 1), 1);\n+    BOOST_CHECK_EQUAL(waitpid(pid, &processstatus, 0), pid);\n+    BOOST_CHECK_EQUAL(processstatus, 0);\n+    BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname, true), true);\n+\n+    // Restore SIGCHLD\n+    signal(SIGCHLD, old_handler);\n+    BOOST_CHECK_EQUAL(close(fd[1]), 0); // Close our side of the socketpair\n+#endif\n+    // Clean up\n+    ReleaseDirectoryLocks();\n+    fs::remove_all(dirname);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "dcf7ed38b11953a826086aecc716893f8fa10f06",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 9,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d4cbd26e4220982f7f2f60e447199d6f62ae254/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d4cbd26e4220982f7f2f60e447199d6f62ae254/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=1d4cbd26e4220982f7f2f60e447199d6f62ae254",
        "patch": "@@ -373,19 +373,22 @@ int LogPrintStr(const std::string &str)\n     return ret;\n }\n \n+/** A map that contains all the currently held directory locks. After\n+ * successful locking, these will be held here until the global destructor\n+ * cleans them up and thus automatically unlocks them, or ReleaseDirectoryLocks\n+ * is called.\n+ */\n+static std::map<std::string, std::unique_ptr<boost::interprocess::file_lock>> dir_locks;\n+/** Mutex to protect dir_locks. */\n+static std::mutex cs_dir_locks;\n+\n bool LockDirectory(const fs::path& directory, const std::string lockfile_name, bool probe_only)\n {\n-    // A map that contains all the currently held directory locks. After\n-    // successful locking, these will be held here until the global\n-    // destructor cleans them up and thus automatically unlocks them.\n-    static std::map<std::string, std::unique_ptr<boost::interprocess::file_lock>> locks;\n-    // Protect the map with a mutex\n-    static std::mutex cs;\n-    std::lock_guard<std::mutex> ulock(cs);\n+    std::lock_guard<std::mutex> ulock(cs_dir_locks);\n     fs::path pathLockFile = directory / lockfile_name;\n \n     // If a lock for this directory already exists in the map, don't try to re-lock it\n-    if (locks.count(pathLockFile.string())) {\n+    if (dir_locks.count(pathLockFile.string())) {\n         return true;\n     }\n \n@@ -400,14 +403,20 @@ bool LockDirectory(const fs::path& directory, const std::string lockfile_name, b\n         }\n         if (!probe_only) {\n             // Lock successful and we're not just probing, put it into the map\n-            locks.emplace(pathLockFile.string(), std::move(lock));\n+            dir_locks.emplace(pathLockFile.string(), std::move(lock));\n         }\n     } catch (const boost::interprocess::interprocess_exception& e) {\n         return error(\"Error while attempting to lock directory %s: %s\", directory.string(), e.what());\n     }\n     return true;\n }\n \n+void ReleaseDirectoryLocks()\n+{\n+    std::lock_guard<std::mutex> ulock(cs_dir_locks);\n+    dir_locks.clear();\n+}\n+\n /** Interpret string as boolean, for argument parsing */\n static bool InterpretBool(const std::string& strValue)\n {"
      },
      {
        "sha": "9490a5678f2a8695203c66d562298ac07c6415fe",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d4cbd26e4220982f7f2f60e447199d6f62ae254/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d4cbd26e4220982f7f2f60e447199d6f62ae254/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=1d4cbd26e4220982f7f2f60e447199d6f62ae254",
        "patch": "@@ -174,6 +174,12 @@ int RaiseFileDescriptorLimit(int nMinFD);\n void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);\n bool RenameOver(fs::path src, fs::path dest);\n bool LockDirectory(const fs::path& directory, const std::string lockfile_name, bool probe_only=false);\n+\n+/** Release all directory locks. This is used for unit testing only, at runtime\n+ * the global destructor will take care of the locks.\n+ */\n+void ReleaseDirectoryLocks();\n+\n bool TryCreateDirectories(const fs::path& p);\n fs::path GetDefaultDataDir();\n const fs::path &GetDataDir(bool fNetSpecific = true);"
      }
    ]
  }
]