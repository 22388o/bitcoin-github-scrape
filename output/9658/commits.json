[
  {
    "sha": "4a1a0df5fbef83486cfe761ef1fb7f48b25445ac",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YTFhMGRmNWZiZWY4MzQ4NmNmZTc2MWVmMWZiN2Y0OGIyNTQ0NWFj",
    "commit": {
      "author": {
        "name": "isle2983",
        "email": "isle2983@yahoo.com",
        "date": "2017-01-31T21:00:05Z"
      },
      "committer": {
        "name": "isle2983",
        "email": "isle2983@yahoo.com",
        "date": "2017-01-31T21:00:05Z"
      },
      "message": "Implement clang_format.py\n\nA script for running 'clang-format' to help expose and resolve code style issues",
      "tree": {
        "sha": "96378fff8a5bca6f3301c7a64fa1f5cda679b3f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96378fff8a5bca6f3301c7a64fa1f5cda679b3f0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac/comments",
    "author": {
      "login": "isle2983",
      "id": 20916903,
      "node_id": "MDQ6VXNlcjIwOTE2OTAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/20916903?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/isle2983",
      "html_url": "https://github.com/isle2983",
      "followers_url": "https://api.github.com/users/isle2983/followers",
      "following_url": "https://api.github.com/users/isle2983/following{/other_user}",
      "gists_url": "https://api.github.com/users/isle2983/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/isle2983/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/isle2983/subscriptions",
      "organizations_url": "https://api.github.com/users/isle2983/orgs",
      "repos_url": "https://api.github.com/users/isle2983/repos",
      "events_url": "https://api.github.com/users/isle2983/events{/privacy}",
      "received_events_url": "https://api.github.com/users/isle2983/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "isle2983",
      "id": 20916903,
      "node_id": "MDQ6VXNlcjIwOTE2OTAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/20916903?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/isle2983",
      "html_url": "https://github.com/isle2983",
      "followers_url": "https://api.github.com/users/isle2983/followers",
      "following_url": "https://api.github.com/users/isle2983/following{/other_user}",
      "gists_url": "https://api.github.com/users/isle2983/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/isle2983/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/isle2983/subscriptions",
      "organizations_url": "https://api.github.com/users/isle2983/orgs",
      "repos_url": "https://api.github.com/users/isle2983/repos",
      "events_url": "https://api.github.com/users/isle2983/events{/privacy}",
      "received_events_url": "https://api.github.com/users/isle2983/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e99f0d7ad443ff72087c6f80e9fab65cace0bf19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e99f0d7ad443ff72087c6f80e9fab65cace0bf19",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e99f0d7ad443ff72087c6f80e9fab65cace0bf19"
      }
    ],
    "stats": {
      "total": 697,
      "additions": 697,
      "deletions": 0
    },
    "files": [
      {
        "sha": "026b9938e0302702b3bb46e6f296a4da73ce52af",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=4a1a0df5fbef83486cfe761ef1fb7f48b25445ac",
        "patch": "@@ -8,6 +8,36 @@ check-doc.py\n Check if all command line args are documented. The return value indicates the\n number of undocumented args.\n \n+clang\\_format.py\n+===================\n+\n+A utility for invoking clang-format to observe the state of C++ code\n+formatting in the repository. It produces reports of style metrics and also can\n+apply formatting. It has three subcommands - `report`, `check`, and `format`:\n+\n+```\n+clang_format.py [-h] [-b BIN_PATH] [-s STYLE_FILE] [-j JOBS] [-f]\n+                    {report,check,format} [target [target ...]]\n+```\n+\n+The style definition file and clang-format binary can be varied to experiment and compare results.\n+\n+clang\\_format.py report\n+-----------------------\n+\n+Produces a report with analysis of the selected files taken as a group.\n+\n+clang\\_format.py check\n+-----------------------\n+\n+Validates that the selected files match the style and gives a per-file report\n+and returns a non-zero bash status if there are any format issues discovered.\n+\n+clang\\_format.py format\n+-----------------------\n+\n+Applies the style formatting to the selected files.\n+\n clang-format-diff.py\n ===================\n "
      },
      {
        "sha": "7d1f7a1e481642a0fda4778a6f471396b813ea41",
        "filename": "contrib/devtools/clang_format.py",
        "status": "added",
        "additions": 667,
        "deletions": 0,
        "changes": 667,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac/contrib/devtools/clang_format.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a1a0df5fbef83486cfe761ef1fb7f48b25445ac/contrib/devtools/clang_format.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/clang_format.py?ref=4a1a0df5fbef83486cfe761ef1fb7f48b25445ac",
        "patch": "@@ -0,0 +1,667 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import sys\n+import os\n+import subprocess\n+import time\n+import argparse\n+import re\n+import fnmatch\n+import difflib\n+import hashlib\n+from multiprocessing import Pool\n+\n+###############################################################################\n+# settings for the set of files that this applies to\n+###############################################################################\n+\n+SOURCE_FILES = ['*.cpp', '*.h']\n+\n+SOURCE_FILES_COMPILED = re.compile('|'.join([fnmatch.translate(match)\n+                                             for match in SOURCE_FILES]))\n+\n+ALWAYS_IGNORE = [\n+    # files in subtrees:\n+    'src/secp256k1/*',\n+    'src/leveldb/*',\n+    'src/univalue/*',\n+    'src/crypto/ctaes/*',\n+]\n+\n+ALWAYS_IGNORE_COMPILED = re.compile('|'.join([fnmatch.translate(match)\n+                                              for match in ALWAYS_IGNORE]))\n+\n+###############################################################################\n+# obtain list of files in repo to examine\n+###############################################################################\n+\n+GIT_LS_CMD = 'git ls-files'\n+\n+\n+def git_ls():\n+    out = subprocess.check_output(GIT_LS_CMD.split(' '))\n+    return [f for f in out.decode(\"utf-8\").split('\\n') if f != '']\n+\n+\n+def filename_is_to_be_examined(filename):\n+    return (SOURCE_FILES_COMPILED.match(filename) and not\n+            ALWAYS_IGNORE_COMPILED.match(filename))\n+\n+\n+def get_filenames_in_scope(full_file_list):\n+    return sorted([filename for filename in full_file_list if\n+                   filename_is_to_be_examined(filename)])\n+\n+\n+###############################################################################\n+# file IO\n+###############################################################################\n+\n+\n+def read_file(filename):\n+    file = open(os.path.abspath(filename), 'r')\n+    contents = file.read()\n+    file.close()\n+    return contents\n+\n+\n+def write_file(filename, contents):\n+    file = open(os.path.abspath(filename), 'w')\n+    file.write(contents)\n+    file.close()\n+\n+\n+###############################################################################\n+# obtain formatted file\n+###############################################################################\n+\n+\n+def generate_style_arg(opts):\n+    return '-style={%s}' % ', '.join([\"%s: %s\" % (k, v) for k, v in\n+                                      opts.style_params.items()])\n+\n+\n+UNKNOWN_KEY_REGEX = re.compile(\"unknown key '(?P<key_name>\\w+)'\")\n+\n+\n+def parse_unknown_key(err):\n+    if len(err) == 0:\n+        return 0, None\n+    match = UNKNOWN_KEY_REGEX.search(err)\n+    if not match:\n+        return len(err), None\n+    return len(err), match.group('key_name')\n+\n+\n+def try_format_file(opts, filename):\n+    cmd = [opts.bin_path, generate_style_arg(opts), filename]\n+    return subprocess.Popen(cmd, stdout=subprocess.PIPE,\n+                            stderr=subprocess.PIPE)\n+\n+\n+def format_file(opts, filename):\n+    while True:\n+        p = try_format_file(opts, filename)\n+        out = p.stdout.read().decode('utf-8')\n+        err = p.stderr.read().decode('utf-8')\n+        p.communicate()\n+        if p.returncode != 0:\n+            sys.exit(\"*** clang-format could not execute\")\n+        # Older versions of clang don't support some style parameter keys, so\n+        # we work around by redacting any key that gets rejected until we find\n+        # a subset of parameters that can apply the format without producing\n+        # any stderr output.\n+        err_len, unknown_key = parse_unknown_key(err)\n+        if not unknown_key and err_len > 0:\n+            sys.exit(\"*** clang-format produced unknown output to stderr\")\n+        if unknown_key:\n+            opts.style_params.pop(unknown_key)\n+            opts.unknown_style_params.append(unknown_key)\n+            continue\n+        return out\n+\n+\n+###############################################################################\n+# scoring\n+###############################################################################\n+\n+\n+def style_score(pre_format, unchanged, added, removed):\n+    # A crude calculation to give a percentage rating for adherence to the\n+    # defined style.\n+    if (added + removed) == 0:\n+        return 100\n+    return min(int(abs(1 - (float(pre_format - unchanged) /\n+                            float(pre_format))) * 100), 99)\n+\n+\n+def scoreboard(score, pre_format, added, removed, unchanged, post_format):\n+    return (\" +-------+          +------------+--------+---------+-----------+\"\n+            \"-------------+\\n\"\n+            \" | score |          | pre-format |  added | removed | unchanged |\"\n+            \" post-format |\\n\"\n+            \" +-------+  +-------+------------+--------+---------+-----------+\"\n+            \"-------------+\\n\"\n+            \" | %3d%%  |  | lines | %10d | %6d | %7d | %9d | %11d |\\n\"\n+            \" +-------+  +-------+------------+--------+---------+-----------+\"\n+            \"-------------+\\n\" % (score, pre_format, added, removed,\n+                                  unchanged, post_format))\n+\n+\n+###############################################################################\n+# gather file and diff info\n+###############################################################################\n+\n+\n+def classify_diff_lines(diff):\n+    for l in diff:\n+        if l.startswith('  '):\n+            yield 1, 0, 0\n+        elif l.startswith('+ '):\n+            yield 0, 1, 0\n+        elif l.startswith('- '):\n+            yield 0, 0, 1\n+\n+\n+def sum_lines_of_type(diff):\n+    return (sum(c) for c in zip(*classify_diff_lines(diff)))\n+\n+\n+def gather_file_info(opts, filename):\n+    start = time.time()\n+    file_info = {}\n+    file_info['filename'] = filename\n+    file_info['contents'] = read_file(filename)\n+    file_info['formatted'] = format_file(opts, filename)\n+    file_info['matching'] = (file_info['contents'] == file_info['formatted'])\n+    file_info['formatted_md5'] = (\n+        hashlib.md5(file_info['formatted'].encode('utf-8')).hexdigest())\n+    return file_info\n+\n+\n+DIFFER = difflib.Differ()\n+\n+\n+def compute_diff_info(file_info):\n+    pre_format_lines = file_info['contents'].splitlines()\n+    post_format_lines = file_info['formatted'].splitlines()\n+    file_info['pre_format_lines'] = len(pre_format_lines)\n+    file_info['post_format_lines'] = len(post_format_lines)\n+    start_time = time.time()\n+    diff = DIFFER.compare(pre_format_lines, post_format_lines)\n+    (file_info['unchanged_lines'],\n+     file_info['added_lines'],\n+     file_info['removed_lines']) = sum_lines_of_type(diff)\n+    file_info['diff_time'] = time.time() - start_time\n+    file_info['score'] = style_score(file_info['pre_format_lines'],\n+                                     file_info['unchanged_lines'],\n+                                     file_info['added_lines'],\n+                                     file_info['removed_lines'])\n+    return file_info\n+\n+\n+###############################################################################\n+# report helpers\n+###############################################################################\n+\n+\n+SEPARATOR = '-' * 80 + '\\n'\n+REPORT = []\n+\n+\n+def report(string):\n+    REPORT.append(string)\n+\n+\n+GREEN = '\\033[92m'\n+RED = '\\033[91m'\n+ENDC = '\\033[0m'\n+\n+\n+def red_report(string):\n+    report(RED + string + ENDC)\n+\n+\n+def green_report(string):\n+    report(GREEN + string + ENDC)\n+\n+\n+def flush_report():\n+    print(''.join(REPORT), end=\"\")\n+\n+\n+###############################################################################\n+# warning for old versions of clang-format\n+###############################################################################\n+\n+\n+def report_if_parameters_unsupported(opts):\n+    if len(opts.unknown_style_params) == 0:\n+        return\n+    report(SEPARATOR)\n+    red_report(\"WARNING\")\n+    report(\" - This version of clang-format does not support the \"\n+           \"following style\\nparameters, so they were not used:\\n\\n\")\n+    for param in opts.unknown_style_params:\n+        report(\"%s\\n\" % param)\n+\n+\n+def exit_if_parameters_unsupported(opts):\n+    if opts.force:\n+        return\n+    if len(opts.unknown_style_params) > 0:\n+        red_report(\"\\nWARNING: \")\n+        report(\"clang-format version %s does not support all \"\n+               \"parameters given in\\n%s\\n\\n\" % (opts.bin_version,\n+                                                opts.style_file))\n+        report(\"Unsupported parameters:\\n\")\n+        for param in opts.unknown_style_params:\n+            report(\"\\t%s\\n\" % param)\n+        # The recommendation is from experimentation where it is found that the\n+        # applied formating has subtle differences that vary between major\n+        # releases of clang-format. A chosen standard of formatting should\n+        # probably be based on the latest stable release and that should be the\n+        # recommendation.\n+        report(\"\\nUsing clang-format version 3.9.0 or higher is recommended\\n\")\n+        report(\"Use the --force option to override and proceed anyway.\\n\\n\")\n+        flush_report()\n+        sys.exit(\"*** missing clang-format support.\")\n+\n+\n+###############################################################################\n+# 'report' subcommand execution\n+###############################################################################\n+\n+\n+def report_examined_files(file_infos, in_scope_file_list, full_file_list):\n+    report(\"%4d files tracked according to '%s'\\n\" %\n+           (len(full_file_list), GIT_LS_CMD))\n+    report(\"%4d files in scope according to SOURCE_FILES and ALWAYS_IGNORE \"\n+           \"settings\\n\" % len(in_scope_file_list))\n+    report(\"%4d files examined according to listed targets\\n\" %\n+           len(file_infos))\n+\n+\n+def score_in_range_inclusive(score, lower, upper):\n+    return (score >= lower) and (score <= upper)\n+\n+\n+def report_files_in_range(file_infos, lower, upper):\n+    in_range = [file_info for file_info in file_infos if\n+                score_in_range_inclusive(file_info['score'], lower, upper)]\n+    report(\"Files %2d%%-%2d%% matching:        %4d\\n\" % (lower, upper,\n+                                                         len(in_range)))\n+\n+\n+def report_files_in_ranges(file_infos):\n+    ranges = [(90, 99), (80, 89), (70, 79), (60, 69), (50, 59), (40, 49),\n+              (30, 39), (20, 29), (10, 19), (0, 9)]\n+    for lower, upper in ranges:\n+        report_files_in_range(file_infos, lower, upper)\n+\n+\n+def report_slowest_diffs(file_infos):\n+    slowest = [file_info for file_info in file_infos if\n+               file_info['diff_time'] > 1.0]\n+    if len(slowest) == 0:\n+        return\n+    report(\"Slowest diffs:\\n\")\n+    for file_info in slowest:\n+        report(\"%6.02fs for %s\\n\" % (file_info['diff_time'],\n+                                     file_info['filename']))\n+\n+\n+def print_report(opts, elapsed_time, file_infos, in_scope_file_list,\n+                 full_file_list):\n+    pre_format_lines = sum(file_info['pre_format_lines'] for file_info in\n+                           file_infos)\n+    added_lines = sum(file_info['added_lines'] for file_info in file_infos)\n+    removed_lines = sum(file_info['removed_lines'] for file_info in file_infos)\n+    unchanged_lines = sum(file_info['unchanged_lines'] for file_info in\n+                          file_infos)\n+    post_format_lines = sum(file_info['post_format_lines'] for file_info in\n+                            file_infos)\n+    score = style_score(pre_format_lines, unchanged_lines, added_lines,\n+                        removed_lines)\n+    matching = [file_info for file_info in file_infos if\n+                file_info['matching']]\n+    not_matching = [file_info for file_info in file_infos if not\n+                    file_info['matching']]\n+    h = hashlib.md5()\n+    for file_info in file_infos:\n+        h.update(file_info['formatted_md5'].encode('utf-8'))\n+    formatted_md5 = h.hexdigest()\n+\n+    report(SEPARATOR)\n+    report_examined_files(file_infos, in_scope_file_list, full_file_list)\n+    report(SEPARATOR)\n+    report(\"clang-format bin:         %s\\n\" % opts.bin_path)\n+    report(\"clang-format version:     %s\\n\" % opts.bin_version)\n+    report(\"Using style in:           %s\\n\" % opts.style_file)\n+    report_if_parameters_unsupported(opts)\n+    report(SEPARATOR)\n+    report(\"Parallel jobs for diffs:   %d\\n\" % opts.jobs)\n+    report(\"Elapsed time:              %.02fs\\n\" % elapsed_time)\n+    report_slowest_diffs(file_infos)\n+    report(SEPARATOR)\n+    report(\"Files 100%% matching:       %8d\\n\" % len(matching))\n+    report(\"Files <100%% matching:      %8d\\n\" % len(not_matching))\n+    report(\"Formatted content MD5:      %s\\n\" % formatted_md5)\n+    report(SEPARATOR)\n+    report_files_in_ranges(file_infos)\n+    report(SEPARATOR)\n+    report(\"\\n\")\n+    report(scoreboard(score, pre_format_lines, added_lines, removed_lines,\n+                      unchanged_lines, post_format_lines))\n+    report(\"\\n\")\n+    report(SEPARATOR)\n+    flush_report()\n+\n+\n+def exec_report(opts):\n+    start_time = time.time()\n+    full_file_list = git_ls()\n+    in_scope_file_list = get_filenames_in_scope(full_file_list)\n+    file_infos = [gather_file_info(opts, filename) for filename in\n+                  in_scope_file_list if opts.target_regex.match(filename)]\n+    file_infos = Pool(opts.jobs).map(compute_diff_info, file_infos)\n+    print_report(opts, time.time() - start_time, file_infos,\n+                 in_scope_file_list, full_file_list)\n+\n+\n+###############################################################################\n+# 'check' subcommand execution\n+###############################################################################\n+\n+\n+def get_failures(file_infos):\n+    return [file_info for file_info in file_infos if not\n+            file_info['matching']]\n+\n+\n+def report_failure(failure):\n+    report(\"A code format issue was detected in \")\n+    red_report(\"%s\\n\" % failure['filename'])\n+    report(scoreboard(failure['score'], failure['pre_format_lines'],\n+                      failure['added_lines'], failure['removed_lines'],\n+                      failure['unchanged_lines'],\n+                      failure['post_format_lines']))\n+\n+\n+def print_check(opts, failures, file_infos, in_scope_file_list,\n+                full_file_list):\n+    report(SEPARATOR)\n+    report_examined_files(file_infos, in_scope_file_list, full_file_list)\n+    for failure in failures:\n+        report(SEPARATOR)\n+        report_failure(failure)\n+    report(SEPARATOR)\n+    if len(failures) == 0:\n+        green_report(\"No format issues found!\\n\")\n+    else:\n+        red_report(\"These files can be auto-formatted by running:\\n\")\n+        report(\"$ contrib/devtools/clang_format.py format [target \"\n+               \"[target ...]]\\n\")\n+    report(SEPARATOR)\n+    flush_report()\n+\n+\n+def exec_check(opts):\n+    full_file_list = git_ls()\n+    in_scope_file_list = get_filenames_in_scope(full_file_list)\n+    file_infos = [gather_file_info(opts, filename) for filename in\n+                  in_scope_file_list if opts.target_regex.match(filename)]\n+    exit_if_parameters_unsupported(opts)\n+    file_infos = Pool(opts.jobs).map(compute_diff_info, file_infos)\n+    failures = get_failures(file_infos)\n+    print_check(opts, failures, file_infos, in_scope_file_list, full_file_list)\n+    if len(failures) > 0:\n+        sys.exit(\"*** Format issues found!\")\n+\n+\n+###############################################################################\n+# 'format' subcommand execution\n+###############################################################################\n+\n+\n+def exec_format(opts):\n+    full_file_list = git_ls()\n+    in_scope_file_list = get_filenames_in_scope(full_file_list)\n+    file_infos = [gather_file_info(opts, filename) for filename in\n+                  in_scope_file_list if opts.target_regex.match(filename)]\n+    exit_if_parameters_unsupported(opts)\n+    failures = get_failures(file_infos)\n+    for failure in failures:\n+        write_file(failure['filename'], failure['formatted'])\n+\n+\n+###############################################################################\n+# parse version\n+###############################################################################\n+\n+\n+VERSION_REGEX = re.compile(\"version (?P<version>[0-9]\\.[0-9](\\.[0-9])?)\")\n+\n+\n+def get_clang_format_version(bin_path):\n+    p = subprocess.Popen([bin_path, '--version'], stdout=subprocess.PIPE)\n+    match = VERSION_REGEX.search(p.stdout.read().decode('utf-8'))\n+    if not match:\n+        return \"(unknown version)\"\n+    return match.group('version')\n+\n+\n+###############################################################################\n+# validate inputs\n+###############################################################################\n+\n+\n+def is_clang_format_executable(executable):\n+    return (executable.startswith('clang-format') and not\n+            executable.startswith('clang-format-diff'))\n+\n+\n+class PathAction(argparse.Action):\n+    def _path_exists(self, path):\n+        return os.path.exists(path)\n+\n+    def _assert_exists(self, path):\n+        if not self._path_exists(path):\n+            sys.exit(\"*** does not exist: %s\" % path)\n+\n+    def _assert_mode(self, path, flags):\n+        if not os.access(path, flags):\n+            sys.exit(\"*** %s does not have correct mode: %x\" % (path, flags))\n+\n+\n+class TargetsPathAction(PathAction):\n+    def _assert_in_git_repository(self, path):\n+        d = os.path.dirname(path) if os.path.isfile(path) else path\n+        cmd = 'git -C %s status' % d\n+        dn = open(os.devnull, 'w')\n+        if (subprocess.call(cmd.split(' '), stderr=dn, stdout=dn) != 0):\n+            sys.exit(\"*** %s is not a git repository\" % path)\n+\n+    def _has_dot_git_dir(self, path):\n+        return os.path.isdir(os.path.join(path, '.git/'))\n+\n+    def _get_repo_base_dir(self, path):\n+        self._assert_exists(path)\n+        self._assert_in_git_repository(path)\n+        if self._has_dot_git_dir(path):\n+            return path\n+\n+        def recurse_repo_base_dir(path):\n+            self._assert_in_git_repository(path)\n+            d = os.path.dirname(path)\n+            if self._has_dot_git_dir(d):\n+                return d\n+            return recurse_repo_base_dir(d)\n+\n+        return recurse_repo_base_dir(path)\n+\n+    def _assert_under_dir(self, target, repo_base_dir):\n+        if not target.startswith(repo_base_dir):\n+            sys.exit(\"*** %s is under repo other than %s\" % (target,\n+                                                             repo_base_dir))\n+\n+    def _compile_target_regex(self, repo_base_dir, targets):\n+        files = [target for target in targets if os.path.isfile(target)]\n+        wildcards = [os.path.join(target, '*') for target in targets if\n+                     os.path.isdir(target)]\n+        fnmatches = (files + wildcards)\n+        trimmed_fnmatches = [match.split(repo_base_dir + '/')[1] for match in\n+                             fnmatches]\n+        return re.compile('|'.join([fnmatch.translate(match)\n+                                    for match in trimmed_fnmatches]))\n+\n+    def __call__(self, parser, namespace, values, option_string=None):\n+        targets = [os.path.abspath(target) for target in values]\n+        repo_base_dir = self._get_repo_base_dir(targets[0])\n+        for target in targets:\n+            self._assert_exists(target)\n+            self._assert_under_dir(target, repo_base_dir)\n+            self._assert_mode(target, os.R_OK)\n+        namespace.repository = repo_base_dir\n+        namespace.target_regex = self._compile_target_regex(repo_base_dir,\n+                                                            targets)\n+\n+\n+class BinPathAction(PathAction):\n+    def _assert_is_clang_format(self, path):\n+        executable = os.path.basename(path)\n+        if not is_clang_format_executable(executable):\n+            sys.exit(\"*** %s is not a clang format binary.\" % path)\n+\n+    def __call__(self, parser, namespace, values, option_string=None):\n+        path = os.path.realpath(os.path.abspath(values))\n+        self._assert_exists(path)\n+        self._assert_mode(path, os.R_OK | os.X_OK)\n+        self._assert_is_clang_format(path)\n+        version = get_clang_format_version(path)\n+        namespace.bin_path = path\n+        namespace.bin_version = version\n+\n+\n+class StylePathAction(PathAction):\n+    def __call__(self, parser, namespace, values, option_string=None):\n+        path = os.path.abspath(values)\n+        self._assert_exists(path)\n+        self._assert_mode(path, os.R_OK)\n+\n+\n+###############################################################################\n+# find installed clang-format binary\n+###############################################################################\n+\n+\n+def get_clang_format_binaries():\n+    for path in os.environ[\"PATH\"].split(os.pathsep):\n+        for e in os.listdir(path):\n+            if is_clang_format_executable(e):\n+                bin_path = os.path.realpath(os.path.join(path, e))\n+                bin_version = get_clang_format_version(bin_path)\n+                yield {'bin_path': bin_path, 'bin_version': bin_version}\n+\n+\n+def locate_installed_binary():\n+    installed = list(get_clang_format_binaries())\n+    if len(installed) == 0:\n+        sys.exit(\"*** could not locate a clang-format executable.\")\n+    return max(installed, key=lambda v: v['bin_version'])\n+\n+\n+###############################################################################\n+# style file\n+###############################################################################\n+\n+\n+def locate_repo_style_file(repository):\n+    path = os.path.join(repository, 'src/.clang-format')\n+    if not os.path.exists(path):\n+        sys.exit(\"*** no style file at: %s\" % path)\n+    return path\n+\n+\n+def parse_style_file(style_file):\n+    # Python does not have a built-in yaml parser, so here is a hand-written\n+    # one that *seems* to minimally work for this purpose.\n+    contents = read_file(style_file)\n+    # remove spaces after colon\n+    many_spaces = re.compile(': +')\n+    spaces_removed = many_spaces.sub(':', contents)\n+    # split into a list of lines\n+    lines = [l for l in spaces_removed.split('\\n') if l != '']\n+    # split by the colon separator\n+    split = [l.split(':') for l in lines]\n+    # present as a dictionary\n+    return {item[0]: ''.join(item[1:]) for item in split}\n+\n+\n+###############################################################################\n+# UI\n+###############################################################################\n+\n+\n+if __name__ == \"__main__\":\n+    # parse arguments\n+    description = (\"A utility for invoking clang-format to observe the state \"\n+                   \"of C++ code formatting in the repository. It produces \"\n+                   \"reports of style metrics and also can apply formatting.\")\n+    parser = argparse.ArgumentParser(description=description)\n+    b_help = (\"The path to the clang-format binary to be used. \"\n+              \"(default=clang-format-[0-9]\\.[0-9] installed in PATH with the \"\n+              \"highest version number)\")\n+    parser.add_argument(\"-b\", \"--bin-path\", type=str,\n+                        action=BinPathAction, help=b_help)\n+    sf_help = (\"The path to the style file to be used. (default=The \"\n+               \"src/.clang_format file of the repository which holds the \"\n+               \"targets)\")\n+    parser.add_argument(\"-s\", \"--style-file\", type=str,\n+                        action=StylePathAction, help=sf_help)\n+    j_help = (\"Parallel jobs for computing diffs. (default=6)\")\n+    parser.add_argument(\"-j\", \"--jobs\", type=int, default=6, help=j_help)\n+    f_help = (\"Force proceeding with 'check' or 'format' if clang-format \"\n+              \"doesn't support all parameters in the style file. \"\n+              \"(default=False)\")\n+    parser.add_argument(\"-f\", \"--force\", action='store_true', help=f_help)\n+    s_help = (\"Selects the action to be taken. 'report' produces a report \"\n+              \"with analysis of the selected files taken as a group. 'check' \"\n+              \"validates that the selected files match the style and gives \"\n+              \"a per-file report and returns a non-zero bash status if there \"\n+              \"are any format issues discovered. 'format' applies the style \"\n+              \"formatting to the selected files.\")\n+    parser.add_argument(\"subcommand\", type=str,\n+                        choices=['report', 'check', 'format'], help=s_help)\n+    t_help = (\"A list of files and/or directories that select the subset of \"\n+              \"files for this action. If a directory is given as a target, \"\n+              \"all files contained in it and its subdirectories are \"\n+              \"recursively selected. All targets must be tracked in the same \"\n+              \"git repository clone. (default=The current directory)\")\n+    parser.add_argument(\"target\", type=str, action=TargetsPathAction,\n+                        nargs='*', default='.', help=t_help)\n+    opts = parser.parse_args()\n+\n+    # finish setting up parameters\n+    if not opts.bin_path:\n+        installed = locate_installed_binary()\n+        opts.bin_path = installed['bin_path']\n+        opts.bin_version = installed['bin_version']\n+    else:\n+        opts.bin_version = get_clang_format_version(opts.bin_path)\n+    if not opts.style_file:\n+        opts.style_file = locate_repo_style_file(opts.repository)\n+    opts.style_params = parse_style_file(opts.style_file)\n+    opts.unknown_style_params = []\n+\n+    # execute commands\n+    os.chdir(opts.repository)\n+    if opts.subcommand == 'report':\n+        exec_report(opts)\n+    elif opts.subcommand == 'check':\n+        exec_check(opts)\n+    else:\n+        exec_format(opts)"
      }
    ]
  }
]