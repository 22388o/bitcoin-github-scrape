[
  {
    "sha": "230f7a833d52dcaa6eaeab46fe0a56a6487c86d1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMzBmN2E4MzNkNTJkY2FhNmVhZWFiNDZmZTBhNTZhNjQ4N2M4NmQx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-19T11:29:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-19T11:29:41Z"
      },
      "message": "Remove unused ecwrapper code",
      "tree": {
        "sha": "549b40279a9839ff1662abf39842b68f990befd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/549b40279a9839ff1662abf39842b68f990befd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "271061242b0bf2fd0864ffc053f0435eb1dcf992",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/271061242b0bf2fd0864ffc053f0435eb1dcf992",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/271061242b0bf2fd0864ffc053f0435eb1dcf992"
      }
    ],
    "stats": {
      "total": 172,
      "additions": 0,
      "deletions": 172
    },
    "files": [
      {
        "sha": "68cdbf2eda863a066d6bc9dbff85c0c8c6d3b889",
        "filename": "src/ecwrapper.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 164,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1/src/ecwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1/src/ecwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.cpp?ref=230f7a833d52dcaa6eaeab46fe0a56a6487c86d1",
        "patch": "@@ -13,43 +13,6 @@\n \n namespace {\n \n-// Generate a private key from just the secret parameter\n-int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n-{\n-    int ok = 0;\n-    BN_CTX *ctx = NULL;\n-    EC_POINT *pub_key = NULL;\n-\n-    if (!eckey) return 0;\n-\n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n-\n-    if ((ctx = BN_CTX_new()) == NULL)\n-        goto err;\n-\n-    pub_key = EC_POINT_new(group);\n-\n-    if (pub_key == NULL)\n-        goto err;\n-\n-    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n-        goto err;\n-\n-    EC_KEY_set_private_key(eckey,priv_key);\n-    EC_KEY_set_public_key(eckey,pub_key);\n-\n-    ok = 1;\n-\n-err:\n-\n-    if (pub_key)\n-        EC_POINT_free(pub_key);\n-    if (ctx != NULL)\n-        BN_CTX_free(ctx);\n-\n-    return(ok);\n-}\n-\n // Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n // recid selects which key is recovered\n // if check is non-zero, additional checks are performed\n@@ -135,48 +98,6 @@ CECKey::~CECKey() {\n     EC_KEY_free(pkey);\n }\n \n-void CECKey::GetSecretBytes(unsigned char vch[32]) const {\n-    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n-    assert(bn);\n-    int nBytes = BN_num_bytes(bn);\n-    int n=BN_bn2bin(bn,&vch[32 - nBytes]);\n-    assert(n == nBytes);\n-    memset(vch, 0, 32 - nBytes);\n-}\n-\n-void CECKey::SetSecretBytes(const unsigned char vch[32]) {\n-    bool ret;\n-    BIGNUM bn;\n-    BN_init(&bn);\n-    ret = BN_bin2bn(vch, 32, &bn) != NULL;\n-    assert(ret);\n-    ret = EC_KEY_regenerate_key(pkey, &bn) != 0;\n-    assert(ret);\n-    BN_clear_free(&bn);\n-}\n-\n-int CECKey::GetPrivKeySize(bool fCompressed) {\n-    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-    return i2d_ECPrivateKey(pkey, NULL);\n-}\n-int CECKey::GetPrivKey(unsigned char* privkey, bool fCompressed) {\n-    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-    return i2d_ECPrivateKey(pkey, &privkey);\n-}\n-\n-bool CECKey::SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck) {\n-    if (d2i_ECPrivateKey(&pkey, &privkey, size)) {\n-        if(fSkipCheck)\n-            return true;\n-\n-        // d2i_ECPrivateKey returns true if parsing succeeds.\n-        // This doesn't necessarily mean the key is valid.\n-        if (EC_KEY_check_key(pkey))\n-            return true;\n-    }\n-    return false;\n-}\n-\n void CECKey::GetPubKey(std::vector<unsigned char> &pubkey, bool fCompressed) {\n     EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n     int nSize = i2o_ECPublicKey(pkey, NULL);\n@@ -193,71 +114,13 @@ bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size) {\n     return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n }\n \n-bool CECKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) {\n-    vchSig.clear();\n-    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-    if (sig == NULL)\n-        return false;\n-    BN_CTX *ctx = BN_CTX_new();\n-    BN_CTX_start(ctx);\n-    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n-    BIGNUM *order = BN_CTX_get(ctx);\n-    BIGNUM *halforder = BN_CTX_get(ctx);\n-    EC_GROUP_get_order(group, order, ctx);\n-    BN_rshift1(halforder, order);\n-    if (BN_cmp(sig->s, halforder) > 0) {\n-        // enforce low S values, by negating the value (modulo the order) if above order/2.\n-        BN_sub(sig->s, order, sig->s);\n-    }\n-    BN_CTX_end(ctx);\n-    BN_CTX_free(ctx);\n-    unsigned int nSize = ECDSA_size(pkey);\n-    vchSig.resize(nSize); // Make sure it is big enough\n-    unsigned char *pos = &vchSig[0];\n-    nSize = i2d_ECDSA_SIG(sig, &pos);\n-    ECDSA_SIG_free(sig);\n-    vchSig.resize(nSize); // Shrink to fit actual size\n-    return true;\n-}\n-\n bool CECKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n     // -1 = error, 0 = bad sig, 1 = good\n     if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n         return false;\n     return true;\n }\n \n-bool CECKey::SignCompact(const uint256 &hash, unsigned char *p64, int &rec) {\n-    bool fOk = false;\n-    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-    if (sig==NULL)\n-        return false;\n-    memset(p64, 0, 64);\n-    int nBitsR = BN_num_bits(sig->r);\n-    int nBitsS = BN_num_bits(sig->s);\n-    if (nBitsR <= 256 && nBitsS <= 256) {\n-        std::vector<unsigned char> pubkey;\n-        GetPubKey(pubkey, true);\n-        for (int i=0; i<4; i++) {\n-            CECKey keyRec;\n-            if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1) {\n-                std::vector<unsigned char> pubkeyRec;\n-                keyRec.GetPubKey(pubkeyRec, true);\n-                if (pubkeyRec == pubkey) {\n-                    rec = i;\n-                    fOk = true;\n-                    break;\n-                }\n-            }\n-        }\n-        assert(fOk);\n-        BN_bn2bin(sig->r,&p64[32-(nBitsR+7)/8]);\n-        BN_bn2bin(sig->s,&p64[64-(nBitsS+7)/8]);\n-    }\n-    ECDSA_SIG_free(sig);\n-    return fOk;\n-}\n-\n bool CECKey::Recover(const uint256 &hash, const unsigned char *p64, int rec)\n {\n     if (rec<0 || rec>=3)\n@@ -270,33 +133,6 @@ bool CECKey::Recover(const uint256 &hash, const unsigned char *p64, int rec)\n     return ret;\n }\n \n-bool CECKey::TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32], const unsigned char vchTweak[32])\n-{\n-    bool ret = true;\n-    BN_CTX *ctx = BN_CTX_new();\n-    BN_CTX_start(ctx);\n-    BIGNUM *bnSecret = BN_CTX_get(ctx);\n-    BIGNUM *bnTweak = BN_CTX_get(ctx);\n-    BIGNUM *bnOrder = BN_CTX_get(ctx);\n-    EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n-    BN_bin2bn(vchTweak, 32, bnTweak);\n-    if (BN_cmp(bnTweak, bnOrder) >= 0)\n-        ret = false; // extremely unlikely\n-    BN_bin2bn(vchSecretIn, 32, bnSecret);\n-    BN_add(bnSecret, bnSecret, bnTweak);\n-    BN_nnmod(bnSecret, bnSecret, bnOrder, ctx);\n-    if (BN_is_zero(bnSecret))\n-        ret = false; // ridiculously unlikely\n-    int nBits = BN_num_bits(bnSecret);\n-    memset(vchSecretOut, 0, 32);\n-    BN_bn2bin(bnSecret, &vchSecretOut[32-(nBits+7)/8]);\n-    EC_GROUP_free(group);\n-    BN_CTX_end(ctx);\n-    BN_CTX_free(ctx);\n-    return ret;\n-}\n-\n bool CECKey::TweakPublic(const unsigned char vchTweak[32]) {\n     bool ret = true;\n     BN_CTX *ctx = BN_CTX_new();"
      },
      {
        "sha": "30c3db79317fac945ebe388243908f3aece82a8b",
        "filename": "src/ecwrapper.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1/src/ecwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/230f7a833d52dcaa6eaeab46fe0a56a6487c86d1/src/ecwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.h?ref=230f7a833d52dcaa6eaeab46fe0a56a6487c86d1",
        "patch": "@@ -21,24 +21,16 @@ class CECKey {\n     CECKey();\n     ~CECKey();\n \n-    void GetSecretBytes(unsigned char vch[32]) const;\n-    void SetSecretBytes(const unsigned char vch[32]);\n-    int GetPrivKeySize(bool fCompressed);\n-    int GetPrivKey(unsigned char* privkey, bool fCompressed);\n-    bool SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck=false);\n     void GetPubKey(std::vector<unsigned char>& pubkey, bool fCompressed);\n     bool SetPubKey(const unsigned char* pubkey, size_t size);\n-    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig);\n     bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n-    bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec);\n \n     // reconstruct public key from a compact signature\n     // This is only slightly more CPU intensive than just verifying it.\n     // If this function succeeds, the recovered public key is guaranteed to be valid\n     // (the signature is a valid signature of the given data for that key)\n     bool Recover(const uint256 &hash, const unsigned char *p64, int rec);\n \n-    static bool TweakSecret(unsigned char vchSecretOut[32], const unsigned char vchSecretIn[32], const unsigned char vchTweak[32]);\n     bool TweakPublic(const unsigned char vchTweak[32]);\n     static bool SanityCheck();\n };"
      }
    ]
  }
]