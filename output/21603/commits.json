[
  {
    "sha": "56104710acf0295dee91f25915da6d2f513b7d00",
    "node_id": "C_kwDOABII59oAKDU2MTA0NzEwYWNmMDI5NWRlZTkxZjI1OTE1ZGE2ZDJmNTEzYjdkMDA",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-09-22T16:09:53Z"
      },
      "committer": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-10-05T18:32:22Z"
      },
      "message": "log: Mitigate disk filling attacks by rate limiting LogPrintf\n\nCo-authored-by: dergoegge <n.goeggi@gmail.com>",
      "tree": {
        "sha": "3930cdd8f22a2c827ce5533ce56cb1b665f61fa5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3930cdd8f22a2c827ce5533ce56cb1b665f61fa5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56104710acf0295dee91f25915da6d2f513b7d00",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56104710acf0295dee91f25915da6d2f513b7d00",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/56104710acf0295dee91f25915da6d2f513b7d00",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56104710acf0295dee91f25915da6d2f513b7d00/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "113b863f0773999497f952daa6539a03a66a9de3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/113b863f0773999497f952daa6539a03a66a9de3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/113b863f0773999497f952daa6539a03a66a9de3"
      }
    ],
    "stats": {
      "total": 177,
      "additions": 163,
      "deletions": 14
    },
    "files": [
      {
        "sha": "982ea17383262454687d68b8b43f35623178f2a6",
        "filename": "src/init/common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56104710acf0295dee91f25915da6d2f513b7d00/src/init/common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56104710acf0295dee91f25915da6d2f513b7d00/src/init/common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/common.cpp?ref=56104710acf0295dee91f25915da6d2f513b7d00",
        "patch": "@@ -76,6 +76,7 @@ void AddLoggingArgs(ArgsManager& argsman)\n     argsman.AddArg(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-printtoconsole\", \"Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-shrinkdebugfile\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-logratelimiting\", strprintf(\"Rate limit debug logging to disk (default: %u)\", DEFAULT_LOGRATELIMITING), ArgsManager::ALLOW_BOOL, OptionsCategory::OPTIONS);\n }\n \n void SetLoggingOptions(const ArgsManager& args)\n@@ -89,6 +90,7 @@ void SetLoggingOptions(const ArgsManager& args)\n     LogInstance().m_log_threadnames = args.GetBoolArg(\"-logthreadnames\", DEFAULT_LOGTHREADNAMES);\n #endif\n     LogInstance().m_log_sourcelocations = args.GetBoolArg(\"-logsourcelocations\", DEFAULT_LOGSOURCELOCATIONS);\n+    LogInstance().m_rate_limiting = args.GetBoolArg(\"-logratelimiting\", DEFAULT_LOGRATELIMITING);\n \n     fLogIPs = args.GetBoolArg(\"-logips\", DEFAULT_LOGIPS);\n }"
      },
      {
        "sha": "ab88d6760bbd09bb56cfd479bcb382b753a02467",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 3,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56104710acf0295dee91f25915da6d2f513b7d00/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56104710acf0295dee91f25915da6d2f513b7d00/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=56104710acf0295dee91f25915da6d2f513b7d00",
        "patch": "@@ -245,13 +245,86 @@ namespace BCLog {\n     }\n } // namespace BCLog\n \n-void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& logging_function, const std::string& source_file, const int source_line)\n+static constexpr uint64_t HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION{1024 * 1024};\n+\n+bool BCLog::Logger::RateLimit(std::string& str, const std::string& logging_function, const SourceLocation& source_location)\n+{\n+    if (!m_rate_limiting) {\n+        // Rate limiting is disabled.\n+        return false;\n+    }\n+\n+    const std::chrono::seconds now = GetTime<std::chrono::seconds>();\n+    QuotaUsage& quota_usage = m_quota_usage_per_source_location[source_location];\n+    // Is the quota exceeded before this log call?\n+    bool quota_exceeded_before = quota_usage.m_bytes_logged > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION;\n+\n+    bool dont_skip = false;\n+    // Every hour the quota usage for a source location is reset.\n+    if ((now - quota_usage.m_last_reset) > std::chrono::hours{1}) {\n+        // Should logging to disk continue to be disabled?\n+        bool quota_still_exceeded = quota_usage.m_bytes_dropped > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION;\n+\n+        if (quota_still_exceeded) {\n+            str = LogTimestampStr(strprintf(\n+                \"Not restarting logging from %s:%d (%s): \"\n+                \"because %d messages (%d MiB) were dropped during the last hour which still exceeds the limit of %d MiB.\\n\",\n+                source_location.m_file, source_location.m_line, logging_function, quota_usage.m_messages_dropped,\n+                quota_usage.m_bytes_dropped / (1024 * 1024), HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION / (1024 * 1024)));\n+        } else if (quota_exceeded_before) {\n+            str = LogTimestampStr(strprintf(\n+                \"Restarting logging from %s:%d (%s): \"\n+                \"%d messages (%d MiB) were dropped during the last hour.\\n\"\n+                \"%s\",\n+                source_location.m_file, source_location.m_line, logging_function, quota_usage.m_messages_dropped,\n+                quota_usage.m_bytes_dropped / (1024 * 1024), str));\n+            --m_rate_limited_locations;\n+        }\n+\n+        // Dont skip the reset logs.\n+        dont_skip = quota_exceeded_before || quota_still_exceeded;\n+\n+        // Logging to disk is only re-enabled if the number of dropped bytes did not exceed the limit.\n+        if (!quota_still_exceeded) quota_usage.m_bytes_logged = 0;\n+        quota_usage.m_messages_dropped = 0;\n+        quota_usage.m_bytes_dropped = 0;\n+        quota_usage.m_last_reset = now;\n+    }\n+\n+    if (!quota_exceeded_before) quota_usage.m_bytes_logged += str.size();\n+\n+    bool quota_exceeded_after = quota_usage.m_bytes_logged > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION;\n+    if (!quota_exceeded_after) {\n+        // The limits were not exceeded and the message should not be dropped.\n+        return false;\n+    }\n+\n+    if (!quota_exceeded_before) {\n+        str = LogTimestampStr(strprintf(\n+            \"Excessive logging detected from %s:%d (%s): \"\n+            \">%d MiB logged during the last hour. \"\n+            \"Suppressing logging to disk from this source location for up to one hour. \"\n+            \"Console logging unaffected. Last log entry: %s\",\n+            source_location.m_file, source_location.m_line, logging_function,\n+            HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION / (1024 * 1024), str));\n+        ++m_rate_limited_locations;\n+    } else if (!dont_skip) {\n+        // The log message should be dropped.\n+        quota_usage.m_messages_dropped++;\n+        quota_usage.m_bytes_dropped += str.size();\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n+void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& logging_function, const SourceLocation& source_location, const bool skip_disk_usage_rate_limiting)\n {\n     StdLockGuard scoped_lock(m_cs);\n     std::string str_prefixed = LogEscapeMessage(str);\n \n     if (m_log_sourcelocations && m_started_new_line) {\n-        str_prefixed.insert(0, \"[\" + RemovePrefix(source_file, \"./\") + \":\" + ToString(source_line) + \"] [\" + logging_function + \"] \");\n+        str_prefixed.insert(0, \"[\" + RemovePrefix(source_location.m_file, \"./\") + \":\" + ToString(source_location.m_line) + \"] [\" + logging_function + \"] \");\n     }\n \n     if (m_log_threadnames && m_started_new_line) {\n@@ -260,6 +333,16 @@ void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& loggi\n \n     str_prefixed = LogTimestampStr(str_prefixed);\n \n+    // Rate limit logging to disk to avoid disk filling attacks.\n+    bool log_quota_exceeded = !skip_disk_usage_rate_limiting &&\n+                              RateLimit(str_prefixed, logging_function, source_location);\n+\n+    // To avoid confusion caused by dropped log messages when debugging an issue, we prefix log lines with \"[*]\"\n+    // when there are any supressed source locations.\n+    if (m_rate_limited_locations > 0) {\n+        str_prefixed.insert(0, \"[*] \");\n+    }\n+\n     m_started_new_line = !str.empty() && str[str.size()-1] == '\\n';\n \n     if (m_buffering) {\n@@ -276,7 +359,7 @@ void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& loggi\n     for (const auto& cb : m_print_callbacks) {\n         cb(str_prefixed);\n     }\n-    if (m_print_to_file) {\n+    if (m_print_to_file && !log_quota_exceeded) {\n         assert(m_fileout != nullptr);\n \n         // reopen the log file, if requested"
      },
      {
        "sha": "6d3c9d52d5373c8657e5c9a4ae17816d126da433",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 74,
        "deletions": 10,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56104710acf0295dee91f25915da6d2f513b7d00/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56104710acf0295dee91f25915da6d2f513b7d00/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=56104710acf0295dee91f25915da6d2f513b7d00",
        "patch": "@@ -6,23 +6,29 @@\n #ifndef BITCOIN_LOGGING_H\n #define BITCOIN_LOGGING_H\n \n+#include <crypto/siphash.h>\n #include <fs.h>\n #include <tinyformat.h>\n #include <threadsafety.h>\n #include <util/string.h>\n \n #include <atomic>\n+#include <chrono>\n #include <cstdint>\n+#include <functional>\n #include <list>\n #include <mutex>\n #include <string>\n+#include <unordered_map>\n+#include <utility>\n #include <vector>\n \n static const bool DEFAULT_LOGTIMEMICROS = false;\n static const bool DEFAULT_LOGIPS        = false;\n static const bool DEFAULT_LOGTIMESTAMPS = true;\n static const bool DEFAULT_LOGTHREADNAMES = false;\n static const bool DEFAULT_LOGSOURCELOCATIONS = false;\n+static const bool DEFAULT_LOGRATELIMITING = true;\n extern const char * const DEFAULT_DEBUGLOGFILE;\n \n extern bool fLogIPs;\n@@ -32,6 +38,34 @@ struct LogCategory {\n     bool active;\n };\n \n+// Replace with std::source_location when switching to C++20.\n+struct SourceLocation {\n+    const char* m_file{nullptr};\n+    int m_line{0};\n+\n+    bool operator==(const SourceLocation& other) const\n+    {\n+        return m_file && other.m_file &&\n+               std::strcmp(m_file, other.m_file) == 0 &&\n+               m_line == other.m_line;\n+    }\n+};\n+\n+struct SourceLocationHasher {\n+    size_t operator()(const SourceLocation& source_location) const noexcept\n+    {\n+        // Use CSipHasher(0, 0) as a simple way to get uniform distribution.\n+        return static_cast<size_t>(CSipHasher(0, 0).Write(std::hash<const char*>{}(source_location.m_file)).Write(std::hash<int>{}(source_location.m_line)).Finalize());\n+    }\n+};\n+\n+struct QuotaUsage {\n+    uint64_t m_bytes_logged{0};\n+    uint64_t m_bytes_dropped{0};\n+    uint64_t m_messages_dropped{0};\n+    std::chrono::seconds m_last_reset{0};\n+};\n+\n namespace BCLog {\n     enum LogFlags : uint32_t {\n         NONE        = 0,\n@@ -72,6 +106,8 @@ namespace BCLog {\n         FILE* m_fileout GUARDED_BY(m_cs) = nullptr;\n         std::list<std::string> m_msgs_before_open GUARDED_BY(m_cs);\n         bool m_buffering GUARDED_BY(m_cs) = true; //!< Buffer messages before logging can be started.\n+        std::unordered_map<SourceLocation, QuotaUsage, SourceLocationHasher> m_quota_usage_per_source_location GUARDED_BY(m_cs);\n+        int m_rate_limited_locations GUARDED_BY(m_cs) = 0;\n \n         /**\n          * m_started_new_line is a state variable that will suppress printing of\n@@ -96,12 +132,25 @@ namespace BCLog {\n         bool m_log_time_micros = DEFAULT_LOGTIMEMICROS;\n         bool m_log_threadnames = DEFAULT_LOGTHREADNAMES;\n         bool m_log_sourcelocations = DEFAULT_LOGSOURCELOCATIONS;\n+        bool m_rate_limiting = DEFAULT_LOGRATELIMITING;\n \n         fs::path m_file_path;\n         std::atomic<bool> m_reopen_file{false};\n \n+        /** Evaluate if a log message should not be printed to disk.\n+         *\n+         * @param[in,out] str              The log message.\n+         *                                 The rate limiting logic message may change the message\n+         *                                 to signal the start or end of a supression period.\n+         * @param[in]     logging_function The function name from which the log message originated.\n+         * @param[in]     source_location  The source location from which the log message originated.\n+         *\n+         * @return true if the message should not be printed to disk, false otherwise.\n+         */\n+        bool RateLimit(std::string& str, const std::string& logging_function, const SourceLocation& source_location) EXCLUSIVE_LOCKS_REQUIRED(m_cs);\n+\n         /** Send a string to the log output */\n-        void LogPrintStr(const std::string& str, const std::string& logging_function, const std::string& source_file, const int source_line);\n+        void LogPrintStr(const std::string& str, const std::string& logging_function, const SourceLocation& source_location, const bool skip_disk_usage_rate_limiting);\n \n         /** Returns whether logs will be written to any output */\n         bool Enabled() const\n@@ -167,9 +216,11 @@ bool GetLogCategory(BCLog::LogFlags& flag, const std::string& str);\n // Be conservative when using LogPrintf/error or other things which\n // unconditionally log to debug.log! It should not be the case that an inbound\n // peer can fill up a user's disk with debug.log entries.\n-\n+//\n+// An attempt to mitigate disk filling attacks is made unless skip_disk_usage_rate_limiting\n+// is set to true.\n template <typename... Args>\n-static inline void LogPrintf_(const std::string& logging_function, const std::string& source_file, const int source_line, const char* fmt, const Args&... args)\n+static inline void LogPrintf_(const std::string& logging_function, const char* source_file, const int source_line, const bool skip_disk_usage_rate_limiting, const char* fmt, const Args&... args)\n {\n     if (LogInstance().Enabled()) {\n         std::string log_msg;\n@@ -179,19 +230,32 @@ static inline void LogPrintf_(const std::string& logging_function, const std::st\n             /* Original format string will have newline so don't add one here */\n             log_msg = \"Error \\\"\" + std::string(fmterr.what()) + \"\\\" while formatting log message: \" + fmt;\n         }\n-        LogInstance().LogPrintStr(log_msg, logging_function, source_file, source_line);\n+\n+        const SourceLocation source_location{source_file, source_line};\n+        LogInstance().LogPrintStr(log_msg, logging_function, source_location, skip_disk_usage_rate_limiting);\n     }\n }\n \n-#define LogPrintf(...) LogPrintf_(__func__, __FILE__, __LINE__, __VA_ARGS__)\n+// Unconditional logging. Uses basic rate limiting to mitigate disk filling attacks.\n+#define LogPrintf(...) LogPrintf_(__func__, __FILE__, __LINE__, /* skip_disk_usage_rate_limiting */ false, __VA_ARGS__)\n+\n+// Unconditional logging WITHOUT rate limiting. Use only for log messages that\n+// MUST NOT be rate limited no matter how often they are logged. That requirement\n+// should be extremely rare, so please use with care. Prefer LogPrintf(...) if\n+// possible.\n+#define LogPrintfWithoutRateLimiting(...) LogPrintf_(__func__, __FILE__, __LINE__, /* skip_disk_usage_rate_limiting */ true, __VA_ARGS__)\n \n // Use a macro instead of a function for conditional logging to prevent\n // evaluating arguments when logging for the category is not enabled.\n-#define LogPrint(category, ...)              \\\n-    do {                                     \\\n-        if (LogAcceptCategory((category))) { \\\n-            LogPrintf(__VA_ARGS__);          \\\n-        }                                    \\\n+//\n+// Note that conditional logging is performed WITHOUT rate limiting. Users\n+// specifying -debug are assumed to be developers or power users who are aware\n+// that -debug may cause excessive disk usage due to logging.\n+#define LogPrint(category, ...)                                                                              \\\n+    do {                                                                                                     \\\n+        if (LogAcceptCategory((category))) {                                                                 \\\n+            LogPrintf_(__func__, __FILE__, __LINE__, /* skip_disk_usage_rate_limiting */ true, __VA_ARGS__); \\\n+        }                                                                                                    \\\n     } while (0)\n \n #endif // BITCOIN_LOGGING_H"
      },
      {
        "sha": "f5fdd20ae7400d572adb7454cc37ba8f29dc9198",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56104710acf0295dee91f25915da6d2f513b7d00/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56104710acf0295dee91f25915da6d2f513b7d00/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=56104710acf0295dee91f25915da6d2f513b7d00",
        "patch": "@@ -2106,7 +2106,7 @@ static void UpdateTipLog(\n {\n \n     AssertLockHeld(::cs_main);\n-    LogPrintf(\"%s%s: new best=%s height=%d version=0x%08x log2_work=%f tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)%s\\n\",\n+    LogPrintfWithoutRateLimiting(\"%s%s: new best=%s height=%d version=0x%08x log2_work=%f tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)%s\\n\",\n         prefix, func_name,\n         tip->GetBlockHash().ToString(), tip->nHeight, tip->nVersion,\n         log(tip->nChainWork.getdouble()) / log(2.0), (unsigned long)tip->nChainTx,"
      }
    ]
  },
  {
    "sha": "9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7",
    "node_id": "C_kwDOABII59oAKDliNThjNDhlOWZkOTlmOWQ4NGI2YjhlZmY3MWIwMjAzNDY4ZjFlYTc",
    "commit": {
      "author": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-06-17T22:27:46Z"
      },
      "committer": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-10-05T18:32:24Z"
      },
      "message": "test: Add logging test for rate limiting",
      "tree": {
        "sha": "d14666ba87324bc293f3c336c7a2456e47e428e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d14666ba87324bc293f3c336c7a2456e47e428e0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7/comments",
    "author": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56104710acf0295dee91f25915da6d2f513b7d00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56104710acf0295dee91f25915da6d2f513b7d00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56104710acf0295dee91f25915da6d2f513b7d00"
      }
    ],
    "stats": {
      "total": 113,
      "additions": 113,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a51bba3ce68bb8f397b035aafd9b6cfeedd4a576",
        "filename": "src/test/logging_tests.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7/src/test/logging_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7/src/test/logging_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logging_tests.cpp?ref=9b58c48e9fd99f9d84b6b8eff71b0203468f1ea7",
        "patch": "@@ -30,4 +30,117 @@ BOOST_AUTO_TEST_CASE(logging_timer)\n     BOOST_CHECK_EQUAL(sec_timer.LogMsg(\"test secs\"), \"tests: test secs (1.00s)\");\n }\n \n+size_t GetLogFileSize()\n+{\n+    boost::system::error_code ec;\n+    size_t size = fs::file_size(LogInstance().m_file_path, ec);\n+    if (ec) LogPrintf(\"%s: %s %s\\n\", __func__, ec.message(), LogInstance().m_file_path);\n+    BOOST_CHECK(!ec);\n+    return size;\n+}\n+\n+void LogFromFixedLocation(const std::string& str)\n+{\n+    LogPrintf(\"%s\\n\", str);\n+}\n+\n+BOOST_AUTO_TEST_CASE(rate_limiting)\n+{\n+#if defined(_WIN32)\n+    // TODO\n+    // Since windows prints \\r\\n to file instead of \\n, the log file size\n+    // does not match up with the internal \"bytes logged\" count.\n+    // This test relies on matching file sizes with expected values.\n+    return;\n+#endif\n+\n+    // This allows us to check for exact size differences in the log file.\n+    bool prev_log_timestamps = LogInstance().m_log_sourcelocations;\n+    LogInstance().m_log_timestamps = false;\n+    bool prev_log_sourcelocations = LogInstance().m_log_sourcelocations;\n+    LogInstance().m_log_sourcelocations = false;\n+    bool prev_log_threadnames = LogInstance().m_log_threadnames;\n+    LogInstance().m_log_threadnames = false;\n+\n+    // Log 1024-character lines (1023 plus newline) to make the math simple.\n+    std::string log_message(1023, 'a');\n+\n+    SetMockTime(std::chrono::seconds{1});\n+\n+    size_t prev_log_file_size, curr_log_file_size;\n+    prev_log_file_size = GetLogFileSize();\n+\n+    // Log 1 MiB, this should be allowed.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 1024 * 1024);\n+\n+    LogFromFixedLocation(\"This should trigger rate limiting\");\n+    prev_log_file_size = GetLogFileSize();\n+\n+    // Log 0.5 MiB, this should not be allowed and all messages should be dropped.\n+    for (int i = 0; i < 512; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 0);\n+\n+    // Let one hour pass.\n+    SetMockTime(std::chrono::seconds{60 * 60 + 1});\n+    LogFromFixedLocation(\"This should trigger the quota usage reset\");\n+    prev_log_file_size = GetLogFileSize();\n+\n+    // Log 1 MiB, this should be allowed since the usage was reset.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 1024 * 1024);\n+\n+    LogFromFixedLocation(\"This should trigger rate limiting\");\n+    prev_log_file_size = GetLogFileSize();\n+\n+    // Log 1 MiB, this should not be allowed and all messages should be dropped.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 0);\n+\n+    LogFromFixedLocation(\"This should also be dropped and bring the total of dropped bytes above 1 MiB.\");\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 0);\n+\n+    // Let another hour pass\n+    SetMockTime(std::chrono::seconds{2 * (60 * 60 + 1)});\n+    LogFromFixedLocation(\"Normally this would reset the usage but it does not because we dropped more than 1 MiB in the previous hour.\");\n+    prev_log_file_size = GetLogFileSize();\n+\n+    // Log 1 MiB, this should not be allowed and all messages should be dropped.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 0);\n+\n+    // Let another hour pass\n+    SetMockTime(std::chrono::seconds{3 * (60 * 60 + 1)});\n+    LogFromFixedLocation(\"This should trigger the quota usage reset\");\n+    prev_log_file_size = GetLogFileSize();\n+\n+    // Log 1 MiB, this should be allowed since the usage was reset.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    curr_log_file_size = GetLogFileSize();\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 1024 * 1024);\n+\n+    LogInstance().m_log_timestamps = prev_log_timestamps;\n+    LogInstance().m_log_sourcelocations = prev_log_sourcelocations;\n+    LogInstance().m_log_threadnames = prev_log_threadnames;\n+    SetMockTime(std::chrono::seconds{0});\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]