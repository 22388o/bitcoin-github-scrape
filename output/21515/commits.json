[
  {
    "sha": "b0ce493386a1ef03dfc409ca578ac2b75225f681",
    "node_id": "C_kwDOABII59oAKGIwY2U0OTMzODZhMWVmMDNkZmM0MDljYTU3OGFjMmI3NTIyNWY2ODE",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-19T11:03:25Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "p2p: Announce reconciliation support\n\nIf we're connecting to the peer which might support\ntransaction reconciliation, we announce we want to reconcile\nwith them.\n\nWe store the reconciliation salt so that when the peer\nresponds with their salt, we are able to compute the\nfull reconciliation salt.",
      "tree": {
        "sha": "0269a1b181c382f3189333f69c088048f046a822",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0269a1b181c382f3189333f69c088048f046a822"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0ce493386a1ef03dfc409ca578ac2b75225f681",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0ce493386a1ef03dfc409ca578ac2b75225f681",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0ce493386a1ef03dfc409ca578ac2b75225f681",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0ce493386a1ef03dfc409ca578ac2b75225f681/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d94dc69ee454144f4db12d163b15717cc6cad383",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d94dc69ee454144f4db12d163b15717cc6cad383",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d94dc69ee454144f4db12d163b15717cc6cad383"
      }
    ],
    "stats": {
      "total": 148,
      "additions": 148,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9fe49fd3dc0dc3b4097952656258f0f649849b19",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "patch": "@@ -230,6 +230,7 @@ BITCOIN_CORE_H = \\\n   txdb.h \\\n   txmempool.h \\\n   txorphanage.h \\\n+  txreconciliation.h \\\n   txrequest.h \\\n   undo.h \\\n   util/asmap.h \\\n@@ -367,6 +368,7 @@ libbitcoin_server_a_SOURCES = \\\n   txdb.cpp \\\n   txmempool.cpp \\\n   txorphanage.cpp \\\n+  txreconciliation.cpp \\\n   txrequest.cpp \\\n   validation.cpp \\\n   validationinterface.cpp \\"
      },
      {
        "sha": "7713b87d20a5bb60ce1b315d386f99ca4b4dbfdb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "patch": "@@ -31,6 +31,7 @@\n #include <tinyformat.h>\n #include <txmempool.h>\n #include <txorphanage.h>\n+#include <txreconciliation.h>\n #include <txrequest.h>\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n@@ -416,6 +417,7 @@ class PeerManagerImpl final : public PeerManager\n     ChainstateManager& m_chainman;\n     CTxMemPool& m_mempool;\n     TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n+    TxReconciliationTracker m_reconciliation;\n \n     /** The height of the best chain */\n     std::atomic<int> m_best_height{-1};\n@@ -2574,6 +2576,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         if (greatest_common_version >= WTXID_RELAY_VERSION) {\n             m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::WTXIDRELAY));\n+\n+            // Reconciliation is supported only when wtxid relay is supported for only\n+            // those connections which (at least might) support transaction relay.\n+            if (pfrom.m_tx_relay) {\n+                const auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] =\n+                    m_reconciliation.PreRegisterPeer(pfrom.GetId(), pfrom.IsInboundConn());\n+                m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::SENDRECON,\n+                    we_initiate_recon, we_respond_recon, recon_version, recon_salt));\n+            }\n         }\n \n         // Signal ADDRv2 support (BIP155)."
      },
      {
        "sha": "969205b6a79338764ad77f965f486f639160591f",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "patch": "@@ -44,6 +44,7 @@ const char *CFHEADERS=\"cfheaders\";\n const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n+const char *SENDRECON=\"sendrecon\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -84,6 +85,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::GETCFCHECKPT,\n     NetMsgType::CFCHECKPT,\n     NetMsgType::WTXIDRELAY,\n+    NetMsgType::SENDRECON,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "cb00d345b23edade41f60a842f0bddec2b9eb886",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "patch": "@@ -262,6 +262,13 @@ extern const char* CFCHECKPT;\n  * @since protocol version 70016 as described by BIP 339.\n  */\n extern const char* WTXIDRELAY;\n+/**\n+ * Contains 2 1-byte bools, a 4-byte version number and an 8-byte salt.\n+ * Indicates that a node is willing to participate in transaction reconciliation,\n+ * either as a sender or a receiver.\n+ * The salt is used to compute short txids needed for efficient reconciliation.\n+ */\n+extern const char *SENDRECON;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "16d3da52e27f8bd921512c7655309a3064a7dd63",
        "filename": "src/txreconciliation.cpp",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "patch": "@@ -0,0 +1,64 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (peer_inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Pre-register peer=%d for reconciling.\\n\", peer_id);\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+};\n+\n+TxReconciliationTracker::TxReconciliationTracker() :\n+    m_impl{std::make_unique<TxReconciliationTracker::Impl>()} {}\n+\n+TxReconciliationTracker::~TxReconciliationTracker() = default;\n+\n+std::tuple<bool, bool, uint32_t, uint64_t>TxReconciliationTracker::PreRegisterPeer(NodeId peer_id, bool peer_inbound)\n+{\n+    return m_impl->PreRegisterPeer(peer_id, peer_inbound);\n+}"
      },
      {
        "sha": "38ceaf0ca4771666cf529b11626048276a06e5d6",
        "filename": "src/txreconciliation.h",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0ce493386a1ef03dfc409ca578ac2b75225f681/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "patch": "@@ -0,0 +1,62 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer and announces all transactions from the\n+ *    corresponding set. Once the peer received the failure notification, the peer announces all\n+ *    transactions from the corresponding set.\n+ *\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+    public:\n+\n+    explicit TxReconciliationTracker();\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state required to reconcile with the peer.\n+     * Returns the following values used to invite the peer to reconcile:\n+     * - whether we want to initiate reconciliation requests\n+     * - whether we agree to respond to reconciliation requests\n+     * - reconciliation protocol version\n+     * - salt used for short ID computation required for reconciliation\n+     * Reconciliation roles depend on whether the peer is inbound or outbound in this connection.\n+     * A peer can't participate in future reconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound);\n+};\n+\n+#endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "c19e7a1c9d061413573ff749dcdc19ecd62c8115",
    "node_id": "C_kwDOABII59oAKGMxOWU3YTFjOWQwNjE0MTM1NzNmZjc0OWRjZGMxOWVjZDYyYzgxMTU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T10:50:02Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "p2p: Forget peer's reconciliation state on disconnect",
      "tree": {
        "sha": "5e03e3c0e489df8a9096e9f5f3b6b7309ed21f51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e03e3c0e489df8a9096e9f5f3b6b7309ed21f51"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c19e7a1c9d061413573ff749dcdc19ecd62c8115",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c19e7a1c9d061413573ff749dcdc19ecd62c8115",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c19e7a1c9d061413573ff749dcdc19ecd62c8115",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c19e7a1c9d061413573ff749dcdc19ecd62c8115/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0ce493386a1ef03dfc409ca578ac2b75225f681",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0ce493386a1ef03dfc409ca578ac2b75225f681"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 23,
      "deletions": 0
    },
    "files": [
      {
        "sha": "feacbff18785e6d17c7c59a31dceef2eea4572d2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c19e7a1c9d061413573ff749dcdc19ecd62c8115/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c19e7a1c9d061413573ff749dcdc19ecd62c8115/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c19e7a1c9d061413573ff749dcdc19ecd62c8115",
        "patch": "@@ -1220,6 +1220,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n     }\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n+    m_reconciliation.ForgetPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n     m_peers_downloading_from -= (state->nBlocksInFlight != 0);\n     assert(m_peers_downloading_from >= 0);"
      },
      {
        "sha": "bd3285d3e9d6ca7ff52b3c0afc38a4f71d0508bc",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c19e7a1c9d061413573ff749dcdc19ecd62c8115/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c19e7a1c9d061413573ff749dcdc19ecd62c8115/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=c19e7a1c9d061413573ff749dcdc19ecd62c8115",
        "patch": "@@ -51,6 +51,15 @@ class TxReconciliationTracker::Impl {\n         LogPrint(BCLog::NET, \"Pre-register peer=%d for reconciling.\\n\", peer_id);\n         return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n     }\n+\n+    void ForgetPeer(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        if (m_local_salts.erase(peer_id)) {\n+            LogPrint(BCLog::NET, \"Forget reconciliation state of peer=%d.\\n\", peer_id);\n+        }\n+    }\n+\n };\n \n TxReconciliationTracker::TxReconciliationTracker() :\n@@ -62,3 +71,8 @@ std::tuple<bool, bool, uint32_t, uint64_t>TxReconciliationTracker::PreRegisterPe\n {\n     return m_impl->PreRegisterPeer(peer_id, peer_inbound);\n }\n+\n+void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n+{\n+    m_impl->ForgetPeer(peer_id);\n+}"
      },
      {
        "sha": "3bce10bd19c0fa2f1a3b85431503d0610042818d",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c19e7a1c9d061413573ff749dcdc19ecd62c8115/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c19e7a1c9d061413573ff749dcdc19ecd62c8115/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=c19e7a1c9d061413573ff749dcdc19ecd62c8115",
        "patch": "@@ -57,6 +57,14 @@ class TxReconciliationTracker {\n      * This function must be called only once per peer.\n      */\n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound);\n+\n+    // Helpers\n+\n+    /**\n+     * Attempts to forget reconciliation-related state of the peer (if we previously stored any).\n+     * After this, we won't be able to reconcile with the peer.\n+     */\n+    void ForgetPeer(NodeId peer_id);\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
    "node_id": "C_kwDOABII59oAKGZkYmYzN2JmNDBkOTcwZDQyYTZmODU4ZTI0N2FiNGFlOWY1N2UwZjg",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-19T11:07:15Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to compute reconciliation salt\n\nTransaction reconciliation assumes exchanging sketches\nrepresenting transactions a peer wants to announce.\nTransactions are included in sketches based on their short ID,\ncomputed by hashing with the use of the salt.\n\nThe salt is computed from contributions by both peers.",
      "tree": {
        "sha": "5dd9e17b773cc17802a5d0f2c1e977dae2923bad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5dd9e17b773cc17802a5d0f2c1e977dae2923bad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c19e7a1c9d061413573ff749dcdc19ecd62c8115",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c19e7a1c9d061413573ff749dcdc19ecd62c8115",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c19e7a1c9d061413573ff749dcdc19ecd62c8115"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 17,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e610e16ad3600385dda811a5876aec1fceecf11e",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
        "patch": "@@ -10,6 +10,23 @@ namespace {\n \n /** Current protocol version */\n constexpr uint32_t RECON_VERSION = 1;\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+static uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    // Accoring to BIP-330, salts should be combined in ascending order.\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n \n } // namespace\n "
      }
    ]
  },
  {
    "sha": "6c402ce30551ea769e45a87586578d0250eab658",
    "node_id": "C_kwDOABII59oAKDZjNDAyY2UzMDU1MWVhNzY5ZTQ1YTg3NTg2NTc4ZDAyNTBlYWI2NTg",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-19T12:00:27Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "p2p: Finish negotiating reconciliation support\n\nOnce we received a reconciliation announcement support\nmessage from a peer and it doesn't violate our protocol,\nwe store the negotiated parameters which will be used\nfor future reconciliations.",
      "tree": {
        "sha": "250178b3d69b952cf92f7ccb103f5a39c33ceb48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/250178b3d69b952cf92f7ccb103f5a39c33ceb48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c402ce30551ea769e45a87586578d0250eab658",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c402ce30551ea769e45a87586578d0250eab658",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6c402ce30551ea769e45a87586578d0250eab658",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c402ce30551ea769e45a87586578d0250eab658/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fdbf37bf40d970d42a6f858e247ab4ae9f57e0f8"
      }
    ],
    "stats": {
      "total": 136,
      "additions": 135,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9c999e247141e51f420e6122adb40b584c23daa8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c402ce30551ea769e45a87586578d0250eab658/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c402ce30551ea769e45a87586578d0250eab658/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6c402ce30551ea769e45a87586578d0250eab658",
        "patch": "@@ -2822,6 +2822,48 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        if (!m_reconciliation.RegisterPeer(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt)) {\n+                LogPrint(BCLog::NET, \"reconciliation protocol violation from peer=%d; disconnecting\\n\", pfrom.GetId());\n+                pfrom.fDisconnect = true;\n+                return;\n+            }\n+        return;\n+    }\n+\n     if (!pfrom.fSuccessfullyConnected) {\n         LogPrint(BCLog::NET, \"Unsupported message \\\"%s\\\" prior to verack from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n         return;"
      },
      {
        "sha": "edd4daf092caca4b9e4545285563deb6d3ed6220",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 1,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c402ce30551ea769e45a87586578d0250eab658/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c402ce30551ea769e45a87586578d0250eab658/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=6c402ce30551ea769e45a87586578d0250eab658",
        "patch": "@@ -28,6 +28,32 @@ static uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n     return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n }\n \n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    [[maybe_unused]] const uint64_t m_k0, m_k1;\n+\n+    public:\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+};\n+\n } // namespace\n \n /** Actual implementation for TxReconciliationTracker's data structure. */\n@@ -44,6 +70,11 @@ class TxReconciliationTracker::Impl {\n      */\n     std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n \n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n     public:\n \n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound)\n@@ -69,10 +100,56 @@ class TxReconciliationTracker::Impl {\n         return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n     }\n \n+    bool RegisterPeer(NodeId peer_id, bool peer_inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt)\n+    {\n+        // We do not support reconciliation salt/version updates. We treat an attempt to update\n+        // after a successful registration as a protocol violation.\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return false;\n+\n+        // If the peer supports the version which is lower than our, we downgrade to the version\n+        // they support. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return false;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if (local_salt == m_local_salts.end()) return false;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !peer_inbound, we_may_respond = peer_inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return false;\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciling with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i.\\n\", peer_id, we_initiate, they_initiate);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        assert(m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate)).second);\n+        return true;\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n-        if (m_local_salts.erase(peer_id)) {\n+        auto salt_erased = m_local_salts.erase(peer_id);\n+        auto state_erased = m_states.erase(peer_id);\n+        if (salt_erased || state_erased) {\n             LogPrint(BCLog::NET, \"Forget reconciliation state of peer=%d.\\n\", peer_id);\n         }\n     }\n@@ -89,6 +166,13 @@ std::tuple<bool, bool, uint32_t, uint64_t>TxReconciliationTracker::PreRegisterPe\n     return m_impl->PreRegisterPeer(peer_id, peer_inbound);\n }\n \n+bool TxReconciliationTracker::RegisterPeer(NodeId peer_id, bool peer_inbound,\n+    bool recon_requestor, bool recon_responder, uint32_t recon_version, uint64_t remote_salt)\n+{\n+    return m_impl->RegisterPeer(peer_id, peer_inbound, recon_requestor, recon_responder,\n+        recon_version, remote_salt);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "1c66f39831c795df483a6d467595d08a10988a80",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c402ce30551ea769e45a87586578d0250eab658/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c402ce30551ea769e45a87586578d0250eab658/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=6c402ce30551ea769e45a87586578d0250eab658",
        "patch": "@@ -58,6 +58,14 @@ class TxReconciliationTracker {\n      */\n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound);\n \n+    /**\n+     * Step 0. Once the peer agreed to reconcile with us, generate the state required to track\n+     * ongoing reconciliations. Should be called only after pre-registering the peer and only once.\n+     * Does nothing and returns false if the peer violates the protocol.\n+     */\n+    bool RegisterPeer(NodeId peer_id, bool peer_inbound,\n+        bool recon_requestor, bool recon_responder, uint32_t recon_version, uint64_t remote_salt);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "fe781d6274ad078bacf59746c30caabd291326e5",
    "node_id": "C_kwDOABII59oAKGZlNzgxZDYyNzRhZDA3OGJhY2Y1OTc0NmMzMGNhYWJkMjkxMzI2ZTU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T10:26:41Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to see if a peer is registered for reconciliations",
      "tree": {
        "sha": "10670f665a8ef6a210648183f1a19547dbd491af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10670f665a8ef6a210648183f1a19547dbd491af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fe781d6274ad078bacf59746c30caabd291326e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe781d6274ad078bacf59746c30caabd291326e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fe781d6274ad078bacf59746c30caabd291326e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe781d6274ad078bacf59746c30caabd291326e5/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6c402ce30551ea769e45a87586578d0250eab658",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c402ce30551ea769e45a87586578d0250eab658",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6c402ce30551ea769e45a87586578d0250eab658"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 18,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6d1ae10cf6ed836dc99d38b3fc3c7fbeba08ba2d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe781d6274ad078bacf59746c30caabd291326e5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe781d6274ad078bacf59746c30caabd291326e5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fe781d6274ad078bacf59746c30caabd291326e5",
        "patch": "@@ -1220,6 +1220,9 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n     }\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n+    // Do not check whether peer is registered for reconciliation here, but rather delegate checks\n+    // to the module. Otherwise it's easy to skip deleting an intermediate state (e.g., we store\n+    // salt for peers before we register them for reconciliation).\n     m_reconciliation.ForgetPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n     m_peers_downloading_from -= (state->nBlocksInFlight != 0);"
      },
      {
        "sha": "f821f24de9b20ac463fa3f1eef8f1a51e3ba4234",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe781d6274ad078bacf59746c30caabd291326e5/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe781d6274ad078bacf59746c30caabd291326e5/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=fe781d6274ad078bacf59746c30caabd291326e5",
        "patch": "@@ -154,6 +154,11 @@ class TxReconciliationTracker::Impl {\n         }\n     }\n \n+    bool IsPeerRegistered(NodeId peer_id) const\n+    {\n+        LOCK(m_mutex);\n+        return m_states.find(peer_id) != m_states.end();\n+    }\n };\n \n TxReconciliationTracker::TxReconciliationTracker() :\n@@ -177,3 +182,8 @@ void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);\n }\n+\n+bool TxReconciliationTracker::IsPeerRegistered(NodeId peer_id) const\n+{\n+    return m_impl->IsPeerRegistered(peer_id);\n+}"
      },
      {
        "sha": "1171148132cfff71b3a819ca28ce134bb7265218",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe781d6274ad078bacf59746c30caabd291326e5/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe781d6274ad078bacf59746c30caabd291326e5/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=fe781d6274ad078bacf59746c30caabd291326e5",
        "patch": "@@ -73,6 +73,11 @@ class TxReconciliationTracker {\n      * After this, we won't be able to reconcile with the peer.\n      */\n     void ForgetPeer(NodeId peer_id);\n+\n+    /**\n+     * Check if a peer is registered to reconcile with us.\n+     */\n+    bool IsPeerRegistered(NodeId peer_id) const;\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "e01537012cb7452158212c03fdf253a347b061bd",
    "node_id": "C_kwDOABII59oAKGUwMTUzNzAxMmNiNzQ1MjE1ODIxMmMwM2ZkZjI1M2EzNDdiMDYxYmQ",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-05T08:40:55Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "test: Add unit tests for reconciliation negotiation",
      "tree": {
        "sha": "9724207f59b034751b5517ba789eefadb3d74218",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9724207f59b034751b5517ba789eefadb3d74218"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e01537012cb7452158212c03fdf253a347b061bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e01537012cb7452158212c03fdf253a347b061bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e01537012cb7452158212c03fdf253a347b061bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e01537012cb7452158212c03fdf253a347b061bd/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fe781d6274ad078bacf59746c30caabd291326e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe781d6274ad078bacf59746c30caabd291326e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe781d6274ad078bacf59746c30caabd291326e5"
      }
    ],
    "stats": {
      "total": 96,
      "additions": 96,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6251cb5f33ffc52b48b9cb265b45676962487b95",
        "filename": "src/test/txreconciliation_tests.cpp",
        "status": "added",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e01537012cb7452158212c03fdf253a347b061bd/src/test/txreconciliation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e01537012cb7452158212c03fdf253a347b061bd/src/test/txreconciliation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txreconciliation_tests.cpp?ref=e01537012cb7452158212c03fdf253a347b061bd",
        "patch": "@@ -0,0 +1,96 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(PreRegisterPeerTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.PreRegisterPeer(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+    assert(recon_version == 1); // RECON_VERSION in src/txreconciliation.cpp\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.PreRegisterPeer(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(RegisterPeerTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    // Prepare a peer for reconciliation.\n+    tracker.PreRegisterPeer(0, true);\n+\n+    // Both roles are false, don't register.\n+    assert(!tracker.RegisterPeer(0, true, false, false, 1, salt));\n+\n+    // Invalid roles for the given connection direction.\n+    assert(!tracker.RegisterPeer(0, true, false, true, 1, salt));\n+    assert(!tracker.RegisterPeer(0, false, true, false, 1, salt));\n+\n+    // Invalid version.\n+    assert(!tracker.RegisterPeer(0, true, true, false, 0, salt));\n+\n+    // Valid registration.\n+    assert(!tracker.IsPeerRegistered(0));\n+    assert(tracker.RegisterPeer(0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(0));\n+\n+    // Reconciliation version is higher than ours, should be able to register.\n+    assert(!tracker.IsPeerRegistered(1));\n+    tracker.PreRegisterPeer(1, true);\n+    assert(tracker.RegisterPeer(1, true, true, false, 2, salt));\n+    assert(tracker.IsPeerRegistered(1));\n+\n+    // Do not register if there were no pre-registration for the peer.\n+    assert(!tracker.RegisterPeer(100, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(100));\n+}\n+\n+BOOST_AUTO_TEST_CASE(ForgetPeerTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+\n+    // Removing peer after pre-registring works and does not let to register the peer.\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    tracker.ForgetPeer(peer_id0);\n+    assert(!tracker.RegisterPeer(peer_id0, true, true, false, 1, 1));\n+\n+    // Removing peer after it is registered works.\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    tracker.RegisterPeer(peer_id0, true, true, false, 1, 1);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+    tracker.ForgetPeer(peer_id0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+}\n+\n+BOOST_AUTO_TEST_CASE(IsPeerRegisteredTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+\n+    assert(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    tracker.ForgetPeer(peer_id0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()\n\\ No newline at end of file"
      }
    ]
  },
  {
    "sha": "7e5eab8bba04063e2e051fb115f57c9660aa6eea",
    "node_id": "C_kwDOABII59oAKDdlNWVhYjhiYmEwNDA2M2UyZTA1MWZiMTE1ZjU3Yzk2NjBhYTZlZWE",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:17:16Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to store transactions in recon set",
      "tree": {
        "sha": "33b917d4f752218aaa803345ddbbedbc4d08fa89",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33b917d4f752218aaa803345ddbbedbc4d08fa89"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e5eab8bba04063e2e051fb115f57c9660aa6eea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e5eab8bba04063e2e051fb115f57c9660aa6eea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e5eab8bba04063e2e051fb115f57c9660aa6eea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e5eab8bba04063e2e051fb115f57c9660aa6eea/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e01537012cb7452158212c03fdf253a347b061bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e01537012cb7452158212c03fdf253a347b061bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e01537012cb7452158212c03fdf253a347b061bd"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 53,
      "deletions": 0
    },
    "files": [
      {
        "sha": "87201f303a49e112bc17bcc7428c1bfa7db9dea4",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e5eab8bba04063e2e051fb115f57c9660aa6eea/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e5eab8bba04063e2e051fb115f57c9660aa6eea/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=7e5eab8bba04063e2e051fb115f57c9660aa6eea",
        "patch": "@@ -28,6 +28,22 @@ static uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n     return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n }\n \n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+    }\n+\n+};\n+\n+\n /**\n  * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n  * peer when next transaction reconciliation happens, and also all parameters required to perform\n@@ -50,6 +66,14 @@ class ReconciliationState {\n      * */\n     const bool m_we_initiate;\n \n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n     ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n         m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n };\n@@ -144,6 +168,24 @@ class TxReconciliationTracker::Impl {\n         return true;\n     }\n \n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state->second.m_local_set.m_wtxids.size());\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -178,6 +220,11 @@ bool TxReconciliationTracker::RegisterPeer(NodeId peer_id, bool peer_inbound,\n         recon_version, remote_salt);\n }\n \n+void TxReconciliationTracker::AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+{\n+    m_impl->AddToReconSet(peer_id, txs_to_reconcile);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "904b083461360ef8973df8b80097124aff218902",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e5eab8bba04063e2e051fb115f57c9660aa6eea/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e5eab8bba04063e2e051fb115f57c9660aa6eea/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=7e5eab8bba04063e2e051fb115f57c9660aa6eea",
        "patch": "@@ -66,6 +66,12 @@ class TxReconciliationTracker {\n     bool RegisterPeer(NodeId peer_id, bool peer_inbound,\n         bool recon_requestor, bool recon_responder, uint32_t recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
    "node_id": "C_kwDOABII59oAKGRlZTlmM2M1NmQ5MGI1NzJiMmYzMTkxOWVjNGMyODI4NWNhMGVjMWU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-07-29T18:25:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to remove wtxid from reconciliation sets\n\nIf a peer announced us a transaction, we should remove it from the\ncorresponding reconciliation set (in case it's there), because we don't\nneed to reconcile it.",
      "tree": {
        "sha": "aff25d7ae21fe867a2fea8128e96be0e16935dba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aff25d7ae21fe867a2fea8128e96be0e16935dba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7e5eab8bba04063e2e051fb115f57c9660aa6eea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e5eab8bba04063e2e051fb115f57c9660aa6eea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7e5eab8bba04063e2e051fb115f57c9660aa6eea"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1371ca2ec8f4e92839d779abe3c022108900fcd7",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
        "patch": "@@ -186,6 +186,15 @@ class TxReconciliationTracker::Impl {\n             \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state->second.m_local_set.m_wtxids.size());\n     }\n \n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+\n+        recon_state->second.m_local_set.m_wtxids.erase(wtxid_to_remove);\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -225,6 +234,11 @@ void TxReconciliationTracker::AddToReconSet(NodeId peer_id, const std::vector<ui\n     m_impl->AddToReconSet(peer_id, txs_to_reconcile);\n }\n \n+void TxReconciliationTracker::TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove)\n+{\n+    m_impl->TryRemovingFromReconSet(peer_id, wtxid_to_remove);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "648e52ad09e31c393975ec067339aeb85332d25c",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
        "patch": "@@ -72,6 +72,12 @@ class TxReconciliationTracker {\n      */\n     void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n \n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "e9416d4a15de7f2256c74f25509f9fe04e6992e3",
    "node_id": "C_kwDOABII59oAKGU5NDE2ZDRhMTVkZTdmMjI1NmM3NGYyNTUwOWY5ZmUwNGU2OTkyZTM",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:16:28Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to get peer's reconciliation set size\n\nThis will be later used to see if the reconciliation\nset is at capacity, or new transactions can be added.",
      "tree": {
        "sha": "5c654261f3be84cea935af008bc5387415e5c2eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c654261f3be84cea935af008bc5387415e5c2eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9416d4a15de7f2256c74f25509f9fe04e6992e3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9416d4a15de7f2256c74f25509f9fe04e6992e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9416d4a15de7f2256c74f25509f9fe04e6992e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9416d4a15de7f2256c74f25509f9fe04e6992e3/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dee9f3c56d90b572b2f31919ec4c28285ca0ec1e"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 28,
      "deletions": 1
    },
    "files": [
      {
        "sha": "85a7aabc5501df6e92382b71a1a44097bd4303cf",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 1,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9416d4a15de7f2256c74f25509f9fe04e6992e3/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9416d4a15de7f2256c74f25509f9fe04e6992e3/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=e9416d4a15de7f2256c74f25509f9fe04e6992e3",
        "patch": "@@ -36,6 +36,11 @@ struct ReconciliationSet {\n     /** Transactions we want to announce to the peer */\n     std::set<uint256> m_wtxids;\n \n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n     /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n     void Clear() {\n         m_wtxids.clear();\n@@ -183,7 +188,7 @@ class TxReconciliationTracker::Impl {\n         }\n \n         LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n-            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state->second.m_local_set.m_wtxids.size());\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state->second.m_local_set.GetSize());\n     }\n \n     void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove)\n@@ -210,6 +215,17 @@ class TxReconciliationTracker::Impl {\n         LOCK(m_mutex);\n         return m_states.find(peer_id) != m_states.end();\n     }\n+\n+    std::optional<size_t> GetPeerSetSize(NodeId peer_id) const\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) {\n+            return std::nullopt;\n+        }\n+        return recon_state->second.m_local_set.GetSize();\n+    }\n+\n };\n \n TxReconciliationTracker::TxReconciliationTracker() :\n@@ -248,3 +264,8 @@ bool TxReconciliationTracker::IsPeerRegistered(NodeId peer_id) const\n {\n     return m_impl->IsPeerRegistered(peer_id);\n }\n+\n+std::optional<size_t> TxReconciliationTracker::GetPeerSetSize(NodeId peer_id) const\n+{\n+    return m_impl->GetPeerSetSize(peer_id);\n+}"
      },
      {
        "sha": "bfc1783ae4f29bedcc7138698acb8ec4fb65f695",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9416d4a15de7f2256c74f25509f9fe04e6992e3/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9416d4a15de7f2256c74f25509f9fe04e6992e3/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=e9416d4a15de7f2256c74f25509f9fe04e6992e3",
        "patch": "@@ -90,6 +90,12 @@ class TxReconciliationTracker {\n      * Check if a peer is registered to reconcile with us.\n      */\n     bool IsPeerRegistered(NodeId peer_id) const;\n+\n+    /**\n+     * Returns the size of the reconciliation set we have locally for the given peer.\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<size_t> GetPeerSetSize(NodeId peer_id) const;\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "87dce7dfe377516780ee06e31b8c036d13563ccd",
    "node_id": "C_kwDOABII59oAKDg3ZGNlN2RmZTM3NzUxNjc4MGVlMDZlMzFiOGMwMzZkMTM1NjNjY2Q",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-23T16:01:53Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to see whether a reconciling peer is a fanout destination",
      "tree": {
        "sha": "7cdc2586a49a34e17356bcb51247029b20aaa31f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7cdc2586a49a34e17356bcb51247029b20aaa31f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87dce7dfe377516780ee06e31b8c036d13563ccd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87dce7dfe377516780ee06e31b8c036d13563ccd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/87dce7dfe377516780ee06e31b8c036d13563ccd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87dce7dfe377516780ee06e31b8c036d13563ccd/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9416d4a15de7f2256c74f25509f9fe04e6992e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9416d4a15de7f2256c74f25509f9fe04e6992e3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9416d4a15de7f2256c74f25509f9fe04e6992e3"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 57,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c26346f891a94eedb325971f06085626f70e5472",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87dce7dfe377516780ee06e31b8c036d13563ccd/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87dce7dfe377516780ee06e31b8c036d13563ccd/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=87dce7dfe377516780ee06e31b8c036d13563ccd",
        "patch": "@@ -5,13 +5,17 @@\n #include <txreconciliation.h>\n \n #include <unordered_map>\n+#include <util/hasher.h>\n \n namespace {\n \n /** Current protocol version */\n constexpr uint32_t RECON_VERSION = 1;\n /** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n \n /**\n  * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n@@ -90,6 +94,13 @@ class TxReconciliationTracker::Impl {\n \n     mutable Mutex m_mutex;\n \n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+\n     /**\n      * Per-peer salt is used to compute transaction short IDs, which will be later used to\n      * construct reconciliation sketches.\n@@ -226,6 +237,42 @@ class TxReconciliationTracker::Impl {\n         return recon_state->second.m_local_set.GetSize();\n     }\n \n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const\n+    {\n+        LOCK(m_mutex);\n+\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) {\n+            return false;\n+        }\n+\n+        // In this function we make an assumption that reconciliation is always initiated from\n+        // inbound to outbound to avoid code complexity.\n+        std::vector<NodeId> eligible_peers;\n+        size_t flood_index_modulo;\n+        if (recon_state->second.m_we_initiate) {\n+            std::for_each(m_states.begin(), m_states.end(),\n+                [&eligible_peers](std::pair<NodeId, ReconciliationState> state) {\n+                    if (state.second.m_we_initiate) eligible_peers.push_back(state.first);\n+                }\n+            );\n+            flood_index_modulo = 1.0 / OUTBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        } else {\n+            std::for_each(m_states.begin(), m_states.end(),\n+                [&eligible_peers](std::pair<NodeId, ReconciliationState> state) {\n+                    if (!state.second.m_we_initiate) eligible_peers.push_back(state.first);\n+                }\n+            );\n+            flood_index_modulo = 1.0 / INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        assert(it != eligible_peers.end());\n+\n+        const size_t peer_index = it - eligible_peers.begin();\n+        return txidHasher(wtxid) % flood_index_modulo == peer_index % flood_index_modulo;\n+    }\n+\n };\n \n TxReconciliationTracker::TxReconciliationTracker() :\n@@ -269,3 +316,8 @@ std::optional<size_t> TxReconciliationTracker::GetPeerSetSize(NodeId peer_id) co\n {\n     return m_impl->GetPeerSetSize(peer_id);\n }\n+\n+bool TxReconciliationTracker::ShouldFloodTo(uint256 wtxid, NodeId peer_id) const\n+{\n+    return m_impl->ShouldFloodTo(wtxid, peer_id);\n+}"
      },
      {
        "sha": "d3435d800fafeb9a4aef6624197a7b3995913c39",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87dce7dfe377516780ee06e31b8c036d13563ccd/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87dce7dfe377516780ee06e31b8c036d13563ccd/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=87dce7dfe377516780ee06e31b8c036d13563ccd",
        "patch": "@@ -96,6 +96,11 @@ class TxReconciliationTracker {\n      * If the peer was not previously registered for reconciliations, returns nullopt.\n      */\n     std::optional<size_t> GetPeerSetSize(NodeId peer_id) const;\n+\n+    /**\n+     * Returns whether for the given call the peer is chosen as a low-fanout destination.\n+     */\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const;\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
    "node_id": "C_kwDOABII59oAKDlmMGQwMTg3ZjBiODM0NDk2YzkxOTNlYjlkNGIzZGZiNWIwNmQwODU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-08-06T15:50:49Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to see whether a transaction is being reconciled\n\nThis will be later used to resolve relaying mempool packages.",
      "tree": {
        "sha": "ad65e23f3119e5cec7ad8484312fbd7dc5d7f6fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad65e23f3119e5cec7ad8484312fbd7dc5d7f6fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87dce7dfe377516780ee06e31b8c036d13563ccd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87dce7dfe377516780ee06e31b8c036d13563ccd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87dce7dfe377516780ee06e31b8c036d13563ccd"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d158c7445f2fb03f4b9f564f74243c34b5628e32",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
        "patch": "@@ -273,6 +273,16 @@ class TxReconciliationTracker::Impl {\n         return txidHasher(wtxid) % flood_index_modulo == peer_index % flood_index_modulo;\n     }\n \n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) {\n+            return false;\n+        }\n+        return recon_state->second.m_local_set.m_wtxids.count(wtxid) > 0;\n+    }\n+\n };\n \n TxReconciliationTracker::TxReconciliationTracker() :\n@@ -321,3 +331,8 @@ bool TxReconciliationTracker::ShouldFloodTo(uint256 wtxid, NodeId peer_id) const\n {\n     return m_impl->ShouldFloodTo(wtxid, peer_id);\n }\n+\n+bool TxReconciliationTracker::CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const\n+{\n+    return m_impl->CurrentlyReconcilingTx(peer_id, wtxid);\n+}"
      },
      {
        "sha": "009e31952ab0741e9d713261c516ab3851cf7469",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
        "patch": "@@ -101,6 +101,11 @@ class TxReconciliationTracker {\n      * Returns whether for the given call the peer is chosen as a low-fanout destination.\n      */\n     bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const;\n+\n+    /**\n+     * Check whether a particular transaction is being currently reconciled with a given peer.\n+     */\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const;\n };\n \n #endif // BITCOIN_TXRECONCILIATION_H"
      }
    ]
  },
  {
    "sha": "873707ea49bdc13c19a673de5de04076b3bddc4f",
    "node_id": "C_kwDOABII59oAKDg3MzcwN2VhNDliZGMxM2MxOWE2NzNkZTVkZTA0MDc2YjNiZGRjNGY",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-24T09:02:56Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add certain transactions to reconciliation sets\n\nAdd transactions which are eligible for reconciliation to the\nreconciliation sets of the peers, otherwise use low-fanout.",
      "tree": {
        "sha": "5f6beaa51fb5937fd1585a65786e05d3534e1aaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5f6beaa51fb5937fd1585a65786e05d3534e1aaa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/873707ea49bdc13c19a673de5de04076b3bddc4f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/873707ea49bdc13c19a673de5de04076b3bddc4f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/873707ea49bdc13c19a673de5de04076b3bddc4f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/873707ea49bdc13c19a673de5de04076b3bddc4f/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9f0d0187f0b834496c9193eb9d4b3dfb5b06d085"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 95,
      "deletions": 2
    },
    "files": [
      {
        "sha": "0523466f9185d78ad7365ea118be514f584c1784",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 2,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/873707ea49bdc13c19a673de5de04076b3bddc4f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/873707ea49bdc13c19a673de5de04076b3bddc4f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=873707ea49bdc13c19a673de5de04076b3bddc4f",
        "patch": "@@ -84,7 +84,9 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n /** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n  *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n  *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n- *  the actual transaction (from any peer) in response to requests for them. */\n+ *  the actual transaction (from any peer) in response to requests for them.\n+ *  Also limits a maximum number of elements to store in the reconciliation set.\n+ */\n static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr auto TXID_RELAY_DELAY = std::chrono::seconds{2};\n@@ -3030,6 +3032,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n+                if (gtxid.IsWtxid()) m_reconciliation.TryRemovingFromReconSet(pfrom.GetId(), gtxid.GetHash());\n             } else {\n                 LogPrint(BCLog::NET, \"Unknown inv type \\\"%s\\\" received from peer=%d\\n\", inv.ToString(), pfrom.GetId());\n             }\n@@ -3315,6 +3318,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n+        m_reconciliation.TryRemovingFromReconSet(pfrom.GetId(), wtxid);\n+\n         const MempoolAcceptResult result = m_chainman.ProcessTransaction(ptx);\n         const TxValidationState& state = result.m_state;\n \n@@ -4849,6 +4854,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     // especially since we have many peers and some will draw much shorter delays.\n                     unsigned int nRelayedTransactions = 0;\n                     LOCK(pto->m_tx_relay->cs_filter);\n+                    std::vector<uint256> txs_to_reconcile;\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n@@ -4876,7 +4882,89 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (m_reconciliation.IsPeerRegistered(pto->GetId())) {\n+                            bool flood_target = m_reconciliation.ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_reconciliation.CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                txs_to_reconcile.push_back(wtxid);\n+                                adding_to_recon_set = true;\n+                            }\n+                        }\n+\n+                        // If not added to the reconciliation set, flood.\n+                        if (!adding_to_recon_set) {\n+                            vInv.push_back(inv);\n+                        }\n+\n                         nRelayedTransactions++;\n                         {\n                             // Expire old relay messages\n@@ -4910,6 +4998,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_reconciliation.AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())"
      }
    ]
  },
  {
    "sha": "b8fd7d634a240b522a37c9c80b724487e8abf3b8",
    "node_id": "C_kwDOABII59oAKGI4ZmQ3ZDYzNGEyNDBiNTIyYTM3YzljODBiNzI0NDg3ZThhYmYzYjg",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-08-05T06:51:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add both txid and wtxid to m_recently_announced_invs\n\nIt's possible that a parent will be scheduled to relay same time as child,\nbut a child arrives earlier. Then, peer receiving an orphan would trigger\nrequesting a parent with txid, which would result in a NOTFOUND.\n\nThis happens because filterInventoryKnown has both txid and wtxid,\nand prevents adding a parent txid to m_recently_announced_invs\nwhen a peer requests a child with GETDATA.\n\nFix this by adding both wtxid and txid to m_recently_announced_invs\nat the same time we schedule them for announcement, to allow\nrequesting parents even though they were scheduled for relay\n(and not relayed yet) based on wtxid.",
      "tree": {
        "sha": "5648da65fba891b96297937fd227102fa242dd48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5648da65fba891b96297937fd227102fa242dd48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8fd7d634a240b522a37c9c80b724487e8abf3b8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8fd7d634a240b522a37c9c80b724487e8abf3b8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8fd7d634a240b522a37c9c80b724487e8abf3b8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8fd7d634a240b522a37c9c80b724487e8abf3b8/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "873707ea49bdc13c19a673de5de04076b3bddc4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/873707ea49bdc13c19a673de5de04076b3bddc4f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/873707ea49bdc13c19a673de5de04076b3bddc4f"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 6,
      "deletions": 1
    },
    "files": [
      {
        "sha": "e7e53c3703ef33fdaaab32038b13e4df1afba836",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8fd7d634a240b522a37c9c80b724487e8abf3b8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8fd7d634a240b522a37c9c80b724487e8abf3b8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b8fd7d634a240b522a37c9c80b724487e8abf3b8",
        "patch": "@@ -4880,8 +4880,13 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             continue;\n                         }\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n \n                         bool adding_to_recon_set = false;\n                         // Check if peer supports reconciliations."
      }
    ]
  },
  {
    "sha": "4011d23e637dbac28835de89854e4984eb3db9f6",
    "node_id": "C_kwDOABII59oAKDQwMTFkMjNlNjM3ZGJhYzI4ODM1ZGU4OTg1NGU0OTg0ZWIzZGI5ZjY",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-16T19:33:05Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Introduce reconciliation-fanout tx broadcast interval\n\nFor a subset of reconciling peers we announce transactions\nvia low fanout. We need to set lower intervals for that to\nachieve lower relay latency.\n\nNote that for privacy reasons the ratio between inbound and outbound\ndelays matter much more than the actual delays. That ratio is preserved\nhere, so it is not a privacy degradation.",
      "tree": {
        "sha": "9e67a6238c2256745f3db2bfc209b9b7e15498fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9e67a6238c2256745f3db2bfc209b9b7e15498fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4011d23e637dbac28835de89854e4984eb3db9f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4011d23e637dbac28835de89854e4984eb3db9f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4011d23e637dbac28835de89854e4984eb3db9f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4011d23e637dbac28835de89854e4984eb3db9f6/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8fd7d634a240b522a37c9c80b724487e8abf3b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8fd7d634a240b522a37c9c80b724487e8abf3b8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8fd7d634a240b522a37c9c80b724487e8abf3b8"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 33,
      "deletions": 6
    },
    "files": [
      {
        "sha": "38c3f6d435100dd64cccc1e143c1d2ceeff07706",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 6,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4011d23e637dbac28835de89854e4984eb3db9f6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4011d23e637dbac28835de89854e4984eb3db9f6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4011d23e637dbac28835de89854e4984eb3db9f6",
        "patch": "@@ -130,17 +130,22 @@ static constexpr auto AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24h;\n /** Average delay between peer address broadcasts */\n static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL = 30s;\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL = 5s;\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON = 2s;\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL = 2s;\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL_RECON = 1s;\n /** Maximum rate of inventory items to send per second.\n  *  Limits the impact of low-fee transaction floods. */\n static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;\n /** Maximum number of inventory items to send per transmission. */\n-static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * count_seconds(INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND *\n+    count_seconds(std::max(INBOUND_INVENTORY_BROADCAST_INTERVAL, INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON));\n /** The number of most recently announced transactions a peer can request. */\n static constexpr unsigned int INVENTORY_MAX_RECENT_RELAY = 3500;\n /** Verify that INVENTORY_MAX_RECENT_RELAY is enough to cache everything typically\n@@ -4792,12 +4797,34 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 LOCK(pto->m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n+                const bool supports_recon = m_reconciliation.IsPeerRegistered(pto->GetId());\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        if (supports_recon) {\n+                            // Use shorter intervals for reconciliation peers because we use\n+                            // low-fanout, and 1) we need to make faster; 2) we won't get much\n+                            // inefficiency due to low intervals and announcing both ways\n+                            // simultaneously.\n+\n+                            // Don't batch for inbound reconciling peers, because sending sketches\n+                            // out is batched already, and low-fanout won't give much info because\n+                            // it's low probability and is not controlled by the attacker.\n+                            pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time,\n+                                INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON);\n+                        }\n+                        else {\n+                            pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time,\n+                                INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        }\n                     } else {\n-                        pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        // Use smaller delay for outbound peers, as there is less privacy concern for them.\n+                        if (supports_recon)\n+                            pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time,\n+                                OUTBOUND_INVENTORY_BROADCAST_INTERVAL_RECON);\n+                        else\n+                            pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time,\n+                                OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     }\n                 }\n \n@@ -4890,7 +4917,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n                         bool adding_to_recon_set = false;\n                         // Check if peer supports reconciliations.\n-                        if (m_reconciliation.IsPeerRegistered(pto->GetId())) {\n+                        if (supports_recon) {\n                             bool flood_target = m_reconciliation.ShouldFloodTo(wtxid, pto->GetId());\n \n                             // Special treatment for unconfirmed transactions with unconfirmed"
      }
    ]
  },
  {
    "sha": "35034806257e1b20f4eceb9ff3e3e6f561f62125",
    "node_id": "C_kwDOABII59oAKDM1MDM0ODA2MjU3ZTFiMjBmNGVjZWI5ZmYzZTNlNmY1NjFmNjIxMjU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T12:12:24Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add peers to reconciliation queue on negotiation\n\nWhen we're finalizing negotiation, we should add the peers\nfor which we will initiate reconciliations to the queue.",
      "tree": {
        "sha": "a2070166b51da75a863b3e57a088bae1e97e3f1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2070166b51da75a863b3e57a088bae1e97e3f1c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35034806257e1b20f4eceb9ff3e3e6f561f62125",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35034806257e1b20f4eceb9ff3e3e6f561f62125",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/35034806257e1b20f4eceb9ff3e3e6f561f62125",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35034806257e1b20f4eceb9ff3e3e6f561f62125/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4011d23e637dbac28835de89854e4984eb3db9f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4011d23e637dbac28835de89854e4984eb3db9f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4011d23e637dbac28835de89854e4984eb3db9f6"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 12,
      "deletions": 0
    },
    "files": [
      {
        "sha": "063d377a5d52615bff2cb516ecded0ab2e5f9832",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35034806257e1b20f4eceb9ff3e3e6f561f62125/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35034806257e1b20f4eceb9ff3e3e6f561f62125/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=35034806257e1b20f4eceb9ff3e3e6f561f62125",
        "patch": "@@ -115,6 +115,13 @@ class TxReconciliationTracker::Impl {\n      */\n     std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n \n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it\u2019s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n     public:\n \n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound)\n@@ -174,6 +181,10 @@ class TxReconciliationTracker::Impl {\n         // The peer set both flags to false, we treat it as a protocol violation.\n         if (!(they_initiate || we_initiate)) return false;\n \n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n         LogPrint(BCLog::NET, \"Register peer=%d for reconciling with the following params: \" /* Continued */\n             \"we_initiate=%i, they_initiate=%i.\\n\", peer_id, we_initiate, they_initiate);\n \n@@ -219,6 +230,7 @@ class TxReconciliationTracker::Impl {\n         if (salt_erased || state_erased) {\n             LogPrint(BCLog::NET, \"Forget reconciliation state of peer=%d.\\n\", peer_id);\n         }\n+        m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n     }\n \n     bool IsPeerRegistered(NodeId peer_id) const"
      }
    ]
  },
  {
    "sha": "010dfb500dad6230e5a3331a1f3cb1318ab9949f",
    "node_id": "C_kwDOABII59oAKDAxMGRmYjUwMGRhZDYyMzBlNWEzMzMxYTFmM2NiMTMxOGFiOTk0OWY",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:26:17Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to track reconciliation requests schedule\n\nWe initiate reconciliation by looking at the queue periodically\nwith equal intervals between peers to achieve efficiency.\n\nThis will be later used to see whether it's time to initiate.",
      "tree": {
        "sha": "8486ae18b91e8086ee78bd5614d1cd970d89f41f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8486ae18b91e8086ee78bd5614d1cd970d89f41f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/010dfb500dad6230e5a3331a1f3cb1318ab9949f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/010dfb500dad6230e5a3331a1f3cb1318ab9949f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/010dfb500dad6230e5a3331a1f3cb1318ab9949f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/010dfb500dad6230e5a3331a1f3cb1318ab9949f/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "35034806257e1b20f4eceb9ff3e3e6f561f62125",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35034806257e1b20f4eceb9ff3e3e6f561f62125",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/35034806257e1b20f4eceb9ff3e3e6f561f62125"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 21,
      "deletions": 0
    },
    "files": [
      {
        "sha": "080079c3b9e29689a882297f86d72115b8402672",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/010dfb500dad6230e5a3331a1f3cb1318ab9949f/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/010dfb500dad6230e5a3331a1f3cb1318ab9949f/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=010dfb500dad6230e5a3331a1f3cb1318ab9949f",
        "patch": "@@ -16,6 +16,14 @@ const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n /** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n \n /**\n  * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n@@ -122,6 +130,19 @@ class TxReconciliationTracker::Impl {\n      */\n     std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n \n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, ReconciliationState> state) { return state.second.m_we_initiate; });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n     public:\n \n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound)"
      }
    ]
  },
  {
    "sha": "129be9c75605763eff5ce115507a1bf933ea0569",
    "node_id": "C_kwDOABII59oAKDEyOWJlOWM3NTYwNTc2M2VmZjVjZTExNTUwN2ExYmY5MzNlYTA1Njk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:27:32Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Initiate reconciliation round\n\nWhen the time comes for the peer, we send a\nreconciliation request with the parameters which\nwill help the peer to construct a (hopefully) sufficient\nreconciliation sketch for us. We will then use that\nsketch to find missing transactions.",
      "tree": {
        "sha": "0c93bd0ed69dc7637871eca04fe913e4d85da3e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c93bd0ed69dc7637871eca04fe913e4d85da3e1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/129be9c75605763eff5ce115507a1bf933ea0569",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/129be9c75605763eff5ce115507a1bf933ea0569",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/129be9c75605763eff5ce115507a1bf933ea0569",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/129be9c75605763eff5ce115507a1bf933ea0569/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "010dfb500dad6230e5a3331a1f3cb1318ab9949f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/010dfb500dad6230e5a3331a1f3cb1318ab9949f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/010dfb500dad6230e5a3331a1f3cb1318ab9949f"
      }
    ],
    "stats": {
      "total": 95,
      "additions": 95,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6d9f5a0747c59118ebc77b9309b1cf742a57b5c9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129be9c75605763eff5ce115507a1bf933ea0569/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129be9c75605763eff5ce115507a1bf933ea0569/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=129be9c75605763eff5ce115507a1bf933ea0569",
        "patch": "@@ -5040,6 +5040,19 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                auto reconciliation_request_data = m_reconciliation.MaybeRequestReconciliation(pto->GetId());\n+                if (reconciliation_request_data) {\n+                    const auto [local_set_size, local_q_formatted] = (*reconciliation_request_data);\n+                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::REQRECON, local_set_size, local_q_formatted));\n+                }\n+            }\n+        }\n+\n         // Detect whether we're stalling\n         if (state.m_stalling_since.count() && state.m_stalling_since < current_time - BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,"
      },
      {
        "sha": "529692dfd2356826c153258683d1337f19ce7b69",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129be9c75605763eff5ce115507a1bf933ea0569/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129be9c75605763eff5ce115507a1bf933ea0569/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=129be9c75605763eff5ce115507a1bf933ea0569",
        "patch": "@@ -45,6 +45,7 @@ const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n+const char *REQRECON=\"reqrecon\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -86,6 +87,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::CFCHECKPT,\n     NetMsgType::WTXIDRELAY,\n     NetMsgType::SENDRECON,\n+    NetMsgType::REQRECON,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "6308f3264f4fdc6967a3b8289c11a88ae1578b40",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129be9c75605763eff5ce115507a1bf933ea0569/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129be9c75605763eff5ce115507a1bf933ea0569/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=129be9c75605763eff5ce115507a1bf933ea0569",
        "patch": "@@ -269,6 +269,13 @@ extern const char* WTXIDRELAY;\n  * The salt is used to compute short txids needed for efficient reconciliation.\n  */\n extern const char *SENDRECON;\n+/**\n+ * Requests a reconciliation, and provides local reconciliation set size\n+ * and coefficient used to accurately estimate reconciliation set difference\n+ * for a peer to construct a set sketch.\n+ * Peer should respond with \"sketch\" message.\n+ */\n+extern const char *REQRECON;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "0043ad5e930896cb5bcf39983d67cef3ccac28e3",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129be9c75605763eff5ce115507a1bf933ea0569/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129be9c75605763eff5ce115507a1bf933ea0569/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=129be9c75605763eff5ce115507a1bf933ea0569",
        "patch": "@@ -16,6 +16,13 @@ const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n /** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n /**\n  * Interval between initiating reconciliations with peers.\n  * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n@@ -25,6 +32,14 @@ constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n  */\n constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n \n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n /**\n  * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n  * to compute transaction short IDs, which are then used to construct a sketch representing a set\n@@ -60,6 +75,13 @@ struct ReconciliationSet {\n \n };\n \n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n \n /**\n  * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n@@ -91,6 +113,9 @@ class ReconciliationState {\n      */\n     ReconciliationSet m_local_set;\n \n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+\n     ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n         m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n };\n@@ -243,6 +268,39 @@ class TxReconciliationTracker::Impl {\n         recon_state->second.m_local_set.m_wtxids.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state->second.m_local_set.m_wtxids.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -345,6 +403,11 @@ void TxReconciliationTracker::TryRemovingFromReconSet(NodeId peer_id, const uint\n     m_impl->TryRemovingFromReconSet(peer_id, wtxid_to_remove);\n }\n \n+std::optional<std::pair<uint16_t, uint16_t>> TxReconciliationTracker::MaybeRequestReconciliation(NodeId peer_id)\n+{\n+    return m_impl->MaybeRequestReconciliation(peer_id);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "2d81659ac6f7f29a646a04fbe9471e84a87b8c43",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129be9c75605763eff5ce115507a1bf933ea0569/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129be9c75605763eff5ce115507a1bf933ea0569/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=129be9c75605763eff5ce115507a1bf933ea0569",
        "patch": "@@ -78,6 +78,16 @@ class TxReconciliationTracker {\n      */\n     void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n \n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "5842e0b8d00b03e58da624072dd1918317889da7",
    "node_id": "C_kwDOABII59oAKDU4NDJlMGI4ZDAwYjAzZTU4ZGE2MjQwNzJkZDE5MTgzMTc4ODlkYTc",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T15:21:49Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Handle reconciliation request\n\nStore the parameters the peer sent us inside the\nreconciliation request.",
      "tree": {
        "sha": "4e5498963c6efccb433e29d5c9c0a99843f347e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e5498963c6efccb433e29d5c9c0a99843f347e2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5842e0b8d00b03e58da624072dd1918317889da7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5842e0b8d00b03e58da624072dd1918317889da7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5842e0b8d00b03e58da624072dd1918317889da7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5842e0b8d00b03e58da624072dd1918317889da7/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "129be9c75605763eff5ce115507a1bf933ea0569",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/129be9c75605763eff5ce115507a1bf933ea0569",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/129be9c75605763eff5ce115507a1bf933ea0569"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 58,
      "deletions": 0
    },
    "files": [
      {
        "sha": "866bd64c89fb78bfd41865b9a85f29192ef65230",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5842e0b8d00b03e58da624072dd1918317889da7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5842e0b8d00b03e58da624072dd1918317889da7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5842e0b8d00b03e58da624072dd1918317889da7",
        "patch": "@@ -4067,6 +4067,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "49bc4a1efffee5d0b300113330d7106dfd8fe580",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5842e0b8d00b03e58da624072dd1918317889da7/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5842e0b8d00b03e58da624072dd1918317889da7/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=5842e0b8d00b03e58da624072dd1918317889da7",
        "patch": "@@ -83,6 +83,28 @@ struct ReconciliationInitByUs {\n     Phase m_phase{Phase::NONE};\n };\n \n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n /**\n  * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n  * peer when next transaction reconciliation happens, and also all parameters required to perform\n@@ -115,6 +137,7 @@ class ReconciliationState {\n \n     /** Keep track of reconciliations with the peer. */\n     ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n \n     ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n         m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n@@ -301,6 +324,23 @@ class TxReconciliationTracker::Impl {\n         return std::nullopt;\n     }\n \n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;\n+\n+        double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\n+        recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\n+        recon_state->second.m_state_init_by_them.m_remote_set_size = peer_recon_set_size;\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_REQUESTED;\n+\n+        LogPrint(BCLog::NET, \"Reconciliation initiated by peer=%d with the following params: \" /* Continued */\n+            \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -408,6 +448,11 @@ std::optional<std::pair<uint16_t, uint16_t>> TxReconciliationTracker::MaybeReque\n     return m_impl->MaybeRequestReconciliation(peer_id);\n }\n \n+void TxReconciliationTracker::HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+{\n+    m_impl->HandleReconciliationRequest(peer_id, peer_recon_set_size, peer_q);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "219939465c8b8c42247dd899f34f745556075a0b",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5842e0b8d00b03e58da624072dd1918317889da7/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5842e0b8d00b03e58da624072dd1918317889da7/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=5842e0b8d00b03e58da624072dd1918317889da7",
        "patch": "@@ -88,6 +88,12 @@ class TxReconciliationTracker {\n      */\n     std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);\n \n+    /**\n+     * Step 2. Record an (expected) reconciliation request with parameters to respond when its time.\n+     * If peer seems to violate the protocol, do nothing.\n+     */\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "2baa87ce4c286acb8c1f139815919abe854ef64e",
    "node_id": "C_kwDOABII59oAKDJiYWE4N2NlNGMyODZhY2I4YzFmMTM5ODE1OTE5YWJlODU0ZWY2NGU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T13:33:22Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T14:26:34Z"
      },
      "message": "Add helper to see whether we should respond to recon request\n\nFor initial reconciliatin requests we track whether was the last time\nwe responded to them, and if it was too recent, we respond after\na small delay.",
      "tree": {
        "sha": "79372e9aee73f4619eb50f22488b68e800b4ff96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79372e9aee73f4619eb50f22488b68e800b4ff96"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2baa87ce4c286acb8c1f139815919abe854ef64e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2baa87ce4c286acb8c1f139815919abe854ef64e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2baa87ce4c286acb8c1f139815919abe854ef64e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2baa87ce4c286acb8c1f139815919abe854ef64e/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5842e0b8d00b03e58da624072dd1918317889da7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5842e0b8d00b03e58da624072dd1918317889da7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5842e0b8d00b03e58da624072dd1918317889da7"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 25,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a2816cafb993464fc24d8f6657a3ca32566b70d8",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2baa87ce4c286acb8c1f139815919abe854ef64e/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2baa87ce4c286acb8c1f139815919abe854ef64e/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=2baa87ce4c286acb8c1f139815919abe854ef64e",
        "patch": "@@ -31,6 +31,11 @@ constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n  * Less frequent reconciliations would introduce high transaction relay latency.\n  */\n constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+/**\n+ * We should keep an interval between responding to reconciliation requests from the same peer,\n+ * to reduce potential DoS surface.\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{1s};\n \n /**\n  * Represents phase of the current reconciliation round with a peer.\n@@ -101,6 +106,24 @@ struct ReconciliationInitByThem {\n      */\n     uint16_t m_remote_set_size;\n \n+    /**\n+     * We track when was the last time we responded to a reconciliation request by the peer,\n+     * so that we don't respond to them too often. This helps to reduce DoS surface.\n+     */\n+    std::chrono::microseconds m_last_init_recon_respond{0};\n+    /**\n+     * Returns whether at this time it's not too early to respond to a reconciliation request by\n+     * the peer, and, if so, bumps the time we last responded to allow further checks.\n+     */\n+    bool ConsiderInitResponseAndTrack() {\n+        auto current_time = GetTime<std::chrono::seconds>();\n+        if (m_last_init_recon_respond <= current_time - RECON_RESPONSE_INTERVAL) {\n+            m_last_init_recon_respond = current_time;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n     /** Keep track of the reconciliation phase with the peer. */\n     Phase m_phase{Phase::NONE};\n };"
      },
      {
        "sha": "cac669e75614ab7c14ca238f6c6443c67572cf29",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2baa87ce4c286acb8c1f139815919abe854ef64e/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2baa87ce4c286acb8c1f139815919abe854ef64e/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=2baa87ce4c286acb8c1f139815919abe854ef64e",
        "patch": "@@ -90,6 +90,8 @@ class TxReconciliationTracker {\n \n     /**\n      * Step 2. Record an (expected) reconciliation request with parameters to respond when its time.\n+     * All initial reconciliation responses will be done not immediately but in batches after\n+     * a delay, to prevent privacy leaks.\n      * If peer seems to violate the protocol, do nothing.\n      */\n     void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q);"
      }
    ]
  },
  {
    "sha": "e0fdefd2469a1827fe0bea88faebcac0972d5992",
    "node_id": "C_kwDOABII59oAKGUwZmRlZmQyNDY5YTE4MjdmZTBiZWE4OGZhZWJjYWMwOTcyZDU5OTI",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:32:57Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-17T15:07:57Z"
      },
      "message": "Add helper to compute reconciliation tx short id\n\nShort ids are used to compute reconciliation sketches.",
      "tree": {
        "sha": "e6bcae57ea817a7e3d590704579ed7fa79aa3a63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e6bcae57ea817a7e3d590704579ed7fa79aa3a63"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e0fdefd2469a1827fe0bea88faebcac0972d5992",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0fdefd2469a1827fe0bea88faebcac0972d5992",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e0fdefd2469a1827fe0bea88faebcac0972d5992",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0fdefd2469a1827fe0bea88faebcac0972d5992/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2baa87ce4c286acb8c1f139815919abe854ef64e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2baa87ce4c286acb8c1f139815919abe854ef64e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2baa87ce4c286acb8c1f139815919abe854ef64e"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 13,
      "deletions": 1
    },
    "files": [
      {
        "sha": "6c2033d92fdfc7c07ea461bca118e109fda199ad",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0fdefd2469a1827fe0bea88faebcac0972d5992/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0fdefd2469a1827fe0bea88faebcac0972d5992/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=e0fdefd2469a1827fe0bea88faebcac0972d5992",
        "patch": "@@ -140,7 +140,7 @@ class ReconciliationState {\n      * peer wants to announce. Sketches are computed over transaction short IDs.\n      * These values are used to salt short IDs.\n      */\n-    [[maybe_unused]] const uint64_t m_k0, m_k1;\n+    const uint64_t m_k0, m_k1;\n \n     public:\n \n@@ -164,6 +164,18 @@ class ReconciliationState {\n \n     ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n         m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n };\n \n } // namespace"
      }
    ]
  },
  {
    "sha": "b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
    "node_id": "C_kwDOABII59oAKGIyOTE4NTRhMWRhMWJkM2IyYjBhYWQ3Y2FhOWQzYjY4YmMzNWQxMzE",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-10-25T13:03:19Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:23Z"
      },
      "message": "build: Link minisketch libraries",
      "tree": {
        "sha": "9641cdd339a2ace4f5565bcb4552bddeaaacda3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9641cdd339a2ace4f5565bcb4552bddeaaacda3e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e0fdefd2469a1827fe0bea88faebcac0972d5992",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0fdefd2469a1827fe0bea88faebcac0972d5992",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e0fdefd2469a1827fe0bea88faebcac0972d5992"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 7,
      "deletions": 4
    },
    "files": [
      {
        "sha": "59b1e552d88d6e9536071a836cd10898866d2b5c",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "patch": "@@ -649,7 +649,8 @@ bitcoin_bin_ldadd = \\\n   $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n-  $(LIBSECP256K1)\n+  $(LIBSECP256K1) \\\n+  $(MINISKETCH_LIBS)\n \n bitcoin_bin_ldadd += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(SQLITE_LIBS)\n "
      },
      {
        "sha": "c55c6b666189ed29a851008a098de62cd1ac28c4",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "patch": "@@ -64,7 +64,8 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBSECP256K1) \\\n   $(LIBUNIVALUE) \\\n   $(EVENT_PTHREADS_LIBS) \\\n-  $(EVENT_LIBS)\n+  $(EVENT_LIBS) \\\n+  $(MINISKETCH_LIBS)\n \n if ENABLE_ZMQ\n bench_bench_bitcoin_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)"
      },
      {
        "sha": "d76e6f5ddb7d7ef3160f3dcea24c98f509f0bb83",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "patch": "@@ -332,7 +332,7 @@ bitcoin_qt_ldadd += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n bitcoin_qt_ldadd += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS) $(MINISKETCH_LIBS)\n bitcoin_qt_ldflags = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n bitcoin_qt_libtoolflags = $(AM_LIBTOOLFLAGS) --tag CXX\n "
      },
      {
        "sha": "e05fb9ae10f450f13060dc1bc8380867f7f0aa07",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "patch": "@@ -54,7 +54,7 @@ endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(NATPMP_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(SQLITE_LIBS) $(MINISKETCH_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n qt_test_test_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n "
      },
      {
        "sha": "666554b2de0d0bb0819ef5e3987136e60e614ece",
        "filename": "src/Makefile.test_fuzz.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.test_fuzz.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131/src/Makefile.test_fuzz.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test_fuzz.include?ref=b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "patch": "@@ -23,3 +23,4 @@ LIBTEST_FUZZ += $(LIBBITCOIN_SERVER)\n LIBTEST_FUZZ += $(LIBBITCOIN_COMMON)\n LIBTEST_FUZZ += $(LIBBITCOIN_UTIL)\n LIBTEST_FUZZ += $(LIBBITCOIN_CRYPTO_BASE)\n+LIBTEST_FUZZ += $(MINISKETCH_LIBS)"
      }
    ]
  },
  {
    "sha": "bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
    "node_id": "C_kwDOABII59oAKGJlZjkzMjVmMWM2YTk4NjdhNzBkOWQ4MGMxMmU1MmI5NjZjNjVkZDk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:41:11Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Add helper to compute sketches for tx reconciliation",
      "tree": {
        "sha": "0c6ae9c20d8775b40f4b3d45d550c9d4e8260cac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c6ae9c20d8775b40f4b3d45d550c9d4e8260cac"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bef9325f1c6a9867a70d9d80c12e52b966c65dd9/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b291854a1da1bd3b2b0aad7caa9d3b68bc35d131"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 62,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ff126776d1050a8f2660f8765809ea7859807d79",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bef9325f1c6a9867a70d9d80c12e52b966c65dd9/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bef9325f1c6a9867a70d9d80c12e52b966c65dd9/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
        "patch": "@@ -4,6 +4,8 @@\n \n #include <txreconciliation.h>\n \n+#include <node/minisketchwrapper.h>\n+\n #include <unordered_map>\n #include <util/hasher.h>\n \n@@ -16,6 +18,22 @@ const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n /** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n /** Coefficient used to estimate reconciliation set differences. */\n constexpr double RECON_Q = 0.25;\n /**\n@@ -68,6 +86,14 @@ struct ReconciliationSet {\n     /** Transactions we want to announce to the peer */\n     std::set<uint256> m_wtxids;\n \n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n     /** Get a number of transactions in the set. */\n     size_t GetSize() const {\n         return m_wtxids.size();\n@@ -76,6 +102,7 @@ struct ReconciliationSet {\n     /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n     void Clear() {\n         m_wtxids.clear();\n+        m_short_id_mapping.clear();\n     }\n \n };\n@@ -126,6 +153,19 @@ struct ReconciliationInitByThem {\n \n     /** Keep track of the reconciliation phase with the peer. */\n     Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n };\n \n /**\n@@ -176,6 +216,28 @@ class ReconciliationState {\n         return short_txid;\n     }\n \n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        sketch = MakeMinisketch32(capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n };\n \n } // namespace"
      }
    ]
  },
  {
    "sha": "6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
    "node_id": "C_kwDOABII59oAKDZlYzVjZjViOWQyY2FjODUwNzE5MjlkM2M0Y2ViMWQwYjU3OTNjY2M",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T15:36:08Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Respond to a reconciliation request\n\nWhen the time comes, we should send a sketch of our\nlocal reconciliation set to the reconciliation initiator.",
      "tree": {
        "sha": "01c270e2405c27448ded225ebf93751576cd7c1a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/01c270e2405c27448ded225ebf93751576cd7c1a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bef9325f1c6a9867a70d9d80c12e52b966c65dd9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bef9325f1c6a9867a70d9d80c12e52b966c65dd9"
      }
    ],
    "stats": {
      "total": 81,
      "additions": 80,
      "deletions": 1
    },
    "files": [
      {
        "sha": "05b2282e4bcd9ec1352b33953f15a5e4463f5d32",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "patch": "@@ -5060,6 +5060,21 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             }\n         }\n \n+        //\n+        // Message: reconciliation response\n+        //\n+        {\n+            std::vector<uint8_t> skdata;\n+            bool respond = m_reconciliation.RespondToReconciliationRequest(pto->GetId(), skdata);\n+            if (respond) {\n+                // It's perfectly valid to send an empty sketch, because we use this behavior\n+                // to trigger early reconciliation termination when it won't help anyway:\n+                // - we have no transactions for the peer\n+                // - the peer have no transactions for us\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::SKETCH, skdata));\n+            }\n+        }\n+\n         // Detect whether we're stalling\n         if (state.m_stalling_since.count() && state.m_stalling_since < current_time - BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,"
      },
      {
        "sha": "1f2c0621f07cc809d190ba59302553c4dc8cb9be",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "patch": "@@ -46,6 +46,7 @@ const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n const char *REQRECON=\"reqrecon\";\n+const char *SKETCH=\"sketch\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -88,6 +89,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::WTXIDRELAY,\n     NetMsgType::SENDRECON,\n     NetMsgType::REQRECON,\n+    NetMsgType::SKETCH,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "ac3d0163de8a221716794555451dc6fc5a1abc87",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "patch": "@@ -276,6 +276,12 @@ extern const char *SENDRECON;\n  * Peer should respond with \"sketch\" message.\n  */\n extern const char *REQRECON;\n+/**\n+ * Contains a sketch of the local reconciliation set,\n+ * used to efficiently reconcile transactions.\n+ * Peer should respond with \"reconcildiff\" or \"reqsketchext\" message.\n+ */\n+extern const char *SKETCH;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "b04d917fa768ecbadd2ce63795fad307a03da58f",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 1,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "patch": "@@ -61,6 +61,7 @@ constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{1s};\n enum Phase {\n     NONE,\n     INIT_REQUESTED,\n+    INIT_RESPONDED,\n };\n \n /**\n@@ -406,7 +407,7 @@ class TxReconciliationTracker::Impl {\n                 if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n                 recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n \n-                size_t local_set_size = recon_state->second.m_local_set.m_wtxids.size();\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n \n                 LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n                     \"local_set_size=%i\\n\", peer_id, local_set_size);\n@@ -438,6 +439,48 @@ class TxReconciliationTracker::Impl {\n             \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n     }\n \n+    bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return false;\n+        if (recon_state->second.m_we_initiate) return false;\n+\n+        Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\n+\n+        // For initial requests we have an extra check to avoid short intervals between responses\n+        // to the same peer (see comments in the check function for justification).\n+        bool respond_to_initial_request = incoming_phase == Phase::INIT_REQUESTED &&\n+            recon_state->second.m_state_init_by_them.ConsiderInitResponseAndTrack();\n+        if (!respond_to_initial_request) {\n+            return false;\n+        }\n+\n+        // Compute a sketch over the local reconciliation set.\n+        uint32_t sketch_capacity = 0;\n+\n+        // We send an empty vector at initial request in the following 2 cases because\n+        // reconciliation can't help:\n+        // - if we have nothing on our side\n+        // - if they have nothing on their side\n+        // Then, they will terminate reconciliation early and force flooding-style announcement.\n+        if (recon_state->second.m_state_init_by_them.m_remote_set_size > 0 &&\n+                recon_state->second.m_local_set.GetSize() > 0) {\n+\n+            sketch_capacity = recon_state->second.m_state_init_by_them.EstimateSketchCapacity(\n+                recon_state->second.m_local_set.GetSize());\n+            Minisketch sketch = recon_state->second.ComputeSketch(sketch_capacity);\n+            if (sketch) skdata = sketch.Serialize();\n+        }\n+\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n+\n+        LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n+            \"sending sketch of capacity=%i.\\n\", peer_id, sketch_capacity);\n+\n+        return true;\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -550,6 +593,11 @@ void TxReconciliationTracker::HandleReconciliationRequest(NodeId peer_id, uint16\n     m_impl->HandleReconciliationRequest(peer_id, peer_recon_set_size, peer_q);\n }\n \n+bool TxReconciliationTracker::RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata)\n+{\n+    return m_impl->RespondToReconciliationRequest(peer_id, skdata);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "73ae457639fd349db8d71aaadebb0c32b08c77c9",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "patch": "@@ -96,6 +96,14 @@ class TxReconciliationTracker {\n      */\n     void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q);\n \n+    /**\n+     * Step 2. Once it's time to respond to reconciliation requests, we construct a sketch from\n+     * the local reconciliation set, and send it to the initiator.\n+     * If the peer was not previously registered for reconciliations or it's not the time yet,\n+     * returns false.\n+     */\n+    bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "37e67ecfdb1d86003cb0af8de0697622696d1787",
    "node_id": "C_kwDOABII59oAKDM3ZTY3ZWNmZGIxZDg2MDAzY2IwYWY4ZGUwNjk3NjIyNjk2ZDE3ODc",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:09:06Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Add a function to identify local/remote missing txs\n\nWhen the sketches from both sides are combined successfully,\nthe diff is produced. Then this diff can (together with the local txs)\nbe used to identified which transactions are missing locally and remotely.",
      "tree": {
        "sha": "0be107f1bfea2a485ba39e5c3d8b6b3f9c2bc365",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0be107f1bfea2a485ba39e5c3d8b6b3f9c2bc365"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37e67ecfdb1d86003cb0af8de0697622696d1787",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37e67ecfdb1d86003cb0af8de0697622696d1787",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37e67ecfdb1d86003cb0af8de0697622696d1787",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37e67ecfdb1d86003cb0af8de0697622696d1787/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6ec5cf5b9d2cac85071929d3c4ceb1d0b5793ccc"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 19,
      "deletions": 0
    },
    "files": [
      {
        "sha": "cf8f88c3c38861bcdb93d9d66bb1f0d05365093e",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37e67ecfdb1d86003cb0af8de0697622696d1787/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37e67ecfdb1d86003cb0af8de0697622696d1787/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=37e67ecfdb1d86003cb0af8de0697622696d1787",
        "patch": "@@ -100,6 +100,25 @@ struct ReconciliationSet {\n         return m_wtxids.size();\n     }\n \n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n     /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n     void Clear() {\n         m_wtxids.clear();"
      }
    ]
  },
  {
    "sha": "748a2cd1732eae4d501d4beb3edf051793b6ba3d",
    "node_id": "C_kwDOABII59oAKDc0OGEyY2QxNzMyZWFlNGQ1MDFkNGJlYjNlZGYwNTE3OTNiNmJhM2Q",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-24T06:23:59Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Use txid/uint256 in CompareInvMempoolOrder\n\nThis will help to reuse the code later on in the function\nto announce transactions.",
      "tree": {
        "sha": "32e32433e95f3382809ec681c60455c8794f9077",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32e32433e95f3382809ec681c60455c8794f9077"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/748a2cd1732eae4d501d4beb3edf051793b6ba3d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/748a2cd1732eae4d501d4beb3edf051793b6ba3d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/748a2cd1732eae4d501d4beb3edf051793b6ba3d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/748a2cd1732eae4d501d4beb3edf051793b6ba3d/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "37e67ecfdb1d86003cb0af8de0697622696d1787",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37e67ecfdb1d86003cb0af8de0697622696d1787",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/37e67ecfdb1d86003cb0af8de0697622696d1787"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 6,
      "deletions": 7
    },
    "files": [
      {
        "sha": "67c11def05d749c7ac1c7b32b28b10723f801f4e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/748a2cd1732eae4d501d4beb3edf051793b6ba3d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/748a2cd1732eae4d501d4beb3edf051793b6ba3d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=748a2cd1732eae4d501d4beb3edf051793b6ba3d",
        "patch": "@@ -4549,11 +4549,11 @@ class CompareInvMempoolOrder\n         m_wtxid_relay = use_wtxid;\n     }\n \n-    bool operator()(std::set<uint256>::iterator a, std::set<uint256>::iterator b)\n+    bool operator()(const uint256& a, const uint256& b)\n     {\n         /* As std::make_heap produces a max-heap, we want the entries with the\n          * fewest ancestors/highest fee to sort later. */\n-        return mp->CompareDepthAndScore(*b, *a, m_wtxid_relay);\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n     }\n };\n }\n@@ -4874,10 +4874,10 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 // Determine transactions to relay\n                 if (fSendTrickle) {\n                     // Produce a vector with all candidates for sending\n-                    std::vector<std::set<uint256>::iterator> vInvTx;\n+                    std::vector<uint256> vInvTx;\n                     vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n                     for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n-                        vInvTx.push_back(it);\n+                        vInvTx.push_back(*it);\n                     }\n                     const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n@@ -4892,12 +4892,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                        std::set<uint256>::iterator it = vInvTx.back();\n+                        uint256 hash = vInvTx.back();\n                         vInvTx.pop_back();\n-                        uint256 hash = *it;\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(it);\n+                        pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n                         // Check if not in the filter already\n                         if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n                             continue;"
      }
    ]
  },
  {
    "sha": "98c5623d7283997b4d21b4c20fde12091f131b21",
    "node_id": "C_kwDOABII59oAKDk4YzU2MjNkNzI4Mzk5N2I0ZDIxYjRjMjBmZGUxMjA5MWYxMzFiMjE",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-08-03T13:33:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Add a function to announce transactions after reconciliation\n\nHave a separate function to announce transactions to a peer (via INVs)\nconsidering INV message limitations.",
      "tree": {
        "sha": "f66e5507a9dc09fed42ca45e6e7743652c3d2a94",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f66e5507a9dc09fed42ca45e6e7743652c3d2a94"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/98c5623d7283997b4d21b4c20fde12091f131b21",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/98c5623d7283997b4d21b4c20fde12091f131b21",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/98c5623d7283997b4d21b4c20fde12091f131b21",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/98c5623d7283997b4d21b4c20fde12091f131b21/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "748a2cd1732eae4d501d4beb3edf051793b6ba3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/748a2cd1732eae4d501d4beb3edf051793b6ba3d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/748a2cd1732eae4d501d4beb3edf051793b6ba3d"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 53,
      "deletions": 21
    },
    "files": [
      {
        "sha": "e84a694c9ba40383727ef70ce6e950b3435f1e41",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 21,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/98c5623d7283997b4d21b4c20fde12091f131b21/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/98c5623d7283997b4d21b4c20fde12091f131b21/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=98c5623d7283997b4d21b4c20fde12091f131b21",
        "patch": "@@ -392,6 +392,9 @@ class PeerManagerImpl final : public PeerManager\n     void AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n+    /** Immediately announce transactions to a given peer via INV message(s). */\n+    void AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto);\n+\n     /** Send a version message to a peer */\n     void PushNodeVersion(CNode& pnode, int64_t nTime);\n \n@@ -2495,6 +2498,56 @@ void PeerManagerImpl::ProcessBlock(CNode& node, const std::shared_ptr<const CBlo\n     }\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.\n+        std::pop_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+        uint256 wtxid = remote_missing_wtxids.back();\n+\n+        remote_missing_wtxids.pop_back();\n+        remote_missing_invs.push_back(CInv(MSG_WTX, wtxid));\n+\n+        if (remote_missing_invs.size() == MAX_INV_SZ || remote_missing_wtxids.empty()) {\n+            m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\n+            remote_missing_invs.clear();\n+        }\n+    }\n+}\n+\n void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n                                      const std::chrono::microseconds time_received,\n                                      const std::atomic<bool>& interruptMsgProc)\n@@ -4537,27 +4590,6 @@ void PeerManagerImpl::MaybeSendFeefilter(CNode& pto, std::chrono::microseconds c\n     }\n }\n \n-namespace {\n-class CompareInvMempoolOrder\n-{\n-    CTxMemPool *mp;\n-    bool m_wtxid_relay;\n-public:\n-    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n-    {\n-        mp = _mempool;\n-        m_wtxid_relay = use_wtxid;\n-    }\n-\n-    bool operator()(const uint256& a, const uint256& b)\n-    {\n-        /* As std::make_heap produces a max-heap, we want the entries with the\n-         * fewest ancestors/highest fee to sort later. */\n-        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n-    }\n-};\n-}\n-\n bool PeerManagerImpl::SetupAddressRelay(const CNode& node, Peer& peer)\n {\n     // We don't participate in addr relay with outbound block-relay-only"
      }
    ]
  },
  {
    "sha": "9da95c301362649ff256eeeb5db82ee6bc7695d2",
    "node_id": "C_kwDOABII59oAKDlkYTk1YzMwMTM2MjY0OWZmMjU2ZWVlYjVkYjgyZWU2YmM3Njk1ZDI",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T18:46:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Handle reconciliation sketch and successful decoding",
      "tree": {
        "sha": "1e87bb75d0e6b3373c648a9a9f1f586c78b61219",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e87bb75d0e6b3373c648a9a9f1f586c78b61219"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9da95c301362649ff256eeeb5db82ee6bc7695d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9da95c301362649ff256eeeb5db82ee6bc7695d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9da95c301362649ff256eeeb5db82ee6bc7695d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9da95c301362649ff256eeeb5db82ee6bc7695d2/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "98c5623d7283997b4d21b4c20fde12091f131b21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/98c5623d7283997b4d21b4c20fde12091f131b21",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/98c5623d7283997b4d21b4c20fde12091f131b21"
      }
    ],
    "stats": {
      "total": 152,
      "additions": 152,
      "deletions": 0
    },
    "files": [
      {
        "sha": "24fcbdec9fac43efc0f5b06b3cab36741e9e41e9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "patch": "@@ -4127,6 +4127,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        bool recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                recon_result, txs_to_request));\n+            AnnounceTxs(txs_to_announce, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation sketch violating the protocol.\n+            LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "2ebf57ac742d271fdde46b5cfa392aba1e026317",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "patch": "@@ -47,6 +47,7 @@ const char *WTXIDRELAY=\"wtxidrelay\";\n const char *SENDRECON=\"sendrecon\";\n const char *REQRECON=\"reqrecon\";\n const char *SKETCH=\"sketch\";\n+const char *RECONCILDIFF=\"reconcildiff\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -90,6 +91,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::SENDRECON,\n     NetMsgType::REQRECON,\n     NetMsgType::SKETCH,\n+    NetMsgType::RECONCILDIFF,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "14876fa2fce6aea48ffaca8d2d9185658b90314a",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "patch": "@@ -282,6 +282,11 @@ extern const char *REQRECON;\n  * Peer should respond with \"reconcildiff\" or \"reqsketchext\" message.\n  */\n extern const char *SKETCH;\n+/**\n+ * Indicates whether ongoing reconciliation has succeeded,\n+ * and requests the missing transactions by short ids.\n+ */\n+extern const char *RECONCILDIFF;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "333b7fab13c29c536af0814312da5171536b9935",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "patch": "@@ -20,6 +20,11 @@ constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n /** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n /**\n  * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n  * and implies that extended sketches could be at most twice the size.\n@@ -100,6 +105,10 @@ struct ReconciliationSet {\n         return m_wtxids.size();\n     }\n \n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n     /**\n      * When during reconciliation we find a set difference successfully (by combining sketches),\n      * we want to find which transactions are missing on our and on their side.\n@@ -258,6 +267,16 @@ class ReconciliationState {\n \n         return sketch;\n     }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set)\n+    {\n+        assert(m_we_initiate);\n+        if (clear_local_set) m_local_set.Clear();\n+    }\n };\n \n } // namespace\n@@ -308,6 +327,75 @@ class TxReconciliationTracker::Impl {\n         m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n     }\n \n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch, remote_sketch;\n+        if (recon_state->second.m_local_set.GetSize() > 0) {\n+            local_sketch = recon_state->second.ComputeSketch(remote_sketch_capacity);\n+        }\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = MakeMinisketch32(remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch. \" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return true;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+            // TODO handle failure.\n+            result = false;\n+        }\n+        return true;\n+    }\n+\n     public:\n \n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound)\n@@ -500,6 +588,25 @@ class TxReconciliationTracker::Impl {\n         return true;\n     }\n \n+    bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return false;\n+        // We only may receive a sketch from reconciliation responder, not initiator.\n+        if (!recon_state->second.m_we_initiate) return false;\n+\n+        Phase cur_phase = recon_state->second.m_state_init_by_us.m_phase;\n+        if (cur_phase == Phase::INIT_REQUESTED) {\n+            return HandleInitialSketch(recon_state, skdata, txs_to_request, txs_to_announce, result);\n+        } else {\n+            LogPrint(BCLog::NET, \"Received sketch from peer=%d in wrong reconciliation phase=%i.\\n\", peer_id, cur_phase);\n+            return false;\n+        }\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -617,6 +724,12 @@ bool TxReconciliationTracker::RespondToReconciliationRequest(NodeId peer_id, std\n     return m_impl->RespondToReconciliationRequest(peer_id, skdata);\n }\n \n+bool TxReconciliationTracker::HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n+    std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result)\n+{\n+    return m_impl->HandleSketch(peer_id, skdata, txs_to_request, txs_to_announce, result);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "b2df824cfaf4c559754bd3a5687ff47446722d4b",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9da95c301362649ff256eeeb5db82ee6bc7695d2/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "patch": "@@ -104,6 +104,16 @@ class TxReconciliationTracker {\n      */\n     bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata);\n \n+    /**\n+     * Step 3. Process a response to our reconciliation request.\n+     * Returns false if the peer seems to violate the protocol.\n+     * Populates the vectors so that we know which transactions should be requested and announced,\n+     * and whether reconciliation succeeded.\n+     */\n+    bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "6f8dbaf688eddc77bbe80954d97e109f85c87d89",
    "node_id": "C_kwDOABII59oAKDZmOGRiYWY2ODhlZGRjNzdiYmU4MDk1NGQ5N2UxMDlmODVjODdkODk",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T18:31:33Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Request extension if decoding failed\n\nIf after decoding a reconciliation sketch it turned out\nto be insufficient to find set difference, request extension.",
      "tree": {
        "sha": "3b2c0d18e5059823d0a2e6a94faf2af4afee4787",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b2c0d18e5059823d0a2e6a94faf2af4afee4787"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f8dbaf688eddc77bbe80954d97e109f85c87d89",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f8dbaf688eddc77bbe80954d97e109f85c87d89",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f8dbaf688eddc77bbe80954d97e109f85c87d89",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f8dbaf688eddc77bbe80954d97e109f85c87d89/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9da95c301362649ff256eeeb5db82ee6bc7695d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9da95c301362649ff256eeeb5db82ee6bc7695d2"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 32,
      "deletions": 10
    },
    "files": [
      {
        "sha": "11da6ff8217ee66078828c382527aa2b9e29ee2c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "patch": "@@ -4133,12 +4133,20 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         std::vector<uint32_t> txs_to_request;\n         std::vector<uint256> txs_to_announce;\n-        bool recon_result;\n+        std::optional<bool> recon_result;\n         bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n \n         if (valid_sketch) {\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n-                recon_result, txs_to_request));\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without losing the initial data.\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::REQSKETCHEXT));\n+            }\n             AnnounceTxs(txs_to_announce, pfrom);\n         } else {\n             // Disconnect peers that send reconciliation sketch violating the protocol."
      },
      {
        "sha": "b5473a7194f140424472ebf1c26ff17cd5ebbf28",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "patch": "@@ -48,6 +48,7 @@ const char *SENDRECON=\"sendrecon\";\n const char *REQRECON=\"reqrecon\";\n const char *SKETCH=\"sketch\";\n const char *RECONCILDIFF=\"reconcildiff\";\n+const char *REQSKETCHEXT=\"reqsketchext\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -92,6 +93,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::REQRECON,\n     NetMsgType::SKETCH,\n     NetMsgType::RECONCILDIFF,\n+    NetMsgType::REQSKETCHEXT,\n };\n const static std::vector<std::string> allNetMessageTypesVec(std::begin(allNetMessageTypes), std::end(allNetMessageTypes));\n "
      },
      {
        "sha": "82c762b34bd1037e83413afda7cba88a3ea1794b",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "patch": "@@ -287,6 +287,10 @@ extern const char *SKETCH;\n  * and requests the missing transactions by short ids.\n  */\n extern const char *RECONCILDIFF;\n+/**\n+ * Requests a sketch extension for ongoing reconciliation.\n+ */\n+extern const char *REQSKETCHEXT;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "df0801ca313685989f8b44de1f725be67d01b838",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "patch": "@@ -67,6 +67,7 @@ enum Phase {\n     NONE,\n     INIT_REQUESTED,\n     INIT_RESPONDED,\n+    EXT_REQUESTED\n };\n \n /**\n@@ -330,7 +331,7 @@ class TxReconciliationTracker::Impl {\n     bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n         const std::vector<uint8_t>& skdata,\n         // returning values\n-        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result)\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n     {\n         assert(recon_state->second.m_we_initiate);\n         assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n@@ -390,8 +391,14 @@ class TxReconciliationTracker::Impl {\n                 \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n         } else {\n             // Initial reconciliation step failed.\n-            // TODO handle failure.\n-            result = false;\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.m_state_init_by_us.m_phase = EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n         }\n         return true;\n     }\n@@ -590,7 +597,7 @@ class TxReconciliationTracker::Impl {\n \n     bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n         // returning values\n-        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result)\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n     {\n         LOCK(m_mutex);\n         auto recon_state = m_states.find(peer_id);\n@@ -725,7 +732,7 @@ bool TxReconciliationTracker::RespondToReconciliationRequest(NodeId peer_id, std\n }\n \n bool TxReconciliationTracker::HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n-    std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result)\n+    std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n {\n     return m_impl->HandleSketch(peer_id, skdata, txs_to_request, txs_to_announce, result);\n }"
      },
      {
        "sha": "5725be9cc3505933077ec60feb1ebfb1c3d781ca",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f8dbaf688eddc77bbe80954d97e109f85c87d89/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "patch": "@@ -108,11 +108,12 @@ class TxReconciliationTracker {\n      * Step 3. Process a response to our reconciliation request.\n      * Returns false if the peer seems to violate the protocol.\n      * Populates the vectors so that we know which transactions should be requested and announced,\n-     * and whether reconciliation succeeded.\n+     * and whether reconciliation succeeded (nullopt if the reconciliation is not over yet and\n+     * extension should be requested).\n      */\n     bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n         // returning values\n-        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, bool& result);\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result);\n \n     // Helpers\n "
      }
    ]
  },
  {
    "sha": "8cb5a960b7b685540479584d5756b9708e9a7af8",
    "node_id": "C_kwDOABII59oAKDhjYjVhOTYwYjdiNjg1NTQwNDc5NTg0ZDU3NTZiOTcwOGU5YTdhZjg",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T18:41:09Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Be ready to receive sketch extension\n\nStore the initial sketches so that we are able to process\nextension sketch while avoiding transmitting the same data.",
      "tree": {
        "sha": "a1ef7cb88d6a6d79d37df41ac5fdc5e723450dd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1ef7cb88d6a6d79d37df41ac5fdc5e723450dd2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8cb5a960b7b685540479584d5756b9708e9a7af8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cb5a960b7b685540479584d5756b9708e9a7af8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8cb5a960b7b685540479584d5756b9708e9a7af8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cb5a960b7b685540479584d5756b9708e9a7af8/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f8dbaf688eddc77bbe80954d97e109f85c87d89",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6f8dbaf688eddc77bbe80954d97e109f85c87d89"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 76,
      "deletions": 4
    },
    "files": [
      {
        "sha": "539de1a9434b52aa97280fda2c5a29432bab2133",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 4,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8cb5a960b7b685540479584d5756b9708e9a7af8/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8cb5a960b7b685540479584d5756b9708e9a7af8/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=8cb5a960b7b685540479584d5756b9708e9a7af8",
        "patch": "@@ -141,6 +141,13 @@ struct ReconciliationSet {\n  * Track ongoing reconciliations with a giving peer which were initiated by us.\n  */\n struct ReconciliationInitByUs {\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n     /** Keep track of the reconciliation phase with the peer. */\n     Phase m_phase{Phase::NONE};\n };\n@@ -214,6 +221,12 @@ class ReconciliationState {\n \n     public:\n \n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n     /**\n      * Reconciliation protocol assumes using one role consistently: either a reconciliation\n      * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n@@ -228,6 +241,16 @@ class ReconciliationState {\n      */\n     ReconciliationSet m_local_set;\n \n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n     /** Keep track of reconciliations with the peer. */\n     ReconciliationInitByUs m_state_init_by_us;\n     ReconciliationInitByThem m_state_init_by_them;\n@@ -251,13 +274,17 @@ class ReconciliationState {\n      * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n      * of elements (see BIP-330).\n      */\n-    Minisketch ComputeSketch(uint32_t& capacity)\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n     {\n         Minisketch sketch;\n         // Avoid serializing/sending an empty sketch.\n         if (capacity == 0) return sketch;\n \n         capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n         sketch = MakeMinisketch32(capacity);\n \n         for (const auto& wtxid: m_local_set.m_wtxids) {\n@@ -269,6 +296,29 @@ class ReconciliationState {\n         return sketch;\n     }\n \n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n     /**\n      * Once we are fully done with the reconciliation we initiated, prepare the state for the\n      * following reconciliations we initiate.\n@@ -277,6 +327,27 @@ class ReconciliationState {\n     {\n         assert(m_we_initiate);\n         if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n     }\n };\n \n@@ -344,7 +415,7 @@ class TxReconciliationTracker::Impl {\n \n         Minisketch local_sketch, remote_sketch;\n         if (recon_state->second.m_local_set.GetSize() > 0) {\n-            local_sketch = recon_state->second.ComputeSketch(remote_sketch_capacity);\n+            local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n         }\n         if (remote_sketch_capacity != 0) {\n             remote_sketch = MakeMinisketch32(remote_sketch_capacity).Deserialize(skdata);\n@@ -393,7 +464,8 @@ class TxReconciliationTracker::Impl {\n             // Initial reconciliation step failed.\n \n             // Update local reconciliation state for the peer.\n-            recon_state->second.m_state_init_by_us.m_phase = EXT_REQUESTED;\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n \n             result = std::nullopt;\n \n@@ -583,7 +655,7 @@ class TxReconciliationTracker::Impl {\n \n             sketch_capacity = recon_state->second.m_state_init_by_them.EstimateSketchCapacity(\n                 recon_state->second.m_local_set.GetSize());\n-            Minisketch sketch = recon_state->second.ComputeSketch(sketch_capacity);\n+            Minisketch sketch = recon_state->second.ComputeBaseSketch(sketch_capacity);\n             if (sketch) skdata = sketch.Serialize();\n         }\n "
      }
    ]
  },
  {
    "sha": "df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
    "node_id": "C_kwDOABII59oAKGRmNDA5YmQyM2IzZmE5ZWUwNGQzMWJiZjc0Y2ZiODBiMmVlMWNhNzA",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:35:45Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Prepare for sketch extension request\n\nTo be ready to respond to a sketch extension request\nfrom our peer, we should store a snapshot of our state\nand capacity of the initial sketch, so that we compute\nextension of the same size and over the exact same\ntransactions.\n\nTransactions arriving during this reconciliation will\nbe instead stored in the regular set.",
      "tree": {
        "sha": "40ecc5ae080a4ec34f6ca6987df91f9939a9530a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/40ecc5ae080a4ec34f6ca6987df91f9939a9530a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8cb5a960b7b685540479584d5756b9708e9a7af8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8cb5a960b7b685540479584d5756b9708e9a7af8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8cb5a960b7b685540479584d5756b9708e9a7af8"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 16,
      "deletions": 1
    },
    "files": [
      {
        "sha": "b47103912c8c24f1115551e88f5242b8234e9569",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
        "patch": "@@ -333,6 +333,19 @@ class ReconciliationState {\n         m_state_init_by_us.m_remote_sketch_snapshot.clear();\n     }\n \n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n     /**\n      * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n      * received in the initial reconciliation step, so that only the necessary extension data\n@@ -660,6 +673,7 @@ class TxReconciliationTracker::Impl {\n         }\n \n         recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n+        recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n \n         LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n             \"sending sketch of capacity=%i.\\n\", peer_id, sketch_capacity);\n@@ -756,7 +770,8 @@ class TxReconciliationTracker::Impl {\n         if (recon_state == m_states.end()) {\n             return false;\n         }\n-        return recon_state->second.m_local_set.m_wtxids.count(wtxid) > 0;\n+        return recon_state->second.m_local_set.m_wtxids.count(wtxid) > 0 ||\n+            recon_state->second.m_local_set_snapshot.m_wtxids.count(wtxid) > 0;\n     }\n \n };"
      }
    ]
  },
  {
    "sha": "9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
    "node_id": "C_kwDOABII59oAKDliN2FiYjFjZGNhOTE5ZTlmYmQwODJjNDM3MGY3ZTM0NjZmOTFkZTA",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-07-29T18:37:03Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Keep track of transactions announced during reconciliation extension",
      "tree": {
        "sha": "f07bb92ba91438ae28b1171bddac62802907558c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f07bb92ba91438ae28b1171bddac62802907558c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b7abb1cdca919e9fbd082c4370f7e3466f91de0/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/df409bd23b3fa9ee04d31bbf74cfb80b2ee1ca70"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 14,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8dac2efe9d27cee507e78026da0c523d25fffa9d",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b7abb1cdca919e9fbd082c4370f7e3466f91de0/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b7abb1cdca919e9fbd082c4370f7e3466f91de0/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
        "patch": "@@ -251,6 +251,15 @@ class ReconciliationState {\n      */\n     ReconciliationSet m_local_set_snapshot;\n \n+    /**\n+     * A peer could announce a transaction to us during reconciliation and after we snapshoted\n+     * the initial set. We can't remove this new transaction from the snapshot, because\n+     * then we won't be able to compute a valid extension (for the sketch already transmitted).\n+     * Instead, we just remember those transaction, and not announce them when we announce\n+     * stuff from the snapshot.\n+     */\n+    std::set<uint256> m_announced_during_extension;\n+\n     /** Keep track of reconciliations with the peer. */\n     ReconciliationInitByUs m_state_init_by_us;\n     ReconciliationInitByThem m_state_init_by_them;\n@@ -328,6 +337,7 @@ class ReconciliationState {\n         assert(m_we_initiate);\n         if (clear_local_set) m_local_set.Clear();\n         m_local_set_snapshot.Clear();\n+        m_announced_during_extension.clear();\n         // This is currently belt-and-suspenders, as the code should work even without these calls.\n         m_capacity_snapshot = 0;\n         m_state_init_by_us.m_remote_sketch_snapshot.clear();\n@@ -586,6 +596,10 @@ class TxReconciliationTracker::Impl {\n         if (recon_state == m_states.end()) return;\n \n         recon_state->second.m_local_set.m_wtxids.erase(wtxid_to_remove);\n+        if (recon_state->second.m_local_set_snapshot.m_wtxids.find(wtxid_to_remove) !=\n+            recon_state->second.m_local_set_snapshot.m_wtxids.end()) {\n+                recon_state->second.m_announced_during_extension.insert(wtxid_to_remove);\n+            }\n     }\n \n     std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)"
      }
    ]
  },
  {
    "sha": "1d168a6ba47948020b480ad51697391069400bd6",
    "node_id": "C_kwDOABII59oAKDFkMTY4YTZiYTQ3OTQ4MDIwYjQ4MGFkNTE2OTczOTEwNjk0MDBiZDY",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:36:54Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Handle reconciliation extension request\n\nIf peer failed to reconcile based on our initial response sketch,\nthey will ask us for a sketch extension. Store this request to respond later.",
      "tree": {
        "sha": "2195b9cf43a2e92563857ea94f00015c062de977",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2195b9cf43a2e92563857ea94f00015c062de977"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1d168a6ba47948020b480ad51697391069400bd6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d168a6ba47948020b480ad51697391069400bd6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1d168a6ba47948020b480ad51697391069400bd6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d168a6ba47948020b480ad51697391069400bd6/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b7abb1cdca919e9fbd082c4370f7e3466f91de0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9b7abb1cdca919e9fbd082c4370f7e3466f91de0"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 36,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c8684550fb558ef5512a57c17ae7556d4fff4d90",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d168a6ba47948020b480ad51697391069400bd6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d168a6ba47948020b480ad51697391069400bd6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1d168a6ba47948020b480ad51697391069400bd6",
        "patch": "@@ -4157,6 +4157,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQSKETCHEXT) {\n+        m_reconciliation.HandleExtensionRequest(pfrom.GetId());\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      },
      {
        "sha": "6076baac24600e9f5a95861a246b1622401dddae",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d168a6ba47948020b480ad51697391069400bd6/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d168a6ba47948020b480ad51697391069400bd6/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=1d168a6ba47948020b480ad51697391069400bd6",
        "patch": "@@ -714,6 +714,24 @@ class TxReconciliationTracker::Impl {\n         }\n     }\n \n+    void HandleExtensionRequest(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::INIT_RESPONDED) return;\n+        if (recon_state->second.m_capacity_snapshot == 0) {\n+            // In this case, the peer is supposed to terminate the reconciliation and not\n+            // request extension.\n+            LogPrint(BCLog::NET, \"Peer=%d violated the protocol by requesting an extension \" /* Continued */\n+                \"even though we initially provided an empty sketch.\\n\", peer_id);\n+            return;\n+        }\n+\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_REQUESTED;\n+        LogPrint(BCLog::NET, \"Received reconciliation extension request from peer=%d.\\n\", peer_id);\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -838,6 +856,11 @@ bool TxReconciliationTracker::HandleSketch(NodeId peer_id, const std::vector<uin\n     return m_impl->HandleSketch(peer_id, skdata, txs_to_request, txs_to_announce, result);\n }\n \n+void TxReconciliationTracker::HandleExtensionRequest(NodeId peer_id)\n+{\n+    m_impl->HandleExtensionRequest(peer_id);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "51d5c139676b3f5a9cbaf07ad41cc5e222b2d5bd",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d168a6ba47948020b480ad51697391069400bd6/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d168a6ba47948020b480ad51697391069400bd6/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=1d168a6ba47948020b480ad51697391069400bd6",
        "patch": "@@ -115,6 +115,14 @@ class TxReconciliationTracker {\n         // returning values\n         std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result);\n \n+    /**\n+     * Step 5. Peer requesting extension after reconciliation they initiated failed on their side:\n+     * the sketch we sent to them was not sufficient to find the difference.\n+     * No privacy leak can happen here because sketch extension is constructed over the snapshot.\n+     * If the peer seems to violate the protocol, do nothing.\n+     */\n+    void HandleExtensionRequest(NodeId peer_id);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "45c051b31efafa405fce3a540977012721da084b",
    "node_id": "C_kwDOABII59oAKDQ1YzA1MWIzMWVmYWZhNDA1ZmNlM2E1NDA5NzcwMTI3MjFkYTA4NGI",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:41:40Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Respond to sketch extension request\n\nSending an extension may allow the peer to reconcile\ntransactions, because now the full sketch has twice\nas much capacity.",
      "tree": {
        "sha": "26512c93cbaaca4bac5330eb756eccba9daa57fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/26512c93cbaaca4bac5330eb756eccba9daa57fa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45c051b31efafa405fce3a540977012721da084b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45c051b31efafa405fce3a540977012721da084b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/45c051b31efafa405fce3a540977012721da084b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45c051b31efafa405fce3a540977012721da084b/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1d168a6ba47948020b480ad51697391069400bd6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d168a6ba47948020b480ad51697391069400bd6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1d168a6ba47948020b480ad51697391069400bd6"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 52,
      "deletions": 19
    },
    "files": [
      {
        "sha": "29656a5b122bd21ec03badf1af83b5d45cd5afac",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 19,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45c051b31efafa405fce3a540977012721da084b/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45c051b31efafa405fce3a540977012721da084b/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=45c051b31efafa405fce3a540977012721da084b",
        "patch": "@@ -67,7 +67,8 @@ enum Phase {\n     NONE,\n     INIT_REQUESTED,\n     INIT_RESPONDED,\n-    EXT_REQUESTED\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n };\n \n /**\n@@ -652,23 +653,8 @@ class TxReconciliationTracker::Impl {\n             \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n     }\n \n-    bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata)\n+    void RespondToInitialRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\n     {\n-        LOCK(m_mutex);\n-        auto recon_state = m_states.find(peer_id);\n-        if (recon_state == m_states.end()) return false;\n-        if (recon_state->second.m_we_initiate) return false;\n-\n-        Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\n-\n-        // For initial requests we have an extra check to avoid short intervals between responses\n-        // to the same peer (see comments in the check function for justification).\n-        bool respond_to_initial_request = incoming_phase == Phase::INIT_REQUESTED &&\n-            recon_state->second.m_state_init_by_them.ConsiderInitResponseAndTrack();\n-        if (!respond_to_initial_request) {\n-            return false;\n-        }\n-\n         // Compute a sketch over the local reconciliation set.\n         uint32_t sketch_capacity = 0;\n \n@@ -686,13 +672,60 @@ class TxReconciliationTracker::Impl {\n             if (sketch) skdata = sketch.Serialize();\n         }\n \n+        // Update local reconciliation state for the peer.\n         recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n         recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n \n         LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n-            \"sending sketch of capacity=%i.\\n\", peer_id, sketch_capacity);\n+            \"sending sketch of capacity=%i.\\n\", recon_state->first, sketch_capacity);\n+    }\n \n-        return true;\n+    void RespondToExtensionRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\n+    {\n+        assert(recon_state->second.m_capacity_snapshot > 0);\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\n+\n+        // Local extension sketch can be null only if initial sketch or initial capacity was 0,\n+        // in which case we would have terminated reconciliation already.\n+        uint32_t extended_capacity = recon_state->second.m_capacity_snapshot * 2;\n+        Minisketch sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(sketch);\n+        skdata = sketch.Serialize();\n+\n+        // For the sketch extension, send only the higher sketch elements.\n+        size_t lower_bytes_to_drop = extended_capacity / 2 * BYTES_PER_SKETCH_CAPACITY;\n+        // Extended sketch is twice the size of the initial sketch (which is m_capacity_snapshot).\n+        assert(lower_bytes_to_drop <= skdata.size());\n+        skdata.erase(skdata.begin(), skdata.begin() + lower_bytes_to_drop);\n+\n+        LogPrint(BCLog::NET, \"Responding with a sketch extension to reconciliation initiated by peer=%d.\\n\", recon_state->first);\n+    }\n+\n+    bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return false;\n+        if (recon_state->second.m_we_initiate) return false;\n+\n+        Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\n+\n+        // For initial requests we have an extra check to avoid short intervals between responses\n+        // to the same peer (see comments in the check function for justification).\n+        bool respond_to_initial_request = incoming_phase == Phase::INIT_REQUESTED &&\n+            recon_state->second.m_state_init_by_them.ConsiderInitResponseAndTrack();\n+        bool respond_to_extension_request = incoming_phase == Phase::EXT_REQUESTED;\n+\n+        if (respond_to_initial_request) {\n+            RespondToInitialRequest(recon_state, skdata);\n+            return true;\n+        } else if(respond_to_extension_request) {\n+            RespondToExtensionRequest(recon_state, skdata);\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n \n     bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,"
      }
    ]
  },
  {
    "sha": "1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
    "node_id": "C_kwDOABII59oAKDFjZjE3ODY3MzZlZmVhYWYyNzg4ZDU1YTdjMzU5ZDlhYjUzMDBmOWU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:47:16Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Handle sketch extension\n\nIf a peer sent us an extension sketch, we should\nreconstruct a full sketch from it with the snapshot\nwe stored initially, and attempt to decode the difference.",
      "tree": {
        "sha": "460208533979a5ddd19b46c03969abccc96fadbe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/460208533979a5ddd19b46c03969abccc96fadbe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1cf1786736efeaaf2788d55a7c359d9ab5300f9e/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "45c051b31efafa405fce3a540977012721da084b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45c051b31efafa405fce3a540977012721da084b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/45c051b31efafa405fce3a540977012721da084b"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 64,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e0d2bac25dea203b2bf33157550bfe9a746485b0",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1cf1786736efeaaf2788d55a7c359d9ab5300f9e/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1cf1786736efeaaf2788d55a7c359d9ab5300f9e/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
        "patch": "@@ -499,6 +499,68 @@ class TxReconciliationTracker::Impl {\n         return true;\n     }\n \n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits. The limits are MAX_SKETCH_CAPACITY * 2, so that\n+        // they can extend even the largest (originally) sketch.\n+        uint16_t extended_capacity = uint32_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY * 2) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+\n+        // Filter out transactions received from the peer during the extension phase.\n+        std::set<uint256> announced_during_extension = recon_state->second.m_announced_during_extension;\n+        txs_to_announce.erase(std::remove_if(txs_to_announce.begin(), txs_to_announce.end(), [announced_during_extension](const auto&x) {\n+            return std::find(announced_during_extension.begin(), announced_during_extension.end(), x) != announced_during_extension.end();\n+        }), txs_to_announce.end());\n+\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.FinalizeInitByUs(false);\n+        recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+        return true;\n+    }\n+\n     public:\n \n     std::tuple<bool, bool, uint32_t, uint64_t> PreRegisterPeer(NodeId peer_id, bool peer_inbound)\n@@ -741,6 +803,8 @@ class TxReconciliationTracker::Impl {\n         Phase cur_phase = recon_state->second.m_state_init_by_us.m_phase;\n         if (cur_phase == Phase::INIT_REQUESTED) {\n             return HandleInitialSketch(recon_state, skdata, txs_to_request, txs_to_announce, result);\n+        } else if (cur_phase == Phase::EXT_REQUESTED) {\n+            return HandleSketchExtension(recon_state, skdata, txs_to_request, txs_to_announce, result);\n         } else {\n             LogPrint(BCLog::NET, \"Received sketch from peer=%d in wrong reconciliation phase=%i.\\n\", peer_id, cur_phase);\n             return false;"
      }
    ]
  },
  {
    "sha": "484214dda7959b4cc5954cb3f2b792b1e3d93abe",
    "node_id": "C_kwDOABII59oAKDQ4NDIxNGRkYTc5NTliNGNjNTk1NGNiM2YyYjc5MmIxZTNkOTNhYmU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:22:01Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Add a function to get wtxids by shortids\n\nAt the end of a reconciliation round, a peer may ask us\nfor transactions by their short id. Add a function for a local\nlookup short_id->wtxid.",
      "tree": {
        "sha": "81ca0a5469d80d158324eec2a0d0880ea9ef1c0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/81ca0a5469d80d158324eec2a0d0880ea9ef1c0f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/484214dda7959b4cc5954cb3f2b792b1e3d93abe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/484214dda7959b4cc5954cb3f2b792b1e3d93abe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/484214dda7959b4cc5954cb3f2b792b1e3d93abe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/484214dda7959b4cc5954cb3f2b792b1e3d93abe/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1cf1786736efeaaf2788d55a7c359d9ab5300f9e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1cf1786736efeaaf2788d55a7c359d9ab5300f9e"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 16,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8671a86068d2d70c312c15bf5e294ac64627980a",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/484214dda7959b4cc5954cb3f2b792b1e3d93abe/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/484214dda7959b4cc5954cb3f2b792b1e3d93abe/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=484214dda7959b4cc5954cb3f2b792b1e3d93abe",
        "patch": "@@ -130,6 +130,22 @@ struct ReconciliationSet {\n         }\n     }\n \n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n     /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n     void Clear() {\n         m_wtxids.clear();"
      }
    ]
  },
  {
    "sha": "90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
    "node_id": "C_kwDOABII59oAKDkwZDRjYWYxZjE5ZmU1ODU4ZTk0NmRhMzQ2ZjA2Y2EwZWUzZTM1ZjY",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:07:43Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Add a finalize incoming reconciliation function\n\nThis currently unused function is supposed to be used once\na reconciliation round is done. It cleans the state corresponding\nto the passed reconciliation.",
      "tree": {
        "sha": "b1fb267c034a49c18f515a30bc702a5722850148",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b1fb267c034a49c18f515a30bc702a5722850148"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90d4caf1f19fe5858e946da346f06ca0ee3e35f6/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "484214dda7959b4cc5954cb3f2b792b1e3d93abe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/484214dda7959b4cc5954cb3f2b792b1e3d93abe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/484214dda7959b4cc5954cb3f2b792b1e3d93abe"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 58,
      "deletions": 0
    },
    "files": [
      {
        "sha": "665aa521e09789ae37313c90c1a2f77f57c623ac",
        "filename": "src/txreconciliation.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4caf1f19fe5858e946da346f06ca0ee3e35f6/src/txreconciliation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4caf1f19fe5858e946da346f06ca0ee3e35f6/src/txreconciliation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.cpp?ref=90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
        "patch": "@@ -845,6 +845,48 @@ class TxReconciliationTracker::Impl {\n         LogPrint(BCLog::NET, \"Received reconciliation extension request from peer=%d.\\n\", peer_id);\n     }\n \n+    bool FinalizeInitByThem(NodeId peer_id, bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return false;\n+        assert(!recon_state->second.m_we_initiate);\n+\n+        // Check that reconciliation is in the right phase.\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::INIT_RESPONDED &&\n+            recon_state->second.m_state_init_by_them.m_phase != Phase::EXT_RESPONDED) return false;\n+\n+        // Note that now matter at which phase this happened, transactions must have been stored in\n+        // the snapshot, so we should operate over the snapshot here.\n+\n+        // Identify missing transactions based on the reconciliation result peer sent us.\n+        if (recon_result) {\n+            remote_missing = recon_state->second.m_local_set_snapshot.GetWTXIDsFromShortIDs(remote_missing_short_ids);\n+        } else {\n+            // Usually, reconciliation fails only after extension, but it also may fail at initial\n+            // phase if of the peers have no transactions locally. In either case, the transactions\n+            // we have for the peer are stored in the snapshot.\n+            remote_missing = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+        }\n+\n+        // Filter out transactions received from the peer during the extension phase.\n+        std::set<uint256> announced_during_extension = recon_state->second.m_announced_during_extension;\n+        remote_missing.erase(std::remove_if(remote_missing.begin(), remote_missing.end(), [announced_during_extension](const auto&x) {\n+            return std::find(announced_during_extension.begin(), announced_during_extension.end(), x) != announced_during_extension.end();\n+        }), remote_missing.end());\n+\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.m_local_set_snapshot.Clear();\n+        recon_state->second.m_announced_during_extension.clear();\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::NONE;\n+\n+        LogPrint(BCLog::NET, \"Finalizing reconciliation init by peer=%d with result=%i, announcing %i txs (requested by shortID).\\n\",\n+            peer_id, recon_result, remote_missing.size());\n+\n+        return true;\n+    }\n+\n     void ForgetPeer(NodeId peer_id)\n     {\n         LOCK(m_mutex);\n@@ -974,6 +1016,12 @@ void TxReconciliationTracker::HandleExtensionRequest(NodeId peer_id)\n     m_impl->HandleExtensionRequest(peer_id);\n }\n \n+bool TxReconciliationTracker::FinalizeInitByThem(NodeId peer_id, bool recon_result,\n+    const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing)\n+{\n+    return m_impl->FinalizeInitByThem(peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+}\n+\n void TxReconciliationTracker::ForgetPeer(NodeId peer_id)\n {\n     m_impl->ForgetPeer(peer_id);"
      },
      {
        "sha": "c06753118a1abd41f4d57c70a7fb789199089b72",
        "filename": "src/txreconciliation.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4caf1f19fe5858e946da346f06ca0ee3e35f6/src/txreconciliation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4caf1f19fe5858e946da346f06ca0ee3e35f6/src/txreconciliation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txreconciliation.h?ref=90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
        "patch": "@@ -123,6 +123,16 @@ class TxReconciliationTracker {\n      */\n     void HandleExtensionRequest(NodeId peer_id);\n \n+    /**\n+     * Step 4. Once we received a signal of reconciliation finalization with a given result from the\n+     * initiating peer, announce the following transactions:\n+     * - in case of a failure, all transactions we had for that peer\n+     * - in case of a success, transactions the peer asked for by short id (ask_shortids)\n+     * Return false if the peer seems to violate the protocol.\n+     */\n+    bool FinalizeInitByThem(NodeId peer_id, bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing);\n+\n     // Helpers\n \n     /**"
      }
    ]
  },
  {
    "sha": "1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
    "node_id": "C_kwDOABII59oAKDFiYTNlMzZkYzk2YjYxOTcxNTI0OGJmNmFhZDdjMWNlN2MwYmY3Mjc",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T10:29:31Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-11-29T13:18:29Z"
      },
      "message": "Handle reconciliation finalization message\n\nOnce a peer tells us reconciliation is done, we should behave as follows:\n- if it was successful, just respond them with the transactions they asked\n  by short ID.\n- if it was a full failure, respond with all local transactions from the reconciliation\n  set snapshot\n- if it was a partial failure (only low or high part was failed after a bisection),\n  respond with all transactions which were asked for by short id,\n  and announce local txs which belong to the failed chunk.",
      "tree": {
        "sha": "2b6489a205d1c8b3e9c8eba4d24588c31b320f32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b6489a205d1c8b3e9c8eba4d24588c31b320f32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90d4caf1f19fe5858e946da346f06ca0ee3e35f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/90d4caf1f19fe5858e946da346f06ca0ee3e35f6"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "aa61bf92c801af13c587d77f4d0b58e65b6af8da",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
        "patch": "@@ -4162,6 +4162,26 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Among transactions requested by short ID here, we should send only those transactions\n+    // sketched (stored in local set snapshot), because otherwise we would leak privacy (mempool content).\n+    if (msg_type == NetMsgType::RECONCILDIFF) {\n+        bool recon_result;\n+        std::vector<uint32_t> ask_shortids;\n+        vRecv >> recon_result >> ask_shortids;\n+\n+        std::vector<uint256> remote_missing;\n+        bool valid_finalization = m_reconciliation.FinalizeInitByThem(pfrom.GetId(), recon_result, ask_shortids, remote_missing);\n+        if (valid_finalization) {\n+            AnnounceTxs(remote_missing, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation finalization violating the protocol.\n+            LogPrint(BCLog::NET, \"reconcildiff from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+        return;\n+    }\n+\n     // Ignore unknown commands for extensibility\n     LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(msg_type), pfrom.GetId());\n     return;"
      }
    ]
  },
  {
    "sha": "cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
    "node_id": "C_kwDOABII59oAKGNiOWRkNmVmNWI4ZDEwMTFkNTNiYzUzODA2YTY1ZGZhYzllZjk3OTU",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-07-06T07:09:30Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-12-01T13:25:07Z"
      },
      "message": "Add tx reconciliation functional tests",
      "tree": {
        "sha": "6d7a7445f3549cc6ab29dcdd5cc182c14a9afbb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d7a7445f3549cc6ab29dcdd5cc182c14a9afbb0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1ba3e36dc96b619715248bf6aad7c1ce7c0bf727"
      }
    ],
    "stats": {
      "total": 918,
      "additions": 916,
      "deletions": 2
    },
    "files": [
      {
        "sha": "d19f575b26b958b6423ca13251584fff691a9fe3",
        "filename": "test/functional/p2p_txrecon_initiator.py",
        "status": "added",
        "additions": 305,
        "deletions": 0,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/p2p_txrecon_initiator.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/p2p_txrecon_initiator.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_txrecon_initiator.py?ref=cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "patch": "@@ -0,0 +1,305 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay (node initiates)\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    msg_getdata, msg_sketch, MSG_WTX, CInv,\n+)\n+\n+from test_framework.util import assert_equal\n+\n+from test_framework.p2p_txrecon import (\n+    BYTES_PER_SKETCH_CAPACITY, create_sketch, get_short_id,\n+    ReconciliationTest, TxReconTestP2PConn\n+)\n+\n+# Taken from net_processing.cpp\n+INVENTORY_BROADCAST_INTERVAL = 1\n+RECON_REQUEST_INTERVAL = 8\n+\n+class TestTxReconResponderP2PConn(TxReconTestP2PConn):\n+    # This object simulates a reconciliation responder, which will be queried by\n+    # the Bitcoin Core node being tested.\n+    def __init__(self):\n+        super().__init__(False)\n+        self.last_sendrecon = []\n+        self.last_tx = []\n+        self.last_reqreconcil = []\n+        self.last_reconcildiff = []\n+        self.last_reqsketchext = []\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def on_reqrecon(self, message):\n+        self.last_reqreconcil.append(message)\n+\n+    def on_reqsketchext(self, message):\n+        self.last_reqsketchext.append(message)\n+\n+    def on_reconcildiff(self, message):\n+        self.last_reconcildiff.append(message)\n+\n+    def send_sketch(self, skdata):\n+        msg = msg_sketch()\n+        msg.skdata = skdata\n+        self.send_message(msg)\n+\n+    def send_getdata(self, ask_wtxids):\n+        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])\n+        self.send_message(msg)\n+\n+\n+class ReconciliationInitiatorTest(ReconciliationTest):\n+\n+    def set_test_params(self):\n+        super().set_test_params()\n+\n+    # Returns False if we received an empty sketch instead of the expected non-empty sketch, likely\n+    # because the transactions were added to the set after the reconciliation initiation.\n+    def receive_reqreconcil(self, expected_set_size):\n+        time.sleep(0.1)\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+\n+        def received_reqreconcil():\n+            return (len(self.test_node.last_reqreconcil) >= 1)\n+        self.wait_until(received_reqreconcil, timeout=30)\n+\n+        # Some of the transactions are set for low-fanout to the mininode, so they won't be\n+        # in the set. The caller should check that they are indeed announced later.\n+        node_set_size = self.test_node.last_reqreconcil[-1].set_size\n+        assert(node_set_size <= expected_set_size)\n+        self.test_node.last_reqreconcil = []\n+        return node_set_size\n+\n+    def transmit_sketch(self, txs_to_sketch, extension, capacity):\n+        short_txids = [get_short_id(tx, self.compute_salt())\n+                       for tx in txs_to_sketch]\n+        if extension:\n+            sketch = create_sketch(\n+                short_txids, capacity * 2)[int(capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            self.test_node.last_full_mininode_size = len(txs_to_sketch)\n+            sketch = create_sketch(short_txids, capacity)\n+        self.test_node.send_sketch(sketch)\n+\n+    def handle_extension_request(self):\n+        def received_reqsketchext():\n+            return (len(self.test_node.last_reqsketchext) == 1)\n+        self.wait_until(received_reqsketchext, timeout=30)\n+        self.test_node.last_reqsketchext = []\n+\n+    def handle_reconciliation_finalization(self, expected_success,\n+                                           expected_requested_txs,\n+                                           might_be_requested_txs):\n+        expected_requested_shortids = [get_short_id(\n+            tx, self.compute_salt()) for tx in expected_requested_txs]\n+\n+        def received_reconcildiff():\n+            return (len(self.test_node.last_reconcildiff) == 1)\n+        self.wait_until(received_reconcildiff, timeout=30)\n+        success = self.test_node.last_reconcildiff[0].success\n+        assert_equal(success, int(expected_success))\n+        # They could ask for more, if they didn't add some transactions to the reconciliation set,\n+        # but set it to low-fanout to us instead.\n+        assert(set(expected_requested_shortids).\n+               issubset(set(self.test_node.last_reconcildiff[0].ask_shortids)))\n+        extra_requested_shortids = set(\n+            self.test_node.last_reconcildiff[0].ask_shortids) - set(expected_requested_shortids)\n+        might_be_requested_shortids = [get_short_id(\n+            tx, self.compute_salt()) for tx in might_be_requested_txs]\n+        assert(extra_requested_shortids.issubset(might_be_requested_shortids))\n+        self.test_node.last_reconcildiff = []\n+\n+    def request_transactions(self, txs_to_request):\n+        # Make sure there were no unexpected transactions received before\n+        assert_equal(self.test_node.last_tx, [])\n+\n+        wtxids_to_request = [tx.calc_sha256(\n+            with_witness=True) for tx in txs_to_request]\n+        self.test_node.send_getdata(wtxids_to_request)\n+\n+        def received_tx():\n+            return (len(self.test_node.last_tx) == len(txs_to_request))\n+        self.wait_until(received_tx, timeout=30)\n+        assert_equal(set([tx.calc_sha256(True)\n+                     for tx in txs_to_request]), set(self.test_node.last_tx))\n+        self.test_node.last_tx = []\n+\n+    def expect_announcements(self, expected_txs, extra_candidates_txs):\n+        expected_wtxids = [tx.calc_sha256(True)\n+                           for tx in expected_txs]\n+        extra_candidates_wtxids = [tx.calc_sha256(True)\n+                                   for tx in extra_candidates_txs]\n+        self.wait_until(lambda: (set(expected_wtxids).issubset(\n+            set(self.test_node.last_inv))), timeout=30)\n+        extra_received_wtxids = set(\n+            self.test_node.last_inv) - set(expected_wtxids)\n+        assert(extra_received_wtxids.issubset(extra_candidates_wtxids))\n+        self.test_node.last_inv = []\n+        return extra_received_wtxids\n+\n+    #\n+    # Actual test cases\n+    #\n+\n+    def reconciliation_initiator_flow(self, n_node, n_mininode, n_shared,\n+                                      capacity, terminate_after_initial,\n+                                      expected_success):\n+\n+        # Generate and submit transactions.\n+        mininode_unique_txs, node_unique_txs, shared_txs = self.generate_txs(\n+            n_mininode, n_node, n_shared)\n+        mininode_txs = mininode_unique_txs + shared_txs\n+        node_txs = node_unique_txs + shared_txs\n+        time.sleep(0.1)\n+        self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 3)\n+\n+        # First, check that the node sends a reconciliation request, claiming to have some\n+        # transactions in their set. Sending out a request always happens after adding to the set\n+        # per net_processing.cpp.\n+        #\n+        # We need to skip the entire RECON_REQUEST_INTERVAL first because the first request\n+        # will be issued as if the queue had only one peer (because it is called before other\n+        # peers are added).\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(expected_set_size=len(node_txs))\n+\n+        # We check that transactions received by the node during the reconciliation round\n+        # are not lost, and will be announced either during the reconciliation (low-fanout) or\n+        # after it (next reconciliation round).\n+        more_node_txs = []\n+        extra_received_wtxids = []\n+        if terminate_after_initial:\n+            # Respond to the node with a sketch of a given capacity over given transactions.\n+            self.transmit_sketch(txs_to_sketch=mininode_txs,\n+                                 extension=False, capacity=capacity)\n+\n+            # Add extra transactions, and let them trigger adding to recon sets or low-fanout.\n+            more_node_txs.extend(self.generate_txs(0, 10, 0)[1])\n+            time.sleep(0.1)\n+            self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 3)\n+\n+            if expected_success:\n+                # Expect the node to guess and request the transactions which it is missing,\n+                # and possibly some of the shared transactions which were set for low-fanout by\n+                # the node, and thus indicated as missing by reconciliation.\n+                self.handle_reconciliation_finalization(expected_success=True,\n+                                                        expected_requested_txs=mininode_unique_txs,\n+                                                        might_be_requested_txs=shared_txs)\n+            else:\n+                # This happens only if one of the sets (or both) was empty.\n+                # The node can't guess what it's missing, so it won't explicitly request anything.\n+                self.handle_reconciliation_finalization(expected_success=False,\n+                                                        expected_requested_txs=[],\n+                                                        might_be_requested_txs=[])\n+\n+            # A node would also announce transactions it has for us (the mininode). It could\n+            # also announce extra transactions here:\n+            # - shared transactions which were set for low-fanout instead of reconciliation\n+            # - transactions received during the reconciliation round and set for low-fanout\n+            # These two types of announcements are returned.\n+            extra_received_wtxids = self.expect_announcements(\n+                node_unique_txs, shared_txs + more_node_txs)\n+        else:\n+            # Respond to the node with a sketch of a given capacity over given transactions.\n+            self.transmit_sketch(txs_to_sketch=mininode_txs,\n+                                 extension=False, capacity=capacity)\n+\n+            # Add extra transactions, and let them trigger adding to recon sets or low-fanout.\n+            more_node_txs.extend(self.generate_txs(0, 4, 0)[1])\n+            time.sleep(0.1)\n+            self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 3)\n+\n+            # Expect the node to request sketch extension, because the sketch we sent to it\n+            # was insufficient.\n+            self.handle_extension_request()\n+\n+            # Add extra transactions, and let them trigger adding to recon sets or low-fanout.\n+            more_node_txs.extend(self.generate_txs(0, 4, 0)[1])\n+            time.sleep(0.1)\n+            self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 3)\n+\n+            # Send a sketch extension to the node.\n+            self.transmit_sketch(txs_to_sketch=mininode_txs,\n+                                 extension=True, capacity=capacity)\n+            if expected_success:\n+                # Expect the node to guess and request the transactions which it is missing,\n+                # and possibly some of the shared transactions which were set for low-fanout by\n+                # the node, and thus indicated as missing by reconciliation.\n+                self.handle_reconciliation_finalization(expected_success=True,\n+                                                        expected_requested_txs=mininode_unique_txs,\n+                                                        might_be_requested_txs=shared_txs)\n+\n+                # A node would also announce transactions it has for us (the mininode). It could\n+                # also announce extra transactions here:\n+                # - shared transactions which were set for low-fanout instead of reconciliation\n+                # - transactions received during the reconciliation round and set for low-fanout\n+                # These two types of announcements are returned.\n+                extra_received_wtxids = self.expect_announcements(\n+                    node_unique_txs, shared_txs + more_node_txs)\n+            else:\n+                # The node can't guess what it's missing, so it won't explicitly request anything.\n+                self.handle_reconciliation_finalization(expected_success=False,\n+                                                        expected_requested_txs=[],\n+                                                        might_be_requested_txs=[])\n+\n+                # A node would also announce transactions it has for us (the mininode). It could\n+                # also announce extra transactions here:\n+                # - transactions received during the reconciliation round and set for low-fanout\n+                # These announcements are returned.\n+                extra_received_wtxids = self.expect_announcements(\n+                    node_txs, more_node_txs)\n+\n+        # Request the transactions the node announced.\n+        self.request_transactions(node_unique_txs)\n+\n+        # Check those additional transactions are not lost. First, filter out those which were\n+        # already announced during the reconciliation round.\n+        more_node_txs = [tx for tx in more_node_txs if tx.calc_sha256(\n+            with_witness=True) not in extra_received_wtxids]\n+\n+        if more_node_txs != []:\n+            # Make a regular early-exit reconciliation round, which would trigger all transactions\n+            # from the set to be announced\n+            self.receive_reqreconcil(expected_set_size=len(more_node_txs))\n+            self.transmit_sketch(txs_to_sketch=[], extension=False, capacity=0)\n+            self.handle_reconciliation_finalization(expected_success=False,\n+                                                    expected_requested_txs=[],\n+                                                    might_be_requested_txs=[])\n+\n+            # Check that all of those extra transactions are announced (either via low-fanout,\n+            # or via either of the 2 possible reconciliation rounds). We also check that no\n+            # other transactions were announced (second parameter).\n+            self.expect_announcements(more_node_txs, [])\n+\n+    def test_recon_initiator(self):\n+        self.test_node = self.nodes[0].add_outbound_p2p_connection(\n+            TestTxReconResponderP2PConn(), p2p_idx=0)\n+        self.test_node.sync_with_ping()\n+\n+        # 20 at node, 0 at mininode, 0 shared, early exit.\n+        self.reconciliation_initiator_flow(20, 0, 0, 0, True, False)\n+        # 0 at node, 20 at mininode, 0 shared, early exit.\n+        self.reconciliation_initiator_flow(0, 20, 0, 0, True, False)\n+        # 20 at node, 20 at mininode, 10 shared, initial reconciliation succeeds\n+        self.reconciliation_initiator_flow(20, 20, 10, 54, True, True)\n+        # 20 at node, 20 at mininode, 10 shared, initial reconciliation fails,\n+        # extension succeeds\n+        self.reconciliation_initiator_flow(20, 20, 10, 27, False, True)\n+        # 20 at node, 20 at mininode, 10 shared, initial reconciliation fails,\n+        # extension fails\n+        self.reconciliation_initiator_flow(20, 20, 10, 10, False, False)\n+\n+\n+    def run_test(self):\n+        super().run_test()\n+        self.test_recon_initiator()\n+\n+\n+if __name__ == '__main__':\n+    ReconciliationInitiatorTest().main()"
      },
      {
        "sha": "c207df4bc78117bfa02a3eaaeb7307dbd5e59891",
        "filename": "test/functional/p2p_txrecon_responder.py",
        "status": "added",
        "additions": 263,
        "deletions": 0,
        "changes": 263,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/p2p_txrecon_responder.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/p2p_txrecon_responder.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_txrecon_responder.py?ref=cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "patch": "@@ -0,0 +1,263 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay (node responds)\"\"\"\n+\n+import random\n+import time\n+\n+from test_framework.messages import (\n+    msg_reqrecon, msg_reqsketchext, msg_reconcildiff,\n+)\n+\n+from test_framework.util import assert_equal\n+\n+from test_framework.p2p_txrecon import (\n+    BYTES_PER_SKETCH_CAPACITY, create_sketch, get_short_id, Q_PRECISION,\n+    estimate_capacity, RECON_Q, ReconciliationTest, TxReconTestP2PConn\n+)\n+\n+# Taken from net_processing.cpp\n+RECON_RESPONSE_INTERVAL = 1\n+# A caller should allow a lot of extra time to handle Poisson delays.\n+INVENTORY_BROADCAST_INTERVAL = 2\n+\n+\n+class TestTxReconInitiatorP2PConn(TxReconTestP2PConn):\n+    # This object simulates a reconciliation initiator, which will communicate with\n+    # the Bitcoin Core node being tested.\n+    def __init__(self):\n+        super().__init__(True)\n+        self.last_sketch = []\n+\n+    def send_reqrecon(self, set_size, q):\n+        msg = msg_reqrecon()\n+        msg.set_size = set_size\n+        msg.q = q\n+        self.send_message(msg)\n+\n+    def on_sketch(self, message):\n+        self.last_sketch.append(message)\n+\n+    def send_reqsketchext(self):\n+        msg = msg_reqsketchext()\n+        self.send_message(msg)\n+\n+    def send_reconcildiff(self, success, ask_shortids):\n+        msg = msg_reconcildiff()\n+        msg.success = success\n+        msg.ask_shortids = ask_shortids\n+        self.send_message(msg)\n+\n+\n+class ReconciliationResponderTest(ReconciliationTest):\n+    def set_test_params(self):\n+        super().set_test_params()\n+\n+    # Check that the node announced a sketch, and return an estimate of how many transaction\n+    # the node had it the set, based on:\n+    # - the sketch capacity\n+    # - reconciliation request it handled\n+    def expect_sketch(self, n_mininode):\n+        # Give time to receive request and start the response delay timer.\n+        self.proceed_in_time(RECON_RESPONSE_INTERVAL + 2)\n+        time.sleep(0.1)\n+\n+        def received_sketch():\n+            # We might have received several unintented sketches before. Consider the latest.\n+            return (len(self.test_node.last_sketch) == 1)\n+        self.wait_until(received_sketch, timeout=30)\n+\n+        skdata = self.test_node.last_sketch[0].skdata\n+        if skdata == []:\n+            return 0\n+\n+        capacity = len(skdata) / BYTES_PER_SKETCH_CAPACITY\n+        # Infer sketched txs based on the diff formula\n+        # capacity = abs(their - ours) + RECON_Q * min(theirs, ours) + 1\n+        # Note that it's impossible to infer this 100% accurate and sometimes the result is\n+        # off-by-one. This should be handled later on.\n+        sketched_txs = capacity - 1 - int(RECON_Q * n_mininode) + n_mininode\n+        return sketched_txs\n+\n+    # Check that the node announced the exact sketch we expected (of the expetcted capacity,\n+    # over the expected transactions, and initial/extension)\n+    def check_sketch(self, n_mininode, expected_transactions, extension):\n+        expected_short_ids = [get_short_id(\n+            tx, self.compute_salt()) for tx in expected_transactions]\n+\n+        if n_mininode == 0 or len(expected_transactions) == 0:\n+            # A peer should send us an empty sketch to trigger reconciliation termination.\n+            # This should never happen in the extension phase.\n+            assert(not extension)\n+            expected_capacity = 0\n+        else:\n+            expected_capacity = estimate_capacity(\n+                n_mininode, len(expected_transactions))\n+\n+        if extension:\n+            expected_sketch = create_sketch(\n+                expected_short_ids, expected_capacity * 2)[\n+                int(expected_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            expected_sketch = create_sketch(\n+                expected_short_ids, expected_capacity)\n+\n+        assert_equal(\n+            self.test_node.last_sketch[0].skdata, expected_sketch)\n+        self.test_node.last_sketch = []\n+\n+    # Check that the node announced N transactions as we expected (or N+1, see below).\n+    # Return the announced transactions.\n+    def handle_announcements(self, n_expected):\n+        if n_expected <= 0:\n+            return []\n+\n+        def received_inv():\n+            # The second condition handles the case where we can't accurately infer how many\n+            # transactions were sketched based on the capacity, and thus how many are fanouted here.\n+            return len(self.test_node.last_inv) == n_expected or len(self.test_node.last_inv) == n_expected + 1\n+\n+        self.wait_until(received_inv, timeout=30)\n+        announced_invs = self.test_node.last_inv\n+        self.test_node.last_inv = []\n+        return announced_invs\n+\n+    # Send reconciliation finalization message to the node, and request some of its transactions\n+    # based on their shortids.\n+    def finalize_reconciliation(self, success, txs_to_request):\n+        ask_shortids = [get_short_id(tx, self.compute_salt())\n+                        for tx in txs_to_request]\n+        self.test_node.send_reconcildiff(success, ask_shortids)\n+\n+    #\n+    # Actual test cases\n+    #\n+\n+    def reconciliation_responder_flow(self, n_mininode, n_node, initial_result,\n+                                      result):\n+        # Generate transactions and let them trigger announcement (low-fanout or adding\n+        # to recon set).\n+        _, node_txs, _ = self.generate_txs(n_mininode, n_node, 0)\n+        self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 10)\n+\n+        # We will announce extra transactions which should not be lost during the\n+        # reconciliation round, and should be relayed along or in the next round.\n+        more_node_txs = []\n+        # We track transactions which are announced during the reconciliation round.\n+        announced_invs = []\n+\n+        self.test_node.send_reqrecon(n_mininode, int(RECON_Q * Q_PRECISION))\n+        time.sleep(0.1)\n+        # The typical check consists of 3 parts:\n+        # 1. Receive a sketch of some size N: expect_sketch.\n+        # 2. Based on the capacity of that sketch, infer how many transactions should be announced\n+        #    by the node, as opposed to be included in that sketch (1).\n+        #    Receive them in handle_announcements.\n+        # 3. Check that the sketch we received in (1) corresponds to all the transactions the node\n+        #    had except for those announced in (2): check_sketch.\n+        n_sketched_txs = self.expect_sketch(n_mininode)\n+\n+        # Some transactions would be announced via fanout right away, so they won't be included in\n+        # the sketch. This block handles only cases where both nodes had transactions, because\n+        # we infer how many transactions should be relayed based on the sketch. In cases when there\n+        # are no transactions, the sketch is always empty, but that doesn't mean all transactions\n+        # are fanouted.\n+        #\n+        # It's still possible some transactions are announced, but we will handle that later.\n+        if n_mininode != 0 and n_node != 0:\n+            announced_invs += self.handle_announcements(\n+                n_node - n_sketched_txs)\n+            node_txs = [tx for tx in node_txs if tx.calc_sha256(\n+                with_witness=True) not in announced_invs]\n+\n+        self.check_sketch(n_mininode, node_txs, False)\n+\n+        more_node_txs.extend(self.generate_txs(0, 8, 0)[1])\n+        self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 10)\n+\n+        if not initial_result and n_mininode != 0 and n_node != 0:\n+            # Request sketch extension and check that we receive what was expected.\n+            # Does not work when one of the sets is empty, because the node knows it's pointless.\n+            self.test_node.send_reqsketchext()\n+            self.expect_sketch(n_mininode)\n+            self.check_sketch(n_mininode, node_txs, True)\n+\n+        more_node_txs.extend(self.generate_txs(0, 8, 0)[1])\n+        self.proceed_in_time(INVENTORY_BROADCAST_INTERVAL + 10)\n+\n+        expected_txs_announced = []\n+        if result:\n+            # In the success case, we query the node for a subset of transactions they have\n+            # within the finalization message.\n+            expected_txs_announced = random.sample(node_txs, 3)\n+            self.finalize_reconciliation(True, expected_txs_announced)\n+        else:\n+            # In the failure case, the node should announce all transactions it has.\n+            self.finalize_reconciliation(False, [])\n+            expected_txs_announced = node_txs\n+\n+        # Receive expected announcements from the node.\n+        expected_wtxids = [tx.calc_sha256(\n+            with_witness=True) for tx in expected_txs_announced]\n+\n+        def received_inv():\n+            # These may include extra transactions: in addition to the expected txs,\n+            # a peer might INV us extra transactions they received during this round.\n+            return (set(expected_wtxids).issubset(set(self.test_node.last_inv)))\n+        self.wait_until(received_inv, timeout=30)\n+        announced_invs += self.test_node.last_inv\n+        self.test_node.last_inv = []\n+\n+        # Check those additional transactions are not lost.\n+        # First, filter those which were already announced.\n+        more_node_txs = [tx for tx in more_node_txs if tx.calc_sha256(\n+            with_witness=True) not in announced_invs]\n+\n+        # Trigger the regular reconciliation event at the node.\n+        self.test_node.send_reqrecon(1, int(RECON_Q * Q_PRECISION))\n+        time.sleep(0.1)\n+\n+        n_sketched_txs = self.expect_sketch(1)\n+        announced_invs += self.handle_announcements(\n+            len(more_node_txs) - n_sketched_txs)\n+\n+        more_node_txs = [tx for tx in more_node_txs if tx.calc_sha256(\n+            with_witness=True) not in announced_invs]\n+        self.check_sketch(1, more_node_txs, False)\n+        self.finalize_reconciliation(True, txs_to_request=[])\n+\n+    def test_recon_responder(self):\n+        # These node will consume some of the low-fanout announcements.\n+        for _ in range(4):\n+            fanout_consumer = self.nodes[0].add_p2p_connection(TestTxReconInitiatorP2PConn())\n+            fanout_consumer.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestTxReconInitiatorP2PConn())\n+        self.test_node.wait_for_verack()\n+\n+        # Early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(0, 15, False, False)\n+        # Early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(20, 0, False, False)\n+        # # Initial reconciliation succeeds\n+        self.reconciliation_responder_flow(3, 15, True, False)\n+        # # Initial reconciliation fails, extension succeeds\n+        self.reconciliation_responder_flow(3, 15, False, True)\n+        # # Initial reconciliation fails, extension fails\n+        self.reconciliation_responder_flow(3, 15, False, False)\n+\n+        # Test disconnect on RECONCILDIFF violation\n+        self.test_node = self.nodes[0].add_p2p_connection(TestTxReconInitiatorP2PConn())\n+        self.test_node.wait_for_verack()\n+        self.finalize_reconciliation(True, [])\n+        self.test_node.wait_for_disconnect()\n+\n+    def run_test(self):\n+        super().run_test()\n+        self.test_recon_responder()\n+\n+\n+if __name__ == '__main__':\n+    ReconciliationResponderTest().main()"
      },
      {
        "sha": "e4bbb6b7a9ecd342f0623e7446ed67b0a7df5b8d",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "patch": "@@ -115,6 +115,11 @@ def ser_uint256(u):\n         u >>= 32\n     return rs\n \n+def deser_uint32(f):\n+    return struct.unpack(\"<I\", f.read(4))[0]\n+\n+def ser_uint32(u):\n+    return b\"\" + struct.pack(\"<I\", u & 0xFFFFFFFF)\n \n def uint256_from_str(s):\n     r = 0\n@@ -173,6 +178,34 @@ def ser_uint256_vector(l):\n         r += ser_uint256(i)\n     return r\n \n+def deser_uint32_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = deser_uint32(f)\n+        r.append(t)\n+    return r\n+\n+def ser_uint32_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += ser_uint32(i)\n+    return r\n+\n+def deser_uint8_vector(f):\n+    nit = deser_compact_size(f)\n+    r = []\n+    for i in range(nit):\n+        t = struct.unpack(\"<B\", f.read(1))[0]\n+        r.append(t)\n+    return r\n+\n+def ser_uint8_vector(l):\n+    r = ser_compact_size(len(l))\n+    for i in l:\n+        r += struct.pack(\"<B\", i & 0xff)\n+    return r\n+\n \n def deser_string_vector(f):\n     nit = deser_compact_size(f)\n@@ -1814,3 +1847,108 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_cfcheckpt(filter_type={:#x}, stop_hash={:x})\".format(\n             self.filter_type, self.stop_hash)\n+\n+class msg_sendrecon:\n+    __slots__ = (\"initiator\", \"responder\", \"version\", \"salt\")\n+    msgtype = b\"sendrecon\"\n+\n+    def __init__(self):\n+        self.initiator = False\n+        self.responder = False\n+        self.version = 0\n+        self.salt = 0\n+\n+    def deserialize(self, f):\n+        self.initiator = struct.unpack(\"<?\", f.read(1))[0]\n+        self.responder = struct.unpack(\"<?\", f.read(1))[0]\n+        self.version = struct.unpack(\"<I\", f.read(4))[0]\n+        self.salt = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<?\", self.initiator)\n+        r += struct.pack(\"<?\", self.responder)\n+        r += struct.pack(\"<I\", self.version)\n+        r += struct.pack(\"<Q\", self.salt)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sendrecon(initiator=%i, responder=%i, version=%lu, salt=%lu)\" %\\\n+            (self.initiator, self.responder, self.version, self.salt)\n+\n+class msg_reqrecon:\n+    __slots__ = (\"set_size\", \"q\")\n+    msgtype = b\"reqrecon\"\n+\n+    def __init__(self):\n+        self.set_size = 0\n+        self.q = 0\n+\n+    def deserialize(self, f):\n+        self.set_size = struct.unpack(\"<H\", f.read(2))[0]\n+        self.q = struct.unpack(\"<H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<I\", self.set_size)\n+        r += struct.pack(\"<I\", self.q)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reqrecon(set_size=%i, q=%i)\" % (self.set_size, self.q)\n+\n+class msg_sketch:\n+    __slots__ = (\"skdata\")\n+    msgtype = b\"sketch\"\n+\n+    def __init__(self):\n+        self.skdata = []\n+\n+    def deserialize(self, f):\n+        self.skdata = deser_uint8_vector(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += ser_uint8_vector(self.skdata)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_sketch(sketch_size=%i)\" % (len(self.skdata))\n+\n+class msg_reqsketchext:\n+    __slots__ = ()\n+    msgtype = b\"reqsketchext\"\n+\n+    def __init__(self):\n+        return\n+\n+    def deserialize(self, f):\n+        return\n+\n+    def serialize(self):\n+        r = b\"\"\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reqsketchext\"\n+\n+class msg_reconcildiff:\n+    __slots__ = (\"success\", \"ask_shortids\")\n+    msgtype = b\"reconcildiff\"\n+\n+    def __init__(self):\n+        self.success = 0\n+        self.ask_shortids = []\n+\n+    def deserialize(self, f):\n+        self.success = struct.unpack(\"<B\", f.read(1))[0]\n+        self.ask_shortids = deser_uint32_vector(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += struct.pack(\"<B\", self.success)\n+        r += ser_uint32_vector(self.ask_shortids)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reconcildiff(success=%i,ask_shortids=%i)\" % (self.success, len(self.ask_shortids))"
      },
      {
        "sha": "0dddd0d7e7cc144b4e450cf3507457a6acfd4300",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "patch": "@@ -56,8 +56,13 @@\n     msg_notfound,\n     msg_ping,\n     msg_pong,\n+    msg_reconcildiff,\n+    msg_reqrecon,\n+    msg_reqsketchext,\n     msg_sendaddrv2,\n     msg_sendcmpct,\n+    msg_sendrecon,\n+    msg_sketch,\n     msg_sendheaders,\n     msg_tx,\n     MSG_TX,\n@@ -81,8 +86,8 @@\n # The minimum P2P version that this test framework supports\n MIN_P2P_VERSION_SUPPORTED = 60001\n # The P2P version that this test framework implements and sends in its `version` message\n-# Version 70016 supports wtxid relay\n-P2P_VERSION = 70016\n+# Version 70017 supports tx reconciliations\n+P2P_VERSION = 70017\n # The services that this test framework offers in its `version` message\n P2P_SERVICES = NODE_NETWORK | NODE_WITNESS\n # The P2P user agent string that this test framework sends in its `version` message\n@@ -115,9 +120,14 @@\n     b\"notfound\": msg_notfound,\n     b\"ping\": msg_ping,\n     b\"pong\": msg_pong,\n+    b\"reconcildiff\": msg_reconcildiff,\n+    b\"reqrecon\": msg_reqrecon,\n+    b\"reqsketchext\": msg_reqsketchext,\n     b\"sendaddrv2\": msg_sendaddrv2,\n     b\"sendcmpct\": msg_sendcmpct,\n     b\"sendheaders\": msg_sendheaders,\n+    b\"sendrecon\": msg_sendrecon,\n+    b\"sketch\": msg_sketch,\n     b\"tx\": msg_tx,\n     b\"verack\": msg_verack,\n     b\"version\": msg_version,\n@@ -413,6 +423,7 @@ def on_pong(self, message): pass\n     def on_sendaddrv2(self, message): pass\n     def on_sendcmpct(self, message): pass\n     def on_sendheaders(self, message): pass\n+    def on_sendrecon(self, message): pass\n     def on_tx(self, message): pass\n     def on_wtxidrelay(self, message): pass\n "
      },
      {
        "sha": "66f2e469d949711a7ad9a967e1d2955a195b7ff4",
        "filename": "test/functional/test_framework/p2p_txrecon.py",
        "status": "added",
        "additions": 195,
        "deletions": 0,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_framework/p2p_txrecon.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_framework/p2p_txrecon.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p_txrecon.py?ref=cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "patch": "@@ -0,0 +1,195 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Helpers to test reconciliation-based transaction relay, both initiator and responder roles\"\"\"\n+\n+import random\n+import time\n+from io import BytesIO\n+import struct\n+\n+\n+from test_framework.messages import (\n+    msg_inv, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon,\n+    MSG_WTX, MSG_BLOCK, CTransaction, CInv,\n+)\n+from test_framework.key import TaggedHash\n+from test_framework.p2p import P2PDataStore, P2PInterface\n+from test_framework.siphash import siphash256\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+# These parameters are suggested by the Erlay paper based on analysis and\n+# simulations.\n+RECON_Q = 0.1\n+\n+\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+\n+def get_short_id(tx, salt):\n+    (k0, k1) = salt\n+    wtxid = tx.calc_sha256(with_witness=True)\n+    s = siphash256(k0, k1, wtxid)\n+    return 1 + (s & 0xFFFFFFFF)\n+\n+\n+def estimate_capacity(theirs, ours):\n+    capacity = int(abs(theirs - ours) + RECON_Q * min(theirs, ours)) + 1\n+    if capacity < 9:\n+        # Poor man's minisketch_compute_capacity.\n+        capacity += 1\n+    return capacity\n+\n+\n+def generate_transaction(node, from_txid):\n+    to_address = node.getnewaddress()\n+    inputs = [{\"txid\": from_txid, \"vout\": 0}]\n+    outputs = {to_address: 0.0001}\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransactionwithwallet(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(bytes.fromhex(signresult['hex'])))\n+    tx.rehash()\n+    return tx\n+\n+\n+class TxReconTestP2PConn(P2PInterface):\n+    def __init__(self, be_initiator):\n+        super().__init__()\n+        self.recon_version = 1\n+        self.mininode_salt = random.randrange(0xffffff)\n+        self.be_initiator = be_initiator\n+        self.node_salt = 0\n+        self.last_inv = []\n+        self.last_tx = []\n+\n+    def on_version(self, message):\n+        if self.recon_version == 1:\n+            assert message.nVersion >= 70016, \"We expect the node to support WTXID relay\"\n+            self.send_message(msg_wtxidrelay())\n+            self.send_sendrecon(self.be_initiator, not self.be_initiator)\n+            self.send_message(msg_verack())\n+            self.nServices = message.nServices\n+        else:\n+            super().on_version(message)\n+\n+    def on_sendrecon(self, message):\n+        self.node_salt = message.salt\n+\n+    def on_reqrecon(self, message):\n+        # This is needed for dummy fanout destinations.\n+        pass\n+\n+    def on_inv(self, message):\n+        for inv in message.inv:\n+            if inv.type != MSG_BLOCK:  # ignore block invs\n+                self.last_inv.append(inv.hash)\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def send_sendrecon(self, initiator, responder):\n+        msg = msg_sendrecon()\n+        msg.salt = self.mininode_salt\n+        msg.version = self.recon_version\n+        msg.initiator = initiator\n+        msg.responder = responder\n+        self.send_message(msg)\n+\n+    def send_inv(self, inv_wtxids):\n+        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])\n+        self.send_message(msg)\n+\n+\n+class ReconciliationTest(BitcoinTestFramework):\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def proceed_in_time(self, jump_in_seconds):\n+        # We usually need the node to process some messages first.\n+        time.sleep(0.01)\n+        self.mocktime += jump_in_seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def compute_salt(self):\n+        RECON_STATIC_SALT = \"Tx Relay Salting\"\n+        salt1, salt2 = self.test_node.node_salt, self.test_node.mininode_salt\n+        if salt1 > salt2:\n+            salt1, salt2 = salt2, salt1\n+        salt = struct.pack(\"<Q\", salt1) + struct.pack(\"<Q\", salt2)\n+        h = TaggedHash(RECON_STATIC_SALT, salt)\n+        k0 = int.from_bytes(h[0:8], \"little\")\n+        k1 = int.from_bytes(h[8:16], \"little\")\n+        return k0, k1\n+\n+    def generate_txs(self, n_mininode_unique, n_node_unique, n_shared):\n+        mininode_unique = []\n+        node_unique = []\n+        shared = []\n+\n+        for i in range(n_mininode_unique):\n+            utxos = [u for u in self.nodes[0].listunspent(1) if u['confirmations'] > 0]\n+            tx = generate_transaction(self.nodes[0], utxos[i]['txid'])\n+            mininode_unique.append(tx)\n+\n+        for i in range(n_mininode_unique, n_mininode_unique + n_node_unique):\n+            utxos = [u for u in self.nodes[0].listunspent(1) if u['confirmations'] > 0]\n+            tx = generate_transaction(self.nodes[0], utxos[i]['txid'])\n+            node_unique.append(tx)\n+\n+        for i in range(n_mininode_unique + n_node_unique,\n+                       n_mininode_unique + n_node_unique + n_shared):\n+            utxos = [u for u in self.nodes[0].listunspent(1) if u['confirmations'] > 0]\n+            tx = generate_transaction(self.nodes[0], utxos[i]['txid'])\n+            shared.append(tx)\n+\n+        tx_submitter = self.nodes[0].add_p2p_connection(P2PDataStore())\n+        tx_submitter.wait_for_verack()\n+        tx_submitter.send_txs_and_test(\n+            node_unique + shared, self.nodes[0], success=True)\n+        tx_submitter.peer_disconnect()\n+\n+        return mininode_unique, node_unique, shared\n+\n+    def run_test(self):\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+        self.blocks = self.generate(self.nodes[0], 512)\n+        self.sync_blocks()"
      },
      {
        "sha": "b5709e7e9a18fdde6e804f0764c78c453d43cd38",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "patch": "@@ -109,6 +109,8 @@\n     'p2p_segwit.py',\n     'p2p_timeouts.py',\n     'p2p_tx_download.py',\n+    'p2p_txrecon_initiator.py',\n+    'p2p_txrecon_responder.py',\n     'mempool_updatefromblock.py',\n     'wallet_dump.py --legacy-wallet',\n     'feature_taproot.py --previous_release',"
      }
    ]
  },
  {
    "sha": "d60c791957f67b6fcd2d011bc4eff4be5414b288",
    "node_id": "C_kwDOABII59oAKGQ2MGM3OTE5NTdmNjdiNmZjZDJkMDExYmM0ZWZmNGJlNTQxNGIyODg",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-28T18:49:42Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-12-01T13:25:09Z"
      },
      "message": "Add fuzzing targets for reconciliation messages",
      "tree": {
        "sha": "33afd5572f8c225541a56238e1242658ab773d02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33afd5572f8c225541a56238e1242658ab773d02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d60c791957f67b6fcd2d011bc4eff4be5414b288",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60c791957f67b6fcd2d011bc4eff4be5414b288",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d60c791957f67b6fcd2d011bc4eff4be5414b288",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60c791957f67b6fcd2d011bc4eff4be5414b288/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb9dd6ef5b8d1011d53bc53806a65dfac9ef9795"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d2dd201f39a67e9d350525cff5b087abd12a179c",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d60c791957f67b6fcd2d011bc4eff4be5414b288/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d60c791957f67b6fcd2d011bc4eff4be5414b288/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=d60c791957f67b6fcd2d011bc4eff4be5414b288",
        "patch": "@@ -134,6 +134,11 @@ FUZZ_TARGET_MSG(pong);\n FUZZ_TARGET_MSG(sendaddrv2);\n FUZZ_TARGET_MSG(sendcmpct);\n FUZZ_TARGET_MSG(sendheaders);\n+FUZZ_TARGET_MSG(sendrecon);\n+FUZZ_TARGET_MSG(sketch);\n+FUZZ_TARGET_MSG(reconcildiff);\n+FUZZ_TARGET_MSG(reqrecon);\n+FUZZ_TARGET_MSG(reqsketchext);\n FUZZ_TARGET_MSG(tx);\n FUZZ_TARGET_MSG(verack);\n FUZZ_TARGET_MSG(version);"
      }
    ]
  },
  {
    "sha": "a70142516167b27bb7d5849d78b8ba15ed2896da",
    "node_id": "C_kwDOABII59oAKGE3MDE0MjUxNjE2N2IyN2JiN2Q1ODQ5ZDc4YjhiYTE1ZWQyODk2ZGE",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-24T09:06:24Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-12-01T13:25:09Z"
      },
      "message": "Add unit tests for tx reconciliation",
      "tree": {
        "sha": "b3d4fcf83d12f1dd11108b64d9d32e3de4f987bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b3d4fcf83d12f1dd11108b64d9d32e3de4f987bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a70142516167b27bb7d5849d78b8ba15ed2896da",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a70142516167b27bb7d5849d78b8ba15ed2896da",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a70142516167b27bb7d5849d78b8ba15ed2896da",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a70142516167b27bb7d5849d78b8ba15ed2896da/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d60c791957f67b6fcd2d011bc4eff4be5414b288",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d60c791957f67b6fcd2d011bc4eff4be5414b288",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d60c791957f67b6fcd2d011bc4eff4be5414b288"
      }
    ],
    "stats": {
      "total": 657,
      "additions": 657,
      "deletions": 0
    },
    "files": [
      {
        "sha": "101039e66a8d2835e6a1b708cc7e615007eae1bb",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a70142516167b27bb7d5849d78b8ba15ed2896da/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a70142516167b27bb7d5849d78b8ba15ed2896da/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=a70142516167b27bb7d5849d78b8ba15ed2896da",
        "patch": "@@ -140,6 +140,7 @@ BITCOIN_TESTS =\\\n   test/transaction_tests.cpp \\\n   test/txindex_tests.cpp \\\n   test/txpackage_tests.cpp \\\n+  test/txreconciliation_tests.cpp \\\n   test/txrequest_tests.cpp \\\n   test/txvalidation_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\"
      },
      {
        "sha": "36d056d3f16ef009fcc957fc5d87f0c83ab1409d",
        "filename": "src/test/txreconciliation_tests.cpp",
        "status": "modified",
        "additions": 656,
        "deletions": 0,
        "changes": 656,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a70142516167b27bb7d5849d78b8ba15ed2896da/src/test/txreconciliation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a70142516167b27bb7d5849d78b8ba15ed2896da/src/test/txreconciliation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txreconciliation_tests.cpp?ref=a70142516167b27bb7d5849d78b8ba15ed2896da",
        "patch": "@@ -4,12 +4,129 @@\n \n #include <txreconciliation.h>\n \n+#include <node/minisketchwrapper.h>\n+\n #include <test/util/setup_common.h>\n \n #include <boost/test/unit_test.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n \n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp.\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr double RECON_Q = 0.25;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+// Converted to int/seconds to be used in SetMockTime().\n+constexpr int RECON_REQUEST_INTERVAL = 8;\n+constexpr int RECON_RESPONSE_INTERVAL = 1;\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.PreRegisterPeer(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.RegisterPeer(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.RegisterPeer(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = MakeMinisketch32(capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n BOOST_AUTO_TEST_CASE(PreRegisterPeerTest)\n {\n     TxReconciliationTracker tracker;\n@@ -77,6 +194,488 @@ BOOST_AUTO_TEST_CASE(ForgetPeerTest)\n     assert(!tracker.IsPeerRegistered(peer_id0));\n }\n \n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.PreRegisterPeer(peer_id0, inbound);\n+    assert(tracker.RegisterPeer(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(TryRemovingFromReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    const uint256 wtxid = GetRandHash();\n+    // For non-registered peer nothing happens (no failure).\n+    tracker.TryRemovingFromReconSet(peer_id0, wtxid);\n+    tracker.PreRegisterPeer(peer_id0, inbound);\n+    assert(tracker.RegisterPeer(peer_id0, inbound, true, false, 1, 0));\n+    // No such transaction, nothing happens.\n+    tracker.TryRemovingFromReconSet(peer_id0, wtxid);\n+\n+    tracker.AddToReconSet(peer_id0, std::vector<uint256>{wtxid});\n+    tracker.TryRemovingFromReconSet(peer_id0, wtxid);\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    assert(tracker.RegisterPeer(peer_id0, true, true, false, 1, 0));\n+\n+    // Don't request from an inbound peer.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+\n+    // Make a request.\n+    NodeId peer_id1 = 1;\n+    tracker.PreRegisterPeer(peer_id1, false);\n+    assert(tracker.RegisterPeer(peer_id1, false, false, true, 1, 0));\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id1);\n+    const auto [local_set_size, local_q_formatted] = (*request_data);\n+    assert(local_set_size == 0);\n+    assert(local_q_formatted == uint16_t(RECON_Q * Q_PRECISION));\n+    // Don't request until the first request is finalized/terminated.\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL);\n+    assert(!tracker.MaybeRequestReconciliation(peer_id1));\n+    tracker.ForgetPeer(peer_id1);\n+\n+    // The next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.PreRegisterPeer(peer_id2, false);\n+    assert(tracker.RegisterPeer(peer_id2, false, false, true, 1, 0));\n+    // Too soon\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 2 - 1);\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 2);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    // Re-add peer 1.\n+    tracker.PreRegisterPeer(peer_id1, false);\n+    assert(tracker.RegisterPeer(peer_id1, false, false, true, 1, 0));\n+    // Second peer is earlier in the queue.\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 3);\n+    assert(!tracker.MaybeRequestReconciliation(peer_id1));\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 4);\n+    assert(tracker.MaybeRequestReconciliation(peer_id1));\n+\n+    // Remove peer 2 from the queue, so peer 1 should be selected again.\n+    tracker.ForgetPeer(peer_id2);\n+    // Clear the state for peer 1.\n+    tracker.HandleSketch(peer_id1, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 5);\n+    assert(tracker.MaybeRequestReconciliation(peer_id1));\n+    tracker.ForgetPeer(peer_id1);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.PreRegisterPeer(peer_id3, false);\n+    assert(tracker.RegisterPeer(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 6);\n+    request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    SetMockTime(start_time);\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    SetMockTime(start_time);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    SetMockTime(start_time);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    auto dummy = std::vector<uint256>();\n+    assert(tracker_test2.FinalizeInitByThem(false, std::vector<uint32_t>(), dummy));\n+    // Too little time since last response, do not respond yet.\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL * 10);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    NodeId peer_id0 = 0;\n+\n+    // Check that we won't respond if we initiate.\n+    TxReconciliationTracker tracker;\n+    SetMockTime(start_time);\n+    tracker.PreRegisterPeer(peer_id0, false);\n+    assert(tracker.RegisterPeer(peer_id0, false, false, true, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    SetMockTime(start_time);\n+    TxReconciliationTracker tracker2;\n+    tracker2.PreRegisterPeer(peer_id0, true);\n+    assert(tracker2.RegisterPeer(peer_id0, true, true, false, 1, 0));\n+    tracker2.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    tracker2.ForgetPeer(peer_id0);\n+    assert(!tracker2.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the node's own local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    SetMockTime(start_time);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    SetMockTime(start_time);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    SetMockTime(start_time);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    assert(tracker_test3.GetPeerSetSize() == 0);\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    SetMockTime(start_time);\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    // Protocol violation: wrong reconciliation phase.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, false));\n+    // Check that we won't respond to non-registered peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));\n+\n+    // Handling valid sketch.\n+    tracker_test.AddTransactions(5);\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL);\n+    assert(tracker_test.MaybeRequestReconciliation());\n+    tracker_test.AddTransactions(10);\n+\n+    std::vector<uint256> txs_to_sketch(tracker_test.m_transactions.begin(), tracker_test.m_transactions.begin() + 12);\n+    std::vector<uint256> node_will_announce(tracker_test.m_transactions.begin() + 12, tracker_test.m_transactions.end());\n+    // Add one extra tx.\n+    uint256 extra_tx = GetRandHash();\n+    txs_to_sketch.push_back(extra_tx);\n+\n+    // Sketch should have sufficient capacity to decode the difference.\n+    Minisketch sketch = tracker_test.ComputeSketch(txs_to_sketch, 10);\n+\n+    bool sketch_valid = tracker_test.HandleSketch(sketch.Serialize(), txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(recon_result && *recon_result);\n+    assert(txs_to_request == std::vector<uint32_t>{tracker_test.ComputeShortID(extra_tx)});\n+    assert(std::set<uint256>(txs_to_announce.begin(), txs_to_announce.end()) ==\n+        std::set<uint256>(node_will_announce.begin(), node_will_announce.end()));\n+    assert(tracker_test.GetPeerSetSize() == 0);\n+\n+    // Early exit: a received sketch is empty, terminate reconciliation with a failure.\n+    tracker_test.m_transactions.clear();\n+    tracker_test.AddTransactions(5);\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 2);\n+    assert(tracker_test.MaybeRequestReconciliation());\n+    tracker_test.AddTransactions(10);\n+\n+    txs_to_request.clear();\n+    txs_to_announce.clear();\n+    recon_result = std::nullopt;\n+\n+    sketch_valid = tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(recon_result && !*recon_result);\n+    assert(txs_to_request.size() == 0);\n+    assert(std::set<uint256>(txs_to_announce.begin(), txs_to_announce.end()) ==\n+        std::set<uint256>(tracker_test.m_transactions.begin(), tracker_test.m_transactions.end()));\n+    assert(tracker_test.GetPeerSetSize() == 0);\n+\n+    // Early exit: a local set is empty, terminate reconciliation with a failure.\n+    tracker_test.m_transactions.clear();\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 3);\n+    assert(tracker_test.MaybeRequestReconciliation());\n+\n+    txs_to_request.clear();\n+    txs_to_announce.clear();\n+    recon_result = std::nullopt;\n+\n+    std::vector<uint8_t> random_skdata = tracker_test.ComputeSketch(std::vector<uint256>{GetRandHash()}, 1).Serialize();\n+\n+    sketch_valid = tracker_test.HandleSketch(random_skdata, txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(recon_result && !*recon_result);\n+    assert(txs_to_request.size() == 0);\n+    assert(txs_to_announce.size() == 0);\n+\n+    // Check the limits: a received sketch could be at most MAX_SKETCH_CAPACITY = 2 << 12.\n+    tracker_test.m_transactions.clear();\n+    tracker_test.AddTransactions(5);\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL * 4);\n+    assert(tracker_test.MaybeRequestReconciliation());\n+\n+    random_skdata = tracker_test.ComputeSketch(std::vector<uint256>{GetRandHash()}, (2 << 12) + 1).Serialize();\n+    sketch_valid = tracker_test.HandleSketch(random_skdata, txs_to_request, txs_to_announce, recon_result);\n+    assert(!sketch_valid);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+\n+    // Extension success.\n+    tracker_test.AddTransactions(5);\n+    assert(tracker_test.MaybeRequestReconciliation());\n+    tracker_test.AddTransactions(10);\n+\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    std::vector<uint256> txs_to_sketch(tracker_test.m_transactions.begin(), tracker_test.m_transactions.begin() + 12);\n+    std::vector<uint256> node_will_announce(tracker_test.m_transactions.begin() + 12, tracker_test.m_transactions.end());\n+    // Add one extra tx.\n+    uint256 extra_tx = GetRandHash();\n+    txs_to_sketch.push_back(extra_tx);\n+\n+    // Sketch should have low capacity, so that decoding suceeeds only after extension.\n+    std::vector<uint8_t> sketch = tracker_test.ComputeSketch(txs_to_sketch, 3).Serialize();\n+\n+    bool sketch_valid = tracker_test.HandleSketch(sketch, txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(!recon_result);\n+    assert(txs_to_request.size() == 0);\n+    assert(txs_to_announce.size() == 0);\n+\n+    std::vector<uint8_t> extendned_sketch = tracker_test.ComputeSketch(txs_to_sketch, 6).Serialize();\n+    std::vector<uint8_t> sketch_extension = std::vector<uint8_t>(extendned_sketch.begin() + extendned_sketch.size() / 2, extendned_sketch.end());\n+\n+    sketch_valid = tracker_test.HandleSketch(sketch_extension, txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(recon_result && *recon_result);\n+    assert(txs_to_request == std::vector<uint32_t>{tracker_test.ComputeShortID(extra_tx)});\n+    assert(std::set<uint256>(txs_to_announce.begin(), txs_to_announce.end()) ==\n+        std::set<uint256>(node_will_announce.begin(), node_will_announce.end()));\n+\n+    // Extension failure.\n+    tracker_test.m_transactions.clear();\n+    tracker_test.AddTransactions(5);\n+    SetMockTime(start_time + RECON_REQUEST_INTERVAL);\n+    assert(tracker_test.MaybeRequestReconciliation());\n+    tracker_test.AddTransactions(10);\n+\n+    txs_to_request.clear();\n+    txs_to_announce.clear();\n+    recon_result = std::nullopt;\n+\n+    txs_to_sketch.assign(tracker_test.m_transactions.begin(), tracker_test.m_transactions.begin() + 12);\n+\n+    // Add one extra tx.\n+    extra_tx = GetRandHash();\n+    txs_to_sketch.push_back(extra_tx);\n+\n+    // Sketch should have low capacity, so that decoding fails even after extension.\n+    sketch = tracker_test.ComputeSketch(txs_to_sketch, 1).Serialize();\n+\n+    sketch_valid = tracker_test.HandleSketch(sketch, txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(!recon_result);\n+    assert(txs_to_request.size() == 0);\n+    assert(txs_to_announce.size() == 0);\n+\n+    extendned_sketch = tracker_test.ComputeSketch(txs_to_sketch, 2).Serialize();\n+    sketch_extension = std::vector<uint8_t>(extendned_sketch.begin() + extendned_sketch.size() / 2, extendned_sketch.end());\n+\n+    sketch_valid = tracker_test.HandleSketch(sketch_extension, txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(recon_result && !*recon_result);\n+    assert(txs_to_request.size() == 0);\n+    assert(std::set<uint256>(txs_to_announce.begin(), txs_to_announce.end()) ==\n+        std::set<uint256>(tracker_test.m_transactions.begin(), tracker_test.m_transactions.end()));\n+\n+    // Check the limits: a received sketch extension could be at most MAX_SKETCH_CAPACITY = 2 << 12.\n+    TxReconciliationTrackerTest tracker_test2(false);\n+    tracker_test2.AddTransactions(10);\n+    assert(tracker_test2.MaybeRequestReconciliation());\n+\n+    std::vector<uint256> too_many_transactions;\n+    for (size_t i = 0; i < (2 << 12) * 2; i++) {\n+        too_many_transactions.push_back(GetRandHash());\n+    }\n+\n+    std::vector<uint8_t> random_skdata = tracker_test2.ComputeSketch(too_many_transactions, 2 << 12).Serialize();\n+\n+    recon_result = std::nullopt;\n+    sketch_valid = tracker_test2.HandleSketch(random_skdata, txs_to_request, txs_to_announce, recon_result);\n+    assert(sketch_valid);\n+    assert(!recon_result);\n+    std::vector<uint8_t> random_extension = tracker_test2.ComputeSketch(too_many_transactions, (2 << 12) + 1).Serialize();\n+    sketch_valid = tracker_test2.HandleSketch(random_extension, txs_to_request, txs_to_announce, recon_result);\n+    assert(!sketch_valid);\n+}\n+\n+BOOST_AUTO_TEST_CASE(FinalizeInitByThemTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(true);\n+    std::vector<uint256> remote_missing;\n+\n+    // Return false if called for an unknown peer.\n+    assert(!tracker_test.FinalizeInitByThem(false, std::vector<uint32_t>(), remote_missing, true));\n+\n+    // Return false if called during the wrong reconciliation phase.\n+    assert(!tracker_test.FinalizeInitByThem(false, std::vector<uint32_t>(), remote_missing));\n+\n+    tracker_test.HandleReconciliationRequest();\n+\n+    // Return false if called during the wrong reconciliation phase.\n+    assert(!tracker_test.FinalizeInitByThem(false, std::vector<uint32_t>(), remote_missing));\n+\n+    // Return true if called at a proper time. Announce all transactions if reconciliation failed.\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(tracker_test.FinalizeInitByThem(false, std::vector<uint32_t>(), remote_missing));\n+    assert(remote_missing.size() == 0);\n+\n+    // Return true if called at a proper time. Announce requested transactions if reconciliation\n+    // succeeded.\n+    tracker_test.AddTransactions(10);\n+    tracker_test.HandleReconciliationRequest();\n+    tracker_test.AddTransactions(5);\n+    SetMockTime(start_time + RECON_RESPONSE_INTERVAL * 2);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    std::vector<uint32_t> remote_missing_by_shortid;\n+    uint256 known_tx_asked_for = tracker_test.m_transactions[0];\n+    remote_missing_by_shortid.push_back(tracker_test.ComputeShortID(known_tx_asked_for));\n+    uint256 extra_tx = GetRandHash(); // An unknown transaction should just be ignored.\n+    remote_missing_by_shortid.push_back(tracker_test.ComputeShortID(extra_tx));\n+    assert(tracker_test.FinalizeInitByThem(true, remote_missing_by_shortid, remote_missing));\n+    assert(remote_missing.size() == 1);\n+    assert(remote_missing[0] == known_tx_asked_for);\n+\n+}\n+\n BOOST_AUTO_TEST_CASE(IsPeerRegisteredTest)\n {\n     TxReconciliationTracker tracker;\n@@ -93,4 +692,61 @@ BOOST_AUTO_TEST_CASE(IsPeerRegisteredTest)\n     assert(!tracker.IsPeerRegistered(peer_id0));\n }\n \n+BOOST_AUTO_TEST_CASE(GetPeerSetSizeTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    assert(!tracker.GetPeerSetSize(peer_id0));\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    assert(!tracker.GetPeerSetSize(peer_id0));\n+    assert(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1));\n+    assert(*tracker.GetPeerSetSize(peer_id0) == 0);\n+    uint256 tx_to_add = GetRandHash();\n+    tracker.AddToReconSet(peer_id0, std::vector<uint256>{tx_to_add});\n+    assert(*tracker.GetPeerSetSize(peer_id0) == 1);\n+    // Adding for the second time should not work.\n+    tracker.AddToReconSet(peer_id0, std::vector<uint256>{tx_to_add});\n+    assert(*tracker.GetPeerSetSize(peer_id0) == 1);\n+    tracker.ForgetPeer(peer_id0);\n+    assert(!tracker.GetPeerSetSize(peer_id0));\n+}\n+\n+BOOST_AUTO_TEST_CASE(ShouldFloodToTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    uint256 wtxid = GetRandHash();\n+    assert(!tracker.ShouldFloodTo(wtxid, peer_id0));\n+\n+    // Add a peer to hit flooding.\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    assert(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1));\n+\n+    tracker.ForgetPeer(peer_id0);\n+    assert(!tracker.ShouldFloodTo(wtxid, peer_id0));\n+}\n+\n+BOOST_AUTO_TEST_CASE(CurrentlyReconcilingTxTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    uint256 wtxid = GetRandHash();\n+    assert(!tracker.CurrentlyReconcilingTx(peer_id0, wtxid));\n+\n+    // Add a peer.\n+    tracker.PreRegisterPeer(peer_id0, true);\n+    assert(tracker.RegisterPeer(peer_id0, true, true, false, 1, 1));\n+\n+    assert(!tracker.CurrentlyReconcilingTx(peer_id0, wtxid));\n+\n+    tracker.AddToReconSet(peer_id0, std::vector<uint256>{wtxid});\n+    assert(tracker.CurrentlyReconcilingTx(peer_id0, wtxid));\n+\n+    tracker.ForgetPeer(peer_id0);\n+    assert(!tracker.CurrentlyReconcilingTx(peer_id0, wtxid));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()\n\\ No newline at end of file"
      }
    ]
  },
  {
    "sha": "5728fac4d3d29f64ea811f5978e80dabdc083d87",
    "node_id": "C_kwDOABII59oAKDU3MjhmYWM0ZDNkMjlmNjRlYTgxMWY1OTc4ZTgwZGFiZGMwODNkODc",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-08-07T09:08:49Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-12-01T13:25:09Z"
      },
      "message": "Update mempool_packages.py test for reconciliation\n\nFirst, extend the timeout to facilitate reconciliation\nrelay which might take longer than previously.\n\nSecond, since reconciliation can't guarantee that\ndescendants of same-degree (from the parent) are\nrelayed in the same order they were received, loosen\nthe check for descendant limit.\nThis is the case because, if the parent is flooded,\nthe children might be both flooded and reconciled,\nand the decision is made independently. So even if\none arrived earlier, it can be relayed later because\nflooding.\nNote, it's possible to make txreconciliation.cpp be aware\nof the order of adding transactions to the set, but this\nwon't help to solve the above issue.",
      "tree": {
        "sha": "e79f54e9b4d3a0db4a3ab1e7302e4e5abf724ffe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e79f54e9b4d3a0db4a3ab1e7302e4e5abf724ffe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5728fac4d3d29f64ea811f5978e80dabdc083d87",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5728fac4d3d29f64ea811f5978e80dabdc083d87",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5728fac4d3d29f64ea811f5978e80dabdc083d87/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a70142516167b27bb7d5849d78b8ba15ed2896da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a70142516167b27bb7d5849d78b8ba15ed2896da",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a70142516167b27bb7d5849d78b8ba15ed2896da"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 8,
      "deletions": 7
    },
    "files": [
      {
        "sha": "9cce40694532218b2014ec74112499b1851f80d7",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5728fac4d3d29f64ea811f5978e80dabdc083d87/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5728fac4d3d29f64ea811f5978e80dabdc083d87/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=5728fac4d3d29f64ea811f5978e80dabdc083d87",
        "patch": "@@ -263,18 +263,19 @@ def run_test(self):\n \n         # Check that node1's mempool is as expected, containing:\n         # - txs from previous ancestor test (-> custom ancestor limit)\n-        # - parent tx for descendant test\n+        # - parent txs for descendant test\n         # - txs chained off parent tx (-> custom descendant limit)\n         self.wait_until(lambda: len(self.nodes[1].getrawmempool()) ==\n-                                MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=10)\n+                                MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=30)\n         mempool0 = self.nodes[0].getrawmempool(False)\n         mempool1 = self.nodes[1].getrawmempool(False)\n         assert set(mempool1).issubset(set(mempool0))\n-        assert parent_transaction in mempool1\n-        for tx in chain[:MAX_DESCENDANTS_CUSTOM]:\n-            assert tx in mempool1\n-        for tx in chain[MAX_DESCENDANTS_CUSTOM:]:\n-            assert tx not in mempool1\n+        chained_txs_in_mempool = 0\n+        for tx in chain:\n+            if tx in mempool1:\n+                chained_txs_in_mempool += 1\n+        assert(chained_txs_in_mempool == MAX_DESCENDANTS_CUSTOM)\n+\n         # TODO: more detailed check of node1's mempool (fees etc.)\n \n         # TODO: test descendant size limits"
      }
    ]
  }
]