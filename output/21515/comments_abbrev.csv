DrahtBot,2021-03-24 09:59:06,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23443](https://github.com/bitcoin/bitcoin/pull/23443) (p2p: Erlay support signaling by naumenkogs)\n* [#23233](https://g",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-805662879,805662879,
ariard,2021-04-30 15:11:30,See comment here if you think replacing assert with exception is better to exercise coverage in unit tests : https://github.com/bitcoin/bitcoin/issues/16700#issuecomment-829494172,https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-830164004,830164004,
DrahtBot,2021-05-03 09:32:58,<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\n🕵️ @hebasto @sipa @practicalswift have been requested to review this pull request as specified in the REVIEWERS file.,https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-831142156,831142156,
sipa,2021-05-17 02:58:34,"@naumenkogs #21859 should be sufficiently ready to rebase on, if you want CI-testable code. Note the src/minisketchwrapper module, which automatically benchmarks.",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-841946130,841946130,
rebroad,2021-06-29 23:07:08,"How can I help test this? I've been running it for a few hours so far on mainnet, but haven't noticed much difference compared to the master branch.",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-870975622,870975622,
naumenkogs,2021-06-30 16:43:32,"@rebroad It only makes a difference if your erlay-enabled node connects to other erlay-enabled nodes :)\nI'm planning to invite people to a such sub-network soon (where we can connect to each other by --addnode manually). I'll let you know once I start that :)\n\nYou can obviously run several nodes with this patch by yourself too, just make sure to connect them.",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-871564829,871564829,
rebroad,2021-07-23 16:07:29,"I've been testing this, and so far I've found that the efficiency is reduced with this patch - i.e. a lower PERCENTAGE of the bandwidth is used for ACCEPTED transactions compared to not using this patch. Therefore it is better NOT to use this patch. Therefore, NACK, for now, perhaps premature.\n\nI'll continue testing, and share my data in the near future.",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885743229,885743229,
sipa,2021-07-23 19:29:56,"@rebroad That's interesting, and surprising. Can you share your data? Which other Erlay-capable nodes have you been testing with? Substantial improvements are only expected once significant subgraphs adopt it.",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885868272,885868272,
prayank23,2021-07-23 20:34:30,"rebroad: \n> How can I help test this? I've been running it for a few hours so far on mainnet, but haven't noticed much difference compared to the master branch.\n\n> I've been testing this, and so far I've found that the efficiency is reduced with this patch - i.e. a lower PERCENTAGE of the bandwidth is used for ACCEPTED transactions compared to not using this patch. Therefore it is better NOT",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885899988,885899988,
naumenkogs,2021-07-24 14:23:47,"@sipa @prayank23 @rebroad \nI've spent last couple days running my own subnetwork of Erlay nodes connected to mainnet. I was slightly tuning implementation/configurations and observing savings of 20-50% of overall bandwidth.\n\nI can imagine this PR with no modifications yeilding suboptimal results. I will update the PR with good actual-peformance (according to my real-time experiments) in the ",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-886060698,886060698,
rebroad,2021-08-04 10:19:27,"![image](https://user-images.githubusercontent.com/1530283/128164829-cb1eef81-705d-433a-b1ce-1cb42106a660.png)\nI'm now running the latest erlay patch on 2 nodes, and created a manual connection between them. Compared to non-erlay nodes, the percentage of mempool-successful receive traffic seems below average, and the upload bps seems significantly higher than for the other nodes.\n\nUpdate (5t",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-892542075,892542075,
jonatack,2021-08-17 17:54:36,Debug build is clean. I'll try to start looking at this soon.,https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-900511655,900511655,
naumenkogs,2021-08-19 18:37:42,"I created 2 discussion boards, please discuss not-code-related topics there:\n1. [Understanding bandwidth savings](https://github.com/naumenkogs/txrelaysim/issues/7)\n2. [Joining mainnet testing](https://github.com/naumenkogs/txrelaysim/issues/8)",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902149222,902149222,
rebroad,2021-08-20 15:04:11,"After running this for a few minutes, I'm so far seeing better performance from non-erlay nodes, but perhaps we need more erlay nodes for testing to really see if there's really an improvement.\n![image](https://user-images.githubusercontent.com/1530283/130253576-76edc275-b00d-4888-8606-f7adee87634d.png)\n",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902758735,902758735,
naumenkogs,2021-08-20 17:17:09,"@rebroad no, the bandwidth savings should come immediately for your node. Maybe the difference is that you run too many conns (I always tested 8/12 erlay conns and that's it)...\n\nWe could also try to understand why it eats more bandwidth in your case, but perhaps we should stick to the realistic case? E.g., 4 erlay conns + 4 legacy conns for. \n\nAnyway, could we continue the bandwidth-relat",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902839760,902839760,
rebroad,2021-09-20 09:10:24,"Maybe this is an ""the emperor has no clothes moment"", but I shall say what's on my mind without fear of appearing stupid.\n\nTo me, this change looks like the improvements are simply due to reducing the delay between sending TXs. With this change I see greater bandwidth, greater TX throughput but reduced efficiency (i.e. percentage of useful bandwidth). I've been seeing this since I started test",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-922753000,922753000,
jnewbery,2021-11-12 10:59:53,Minisketch is merged! Please rebase :),https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-967011885,967011885,
MarcoFalke,2021-11-12 11:07:10,#23491 will conflict with this pull after rebase. Let me know if this acceptable or if you prefer to defer 23491 until after all other changes are merged.,https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-967016604,967016604,
rebroad,2021-11-25 13:20:02,what is the 2021-11-erlay1 branch please? confused as it looks more recent (from the name) but this one is also getting updated.,https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-979209269,979209269,
rebroad,2021-11-25 19:26:48,"This does not compile:-\n\n```\n8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\ncommit 8d4354499f39a49bbb8675494c532802ef034b03\nAuthor: Gleb Naumenko <naumenko.gs@gmail.com>\nDate:   Sat Mar 20 17:36:08 2021 +0200\n\n    Respond to a reconciliation request\n\n    When the time comes, we should send a sketch of our\n    local reconciliation set to the reconciliation in",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-979436224,979436224,
naumenkogs,2021-11-29 09:53:43,"@rebroad hey\n\n>what is the 2021-11-erlay1 branch please? confused as it looks more recent (from the name) but this one is also getting updated.\n\nThat branch is a first batch of this PR commits, forked to be merged separately within [that PR](https://github.com/bitcoin/bitcoin/pull/23443).\nI try to keep the OP PR up-to-date with that one, but also not too often to avoid too many notificat",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981466935,981466935,
glozow,2021-11-29 14:13:21,"Concept ACK, thanks for splitting the big PR up :) Will review soon.",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981672502,981672502,
naumenkogs,2021-11-29 14:57:40,"Fixing new CI issues here, for now please review the first batch separately [here](https://github.com/bitcoin/bitcoin/pull/23443) :)",https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981712350,981712350,
promag,2021-03-23 21:34:00,"8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\n\nnit `#include <memory>` for `std::unique_ptr`.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599969335,599969335,src/txreconciliation.h
promag,2021-03-23 21:39:09,"8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\n\nMove to txreconciliation.cpp",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599974713,599974713,src/txreconciliation.h
promag,2021-03-23 21:47:10,"8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\n\nLooks like insertion should always happen? If so you could assert `.second` of `emplace()` result. If not, then `GetRand()` could be avoided in case it exists, and below it should return the existing salt.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599979335,599979335,src/txreconciliation.cpp
promag,2021-03-28 20:35:51,"3e4022a4a87c91b4b671ab4b71ccbd6d7136bade\n\nCould make this log conditional to whether `peer_id` was erased from `m_local_salts`.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602929047,602929047,src/txreconciliation.cpp
promag,2021-03-28 20:50:59,"8cdaf385aee34a9a10406eef73d6dcae74b5a2c4\n\nShould be ""SuggestReconciling""?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602930818,602930818,src/txreconciliation.cpp
promag,2021-03-28 22:26:29,"49108e38941f7136fafdbfc64a989aba0f1cc99f\n\nnit, `->second`.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602941978,602941978,src/txreconciliation.cpp
promag,2021-03-28 22:39:57,"99906e0c3399225ee361ce85291074971d2025e1\n\n`IsPeerRegistered` is not needed since `IsPeerChosenForFlooding` returns `nullopt`. Maybe:\n```cpp\nif (pfrom.MightSupportTransactionRelay()) {\n    we_may_flood_to = m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId()).value_or(true);\n}\n```",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602943795,602943795,src/net_processing.cpp
naumenkogs,2021-03-29 09:27:57,"I agree this is way cleaner, but I think the current code is easier to understand, so I'm leaning towards my approach.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603143723,603143723,src/net_processing.cpp
promag,2021-03-29 09:29:16,"The problem is that you can hit undefined behavior with the current code - assuming peer can be disconnected between `IsPeerRegistered` and  `IsPeerChosenForFlooding`.\n\nEdit: Looks like the above is not possible.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603144648,603144648,src/net_processing.cpp
promag,2021-03-29 11:01:03,"3692db74f86186789c9dad4005f7b768721d5afe\n\nnit, could move to inner scope.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603200987,603200987,src/net_processing.cpp
promag,2021-03-29 11:04:13,"83a08c5ea07f7f7e3e67501ac8666521427ae9d3\n\nnit, `assert(txs_to_reconcile.size() > 0)`",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603202580,603202580,src/txreconciliation.cpp
promag,2021-03-29 11:06:33,"83a08c5ea07f7f7e3e67501ac8666521427ae9d3\n\nCould `m_local_set already` have some of `txs_to_reconcile`? If so maybe we should count successful `.insert()` and log that?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603203867,603203867,src/txreconciliation.cpp
promag,2021-03-29 11:12:08,"3692db74f86186789c9dad4005f7b768721d5afe\n\nMove to inner scope, make const.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603206903,603206903,src/net_processing.cpp
promag,2021-03-29 11:13:40,"05ac9dc21e5697a1e0261909b64de4f7d6e21eb1\n\ntypo ""differene""",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603207731,603207731,src/txreconciliation.cpp
promag,2021-03-29 11:17:55,"e854bcf5391d02a28690f7eedad8382cbb05f85b\n\nAdd TSAN annotation?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210177,603210177,src/txreconciliation.cpp
promag,2021-03-29 11:19:03,"e854bcf5391d02a28690f7eedad8382cbb05f85b\n\nnit `assert(m_queue.size() > 0)`",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210815,603210815,src/txreconciliation.cpp
promag,2021-03-29 11:25:31,"476ced6df27c13fd8d1dae46d09b91549977cac1\n\nnit, enum class and use as `ReconciliationPhase::NONE`?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603214394,603214394,src/txreconciliation.cpp
jnewbery,2021-03-29 11:34:44,"There's no need to update this public interface method. The only users of this method outside net_processing will _always_ call `RelayTransaction()` without a `from` parameter.\n\n(it's also unnecessary to wrap an optional parameter in a `std::optional` since the fact that it's an optional parameter already gives you a way to indicate no value)",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603219571,603219571,src/net_processing.h
jnewbery,2021-03-29 11:38:10,No need to protect this with `cs_main`. You can just make it atomic.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221491,603221491,src/net_processing.cpp
jnewbery,2021-03-29 11:38:34,"Again, no need for this to be protected by main. I think it can easily live in `Peer`.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221670,603221670,src/net_processing.cpp
jnewbery,2021-03-29 11:41:12,New `from` parameter is unused.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603223119,603223119,src/net_processing.cpp
naumenkogs,2021-04-02 19:26:16,"Making const. Can't move because it's erased in two lines after, so it won't be accessible in the inner scope.\nAnd I can't call `.second` on `.erase`, because it returns a number of erased elements.\n\nOne alternative could be to use `txid_to_ann_protocol` in `vInvTx` (instead of uint256). But then I won't be able to reuse `CompareInvMempoolOrder` in `AnnounceTxs`.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606384776,606384776,src/net_processing.cpp
naumenkogs,2021-04-02 19:39:35,"Sorry I don't understand this comment, despite your elaborate explanation. Probably my lack of C++ expertise.\n\nIf I remove just this change in the `virtual void` line, I get a compilation error.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606389480,606389480,src/net_processing.h
ariard,2021-04-14 21:21:06,"Thanks for the clear write-up, may I suggest to insert a stable link to the paper ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613595312,613595312,src/txreconciliation.h
ariard,2021-04-14 21:28:34,"I think one obvious extension of the test coverage would be to join basic fuzz coverage of `TxReconciliationTracker` interface to assert its robustness. Have a look on `src/test/fuzz/addrman.cpp` or `src/test/fuzz/banman.cpp`.\n\nFuzz coverage might test further sanity of `TxReconciliationTracker` after each call or in function of `m_we_initiate` or `m_flood_to`. Still thinking about concrete su",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613599268,613599268,src/txreconciliation.h
jnewbery,2021-04-15 09:50:05,"Yes, you'll need to change the function signature in `PeerManagerImpl()` as well. An `override` function must have the same signature as the function it's overriding.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613926434,613926434,src/net_processing.h
ariard,2021-04-15 15:21:39,"Surprised that modifying those 2 values doesn't lead to functional test changes. Apparently, they're not covered in p2p_tx_download.py. I can extend coverage there in another PR.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614166227,614166227,src/net_processing.cpp
ariard,2021-04-15 16:18:39,"Do we have privacy leaks for the following cases not mentioned in this comment ?\n\nA non-reachable node reconciliate with reconciliation-supporting _flooding_ outbound peers ? As it would be a deviation from the expected announcement policy.\n\nA reachable node reconciliate with reconciliation-supporting _flooding_ inbound/outbound peers ? Likewise, it would be a deviation from the expected a",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614211171,614211171,src/net_processing.cpp
ariard,2021-04-15 16:37:59,"In theory, peer's feefilter might have increased between transaction selection for announcement at INV sending and receiving a SKETCH or RECONCILDIFF messages. Though AVG_FEEFILTER_BROADCAST_INTERVAL is 10min so it should be really okay.\n\nIs this gap could be exploited by an off-path attacker to interfere with tx-relay ? I don't think so, or at least without costly manipulation of victim's mem",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614225402,614225402,src/net_processing.cpp
ariard,2021-04-15 16:44:32,"This is logically equivalent ? \n\n```\n@@ -2386,15 +2390,11 @@ void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CN\n         remote_missing_wtxids.pop_back();\n \n         remote_missing_invs.push_back(CInv(MSG_WTX, wtxid));\n-        if (remote_missing_invs.size() == MAX_INV_SZ) {\n+        if (remote_missing_invs.size() == MAX_INV_SZ || remote_missing_wtxids",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614231349,614231349,src/net_processing.cpp
adamjonas,2021-04-16 15:37:09,[The linter](https://cirrus-ci.com/task/6704150097428480) is not happy with this comment style.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614934750,614934750,test/functional/p2p_erlay.py
adamjonas,2021-04-16 15:45:48,s/substraction/subtraction/,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614943424,614943424,src/net_processing.cpp
adamjonas,2021-04-16 15:46:47,s/loosing/losing/,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614944439,614944439,src/net_processing.cpp
brunoerg,2021-04-18 00:26:05,Why 1024? Is it an arbitrary number? I tested it using 500 blocks and it seems to work. Is there an explanation?,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615320860,615320860,test/functional/p2p_erlay.py
brunoerg,2021-04-18 00:46:58,Why have you used CamelCase here? ,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322415,615322415,test/functional/p2p_erlay.py
brunoerg,2021-04-18 00:52:59,"Not only with that.  I ran pycodestyle and got many warnings about it.\n\n![image](https://user-images.githubusercontent.com/19480819/115130588-3c113100-9fc7-11eb-8efd-77b0b406f732.png)\n",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322950,615322950,test/functional/p2p_erlay.py
naumenkogs,2021-04-19 07:14:13,"Yeah, pretty arbitrary. I could generate them in `generate_transactions` function, but then it would force block sync across nodes, which is not ideal to test that transactions are not lost between scenarios (block sync could hide this effect by forcing tx sync)",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615594571,615594571,test/functional/p2p_erlay.py
ariard,2021-04-20 15:45:54,"I think we should update BIP330 to mark the dependency on BIP339. Also, should we bump the protocol version ? Otherwise a bip330 peer will send `SENDRECON` for nothing to bip339-only peer (core version 20+).",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616814867,616814867,src/net_processing.cpp
ariard,2021-04-20 16:24:21,"I don't think what said in comment ""which pass... !IsInboundConn"" is enforced and actually inbound peers might take outbound flooding peers slots ?\n\nTurning this flag to false break `test_outgoing_recon` as all added peers L475-479 aren't occupying anymore flooding peers slots and as such the tested peers is flood to. IIRC `add_p2p_connection`'s peers are seen as inbound ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616846325,616846325,src/net_processing.cpp
ariard,2021-04-20 16:35:59,"Is the following scenario possible ?\n* current outbound flooding peers=MAX_OUTBOUND_FLOOD_TO - 1\n* outbound peer 1 connects\n* outbound peer 2 connects\n* outbound peer 1 send a SENDRECON is marked as outbound flooding peers as a slot is still available\n* outbound peer 2 send a SENDRECON is marked as outbound flooding peers as a slot is still available\n* outbound peer 1 send a VERACK, cu",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616855063,616855063,src/net_processing.cpp
ariard,2021-04-20 16:43:49,"I think this variable belong more to our transaction relay policy rather than the reconciliation module in itself.  Its effect on the reconciliation module are function of the connection state, which is located outside this module. I'm leaning towards removing any ""flooding"" mention from this module, it should be agnostic about the existence of another transaction-announcement protocol.\n\nI gue",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616861921,616861921,src/txreconciliation.cpp
ariard,2021-04-20 17:32:07,"I don't think `MAX_PEER_TX_ANNOUNCEMENTS` is covered by `p2p_erlay.py` ? This diff doesn't yell an error.\n\n```\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex 689b899f1..0703fcea7 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -81,7 +81,7 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n  *  the actual transaction (from any pe",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616897107,616897107,src/net_processing.cpp
ariard,2021-04-20 17:40:31,"IIUC, erlay is introducing an interdependency between transaction's source and selection of outgoing announcement-protocol (cf `RelayTransaction`), but I'm not if this is covered by `p2p_erlay.py` ? Following diff doesn't yell a failure. Same we turning to always true.\n\n```\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex 1818fc0f2..a4e847110 100644\n--- a/src/net_proces",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616903681,616903681,src/net_processing.cpp
ariard,2021-04-20 17:42:51,"I think it should be AND not an OR here. If `recon_peer_flood_to`= false, even if transaction is marked for flooding, it will be added to reconciliation set. Is it the semantic intended ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616905161,616905161,src/net_processing.cpp
ariard,2021-04-20 17:51:11,"Not sure if the following change on how reconciliation is influencing broadcast interval is covered by `p2p_erlay.py`\n\n```\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex 1818fc0f2..28641f576 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -4664,7 +4664,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 bool fSendTrickle = pt",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616910754,616910754,src/net_processing.cpp
naumenkogs,2021-04-21 08:57:22,">Is it the semantic intended?\n\nYes. Whether the transaction is marked for flooding *only* matters for reconciliation peers which are set for flooding.\nSo, if `flood_tx=true` but `recon_peer_flood_to= false`, we should reconcile.\n\nPerhaps this comment covers it already, no:\n```\n    /**\n     * Per BIP-330, we may want to flood certain transactions to a subset of peers with whom we\n",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617332543,617332543,src/net_processing.cpp
naumenkogs,2021-04-21 09:02:46,">I don't think what said in comment ""which pass... !IsInboundConn"" is enforced and actually inbound peers might take outbound flooding peers slots ?\n\nSee line above: `if (!pfrom.IsInboundConn()) {`, that's where it's enforced.\n\n>IIRC add_p2p_connection's peers are seen as inbound ?\n\nNope, I added a hack for that: 108b0233be7735b793e488ba5bda836d24b75d4e",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617336557,617336557,src/net_processing.cpp
naumenkogs,2021-04-21 09:25:55,">I think we should update BIP330 to mark the dependency on BIP339.\n\nAgree.\n\n>Also, should we bump the protocol version ? Otherwise a bip330 peer will send SENDRECON for nothing to bip339-only peer (core version 20+).\n\nI don't understand what you mean here. \n",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617353731,617353731,src/net_processing.cpp
naumenkogs,2021-04-21 09:45:07,"Accidentally some nodes might ignore fee filter, but we don't punish, so it's safe in that sense. Some useless transactions could be sent, but I think it's too hard to exploit in a real way.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617367944,617367944,src/net_processing.cpp
adamjonas,2021-04-21 14:52:01,"linter not happy with this line:\n\n`All calls to LogPrintf() and LogPrint() should be terminated with \n`\n",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617622941,617622941,src/txreconciliation.cpp
ariard,2021-04-21 15:39:43,Yes I recognize that's hard to exploit but even further any mempool manipulation comes up with a priced cost for the attacker as you need utxo value to fan out in victim(s) mempools.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617664798,617664798,src/net_processing.cpp
ariard,2021-04-21 15:46:48,"A bip330 peer sends a SENDRECON message to a wtxid-relay peer but not supporting bip330. \nThe wtxid-relay peer doesn't understand SENDRECON and will ignore the message.\nThe bip330 wasted SENDRECON message bandwidth.\n\nIf the bip330 peer would have been aware that the wtxid-relay peer didn't support bip330 it could have avoid sending SENDRECON. Right now, I think your check implies that wtxi",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617670809,617670809,src/net_processing.cpp
ariard,2021-04-21 16:05:38,"Ah sorry didn't see the patch was the reason of my confusion. So yes it's tested and the logic works as documented. \n\nMaybe add a friendly note L475 in `p2p_erlay.py` ""Contrary to default mininode setting, we mark those peers as node_outgoing=true to simulate them as outgoing connections and thus have them consume regular flood tx forwarding"" ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617686514,617686514,src/net_processing.cpp
naumenkogs,2021-04-21 16:11:02,"@brunoerg I think following best practices beyond what *our* linter does is not necessary, but still I tried to resolve most of those complaints from `pycodestyle` where it makes sense.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617690684,617690684,test/functional/p2p_erlay.py
ariard,2021-04-21 16:49:19,">  So, if flood_tx=true but recon_peer_flood_to= false, we should reconcile.\n\nThis case I understand. The case I don't get the rational for is recon_peer_flood_to=true and flood_tx=false. \n\nAFAICT, it's motivated to preserve privacy of transactions originated locally as detailed in `RelayTransaction` ? I don't think it's achieving its goal as this announcement (i.e _reconciliation_) will d",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617718341,617718341,src/net_processing.cpp
ariard,2021-04-21 17:58:28,"If your peer has been marked as a responder but it sends you anyway a REQRECON, should we severe the connection ? I think it's qualify as a violation of protocol roles (sender, responder) as negotiated in SENDRECON.\n\nSame reasoning for other Erlay messages, should we enforce protocol flow ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617765235,617765235,src/net_processing.cpp
ariard,2021-04-21 18:13:54,"Mutating this flag to false doesn't seem to break `p2p_erlay.py` ?\n\n```\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex bbab3f92c..1dfdc3017 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -3998,7 +3998,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         } else {\n             // Disconnect peers that",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617774781,617774781,src/net_processing.cpp
ariard,2021-04-21 18:28:32,"Should we sanitize `peer_recon_set_size` ?\n\nWhat if a peer send you peer_recon_set_size=UINT16_MAX, may this provoke issues in `EstimateSketchCapacity` or `ComputeBaseSketch`, which are both consuming this value or product of it ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617784280,617784280,src/net_processing.cpp
ariard,2021-04-21 18:38:18,"Should `MAX_SKETCH_CAPACITY` be exposed in the BIP ?\n\nOtherwise I think other implementation can't verify when they're not in violation of your reconciliation bounds.\n\n",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617790228,617790228,src/txreconciliation.cpp
ariard,2021-04-21 18:54:51,"How do we handle failure if the responder never replies to our reconciliation request ?\n\nI don't think this is handled by `TxReconciliationTracker` for now. After RECON_REQUEST_INTERVAL expires again, is `MaybeRequestReconciliation` going to generate a new reconciliation request ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617800136,617800136,src/net_processing.cpp
ariard,2021-04-21 19:00:24,"Mutating this flag doesn't seem to break `p2p_erlay.py` \n\n```\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\nindex bbab3f92c..62afc0eb3 100644\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -4023,7 +4023,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         } else {\n             // Disconnect peers that send reco",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617803685,617803685,src/net_processing.cpp
naumenkogs,2021-04-22 06:55:00,"It is enforced in `txreconciliation.cpp`, but currently these requests are just ignored. I'm not sure if we should disconnect.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618127934,618127934,src/net_processing.cpp
naumenkogs,2021-04-22 06:56:43,">What if a peer send you peer_recon_set_size=UINT16_MAX, may this provoke issues in EstimateSketchCapacity or ComputeBaseSketch, which are both consuming this value or product of it ?\n\nThis is taken care by `capacity = std::min(capacity, MAX_SKETCH_CAPACITY);` in `ComputeBaseSketch`, so this shouldn't cause any harm.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618129008,618129008,src/net_processing.cpp
naumenkogs,2021-04-22 06:58:55,">is MaybeRequestReconciliation going to generate a new reconciliation request ?\n\nNo, because `if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;` takes care of that. Basically, an initiator will wait forever.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618130349,618130349,src/net_processing.cpp
adamjonas,2021-04-22 14:32:47,"linter turned up:\n`test/functional/p2p_erlay.py:20:1: F401 'test_framework.p2p.MIN_P2P_VERSION_SUPPORTED' imported but unused`",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618457926,618457926,test/functional/p2p_erlay.py
naumenkogs,2021-04-22 19:42:48,"oops, sorry I keep missing these issues. Linter broke on my machine for some reason, I better fix it before pushing again.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618689965,618689965,test/functional/p2p_erlay.py
naumenkogs,2021-04-27 08:43:43,">This case I understand. The case I don't get the rational for is recon_peer_flood_to=true and flood_tx=false.\n\nOk, what exactly are you suggesting? Always flood if `recon_peer_flood_to=true` and drop `flood_tx` at all?\n\n1. If this is applied, non-reachable nodes will flood transactions to 7 (erlay enabled) peers after receiving transactions from the 8th. No bandwidth savings because almos",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r620993937,620993937,src/net_processing.cpp
naumenkogs,2021-04-27 10:01:07,"Yes, this scenario is possible.\n\n>What do you think about moving outbound flooding peers accouting from VERACK to SENDRECON ?\n\nThe problem with your suggestion is that we also need to account for peers which will never send SENDRECON (legacy flooding peers). There are 2 possible solutions:\n\n1. Handle legacy peers as a special case, so have this accounting twice (in VERACK for legacy, i",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621060125,621060125,src/net_processing.cpp
naumenkogs,2021-04-27 12:24:37,I will implement the latter.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621156563,621156563,src/net_processing.cpp
ariard,2021-04-28 17:10:54,"Thanks for implementing the suggestion. \n\nFurther, should we disconnect sendrecon sender with a protocol version inferior to `RECONCILIATION_RELAY_VERSION` ? \n\nGood point to keep the check on `WTXID_RELAY_VERSION` support, I thought at first it should be removed but you might have sendrecon sender who don't signal wtxid-relay.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622379909,622379909,src/net_processing.cpp
ariard,2021-04-28 18:28:18,"> If this is applied, non-reachable nodes will flood transactions to 7 (erlay enabled) peers after receiving transactions from the 8th. No bandwidth savings because almost all transactions are flooded, bad.\n\nCan you point me where as a _non-reachable node_ we necessary mark our peers as reconciling ones ? AFAICT, it's decided there without evaluating node reachability : https://github.com/naum",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622435781,622435781,src/net_processing.cpp
ariard,2021-04-29 16:29:55,"Should interface documentation say that peer must not be registered more than once ?\n\nI think that's a property enforced by the assert in the implementation.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623211332,623211332,src/txreconciliation.h
ariard,2021-04-29 16:32:22,`assert(recon_version == RECON_VERSION)` ?,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623213192,623213192,src/test/txreconciliation_tests.cpp
ariard,2021-04-29 16:40:52,What's purpose serves the `TxReconciliationTrackerTest` wrapper given in that unit test you're using directly the reference implementation of `TxReconciliationTracker` ?,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623219478,623219478,src/test/txreconciliation_tests.cpp
ariard,2021-04-29 17:07:14,"W.r.t to future reconciliation upgrades, IIUC if peer support a lower version than us we downgrade to the lowest common version ? I think it's interesting to document in the `EnableReconciliationSupport` declaration how reconciliation version conflicts are negotiated. Further, why RECON_VERSION=1 and not just 0 ?\n\nReally likely we'll have to upgrade reconciliation if we introduce package_ids a",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623238188,623238188,src/txreconciliation.cpp
ariard,2021-04-29 17:32:06,"Just test peer has been registered ?\n\n```\ndiff --git a/src/test/txreconciliation_tests.cpp b/src/test/txreconciliation_tests.cpp\nindex e7f20d7de..8dbad9461 100644\n--- a/src/test/txreconciliation_tests.cpp\n+++ b/src/test/txreconciliation_tests.cpp\n@@ -146,6 +146,10 @@ BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n     // Test inbound peers.\n     bool inbound = true;\n \n",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623255076,623255076,src/test/txreconciliation_tests.cpp
ariard,2021-04-29 17:40:06,"IIUC, you can only hit this return if the peer is sending us both `they_may_initiate`=false and `they_may_respond`=false. This is def a pathological case and maybe we should disconnect such buggy peer ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623260500,623260500,src/txreconciliation.cpp
ariard,2021-04-29 18:52:05,"Maybe add some transactions to the set, to exercise that the correct `local_set_size` is returned \n\n```\n@@ -264,6 +270,25 @@ BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n     assert(!tracker.MaybeRequestReconciliation(peer_id2));\n     tracker.RemovePeer(peer_id1);\n     assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    NodeId p",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623308713,623308713,src/test/txreconciliation_tests.cpp
ariard,2021-04-29 18:58:30,"This doesn't seem to break `HandleReconciliationRequestTest` ?\n\n```\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\nindex d4cfc8ee4..65dcc2675 100644\n--- a/src/txreconciliation.cpp\n+++ b/src/txreconciliation.cpp\n@@ -715,7 +715,9 @@ class TxReconciliationTracker::Impl {\n         auto recon_state = m_states.find(peer_id);\n         if (recon_state == m_states.end())",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623312838,623312838,src/txreconciliation.cpp
naumenkogs,2021-04-30 09:54:48,">W.r.t to future reconciliation upgrades, IIUC if peer support a lower version than us we downgrade to the lowest common version ? I think it's interesting to document in the EnableReconciliationSupport declaration how reconciliation version conflicts are negotiated.?\n\nAgree.\n\n>Further, why RECON_VERSION=1 and not just 0 ?\n\nI think this is about personal taste, 0 might have special mea",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758208,623758208,src/txreconciliation.cpp
naumenkogs,2021-04-30 09:56:00,The purpose is to deduplicate the repeatable valid handshake (Suggest/Enable) by hiding it under the `TxReconciliationTrackerTest`,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758952,623758952,src/test/txreconciliation_tests.cpp
naumenkogs,2021-04-30 09:57:37,"1. Not sure this is really useful.\n2. RECON_VERSION is currently hidden in the module, it it worth moving it out? ",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623759838,623759838,src/test/txreconciliation_tests.cpp
naumenkogs,2021-04-30 09:59:10,"1. I think there is a confusion about ""register"". Register for me is when Enable[...] is called and when ReconciliationState is created Here, we just generate the salt.\n2. Ok, adding the mention.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623760722,623760722,src/txreconciliation.h
ariard,2021-04-30 15:41:50,Though embedding the peer in `TxReconciliationTrackerTest` doesn't let you test the no-registered peer or initiation direction for this method ?,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623977943,623977943,src/test/txreconciliation_tests.cpp
naumenkogs,2021-05-03 08:32:35,">Further, should we disconnect sendrecon sender with a protocol version inferior to RECONCILIATION_RELAY_VERSION ?\n\nYeah seems right.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624948905,624948905,src/net_processing.cpp
naumenkogs,2021-05-03 08:41:43,">Can you point me where as a non-reachable node we necessary mark our peers as reconciling ones ? AFAICT, it's decided there without evaluating node reachability : https://github.com/naumenkogs/bitcoin/blob/5b8c65d32c142e7d91aef13772cf8c771020bee7/src/txreconciliation.cpp#L654\n\nYes, that exact line: `bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;`\n\nFor a non-reachab",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992,624952992,src/net_processing.cpp
naumenkogs,2021-05-03 10:52:36,Let's continue this same discussion in one place: https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r625010038,625010038,src/net_processing.cpp
naumenkogs,2021-05-04 21:26:27,">Now, we should think what to do when we bump the connectivity... Non-reachable nodes will have both flood_to false AND true peers.\n\nOk, so this is fine, because again, local transactions and transactions from outbounds are always reconciled, so it doesn't matter if a non-reachable node has some peers with `flood_to=true`.\n\nI will improve the docs.\n\nKeeping this open, it's likely gonna",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626118561,626118561,src/net_processing.cpp
naumenkogs,2021-05-05 07:14:07,"I tried to make this test, but signing 5000 transactions takes minutes (that's expected, right?), and that's the only way to test this.\n\nInstead, I'm adding tests for `MAX_SKETCH_CAPACITY = 2 << 12`",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626311725,626311725,src/net_processing.cpp
ariard,2021-05-07 14:33:06,"What's the unit of the mocktime bump here, seconds or microseconds ? If it's second I would recommend to replace the bumping value by RECON_RESPOND_INTERVAL, I think it can be taken verbatim from txreconciliation.cpp like you're already doing for few values.\n\nThat way you can assert that's the module is binding to the interval expectation. Otherwise, slightly increasing RECON_RESPOND_INTERVAL ",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628258132,628258132,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 14:39:10,"I think it's missing a small case coverage if node is the initiator. It should be ignored.\n\n```\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\nindex 0218d21ad..9cac2eba5 100644\n--- a/src/txreconciliation.cpp\n+++ b/src/txreconciliation.cpp\n@@ -786,7 +786,7 @@ class TxReconciliationTracker::Impl {\n         LOCK(m_mutex);\n         auto recon_state = m_states.find(p",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628262633,628262633,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 15:31:28,"I think this comment should be reverse with the test case above ?\n\nLocal set is increased by `AddTransaction(5)` though initiator set is empty `HandleReconciliationRequest`",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628313826,628313826,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 15:33:15,Also I don't understand why you bump mocktime by +1000 at each new test case ? You're renewing `tracker_test` everytime so it shouldn't matter,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628315271,628315271,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 15:45:03,"If this helper is called in `RespondToInitialRequest` I believe the check on local set size is duplicated. \n\nTo avoid this, what do you think about uplifting this check to `HandleInitialSketch` and returning true and empty `skdata` there ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628325062,628325062,src/txreconciliation.cpp
ariard,2021-05-07 15:53:26,"You can verify that `PrepareForExtensionRequest` did clear up `local_set` for `local_snapshot`.\n\n```\ndiff --git a/src/test/txreconciliation_tests.cpp b/src/test/txreconciliation_tests.cpp\nindex 2e12d55dc..35e3db5e5 100644\n--- a/src/test/txreconciliation_tests.cpp\n+++ b/src/test/txreconciliation_tests.cpp\n@@ -343,344 +343,345 @@ BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628332247,628332247,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 16:04:47,"Verify but I believe that module's previous steps guarantee that `m_capacity_snapshot` can't be superior to `MAX_SKETCH_CAPCITY`.\n\nAt least following diff seems to pass unit tests:\n```\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\nindex 0218d21ad..d035569af 100644\n--- a/src/txreconciliation.cpp\n+++ b/src/txreconciliation.cpp\n@@ -762,12 +762,13 @@ class TxReconcil",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628339736,628339736,src/txreconciliation.cpp
ariard,2021-05-07 16:11:24,nit: verify if we're reconciliation responder and not initiator.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628343839,628343839,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 16:13:28,"Also I don't think this unit test is covering sketch reception during wrong reconciliation phase, the final branch of `HandleSketch` ?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628345073,628345073,src/test/txreconciliation_tests.cpp
ariard,2021-05-07 16:58:53,"I would verify returned pointer before to try `Deserialize()`. Beyond capacity == 0, minisketch API will also return a nullptr in case of memory allocation failure inside library. I don't know how to tread it, but definitively not crashing on it :/",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628372727,628372727,src/txreconciliation.cpp
ariard,2021-05-07 17:12:55,"Note, coefficient recomputation doesn't seem covered by unit tests but sounds to be by functional tests. I would favor covering it unit tests too. An unrelated change in `p2p_erlay.py` in the future might remove coverage, up to you.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628381177,628381177,src/txreconciliation.cpp
ariard,2021-05-07 17:27:10,"Interesting, default value sounds to diverge from Erlay paper recommendation : \n\n""The coefficient q characterizes earlier reconciliation, so before the very first reconciliation round it is set to zero.""\n\nYou find empirically that a small coefficient was better to start with?",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628389326,628389326,src/txreconciliation.cpp
naumenkogs,2021-06-29 10:34:41,"For future conversations, I will refer to my findings [here](https://github.com/naumenkogs/txrelaysim/tree/master/results/flood-erlay).",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660490867,660490867,src/txreconciliation.cpp
naumenkogs,2021-06-29 14:22:36,"No way to test this. HandleSketch() can be legally called only after MaybeRequestSketch (`m_state_init_by_us.m_phase = Phase::INIT_REQUESTED`) , which is not possible for responders in the first place.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660668925,660668925,src/test/txreconciliation_tests.cpp
naumenkogs,2021-06-29 14:25:25,"Adding a check for `local_set`, but it's hard to get into `local_set_snapshot` because it's a private variable with no getter method. I could possibly check it implicitly, but that's more of a functional test thing.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660671746,660671746,src/test/txreconciliation_tests.cpp
kiminuo,2021-07-05 08:53:06,nit: Why is this change here? ,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663755989,663755989,doc/README.md
kiminuo,2021-07-05 08:57:25,Nit: Is it a good idea to reformat this file? Maybe that can be done in a separate PR.,https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663759139,663759139,test/functional/test_runner.py
naumenkogs,2021-07-05 14:51:39,"oops, definitely not indented. Probably a rebasing mistake.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988352,663988352,test/functional/test_runner.py
naumenkogs,2021-07-05 14:51:41,"oops, definitely not indented. Probably a rebasing mistake.",https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988384,663988384,doc/README.md
