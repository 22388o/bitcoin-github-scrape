[
  {
    "sha": "480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODBkZjQ3ZjhmNWI2YWQ5NTcxMTViMzllM2M0YmQyYzQ4YTU5NWJj",
    "commit": {
      "author": {
        "name": "Hossein Amin",
        "email": "hossein@aminbros.com",
        "date": "2019-05-22T02:20:24Z"
      },
      "committer": {
        "name": "Kristaps Kaupe",
        "email": "kristaps@blogiem.lv",
        "date": "2020-12-14T00:41:40Z"
      },
      "message": "rpc listtransactions new argument options (paginatebypointer impl)\n\nAdded fifth param to `listtransactions` named `options`, `options` may be an object containing `paginatebypointer` (boolean default: false) and `nextpagepointer` (string default: OMITTED).\n\nWith `paginatebypointer` output will have the following changes.\n\n1. Return transactions is ordered by most recent transactions. Though the default does reverse the order after transactions are fetched and clipped.\n2. `skip` argument has no effect. Instead `nextpagepointer` will be used for pagination.\n3. Return value is an object containing, records (array of txs) and nextpagepointer (string)\n\nCo-authored-by: Kristaps Kaupe <kristaps@blogiem.lv>",
      "tree": {
        "sha": "064affa9db2291854c38c373679c8670b09c9d51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/064affa9db2291854c38c373679c8670b09c9d51"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEv2Dflk+I3YgXQImi1HsbQjK1VDcFAl/WtMcACgkQ1HsbQjK1\nVDf3rg/8DoiB0KYdnDVmkvzTGj/nIHq8S5c0oykiQevKam2p2S41+nS1o6Z1uaBh\nCyTQXELaVa4DvKBjQ+MYNinc6dspjILl9XWn3oPUzJ5OkZiQPXBRVIsNcZUNcf2M\nQlQKq5c1jXJP6jlamCAv7Z1lwkA5BzeH9f3XTpZOio01AB1hTxoQ+FFhCot+j19Z\nXa/OQtNlikFSa9vPveFSnYulxsUQ2okuEt3MGyjBJIWoyRqwofufzP/rojVEG7EA\ne67XcjrjWZgajoJFFd9lBDBMlsbibK/IR3bkBnyfcfryiAw5sdb2gefL3zJFelxt\nNXnkMxJOzD4F5b5lQnUxydxltg9gUbNAjh+5FzuRmYszGv8GHc7ecAXR2biAR/RA\nTUzUDGa+iEH2e6QT+2juyfe7wLgj0fDWPd/ASLy5Q4SJaoWiUfDAu+QQYVRQz4wV\nyhu3oj3Sk5C9O0GxNqTEvp5zAH6iVrltXpp6sy2CzJNC9ENV8TukPWdyz34hBDjI\npVFNGgxjqtvSyBUoLSFPmNfo/4eLeWk9B38PYSRjaRTJ/FS9m7yPiNhBFVoHYhMr\ny0fM6lbQ4tyXv8mfAd/HgGkKmMiBtmadUy00pYXQ4Zx+dZmTxXNNZaqtNcBmqycu\nyONzxhIrCw4A+ckut+Ph+STOgVkAQQgb+mV66O/3j/G/s/PtU9w=\n=U2Ux\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIFi0+ODRSKmuAXaQEcaNp4E1yflvdEoE59TRcYOWJiE2CP/wECcZUQaGYMuE\nhhhvf+o2cdAI8QRf1rTN8AhXQBKlvjoW6gCD3+MNLvkMji4taHR0cHM6Ly9hbGlj\nZS5idGMuY2FsZW5kYXIub3BlbnRpbWVzdGFtcHMub3Jn//AQp4zR92X6Y6fhonOg\nwMIz8wjxIKz3DgAJ20Ayddz8fRi6ldbiV/bdMD24i282fLv/8+kVCPEgjYhglKr1\nKqfFbKNxME0uxHlsIFJw35N9J+FaDkybvH4I8QRf1rTL8Ajj4wQIxi7qQQCD3+MN\nLvkMjikoaHR0cHM6Ly9maW5uZXkuY2FsZW5kYXIuZXRlcm5pdHl3YWxsLmNvbf/w\nEK17xrrYGEuMkTvQTia+B9wI8QRf1rTM8AhIGEh71jCYqQCD3+MNLvkMjiwraHR0\ncHM6Ly9ib2IuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ/AQskOrkyAD\nxS8dTR04EyVYtAjxBF/WtMvwCFl1oecuGhuRAIPf4w0u+QyOIyJodHRwczovL2J0\nYy5jYWxlbmRhci5jYXRhbGxheHkuY29t\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 064affa9db2291854c38c373679c8670b09c9d51\nparent 78f912c9010f686e2d1bbdc1c51f381b496c2a1b\nauthor Hossein Amin <hossein@aminbros.com> 1558491624 +0300\ncommitter Kristaps Kaupe <kristaps@blogiem.lv> 1607906500 +0200\n\nrpc listtransactions new argument options (paginatebypointer impl)\n\nAdded fifth param to `listtransactions` named `options`, `options` may be an object containing `paginatebypointer` (boolean default: false) and `nextpagepointer` (string default: OMITTED).\n\nWith `paginatebypointer` output will have the following changes.\n\n1. Return transactions is ordered by most recent transactions. Though the default does reverse the order after transactions are fetched and clipped.\n2. `skip` argument has no effect. Instead `nextpagepointer` will be used for pagination.\n3. Return value is an object containing, records (array of txs) and nextpagepointer (string)\n\nCo-authored-by: Kristaps Kaupe <kristaps@blogiem.lv>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/comments",
    "author": null,
    "committer": {
      "login": "kristapsk",
      "id": 4500994,
      "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kristapsk",
      "html_url": "https://github.com/kristapsk",
      "followers_url": "https://api.github.com/users/kristapsk/followers",
      "following_url": "https://api.github.com/users/kristapsk/following{/other_user}",
      "gists_url": "https://api.github.com/users/kristapsk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kristapsk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
      "organizations_url": "https://api.github.com/users/kristapsk/orgs",
      "repos_url": "https://api.github.com/users/kristapsk/repos",
      "events_url": "https://api.github.com/users/kristapsk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kristapsk/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "78f912c9010f686e2d1bbdc1c51f381b496c2a1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78f912c9010f686e2d1bbdc1c51f381b496c2a1b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/78f912c9010f686e2d1bbdc1c51f381b496c2a1b"
      }
    ],
    "stats": {
      "total": 282,
      "additions": 253,
      "deletions": 29
    },
    "files": [
      {
        "sha": "98165fc1f72f5b64547ebecc83befa7afa0dbd8a",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
        "patch": "@@ -61,6 +61,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"waitfornewblock\", 0, \"timeout\" },\n     { \"listtransactions\", 1, \"count\" },\n     { \"listtransactions\", 2, \"skip\" },\n+    { \"listtransactions\", 2, \"options\" },\n     { \"listtransactions\", 3, \"include_watchonly\" },\n     { \"walletpassphrase\", 1, \"timeout\" },\n     { \"getblocktemplate\", 0, \"template_request\" },"
      },
      {
        "sha": "de92f26769771ec9d1cedf3e4ae638958d8dc4a2",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 189,
        "deletions": 29,
        "changes": 218,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
        "patch": "@@ -1259,8 +1259,11 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n  * @param  ret            The UniValue into which the result is stored.\n  * @param  filter_ismine  The \"is mine\" filter flags.\n  * @param  filter_label   Optional label string to filter incoming transactions.\n+ * @param  limit          limits the insertion amount\n+ *\n+ * Returns true only if all elements got processed\n  */\n-static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static bool ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label, int limit = -1) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     CAmount nFee;\n     std::list<COutputEntry> listReceived;\n@@ -1276,6 +1279,10 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n         for (const COutputEntry& s : listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n+            // check for limit when new entry exists\n+            if (limit-- == 0) {\n+                return false;\n+            }\n             if (involvesWatchonly || (pwallet->IsMine(s.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n@@ -1307,6 +1314,10 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n             if (filter_label && label != *filter_label) {\n                 continue;\n             }\n+            // check for limit when new entry exists\n+            if (limit-- == 0) {\n+                return false;\n+            }\n             UniValue entry(UniValue::VOBJ);\n             if (involvesWatchonly || (pwallet->IsMine(r.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n@@ -1335,6 +1346,8 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n             ret.push_back(entry);\n         }\n     }\n+\n+    return true;\n }\n \n static const std::vector<RPCResult> TransactionDescriptionString()\n@@ -1363,12 +1376,22 @@ static RPCHelpMan listtransactions()\n {\n     return RPCHelpMan{\"listtransactions\",\n                 \"\\nIf a label name is provided, this will return only incoming transactions paying to addresses with the specified label.\\n\"\n-                \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions.\\n\",\n+                \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions.\\n\"\n+                \"\\nWhen 'paginatebypointer' option is given, the output will have the following changes:\\n\"\n+                \"1. Return transactions is ordered by most recent transactions. Though the default does reverse the order after transactions are fetched and clipped.\\n\"\n+                \"2. skip argument has no effect. Instead nextpagepointer will be used for pagination.\\n\"\n+                \"3. Return value is an object containing, records (array of txs) and nextpagepointer (string),\\n\",\n                 {\n                     {\"label|dummy\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"If set, should be a valid label name to return only incoming transactions\\n\"\n                           \"with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\"},\n                     {\"count\", RPCArg::Type::NUM, /* default */ \"10\", \"The number of transactions to return\"},\n-                    {\"skip\", RPCArg::Type::NUM, /* default */ \"0\", \"The number of transactions to skip\"},\n+                    {\"options|skip\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"for backward compatibility: passing in a number instead of an object will result in {\\\"skip\\\":nnn, \\\"paginatebypointer\\\":false}\",\n+                        {\n+                            {\"paginatebypointer\", RPCArg::Type::BOOL, /* default */ \"false\", \"If it is true it changes output type to an object containing records and nextpagepointer\"},\n+                            {\"nextpagepointer\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"A nullable string provided from previous calls to listtransactions for performing pagination\"},\n+                            {\"skip\", RPCArg::Type::NUM, /* default */ \"0\", \"The number of transactions to skip. If \\\"usesnextpagepointer\\\" option is true, skip won't have an effect.\"},\n+                        },\n+                        \"options\"},\n                     {\"include_watchonly\", RPCArg::Type::BOOL, /* default */ \"true for watch-only wallets, otherwise false\", \"Include transactions to watch-only addresses (see 'importaddress')\"},\n                 },\n                 RPCResult{\n@@ -1404,7 +1427,9 @@ static RPCHelpMan listtransactions()\n             \"\\nList transactions 100 to 120\\n\"\n             + HelpExampleCli(\"listtransactions\", \"\\\"*\\\" 20 100\") +\n             \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"listtransactions\", \"\\\"*\\\", 20, 100\")\n+            + HelpExampleRpc(\"listtransactions\", \"\\\"*\\\", 20, 100\") +\n+            \"\\nList transactions with paginatebypointer option\\n\"\n+            + HelpExampleCli(\"listtransactions\", \"\\\"*\\\" 20 '{\\\"paginatebypointer\\\":true}' false\")\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n@@ -1426,47 +1451,182 @@ static RPCHelpMan listtransactions()\n     int nCount = 10;\n     if (!request.params[1].isNull())\n         nCount = request.params[1].get_int();\n-    int nFrom = 0;\n-    if (!request.params[2].isNull())\n-        nFrom = request.params[2].get_int();\n+    if (nCount < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n+\n     isminefilter filter = ISMINE_SPENDABLE;\n \n     if (ParseIncludeWatchonly(request.params[3], *pwallet)) {\n         filter |= ISMINE_WATCH_ONLY;\n     }\n \n-    if (nCount < 0)\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n+    int nFrom = 0;\n+    bool paginatebypointer = false;\n+    std::string nextpagepointer;\n+    const UniValue& options = request.params[2];\n+    if (!options.isNull()) {\n+        if (options.type() == UniValue::VNUM) {\n+            // backward compatibility int only fallback\n+            nFrom = request.params[2].get_int();\n+        }\n+        else {\n+            RPCTypeCheckArgument(options, UniValue::VOBJ);\n+            RPCTypeCheckObj(options,\n+                {\n+                    {\"paginatebypointer\", UniValueType(UniValue::VBOOL)},\n+                    {\"nextpagepointer\", UniValueType(UniValue::VSTR)},\n+                    {\"skip\", UniValueType(UniValue::VNUM)},\n+                }, true, true);\n+            if (options.exists(\"paginatebypointer\")) {\n+                paginatebypointer = options[\"paginatebypointer\"].get_bool();\n+                if (options.exists(\"nextpagepointer\") &&\n+                    !options[\"nextpagepointer\"].isNull()) {\n+                    nextpagepointer = options[\"nextpagepointer\"].get_str();\n+                }\n+            }\n+            else if (options.exists(\"skip\")) {\n+                nFrom = options[\"skip\"].get_int();\n+            }\n+        }\n+    }\n+\n     if (nFrom < 0)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative from\");\n \n-    UniValue ret(UniValue::VARR);\n+    if (paginatebypointer) {\n+        uint256 nextHash;\n+        // if it is -1 it indicates nextpagepointer is not provided\n+        int32_t nextVOut = -1;\n+        bool nextIsSend = false;\n+        if (!nextpagepointer.empty()) {\n+            std::stringstream ss(nextpagepointer);\n+            std::string s;\n+            int i = 0;\n+            while (std::getline(ss, s, ':')) {\n+                if (i == 0) {\n+                    if (!IsHex(s)) {\n+                        break;\n+                    }\n+                    nextHash = uint256S(s);\n+                } else if (i == 1) {\n+                    if (!ParseInt32(s, &nextVOut)) {\n+                        break;\n+                    }\n+                } else if (i == 2) {\n+                    int32_t v;\n+                    if (!ParseInt32(s, &v)) {\n+                        break;\n+                    }\n+                    nextIsSend = v == 1;\n+                }\n+                i++;\n+            }\n+            if (i != 3) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, nextpagepointer expected to be in format <txid:vout:issend>\");\n+            }\n+        }\n \n-    {\n-        LOCK(pwallet->cs_wallet);\n+        UniValue txs(UniValue::VARR);\n+        bool hasMore = false;\n \n-        const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n+        {\n+            LOCK(pwallet->cs_wallet);\n+\n+            const CWallet::TxItems& txOrdered = pwallet->wtxOrdered;\n+            // iterate backwards until we have nCount items to return:\n+            CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin();\n+            if (nextVOut != -1) {\n+                // skip processing until txid match found\n+                while (it != txOrdered.rend()) {\n+                    CWalletTx *const pwtx = (*it++).second;\n+                    if (nextHash == pwtx->GetHash()) {\n+                        UniValue tmp(UniValue::VARR);\n+                        ListTransactions(pwallet, *pwtx, 0, true, tmp, filter, filter_label, -1);\n+                        unsigned int idx = 0;\n+                        while (idx < tmp.size()) {\n+                            const UniValue& o = tmp[idx++].get_obj();\n+                            const bool isSend = find_value(o, \"category\").get_str() == \"send\";\n+                            if (((isSend && nextIsSend) || !isSend) &&\n+                                find_value(o, \"vout\").get_int() == nextVOut) {\n+                                break;\n+                            }\n+                        }\n+                        for (; idx < tmp.size(); idx++) {\n+                            if (((int)txs.size()) >= nCount) {\n+                                hasMore = nCount > 0 && tmp.size() - idx - 1 > 0;\n+                                break;\n+                            }\n+                            txs.push_back(tmp[idx]);\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // when hasMore is true, no more need for rest of iteration\n+            if (!hasMore) {\n+                for (; it != txOrdered.rend(); ++it) {\n+                    CWalletTx *const pwtx = (*it).second;\n+                    // in all cases, nCount >= txs.size()\n+                    // There's no need to add more if statement\n+                    if (!ListTransactions(pwallet, *pwtx, 0, true, txs, filter, filter_label, nCount - txs.size())) {\n+                        hasMore = nCount > 0;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        UniValue ret(UniValue::VOBJ);\n+        ret.pushKV(\"records\", txs);\n+        if (hasMore) {\n+            const UniValue& lastTx = txs[txs.size()-1].get_obj();\n+            ret.pushKV(\"nextpagepointer\", strprintf(\"%s:%d:%d\", find_value(lastTx, \"txid\").get_str(), find_value(lastTx, \"vout\").get_int(), find_value(lastTx, \"category\").get_str() == \"send\" ? 1 : 0));\n+        } else {\n+            ret.pushKV(\"nextpagepointer\", NullUniValue); // set to null\n+        }\n+        return ret;\n+    } else {\n+        UniValue ret(UniValue::VARR);\n \n-        // iterate backwards until we have nCount items to return:\n-        for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n-            CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(pwallet, *pwtx, 0, true, ret, filter, filter_label);\n-            if ((int)ret.size() >= (nCount+nFrom)) break;\n+            LOCK(pwallet->cs_wallet);\n+\n+            const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n+\n+            // iterate backwards until we have nCount items to return:\n+            for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+                {\n+                    CWalletTx *const pwtx = (*it).second;\n+                    ListTransactions(pwallet, *pwtx, 0, true, ret, filter, filter_label);\n+                    if ((int)ret.size() >= (nCount+nFrom)) break;\n+                }\n         }\n-    }\n \n-    // ret is newest to oldest\n+        // ret is newest to oldest\n \n-    if (nFrom > (int)ret.size())\n-        nFrom = ret.size();\n-    if ((nFrom + nCount) > (int)ret.size())\n-        nCount = ret.size() - nFrom;\n+        if (nFrom > (int)ret.size())\n+            nFrom = ret.size();\n+        if ((nFrom + nCount) > (int)ret.size())\n+            nCount = ret.size() - nFrom;\n \n-    const std::vector<UniValue>& txs = ret.getValues();\n-    UniValue result{UniValue::VARR};\n-    result.push_backV({ txs.rend() - nFrom - nCount, txs.rend() - nFrom }); // Return oldest to newest\n-    return result;\n+        std::vector<UniValue> arrTmp = ret.getValues();\n+\n+        std::vector<UniValue>::iterator first = arrTmp.begin();\n+        std::advance(first, nFrom);\n+        std::vector<UniValue>::iterator last = arrTmp.begin();\n+        std::advance(last, nFrom+nCount);\n+\n+        if (last != arrTmp.end()) arrTmp.erase(last, arrTmp.end());\n+        if (first != arrTmp.begin()) arrTmp.erase(arrTmp.begin(), first);\n+\n+        std::reverse(arrTmp.begin(), arrTmp.end()); // Return oldest to newest\n+\n+        ret.clear();\n+        ret.setArray();\n+        ret.push_backV(arrTmp);\n+\n+        return ret;\n+    }\n },\n     };\n }\n@@ -4492,7 +4652,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listreceivedbyaddress\",            &listreceivedbyaddress,         {\"minconf\",\"include_empty\",\"include_watchonly\",\"address_filter\"} },\n     { \"wallet\",             \"listreceivedbylabel\",              &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"listsinceblock\",                   &listsinceblock,                {\"blockhash\",\"target_confirmations\",\"include_watchonly\",\"include_removed\"} },\n-    { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"label|dummy\",\"count\",\"skip\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"label|dummy\",\"count\",\"options|skip\",\"include_watchonly\"} },\n     { \"wallet\",             \"listunspent\",                      &listunspent,                   {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\",\"query_options\"} },\n     { \"wallet\",             \"listwalletdir\",                    &listwalletdir,                 {} },\n     { \"wallet\",             \"listwallets\",                      &listwallets,                   {} },"
      },
      {
        "sha": "debc235576e4b91bd88559fed7a7787ea026f674",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/480df47f8f5b6ad957115b39e3c4bd2c48a595bc/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=480df47f8f5b6ad957115b39e3c4bd2c48a595bc",
        "patch": "@@ -105,6 +105,69 @@ def run_test(self):\n                             {\"txid\": txid, \"label\": \"watchonly\"})\n \n         self.run_rbf_opt_in_test()\n+        self.run_with_paginatebypointer_test()\n+\n+    # specific tests with nextpagepointer flag\n+    def run_with_paginatebypointer_test(self):\n+        def get_with_paginatebypointer(node, count=20, label=\"*\", watchonly=False):\n+            i = 1\n+            records = []\n+            pointer = None\n+            while i < count:\n+                options = {\n+                    \"paginatebypointer\": True,\n+                    \"nextpagepointer\": pointer,\n+                }\n+                #if pointer is None:\n+                #    del options[\"nextpagepointer\"]\n+                result = node.listtransactions(label, i, options, watchonly)\n+                pointer = result.get(\"nextpagepointer\", None)\n+                records += result[\"records\"]\n+                if len(records) >= count or pointer is None:\n+                    break\n+                i += 1\n+            return records\n+        # Simple send, 0 to 1:\n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        self.sync_all()\n+        assert_array_result(get_with_paginatebypointer(self.nodes[0]),\n+                            {\"txid\": txid},\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 0})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"txid\": txid},\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n+\n+        # sendmany from node1: twice to self, twice to node2:\n+        send_to = {self.nodes[0].getnewaddress(): 0.111,\n+                   self.nodes[1].getnewaddress(): 0.222,\n+                   self.nodes[0].getnewaddress(): 0.333,\n+                   self.nodes[1].getnewaddress(): 0.444}\n+        txid = self.nodes[1].sendmany(\"\", send_to)\n+        self.sync_all()\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.111\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[0]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.111\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.222\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.222\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.333\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[0]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.333\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.444\")},\n+                            {\"txid\": txid})\n+        assert_array_result(get_with_paginatebypointer(self.nodes[1]),\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.444\")},\n+                            {\"txid\": txid})\n \n     # Check that the opt-in-rbf flag works properly, for sent and received\n     # transactions."
      }
    ]
  }
]