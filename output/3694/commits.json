[
  {
    "sha": "93a18a3650292afbb441a47d1fa1b94aeb0164e3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5M2ExOGEzNjUwMjkyYWZiYjQ0MWE0N2QxZmExYjk0YWViMDE2NGUz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-02-15T21:38:28Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-02-26T16:53:51Z"
      },
      "message": "Remove CWalletTx::vfSpent\n\nUse the spent outpoint multimap to figure out which wallet transaction\noutputs are unspent, instead of a vfSpent array that is saved\nto disk.",
      "tree": {
        "sha": "36382e2077820d469fd1257ee35375a86206a878",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/36382e2077820d469fd1257ee35375a86206a878"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/93a18a3650292afbb441a47d1fa1b94aeb0164e3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93a18a3650292afbb441a47d1fa1b94aeb0164e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/93a18a3650292afbb441a47d1fa1b94aeb0164e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93a18a3650292afbb441a47d1fa1b94aeb0164e3/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a16ad1c0f465935d437bd9ae9875b28be49ec65b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a16ad1c0f465935d437bd9ae9875b28be49ec65b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a16ad1c0f465935d437bd9ae9875b28be49ec65b"
      }
    ],
    "stats": {
      "total": 718,
      "additions": 356,
      "deletions": 362
    },
    "files": [
      {
        "sha": "15aede6c41b9cc4e64046ab19ebf95cce8627dfd",
        "filename": "qa/rpc-tests/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/README.md?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -1,9 +1,10 @@\n Regression tests of RPC interface\n =================================\n \n-wallet.sh : Exercise wallet send/receive code.\n+Bash scripts that use the RPC interface and command-line bitcoin-cli to test\n+full functionality in -regtest mode.\n \n-walletbackup.sh : Exercise wallet backup / dump / import\n+wallet.sh : Exercise wallet send/receive code.\n \n txnmall.sh : Test proper accounting of malleable transactions\n "
      },
      {
        "sha": "9d854d2d87bfba07bd5aedcf4bbde2a37b4d6690",
        "filename": "qa/rpc-tests/conflictedbalance.sh",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/conflictedbalance.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/conflictedbalance.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/conflictedbalance.sh?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -0,0 +1,143 @@\n+#!/usr/bin/env bash\n+\n+# Test marking of spent outputs\n+\n+# Create a transaction graph with four transactions,\n+# A/B/C/D\n+# C spends A\n+# D spends B and C\n+\n+# Then simulate C being mutated, to create C'\n+#  that is mined.\n+# A is still (correctly) considered spent.\n+# B should be treated as unspent\n+\n+if [ $# -lt 1 ]; then\n+        echo \"Usage: $0 path_to_binaries\"\n+        echo \"e.g. $0 ../../src\"\n+        exit 1\n+fi\n+\n+set -f\n+\n+BITCOIND=${1}/bitcoind\n+CLI=${1}/bitcoin-cli\n+\n+DIR=\"${BASH_SOURCE%/*}\"\n+SENDANDWAIT=\"${DIR}/send.sh\"\n+if [[ ! -d \"$DIR\" ]]; then DIR=\"$PWD\"; fi\n+. \"$DIR/util.sh\"\n+\n+D=$(mktemp -d test.XXXXX)\n+\n+# Two nodes; one will play the part of merchant, the\n+# other an evil transaction-mutating miner.\n+\n+D1=${D}/node1\n+CreateDataDir $D1 port=11000 rpcport=11001\n+B1ARGS=\"-datadir=$D1 -debug=mempool\"\n+$BITCOIND $B1ARGS &\n+B1PID=$!\n+\n+D2=${D}/node2\n+CreateDataDir $D2 port=11010 rpcport=11011\n+B2ARGS=\"-datadir=$D2 -debug=mempool\"\n+$BITCOIND $B2ARGS &\n+B2PID=$!\n+\n+# Wait until all four nodes are at the same block number\n+function WaitBlocks {\n+    while :\n+    do\n+        sleep 1\n+        declare -i BLOCKS1=$( GetBlocks $B1ARGS )\n+        declare -i BLOCKS2=$( GetBlocks $B2ARGS )\n+        if (( BLOCKS1 == BLOCKS2 ))\n+        then\n+            break\n+        fi\n+    done\n+}\n+\n+# Wait until node has $N peers\n+function WaitPeers {\n+    while :\n+    do\n+        declare -i PEERS=$( $CLI $1 getconnectioncount )\n+        if (( PEERS == \"$2\" ))\n+        then\n+            break\n+        fi\n+        sleep 1\n+    done\n+}\n+\n+echo \"Generating test blockchain...\"\n+\n+# Start with B2 connected to B1:\n+$CLI $B2ARGS addnode 127.0.0.1:11000 onetry\n+WaitPeers \"$B1ARGS\" 1\n+\n+# 2 block, 50 XBT each == 100 XBT\n+# These will be transactions \"A\" and \"B\"\n+$CLI $B1ARGS setgenerate true 2\n+\n+WaitBlocks\n+# 100 blocks, 0 mature == 0 XBT\n+$CLI $B2ARGS setgenerate true 100\n+WaitBlocks\n+\n+CheckBalance \"$B1ARGS\" 100\n+CheckBalance \"$B2ARGS\" 0\n+\n+# restart B2 with no connection\n+$CLI $B2ARGS stop > /dev/null 2>&1\n+wait $B2PID\n+$BITCOIND $B2ARGS &\n+B2PID=$!\n+\n+B1ADDRESS=$( $CLI $B1ARGS getnewaddress )\n+B2ADDRESS=$( $CLI $B2ARGS getnewaddress )\n+\n+# Transaction C: send-to-self, spend A\n+TXID_C=$( $CLI $B1ARGS sendtoaddress $B1ADDRESS 50.0)\n+\n+# Transaction D: spends B and C\n+TXID_D=$( $CLI $B1ARGS sendtoaddress $B2ADDRESS 100.0)\n+\n+CheckBalance \"$B1ARGS\" 0\n+\n+# Mutate TXID_C and add it to B2's memory pool:\n+RAWTX_C=$( $CLI $B1ARGS getrawtransaction $TXID_C )\n+\n+# ... mutate C to create C'\n+L=${RAWTX_C:82:2}\n+NEWLEN=$( printf \"%x\" $(( 16#$L + 1 )) )\n+MUTATEDTX_C=${RAWTX_C:0:82}${NEWLEN}4c${RAWTX_C:84}\n+# ... give mutated tx1 to B2:\n+MUTATEDTXID=$( $CLI $B2ARGS sendrawtransaction $MUTATEDTX_C )\n+\n+echo \"TXID_C: \" $TXID_C\n+echo \"Mutated: \" $MUTATEDTXID\n+\n+# Re-connect nodes, and have both nodes mine some blocks:\n+$CLI $B2ARGS addnode 127.0.0.1:11000 onetry\n+WaitPeers \"$B1ARGS\" 1\n+\n+# Having B2 mine the next block puts the mutated\n+# transaction C in the chain:\n+$CLI $B2ARGS setgenerate true 1\n+WaitBlocks\n+\n+# B1 should still be able to spend 100, because D is conflicted\n+# so does not count as a spend of B\n+CheckBalance \"$B1ARGS\" 100\n+\n+$CLI $B2ARGS stop > /dev/null 2>&1\n+wait $B2PID\n+$CLI $B1ARGS stop > /dev/null 2>&1\n+wait $B1PID\n+\n+echo \"Tests successful, cleaning up\"\n+rm -rf $D\n+exit 0"
      },
      {
        "sha": "11e02764946db369ffa6eb2f84428ff1ab4bdea8",
        "filename": "qa/rpc-tests/txnmall.sh",
        "status": "modified",
        "additions": 28,
        "deletions": 30,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/txnmall.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/txnmall.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txnmall.sh?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/env bash\n \n-# Test block generation and basic wallet sending\n+# Test proper accounting with malleable transactions\n \n if [ $# -lt 1 ]; then\n         echo \"Usage: $0 path_to_binaries\"\n@@ -35,16 +35,14 @@ B2ARGS=\"-datadir=$D2\"\n $BITCOIND $B2ARGS &\n B2PID=$!\n \n-trap \"kill -9 $B1PID $B2PID; rm -rf $D\" EXIT\n-\n-# Wait until all four nodes are at the same block number\n+# Wait until both nodes are at the same block number\n function WaitBlocks {\n     while :\n     do\n         sleep 1\n-        BLOCKS1=$( GetBlocks $B1ARGS )\n-        BLOCKS2=$( GetBlocks $B2ARGS )\n-        if (( $BLOCKS1 == $BLOCKS2 ))\n+        declare -i BLOCKS1=$( GetBlocks $B1ARGS )\n+        declare -i BLOCKS2=$( GetBlocks $B2ARGS )\n+        if (( BLOCKS1 == BLOCKS2 ))\n         then\n             break\n         fi\n@@ -55,15 +53,17 @@ function WaitBlocks {\n function WaitPeers {\n     while :\n     do\n-        PEERS=$( $CLI $1 getconnectioncount )\n-        if (( \"$PEERS\" == $2 ))\n+        declare -i PEERS=$( $CLI $1 getconnectioncount )\n+        if (( PEERS == \"$2\" ))\n         then\n             break\n         fi\n         sleep 1\n     done\n }\n \n+echo \"Generating test blockchain...\"\n+\n # Start with B2 connected to B1:\n $CLI $B2ARGS addnode 127.0.0.1:11000 onetry\n WaitPeers \"$B1ARGS\" 1\n@@ -76,29 +76,27 @@ WaitBlocks\n $CLI $B2ARGS setgenerate true 100\n WaitBlocks\n \n-CheckBalance $B1ARGS 50\n-CheckBalance $B2ARGS 0\n+CheckBalance \"$B1ARGS\" 50\n+CheckBalance \"$B2ARGS\" 0\n \n # restart B2 with no connection\n $CLI $B2ARGS stop > /dev/null 2>&1\n wait $B2PID\n $BITCOIND $B2ARGS &\n B2PID=$!\n \n-B2ADDRESS=$( $CLI $B2ARGS getnewaddress )\n+B2ADDRESS=$( $CLI $B2ARGS getaccountaddress \"from1\" )\n \n # Have B1 create two transactions; second will\n # spend change from first, since B1 starts with only a single\n # 50 bitcoin output:\n-$CLI $B1ARGS move \"\" \"foo\" 10.0\n-$CLI $B1ARGS move \"\" \"bar\" 10.0\n+$CLI $B1ARGS move \"\" \"foo\" 10.0 > /dev/null\n+$CLI $B1ARGS move \"\" \"bar\" 10.0 > /dev/null\n TXID1=$( $CLI $B1ARGS sendfrom foo $B2ADDRESS 1.0 0)\n TXID2=$( $CLI $B1ARGS sendfrom bar $B2ADDRESS 2.0 0)\n \n # Mutate TXID1 and add it to B2's memory pool:\n RAWTX1=$( $CLI $B1ARGS getrawtransaction $TXID1 )\n-RAWTX2=$( $CLI $B1ARGS getrawtransaction $TXID2 )\n-# ... mutate RAWTX1:\n # RAWTX1 is hex-encoded, serialized transaction. So each\n # byte is two characters; we'll prepend the first\n # \"push\" in the scriptsig with OP_PUSHDATA1 (0x4c),\n@@ -123,28 +121,28 @@ echo \"TXID1: \" $TXID1\n echo \"Mutated: \" $MUTATEDTXID\n \n # Re-connect nodes, and have B2 mine a block\n+# containing the mutant:\n $CLI $B2ARGS addnode 127.0.0.1:11000 onetry\n-WaitPeers \"$B1ARGS\" 1\n-\n-$CLI $B2ARGS setgenerate true 3\n-WaitBlocks\n-$CLI $B1ARGS setgenerate true 3\n+$CLI $B2ARGS setgenerate true 1\n WaitBlocks\n \n+# B1 should have 49 BTC; the 2 BTC send is\n+# conflicted, and should not count in\n+# balances.\n+CheckBalance \"$B1ARGS\" 49\n+CheckBalance \"$B1ARGS\" 49 \"*\"\n+CheckBalance \"$B1ARGS\" 9 \"foo\"\n+CheckBalance \"$B1ARGS\" 10 \"bar\"\n+\n+# B2 should have 51 BTC\n+CheckBalance \"$B2ARGS\" 51\n+CheckBalance \"$B2ARGS\" 1 \"from1\"\n+\n $CLI $B2ARGS stop > /dev/null 2>&1\n wait $B2PID\n $CLI $B1ARGS stop > /dev/null 2>&1\n wait $B1PID\n \n-trap \"\" EXIT\n-\n-echo \"Done, bitcoind's shut down. To rerun/poke around:\"\n-echo \"${1}/bitcoind -datadir=$D1 -daemon\"\n-echo \"${1}/bitcoind -datadir=$D2 -daemon -connect=127.0.0.1:11000\"\n-echo \"To cleanup:\"\n-echo \"killall bitcoind; rm -rf test.*\"\n-exit 0\n-\n echo \"Tests successful, cleaning up\"\n rm -rf $D\n exit 0"
      },
      {
        "sha": "9001c42fbc5878a06358d69b2f4bc1ab22f28af1",
        "filename": "qa/rpc-tests/util.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/util.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/util.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.sh?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -41,8 +41,9 @@ function AssertEqual {\n \n # CheckBalance -datadir=... amount account minconf\n function CheckBalance {\n+  declare -i EXPECT=\"$2\"\n   B=$( $CLI $1 getbalance $3 $4 )\n-  if (( $( echo \"$B == $2\" | bc ) == 0 ))\n+  if (( $( echo \"$B == $EXPECT\" | bc ) == 0 ))\n   then\n     echoerr \"bad balance: $B (expected $2)\"\n     exit 1\n@@ -87,5 +88,5 @@ function SendRawTxn {\n # Use: GetBlocks <datadir>\n # returns number of blocks from getinfo\n function GetBlocks {\n-    ExtractKey blocks \"$( $CLI $1 getinfo )\"\n+    $CLI $1 getblockcount\n }"
      },
      {
        "sha": "2940566af96356949d8d2ae8203b657acecaca03",
        "filename": "qa/rpc-tests/wallet.sh",
        "status": "modified",
        "additions": 20,
        "deletions": 19,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/wallet.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/qa/rpc-tests/wallet.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet.sh?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -8,6 +8,8 @@ if [ $# -lt 1 ]; then\n         exit 1\n fi\n \n+set -f\n+\n BITCOIND=${1}/bitcoind\n CLI=${1}/bitcoin-cli\n \n@@ -19,49 +21,49 @@ if [[ ! -d \"$DIR\" ]]; then DIR=\"$PWD\"; fi\n D=$(mktemp -d test.XXXXX)\n \n D1=${D}/node1\n-CreateDataDir $D1 port=11000 rpcport=11001\n+CreateDataDir \"$D1\" port=11000 rpcport=11001\n B1ARGS=\"-datadir=$D1\"\n $BITCOIND $B1ARGS &\n B1PID=$!\n \n D2=${D}/node2\n-CreateDataDir $D2 port=11010 rpcport=11011 connect=127.0.0.1:11000\n+CreateDataDir \"$D2\" port=11010 rpcport=11011 connect=127.0.0.1:11000\n B2ARGS=\"-datadir=$D2\"\n $BITCOIND $B2ARGS &\n B2PID=$!\n \n D3=${D}/node3\n-CreateDataDir $D3 port=11020 rpcport=11021 connect=127.0.0.1:11000\n+CreateDataDir \"$D3\" port=11020 rpcport=11021 connect=127.0.0.1:11000\n B3ARGS=\"-datadir=$D3\"\n $BITCOIND $BITCOINDARGS $B3ARGS &\n B3PID=$!\n \n-trap \"kill -9 $B1PID $B2PID $B3PID; rm -rf $D\" EXIT\n-\n # Wait until all three nodes are at the same block number\n function WaitBlocks {\n     while :\n     do\n         sleep 1\n-        BLOCKS1=$( GetBlocks $B1ARGS )\n-        BLOCKS2=$( GetBlocks $B2ARGS )\n-        BLOCKS3=$( GetBlocks $B3ARGS )\n-        if (( $BLOCKS1 == $BLOCKS2 && $BLOCKS2 == $BLOCKS3 ))\n+        declare -i BLOCKS1=$( GetBlocks $B1ARGS )\n+        declare -i BLOCKS2=$( GetBlocks $B2ARGS )\n+        declare -i BLOCKS3=$( GetBlocks $B3ARGS )\n+        if (( BLOCKS1 == BLOCKS2 && BLOCKS2 == BLOCKS3 ))\n         then\n             break\n         fi\n     done\n }\n \n+echo \"Generating test blockchain...\"\n+\n # 1 block, 50 XBT each == 50 XBT\n $CLI $B1ARGS setgenerate true 1\n WaitBlocks\n # 101 blocks, 1 mature == 50 XBT\n $CLI $B2ARGS setgenerate true 101\n WaitBlocks\n \n-CheckBalance $B1ARGS 50\n-CheckBalance $B2ARGS 50\n+CheckBalance \"$B1ARGS\" 50\n+CheckBalance \"$B2ARGS\" 50\n \n # Send 21 XBT from 1 to 3. Second\n # transaction will be child of first, and\n@@ -80,25 +82,25 @@ WaitBlocks\n \n # B1 should end up with 100 XBT in block rewards plus fees,\n # minus the 21 XBT sent to B3:\n-CheckBalance $B1ARGS \"100-21\"\n-CheckBalance $B3ARGS \"21\"\n+CheckBalance \"$B1ARGS\" \"100-21\"\n+CheckBalance \"$B3ARGS\" \"21\"\n \n # B1 should have two unspent outputs; create a couple\n # of raw transactions to send them to B3, submit them through\n # B2, and make sure both B1 and B3 pick them up properly:\n RAW1=$(CreateTxn1 $B1ARGS 1 $(Address $B3ARGS \"from1\" ) )\n RAW2=$(CreateTxn1 $B1ARGS 2 $(Address $B3ARGS \"from1\" ) )\n-RAWTXID1=$(SendRawTxn $B2ARGS $RAW1)\n-RAWTXID2=$(SendRawTxn $B2ARGS $RAW2)\n+RAWTXID1=$(SendRawTxn \"$B2ARGS\" $RAW1)\n+RAWTXID2=$(SendRawTxn \"$B2ARGS\" $RAW2)\n \n # Have B2 mine a block to confirm transactions:\n $CLI $B2ARGS setgenerate true 1\n WaitBlocks\n \n # Check balances after confirmation\n-CheckBalance $B1ARGS 0\n-CheckBalance $B3ARGS 100\n-CheckBalance $B3ARGS \"100-21\" \"from1\"\n+CheckBalance \"$B1ARGS\" 0\n+CheckBalance \"$B3ARGS\" 100\n+CheckBalance \"$B3ARGS\" \"100-21\" \"from1\"\n \n $CLI $B3ARGS stop > /dev/null 2>&1\n wait $B3PID\n@@ -108,6 +110,5 @@ $CLI $B1ARGS stop > /dev/null 2>&1\n wait $B1PID\n \n echo \"Tests successful, cleaning up\"\n-trap \"\" EXIT\n rm -rf $D\n exit 0"
      },
      {
        "sha": "b38973b18e54e946b4c3cb68268584a08d6404ab",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 4,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -1866,17 +1866,23 @@ bool static DisconnectTip(CValidationState &state) {\n     // Write the chain state to disk, if necessary.\n     if (!WriteChainState(state))\n         return false;\n-    // Ressurect mempool transactions from the disconnected block.\n+    // Resurrect mempool transactions from the disconnected block.\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n         // ignore validation errors in resurrected transactions\n+        list<CTransaction> removed;\n         CValidationState stateDummy; \n         if (!tx.IsCoinBase())\n             if (!AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))\n-                mempool.remove(tx, true);\n+                mempool.remove(tx, removed, true);\n     }\n     mempool.check(pcoinsTip);\n     // Update chainActive and related variables.\n     UpdateTip(pindexDelete->pprev);\n+    // Let wallets know transactions went from 1-confirmed to\n+    // 0-confirmed or conflicted:\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        SyncWithWallets(tx.GetHash(), tx, NULL);\n+    }\n     return true;\n }\n \n@@ -1907,13 +1913,24 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n     if (!WriteChainState(state))\n         return false;\n     // Remove conflicting transactions from the mempool.\n+    list<CTransaction> txConflicted;\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        mempool.remove(tx);\n-        mempool.removeConflicts(tx);\n+        list<CTransaction> unused;\n+        mempool.remove(tx, unused);\n+        mempool.removeConflicts(tx, txConflicted);\n     }\n     mempool.check(pcoinsTip);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew);\n+    // Tell wallet about transactions that went from mempool\n+    // to conflicted:\n+    BOOST_FOREACH(const CTransaction &tx, txConflicted) {\n+        SyncWithWallets(tx.GetHash(), tx, NULL);\n+    }\n+    // ... and about transactions that got confirmed:\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        SyncWithWallets(tx.GetHash(), tx, &block);\n+    }\n     return true;\n }\n "
      },
      {
        "sha": "2d8fcd7a521faeecb27ec436a2a756b6ec72426e",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -468,11 +468,12 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n     BOOST_FOREACH(const COutput& out, vOutputs)\n     {\n-        // unselect already spent, very unlikely scenario, this could happen when selected are spent elsewhere, like rpc or another computer\n-        if (out.tx->IsSpent(out.i))\n+        // unselect already spent, very unlikely scenario, this could happen\n+        // when selected are spent elsewhere, like rpc or another computer\n+        uint256 txhash = out.tx->GetHash();\n+        COutPoint outpt(txhash, out.i);\n+        if (model->isSpent(outpt))\n         {\n-            uint256 txhash = out.tx->GetHash();\n-            COutPoint outpt(txhash, out.i);\n             coinControl->UnSelect(outpt);\n             continue;\n         }"
      },
      {
        "sha": "eae448fee49c67515b4b43dfce0ebecbb2b61077",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -501,6 +501,12 @@ void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vect\n     }\n }\n \n+bool WalletModel::isSpent(const COutPoint& outpoint) const\n+{\n+    LOCK(wallet->cs_wallet);\n+    return wallet->IsSpent(outpoint.hash, outpoint.n);\n+}\n+\n // AvailableCoins + LockedCoins grouped by wallet address (put change in one group with wallet address)\n void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const\n {"
      },
      {
        "sha": "28a9169e273b467547fe5cd91f24ae65fc0313e2",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -180,6 +180,7 @@ class WalletModel : public QObject\n \n     bool getPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n     void getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs);\n+    bool isSpent(const COutPoint& outpoint) const;\n     void listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const;\n \n     bool isLockedCoin(uint256 hash, unsigned int n) const;"
      },
      {
        "sha": "635d4ac19bc3882d68b2ddbe6dbb45c99ea993ca",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -128,7 +128,6 @@ Value importprivkey(const Array& params, bool fHelp)\n \n         if (fRescan) {\n             pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n-            pwalletMain->ReacceptWalletTransactions();\n         }\n     }\n \n@@ -216,7 +215,6 @@ Value importwallet(const Array& params, bool fHelp)\n \n     LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n     pwalletMain->ScanForWalletTransactions(pindex);\n-    pwalletMain->ReacceptWalletTransactions();\n     pwalletMain->MarkDirty();\n \n     if (!fGood)"
      },
      {
        "sha": "d3b6c349a7a38fa6a67c47a32e115b45bc9668b6",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -560,7 +560,7 @@ int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n-        if (!IsFinalTx(wtx))\n+        if (!IsFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n             continue;\n \n         int64_t nReceived, nSent, nFee;\n@@ -1324,13 +1324,14 @@ Value listaccounts(const Array& params, bool fHelp)\n         string strSentAccount;\n         list<pair<CTxDestination, int64_t> > listReceived;\n         list<pair<CTxDestination, int64_t> > listSent;\n-        if (wtx.GetBlocksToMaturity() > 0)\n+        int nDepth = wtx.GetDepthInMainChain();\n+        if (wtx.GetBlocksToMaturity() > 0 || nDepth < 0)\n             continue;\n         wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount);\n         mapAccountBalances[strSentAccount] -= nFee;\n         BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64_t)& s, listSent)\n             mapAccountBalances[strSentAccount] -= s.second;\n-        if (wtx.GetDepthInMainChain() >= nMinDepth)\n+        if (nDepth >= nMinDepth)\n         {\n             BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64_t)& r, listReceived)\n                 if (pwalletMain->mapAddressBook.count(r.first))"
      },
      {
        "sha": "64c9eac73dcb560f4a73ddff42a0f10b4b1f053a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -86,7 +86,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry)\n }\n \n \n-bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n+void CTxMemPool::remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive)\n {\n     // Remove transaction from memory pool\n     {\n@@ -95,34 +95,37 @@ bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n         if (fRecursive) {\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n-                if (it != mapNextTx.end())\n-                    remove(*it->second.ptx, true);\n+                if (it == mapNextTx.end())\n+                    continue;\n+                remove(*it->second.ptx, removed, true);\n             }\n         }\n         if (mapTx.count(hash))\n         {\n+            removed.push_front(tx);\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n             mapTx.erase(hash);\n             nTransactionsUpdated++;\n         }\n     }\n-    return true;\n }\n \n-bool CTxMemPool::removeConflicts(const CTransaction &tx)\n+void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed)\n {\n     // Remove transactions which depend on inputs of tx, recursively\n+    list<CTransaction> result;\n     LOCK(cs);\n     BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n         std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n             const CTransaction &txConflict = *it->second.ptx;\n             if (txConflict != tx)\n-                remove(txConflict, true);\n+            {\n+                remove(txConflict, removed, true);\n+            }\n         }\n     }\n-    return true;\n }\n \n void CTxMemPool::clear()"
      },
      {
        "sha": "4509e95778c9ed98f7bd5c9803b90e61a6e602c7",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_TXMEMPOOL_H\n #define BITCOIN_TXMEMPOOL_H\n \n+#include <list>\n+\n #include \"coins.h\"\n #include \"core.h\"\n #include \"sync.h\"\n@@ -72,8 +74,8 @@ class CTxMemPool\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry);\n-    bool remove(const CTransaction &tx, bool fRecursive = false);\n-    bool removeConflicts(const CTransaction &tx);\n+    void remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive = false);\n+    void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);"
      },
      {
        "sha": "2514d24cc07114c435d5f079e493a25744ebd315",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 187,
        "changes": 270,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -32,6 +32,15 @@ struct CompareValueOnly\n     }\n };\n \n+const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n+{\n+    LOCK(cs_wallet);\n+    std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);\n+    if (it == mapWallet.end())\n+        return NULL;\n+    return &(it->second);\n+}\n+\n CPubKey CWallet::GenerateNewKey()\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n@@ -239,26 +248,28 @@ set<uint256> CWallet::GetConflicts(const uint256& txid) const\n         return result;\n     const CWalletTx& wtx = it->second;\n \n-    std::pair<TxConflicts::const_iterator, TxConflicts::const_iterator> range;\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n \n     BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n     {\n-        range = mapTxConflicts.equal_range(txin.prevout);\n-        for (TxConflicts::const_iterator it = range.first; it != range.second; ++it)\n+        if (mapTxSpends.count(txin.prevout) <= 1)\n+            continue;  // No conflict if zero or one spends\n+        range = mapTxSpends.equal_range(txin.prevout);\n+        for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n             result.insert(it->second);\n     }\n     return result;\n }\n \n-void CWallet::SyncMetaData(pair<TxConflicts::iterator, TxConflicts::iterator> range)\n+void CWallet::SyncMetaData(pair<TxSpends::iterator, TxSpends::iterator> range)\n {\n     // We want all the wallet transactions in range to have the same metadata as\n     // the oldest (smallest nOrderPos).\n     // So: find smallest nOrderPos:\n \n     int nMinOrderPos = std::numeric_limits<int>::max();\n     const CWalletTx* copyFrom = NULL;\n-    for (TxConflicts::iterator it = range.first; it != range.second; ++it)\n+    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n     {\n         const uint256& hash = it->second;\n         int n = mapWallet[hash].nOrderPos;\n@@ -269,7 +280,7 @@ void CWallet::SyncMetaData(pair<TxConflicts::iterator, TxConflicts::iterator> ra\n         }\n     }\n     // Now copy data from copyFrom to rest:\n-    for (TxConflicts::iterator it = range.first; it != range.second; ++it)\n+    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n     {\n         const uint256& hash = it->second;\n         CWalletTx* copyTo = &mapWallet[hash];\n@@ -281,28 +292,48 @@ void CWallet::SyncMetaData(pair<TxConflicts::iterator, TxConflicts::iterator> ra\n         copyTo->nTimeSmart = copyFrom->nTimeSmart;\n         copyTo->fFromMe = copyFrom->fFromMe;\n         copyTo->strFromAccount = copyFrom->strFromAccount;\n-        // vfSpent not copied on purpose\n         // nOrderPos not copied on purpose\n         // cached members not copied on purpose\n     }\n }\n \n-void CWallet::AddToConflicts(const uint256& wtxhash)\n+// Outpoint is spent if any non-conflicted transaction\n+// spends it:\n+bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n {\n-    assert(mapWallet.count(wtxhash));\n-    CWalletTx& thisTx = mapWallet[wtxhash];\n-    if (thisTx.IsCoinBase())\n-        return;\n+    const COutPoint outpoint(hash, n);\n+    pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+    range = mapTxSpends.equal_range(outpoint);\n \n-    BOOST_FOREACH(const CTxIn& txin, thisTx.vin)\n+    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n     {\n-        mapTxConflicts.insert(make_pair(txin.prevout, wtxhash));\n-\n-        pair<TxConflicts::iterator, TxConflicts::iterator> range;\n-        range = mapTxConflicts.equal_range(txin.prevout);\n-        if (range.first != range.second)\n-            SyncMetaData(range);\n+        const uint256& wtxid = it->second;\n+        std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);\n+        if (mit != mapWallet.end() && mit->second.GetDepthInMainChain() >= 0)\n+            return true; // Spent\n     }\n+    return false;\n+}\n+\n+void CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n+{\n+    mapTxSpends.insert(make_pair(outpoint, wtxid));\n+\n+    pair<TxSpends::iterator, TxSpends::iterator> range;\n+    range = mapTxSpends.equal_range(outpoint);\n+    SyncMetaData(range);\n+}\n+\n+\n+void CWallet::AddToSpends(const uint256& wtxid)\n+{\n+    assert(mapWallet.count(wtxid));\n+    CWalletTx& thisTx = mapWallet[wtxid];\n+    if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n+        return;\n+\n+    BOOST_FOREACH(const CTxIn& txin, thisTx.vin)\n+        AddToSpends(txin.prevout, wtxid);\n }\n \n bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n@@ -423,33 +454,6 @@ CWallet::TxItems CWallet::OrderedTxItems(std::list<CAccountingEntry>& acentries,\n     return txOrdered;\n }\n \n-void CWallet::WalletUpdateSpent(const CTransaction &tx)\n-{\n-    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n-    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n-    // restored from backup or the user making copies of wallet.dat.\n-    {\n-        LOCK(cs_wallet);\n-        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        {\n-            map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n-            if (mi != mapWallet.end())\n-            {\n-                CWalletTx& wtx = (*mi).second;\n-                if (txin.prevout.n >= wtx.vout.size())\n-                    LogPrintf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString());\n-                else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n-                {\n-                    LogPrintf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()), wtx.GetHash().ToString());\n-                    wtx.MarkSpent(txin.prevout.n);\n-                    wtx.WriteToDisk();\n-                    NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n void CWallet::MarkDirty()\n {\n     {\n@@ -466,7 +470,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet)\n     if (fFromLoadWallet)\n     {\n         mapWallet[hash] = wtxIn;\n-        AddToConflicts(hash);\n+        AddToSpends(hash);\n     }\n     else\n     {\n@@ -526,7 +530,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet)\n                              wtxIn.GetHash().ToString(),\n                              wtxIn.hashBlock.ToString());\n             }\n-            AddToConflicts(hash);\n+            AddToSpends(hash);\n         }\n \n         bool fUpdated = false;\n@@ -549,7 +553,6 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet)\n                 wtx.fFromMe = wtxIn.fFromMe;\n                 fUpdated = true;\n             }\n-            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n         }\n \n         //// debug print\n@@ -560,8 +563,8 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet)\n             if (!wtx.WriteToDisk())\n                 return false;\n \n-        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n-        WalletUpdateSpent(wtx);\n+        // Break debit/credit balance caches:\n+        wtx.MarkDirty();\n \n         // Notify UI of new or updated transaction\n         NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n@@ -596,14 +599,25 @@ bool CWallet::AddToWalletIfInvolvingMe(const uint256 &hash, const CTransaction&\n                 wtx.SetMerkleBranch(pblock);\n             return AddToWallet(wtx);\n         }\n-        else\n-            WalletUpdateSpent(tx);\n     }\n     return false;\n }\n \n-void CWallet::SyncTransaction(const uint256 &hash, const CTransaction& tx, const CBlock* pblock) {\n+void CWallet::SyncTransaction(const uint256 &hash, const CTransaction& tx, const CBlock* pblock)\n+{\n     AddToWalletIfInvolvingMe(hash, tx, pblock, true);\n+\n+    if (mapWallet.count(hash) == 0)\n+        return; // Not one of ours\n+\n+    // If a transaction changes 'conflicted' state, that changes the balance\n+    // available of the outputs it spends. So force those to be\n+    // recomputed, also:\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    {\n+        if (mapWallet.count(txin.prevout.hash))\n+            mapWallet[txin.prevout.hash].MarkDirty();\n+    }\n }\n \n void CWallet::EraseFromWallet(const uint256 &hash)\n@@ -804,78 +818,6 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, int64_t& nReceived,\n     }\n }\n \n-void CWalletTx::AddSupportingTransactions()\n-{\n-    vtxPrev.clear();\n-\n-    const int COPY_DEPTH = 3;\n-    if (SetMerkleBranch() < COPY_DEPTH)\n-    {\n-        vector<uint256> vWorkQueue;\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-            vWorkQueue.push_back(txin.prevout.hash);\n-\n-        {\n-            LOCK(pwallet->cs_wallet);\n-            map<uint256, const CMerkleTx*> mapWalletPrev;\n-            set<uint256> setAlreadyDone;\n-            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n-            {\n-                uint256 hash = vWorkQueue[i];\n-                if (setAlreadyDone.count(hash))\n-                    continue;\n-                setAlreadyDone.insert(hash);\n-\n-                CMerkleTx tx;\n-                map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n-                if (mi != pwallet->mapWallet.end())\n-                {\n-                    tx = (*mi).second;\n-                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n-                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n-                }\n-                else if (mapWalletPrev.count(hash))\n-                {\n-                    tx = *mapWalletPrev[hash];\n-                }\n-                else\n-                {\n-                    continue;\n-                }\n-\n-                int nDepth = tx.SetMerkleBranch();\n-                vtxPrev.push_back(tx);\n-\n-                if (nDepth < COPY_DEPTH)\n-                {\n-                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-                        vWorkQueue.push_back(txin.prevout.hash);\n-                }\n-            }\n-        }\n-    }\n-\n-    reverse(vtxPrev.begin(), vtxPrev.end());\n-}\n-\n-bool CWalletTx::AcceptWalletTransaction()\n-{\n-    {\n-        LOCK(mempool.cs);\n-        // Add previous supporting transactions first\n-        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n-        {\n-            if (!tx.IsCoinBase())\n-            {\n-                uint256 hash = tx.GetHash();\n-                if (!mempool.exists(hash) && pcoinsTip->HaveCoins(hash))\n-                    tx.AcceptToMemoryPool(false);\n-            }\n-        }\n-        return AcceptToMemoryPool(false);\n-    }\n-    return false;\n-}\n \n bool CWalletTx::WriteToDisk()\n {\n@@ -916,69 +858,26 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n \n void CWallet::ReacceptWalletTransactions()\n {\n-    bool fRepeat = true;\n-    while (fRepeat)\n+    LOCK(cs_wallet);\n+    BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n     {\n-        LOCK(cs_wallet);\n-        fRepeat = false;\n-        bool fMissing = false;\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n-        {\n-            CWalletTx& wtx = item.second;\n-            if (wtx.IsCoinBase() && wtx.IsSpent(0))\n-                continue;\n+        const uint256& wtxid = item.first;\n+        CWalletTx& wtx = item.second;\n+        assert(wtx.GetHash() == wtxid);\n \n-            CCoins coins;\n-            bool fUpdated = false;\n-            bool fFound = pcoinsTip->GetCoins(wtx.GetHash(), coins);\n-            if (fFound || wtx.GetDepthInMainChain() > 0)\n-            {\n-                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n-                for (unsigned int i = 0; i < wtx.vout.size(); i++)\n-                {\n-                    if (wtx.IsSpent(i))\n-                        continue;\n-                    if ((i >= coins.vout.size() || coins.vout[i].IsNull()) && IsMine(wtx.vout[i]))\n-                    {\n-                        wtx.MarkSpent(i);\n-                        fUpdated = true;\n-                        fMissing = true;\n-                    }\n-                }\n-                if (fUpdated)\n-                {\n-                    LogPrintf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()), wtx.GetHash().ToString());\n-                    wtx.MarkDirty();\n-                    wtx.WriteToDisk();\n-                }\n-            }\n-            else\n-            {\n-                // Re-accept any txes of ours that aren't already in a block\n-                if (!wtx.IsCoinBase())\n-                    wtx.AcceptWalletTransaction();\n-            }\n-        }\n-        if (fMissing)\n+        int nDepth = wtx.GetDepthInMainChain();\n+\n+        if (!wtx.IsCoinBase() && nDepth < 0)\n         {\n-            // TODO: optimize this to scan just part of the block chain?\n-            if (ScanForWalletTransactions(chainActive.Genesis()))\n-                fRepeat = true;  // Found missing transactions: re-do re-accept.\n+            // Try to add to memory pool\n+            LOCK(mempool.cs);\n+            wtx.AcceptToMemoryPool(false);\n         }\n     }\n }\n \n void CWalletTx::RelayWalletTransaction()\n {\n-    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n-    {\n-        // Important: versions of bitcoin before 0.8.6 had a bug that inserted\n-        // empty transactions into the vtxPrev, which will cause the node to be\n-        // banned when retransmitted, hence the check for !tx.vin.empty()\n-        if (!tx.IsCoinBase() && !tx.vin.empty())\n-            if (tx.GetDepthInMainChain() == 0)\n-                RelayTransaction((CTransaction)tx, tx.GetHash());\n-    }\n     if (!IsCoinBase())\n     {\n         if (GetDepthInMainChain() == 0) {\n@@ -1104,6 +1003,7 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n         LOCK(cs_wallet);\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n+            const uint256& wtxid = it->first;\n             const CWalletTx* pcoin = &(*it).second;\n \n             if (!IsFinalTx(*pcoin))\n@@ -1120,7 +1020,7 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n                 continue;\n \n             for (unsigned int i = 0; i < pcoin->vout.size(); i++) {\n-                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) &&\n+                if (!(IsSpent(wtxid, i)) && IsMine(pcoin->vout[i]) &&\n                     !IsLockedCoin((*it).first, i) && pcoin->vout[i].nValue > 0 &&\n                     (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                         vCoins.push_back(COutput(pcoin, i, nDepth));\n@@ -1452,8 +1352,6 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                     continue;\n                 }\n \n-                // Fill vtxPrev by copying from previous transactions vtxPrev\n-                wtxNew.AddSupportingTransactions();\n                 wtxNew.fTimeReceivedIsTxTime = true;\n \n                 break;\n@@ -1490,14 +1388,12 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n             // otherwise just for transaction history.\n             AddToWallet(wtxNew);\n \n-            // Mark old coins as spent\n+            // Notify that old coins are spent\n             set<CWalletTx*> setCoins;\n             BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n             {\n                 CWalletTx &coin = mapWallet[txin.prevout.hash];\n                 coin.BindWallet(this);\n-                coin.MarkSpent(txin.prevout.n);\n-                coin.WriteToDisk();\n                 NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n             }\n \n@@ -1855,7 +1751,7 @@ std::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n                 if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                     continue;\n \n-                int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n+                int64_t n = IsSpent(walletEntry.first, i) ? 0 : pcoin->vout[i].nValue;\n \n                 if (!balances.count(addr))\n                     balances[addr] = 0;"
      },
      {
        "sha": "7feb86d2943036f3ef799a0feaa63331e40f37bc",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 25,
        "deletions": 100,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/93a18a3650292afbb441a47d1fa1b94aeb0164e3/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=93a18a3650292afbb441a47d1fa1b94aeb0164e3",
        "patch": "@@ -108,11 +108,15 @@ class CWallet : public CCryptoKeyStore, public CWalletInterface\n     int64_t nNextResend;\n     int64_t nLastResend;\n \n-    // Used to detect and report conflicted transactions:\n-    typedef std::multimap<COutPoint, uint256> TxConflicts;\n-    TxConflicts mapTxConflicts;\n-    void AddToConflicts(const uint256& wtxhash);\n-    void SyncMetaData(std::pair<TxConflicts::iterator, TxConflicts::iterator>);\n+    // Used to keep track of spent outpoints, and\n+    // detect and report conflicts (double-spends or\n+    // mutated transactions where the mutant gets mined).\n+    typedef std::multimap<COutPoint, uint256> TxSpends;\n+    TxSpends mapTxSpends;\n+    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n+    void AddToSpends(const uint256& wtxid);\n+\n+    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n \n public:\n     /// Main wallet lock.\n@@ -169,12 +173,16 @@ class CWallet : public CCryptoKeyStore, public CWalletInterface\n \n     int64_t nTimeFirstKey;\n \n+    const CWalletTx* GetWalletTx(const uint256& hash) const;\n+\n     // check whether we are allowed to upgrade (or already support) to the named feature\n     bool CanSupportFeature(enum WalletFeature wf) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }\n \n     void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL) const;\n     bool SelectCoinsMinConf(int64_t nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const;\n \n+    bool IsSpent(const uint256& hash, unsigned int n) const;\n+\n     bool IsLockedCoin(uint256 hash, unsigned int n) const;\n     void LockCoin(COutPoint& output);\n     void UnlockCoin(COutPoint& output);\n@@ -234,7 +242,6 @@ class CWallet : public CCryptoKeyStore, public CWalletInterface\n     void SyncTransaction(const uint256 &hash, const CTransaction& tx, const CBlock* pblock);\n     bool AddToWalletIfInvolvingMe(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n     void EraseFromWallet(const uint256 &hash);\n-    void WalletUpdateSpent(const CTransaction& prevout);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions();\n@@ -439,15 +446,13 @@ class CWalletTx : public CMerkleTx\n     const CWallet* pwallet;\n \n public:\n-    std::vector<CMerkleTx> vtxPrev;\n     mapValue_t mapValue;\n     std::vector<std::pair<std::string, std::string> > vOrderForm;\n     unsigned int fTimeReceivedIsTxTime;\n     unsigned int nTimeReceived;  // time received by this node\n     unsigned int nTimeSmart;\n     char fFromMe;\n     std::string strFromAccount;\n-    std::vector<char> vfSpent; // which outputs are already spent\n     int64_t nOrderPos;  // position in ordered transaction list\n \n     // memory only\n@@ -485,15 +490,13 @@ class CWalletTx : public CMerkleTx\n     void Init(const CWallet* pwalletIn)\n     {\n         pwallet = pwalletIn;\n-        vtxPrev.clear();\n         mapValue.clear();\n         vOrderForm.clear();\n         fTimeReceivedIsTxTime = false;\n         nTimeReceived = 0;\n         nTimeSmart = 0;\n         fFromMe = false;\n         strFromAccount.clear();\n-        vfSpent.clear();\n         fDebitCached = false;\n         fCreditCached = false;\n         fImmatureCreditCached = false;\n@@ -518,23 +521,15 @@ class CWalletTx : public CMerkleTx\n         {\n             pthis->mapValue[\"fromaccount\"] = pthis->strFromAccount;\n \n-            std::string str;\n-            BOOST_FOREACH(char f, vfSpent)\n-            {\n-                str += (f ? '1' : '0');\n-                if (f)\n-                    fSpent = true;\n-            }\n-            pthis->mapValue[\"spent\"] = str;\n-\n             WriteOrderPos(pthis->nOrderPos, pthis->mapValue);\n \n             if (nTimeSmart)\n                 pthis->mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n         }\n \n         nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n-        READWRITE(vtxPrev);\n+        std::vector<CMerkleTx> vUnused; // Used to be vtxPrev\n+        READWRITE(vUnused);\n         READWRITE(mapValue);\n         READWRITE(vOrderForm);\n         READWRITE(fTimeReceivedIsTxTime);\n@@ -546,12 +541,6 @@ class CWalletTx : public CMerkleTx\n         {\n             pthis->strFromAccount = pthis->mapValue[\"fromaccount\"];\n \n-            if (mapValue.count(\"spent\"))\n-                BOOST_FOREACH(char c, pthis->mapValue[\"spent\"])\n-                    pthis->vfSpent.push_back(c != '0');\n-            else\n-                pthis->vfSpent.assign(vout.size(), fSpent);\n-\n             ReadOrderPos(pthis->nOrderPos, pthis->mapValue);\n \n             pthis->nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(pthis->mapValue[\"timesmart\"]) : 0;\n@@ -564,26 +553,6 @@ class CWalletTx : public CMerkleTx\n         pthis->mapValue.erase(\"timesmart\");\n     )\n \n-    // marks certain txout's as spent\n-    // returns true if any update took place\n-    bool UpdateSpent(const std::vector<char>& vfNewSpent)\n-    {\n-        bool fReturn = false;\n-        for (unsigned int i = 0; i < vfNewSpent.size(); i++)\n-        {\n-            if (i == vfSpent.size())\n-                break;\n-\n-            if (vfNewSpent[i] && !vfSpent[i])\n-            {\n-                vfSpent[i] = true;\n-                fReturn = true;\n-                fAvailableCreditCached = false;\n-            }\n-        }\n-        return fReturn;\n-    }\n-\n     // make sure balances are recalculated\n     void MarkDirty()\n     {\n@@ -599,27 +568,6 @@ class CWalletTx : public CMerkleTx\n         MarkDirty();\n     }\n \n-    void MarkSpent(unsigned int nOut)\n-    {\n-        if (nOut >= vout.size())\n-            throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n-        vfSpent.resize(vout.size());\n-        if (!vfSpent[nOut])\n-        {\n-            vfSpent[nOut] = true;\n-            fAvailableCreditCached = false;\n-        }\n-    }\n-\n-    bool IsSpent(unsigned int nOut) const\n-    {\n-        if (nOut >= vout.size())\n-            throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n-        if (nOut >= vfSpent.size())\n-            return false;\n-        return (!!vfSpent[nOut]);\n-    }\n-\n     int64_t GetDebit() const\n     {\n         if (vin.empty())\n@@ -661,6 +609,9 @@ class CWalletTx : public CMerkleTx\n \n     int64_t GetAvailableCredit(bool fUseCache=true) const\n     {\n+        if (pwallet == 0)\n+            return 0;\n+\n         // Must wait until coinbase is safely deep enough in the chain before valuing it\n         if (IsCoinBase() && GetBlocksToMaturity() > 0)\n             return 0;\n@@ -671,7 +622,7 @@ class CWalletTx : public CMerkleTx\n         int64_t nCredit = 0;\n         for (unsigned int i = 0; i < vout.size(); i++)\n         {\n-            if (!IsSpent(i))\n+            if (!pwallet->IsSpent(GetHash(), i))\n             {\n                 const CTxOut &txout = vout[i];\n                 nCredit += pwallet->GetCredit(txout);\n@@ -719,38 +670,14 @@ class CWalletTx : public CMerkleTx\n         if (!bSpendZeroConfChange || !IsFromMe()) // using wtx's cached debit\n             return false;\n \n-        // If no confirmations but it's from us, we can still\n-        // consider it confirmed if all dependencies are confirmed\n-        std::map<uint256, const CMerkleTx*> mapPrev;\n-        std::vector<const CMerkleTx*> vWorkQueue;\n-        vWorkQueue.reserve(vtxPrev.size()+1);\n-        vWorkQueue.push_back(this);\n-        for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+        // Trusted if all inputs are from us and are in the mempool:\n+        BOOST_FOREACH(const CTxIn& txin, vin)\n         {\n-            const CMerkleTx* ptx = vWorkQueue[i];\n-\n-            if (!IsFinalTx(*ptx))\n+            // Transactions not sent by us: not trusted\n+            const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n+            const CTxOut& parentOut = parent->vout[txin.prevout.n];\n+            if (parent == NULL || !pwallet->IsMine(parentOut))\n                 return false;\n-            int nPDepth = ptx->GetDepthInMainChain();\n-            if (nPDepth >= 1)\n-                continue;\n-            if (nPDepth < 0)\n-                return false;\n-            if (!pwallet->IsFromMe(*ptx))\n-                return false;\n-\n-            if (mapPrev.empty())\n-            {\n-                BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n-                    mapPrev[tx.GetHash()] = &tx;\n-            }\n-\n-            BOOST_FOREACH(const CTxIn& txin, ptx->vin)\n-            {\n-                if (!mapPrev.count(txin.prevout.hash))\n-                    return false;\n-                vWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n-            }\n         }\n         return true;\n     }\n@@ -760,8 +687,6 @@ class CWalletTx : public CMerkleTx\n     int64_t GetTxTime() const;\n     int GetRequestCount() const;\n \n-    void AddSupportingTransactions();\n-    bool AcceptWalletTransaction();\n     void RelayWalletTransaction();\n \n     std::set<uint256> GetConflicts() const;"
      }
    ]
  }
]