[
  {
    "sha": "8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YTJiNThkYjllZTZhMTRkMzZiNWQ4ZTQzMGIzNWYxOGU3YzdiMGM1",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-07-11T13:51:48Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2021-07-11T14:01:18Z"
      },
      "message": "test: fix segwit terminology (s/witness_program/witness_script/)",
      "tree": {
        "sha": "d68bc8a364f07574f8193c58f803245f9fd6d003",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d68bc8a364f07574f8193c58f803245f9fd6d003"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ab0c77299a5b184a8d0edf38f26a97bf9bbed6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ab0c77299a5b184a8d0edf38f26a97bf9bbed6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ab0c77299a5b184a8d0edf38f26a97bf9bbed6e"
      }
    ],
    "stats": {
      "total": 184,
      "additions": 92,
      "deletions": 92
    },
    "files": [
      {
        "sha": "3ad25f183eac60d677333a92efc624bfcdbbf3ff",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 90,
        "deletions": 90,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5",
        "patch": "@@ -102,7 +102,7 @@ def __init__(self, sha256, n, value):\n         self.nValue = value\n \n def sign_p2pk_witness_input(script, tx_to, in_idx, hashtype, value, key):\n-    \"\"\"Add signature for a P2PK witness program.\"\"\"\n+    \"\"\"Add signature for a P2PK witness script.\"\"\"\n     tx_hash = SegwitV0SignatureHash(script, tx_to, in_idx, hashtype, value)\n     signature = key.sign_ecdsa(tx_hash) + chr(hashtype).encode('latin-1')\n     tx_to.wit.vtxinwit[in_idx].scriptWitness.stack = [signature, script]\n@@ -281,7 +281,7 @@ def run_test(self):\n         self.test_submit_block()\n         self.test_extra_witness_data()\n         self.test_max_witness_push_length()\n-        self.test_max_witness_program_length()\n+        self.test_max_witness_script_length()\n         self.test_witness_input_length()\n         self.test_block_relay()\n         self.test_tx_relay_after_segwit_activation()\n@@ -488,8 +488,8 @@ def test_v0_outputs_arent_spendable(self):\n         self.disconnect_nodes(0, 2)\n \n         # Create two outputs, a p2wsh and p2sh-p2wsh\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         p2sh_script_pubkey = script_to_p2sh_script(script_pubkey)\n \n         value = self.utxo[0].nValue // 3\n@@ -624,9 +624,9 @@ def test_standardness_v0(self):\n         V0 segwit outputs and inputs are always standard.\n         V0 segwit inputs may only be mined after activation, but not before.\"\"\"\n \n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n-        p2sh_script_pubkey = script_to_p2sh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n+        p2sh_script_pubkey = script_to_p2sh_script(witness_script)\n \n         # First prepare a p2sh output (so that spending it will pass standardness)\n         p2sh_tx = CTransaction()\n@@ -642,7 +642,7 @@ def test_standardness_v0(self):\n         # Now test standardness of v0 P2WSH outputs.\n         # Start by creating a transaction with two outputs.\n         tx = CTransaction()\n-        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n+        tx.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_script]))]\n         tx.vout = [CTxOut(p2sh_tx.vout[0].nValue - 10000, script_pubkey)]\n         tx.vout.append(CTxOut(8000, script_pubkey))  # Might burn this later\n         tx.vin[0].nSequence = BIP125_SEQUENCE_NUMBER  # Just to have the option to bump this tx from the mempool\n@@ -653,14 +653,14 @@ def test_standardness_v0(self):\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx, with_witness=True, accepted=True)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n-        witness_hash = sha256(witness_program)\n+        witness_hash = sha256(witness_script)\n         script_pubkey = CScript([OP_0, hash160(witness_hash)])\n         tx2 = CTransaction()\n         # tx was accepted, so we spend the second output.\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 1), b\"\")]\n         tx2.vout = [CTxOut(7000, script_pubkey)]\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n \n         test_transaction_acceptance(self.nodes[1], self.std_node, tx2, with_witness=True, accepted=True)\n@@ -673,7 +673,7 @@ def test_standardness_v0(self):\n         tx3.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n         tx3.vout = [CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))]\n         tx3.wit.vtxinwit.append(CTxInWitness())\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx3.rehash()\n         if not self.segwit_active:\n             # Just check mempool acceptance, but don't add the transaction to the mempool, since witness is disallowed\n@@ -731,8 +731,8 @@ def test_p2sh_witness(self):\n         \"\"\"Test P2SH wrapped witness programs.\"\"\"\n \n         # Prepare the p2sh-wrapped witness output\n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        p2wsh_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        p2wsh_pubkey = script_to_p2wsh_script(witness_script)\n         script_pubkey = script_to_p2sh_script(p2wsh_pubkey)\n         script_sig = CScript([p2wsh_pubkey])  # a push of the redeem script\n \n@@ -776,7 +776,7 @@ def test_p2sh_witness(self):\n         spend_tx.vin[0].scriptSig = script_sig\n         spend_tx.rehash()\n         spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_program]\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [b'a', witness_script]\n \n         # Verify mempool acceptance\n         test_transaction_acceptance(self.nodes[0], self.test_node, spend_tx, with_witness=True, accepted=True)\n@@ -825,18 +825,18 @@ def test_witness_commitments(self):\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n \n-        # Let's construct a witness program\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        # Let's construct a witness script\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n \n         # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_program))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_script))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n \n         block_3 = self.build_next_block()\n@@ -871,7 +871,7 @@ def test_witness_commitments(self):\n         block_4 = self.build_next_block()\n         tx3 = CTransaction()\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n-        tx3.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_program))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue - 1000, witness_script))\n         tx3.rehash()\n         block_4.vtx.append(tx3)\n         block_4.hashMerkleRoot = block_4.calc_merkle_root()\n@@ -933,14 +933,14 @@ def test_witness_block_size(self):\n         assert len(self.utxo) > 0\n \n         # Create a P2WSH transaction.\n-        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # The witness script will be a bunch of OP_2DROP's, followed by OP_TRUE.\n         # This should give us plenty of room to tweak the spending tx's\n         # virtual size.\n         NUM_DROPS = 200  # 201 max ops per script!\n         NUM_OUTPUTS = 50\n \n-        witness_program = CScript([OP_2DROP] * NUM_DROPS + [OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_2DROP] * NUM_DROPS + [OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n         value = self.utxo[0].nValue\n@@ -960,7 +960,7 @@ def test_witness_block_size(self):\n         child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n         for _ in range(NUM_OUTPUTS):\n             child_tx.wit.vtxinwit.append(CTxInWitness())\n-            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a' * 195] * (2 * NUM_DROPS) + [witness_program]\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a' * 195] * (2 * NUM_DROPS) + [witness_script]\n         child_tx.rehash()\n         self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n \n@@ -1041,8 +1041,8 @@ def test_extra_witness_data(self):\n \n         block = self.build_next_block()\n \n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         # First try extra witness data on a tx that doesn't require a witness\n         tx = CTransaction()\n@@ -1073,7 +1073,7 @@ def test_extra_witness_data(self):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\"))  # non-witness\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.extend([CTxInWitness(), CTxInWitness()])\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_script]\n         tx2.wit.vtxinwit[1].scriptWitness.stack = [CScript([OP_TRUE])]\n \n         block = self.build_next_block()\n@@ -1113,8 +1113,8 @@ def test_max_witness_push_length(self):\n \n         block = self.build_next_block()\n \n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n@@ -1126,7 +1126,7 @@ def test_max_witness_push_length(self):\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n         # First try a 521-byte stack element\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * (MAX_SCRIPT_ELEMENT_SIZE + 1), witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a' * (MAX_SCRIPT_ELEMENT_SIZE + 1), witness_script]\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n@@ -1144,15 +1144,15 @@ def test_max_witness_push_length(self):\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n     @subtest  # type: ignore\n-    def test_max_witness_program_length(self):\n+    def test_max_witness_script_length(self):\n         \"\"\"Test that witness outputs greater than 10kB can't be spent.\"\"\"\n \n-        MAX_PROGRAM_LENGTH = 10000\n+        MAX_WITNESS_SCRIPT_LENGTH = 10000\n \n-        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n-        long_witness_program = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 63 + [OP_TRUE])\n-        assert len(long_witness_program) == MAX_PROGRAM_LENGTH + 1\n-        long_script_pubkey = script_to_p2wsh_script(long_witness_program)\n+        # This script is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_script = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 63 + [OP_TRUE])\n+        assert len(long_witness_script) == MAX_WITNESS_SCRIPT_LENGTH + 1\n+        long_script_pubkey = script_to_p2wsh_script(long_witness_script)\n \n         block = self.build_next_block()\n \n@@ -1165,22 +1165,22 @@ def test_max_witness_program_length(self):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, CScript([OP_TRUE])))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 44 + [long_witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 44 + [long_witness_script]\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n \n         test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n-        # Try again with one less byte in the witness program\n-        witness_program = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n-        assert len(witness_program) == MAX_PROGRAM_LENGTH\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        # Try again with one less byte in the witness script\n+        witness_script = CScript([b'a' * MAX_SCRIPT_ELEMENT_SIZE] * 19 + [OP_DROP] * 62 + [OP_TRUE])\n+        assert len(witness_script) == MAX_WITNESS_SCRIPT_LENGTH\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         tx.vout[0] = CTxOut(tx.vout[0].nValue, script_pubkey)\n         tx.rehash()\n         tx2.vin[0].prevout.hash = tx.sha256\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 43 + [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a'] * 43 + [witness_script]\n         tx2.rehash()\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n@@ -1193,8 +1193,8 @@ def test_max_witness_program_length(self):\n     def test_witness_input_length(self):\n         \"\"\"Test that vin length must match vtxinwit length.\"\"\"\n \n-        witness_program = CScript([OP_DROP, OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_DROP, OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         # Create a transaction that splits our utxo into many outputs\n         tx = CTransaction()\n@@ -1238,7 +1238,7 @@ def serialize_with_witness(self):\n         # First try using a too long vtxinwit\n         for i in range(11):\n             tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_script]\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n@@ -1254,15 +1254,15 @@ def serialize_with_witness(self):\n \n         # Now make one of the intermediate witnesses be incorrect\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n-        tx2.wit.vtxinwit[5].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_script]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [witness_script]\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n         # Fix the broken witness and the block should be accepted.\n-        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_script]\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n         test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -1300,8 +1300,8 @@ def test_tx_relay_after_segwit_activation(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Now try to add extra witness data to a valid witness tx.\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n@@ -1312,10 +1312,10 @@ def test_tx_relay_after_segwit_activation(self):\n         tx3.wit.vtxinwit.append(CTxInWitness())\n \n         # Add too-large for IsStandard witness and check that it does not enter reject filter\n-        p2sh_program = CScript([OP_TRUE])\n-        witness_program2 = CScript([b'a' * 400000])\n-        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_to_p2sh_script(p2sh_program)))\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program2]\n+        p2sh_script = CScript([OP_TRUE])\n+        witness_script2 = CScript([b'a' * 400000])\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_to_p2sh_script(p2sh_script)))\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_script2]\n         tx3.rehash()\n \n         # Node will not be blinded to the transaction, requesting it any number of times\n@@ -1329,14 +1329,14 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_script]\n         tx3.rehash()\n \n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=False)\n \n         # Get rid of the extra witness, and verify acceptance.\n-        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n         self.old_node.wait_for_inv([CInv(MSG_TX, tx2.sha256)])  # wait until tx2 was inv'ed\n@@ -1353,7 +1353,7 @@ def test_tx_relay_after_segwit_activation(self):\n         assert_equal(raw_tx[\"vsize\"], vsize)\n         assert_equal(raw_tx[\"weight\"], weight)\n         assert_equal(len(raw_tx[\"vin\"][0][\"txinwitness\"]), 1)\n-        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], witness_program.hex())\n+        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], witness_script.hex())\n         assert vsize != raw_tx[\"size\"]\n \n         # Cleanup: mine the transactions and update utxo for next test\n@@ -1389,8 +1389,8 @@ def test_segwit_versions(self):\n         self.sync_blocks()\n         temp_utxo = []\n         tx = CTransaction()\n-        witness_program = CScript([OP_TRUE])\n-        witness_hash = sha256(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_script)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n             # First try to spend to a future version segwit script_pubkey.\n@@ -1418,7 +1418,7 @@ def test_segwit_versions(self):\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n         tx2.vout = [CTxOut(tx.vout[0].nValue - 1000, script_pubkey)]\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n         # Gets accepted to both policy-enforcing nodes and others.\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, with_witness=True, accepted=True)\n@@ -1433,7 +1433,7 @@ def test_segwit_versions(self):\n             tx3.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n             tx3.wit.vtxinwit.append(CTxInWitness())\n             total_value += i.nValue\n-        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_script]\n         tx3.vout.append(CTxOut(total_value - 1000, script_pubkey))\n         tx3.rehash()\n \n@@ -1462,8 +1462,8 @@ def test_premature_coinbase_witness_spend(self):\n \n         block = self.build_next_block()\n         # Change the output of the block to be a witness output.\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n         block.vtx[0].vout[0].scriptPubKey = script_pubkey\n         # This next line will rehash the coinbase and update the merkle\n         # root, and solve.\n@@ -1472,9 +1472,9 @@ def test_premature_coinbase_witness_spend(self):\n \n         spend_tx = CTransaction()\n         spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n-        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n+        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_script)]\n         spend_tx.wit.vtxinwit.append(CTxInWitness())\n-        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         spend_tx.rehash()\n \n         # Now test a premature spend.\n@@ -1523,8 +1523,8 @@ def test_uncompressed_pubkey(self):\n \n         # Now try to spend it. Send it to a P2WSH output, which we'll\n         # use in the next test.\n-        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n-        script_wsh = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        script_wsh = script_to_p2wsh_script(witness_script)\n \n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n@@ -1553,7 +1553,7 @@ def test_uncompressed_pubkey(self):\n         tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n         tx3.vout.append(CTxOut(tx2.vout[0].nValue - 1000, script_p2sh))\n         tx3.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n@@ -1570,7 +1570,7 @@ def test_uncompressed_pubkey(self):\n         tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), script_sig))\n         tx4.vout.append(CTxOut(tx3.vout[0].nValue - 1000, script_pubkey))\n         tx4.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx4, True, False, 'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n@@ -1601,8 +1601,8 @@ def test_signature_version_1(self):\n         key.generate()\n         pubkey = key.get_pubkey().get_bytes()\n \n-        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         # First create a witness output for use in the tests.\n         tx = CTransaction()\n@@ -1629,18 +1629,18 @@ def test_signature_version_1(self):\n                 tx.vout.append(CTxOut(prev_utxo.nValue - 1000, script_pubkey))\n                 tx.wit.vtxinwit.append(CTxInWitness())\n                 # Too-large input value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n+                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue + 1, key)\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Too-small input value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n+                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue - 1, key)\n                 block.vtx.pop()  # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=False)\n \n                 # Now try correct value\n-                sign_p2pk_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n+                sign_p2pk_witness_input(witness_script, tx, 0, hashtype, prev_utxo.nValue, key)\n                 block.vtx.pop()\n                 self.update_witness_block_with_transactions(block, [tx])\n                 test_witness_block(self.nodes[0], self.test_node, block, accepted=True)\n@@ -1661,7 +1661,7 @@ def test_signature_version_1(self):\n         for _ in range(NUM_SIGHASH_TESTS):\n             tx.vout.append(CTxOut(split_value, script_pubkey))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n         for i in range(NUM_SIGHASH_TESTS):\n             temp_utxos.append(UTXO(tx.sha256, i, split_value))\n \n@@ -1696,7 +1696,7 @@ def test_signature_version_1(self):\n                 if random.randint(0, 1):\n                     anyonecanpay = SIGHASH_ANYONECANPAY\n                 hashtype = random.randint(1, 3) | anyonecanpay\n-                sign_p2pk_witness_input(witness_program, tx, i, hashtype, temp_utxos[i].nValue, key)\n+                sign_p2pk_witness_input(witness_script, tx, i, hashtype, temp_utxos[i].nValue, key)\n                 if (hashtype == SIGHASH_SINGLE and i >= num_outputs):\n                     used_sighash_single_out_of_bounds = True\n             tx.rehash()\n@@ -1726,7 +1726,7 @@ def test_signature_version_1(self):\n         tx.vin.append(CTxIn(COutPoint(temp_utxos[0].sha256, temp_utxos[0].n), b\"\"))\n         tx.vout.append(CTxOut(temp_utxos[0].nValue, script_pkh))\n         tx.wit.vtxinwit.append(CTxInWitness())\n-        sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n+        sign_p2pk_witness_input(witness_script, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n         tx2 = CTransaction()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n@@ -1766,7 +1766,7 @@ def test_signature_version_1(self):\n             # the signatures as we go.\n             tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n             tx.wit.vtxinwit.append(CTxInWitness())\n-            sign_p2pk_witness_input(witness_program, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n+            sign_p2pk_witness_input(witness_script, tx, index, SIGHASH_ALL | SIGHASH_ANYONECANPAY, i.nValue, key)\n             index += 1\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n@@ -1965,8 +1965,8 @@ def test_witness_sigops(self):\n         \"\"\"Test sigop counting is correct inside witnesses.\"\"\"\n \n         # Keep this under MAX_OPS_PER_SCRIPT (201)\n-        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG] * 5 + [OP_CHECKSIG] * 193 + [OP_ENDIF])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         sigops_per_script = 20 * 5 + 193 * 1\n         # We'll produce 2 extra outputs, one with a program that would take us\n@@ -1981,13 +1981,13 @@ def test_witness_sigops(self):\n         # This script, when spent with the first\n         # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n         # would push us just over the block sigop limit.\n-        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n-        script_pubkey_toomany = script_to_p2wsh_script(witness_program_toomany)\n+        witness_script_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available + 1) + [OP_ENDIF])\n+        script_pubkey_toomany = script_to_p2wsh_script(witness_script_toomany)\n \n         # If we spend this script instead, we would exactly reach our sigop\n         # limit (for witness sigops).\n-        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n-        script_pubkey_justright = script_to_p2wsh_script(witness_program_justright)\n+        witness_script_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG] * (extra_sigops_available) + [OP_ENDIF])\n+        script_pubkey_justright = script_to_p2wsh_script(witness_script_justright)\n \n         # First split our available utxo into a bunch of outputs\n         split_value = self.utxo[0].nValue // outputs\n@@ -2010,9 +2010,9 @@ def test_witness_sigops(self):\n         for i in range(outputs - 1):\n             tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n             tx2.wit.vtxinwit.append(CTxInWitness())\n-            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+            tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_script]\n             total_value += tx.vout[i].nValue\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_toomany]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_script_toomany]\n         tx2.vout.append(CTxOut(total_value, CScript([OP_TRUE])))\n         tx2.rehash()\n \n@@ -2051,7 +2051,7 @@ def test_witness_sigops(self):\n         tx2.vout.pop()\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs - 1), b\"\"))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_program_justright]\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [witness_script_justright]\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_5, [tx2])\n         test_witness_block(self.nodes[0], self.test_node, block_5, accepted=True)\n@@ -2119,8 +2119,8 @@ def received_wtxidrelay():\n \n         # Create a Segwit output from the latest UTXO\n         # and announce it to the network\n-        witness_program = CScript([OP_TRUE])\n-        script_pubkey = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_TRUE])\n+        script_pubkey = script_to_p2wsh_script(witness_script)\n \n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n@@ -2132,7 +2132,7 @@ def received_wtxidrelay():\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n         tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_script]\n         tx2.rehash()\n \n         # Announce Segwit transaction with wtxid"
      },
      {
        "sha": "9c4d9c46f06f77ecb4c6b8cb4034c2f82b9413dd",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=8a2b58db9ee6a14d36b5d8e430b35f18e7c7b0c5",
        "patch": "@@ -210,8 +210,8 @@ def witness_script(use_p2wsh, pubkey):\n         pkscript = key_to_p2wpkh_script(pubkey)\n     else:\n         # 1-of-1 multisig\n-        witness_program = CScript([OP_1, hex_str_to_bytes(pubkey), OP_1, OP_CHECKMULTISIG])\n-        pkscript = script_to_p2wsh_script(witness_program)\n+        witness_script = CScript([OP_1, hex_str_to_bytes(pubkey), OP_1, OP_CHECKMULTISIG])\n+        pkscript = script_to_p2wsh_script(witness_script)\n     return pkscript.hex()\n \n def create_witness_tx(node, use_p2wsh, utxo, pubkey, encode_p2sh, amount):"
      }
    ]
  }
]