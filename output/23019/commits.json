[
  {
    "sha": "4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
    "node_id": "C_kwDOABII59oAKDRjMjYyNWFhOWFjNDYzYzIyOGZmYjQwZTdhYTk5ODRhYTdhOTQ1MzM",
    "commit": {
      "author": {
        "name": "lsilva01",
        "email": "lsilva01@protonmail.com",
        "date": "2021-10-01T15:12:26Z"
      },
      "committer": {
        "name": "lsilva01",
        "email": "lsilva01@protonmail.com",
        "date": "2021-10-01T20:13:49Z"
      },
      "message": "Add listaddresses RPC",
      "tree": {
        "sha": "8f69b6e9b6ae117144edf0b8a2ef464e5ae4c185",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f69b6e9b6ae117144edf0b8a2ef464e5ae4c185"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/comments",
    "author": {
      "login": "lsilva01",
      "id": 84432093,
      "node_id": "MDQ6VXNlcjg0NDMyMDkz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsilva01",
      "html_url": "https://github.com/lsilva01",
      "followers_url": "https://api.github.com/users/lsilva01/followers",
      "following_url": "https://api.github.com/users/lsilva01/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsilva01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsilva01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
      "organizations_url": "https://api.github.com/users/lsilva01/orgs",
      "repos_url": "https://api.github.com/users/lsilva01/repos",
      "events_url": "https://api.github.com/users/lsilva01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsilva01/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lsilva01",
      "id": 84432093,
      "node_id": "MDQ6VXNlcjg0NDMyMDkz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsilva01",
      "html_url": "https://github.com/lsilva01",
      "followers_url": "https://api.github.com/users/lsilva01/followers",
      "following_url": "https://api.github.com/users/lsilva01/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsilva01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsilva01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
      "organizations_url": "https://api.github.com/users/lsilva01/orgs",
      "repos_url": "https://api.github.com/users/lsilva01/repos",
      "events_url": "https://api.github.com/users/lsilva01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsilva01/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3c776fdcec176ffaa2056633fa2b4e737cda29ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c776fdcec176ffaa2056633fa2b4e737cda29ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3c776fdcec176ffaa2056633fa2b4e737cda29ce"
      }
    ],
    "stats": {
      "total": 257,
      "additions": 257,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e3683946de15de87f414aeb6274040fa6bef7375",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 146,
        "deletions": 0,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "patch": "@@ -236,6 +236,151 @@ static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const Un\n     }\n }\n \n+UniValue AddDestinationInfo(const CTxDestination& dest, const CWallet& pwallet, bool detailed)\n+{\n+    UniValue ret(UniValue::VOBJ);\n+\n+    std::string currentAddress = EncodeDestination(dest);\n+    ret.pushKV(\"address\", currentAddress);\n+\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n+    if (detailed) ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey));\n+\n+    std::unique_ptr<SigningProvider> provider = pwallet.GetSolvingProvider(scriptPubKey);\n+\n+    if (provider) {\n+        auto inferred = InferDescriptor(scriptPubKey, *provider);\n+        bool solvable = inferred->IsSolvable() || IsSolvable(*provider, scriptPubKey);\n+        ret.pushKV(\"solvable\", solvable);\n+        if (solvable) {\n+            ret.pushKV(\"desc\", inferred->ToString());\n+        }\n+    } else {\n+        ret.pushKV(\"solvable\", false);\n+    }\n+\n+    ScriptPubKeyMan* spk_man = pwallet.GetScriptPubKeyMan(scriptPubKey);\n+    if (spk_man) {\n+        if (const std::unique_ptr<CKeyMetadata> meta = spk_man->GetMetadata(dest)) {\n+            if (detailed) ret.pushKV(\"timestamp\", meta->nCreateTime);\n+            if (meta->has_key_origin) {\n+                ret.pushKV(\"hdkeypath\", WriteHDKeypath(meta->key_origin.path));\n+                if (detailed) ret.pushKV(\"hdseedid\", meta->hd_seed_id.GetHex());\n+                if (detailed) ret.pushKV(\"hdmasterfingerprint\", HexStr(meta->key_origin.fingerprint));\n+            }\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n+static RPCHelpMan listaddresses()\n+{\n+    return RPCHelpMan{\"listaddresses\",\n+                \"\\nLists wallet addresses\\n\"\n+                \"In legacy wallets, addresses may be displayed in any order \\n\"\n+                \"In descriptor wallets, addresses are displayed in the BIP32 derivation order.  \\n\",\n+                {\n+                    {\"address_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -addresstype\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                },\n+                RPCResult{\n+                    RPCResult::Type::OBJ, \"\", \"\",{\n+                    {\n+                        RPCResult::Type::ARR, \"\", \"\",\n+                        {\n+                            {RPCResult::Type::OBJ, \"\", \"\", {\n+                                {RPCResult::Type::STR, \"address\", \"The bitcoin address\"},\n+                                {RPCResult::Type::STR, \"hdkeypath\", \"The BIP 32 HD path of the address\"},\n+                                {RPCResult::Type::STR, \"descriptor\", \"The address descriptor\"},\n+                                {RPCResult::Type::BOOL, \"internal\", \"The address is internal (change) or external (receive)\"},\n+                                {RPCResult::Type::STR, \"address_type\", \"The address type (legacy, p2sh-segwit, and bech32)\"},\n+                                {RPCResult::Type::NUM, \"amount\", \"Available amount at address\"},\n+                                {RPCResult::Type::BOOL, \"address_used\", \"This address has already received funds or not\"}\n+                            }},\n+                        },\n+                    }},\n+                },\n+                RPCExamples{\n+                    HelpExampleCli(\"listaddresses\", \"\")\n+                    + HelpExampleCli(\"listaddresses\", \"\\\"legacy\\\"\")\n+            + HelpExampleRpc(\"listaddresses\", \"\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n+\n+    pwallet->BlockUntilSyncedToCurrentChain();\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    if (!pwallet->CanGetAddresses()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: This wallet has no available keys\");\n+    }\n+\n+    OutputType output_type = pwallet->m_default_address_type;\n+    if (!request.params[0].isNull()) {\n+        std::optional<OutputType> parsed = ParseOutputType(request.params[0].get_str());\n+        if (!parsed) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[1].get_str()));\n+        } else if (parsed.value() == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Legacy wallets cannot provide bech32m addresses\");\n+        }\n+        output_type = parsed.value();\n+    }\n+\n+    auto addressbalances = GetAddressBalances(*pwallet);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    std::map<std::string, bool> used_addresses;\n+\n+    for (const std::pair<const uint256, CWalletTx>& wtx_pair : pwallet->mapWallet) {\n+        const CWalletTx& wtx = wtx_pair.second;\n+\n+        for (const CTxOut& txout : wtx.tx->vout) {\n+            CTxDestination address;\n+            if (ExtractDestination(txout.scriptPubKey, address) && pwallet->IsMine(address)) {\n+                used_addresses[EncodeDestination(address)] = true;\n+                break;\n+            }\n+        }\n+    }\n+\n+    bilingual_str error;\n+    std::map<bool, std::vector<CTxDestination>> map_internal_destinations;\n+    if (!pwallet->ListAddresses(output_type, map_internal_destinations, error)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n+    }\n+\n+    for (auto const& [internal, destinations] : map_internal_destinations)\n+    {\n+        UniValue list_address(UniValue::VARR);\n+\n+        for(auto destination : destinations) {\n+            auto it = addressbalances.find(destination);\n+            auto amount = (it != addressbalances.end()) ? it->second : 0;\n+\n+            UniValue item = AddDestinationInfo(destination, *pwallet, false);\n+            item.pushKV(\"address_type\", FormatOutputType(output_type));\n+            item.pushKV(\"internal\", internal);\n+            item.pushKV(\"amount\", ValueFromAmount(amount));\n+            item.pushKV(\"address_used\", used_addresses[item[\"address\"].get_str()]);\n+\n+            list_address.push_back(item);\n+        }\n+\n+        result.pushKV(\n+            internal ? \"change_addresses\" : \"receive_addresses\",\n+            list_address\n+        );\n+    }\n+\n+    return result;\n+},\n+    };\n+}\n+\n static RPCHelpMan getnewaddress()\n {\n     return RPCHelpMan{\"getnewaddress\",\n@@ -4778,6 +4923,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             &importwallet,                   },\n     { \"wallet\",             &keypoolrefill,                  },\n     { \"wallet\",             &listaddressgroupings,           },\n+    { \"wallet\",             &listaddresses,                  },\n     { \"wallet\",             &listdescriptors,                },\n     { \"wallet\",             &listlabels,                     },\n     { \"wallet\",             &listlockunspent,                },"
      },
      {
        "sha": "9d6d6443e686b765c878ba589b07ec4791bd69b7",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "patch": "@@ -1613,6 +1613,51 @@ std::set<CKeyID> LegacyScriptPubKeyMan::GetKeys() const\n     return set_address;\n }\n \n+void LegacyScriptPubKeyMan::ListAddresses(const OutputType type, std::vector<CTxDestination>& addresses, bool internal)\n+{\n+    LOCK(cs_KeyStore);\n+\n+    WalletBatch batch(m_storage.GetDatabase());\n+    std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : &setExternalKeyPool;\n+\n+    addresses.reserve(addresses.size() + setKeyPool->size());\n+\n+    auto it = setKeyPool->begin();\n+    while (it != std::end(*setKeyPool)) {\n+        CKeyPool keypool;\n+        if (batch.ReadPool(*(it), keypool)) {\n+            auto dest = GetDestinationForKey(keypool.vchPubKey, type);\n+            addresses.emplace_back(dest);\n+        }\n+        ++it;\n+    }\n+}\n+\n+void DescriptorScriptPubKeyMan::ListAddresses(const OutputType type, std::vector<CTxDestination>& addresses, bool internal)\n+{\n+    LOCK(cs_desc_man);\n+\n+    addresses.reserve(m_map_script_pub_keys.size());\n+\n+    std::vector<std::pair<CScript, int32_t>> temp_m_map_script_pub_keys;\n+\n+    for (auto& it : m_map_script_pub_keys) {\n+        temp_m_map_script_pub_keys.push_back(it);\n+    }\n+\n+    sort(temp_m_map_script_pub_keys.begin(), temp_m_map_script_pub_keys.end(),\n+        [](const std::pair<CScript, int32_t> & a, const std::pair<CScript, int32_t> & b) -> bool {\n+        return a.second < b.second;\n+    });\n+\n+    for (auto const& script_pub_key_item: temp_m_map_script_pub_keys) {\n+        CTxDestination dest;\n+        ExtractDestination(script_pub_key_item.first, dest);\n+\n+        addresses.emplace_back(dest);\n+    }\n+}\n+\n bool DescriptorScriptPubKeyMan::GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error)\n {\n     // Returns true if this descriptor supports getting new addresses. Conditions where we may be unable to fetch them (e.g. locked) are caught later"
      },
      {
        "sha": "d3b4401440d9f214fa07751b9efd70e53b597a26",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "patch": "@@ -163,6 +163,8 @@ class ScriptPubKeyMan\n public:\n     explicit ScriptPubKeyMan(WalletStorage& storage) : m_storage(storage) {}\n     virtual ~ScriptPubKeyMan() {};\n+\n+    virtual void ListAddresses(const OutputType type, std::vector<CTxDestination>& addresses, bool internal) {}\n     virtual bool GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error) { return false; }\n     virtual isminetype IsMine(const CScript& script) const { return ISMINE_NO; }\n \n@@ -344,6 +346,7 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n public:\n     using ScriptPubKeyMan::ScriptPubKeyMan;\n \n+    void ListAddresses(const OutputType type, std::vector<CTxDestination>& addresses, bool internal) override;\n     bool GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error) override;\n     isminetype IsMine(const CScript& script) const override;\n \n@@ -548,6 +551,7 @@ class DescriptorScriptPubKeyMan : public ScriptPubKeyMan\n \n     mutable RecursiveMutex cs_desc_man;\n \n+    void ListAddresses(const OutputType type, std::vector<CTxDestination>& addresses, bool internal) override;\n     bool GetNewDestination(const OutputType type, CTxDestination& dest, bilingual_str& error) override;\n     isminetype IsMine(const CScript& script) const override;\n "
      },
      {
        "sha": "92170561aef03ae00595cd0f2cf1a43f6dc9116e",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "patch": "@@ -2137,6 +2137,49 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n     return res;\n }\n \n+void CWallet::GetDestinationsFromAddressBook(std::vector<CTxDestination>& destinations, bool internal)\n+{\n+    LOCK(cs_wallet);\n+    auto start = m_address_book.begin();\n+    auto end = m_address_book.end();\n+\n+    for (auto item_it = start; item_it != end; ++item_it)\n+    {\n+        if (item_it->second.IsChange() != internal)\n+            continue;\n+\n+        destinations.emplace_back(item_it->first);\n+    }\n+}\n+\n+bool CWallet::ListAddresses(const OutputType output_type, std::map<bool, std::vector<CTxDestination>>& map_internal_destinations, bilingual_str& error)\n+{\n+    LOCK(cs_wallet);\n+    error.clear();\n+\n+    for (bool internal: { false, true }) {\n+        auto spk_man = GetScriptPubKeyMan(output_type, internal);\n+\n+        if (spk_man) {\n+\n+            std::vector<CTxDestination> destinations;\n+\n+            if (!IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {\n+                GetDestinationsFromAddressBook(destinations, internal);\n+            }\n+\n+            spk_man->ListAddresses(output_type, destinations, internal);\n+\n+            map_internal_destinations[internal] = destinations;\n+        } else {\n+            error = strprintf(_(\"Error: No %s addresses available.\"), FormatOutputType(output_type));\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool CWallet::GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, bilingual_str& error)\n {\n     LOCK(cs_wallet);"
      },
      {
        "sha": "690aecd32ac844d639fbcaa7f848ee1266bf1e23",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c2625aa9ac463c228ffb40e7aa9984aa7a94533/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "patch": "@@ -221,6 +221,21 @@ struct CRecipient\n     bool fSubtractFeeFromAmount;\n };\n \n+struct AddressInfo\n+{\n+    CTxDestination destination;\n+    std::string address;\n+    std::string hdkeypath;\n+    std::string descriptor;\n+    bool internal;\n+    std::string output_type;\n+    bool address_used;\n+\n+    AddressInfo(\n+        CTxDestination destination, std::string address, std::string hdkeypath, std::string descriptor, bool internal, std::string output_type, bool address_used)\n+        : destination{destination}, address{address}, hdkeypath{hdkeypath}, descriptor{descriptor}, internal{internal}, output_type{output_type}, address_used{address_used} {}\n+};\n+\n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n /**\n  * A CWallet maintains a set of transactions and balances, and provides the ability to create new transactions.\n@@ -339,6 +354,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     static bool AttachChain(const std::shared_ptr<CWallet>& wallet, interfaces::Chain& chain, bilingual_str& error, std::vector<bilingual_str>& warnings);\n \n+    void GetDestinationsFromAddressBook(std::vector<CTxDestination>& destinations, bool internal);\n+\n public:\n     /**\n      * Main wallet lock.\n@@ -641,6 +658,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     void MarkDestinationsDirty(const std::set<CTxDestination>& destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n+    void GetAddressInfoFromDestinations(const OutputType output_type, ScriptPubKeyMan* spk_man, std::vector<CTxDestination>& destinations, std::vector<AddressInfo>& address_info_list, bool internal);\n+    bool ListAddresses(const OutputType output_type, std::map<bool, std::vector<CTxDestination>>& map_internal_destinations, bilingual_str& error);\n     bool GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, bilingual_str& error);\n     bool GetNewChangeDestination(const OutputType type, CTxDestination& dest, bilingual_str& error);\n "
      }
    ]
  },
  {
    "sha": "b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
    "node_id": "C_kwDOABII59oAKGI1NGNjZmI4N2JmMmJmY2EzOTA0Y2UyM2FiOTg5NTJiYzIzNmRlYzA",
    "commit": {
      "author": {
        "name": "lsilva01",
        "email": "lsilva01@protonmail.com",
        "date": "2021-10-01T20:20:43Z"
      },
      "committer": {
        "name": "lsilva01",
        "email": "lsilva01@protonmail.com",
        "date": "2021-10-01T20:20:43Z"
      },
      "message": "Add functional test for listaddresses RPC",
      "tree": {
        "sha": "8e73f1570e9db146c0e615652b830af68e157444",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8e73f1570e9db146c0e615652b830af68e157444"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b54ccfb87bf2bfca3904ce23ab98952bc236dec0/comments",
    "author": {
      "login": "lsilva01",
      "id": 84432093,
      "node_id": "MDQ6VXNlcjg0NDMyMDkz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsilva01",
      "html_url": "https://github.com/lsilva01",
      "followers_url": "https://api.github.com/users/lsilva01/followers",
      "following_url": "https://api.github.com/users/lsilva01/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsilva01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsilva01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
      "organizations_url": "https://api.github.com/users/lsilva01/orgs",
      "repos_url": "https://api.github.com/users/lsilva01/repos",
      "events_url": "https://api.github.com/users/lsilva01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsilva01/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lsilva01",
      "id": 84432093,
      "node_id": "MDQ6VXNlcjg0NDMyMDkz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsilva01",
      "html_url": "https://github.com/lsilva01",
      "followers_url": "https://api.github.com/users/lsilva01/followers",
      "following_url": "https://api.github.com/users/lsilva01/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsilva01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsilva01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
      "organizations_url": "https://api.github.com/users/lsilva01/orgs",
      "repos_url": "https://api.github.com/users/lsilva01/repos",
      "events_url": "https://api.github.com/users/lsilva01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsilva01/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c2625aa9ac463c228ffb40e7aa9984aa7a94533",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c2625aa9ac463c228ffb40e7aa9984aa7a94533"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 66,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f1754154ee3691a63a206c60308c762b440bfd84",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b54ccfb87bf2bfca3904ce23ab98952bc236dec0/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b54ccfb87bf2bfca3904ce23ab98952bc236dec0/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
        "patch": "@@ -158,6 +158,8 @@\n     'wallet_createwallet.py --legacy-wallet',\n     'wallet_createwallet.py --usecli',\n     'wallet_createwallet.py --descriptors',\n+    'wallet_listaddresses.py --legacy-wallet',\n+    'wallet_listaddresses.py --descriptors',\n     'wallet_listtransactions.py --legacy-wallet',\n     'wallet_listtransactions.py --descriptors',\n     'wallet_watchonly.py --legacy-wallet',"
      },
      {
        "sha": "1a0a09a9bb078e266baee151f019f66219bf955f",
        "filename": "test/functional/wallet_listaddresses.py",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b54ccfb87bf2bfca3904ce23ab98952bc236dec0/test/functional/wallet_listaddresses.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b54ccfb87bf2bfca3904ce23ab98952bc236dec0/test/functional/wallet_listaddresses.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listaddresses.py?ref=b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
        "patch": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the listaddresses RPC.\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal\n+)\n+from random import randrange\n+\n+class ListAddressesTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_addresses(self, wallet, address_type = None):\n+\n+        new_address_list = []\n+        count_addr = 0\n+\n+        for i in range (10, randrange(15,20)):\n+            new_address_list.append(wallet.getnewaddress('', address_type))\n+\n+        list_addresses = wallet.listaddresses(address_type)\n+\n+        for i in range(0, len(list_addresses[\"receive_addresses\"])):\n+            rec_addr_item = list_addresses['receive_addresses'][i]\n+            rec_addr = rec_addr_item['address']\n+            if rec_addr in new_address_list:\n+                count_addr = count_addr + 1\n+\n+                rec_addr_info = wallet.getaddressinfo(rec_addr)\n+\n+                assert_equal(rec_addr_item['hdkeypath'], rec_addr_info['hdkeypath'])\n+                assert_equal(rec_addr_item['desc'], rec_addr_info['desc'])\n+                assert_equal(rec_addr_item['internal'], rec_addr_info['ischange'])\n+\n+        assert_equal(count_addr, len(new_address_list))\n+\n+        for i in range(0, len(list_addresses[\"change_addresses\"])):\n+            chg_addr_item = list_addresses['change_addresses'][i]\n+            chg_addr = chg_addr_item['address']\n+\n+            chg_addr_info = wallet.getaddressinfo(chg_addr)\n+\n+            assert_equal(chg_addr_item['hdkeypath'], chg_addr_info['hdkeypath'])\n+            assert_equal(chg_addr_item['desc'], chg_addr_info['desc'])\n+            assert_equal(chg_addr_item['internal'], chg_addr_info['ischange'])\n+\n+    def run_test(self):\n+\n+        wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        self.test_addresses(wallet)\n+        self.test_addresses(wallet, \"legacy\")\n+        self.test_addresses(wallet, \"p2sh-segwit\")\n+        self.test_addresses(wallet, \"bech32\")\n+\n+if __name__ == '__main__':\n+    ListAddressesTest().main()"
      }
    ]
  },
  {
    "sha": "fcade9b64d08aa7dfe83e00a105348ce06884700",
    "node_id": "C_kwDOABII59oAKGZjYWRlOWI2NGQwOGFhN2RmZTgzZTAwYTEwNTM0OGNlMDY4ODQ3MDA",
    "commit": {
      "author": {
        "name": "lsilva01",
        "email": "lsilva01@protonmail.com",
        "date": "2021-10-01T20:40:07Z"
      },
      "committer": {
        "name": "lsilva01",
        "email": "lsilva01@protonmail.com",
        "date": "2021-10-01T21:50:13Z"
      },
      "message": "Change getaddressinfo() to use AddDestinationInfo() function\n\ngetaddressinfo() and listddresses() have fields in common.\nAddDestinationInfo() was created to reuse the same code for both.\nIn this commit, getaddressinfo() is changed to call this function.",
      "tree": {
        "sha": "7bec1e31f24a567055cc2d82e019e3112975af22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7bec1e31f24a567055cc2d82e019e3112975af22"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fcade9b64d08aa7dfe83e00a105348ce06884700",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcade9b64d08aa7dfe83e00a105348ce06884700",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fcade9b64d08aa7dfe83e00a105348ce06884700",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcade9b64d08aa7dfe83e00a105348ce06884700/comments",
    "author": {
      "login": "lsilva01",
      "id": 84432093,
      "node_id": "MDQ6VXNlcjg0NDMyMDkz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsilva01",
      "html_url": "https://github.com/lsilva01",
      "followers_url": "https://api.github.com/users/lsilva01/followers",
      "following_url": "https://api.github.com/users/lsilva01/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsilva01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsilva01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
      "organizations_url": "https://api.github.com/users/lsilva01/orgs",
      "repos_url": "https://api.github.com/users/lsilva01/repos",
      "events_url": "https://api.github.com/users/lsilva01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsilva01/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "lsilva01",
      "id": 84432093,
      "node_id": "MDQ6VXNlcjg0NDMyMDkz",
      "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lsilva01",
      "html_url": "https://github.com/lsilva01",
      "followers_url": "https://api.github.com/users/lsilva01/followers",
      "following_url": "https://api.github.com/users/lsilva01/following{/other_user}",
      "gists_url": "https://api.github.com/users/lsilva01/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lsilva01/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
      "organizations_url": "https://api.github.com/users/lsilva01/orgs",
      "repos_url": "https://api.github.com/users/lsilva01/repos",
      "events_url": "https://api.github.com/users/lsilva01/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lsilva01/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b54ccfb87bf2bfca3904ce23ab98952bc236dec0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b54ccfb87bf2bfca3904ce23ab98952bc236dec0"
      }
    ],
    "stats": {
      "total": 355,
      "additions": 164,
      "deletions": 191
    },
    "files": [
      {
        "sha": "79ba74d0e29845c7c2e4a974fdbc73b2bc5930db",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 164,
        "deletions": 191,
        "changes": 355,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fcade9b64d08aa7dfe83e00a105348ce06884700/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fcade9b64d08aa7dfe83e00a105348ce06884700/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=fcade9b64d08aa7dfe83e00a105348ce06884700",
        "patch": "@@ -236,151 +236,6 @@ static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const Un\n     }\n }\n \n-UniValue AddDestinationInfo(const CTxDestination& dest, const CWallet& pwallet, bool detailed)\n-{\n-    UniValue ret(UniValue::VOBJ);\n-\n-    std::string currentAddress = EncodeDestination(dest);\n-    ret.pushKV(\"address\", currentAddress);\n-\n-    CScript scriptPubKey = GetScriptForDestination(dest);\n-    if (detailed) ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey));\n-\n-    std::unique_ptr<SigningProvider> provider = pwallet.GetSolvingProvider(scriptPubKey);\n-\n-    if (provider) {\n-        auto inferred = InferDescriptor(scriptPubKey, *provider);\n-        bool solvable = inferred->IsSolvable() || IsSolvable(*provider, scriptPubKey);\n-        ret.pushKV(\"solvable\", solvable);\n-        if (solvable) {\n-            ret.pushKV(\"desc\", inferred->ToString());\n-        }\n-    } else {\n-        ret.pushKV(\"solvable\", false);\n-    }\n-\n-    ScriptPubKeyMan* spk_man = pwallet.GetScriptPubKeyMan(scriptPubKey);\n-    if (spk_man) {\n-        if (const std::unique_ptr<CKeyMetadata> meta = spk_man->GetMetadata(dest)) {\n-            if (detailed) ret.pushKV(\"timestamp\", meta->nCreateTime);\n-            if (meta->has_key_origin) {\n-                ret.pushKV(\"hdkeypath\", WriteHDKeypath(meta->key_origin.path));\n-                if (detailed) ret.pushKV(\"hdseedid\", meta->hd_seed_id.GetHex());\n-                if (detailed) ret.pushKV(\"hdmasterfingerprint\", HexStr(meta->key_origin.fingerprint));\n-            }\n-        }\n-    }\n-\n-    return ret;\n-}\n-\n-static RPCHelpMan listaddresses()\n-{\n-    return RPCHelpMan{\"listaddresses\",\n-                \"\\nLists wallet addresses\\n\"\n-                \"In legacy wallets, addresses may be displayed in any order \\n\"\n-                \"In descriptor wallets, addresses are displayed in the BIP32 derivation order.  \\n\",\n-                {\n-                    {\"address_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -addresstype\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n-                },\n-                RPCResult{\n-                    RPCResult::Type::OBJ, \"\", \"\",{\n-                    {\n-                        RPCResult::Type::ARR, \"\", \"\",\n-                        {\n-                            {RPCResult::Type::OBJ, \"\", \"\", {\n-                                {RPCResult::Type::STR, \"address\", \"The bitcoin address\"},\n-                                {RPCResult::Type::STR, \"hdkeypath\", \"The BIP 32 HD path of the address\"},\n-                                {RPCResult::Type::STR, \"descriptor\", \"The address descriptor\"},\n-                                {RPCResult::Type::BOOL, \"internal\", \"The address is internal (change) or external (receive)\"},\n-                                {RPCResult::Type::STR, \"address_type\", \"The address type (legacy, p2sh-segwit, and bech32)\"},\n-                                {RPCResult::Type::NUM, \"amount\", \"Available amount at address\"},\n-                                {RPCResult::Type::BOOL, \"address_used\", \"This address has already received funds or not\"}\n-                            }},\n-                        },\n-                    }},\n-                },\n-                RPCExamples{\n-                    HelpExampleCli(\"listaddresses\", \"\")\n-                    + HelpExampleCli(\"listaddresses\", \"\\\"legacy\\\"\")\n-            + HelpExampleRpc(\"listaddresses\", \"\")\n-                },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n-    if (!pwallet) return NullUniValue;\n-\n-    pwallet->BlockUntilSyncedToCurrentChain();\n-\n-    LOCK(pwallet->cs_wallet);\n-\n-    if (!pwallet->CanGetAddresses()) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: This wallet has no available keys\");\n-    }\n-\n-    OutputType output_type = pwallet->m_default_address_type;\n-    if (!request.params[0].isNull()) {\n-        std::optional<OutputType> parsed = ParseOutputType(request.params[0].get_str());\n-        if (!parsed) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[1].get_str()));\n-        } else if (parsed.value() == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Legacy wallets cannot provide bech32m addresses\");\n-        }\n-        output_type = parsed.value();\n-    }\n-\n-    auto addressbalances = GetAddressBalances(*pwallet);\n-\n-    UniValue result(UniValue::VOBJ);\n-\n-    std::map<std::string, bool> used_addresses;\n-\n-    for (const std::pair<const uint256, CWalletTx>& wtx_pair : pwallet->mapWallet) {\n-        const CWalletTx& wtx = wtx_pair.second;\n-\n-        for (const CTxOut& txout : wtx.tx->vout) {\n-            CTxDestination address;\n-            if (ExtractDestination(txout.scriptPubKey, address) && pwallet->IsMine(address)) {\n-                used_addresses[EncodeDestination(address)] = true;\n-                break;\n-            }\n-        }\n-    }\n-\n-    bilingual_str error;\n-    std::map<bool, std::vector<CTxDestination>> map_internal_destinations;\n-    if (!pwallet->ListAddresses(output_type, map_internal_destinations, error)) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n-    }\n-\n-    for (auto const& [internal, destinations] : map_internal_destinations)\n-    {\n-        UniValue list_address(UniValue::VARR);\n-\n-        for(auto destination : destinations) {\n-            auto it = addressbalances.find(destination);\n-            auto amount = (it != addressbalances.end()) ? it->second : 0;\n-\n-            UniValue item = AddDestinationInfo(destination, *pwallet, false);\n-            item.pushKV(\"address_type\", FormatOutputType(output_type));\n-            item.pushKV(\"internal\", internal);\n-            item.pushKV(\"amount\", ValueFromAmount(amount));\n-            item.pushKV(\"address_used\", used_addresses[item[\"address\"].get_str()]);\n-\n-            list_address.push_back(item);\n-        }\n-\n-        result.pushKV(\n-            internal ? \"change_addresses\" : \"receive_addresses\",\n-            list_address\n-        );\n-    }\n-\n-    return result;\n-},\n-    };\n-}\n-\n static RPCHelpMan getnewaddress()\n {\n     return RPCHelpMan{\"getnewaddress\",\n@@ -4031,6 +3886,67 @@ static UniValue AddressBookDataToJSON(const CAddressBookData& data, const bool v\n     return ret;\n }\n \n+UniValue AddDestinationInfo(const CTxDestination& dest, const CWallet& pwallet, bool detailed)\n+{\n+    LOCK(pwallet.cs_wallet);\n+\n+    UniValue ret(UniValue::VOBJ);\n+\n+    std::string currentAddress = EncodeDestination(dest);\n+    ret.pushKV(\"address\", currentAddress);\n+\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n+    if (detailed) ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey));\n+\n+    std::unique_ptr<SigningProvider> provider = pwallet.GetSolvingProvider(scriptPubKey);\n+\n+    isminetype mine = pwallet.IsMine(dest);\n+\n+    if (detailed) ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n+\n+    if (provider) {\n+        auto inferred = InferDescriptor(scriptPubKey, *provider);\n+        bool solvable = inferred->IsSolvable() || IsSolvable(*provider, scriptPubKey);\n+        ret.pushKV(\"solvable\", solvable);\n+        if (solvable) {\n+            ret.pushKV(\"desc\", inferred->ToString());\n+        }\n+    } else {\n+        ret.pushKV(\"solvable\", false);\n+    }\n+\n+    if (detailed) {\n+        DescriptorScriptPubKeyMan* desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(pwallet.GetScriptPubKeyMan(scriptPubKey));\n+        if (desc_spk_man) {\n+            std::string desc_str;\n+            if (desc_spk_man->GetDescriptorString(desc_str, /* priv */ false)) {\n+                ret.pushKV(\"parent_desc\", desc_str);\n+            }\n+        }\n+\n+        ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n+\n+        UniValue detail = DescribeWalletAddress(pwallet, dest);\n+        ret.pushKVs(detail);\n+\n+        ret.pushKV(\"ischange\", ScriptIsChange(pwallet, scriptPubKey));\n+    }\n+\n+    ScriptPubKeyMan* spk_man = pwallet.GetScriptPubKeyMan(scriptPubKey);\n+    if (spk_man) {\n+        if (const std::unique_ptr<CKeyMetadata> meta = spk_man->GetMetadata(dest)) {\n+            if (detailed) ret.pushKV(\"timestamp\", meta->nCreateTime);\n+            if (meta->has_key_origin) {\n+                ret.pushKV(\"hdkeypath\", WriteHDKeypath(meta->key_origin.path));\n+                if (detailed) ret.pushKV(\"hdseedid\", meta->hd_seed_id.GetHex());\n+                if (detailed) ret.pushKV(\"hdmasterfingerprint\", HexStr(meta->key_origin.fingerprint));\n+            }\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n RPCHelpMan getaddressinfo()\n {\n     return RPCHelpMan{\"getaddressinfo\",\n@@ -4103,71 +4019,128 @@ RPCHelpMan getaddressinfo()\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, error_msg);\n     }\n \n-    UniValue ret(UniValue::VOBJ);\n+    UniValue ret = AddDestinationInfo(dest, *pwallet, true);\n \n-    std::string currentAddress = EncodeDestination(dest);\n-    ret.pushKV(\"address\", currentAddress);\n+    // Return a `labels` array containing the label associated with the address,\n+    // equivalent to the `label` field above. Currently only one label can be\n+    // associated with an address, but we return an array so the API remains\n+    // stable if we allow multiple labels to be associated with an address in\n+    // the future.\n+    UniValue labels(UniValue::VARR);\n+    const auto* address_book_entry = pwallet->FindAddressBookEntry(dest);\n+    if (address_book_entry) {\n+        labels.push_back(address_book_entry->GetLabel());\n+    }\n+    ret.pushKV(\"labels\", std::move(labels));\n \n-    CScript scriptPubKey = GetScriptForDestination(dest);\n-    ret.pushKV(\"scriptPubKey\", HexStr(scriptPubKey));\n+    return ret;\n+},\n+    };\n+}\n+\n+static RPCHelpMan listaddresses()\n+{\n+    return RPCHelpMan{\"listaddresses\",\n+                \"\\nLists wallet addresses\\n\"\n+                \"In legacy wallets, addresses may be displayed in any order \\n\"\n+                \"In descriptor wallets, addresses are displayed in the BIP32 derivation order.  \\n\",\n+                {\n+                    {\"address_type\", RPCArg::Type::STR, RPCArg::DefaultHint{\"set by -addresstype\"}, \"The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n+                },\n+                RPCResult{\n+                    RPCResult::Type::OBJ, \"\", \"\",{\n+                    {\n+                        RPCResult::Type::ARR, \"\", \"\",\n+                        {\n+                            {RPCResult::Type::OBJ, \"\", \"\", {\n+                                {RPCResult::Type::STR, \"address\", \"The bitcoin address\"},\n+                                {RPCResult::Type::STR, \"hdkeypath\", \"The BIP 32 HD path of the address\"},\n+                                {RPCResult::Type::STR, \"descriptor\", \"The address descriptor\"},\n+                                {RPCResult::Type::BOOL, \"internal\", \"The address is internal (change) or external (receive)\"},\n+                                {RPCResult::Type::STR, \"address_type\", \"The address type (legacy, p2sh-segwit, and bech32)\"},\n+                                {RPCResult::Type::NUM, \"amount\", \"Available amount at address\"},\n+                                {RPCResult::Type::BOOL, \"address_used\", \"This address has already received funds or not\"}\n+                            }},\n+                        },\n+                    }},\n+                },\n+                RPCExamples{\n+                    HelpExampleCli(\"listaddresses\", \"\")\n+                    + HelpExampleCli(\"listaddresses\", \"\\\"legacy\\\"\")\n+            + HelpExampleRpc(\"listaddresses\", \"\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    std::unique_ptr<SigningProvider> provider = pwallet->GetSolvingProvider(scriptPubKey);\n+    pwallet->BlockUntilSyncedToCurrentChain();\n \n-    isminetype mine = pwallet->IsMine(dest);\n-    ret.pushKV(\"ismine\", bool(mine & ISMINE_SPENDABLE));\n+    LOCK(pwallet->cs_wallet);\n \n-    if (provider) {\n-        auto inferred = InferDescriptor(scriptPubKey, *provider);\n-        bool solvable = inferred->IsSolvable() || IsSolvable(*provider, scriptPubKey);\n-        ret.pushKV(\"solvable\", solvable);\n-        if (solvable) {\n-            ret.pushKV(\"desc\", inferred->ToString());\n-        }\n-    } else {\n-        ret.pushKV(\"solvable\", false);\n+    if (!pwallet->CanGetAddresses()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: This wallet has no available keys\");\n     }\n \n-\n-    DescriptorScriptPubKeyMan* desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(pwallet->GetScriptPubKeyMan(scriptPubKey));\n-    if (desc_spk_man) {\n-        std::string desc_str;\n-        if (desc_spk_man->GetDescriptorString(desc_str, /* priv */ false)) {\n-            ret.pushKV(\"parent_desc\", desc_str);\n+    OutputType output_type = pwallet->m_default_address_type;\n+    if (!request.params[0].isNull()) {\n+        std::optional<OutputType> parsed = ParseOutputType(request.params[0].get_str());\n+        if (!parsed) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[1].get_str()));\n+        } else if (parsed.value() == OutputType::BECH32M && pwallet->GetLegacyScriptPubKeyMan()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Legacy wallets cannot provide bech32m addresses\");\n         }\n+        output_type = parsed.value();\n     }\n \n-    ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n+    auto addressbalances = GetAddressBalances(*pwallet);\n \n-    UniValue detail = DescribeWalletAddress(*pwallet, dest);\n-    ret.pushKVs(detail);\n+    UniValue result(UniValue::VOBJ);\n \n-    ret.pushKV(\"ischange\", ScriptIsChange(*pwallet, scriptPubKey));\n+    std::map<std::string, bool> used_addresses;\n \n-    ScriptPubKeyMan* spk_man = pwallet->GetScriptPubKeyMan(scriptPubKey);\n-    if (spk_man) {\n-        if (const std::unique_ptr<CKeyMetadata> meta = spk_man->GetMetadata(dest)) {\n-            ret.pushKV(\"timestamp\", meta->nCreateTime);\n-            if (meta->has_key_origin) {\n-                ret.pushKV(\"hdkeypath\", WriteHDKeypath(meta->key_origin.path));\n-                ret.pushKV(\"hdseedid\", meta->hd_seed_id.GetHex());\n-                ret.pushKV(\"hdmasterfingerprint\", HexStr(meta->key_origin.fingerprint));\n+    for (const std::pair<const uint256, CWalletTx>& wtx_pair : pwallet->mapWallet) {\n+        const CWalletTx& wtx = wtx_pair.second;\n+\n+        for (const CTxOut& txout : wtx.tx->vout) {\n+            CTxDestination address;\n+            if (ExtractDestination(txout.scriptPubKey, address) && pwallet->IsMine(address)) {\n+                used_addresses[EncodeDestination(address)] = true;\n+                break;\n             }\n         }\n     }\n \n-    // Return a `labels` array containing the label associated with the address,\n-    // equivalent to the `label` field above. Currently only one label can be\n-    // associated with an address, but we return an array so the API remains\n-    // stable if we allow multiple labels to be associated with an address in\n-    // the future.\n-    UniValue labels(UniValue::VARR);\n-    const auto* address_book_entry = pwallet->FindAddressBookEntry(dest);\n-    if (address_book_entry) {\n-        labels.push_back(address_book_entry->GetLabel());\n+    bilingual_str error;\n+    std::map<bool, std::vector<CTxDestination>> map_internal_destinations;\n+    if (!pwallet->ListAddresses(output_type, map_internal_destinations, error)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n     }\n-    ret.pushKV(\"labels\", std::move(labels));\n \n-    return ret;\n+    for (auto const& [internal, destinations] : map_internal_destinations)\n+    {\n+        UniValue list_address(UniValue::VARR);\n+\n+        for(auto destination : destinations) {\n+            auto it = addressbalances.find(destination);\n+            auto amount = (it != addressbalances.end()) ? it->second : 0;\n+\n+            UniValue item = AddDestinationInfo(destination, *pwallet, false);\n+            item.pushKV(\"address_type\", FormatOutputType(output_type));\n+            item.pushKV(\"internal\", internal);\n+            item.pushKV(\"amount\", ValueFromAmount(amount));\n+            item.pushKV(\"address_used\", used_addresses[item[\"address\"].get_str()]);\n+\n+            list_address.push_back(item);\n+        }\n+\n+        result.pushKV(\n+            internal ? \"change_addresses\" : \"receive_addresses\",\n+            list_address\n+        );\n+    }\n+\n+    return result;\n },\n     };\n }"
      }
    ]
  }
]