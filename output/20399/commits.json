[
  {
    "sha": "fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTA3NGQyYzdiOWMzZDM0ODc2YzQyOGQxMjY3MmE1MDVkNGNlNGVi",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-11-16T06:51:21Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-11-16T06:50:27Z"
      },
      "message": "Revert \"Merge #19606: Backport wtxid relay to v0.20\"\n\nThis reverts commit a339289c2ef9caffa1195436695a13f6e48e1bbc, reversing\nchanges made to b9ac31f2d29ae3e79c0f0cde5bab2d7213e6da51.",
      "tree": {
        "sha": "26338f3d5945b898c8ea9dfbd13d32679ec81040",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/26338f3d5945b898c8ea9dfbd13d32679ec81040"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiHvAv9G3NerSwQ/BI30tpO/EULMG7CpQebMggg9VWnFk+URrCkV/42TpB5NtCi\n/xYaZ44RmmhxFig9YXME6u9yAhqaFs0OpHhsxupAV5yqj1eZWwn/RoUmrq0SNm4g\n1Bar3NYAWm4AhVriHEtvu7ckeiLdbpQRwgZh6B3BeR/j2OLdqKpRJBdNbIaFNnWv\nKpof3mFiRNAnudEsuBANDOPW1jFVj5xSoINLIb/o0HtlhRY+sLN6llLkduJeHhyU\nrvQNaXZMBPX+i3j7uaeiOZHENvYEt/vRnexid6C6r3TQUYg+asLc/OfYo/UN9BTQ\nBgecNC33UpKIskhsgR6HYv4y7uDJmlR4i1QcUy9+mWbeNtbCv9aXnI8iGhpC6h5i\nqMvPe7VD7x2+1NeeXF1CsvCcXR36XFxK0TSxbrpl4Ncu87LJU96ot4kRHVZ/8yyR\nWxt3cbJh/PS+sqKG6cAgM7wBid4243WkNblv4SP66Sg8XqH9uZeT3EKShhNLMix+\nsoGOHmK5\n=NpjW\n-----END PGP SIGNATURE-----",
        "payload": "tree 26338f3d5945b898c8ea9dfbd13d32679ec81040\nparent a339289c2ef9caffa1195436695a13f6e48e1bbc\nauthor MarcoFalke <falke.marco@gmail.com> 1605509481 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1605509427 +0100\n\nRevert \"Merge #19606: Backport wtxid relay to v0.20\"\n\nThis reverts commit a339289c2ef9caffa1195436695a13f6e48e1bbc, reversing\nchanges made to b9ac31f2d29ae3e79c0f0cde5bab2d7213e6da51.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a339289c2ef9caffa1195436695a13f6e48e1bbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a339289c2ef9caffa1195436695a13f6e48e1bbc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a339289c2ef9caffa1195436695a13f6e48e1bbc"
      }
    ],
    "stats": {
      "total": 545,
      "additions": 101,
      "deletions": 444
    },
    "files": [
      {
        "sha": "3a90cd69b320e929d4f8c5950920d551108caa32",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -31,15 +31,11 @@ enum class TxValidationResult {\n     TX_MISSING_INPUTS,        //!< transaction was missing some of its inputs\n     TX_PREMATURE_SPEND,       //!< transaction spends a coinbase too early, or violates locktime/sequence locks\n     /**\n-     * Transaction might have a witness prior to SegWit\n+     * Transaction might be missing a witness, have a witness prior to SegWit\n      * activation, or witness may have been malleated (which includes\n      * non-standard witnesses).\n      */\n     TX_WITNESS_MUTATED,\n-    /**\n-     * Transaction is missing a witness.\n-     */\n-    TX_WITNESS_STRIPPED,\n     /**\n      * Tx already in mempool or conflicts with a tx in the chain\n      * (if it conflicts with another tx in mempool, we use MEMPOOL_POLICY as it failed to reach the RBF threshold)"
      },
      {
        "sha": "0dbd5e05496591831e196102463b979c6be9486e",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -969,11 +969,11 @@ class CNode\n     }\n \n \n-    void AddKnownTx(const uint256& hash)\n+    void AddInventoryKnown(const CInv& inv)\n     {\n         if (m_tx_relay != nullptr) {\n             LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n+            m_tx_relay->filterInventoryKnown.insert(inv.hash);\n         }\n     }\n "
      },
      {
        "sha": "8572ebb9f72dcb2d26474fd53ea61de1ba696e77",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 225,
        "changes": 282,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -68,8 +68,6 @@ static constexpr int HISTORICAL_BLOCK_AGE = 7 * 24 * 60 * 60;\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n /** Maximum number of announced transactions from a peer */\n static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n-/** How many microseconds to delay requesting transactions via txids, if we have wtxid-relaying peers */\n-static constexpr std::chrono::microseconds TXID_RELAY_DELAY{std::chrono::seconds{2}};\n /** How many microseconds to delay requesting transactions from inbound peers */\n static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};\n /** How long to wait (in microseconds) before downloading a transaction from an additional peer */\n@@ -93,7 +91,6 @@ struct COrphanTx {\n };\n RecursiveMutex g_cs_orphans;\n std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n-std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n \n void EraseOrphansFor(NodeId peer);\n \n@@ -145,15 +142,6 @@ namespace {\n      * million to make it highly unlikely for users to have issues with this\n      * filter.\n      *\n-     * We only need to add wtxids to this filter. For non-segwit\n-     * transactions, the txid == wtxid, so this only prevents us from\n-     * re-downloading non-segwit transactions when communicating with\n-     * non-wtxidrelay peers -- which is important for avoiding malleation\n-     * attacks that could otherwise interfere with transaction relay from\n-     * non-wtxidrelay peers. For communicating with wtxidrelay peers, having\n-     * the reject filter store wtxids is exactly what we want to avoid\n-     * redownload of a rejected transaction.\n-     *\n      * Memory used: 1.3 MB\n      */\n     std::unique_ptr<CRollingBloomFilter> recentRejects GUARDED_BY(cs_main);\n@@ -185,9 +173,6 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n-    /** Number of peers with wtxid relay. */\n-    int g_wtxid_relay_peers GUARDED_BY(cs_main) = 0;\n-\n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int g_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n \n@@ -376,9 +361,6 @@ struct CNodeState {\n     //! Whether this peer is a manual connection\n     bool m_is_manual_connection;\n \n-    //! Whether this peer relays txs via wtxid\n-    bool m_wtxid_relay{false};\n-\n     CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :\n         address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),\n         m_is_manual_connection (is_manual)\n@@ -729,7 +711,7 @@ void UpdateTxRequestTime(const uint256& txid, std::chrono::microseconds request_\n     }\n }\n \n-std::chrono::microseconds CalculateTxGetDataTime(const uint256& txid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+std::chrono::microseconds CalculateTxGetDataTime(const uint256& txid, std::chrono::microseconds current_time, bool use_inbound_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::chrono::microseconds process_time;\n     const auto last_request_time = GetTxRequestTime(txid);\n@@ -745,9 +727,6 @@ std::chrono::microseconds CalculateTxGetDataTime(const uint256& txid, std::chron\n     // We delay processing announcements from inbound peers\n     if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n \n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n     return process_time;\n }\n \n@@ -765,7 +744,7 @@ void RequestTx(CNodeState* state, const uint256& txid, std::chrono::microseconds\n \n     // Calculate the time to try requesting this transaction. Use\n     // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(txid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n+    const auto process_time = CalculateTxGetDataTime(txid, current_time, !state->fPreferredDownload);\n \n     peer_download_state.m_tx_process_time.emplace(process_time, txid);\n }\n@@ -822,8 +801,6 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     assert(nPeersWithValidatedDownloads >= 0);\n     g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n-    g_wtxid_relay_peers -= state->m_wtxid_relay;\n-    assert(g_wtxid_relay_peers >= 0);\n \n     mapNodeState.erase(nodeid);\n \n@@ -833,7 +810,6 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n         assert(g_outbound_peers_with_protect_from_disconnect == 0);\n-        assert(g_wtxid_relay_peers == 0);\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -892,8 +868,6 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n     auto ret = mapOrphanTransactions.emplace(hash, COrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME, g_orphan_list.size()});\n     assert(ret.second);\n     g_orphan_list.push_back(ret.first);\n-    // Allow for lookups in the orphan pool by wtxid, as well as txid\n-    g_orphans_by_wtxid.emplace(tx->GetWitnessHash(), ret.first);\n     for (const CTxIn& txin : tx->vin) {\n         mapOrphanTransactionsByPrev[txin.prevout].insert(ret.first);\n     }\n@@ -930,7 +904,6 @@ int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n         it_last->second.list_pos = old_pos;\n     }\n     g_orphan_list.pop_back();\n-    g_orphans_by_wtxid.erase(it->second.tx->GetWitnessHash());\n \n     mapOrphanTransactions.erase(it);\n     return 1;\n@@ -1101,7 +1074,6 @@ static bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state,\n     case TxValidationResult::TX_MISSING_INPUTS:\n     case TxValidationResult::TX_PREMATURE_SPEND:\n     case TxValidationResult::TX_WITNESS_MUTATED:\n-    case TxValidationResult::TX_WITNESS_STRIPPED:\n     case TxValidationResult::TX_CONFLICT:\n     case TxValidationResult::TX_MEMPOOL_POLICY:\n         break;\n@@ -1141,15 +1113,14 @@ PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, BanMan* banman, CS\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n \n     // Blocks don't typically have more than 4000 transactions, so this should\n-    // be at least six blocks (~1 hr) worth of transactions that we can store,\n-    // inserting both a txid and wtxid for every observed transaction.\n+    // be at least six blocks (~1 hr) worth of transactions that we can store.\n     // If the number of transactions appearing in a block goes up, or if we are\n     // seeing getdata requests more than an hour after initial announcement, we\n     // can increase this number.\n     // The false positive rate of 1/1M should come out to less than 1\n     // transaction per day that would be inadvertently ignored (which is the\n     // same probability that we have in the reject filter).\n-    g_recent_confirmed_transactions.reset(new CRollingBloomFilter(48000, 0.000001));\n+    g_recent_confirmed_transactions.reset(new CRollingBloomFilter(24000, 0.000001));\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     // Stale tip checking and peer eviction are on two different timers, but we\n@@ -1201,9 +1172,6 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         LOCK(g_cs_recent_confirmed_transactions);\n         for (const auto& ptx : pblock->vtx) {\n             g_recent_confirmed_transactions->insert(ptx->GetHash());\n-            if (ptx->GetHash() != ptx->GetWitnessHash()) {\n-                g_recent_confirmed_transactions->insert(ptx->GetWitnessHash());\n-            }\n         }\n     }\n }\n@@ -1356,7 +1324,6 @@ bool static AlreadyHave(const CInv& inv, const CTxMemPool& mempool) EXCLUSIVE_LO\n     {\n     case MSG_TX:\n     case MSG_WITNESS_TX:\n-    case MSG_WTX:\n         {\n             assert(recentRejects);\n             if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip)\n@@ -1371,20 +1338,16 @@ bool static AlreadyHave(const CInv& inv, const CTxMemPool& mempool) EXCLUSIVE_LO\n \n             {\n                 LOCK(g_cs_orphans);\n-                if (inv.type != MSG_WTX && mapOrphanTransactions.count(inv.hash)) {\n-                    return true;\n-                } else if (inv.type == MSG_WTX && g_orphans_by_wtxid.count(inv.hash)) {\n-                    return true;\n-                }\n+                if (mapOrphanTransactions.count(inv.hash)) return true;\n             }\n \n             {\n                 LOCK(g_cs_recent_confirmed_transactions);\n                 if (g_recent_confirmed_transactions->contains(inv.hash)) return true;\n             }\n \n-            const bool by_wtxid = (inv.type == MSG_WTX);\n-            return recentRejects->contains(inv.hash) || mempool.exists(inv.hash, by_wtxid);\n+            return recentRejects->contains(inv.hash) ||\n+                   mempool.exists(inv.hash);\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n@@ -1394,17 +1357,12 @@ bool static AlreadyHave(const CInv& inv, const CTxMemPool& mempool) EXCLUSIVE_LO\n     return true;\n }\n \n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n+void RelayTransaction(const uint256& txid, const CConnman& connman)\n {\n-    connman.ForEachNode([&txid, &wtxid](CNode* pnode)\n+    CInv inv(MSG_TX, txid);\n+    connman.ForEachNode([&inv](CNode* pnode)\n     {\n-        AssertLockHeld(cs_main);\n-        CNodeState &state = *State(pnode->GetId());\n-        if (state.m_wtxid_relay) {\n-            pnode->PushInventory({MSG_TX, wtxid});  // inv type is MSG_TX even for wtxid relay\n-        } else {\n-            pnode->PushInventory({MSG_TX, txid});\n-        }\n+        pnode->PushInventory(inv);\n     });\n }\n \n@@ -1619,7 +1577,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n         // Process as many TX items from the front of the getdata queue as\n         // possible, since they're common and it's efficient to batch process\n         // them.\n-        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX || it->type == MSG_WTX)) {\n+        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {\n             if (interruptMsgProc)\n                 return;\n             // The send buffer provides backpressure. If there's no space in\n@@ -1642,7 +1600,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n                 connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                 push = true;\n             } else {\n-                auto txinfo = mempool.info(inv.hash, inv.type == MSG_WTX);\n+                auto txinfo = mempool.info(inv.hash);\n                 // To protect privacy, do not answer getdata using the mempool when\n                 // that TX couldn't have been INVed in reply to a MEMPOOL request,\n                 // or when it's too recent to have expired from mapRelay.\n@@ -1922,7 +1880,7 @@ void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uin\n         if (setMisbehaving.count(fromPeer)) continue;\n         if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-            RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), *connman);\n+            RelayTransaction(orphanHash, *connman);\n             for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(orphanHash, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n@@ -1944,35 +1902,17 @@ void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uin\n             // Has inputs but not accepted to mempool\n             // Probably non-standard or insufficient fee\n             LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n-            if (orphan_state.GetResult() != TxValidationResult::TX_WITNESS_STRIPPED) {\n-                // We can add the wtxid of this transaction to our reject filter.\n-                // Do not add txids of witness transactions or witness-stripped\n-                // transactions to the filter, as they can have been malleated;\n-                // adding such txids to the reject filter would potentially\n-                // interfere with relay of valid transactions from peers that\n-                // do not support wtxid-based relay. See\n-                // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                // We can remove this restriction (and always add wtxids to\n-                // the filter even for witness stripped transactions) once\n-                // wtxid-based relay is broadly deployed.\n-                // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n-                // for concerns around weakening security of unupgraded nodes\n-                // if we start doing this too early.\n-                assert(recentRejects);\n-                recentRejects->insert(orphanTx.GetWitnessHash());\n-                // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+            if ((!orphanTx.HasWitness() && orphan_state.GetResult() != TxValidationResult::TX_WITNESS_MUTATED) ||\n+                    orphan_state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD) {\n+                // Do not use rejection cache for witness transactions or\n+                // witness-stripped transactions, as they can have been malleated.\n+                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+                // However, if the transaction failed for TX_INPUTS_NOT_STANDARD,\n                 // then we know that the witness was irrelevant to the policy\n                 // failure, since this check depends only on the txid\n                 // (the scriptPubKey being spent is covered by the txid).\n-                // Add the txid to the reject filter to prevent repeated\n-                // processing of this transaction in the event that child\n-                // transactions are later received (resulting in\n-                // parent-fetching by txid via the orphan-handling logic).\n-                if (orphan_state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && orphanTx.GetWitnessHash() != orphanTx.GetHash()) {\n-                    // We only add the txid if it differs from the wtxid, to\n-                    // avoid wasting entries in the rolling bloom filter.\n-                    recentRejects->insert(orphanTx.GetHash());\n-                }\n+                assert(recentRejects);\n+                recentRejects->insert(orphanHash);\n             }\n             EraseOrphanTx(orphanHash);\n             done = true;\n@@ -2076,10 +2016,6 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         if (pfrom->fInbound)\n             PushNodeVersion(pfrom, connman, GetAdjustedTime());\n \n-        if (nVersion >= WTXID_RELAY_VERSION) {\n-            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::WTXIDRELAY));\n-        }\n-\n         connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n         pfrom->nServices = nServices;\n@@ -2219,25 +2155,6 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         return true;\n     }\n \n-    // Feature negotiation of wtxidrelay should happen between VERSION and\n-    // VERACK, to avoid relay problems from switching after a connection is up\n-    if (msg_type == NetMsgType::WTXIDRELAY) {\n-        if (pfrom->fSuccessfullyConnected) {\n-            // Disconnect peers that send wtxidrelay message after VERACK; this\n-            // must be negotiated between VERSION and VERACK.\n-            pfrom->fDisconnect = true;\n-            return false;\n-        }\n-        if (pfrom->nVersion >= WTXID_RELAY_VERSION) {\n-            LOCK(cs_main);\n-            if (!State(pfrom->GetId())->m_wtxid_relay) {\n-                State(pfrom->GetId())->m_wtxid_relay = true;\n-                g_wtxid_relay_peers++;\n-            }\n-        }\n-        return false;\n-    }\n-\n     if (!pfrom->fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n         LOCK(cs_main);\n@@ -2358,13 +2275,6 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n             if (interruptMsgProc)\n                 return true;\n \n-            // ignore INVs that don't match wtxidrelay setting\n-            if (State(pfrom->GetId())->m_wtxid_relay) {\n-                if (inv.type == MSG_TX) continue;\n-            } else {\n-                if (inv.type == MSG_WTX) continue;\n-            }\n-\n             bool fAlreadyHave = AlreadyHave(inv, mempool);\n             LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());\n \n@@ -2383,7 +2293,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                     best_block = &inv.hash;\n                 }\n             } else {\n-                pfrom->AddKnownTx(inv.hash);\n+                pfrom->AddInventoryKnown(inv);\n                 if (fBlocksOnly) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n                     pfrom->fDisconnect = true;\n@@ -2622,50 +2532,26 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         vRecv >> ptx;\n         const CTransaction& tx = *ptx;\n \n-        const uint256& txid = ptx->GetHash();\n-        const uint256& wtxid = ptx->GetWitnessHash();\n+        CInv inv(MSG_TX, tx.GetHash());\n+        pfrom->AddInventoryKnown(inv);\n \n         LOCK2(cs_main, g_cs_orphans);\n \n-        CNodeState* nodestate = State(pfrom->GetId());\n-\n-        const uint256& hash = nodestate->m_wtxid_relay ? wtxid : txid;\n-        pfrom->AddKnownTx(hash);\n-        if (nodestate->m_wtxid_relay && txid != wtxid) {\n-            // Insert txid into filterInventoryKnown, even for\n-            // wtxidrelay peers. This prevents re-adding of\n-            // unconfirmed parents to the recently_announced\n-            // filter, when a child tx is requested. See\n-            // ProcessGetData().\n-            pfrom->AddKnownTx(txid);\n-        }\n-\n         TxValidationState state;\n \n-        nodestate->m_tx_download.m_tx_announced.erase(hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(hash);\n-        EraseTxRequest(hash);\n+        CNodeState* nodestate = State(pfrom->GetId());\n+        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n+        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n+        EraseTxRequest(inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n-        // We do the AlreadyHave() check using wtxid, rather than txid - in the\n-        // absence of witness malleation, this is strictly better, because the\n-        // recent rejects filter may contain the wtxid but will never contain\n-        // the txid of a segwit transaction that has been rejected.\n-        // In the presence of witness malleation, it's possible that by only\n-        // doing the check with wtxid, we could overlook a transaction which\n-        // was confirmed with a different witness, or exists in our mempool\n-        // with a different witness, but this has limited downside:\n-        // mempool validation does its own lookup of whether we have the txid\n-        // already; and an adversary can already relay us old transactions\n-        // (older than our recency filter) if trying to DoS us, without any need\n-        // for witness malleation.\n-        if (!AlreadyHave(CInv(MSG_WTX, wtxid), mempool) &&\n+        if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n-            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), *connman);\n+            RelayTransaction(tx.GetHash(), *connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(txid, i));\n+                auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n                     for (const auto& elem : it_by_prev->second) {\n                         pfrom->orphan_work_set.insert(elem->first);\n@@ -2696,17 +2582,10 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                 const auto current_time = GetTime<std::chrono::microseconds>();\n \n-                if (!State(pfrom->GetId())->m_wtxid_relay) {\n-                    for (const CTxIn& txin : tx.vin) {\n-                        // Here, we only have the txid (and not wtxid) of the\n-                        // inputs, so we only request parents from\n-                        // non-wtxid-relay peers.\n-                        // Eventually we should replace this with an improved\n-                        // protocol for getting all unconfirmed parents.\n-                        CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n-                        pfrom->AddKnownTx(txin.prevout.hash);\n-                        if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom->GetId()), _inv.hash, current_time);\n-                    }\n+                for (const CTxIn& txin : tx.vin) {\n+                    CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n+                    pfrom->AddInventoryKnown(_inv);\n+                    if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom->GetId()), _inv.hash, current_time);\n                 }\n                 AddOrphanTx(ptx, pfrom->GetId());\n \n@@ -2720,41 +2599,20 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                 LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n                 // We will continue to reject this tx since it has rejected\n                 // parents so avoid re-requesting it from other peers.\n-                // Here we add both the txid and the wtxid, as we know that\n-                // regardless of what witness is provided, we will not accept\n-                // this, so we don't need to allow for redownload of this txid\n-                // from any of our non-wtxidrelay peers.\n                 recentRejects->insert(tx.GetHash());\n-                recentRejects->insert(tx.GetWitnessHash());\n             }\n         } else {\n-            if (state.GetResult() != TxValidationResult::TX_WITNESS_STRIPPED) {\n-                // We can add the wtxid of this transaction to our reject filter.\n-                // Do not add txids of witness transactions or witness-stripped\n-                // transactions to the filter, as they can have been malleated;\n-                // adding such txids to the reject filter would potentially\n-                // interfere with relay of valid transactions from peers that\n-                // do not support wtxid-based relay. See\n-                // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                // We can remove this restriction (and always add wtxids to\n-                // the filter even for witness stripped transactions) once\n-                // wtxid-based relay is broadly deployed.\n-                // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n-                // for concerns around weakening security of unupgraded nodes\n-                // if we start doing this too early.\n-                assert(recentRejects);\n-                recentRejects->insert(tx.GetWitnessHash());\n-                // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n+            if ((!tx.HasWitness() && state.GetResult() != TxValidationResult::TX_WITNESS_MUTATED) ||\n+                    state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD) {\n+                // Do not use rejection cache for witness transactions or\n+                // witness-stripped transactions, as they can have been malleated.\n+                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+                // However, if the transaction failed for TX_INPUTS_NOT_STANDARD,\n                 // then we know that the witness was irrelevant to the policy\n                 // failure, since this check depends only on the txid\n                 // (the scriptPubKey being spent is covered by the txid).\n-                // Add the txid to the reject filter to prevent repeated\n-                // processing of this transaction in the event that child\n-                // transactions are later received (resulting in\n-                // parent-fetching by txid via the orphan-handling logic).\n-                if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && tx.GetWitnessHash() != tx.GetHash()) {\n-                    recentRejects->insert(tx.GetHash());\n-                }\n+                assert(recentRejects);\n+                recentRejects->insert(tx.GetHash());\n                 if (RecursiveDynamicUsage(*ptx) < 100000) {\n                     AddToCompactExtraTransactions(ptx);\n                 }\n@@ -2771,7 +2629,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n                     LogPrintf(\"Not relaying non-mempool transaction %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n-                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), *connman);\n+                    RelayTransaction(tx.GetHash(), *connman);\n                 }\n             }\n         }\n@@ -3387,7 +3245,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         vRecv >> vInv;\n         if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {\n-                if (inv.type == MSG_TX || inv.type == MSG_WITNESS_TX || inv.type == MSG_WTX) {\n+                if (inv.type == MSG_TX || inv.type == MSG_WITNESS_TX) {\n                     // If we receive a NOTFOUND message for a txid we requested, erase\n                     // it from our data structures for this peer.\n                     auto in_flight_it = state->m_tx_download.m_tx_in_flight.find(inv.hash);\n@@ -3679,19 +3537,17 @@ namespace {\n class CompareInvMempoolOrder\n {\n     CTxMemPool *mp;\n-    bool m_wtxid_relay;\n public:\n-    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool)\n     {\n         mp = _mempool;\n-        m_wtxid_relay = use_wtxid;\n     }\n \n     bool operator()(std::set<uint256>::iterator a, std::set<uint256>::iterator b)\n     {\n         /* As std::make_heap produces a max-heap, we want the entries with the\n          * fewest ancestors/highest fee to sort later. */\n-        return mp->CompareDepthAndScore(*b, *a, m_wtxid_relay);\n+        return mp->CompareDepthAndScore(*b, *a);\n     }\n };\n }\n@@ -3998,8 +3854,8 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     LOCK(pto->m_tx_relay->cs_filter);\n \n                     for (const auto& txinfo : vtxinfo) {\n-                        const uint256& hash = state.m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n-                        CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n+                        const uint256& hash = txinfo.tx->GetHash();\n+                        CInv inv(MSG_TX, hash);\n                         pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n@@ -4033,7 +3889,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     }\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n-                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, state.m_wtxid_relay);\n+                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n@@ -4052,19 +3908,17 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n-                        auto txinfo = m_mempool.info(hash, state.m_wtxid_relay);\n+                        auto txinfo = m_mempool.info(hash);\n                         if (!txinfo.tx) {\n                             continue;\n                         }\n-                        auto txid = txinfo.tx->GetHash();\n-                        auto wtxid = txinfo.tx->GetWitnessHash();\n                         // Peer told you to not send transactions at that feerate? Don't bother sending it.\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        vInv.push_back(CInv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash));\n+                        vInv.push_back(CInv(MSG_TX, hash));\n                         nRelayedTransactions++;\n                         {\n                             // Expire old relay messages\n@@ -4074,29 +3928,16 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                                 vRelayExpiration.pop_front();\n                             }\n \n-                            auto ret = mapRelay.emplace(txid, std::move(txinfo.tx));\n+                            auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n                             if (ret.second) {\n-                                vRelayExpiration.emplace_back(nNow + std::chrono::microseconds{RELAY_TX_CACHE_TIME}.count(), ret.first);\n-                            }\n-                            // Add wtxid-based lookup into mapRelay as well, so that peers can request by wtxid\n-                            auto ret2 = mapRelay.emplace(wtxid, ret.first->second);\n-                            if (ret2.second) {\n-                                vRelayExpiration.emplace_back(nNow + std::chrono::microseconds{RELAY_TX_CACHE_TIME}.count(), ret2.first);\n+                                vRelayExpiration.push_back(std::make_pair(nNow + std::chrono::microseconds{RELAY_TX_CACHE_TIME}.count(), ret.first));\n                             }\n                         }\n                         if (vInv.size() == MAX_INV_SZ) {\n                             connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n                         pto->m_tx_relay->filterInventoryKnown.insert(hash);\n-                        if (hash != txid) {\n-                            // Insert txid into filterInventoryKnown, even for\n-                            // wtxidrelay peers. This prevents re-adding of\n-                            // unconfirmed parents to the recently_announced\n-                            // filter, when a child tx is requested. See\n-                            // ProcessGetData().\n-                            pto->m_tx_relay->filterInventoryKnown.insert(txid);\n-                        }\n                     }\n                 }\n             }\n@@ -4221,7 +4062,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             // Erase this entry from tx_process_time (it may be added back for\n             // processing at a later time, see below)\n             tx_process_time.erase(tx_process_time.begin());\n-            CInv inv(state.m_wtxid_relay ? MSG_WTX : (MSG_TX | GetFetchFlags(pto)), txid);\n+            CInv inv(MSG_TX | GetFetchFlags(pto), txid);\n             if (!AlreadyHave(inv, m_mempool)) {\n                 // If this transaction was last requested more than 1 minute ago,\n                 // then request.\n@@ -4240,15 +4081,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     // up processing to happen after the download times out\n                     // (with a slight delay for inbound peers, to prefer\n                     // requests to outbound peers).\n-                    // Don't apply the txid-delay to re-requests of a\n-                    // transaction; the heuristic of delaying requests to\n-                    // txid-relay peers is to save bandwidth on initial\n-                    // announcement of a transaction, and doesn't make sense\n-                    // for a followup request if our first peer times out (and\n-                    // would open us up to an attacker using inbound\n-                    // wtxid-relay to prevent us from requesting transactions\n-                    // from outbound txid-relay peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload, false);\n+                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload);\n                     tx_process_time.emplace(next_process_time, txid);\n                 }\n             } else {\n@@ -4301,7 +4134,6 @@ class CNetProcessingCleanup\n         // orphan transactions\n         mapOrphanTransactions.clear();\n         mapOrphanTransactionsByPrev.clear();\n-        g_orphans_by_wtxid.clear();\n     }\n };\n static CNetProcessingCleanup instance_of_cnetprocessingcleanup;"
      },
      {
        "sha": "ddb178014801cfbc3b56963578f3d74389ebb7c3",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -92,6 +92,6 @@ struct CNodeStateStats {\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n \n /** Relay transaction to every node */\n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+void RelayTransaction(const uint256&, const CConnman& connman);\n \n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "201406ce3b69dfe574abfaf9c2c0725a657b0017",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -78,8 +78,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     }\n \n     if (relay) {\n-        LOCK(cs_main);\n-        RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman);\n+        RelayTransaction(hashTx, *node.connman);\n     }\n \n     return TransactionError::OK;"
      },
      {
        "sha": "bd3ed25a8af7cc7428a6a1e66ee03dbe6c8d805d",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -40,7 +40,6 @@ const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n-const char *WTXIDRELAY=\"wtxidrelay\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -72,7 +71,6 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::CMPCTBLOCK,\n     NetMsgType::GETBLOCKTXN,\n     NetMsgType::BLOCKTXN,\n-    NetMsgType::WTXIDRELAY,\n };\n const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n \n@@ -185,8 +183,6 @@ std::string CInv::GetCommand() const\n     switch (masked)\n     {\n     case MSG_TX:             return cmd.append(NetMsgType::TX);\n-    // WTX is not a message type, just an inv type\n-    case MSG_WTX:            return cmd.append(\"wtx\");\n     case MSG_BLOCK:          return cmd.append(NetMsgType::BLOCK);\n     case MSG_FILTERED_BLOCK: return cmd.append(NetMsgType::MERKLEBLOCK);\n     case MSG_CMPCT_BLOCK:    return cmd.append(NetMsgType::CMPCTBLOCK);"
      },
      {
        "sha": "6639ae2aacf386550d8387f75c8d27ee66eb22f0",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -234,12 +234,6 @@ extern const char *GETBLOCKTXN;\n  * @since protocol version 70014 as described by BIP 152\n  */\n extern const char *BLOCKTXN;\n-/**\n- * Indicates that a node prefers to relay transactions via wtxid, rather than\n- * txid.\n- * @since protocol version 70016 as described by BIP 339.\n- */\n-extern const char *WTXIDRELAY;\n };\n \n /* Get a vector of all valid message types (see above) */\n@@ -368,12 +362,12 @@ const uint32_t MSG_TYPE_MASK    = 0xffffffff >> 2;\n  * These numbers are defined by the protocol. When adding a new value, be sure\n  * to mention it in the respective BIP.\n  */\n-enum GetDataMsg : uint32_t {\n+enum GetDataMsg\n+{\n     UNDEFINED = 0,\n     MSG_TX = 1,\n     MSG_BLOCK = 2,\n-    MSG_WTX = 5,                                      //!< Defined in BIP 339\n-    // The following can only occur in getdata. Invs always use TX/WTX or BLOCK.\n+    // The following can only occur in getdata. Invs always use TX or BLOCK.\n     MSG_FILTERED_BLOCK = 3,  //!< Defined in BIP37\n     MSG_CMPCT_BLOCK = 4,     //!< Defined in BIP152\n     MSG_WITNESS_BLOCK = MSG_BLOCK | MSG_WITNESS_FLAG, //!< Defined in BIP144"
      },
      {
        "sha": "c14417a84736b24c77aead5220e018fda8df21fb",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -724,12 +724,12 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     assert(innerUsage == cachedInnerUsage);\n }\n \n-bool CTxMemPool::CompareDepthAndScore(const uint256& hasha, const uint256& hashb, bool wtxid)\n+bool CTxMemPool::CompareDepthAndScore(const uint256& hasha, const uint256& hashb)\n {\n     LOCK(cs);\n-    indexed_transaction_set::const_iterator i = wtxid ? get_iter_from_wtxid(hasha) : mapTx.find(hasha);\n+    indexed_transaction_set::const_iterator i = mapTx.find(hasha);\n     if (i == mapTx.end()) return false;\n-    indexed_transaction_set::const_iterator j = wtxid ? get_iter_from_wtxid(hashb) : mapTx.find(hashb);\n+    indexed_transaction_set::const_iterator j = mapTx.find(hashb);\n     if (j == mapTx.end()) return true;\n     uint64_t counta = i->GetCountWithAncestors();\n     uint64_t countb = j->GetCountWithAncestors();\n@@ -809,10 +809,10 @@ CTransactionRef CTxMemPool::get(const uint256& hash) const\n     return i->GetSharedTx();\n }\n \n-TxMempoolInfo CTxMemPool::info(const uint256& hash, bool wtxid) const\n+TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n {\n     LOCK(cs);\n-    indexed_transaction_set::const_iterator i = (wtxid ? get_iter_from_wtxid(hash) : mapTx.find(hash));\n+    indexed_transaction_set::const_iterator i = mapTx.find(hash);\n     if (i == mapTx.end())\n         return TxMempoolInfo();\n     return GetInfo(i);\n@@ -915,8 +915,8 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    // Estimate the overhead of mapTx to be 15 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 12 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 12 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n }\n \n void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {"
      },
      {
        "sha": "3dae0a04c7fcc304c95d16a86ce1c8f94302a3e0",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 37,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -198,22 +198,6 @@ struct mempoolentry_txid\n     }\n };\n \n-// extracts a transaction witness-hash from CTxMemPoolEntry or CTransactionRef\n-struct mempoolentry_wtxid\n-{\n-    typedef uint256 result_type;\n-    result_type operator() (const CTxMemPoolEntry &entry) const\n-    {\n-        return entry.GetTx().GetWitnessHash();\n-    }\n-\n-    result_type operator() (const CTransactionRef& tx) const\n-    {\n-        return tx->GetWitnessHash();\n-    }\n-};\n-\n-\n /** \\class CompareTxMemPoolEntryByDescendantScore\n  *\n  *  Sort an entry by max(score/size of entry's tx, score/size with all descendants).\n@@ -334,7 +318,6 @@ class CompareTxMemPoolEntryByAncestorFee\n struct descendant_score {};\n struct entry_time {};\n struct ancestor_score {};\n-struct index_by_wtxid {};\n \n class CBlockPolicyEstimator;\n \n@@ -400,9 +383,8 @@ class SaltedTxidHasher\n  *\n  * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:\n  *\n- * mapTx is a boost::multi_index that sorts the mempool on 5 criteria:\n- * - transaction hash (txid)\n- * - witness-transaction hash (wtxid)\n+ * mapTx is a boost::multi_index that sorts the mempool on 4 criteria:\n+ * - transaction hash\n  * - descendant feerate [we use max(feerate of tx, feerate of tx with all descendants)]\n  * - time in mempool\n  * - ancestor feerate [we use min(feerate of tx, feerate of tx with all unconfirmed ancestors)]\n@@ -487,12 +469,6 @@ class CTxMemPool\n         boost::multi_index::indexed_by<\n             // sorted by txid\n             boost::multi_index::hashed_unique<mempoolentry_txid, SaltedTxidHasher>,\n-            // sorted by wtxid\n-            boost::multi_index::hashed_unique<\n-                boost::multi_index::tag<index_by_wtxid>,\n-                mempoolentry_wtxid,\n-                SaltedTxidHasher\n-            >,\n             // sorted by fee rate\n             boost::multi_index::ordered_non_unique<\n                 boost::multi_index::tag<descendant_score>,\n@@ -607,7 +583,7 @@ class CTxMemPool\n \n     void clear();\n     void _clear() EXCLUSIVE_LOCKS_REQUIRED(cs); //lock free\n-    bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb, bool wtxid=false);\n+    bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n     void queryHashes(std::vector<uint256>& vtxid) const;\n     bool isSpent(const COutPoint& outpoint) const;\n     unsigned int GetTransactionsUpdated() const;\n@@ -710,22 +686,14 @@ class CTxMemPool\n         return totalTxSize;\n     }\n \n-    bool exists(const uint256& hash, bool wtxid=false) const\n+    bool exists(const uint256& hash) const\n     {\n         LOCK(cs);\n-        if (wtxid) {\n-            return (mapTx.get<index_by_wtxid>().count(hash) != 0);\n-        }\n         return (mapTx.count(hash) != 0);\n     }\n \n     CTransactionRef get(const uint256& hash) const;\n-    txiter get_iter_from_wtxid(const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(cs)\n-    {\n-        AssertLockHeld(cs);\n-        return mapTx.project<0>(mapTx.get<index_by_wtxid>().find(wtxid));\n-    }\n-    TxMempoolInfo info(const uint256& hash, bool wtxid=false) const;\n+    TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n \n     size_t DynamicMemoryUsage() const;"
      },
      {
        "sha": "5a98b2cb9277be7aeacf28666bf8309d401288d4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -916,7 +916,7 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n         if (!tx.HasWitness() && CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n                 !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n             // Only the witness is missing, so the transaction itself may be fine.\n-            state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED,\n+            state.Invalid(TxValidationResult::TX_WITNESS_MUTATED,\n                     state.GetRejectReason(), state.GetDebugMessage());\n         }\n         return false; // state filled in by CheckInputScripts"
      },
      {
        "sha": "d932b512d4bb70ae13aba687f6a0d64e0e52634d",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -9,7 +9,7 @@\n  * network protocol versioning\n  */\n \n-static const int PROTOCOL_VERSION = 70016;\n+static const int PROTOCOL_VERSION = 70015;\n \n //! initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;\n@@ -42,7 +42,4 @@ static const int SHORT_IDS_BLOCKS_VERSION = 70014;\n //! not banning for invalid compact blocks starts with this version\n static const int INVALID_CB_NO_BAN_VERSION = 70015;\n \n-//! \"wtxidrelay\" command for wtxid-based relay starts with this version\n-static const int WTXID_RELAY_VERSION = 70016;\n-\n #endif // BITCOIN_VERSION_H"
      },
      {
        "sha": "a07dad18d61eef32697cf43dc22bdf35f758f62a",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -67,15 +67,10 @@ def run_test(self):\n         fee = Decimal(\"0.0001\")\n         # MAX_ANCESTORS transactions off a confirmed tx should be fine\n         chain = []\n-        witness_chain = []\n         for i in range(MAX_ANCESTORS):\n             (txid, sent_value) = self.chain_transaction(self.nodes[0], txid, 0, value, fee, 1)\n             value = sent_value\n             chain.append(txid)\n-            # We need the wtxids to check P2P announcements\n-            fulltx = self.nodes[0].getrawtransaction(txid)\n-            witnesstx = self.nodes[0].decoderawtransaction(fulltx, True)\n-            witness_chain.append(witnesstx['hash'])\n \n         # Check mempool has MAX_ANCESTORS transactions in it, and descendant and ancestor\n         # count and fees should look correct"
      },
      {
        "sha": "3258a38e3cba70cf6831320f7e5a21246d1fa927",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -52,7 +52,7 @@ def run_test(self):\n         self.log.info('Check that txs from rpc are not rejected and relayed to other peers')\n         assert_equal(self.nodes[0].getpeerinfo()[0]['relaytxes'], True)\n         txid = self.nodes[0].testmempoolaccept([sigtx])[0]['txid']\n-        with self.nodes[0].assert_debug_log(['received getdata for: wtx {} peer=1'.format(txid)]):\n+        with self.nodes[0].assert_debug_log(['received getdata for: tx {} peer=1'.format(txid)]):\n             self.nodes[0].sendrawtransaction(sigtx)\n             self.nodes[0].p2p.wait_for_tx(txid)\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 1)"
      },
      {
        "sha": "4f242bd94a639bed05ab1d144e818225a28e034e",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -7,7 +7,7 @@\n from decimal import Decimal\n import time\n \n-from test_framework.messages import MSG_TX, MSG_WTX, msg_feefilter\n+from test_framework.messages import msg_feefilter\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n \n@@ -31,7 +31,7 @@ def __init__(self):\n \n     def on_inv(self, message):\n         for i in message.inv:\n-            if (i.type == MSG_TX) or (i.type == MSG_WTX):\n+            if (i.type == 1):\n                 self.txinvs.append(hashToHex(i.hash))\n \n     def clear_invs(self):"
      },
      {
        "sha": "a7cfefc4857e6747c765a5eac0e66f0ddae6e1b0",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 6,
        "deletions": 93,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -22,9 +22,7 @@\n     CTxOut,\n     CTxWitness,\n     MAX_BLOCK_BASE_SIZE,\n-    MSG_TX,\n     MSG_WITNESS_FLAG,\n-    MSG_WTX,\n     NODE_NETWORK,\n     NODE_WITNESS,\n     msg_no_witness_block,\n@@ -34,7 +32,6 @@\n     msg_tx,\n     msg_block,\n     msg_no_witness_tx,\n-    msg_verack,\n     ser_uint256,\n     ser_vector,\n     sha256,\n@@ -82,7 +79,6 @@\n     softfork_active,\n     hex_str_to_bytes,\n     assert_raises_rpc_error,\n-    wait_until,\n )\n \n # The versionbit bit used to signal activation of SegWit\n@@ -145,42 +141,23 @@ def test_witness_block(node, p2p, block, accepted, with_witness=True, reason=Non\n \n \n class TestP2PConn(P2PInterface):\n-    def __init__(self, wtxidrelay=False):\n+    def __init__(self):\n         super().__init__()\n         self.getdataset = set()\n-        self.last_wtxidrelay = []\n-        self.lastgetdata = []\n-        self.wtxidrelay = wtxidrelay\n \n     # Avoid sending out msg_getdata in the mininode thread as a reply to invs.\n     # They are not needed and would only lead to races because we send msg_getdata out in the test thread\n     def on_inv(self, message):\n         pass\n \n-    def on_version(self, message):\n-        if self.wtxidrelay:\n-            super().on_version(message)\n-        else:\n-            self.send_message(msg_verack())\n-            self.nServices = message.nServices\n-\n     def on_getdata(self, message):\n-        self.lastgetdata = message.inv\n         for inv in message.inv:\n             self.getdataset.add(inv.hash)\n \n-    def on_wtxidrelay(self, message):\n-        self.last_wtxidrelay.append(message)\n-\n-    def announce_tx_and_wait_for_getdata(self, tx, timeout=60, success=True, use_wtxid=False):\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60, success=True):\n         with mininode_lock:\n             self.last_message.pop(\"getdata\", None)\n-        if use_wtxid:\n-            wtxid = tx.calc_sha256(True)\n-            self.send_message(msg_inv(inv=[CInv(MSG_WTX, wtxid)]))\n-        else:\n-            self.send_message(msg_inv(inv=[CInv(MSG_TX, tx.sha256)]))\n-\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n         if success:\n             self.wait_for_getdata(timeout)\n         else:\n@@ -298,7 +275,6 @@ def run_test(self):\n         self.test_upgrade_after_activation()\n         self.test_witness_sigops()\n         self.test_superfluous_witness()\n-        self.test_wtxid_relay()\n \n     # Individual tests\n \n@@ -1292,6 +1268,7 @@ def test_tx_relay_after_segwit_activation(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=True, accepted=False)\n \n         # Verify that removing the witness succeeds.\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Now try to add extra witness data to a valid witness tx.\n@@ -1318,6 +1295,8 @@ def test_tx_relay_after_segwit_activation(self):\n         # Node will not be blinded to the transaction\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n         test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, 'tx-size')\n+        self.std_node.announce_tx_and_wait_for_getdata(tx3)\n+        test_transaction_acceptance(self.nodes[1], self.std_node, tx3, True, False, 'tx-size')\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue - 1000, CScript([OP_TRUE, OP_DROP] * 15 + [OP_TRUE]))\n@@ -2044,11 +2023,6 @@ def test_witness_sigops(self):\n \n         # TODO: test p2sh sigop counting\n \n-        # Cleanup and prep for next test\n-        self.utxo.pop(0)\n-        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n-\n-    @subtest  # type: ignore\n     def test_superfluous_witness(self):\n         # Serialization of tx that puts witness flag to 3 always\n         def serialize_with_bogus_witness(tx):\n@@ -2092,67 +2066,6 @@ def serialize(self):\n         with self.nodes[0].assert_debug_log(['Unknown transaction optional data']):\n             self.nodes[0].p2p.send_and_ping(msg_bogus_tx(tx))\n \n-    @subtest  # type: ignore\n-    def test_wtxid_relay(self):\n-        # Use brand new nodes to avoid contamination from earlier tests\n-        self.wtx_node = self.nodes[0].add_p2p_connection(TestP2PConn(wtxidrelay=True), services=NODE_NETWORK | NODE_WITNESS)\n-        self.tx_node = self.nodes[0].add_p2p_connection(TestP2PConn(wtxidrelay=False), services=NODE_NETWORK | NODE_WITNESS)\n-\n-        # Check wtxidrelay feature negotiation message through connecting a new peer\n-        def received_wtxidrelay():\n-            return (len(self.wtx_node.last_wtxidrelay) > 0)\n-        wait_until(received_wtxidrelay, timeout=60, lock=mininode_lock)\n-\n-        # Create a Segwit output from the latest UTXO\n-        # and announce it to the network\n-        witness_program = CScript([OP_TRUE])\n-        witness_hash = sha256(witness_program)\n-        script_pubkey = CScript([OP_0, witness_hash])\n-\n-        tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-        tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n-        tx.rehash()\n-\n-        # Create a Segwit transaction\n-        tx2 = CTransaction()\n-        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n-        tx2.vout.append(CTxOut(tx.vout[0].nValue - 1000, script_pubkey))\n-        tx2.wit.vtxinwit.append(CTxInWitness())\n-        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n-        tx2.rehash()\n-\n-        # Announce Segwit transaction with wtxid\n-        # and wait for getdata\n-        self.wtx_node.announce_tx_and_wait_for_getdata(tx2, use_wtxid=True)\n-        with mininode_lock:\n-            lgd = self.wtx_node.lastgetdata[:]\n-        assert_equal(lgd, [CInv(MSG_WTX, tx2.calc_sha256(True))])\n-\n-        # Announce Segwit transaction from non wtxidrelay peer\n-        # and wait for getdata\n-        self.tx_node.announce_tx_and_wait_for_getdata(tx2, use_wtxid=False)\n-        with mininode_lock:\n-            lgd = self.tx_node.lastgetdata[:]\n-        assert_equal(lgd, [CInv(MSG_TX | MSG_WITNESS_FLAG, tx2.sha256)])\n-\n-        # Send tx2 through; it's an orphan so won't be accepted\n-        with mininode_lock:\n-            self.tx_node.last_message.pop(\"getdata\", None)\n-        test_transaction_acceptance(self.nodes[0], self.tx_node, tx2, with_witness=True, accepted=False)\n-\n-        # Expect a request for parent (tx) due to use of non-WTX peer\n-        self.tx_node.wait_for_getdata(60)\n-        with mininode_lock:\n-            lgd = self.tx_node.lastgetdata[:]\n-        assert_equal(lgd, [CInv(MSG_TX | MSG_WITNESS_FLAG, tx.sha256)])\n-\n-        # Send tx through\n-        test_transaction_acceptance(self.nodes[0], self.tx_node, tx, with_witness=False, accepted=True)\n-\n-        # Check tx2 is there now\n-        assert_equal(tx2.hash in self.nodes[0].getrawmempool(), True)\n-\n \n if __name__ == '__main__':\n     SegWitTest().main()"
      },
      {
        "sha": "b56dc994e7842c31ae20ffe29e853c86d60b70c1",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -12,7 +12,6 @@\n     FromHex,\n     MSG_TX,\n     MSG_TYPE_MASK,\n-    MSG_WTX,\n     msg_inv,\n     msg_notfound,\n )\n@@ -37,21 +36,20 @@ def __init__(self):\n \n     def on_getdata(self, message):\n         for i in message.inv:\n-            if i.type & MSG_TYPE_MASK == MSG_TX or i.type & MSG_TYPE_MASK == MSG_WTX:\n+            if i.type & MSG_TYPE_MASK == MSG_TX:\n                 self.tx_getdata_count += 1\n \n \n # Constants from net_processing\n GETDATA_TX_INTERVAL = 60  # seconds\n MAX_GETDATA_RANDOM_DELAY = 2  # seconds\n INBOUND_PEER_TX_DELAY = 2  # seconds\n-TXID_RELAY_DELAY = 2 # seconds\n MAX_GETDATA_IN_FLIGHT = 100\n TX_EXPIRY_INTERVAL = GETDATA_TX_INTERVAL * 10\n \n # Python test constants\n NUM_INBOUND = 10\n-MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY + TXID_RELAY_DELAY\n+MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY\n \n \n class TxDownloadTest(BitcoinTestFramework):\n@@ -65,7 +63,7 @@ def test_tx_requests(self):\n         txid = 0xdeadbeef\n \n         self.log.info(\"Announce the txid from each incoming peer to node 0\")\n-        msg = msg_inv([CInv(t=MSG_WTX, h=txid)])\n+        msg = msg_inv([CInv(t=1, h=txid)])\n         for p in self.nodes[0].p2ps:\n             p.send_and_ping(msg)\n \n@@ -137,13 +135,13 @@ def test_in_flight_max(self):\n         with mininode_lock:\n             p.tx_getdata_count = 0\n \n-        p.send_message(msg_inv([CInv(t=MSG_WTX, h=i) for i in txids]))\n+        p.send_message(msg_inv([CInv(t=1, h=i) for i in txids]))\n         wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT, lock=mininode_lock)\n         with mininode_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)\n \n         self.log.info(\"Now check that if we send a NOTFOUND for a transaction, we'll get one more request\")\n-        p.send_message(msg_notfound(vec=[CInv(t=MSG_WTX, h=txids[0])]))\n+        p.send_message(msg_notfound(vec=[CInv(t=1, h=txids[0])]))\n         wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10, lock=mininode_lock)\n         with mininode_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT + 1)"
      },
      {
        "sha": "5f8fcc6fd867595248b18d85e71af66db4e9066c",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 23,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -31,7 +31,7 @@\n from test_framework.util import hex_str_to_bytes, assert_equal\n \n MIN_VERSION_SUPPORTED = 60001\n-MY_VERSION = 70016  # past wtxid relay\n+MY_VERSION = 70014  # past bip-31 for ping/pong\n MY_SUBVERSION = b\"/python-mininode-tester:0.0.3/\"\n MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)\n \n@@ -52,7 +52,6 @@\n MSG_TX = 1\n MSG_BLOCK = 2\n MSG_FILTERED_BLOCK = 3\n-MSG_WTX = 5\n MSG_WITNESS_FLAG = 1 << 30\n MSG_TYPE_MASK = 0xffffffff >> 2\n \n@@ -232,8 +231,7 @@ class CInv:\n         MSG_TX | MSG_WITNESS_FLAG: \"WitnessTx\",\n         MSG_BLOCK | MSG_WITNESS_FLAG: \"WitnessBlock\",\n         MSG_FILTERED_BLOCK: \"filtered Block\",\n-        4: \"CompactBlock\",\n-        5: \"WTX\",\n+        4: \"CompactBlock\"\n     }\n \n     def __init__(self, t=0, h=0):\n@@ -254,9 +252,6 @@ def __repr__(self):\n         return \"CInv(type=%s hash=%064x)\" \\\n             % (self.typemap[self.type], self.hash)\n \n-    def __eq__(self, other):\n-        return isinstance(other, CInv) and self.hash == other.hash and self.type == other.type\n-\n \n class CBlockLocator:\n     __slots__ = (\"nVersion\", \"vHave\")\n@@ -1118,22 +1113,6 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_tx(tx=%s)\" % (repr(self.tx))\n \n-class msg_wtxidrelay:\n-    __slots__ = ()\n-    command = b\"wtxidrelay\"\n-\n-    def __init__(self):\n-        pass\n-\n-    def deserialize(self, f):\n-        pass\n-\n-    def serialize(self):\n-        return b\"\"\n-\n-    def __repr__(self):\n-        return \"msg_wtxidrelay()\"\n-\n \n class msg_no_witness_tx(msg_tx):\n     __slots__ = ()"
      },
      {
        "sha": "ad330f2a936f36abae783b1a780931f69d51a0b1",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -52,7 +52,6 @@\n     MSG_TYPE_MASK,\n     msg_verack,\n     msg_version,\n-    msg_wtxidrelay,\n     NODE_NETWORK,\n     NODE_WITNESS,\n     sha256,\n@@ -87,7 +86,6 @@\n     b\"tx\": msg_tx,\n     b\"verack\": msg_verack,\n     b\"version\": msg_version,\n-    b\"wtxidrelay\": msg_wtxidrelay,\n }\n \n MAGIC_BYTES = {\n@@ -345,7 +343,6 @@ def on_reject(self, message): pass\n     def on_sendcmpct(self, message): pass\n     def on_sendheaders(self, message): pass\n     def on_tx(self, message): pass\n-    def on_wtxidrelay(self, message): pass\n \n     def on_inv(self, message):\n         want = msg_getdata()\n@@ -363,8 +360,6 @@ def on_verack(self, message):\n \n     def on_version(self, message):\n         assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n-        if message.nVersion >= 70016:\n-            self.send_message(msg_wtxidrelay())\n         self.send_message(msg_verack())\n         self.nServices = message.nServices\n "
      },
      {
        "sha": "d122e3db523fa06727ba76fc44e2912dea924c3b",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "modified",
        "additions": 6,
        "deletions": 11,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa074d2c7b9c3d34876c428d12672a505d4ce4eb/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=fa074d2c7b9c3d34876c428d12672a505d4ce4eb",
        "patch": "@@ -7,11 +7,7 @@\n import time\n \n from test_framework.blocktools import create_block, create_coinbase\n-from test_framework.messages import (\n-    MSG_TX,\n-    MSG_WTX,\n-    ToHex,\n-)\n+from test_framework.messages import ToHex\n from test_framework.mininode import P2PInterface, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, wait_until\n@@ -25,7 +21,7 @@ def __init__(self):\n     def on_inv(self, message):\n         # Store how many times invs have been received for each tx.\n         for i in message.inv:\n-            if i.type == MSG_TX or i.type == MSG_WTX:\n+            if i.type == 1:\n                 # save txid\n                 self.tx_invs_received[i.hash] += 1\n \n@@ -43,8 +39,7 @@ def run_test(self):\n         node.add_p2p_connection(P2PStoreTxInvs())\n \n         self.log.info(\"Create a new transaction and wait until it's broadcast\")\n-        txid = node.sendtoaddress(node.getnewaddress(), 1)\n-        wtxid = int(node.getrawtransaction(txid, 1)['hash'], 16)\n+        txid = int(node.sendtoaddress(node.getnewaddress(), 1), 16)\n \n         # Wallet rebroadcast is first scheduled 1 sec after startup (see\n         # nNextResend in ResendWalletTransactions()). Sleep for just over a\n@@ -53,7 +48,7 @@ def run_test(self):\n         time.sleep(1.1)\n \n         # Can take a few seconds due to transaction trickling\n-        wait_until(lambda: node.p2p.tx_invs_received[wtxid] >= 1, lock=mininode_lock)\n+        wait_until(lambda: node.p2p.tx_invs_received[txid] >= 1, lock=mininode_lock)\n \n         # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)\n         node.add_p2p_connection(P2PStoreTxInvs())\n@@ -72,13 +67,13 @@ def run_test(self):\n         # Transaction should not be rebroadcast\n         node.syncwithvalidationinterfacequeue()\n         node.p2ps[1].sync_with_ping()\n-        assert_equal(node.p2ps[1].tx_invs_received[wtxid], 0)\n+        assert_equal(node.p2ps[1].tx_invs_received[txid], 0)\n \n         self.log.info(\"Transaction should be rebroadcast after 30 minutes\")\n         # Use mocktime and give an extra 5 minutes to be sure.\n         rebroadcast_time = int(time.time()) + 41 * 60\n         node.setmocktime(rebroadcast_time)\n-        wait_until(lambda: node.p2ps[1].tx_invs_received[wtxid] >= 1, lock=mininode_lock)\n+        wait_until(lambda: node.p2ps[1].tx_invs_received[txid] >= 1, lock=mininode_lock)\n \n \n if __name__ == '__main__':"
      }
    ]
  }
]