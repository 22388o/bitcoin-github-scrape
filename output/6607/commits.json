[
  {
    "sha": "423f91f73ce65daace5f612aa6d7b4ba6c18f667",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MjNmOTFmNzNjZTY1ZGFhY2U1ZjYxMmFhNmQ3YjRiYTZjMThmNjY3",
    "commit": {
      "author": {
        "name": "Gazbert",
        "email": "gazbert@users.noreply.github.com",
        "date": "2015-05-29T20:42:59Z"
      },
      "committer": {
        "name": "Gazbert",
        "email": "gazbert@users.noreply.github.com",
        "date": "2015-05-29T20:42:59Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nPull latest changes down and actually do some coding... ;-)",
      "tree": {
        "sha": "7aba5961a7254a73e5e5eb9810c828199cb27e00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7aba5961a7254a73e5e5eb9810c828199cb27e00"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/423f91f73ce65daace5f612aa6d7b4ba6c18f667",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/423f91f73ce65daace5f612aa6d7b4ba6c18f667",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/423f91f73ce65daace5f612aa6d7b4ba6c18f667",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/423f91f73ce65daace5f612aa6d7b4ba6c18f667/comments",
    "author": {
      "login": "gazbert",
      "id": 6501814,
      "node_id": "MDQ6VXNlcjY1MDE4MTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6501814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gazbert",
      "html_url": "https://github.com/gazbert",
      "followers_url": "https://api.github.com/users/gazbert/followers",
      "following_url": "https://api.github.com/users/gazbert/following{/other_user}",
      "gists_url": "https://api.github.com/users/gazbert/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gazbert/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gazbert/subscriptions",
      "organizations_url": "https://api.github.com/users/gazbert/orgs",
      "repos_url": "https://api.github.com/users/gazbert/repos",
      "events_url": "https://api.github.com/users/gazbert/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gazbert/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gazbert",
      "id": 6501814,
      "node_id": "MDQ6VXNlcjY1MDE4MTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6501814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gazbert",
      "html_url": "https://github.com/gazbert",
      "followers_url": "https://api.github.com/users/gazbert/followers",
      "following_url": "https://api.github.com/users/gazbert/following{/other_user}",
      "gists_url": "https://api.github.com/users/gazbert/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gazbert/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gazbert/subscriptions",
      "organizations_url": "https://api.github.com/users/gazbert/orgs",
      "repos_url": "https://api.github.com/users/gazbert/repos",
      "events_url": "https://api.github.com/users/gazbert/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gazbert/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6"
      },
      {
        "sha": "b679a6b4038d12aa9c194c777b1f91d71cb076a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b679a6b4038d12aa9c194c777b1f91d71cb076a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b679a6b4038d12aa9c194c777b1f91d71cb076a4"
      }
    ],
    "stats": {
      "total": 53991,
      "additions": 36419,
      "deletions": 17572
    },
    "files": [
      {
        "sha": "1f6eb15c272d931eade7cb4674ca10423dcf5555",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -10,11 +10,14 @@ env:\n   global:\n     - MAKEJOBS=-j3\n     - RUN_TESTS=false\n+    - BOOST_TEST_RANDOM=1$TRAVIS_BUILD_ID\n     - CCACHE_SIZE=100M\n     - CCACHE_TEMPDIR=/tmp/.ccache-temp\n     - CCACHE_COMPRESS=1\n     - BASE_OUTDIR=$TRAVIS_BUILD_DIR/out\n     - SDK_URL=https://bitcoincore.org/depends-sources/sdks\n+    - PYTHON_DEBUG=1\n+    - WINEDEBUG=fixme-all\n cache:\n   apt: true\n   directories:\n@@ -25,19 +28,19 @@ matrix:\n   fast_finish: true\n   include:\n     - compiler: \": ARM\"\n-      env: HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat\"\n+      env: HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - compiler: \": Win32\"\n+      env: HOST=i686-w64-mingw32 PACKAGES=\"nsis gcc-mingw-w64-i686 g++-mingw-w64-i686 binutils-mingw-w64-i686 mingw-w64-dev wine bc\" RUN_TESTS=true GOAL=\"deploy\" BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports\" MAKEJOBS=\"-j2\"\n+    - compiler: \": 32-bit + dash\"\n+      env: HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n+    - compiler: \": Win64\"\n+      env: HOST=x86_64-w64-mingw32 PACKAGES=\"nsis gcc-mingw-w64-x86-64 g++-mingw-w64-x86-64 binutils-mingw-w64-x86-64 mingw-w64-dev wine bc\" RUN_TESTS=true GOAL=\"deploy\" BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports\" MAKEJOBS=\"-j2\"\n     - compiler: \": bitcoind\"\n-      env: HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat CPPFLAGS=-DDEBUG_LOCKORDER\"\n+      env: HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n     - compiler: \": No wallet\"\n-      env: HOST=x86_64-unknown-linux-gnu DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat\"\n-    - compiler: \": 32-bit + dash\"\n-      env: HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat\" USE_SHELL=\"/bin/dash\"\n+      env: HOST=x86_64-unknown-linux-gnu DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n     - compiler: \": Cross-Mac\"\n-      env: HOST=x86_64-apple-darwin11 PACKAGES=\"cmake libcap-dev libz-dev libbz2-dev\" OSX_SDK=10.9 GOAL=\"deploy\"\n-    - compiler: \": Win64\"\n-      env: HOST=x86_64-w64-mingw32 PACKAGES=\"nsis gcc-mingw-w64-x86-64 g++-mingw-w64-x86-64 binutils-mingw-w64-x86-64 mingw-w64-dev wine bc\" RUN_TESTS=true GOAL=\"deploy\" BITCOIN_CONFIG=\"--enable-gui\" MAKEJOBS=\"-j2\"\n-    - compiler: \": Win32\"\n-      env: HOST=i686-w64-mingw32 PACKAGES=\"nsis gcc-mingw-w64-i686 g++-mingw-w64-i686 binutils-mingw-w64-i686 mingw-w64-dev wine bc\" RUN_TESTS=true GOAL=\"deploy\" BITCOIN_CONFIG=\"--enable-gui\" MAKEJOBS=\"-j2\"\n+      env: HOST=x86_64-apple-darwin11 PACKAGES=\"cmake libcap-dev libz-dev libbz2-dev\" BITCOIN_CONFIG=\"--enable-reduce-exports\" OSX_SDK=10.9 GOAL=\"deploy\"\n install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi"
      },
      {
        "sha": "6c534f06e49c1e65e7cee1f3351307c1561c9e2b",
        "filename": ".tx/config",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/.tx/config",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/.tx/config",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.tx/config?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,7 +1,7 @@\n [main]\n host = https://www.transifex.com\n \n-[bitcoin.qt-translation-010x]\n+[bitcoin.qt-translation-011x]\n file_filter = src/qt/locale/bitcoin_<lang>.ts\n source_file = src/qt/locale/bitcoin_en.ts\n source_lang = en"
      },
      {
        "sha": "cae0f5b6f41ae1fc0299a52305a9aa047122724e",
        "filename": "COPYING",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/COPYING",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/COPYING",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/COPYING?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,4 +1,4 @@\n-Copyright (c) 2009-2015 Bitcoin Developers\n+Copyright (c) 2009-2015 The Bitcoin Core developers\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal"
      },
      {
        "sha": "56c8c092232dd6ca66fc144855e2e92108d0faf8",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 12,
        "deletions": 10,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -14,8 +14,9 @@ BITCOIN_QT_BIN=$(top_builddir)/src/qt/bitcoin-qt$(EXEEXT)\n BITCOIN_CLI_BIN=$(top_builddir)/src/bitcoin-cli$(EXEEXT)\n BITCOIN_WIN_INSTALLER=$(PACKAGE)-$(PACKAGE_VERSION)-win$(WINDOWS_BITS)-setup$(EXEEXT)\n \n-OSX_APP=Bitcoin-Qt.app\n-OSX_DMG=Bitcoin-Qt.dmg\n+OSX_APP=Bitcoin-Core.app\n+OSX_DMG=Bitcoin-Core.dmg\n+OSX_BACKGROUND_IMAGE=background.tiff\n OSX_DEPLOY_SCRIPT=$(top_srcdir)/contrib/macdeploy/macdeployqtplus\n OSX_FANCY_PLIST=$(top_srcdir)/contrib/macdeploy/fancy.plist\n OSX_INSTALLER_ICONS=$(top_srcdir)/src/qt/res/icons/bitcoin.icns\n@@ -30,7 +31,7 @@ WINDOWS_PACKAGING = $(top_srcdir)/share/pixmaps/bitcoin.ico \\\n   $(top_srcdir)/doc/README_windows.txt\n \n OSX_PACKAGING = $(OSX_DEPLOY_SCRIPT) $(OSX_FANCY_PLIST) $(OSX_INSTALLER_ICONS) \\\n-  $(top_srcdir)/contrib/macdeploy/background.png \\\n+  $(top_srcdir)/contrib/macdeploy/$(OSX_BACKGROUND_IMAGE) \\\n   $(top_srcdir)/contrib/macdeploy/DS_Store \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-apply.sh \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-create.sh\n@@ -58,8 +59,9 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIND_BIN) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_QT_BIN) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_CLI_BIN) $(top_builddir)/release\n-\t@test -f $(MAKENSIS) && $(MAKENSIS) $(top_builddir)/share/setup.nsi || \\\n+\t@test -f $(MAKENSIS) && $(MAKENSIS) -V2 $(top_builddir)/share/setup.nsi || \\\n \t  echo error: could not build $@\n+\t@echo built $@\n \n $(if $(findstring src/,$(MAKECMDGOALS)),$(MAKECMDGOALS), none): FORCE\n \t$(MAKE) -C src $(patsubst src/%,%,$@)\n@@ -95,7 +97,7 @@ $(OSX_DMG): $(OSX_APP_BUILT) $(OSX_PACKAGING)\n deploydir: $(OSX_DMG)\n else\n APP_DIST_DIR=$(top_builddir)/dist\n-APP_DIST_EXTRAS=$(APP_DIST_DIR)/.background/background.png $(APP_DIST_DIR)/.DS_Store $(APP_DIST_DIR)/Applications\n+APP_DIST_EXTRAS=$(APP_DIST_DIR)/.background/$(OSX_BACKGROUND_IMAGE) $(APP_DIST_DIR)/.DS_Store $(APP_DIST_DIR)/Applications\n \n $(APP_DIST_DIR)/Applications:\n \t@rm -f $@\n@@ -104,13 +106,13 @@ $(APP_DIST_DIR)/Applications:\n $(APP_DIST_EXTRAS): $(APP_DIST_DIR)/$(OSX_APP)/Contents/MacOS/Bitcoin-Qt\n \n $(OSX_DMG): $(APP_DIST_EXTRAS)\n-\t$(GENISOIMAGE) -no-cache-inodes -D -l -probe -V \"Bitcoin-Qt\" -no-pad -r -apple -o $@ dist\n+\t$(GENISOIMAGE) -no-cache-inodes -D -l -probe -V \"Bitcoin-Core\" -no-pad -r -apple -o $@ dist\n \n-$(APP_DIST_DIR)/.background/background.png:\n+$(APP_DIST_DIR)/.background/$(OSX_BACKGROUND_IMAGE): contrib/macdeploy/$(OSX_BACKGROUND_IMAGE)\n \t$(MKDIR_P) $(@D)\n-\t$(INSTALL) $(top_srcdir)/contrib/macdeploy/background.png $@\n-$(APP_DIST_DIR)/.DS_Store:\n-\t$(INSTALL) $(top_srcdir)/contrib/macdeploy/DS_Store $@\n+\t$(INSTALL) $< $@\n+$(APP_DIST_DIR)/.DS_Store: contrib/macdeploy/DS_Store\n+\t$(INSTALL) $< $@\n \n $(APP_DIST_DIR)/$(OSX_APP)/Contents/MacOS/Bitcoin-Qt: $(OSX_APP_BUILT) $(OSX_PACKAGING)\n \tINSTALLNAMETOOL=$(INSTALLNAMETOOL)  OTOOL=$(OTOOL) STRIP=$(STRIP) $(OSX_DEPLOY_SCRIPT) $(OSX_APP) -translations-dir=$(QT_TRANSLATION_DIR) -add-qt-tr $(OSX_QT_TRANSLATIONS) -verbose 2"
      },
      {
        "sha": "0bf558d25b5e904fe40340bb29115baaf32da190",
        "filename": "build-aux/m4/bitcoin_find_bdb48.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/build-aux/m4/bitcoin_find_bdb48.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/build-aux/m4/bitcoin_find_bdb48.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_find_bdb48.m4?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -38,7 +38,7 @@ AC_DEFUN([BITCOIN_FIND_BDB48],[\n   done\n   if test \"x$bdbpath\" = \"xX\"; then\n     AC_MSG_RESULT([no])\n-    AC_MSG_ERROR(libdb_cxx headers missing)\n+    AC_MSG_ERROR([libdb_cxx headers missing, Bitcoin Core requires this library for wallet functionality (--disable-wallet to disable wallet functionality)])\n   elif test \"x$bdb48path\" = \"xX\"; then\n     BITCOIN_SUBDIR_TO_INCLUDE(BDB_CPPFLAGS,[${bdbpath}],db_cxx)\n     AC_ARG_WITH([incompatible-bdb],[AS_HELP_STRING([--with-incompatible-bdb], [allow using a bdb version other than 4.8])],["
      },
      {
        "sha": "570ccb8b6f69a7f5a4221cf85eea2d69bdba8c01",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,6 +6,7 @@ AC_DEFUN([BITCOIN_QT_FAIL],[\n       AC_MSG_WARN([$1; bitcoin-qt frontend will not be built])\n     fi\n     bitcoin_enable_qt=no\n+    bitcoin_enable_qt_test=no\n   else\n     AC_MSG_ERROR([$1])\n   fi"
      },
      {
        "sha": "c5d08a02854dc7e30bc8866187feb30b1b145576",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 24,
        "deletions": 42,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,7 +6,7 @@ define(_CLIENT_VERSION_REVISION, 99)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_IS_RELEASE, false)\n define(_COPYRIGHT_YEAR, 2015)\n-AC_INIT([Bitcoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[info@bitcoin.org],[bitcoin])\n+AC_INIT([Bitcoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[https://github.com/bitcoin/bitcoin/issues],[bitcoin])\n AC_CONFIG_SRCDIR([src/main.cpp])\n AC_CONFIG_HEADERS([src/config/bitcoin-config.h])\n AC_CONFIG_AUX_DIR([build-aux])\n@@ -115,9 +115,9 @@ AC_ARG_ENABLE([hardening],\n \n AC_ARG_ENABLE([reduce-exports],\n   [AS_HELP_STRING([--enable-reduce-exports],\n-  [attempt to reduce exported symbols in the resulting executables (default is yes)])],\n+  [attempt to reduce exported symbols in the resulting executables (default is no)])],\n   [use_reduce_exports=$enableval],\n-  [use_reduce_exports=auto])\n+  [use_reduce_exports=no])\n \n AC_ARG_ENABLE([ccache],\n   [AS_HELP_STRING([--enable-ccache],\n@@ -133,7 +133,7 @@ AC_ARG_ENABLE([lcov],\n \n AC_ARG_ENABLE([glibc-back-compat],\n   [AS_HELP_STRING([--enable-glibc-back-compat],\n-  [enable backwards compatibility with glibc and libstdc++])],\n+  [enable backwards compatibility with glibc])],\n   [use_glibc_compat=$enableval],\n   [use_glibc_compat=no])\n \n@@ -350,8 +350,8 @@ if test x$use_lcov = xyes; then\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage flag does not work\")])\n fi\n \n-dnl Require little endian\n-AC_C_BIGENDIAN([AC_MSG_ERROR(\"Big Endian not supported\")])\n+dnl Check for endianness\n+AC_C_BIGENDIAN\n \n dnl Check for pthread compile/link requirements\n AX_PTHREAD\n@@ -438,17 +438,22 @@ if test x$TARGET_OS = xdarwin; then\n   AX_CHECK_LINK_FLAG([[-Wl,-dead_strip]], [LDFLAGS=\"$LDFLAGS -Wl,-dead_strip\"])\n fi\n \n-AC_CHECK_HEADERS([endian.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h])\n+AC_CHECK_HEADERS([endian.h byteswap.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h sys/prctl.h])\n AC_SEARCH_LIBS([getaddrinfo_a], [anl], [AC_DEFINE(HAVE_GETADDRINFO_A, 1, [Define this symbol if you have getaddrinfo_a])])\n AC_SEARCH_LIBS([inet_pton], [nsl resolv], [AC_DEFINE(HAVE_INET_PTON, 1, [Define this symbol if you have inet_pton])])\n \n AC_CHECK_DECLS([strnlen])\n \n-AC_CHECK_DECLS([le32toh, le64toh, htole32, htole64, be32toh, be64toh, htobe32, htobe64],,,\n+AC_CHECK_DECLS([le16toh, le32toh, le64toh, htole16, htole32, htole64, be16toh, be32toh, be64toh, htobe16, htobe32, htobe64],,,\n \t\t[#if HAVE_ENDIAN_H\n                  #include <endian.h>\n                  #endif])\n \n+AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,\n+\t\t[#if HAVE_BYTESWAP_H\n+                 #include <byteswap.h>\n+                 #endif])\n+\n dnl Check for MSG_NOSIGNAL\n AC_MSG_CHECKING(for MSG_NOSIGNAL)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n@@ -471,22 +476,14 @@ AC_LINK_IFELSE([AC_LANG_SOURCE([\n   [\n     AC_MSG_RESULT(no)\n     if test x$use_reduce_exports = xyes; then\n-      AC_MSG_ERROR([Cannot find a working visibility attribute. Use --disable-reduced-exports.])\n+      AC_MSG_ERROR([Cannot find a working visibility attribute. Use --disable-reduce-exports.])\n     fi\n-      AC_MSG_WARN([Cannot find a working visibility attribute. Disabling reduced exports.])\n-      use_reduce_exports=no\n   ]\n )\n \n-if test x$use_reduce_exports != xno; then\n+if test x$use_reduce_exports = xyes; then\n   AX_CHECK_COMPILE_FLAG([-fvisibility=hidden],[RE_CXXFLAGS=\"-fvisibility=hidden\"],\n-  [\n-    if test x$use_reduce_exports = xyes; then\n-      AC_MSG_ERROR([Cannot set default symbol visibility. Use --disable-reduced-exports.])\n-    fi\n-    AC_MSG_WARN([Cannot set default symbol visibility. Disabling reduced exports.])\n-    use_reduce_exports=no\n-  ])\n+  [AC_MSG_ERROR([Cannot set default symbol visibility. Use --disable-reduce-exports.])])\n fi\n \n LEVELDB_CPPFLAGS=\n@@ -533,7 +530,7 @@ AX_BOOST_THREAD\n AX_BOOST_CHRONO\n \n \n-if test x$use_reduce_exports != xno; then\n+if test x$use_reduce_exports = xyes; then\n   AC_MSG_CHECKING([for working boost reduced exports])\n   TEMP_CPPFLAGS=\"$CPPFLAGS\"\n   CPPFLAGS=\"$BOOST_CPPFLAGS $CPPFLAGS\"\n@@ -547,25 +544,14 @@ if test x$use_reduce_exports != xno; then\n       #endif\n     ]])],[\n       AC_MSG_RESULT(yes)\n-    ],[:\n-    if test x$use_reduce_exports = xauto; then\n-      use_reduce_exports=no\n-    else\n-      if test x$use_reduce_exports = xyes; then\n-        AC_MSG_ERROR([boost versions < 1.49 are known to be broken with reduced exports. Use --disable-reduced-exports.])\n-      fi\n-    fi\n-    AC_MSG_RESULT(no)\n-    AC_MSG_WARN([boost versions < 1.49 are known to have symbol visibility issues. Disabling reduced exports.])\n+    ],[\n+    AC_MSG_ERROR([boost versions < 1.49 are known to be broken with reduced exports. Use --disable-reduce-exports.])\n   ])\n   CPPFLAGS=\"$TEMP_CPPFLAGS\"\n fi\n-\n-elif test x$use_reduce_exports = xauto; then\n-    use_reduce_exports=yes\n fi\n \n-if test x$use_reduce_exports != xno; then\n+if test x$use_reduce_exports = xyes; then\n     CXXFLAGS=\"$CXXFLAGS $RE_CXXFLAGS\"\n     AX_CHECK_LINK_FLAG([[-Wl,--exclude-libs,ALL]], [RELDFLAGS=\"-Wl,--exclude-libs,ALL\"])\n fi\n@@ -604,17 +590,15 @@ fi\n \n if test x$use_boost = xyes; then\n \n-BOOST_LIBS=\"$BOOST_LDFLAGS $BOOST_SYSTEM_LIB $BOOST_FILESYSTEM_LIB $BOOST_PROGRAM_OPTIONS_LIB $BOOST_THREAD_LIB\"\n+BOOST_LIBS=\"$BOOST_LDFLAGS $BOOST_SYSTEM_LIB $BOOST_FILESYSTEM_LIB $BOOST_PROGRAM_OPTIONS_LIB $BOOST_THREAD_LIB $BOOST_CHRONO_LIB\"\n \n dnl Boost >= 1.50 uses sleep_for rather than the now-deprecated sleep, however\n dnl it was broken from 1.50 to 1.52 when backed by nanosleep. Use sleep_for if\n dnl a working version is available, else fall back to sleep. sleep was removed\n dnl after 1.56.\n dnl If neither is available, abort.\n-dnl If sleep_for is used, boost_chrono becomes a requirement.\n-if test x$ax_cv_boost_chrono = xyes; then\n TEMP_LIBS=\"$LIBS\"\n-LIBS=\"$BOOST_LIBS $BOOST_CHRONO_LIB $LIBS\"\n+LIBS=\"$BOOST_LIBS $LIBS\"\n TEMP_CPPFLAGS=\"$CPPFLAGS\"\n CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n@@ -627,12 +611,11 @@ AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n    choke me\n   #endif\n   ]])],\n-  [boost_sleep=yes; BOOST_LIBS=\"$BOOST_LIBS $BOOST_CHRONO_LIB\";\n+  [boost_sleep=yes;\n      AC_DEFINE(HAVE_WORKING_BOOST_SLEEP_FOR, 1, [Define this symbol if boost sleep_for works])],\n   [boost_sleep=no])\n LIBS=\"$TEMP_LIBS\"\n CPPFLAGS=\"$TEMP_CPPFLAGS\"\n-fi\n \n if test x$boost_sleep != xyes; then\n TEMP_LIBS=\"$LIBS\"\n@@ -827,7 +810,7 @@ else\n fi\n \n AC_MSG_CHECKING([whether to reduce exports])\n-if test x$use_reduce_exports != xno; then\n+if test x$use_reduce_exports = xyes; then\n   AC_MSG_RESULT([yes])\n else\n   AC_MSG_RESULT([no])\n@@ -849,7 +832,6 @@ AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n AM_CONDITIONAL([USE_COMPARISON_TOOL],[test x$use_comparison_tool != xno])\n AM_CONDITIONAL([USE_COMPARISON_TOOL_REORG_TESTS],[test x$use_comparison_tool_reorg_test != xno])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n-AM_CONDITIONAL([USE_LIBSECP256K1],[test x$use_libsecp256k1 = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])"
      },
      {
        "sha": "7d4b91e887f8e72fed16889c7d8a53c77d5cf5fc",
        "filename": "contrib/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -16,6 +16,9 @@ Repository Tools\n Specific tools for developers working on this repository.\n Contains the script `github-merge.sh` for merging github pull requests securely and signing them using GPG.\n \n+### [Verify-Commits](/contrib/verify-commits) ###\n+Tool to verify that every merge commit was signed by a developer using the above `github-merge.sh` script.\n+\n ### [Linearize](/contrib/linearize) ###\n Construct a linear, no-fork, best version of the blockchain.\n "
      },
      {
        "sha": "c3ce9d793625fc0b1318a9baf77b7f428cbe2062",
        "filename": "contrib/bitrpc/bitrpc.py",
        "status": "modified",
        "additions": 71,
        "deletions": 73,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/bitrpc/bitrpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/bitrpc/bitrpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/bitrpc/bitrpc.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -20,9 +20,9 @@\n     try:\n         path = raw_input(\"Enter destination path/filename: \")\n         print access.backupwallet(path)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n-        \n+    except Exception as inst:\n+        print inst\n+\n elif cmd == \"encryptwallet\":\n     try:\n         pwd = getpass.getpass(prompt=\"Enter passphrase: \")\n@@ -32,29 +32,29 @@\n             print \"\\n---Wallet encrypted. Server stopping, restart to run with encrypted wallet---\\n\"\n         else:\n             print \"\\n---Passphrases do not match---\\n\"\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getaccount\":\n     try:\n         addr = raw_input(\"Enter a Bitcoin address: \")\n         print access.getaccount(addr)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getaccountaddress\":\n     try:\n         acct = raw_input(\"Enter an account name: \")\n         print access.getaccountaddress(acct)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getaddressesbyaccount\":\n     try:\n         acct = raw_input(\"Enter an account name: \")\n         print access.getaddressesbyaccount(acct)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getbalance\":\n     try:\n@@ -64,57 +64,57 @@\n             print access.getbalance(acct, mc)\n         except:\n             print access.getbalance()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getblockbycount\":\n     try:\n         height = raw_input(\"Height: \")\n         print access.getblockbycount(height)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getblockcount\":\n     try:\n         print access.getblockcount()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getblocknumber\":\n     try:\n         print access.getblocknumber()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getconnectioncount\":\n     try:\n         print access.getconnectioncount()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getdifficulty\":\n     try:\n         print access.getdifficulty()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getgenerate\":\n     try:\n         print access.getgenerate()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"gethashespersec\":\n     try:\n         print access.gethashespersec()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getinfo\":\n     try:\n         print access.getinfo()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getnewaddress\":\n     try:\n@@ -123,8 +123,8 @@\n             print access.getnewaddress(acct)\n         except:\n             print access.getnewaddress()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getreceivedbyaccount\":\n     try:\n@@ -134,8 +134,8 @@\n             print access.getreceivedbyaccount(acct, mc)\n         except:\n             print access.getreceivedbyaccount()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getreceivedbyaddress\":\n     try:\n@@ -145,15 +145,15 @@\n             print access.getreceivedbyaddress(addr, mc)\n         except:\n             print access.getreceivedbyaddress()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"gettransaction\":\n     try:\n         txid = raw_input(\"Enter a transaction ID: \")\n         print access.gettransaction(txid)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"getwork\":\n     try:\n@@ -162,8 +162,8 @@\n             print access.gettransaction(data)\n         except:\n             print access.gettransaction()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"help\":\n     try:\n@@ -172,8 +172,8 @@\n             print access.help(cmd)\n         except:\n             print access.help()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"listaccounts\":\n     try:\n@@ -182,8 +182,8 @@\n             print access.listaccounts(mc)\n         except:\n             print access.listaccounts()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"listreceivedbyaccount\":\n     try:\n@@ -193,8 +193,8 @@\n             print access.listreceivedbyaccount(mc, incemp)\n         except:\n             print access.listreceivedbyaccount()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"listreceivedbyaddress\":\n     try:\n@@ -204,8 +204,8 @@\n             print access.listreceivedbyaddress(mc, incemp)\n         except:\n             print access.listreceivedbyaddress()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"listtransactions\":\n     try:\n@@ -216,8 +216,8 @@\n             print access.listtransactions(acct, count, frm)\n         except:\n             print access.listtransactions()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"move\":\n     try:\n@@ -230,8 +230,8 @@\n             print access.move(frm, to, amt, mc, comment)\n         except:\n             print access.move(frm, to, amt)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"sendfrom\":\n     try:\n@@ -245,8 +245,8 @@\n             print access.sendfrom(frm, to, amt, mc, comment, commentto)\n         except:\n             print access.sendfrom(frm, to, amt)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"sendmany\":\n     try:\n@@ -258,8 +258,8 @@\n             print access.sendmany(frm,to,mc,comment)\n         except:\n             print access.sendmany(frm,to)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"sendtoaddress\":\n     try:\n@@ -271,16 +271,16 @@\n             print access.sendtoaddress(to,amt,comment,commentto)\n         except:\n             print access.sendtoaddress(to,amt)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"setaccount\":\n     try:\n         addr = raw_input(\"Address: \")\n         acct = raw_input(\"Account:\")\n         print access.setaccount(addr,acct)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"setgenerate\":\n     try:\n@@ -290,36 +290,36 @@\n             print access.setgenerate(gen, cpus)\n         except:\n             print access.setgenerate(gen)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"settxfee\":\n     try:\n         amt = raw_input(\"Amount:\")\n         print access.settxfee(amt)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"stop\":\n     try:\n         print access.stop()\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"validateaddress\":\n     try:\n         addr = raw_input(\"Address: \")\n         print access.validateaddress(addr)\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"walletpassphrase\":\n     try:\n         pwd = getpass.getpass(prompt=\"Enter wallet passphrase: \")\n         access.walletpassphrase(pwd, 60)\n         print \"\\n---Wallet unlocked---\\n\"\n-    except:\n-        print \"\\n---An error occurred---\\n\"\n+    except Exception as inst:\n+        print inst\n \n elif cmd == \"walletpassphrasechange\":\n     try:\n@@ -328,10 +328,8 @@\n         access.walletpassphrasechange(pwd, pwd2)\n         print\n         print \"\\n---Passphrase changed---\\n\"\n-    except:\n-        print\n-        print \"\\n---An error occurred---\\n\"\n-        print\n+    except Exception as inst:\n+        print inst\n \n else:\n     print \"Command not found or not supported\""
      },
      {
        "sha": "6d3e683855018ec721d97853b0d5c9b90edd5c35",
        "filename": "contrib/debian/bitcoind.manpages",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/bitcoind.manpages",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/bitcoind.manpages",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoind.manpages?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,2 +1,3 @@\n debian/manpages/bitcoind.1\n debian/manpages/bitcoin.conf.5\n+debian/manpages/bitcoin-cli.1"
      },
      {
        "sha": "7ce3babc1b1ae5cdb8ce5f84ffa6cb67c4abba71",
        "filename": "contrib/debian/changelog",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/changelog",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/changelog",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/changelog?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,3 +1,15 @@\n+bitcoin (0.10.0-precise1) precise; urgency=medium\n+\n+  * New upstream releases.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 18 Feb 2015 13:22:00 -1000\n+\n+bitcoin (0.9.4-precise1) precise; urgency=high\n+\n+  * New upstream releases.\n+\n+ -- Matt Corallo (laptop - only while traveling) <matt@mattcorallo.com>  Mon, 12 Jan 2015 23:30:00 -1000\n+\n bitcoin (0.9.3-precise1) precise; urgency=medium\n \n   * New upstream releases."
      },
      {
        "sha": "4392bb33853f9d29b0567f51a8648e962b8f322d",
        "filename": "contrib/debian/control",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/control",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/control",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/control?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -12,7 +12,7 @@ Build-Depends: debhelper,\n  libdb4.8++-dev,\n  libssl-dev,\n  pkg-config,\n- libminiupnpc8-dev,\n+ libminiupnpc8-dev | libminiupnpc-dev (>> 1.6),\n  libboost-filesystem-dev (>> 1.35) | libboost-filesystem1.35-dev,\n  libboost-program-options-dev (>> 1.35) | libboost-program-options1.35-dev,\n  libboost-thread-dev (>> 1.35) | libboost-thread1.35-dev,"
      },
      {
        "sha": "3741031f9ce0a281ef54e5474ed73587be59fe20",
        "filename": "contrib/debian/copyright",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/copyright",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/copyright",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/copyright?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -15,10 +15,6 @@ Files: src/json/*\n Copyright: 2007-2009, John W. Wilkinson\n License: Expat\n \n-Files: src/strlcpy.h\n-Copyright: 1998, Todd C. Miller <Todd.Miller@courtesan.com>\n-License: ISC\n-\n Files: debian/*\n Copyright: 2010-2011, Jonas Smedegaard <dr@jones.dk>\n            2011, Matt Corallo <matt@bluematt.me>"
      },
      {
        "sha": "ade80d60ea0e9937ca6c679b8c44c12b22327493",
        "filename": "contrib/debian/examples/bitcoin.conf",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/examples/bitcoin.conf?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -13,6 +13,12 @@\n # Connect via a SOCKS5 proxy\n #proxy=127.0.0.1:9050\n \n+# Bind to given address and always listen on it. Use [host]:port notation for IPv6\n+#bind=<addr>\n+\n+# Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\n+#whitebind=<addr>\n+\n ##############################################################\n ##            Quick Primer on addnode vs connect            ##\n ##  Let's say for instance you use addnode=4.2.2.4          ##\n@@ -57,6 +63,10 @@\n # server=1 tells Bitcoin-QT and bitcoind to accept JSON-RPC commands\n #server=0\n \n+# Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6.\n+# This option can be specified multiple times (default: bind to all interfaces)\n+#rpcbind=<addr>\n+\n # You must set rpcuser and rpcpassword to secure the JSON-RPC api\n #rpcuser=Ulysseys\n #rpcpassword=YourSuperGreatPasswordNumber_DO_NOT_USE_THIS_OR_YOU_WILL_GET_ROBBED_385593\n@@ -94,6 +104,14 @@\n #rpcsslcertificatechainfile=server.cert\n #rpcsslprivatekeyfile=server.pem\n \n+# Transaction Fee Changes in 0.10.0\n+\n+# Send transactions as zero-fee transactions if possible (default: 0)\n+#sendfreetransactions=0\n+\n+# Create transactions that have enough fees (or priority) so they are likely to begin confirmation within n blocks (default: 1).\n+# This setting is over-ridden by the -paytxfee option.\n+#txconfirmtarget=n\n \n # Miscellaneous options\n "
      },
      {
        "sha": "f953ae9db7a3b4818c71e176dc4edbebada338f9",
        "filename": "contrib/debian/manpages/bitcoin-cli.1",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/manpages/bitcoin-cli.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/manpages/bitcoin-cli.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin-cli.1?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,48 @@\n+.TH BITCOIN-CLI \"1\" \"February 2015\" \"bitcoin-cli 0.10\" \n+.SH NAME\n+bitcoin-cli \\- a remote procedure call client for Bitcoin Core. \n+.SH SYNOPSIS\n+bitcoin-cli [options] <command> [params] \\- Send command to Bitcoin Core. \n+.TP\n+bitcoin-cli [options] help \\- Asks Bitcoin Core for a list of supported commands.\n+.SH DESCRIPTION\n+This manual page documents the bitcoin-cli program. bitcoin-cli is an RPC client used to send commands to Bitcoin Core.\n+\n+.SH OPTIONS\n+.TP\n+\\fB\\-?\\fR\n+Show the help message.\n+.TP\n+\\fB\\-conf=\\fR<file>\n+Specify configuration file (default: bitcoin.conf).\n+.TP\n+\\fB\\-datadir=\\fR<dir>\n+Specify data directory.\n+.TP\n+\\fB\\-testnet\\fR\n+Connect to a Bitcoin Core instance running in testnet mode.\n+.TP\n+\\fB\\-regtest\\fR\n+Connect to a Bitcoin Core instance running in regtest mode (see documentation for -regtest on bitcoind).\n+.TP\n+\\fB\\-rpcuser=\\fR<user>\n+Username for JSON\\-RPC connections.\n+.TP\n+\\fB\\-rpcpassword=\\fR<pw>\n+Password for JSON\\-RPC connections.\n+.TP\n+\\fB\\-rpcport=\\fR<port>\n+Listen for JSON\\-RPC connections on <port> (default: 8332 or testnet: 18332).\n+.TP\n+\\fB\\-rpcconnect=\\fR<ip>\n+Send commands to node running on <ip> (default: 127.0.0.1).\n+.TP\n+\\fB\\-rpcssl\\fR=\\fI1\\fR\n+Use OpenSSL (https) for JSON\\-RPC connections (see the Bitcoin Wiki for SSL setup instructions).\n+\n+.SH \"SEE ALSO\"\n+\\fBbitcoind\\fP, \\fBbitcoin.conf\\fP\n+.SH AUTHOR\n+This manual page was written by Ciemon Dunville <ciemon@gmail.com>. Permission is granted to copy, distribute and/or modify this document under the terms of the MIT License.\n+\n+The complete text of the MIT License can be found on the web at \\fIhttp://opensource.org/licenses/MIT\\fP."
      },
      {
        "sha": "c225b9f3e95f4772097992439c53f7dc96e57ee5",
        "filename": "contrib/debian/manpages/bitcoind.1",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/manpages/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/debian/manpages/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoind.1?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -85,19 +85,19 @@ This help message\n Safely copies *wallet.dat* to 'destination', which can be a directory or a path with filename.\n .TP\n \\fBgetaccount 'bitcoinaddress'\\fR\n-Returns the account associated with the given address.\n+DEPRECATED. Returns the account associated with the given address.\n .TP\n \\fBsetaccount 'bitcoinaddress' ['account']\\fR\n-Sets the ['account'] associated with the given address. ['account'] may be omitted to remove an address from ['account'].\n+DEPRECATED. Sets the ['account'] associated with the given address. ['account'] may be omitted to remove an address from ['account'].\n .TP\n \\fBgetaccountaddress 'account'\\fR\n-Returns a new bitcoin address for 'account'.\n+DEPRECATED. Returns a new bitcoin address for 'account'.\n .TP\n \\fBgetaddressesbyaccount 'account'\\fR\n-Returns the list of addresses associated with the given 'account'.\n+DEPRECATED. Returns the list of addresses associated with the given 'account'.\n .TP\n \\fBgetbalance 'account'\\fR\n-Returns the server's available balance, or the balance for 'account'.\n+Returns the server's available balance, or the balance for 'account' (accounts are deprecated).\n .TP\n \\fBgetblockcount\\fR\n Returns the number of blocks in the longest block chain.\n@@ -124,10 +124,10 @@ Returns a recent hashes per second performance measurement while generating.\n Returns an object containing server information.\n .TP\n \\fBgetnewaddress 'account'\\fR\n-Returns a new bitcoin address for receiving payments. If 'account' is specified (recommended), it is added to the address book so payments received with the address will be credited to 'account'.\n+Returns a new bitcoin address for receiving payments. If 'account' is specified (deprecated), it is added to the address book so payments received with the address will be credited to 'account'.\n .TP\n \\fBgetreceivedbyaccount 'account' ['minconf=1']\\fR\n-Returns the total amount received by addresses associated with 'account' in transactions with at least ['minconf'] confirmations.\n+DEPRECATED. Returns the total amount received by addresses associated with 'account' in transactions with at least ['minconf'] confirmations.\n .TP\n \\fBgetreceivedbyaddress 'bitcoinaddress' ['minconf=1']\\fR\n Returns the total amount received by 'bitcoinaddress' in transactions with at least ['minconf'] confirmations.\n@@ -147,21 +147,21 @@ If 'data' is specified, tries to solve the block and returns true if it was succ\n List commands, or get help for a command.\n .TP\n \\fBlistaccounts ['minconf=1']\\fR\n-List accounts and their current balances.\n+DEPRECATED. List accounts and their current balances.\n      *note: requires bitcoin 0.3.20 or later.\n .TP\n \\fBlistreceivedbyaccount ['minconf=1'] ['includeempty=false']\\fR\n ['minconf'] is the minimum number of confirmations before payments are included. ['includeempty'] whether to include addresses that haven't received any payments. Returns an array of objects containing:\n \n-    \"account\"       : the account of the receiving address.\n+    \"account\"       : DEPRECATED. the account of the receiving address.\n     \"amount\"        : total amount received by the address.\n     \"confirmations\" : number of confirmations of the most recent transaction included.\n .TP\n \\fBlistreceivedbyaddress ['minconf=1'] ['includeempty=false']\\fR\n ['minconf'] is the minimum number of confirmations before payments are included. ['includeempty'] whether to include addresses that haven't received any payments. Returns an array of objects containing:\n \n     \"address\"       : receiving address.\n-    \"account\"       : the account of the receiving address.\n+    \"account\"       : DEPRECATED. the account of the receiving address.\n     \"amount\"        : total amount received by the address.\n     \"confirmations\" : number of confirmations of the most recent transaction included.\n .TP\n@@ -180,10 +180,10 @@ Returns a list of the last ['count'] transactions for 'account' \\- for all accou\n     *note: requires bitcoin 0.3.20 or later.\n .TP\n \\fBmove <'fromaccount'> <'toaccount'> <'amount'> ['minconf=1'] ['comment']\\fR\n-Moves funds between accounts.\n+DEPRECATED. Moves funds between accounts.\n .TP\n \\fBsendfrom* <'account'> <'bitcoinaddress'> <'amount'> ['minconf=1'] ['comment'] ['comment-to']\\fR\n-Sends amount from account's balance to 'bitcoinaddress'. This method will fail if there is less than amount bitcoins with ['minconf'] confirmations in the account's balance (unless account is the empty-string-named default account; it behaves like the *sendtoaddress* method). Returns transaction ID on success.\n+DEPRECATED. Sends amount from account's balance to 'bitcoinaddress'. This method will fail if there is less than amount bitcoins with ['minconf'] confirmations in the account's balance (unless account is the empty-string-named default account; it behaves like the *sendtoaddress* method). Returns transaction ID on success.\n .TP     \n \\fBsendtoaddress 'bitcoinaddress' 'amount' ['comment'] ['comment-to']\\fR\n Sends amount from the server's available balance to 'bitcoinaddress'. amount is a real and is rounded to the nearest 0.01. Returns transaction id on success."
      },
      {
        "sha": "f90afa7f20d829a003d91def92c024d895fea29c",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -81,3 +81,16 @@ It will do the following automatically:\n \n See doc/translation-process.md for more information.\n \n+git-subtree-check.sh\n+====================\n+\n+Run this script from the root of the repository to verify that a subtree matches the contents of\n+the commit it claims to have been updated to.\n+\n+To use, make sure that you have fetched the upstream repository branch in which the subtree is\n+maintained:\n+* for src/secp256k1: https://github.com/bitcoin/secp256k1.git (branch master)\n+* for sec/leveldb: https://github.com/bitcoin/leveldb.git (branch bitcoin-fork)\n+\n+Usage: git-subtree-check.sh DIR COMMIT\n+COMMIT may be omitted, in which case HEAD is used."
      },
      {
        "sha": "1cb82fe6826c74af49cf381ecaf5381ab210bdb7",
        "filename": "contrib/devtools/git-subtree-check.sh",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/devtools/git-subtree-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/devtools/git-subtree-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/git-subtree-check.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,74 @@\n+#!/bin/sh\n+\n+DIR=\"$1\"\n+COMMIT=\"$2\"\n+if [ -z \"$COMMIT\" ]; then\n+    COMMIT=HEAD\n+fi\n+\n+# Taken from git-subtree (Copyright (C) 2009 Avery Pennarun <apenwarr@gmail.com>)\n+find_latest_squash()\n+{\n+\tdir=\"$1\"\n+\tsq=\n+\tmain=\n+\tsub=\n+\tgit log --grep=\"^git-subtree-dir: $dir/*\\$\" \\\n+\t\t--pretty=format:'START %H%n%s%n%n%b%nEND%n' \"$COMMIT\" |\n+\twhile read a b junk; do\n+\t\tcase \"$a\" in\n+\t\t\tSTART) sq=\"$b\" ;;\n+\t\t\tgit-subtree-mainline:) main=\"$b\" ;;\n+\t\t\tgit-subtree-split:) sub=\"$b\" ;;\n+\t\t\tEND)\n+\t\t\t\tif [ -n \"$sub\" ]; then\n+\t\t\t\t\tif [ -n \"$main\" ]; then\n+\t\t\t\t\t\t# a rejoin commit?\n+\t\t\t\t\t\t# Pretend its sub was a squash.\n+\t\t\t\t\t\tsq=\"$sub\"\n+\t\t\t\t\tfi\n+\t\t\t\t\techo \"$sq\" \"$sub\"\n+\t\t\t\t\tbreak\n+\t\t\t\tfi\n+\t\t\t\tsq=\n+\t\t\t\tmain=\n+\t\t\t\tsub=\n+\t\t\t\t;;\n+\t\tesac\n+\tdone\n+}\n+\n+latest_squash=\"$(find_latest_squash \"$DIR\")\"\n+if [ -z \"$latest_squash\" ]; then\n+    echo \"ERROR: $DIR is not a subtree\" >&2\n+    exit 2\n+fi\n+\n+set $latest_squash\n+old=$1\n+rev=$2\n+if [ \"d$(git cat-file -t $rev 2>/dev/null)\" != dcommit ]; then\n+    echo \"ERROR: subtree commit $rev unavailable. Fetch/update the subtree repository\" >&2\n+    exit 2\n+fi\n+tree_subtree=$(git show -s --format=\"%T\" $rev)\n+echo \"$DIR in $COMMIT was last updated to upstream commit $rev (tree $tree_subtree)\"\n+tree_actual=$(git ls-tree -d \"$COMMIT\" \"$DIR\" | head -n 1)\n+if [ -z \"$tree_actual\" ]; then\n+    echo \"FAIL: subtree directory $DIR not found in $COMMIT\" >&2\n+    exit 1\n+fi\n+set $tree_actual\n+tree_actual_type=$2\n+tree_actual_tree=$3\n+echo \"$DIR in $COMMIT currently refers to $tree_actual_type $tree_actual_tree\"\n+if [ \"d$tree_actual_type\" != \"dtree\" ]; then\n+    echo \"FAIL: subtree directory $DIR is not a tree in $COMMIT\" >&2\n+    exit 1\n+fi\n+if [ \"$tree_actual_tree\" != \"$tree_subtree\" ]; then\n+    git diff-tree $tree_actual_tree $tree_subtree >&2\n+    echo \"FAIL: subtree directory tree doesn't match subtree commit tree\" >&2\n+    exit 1\n+fi\n+echo \"GOOD\""
      },
      {
        "sha": "dde4af34915c2ccf07f0dc184779416efe60f4de",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -15,6 +15,7 @@ packages:\n - \"faketime\"\n - \"bsdmainutils\"\n - \"binutils-gold\"\n+- \"libstdc++6-4.6-pic\"\n reference_datetime: \"2013-06-01 00:00:00\"\n remotes:\n - \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n@@ -23,7 +24,7 @@ files: []\n script: |\n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"i686-pc-linux-gnu x86_64-unknown-linux-gnu\"\n-  CONFIGFLAGS=\"--enable-upnp-default --enable-glibc-back-compat\"\n+  CONFIGFLAGS=\"--enable-upnp-default --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\"\n   FAKETIME_HOST_PROGS=\"\"\n   FAKETIME_PROGS=\"date ar ranlib nm strip\"\n \n@@ -69,6 +70,14 @@ script: |\n     make ${MAKEOPTS} -C ${BASEPREFIX} HOST=\"${i}\"\n   done\n \n+  # Ubuntu precise hack: Not an issue in later versions.\n+  # Precise's libstdc++.a is non-pic. There's an optional libstdc++6-4.6-pic\n+  #   package which provides libstdc++_pic.a, but the linker can't find it.\n+  # Symlink it to a path that will be included in our link-line so that the\n+  # linker picks it up before the default libstdc++.a.\n+  # This is only necessary for 64bit.\n+  ln -s /usr/lib/gcc/x86_64-linux-gnu/4.6/libstdc++_pic.a ${BASEPREFIX}/x86_64-unknown-linux-gnu/lib/libstdc++.a\n+\n   # Create the release tarball using (arbitrarily) the first host\n   ./autogen.sh\n   ./configure --prefix=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`\n@@ -99,7 +108,7 @@ script: |\n     find . -name \"lib*.la\" -delete\n     find . -name \"lib*.a\" -delete\n     rm -rf ${DISTNAME}/lib/pkgconfig\n-    find . | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n+    find ${DISTNAME} | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n     cd ../../\n   done\n   mkdir -p $OUTDIR/src"
      },
      {
        "sha": "afe03c7a22d11a8f02c764ec5e8112c3b9d6eb90",
        "filename": "contrib/gitian-descriptors/gitian-osx-signer.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx-signer.yml?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -33,5 +33,5 @@ script: |\n \n   tar -xf ${UNSIGNED}\n   ./detached-sig-apply.sh ${UNSIGNED} signature.tar.gz\n-  ${WRAP_DIR}/genisoimage -no-cache-inodes -D -l -probe -V \"Bitcoin-Qt\" -no-pad -r -apple -o uncompressed.dmg signed-app\n+  ${WRAP_DIR}/genisoimage -no-cache-inodes -D -l -probe -V \"Bitcoin-Core\" -no-pad -r -apple -o uncompressed.dmg signed-app\n   ${WRAP_DIR}/dmg dmg uncompressed.dmg ${OUTDIR}/${SIGNED}"
      },
      {
        "sha": "61eb5b100106ce2f4b5870f1f766f7c9da9ac6af",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -27,7 +27,7 @@ files:\n script: |\n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"x86_64-apple-darwin11\"\n-  CONFIGFLAGS=\"--enable-upnp-default GENISOIMAGE=$WRAP_DIR/genisoimage\"\n+  CONFIGFLAGS=\"--enable-upnp-default --enable-reduce-exports GENISOIMAGE=$WRAP_DIR/genisoimage\"\n   FAKETIME_HOST_PROGS=\"\"\n   FAKETIME_PROGS=\"ar ranlib date dmg genisoimage\"\n \n@@ -120,13 +120,13 @@ script: |\n     popd\n \n     make deploy\n-    ${WRAP_DIR}/dmg dmg Bitcoin-Qt.dmg ${OUTDIR}/${DISTNAME}-osx-unsigned.dmg\n+    ${WRAP_DIR}/dmg dmg Bitcoin-Core.dmg ${OUTDIR}/${DISTNAME}-osx-unsigned.dmg\n \n     cd installed\n     find . -name \"lib*.la\" -delete\n     find . -name \"lib*.a\" -delete\n     rm -rf ${DISTNAME}/lib/pkgconfig\n-    find . | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n+    find ${DISTNAME} | sort | tar --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n     cd ../../\n   done\n   mkdir -p $OUTDIR/src"
      },
      {
        "sha": "2d72f7b6e5aafe7935a7289dfee1f6e103e16c10",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -26,7 +26,7 @@ files: []\n script: |\n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"x86_64-w64-mingw32 i686-w64-mingw32\"\n-  CONFIGFLAGS=\"--enable-upnp-default\"\n+  CONFIGFLAGS=\"--enable-upnp-default --enable-reduce-exports\"\n   FAKETIME_HOST_PROGS=\"g++ ar ranlib nm windres strip\"\n   FAKETIME_PROGS=\"date makensis zip\"\n \n@@ -106,7 +106,7 @@ script: |\n     find . -name \"lib*.la\" -delete\n     find . -name \"lib*.a\" -delete\n     rm -rf ${DISTNAME}/lib/pkgconfig\n-    find . -type f | sort | zip -X@ ${OUTDIR}/${DISTNAME}-${i}.zip\n+    find ${DISTNAME} -type f | sort | zip -X@ ${OUTDIR}/${DISTNAME}-${i}.zip\n     cd ../..\n   done\n   mkdir -p $OUTDIR/src"
      },
      {
        "sha": "9c03ff45226c5629d24e5f9925da7210df0760a5",
        "filename": "contrib/gitian-downloader/fanquake-key.pgp",
        "status": "added",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-downloader/fanquake-key.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-downloader/fanquake-key.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-downloader/fanquake-key.pgp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,63 @@\n+-----BEGIN PGP PUBLIC KEY BLOCK-----\n+Version: GnuPG/MacGPG2 v2.0.26\n+\n+mQINBFFlV7oBEAC3dRAS7gSWQ1fV4JySD0HMBOtY+Y2oCX8vEuTI4atGcxbwXr4/\n+OElRYhDK6Zirk8rMoKPxmr8OVek5LNnY3gcDffco6NXmZ+wTstQm6oqUxFfgzznG\n+X/ExEVuCqiaPAwdWSKn9tC1GuOqRFcD+p2zmxw5mNH5XdsqaPSEGsKESY1IK+dMv\n+K+YUrfrtexZyb66wCtupYziEeag6iEK/i2x2wewOji6IvtI+wB5FO+YMXw+LKucw\n+PoHUOxjoz6YX3s04UxFaZo4R8x6J9XnJBSB2E5kfsSAzz3xR+zuapXY6H6mo/grq\n+nr3c6ACcbAHnMWwQLYvWzde6iwswhyl0whebsajJH7Rd3G4c1U3L/oj4RwUFmZYU\n+5Prs+Q5PepKAJfBeWCXZtUY2BNFCFj7b2H2NXYFR92Oc2GtoHAYACNeP070I9d3m\n+IeuYhOrOckkunwaijUczq4rb3n3Vaq6YrdwZIzs8fALwc9Th98jj2dCUq0fljpSh\n+UQFnPG83UsNkeWzUSgw+lBeEQqgOqUQQ293MbgRg0mJ8q677Iv+WaFqPKZzXxkwT\n+QCCXhjcBmUKgXIHLFcbfmkR8pCcCToWXBD8CU441cBsootDD7SanPHbpcwZjt74x\n+uLrVoCIyaju0T1jSrsPnm2A/8VkWLSCh1WRAlbjvMr7DwizGnRtzTiB6HQARAQAB\n+tC9NaWNoYWVsIEZvcmQgKGJpdGNvaW4tb3RjKSA8ZmFucXVha2VAZ21haWwuY29t\n+PokCNwQTAQoAIQUCUWVXugIbLwULCQgHAwUVCgkICwUWAgMBAAIeAQIXgAAKCRCU\n+TTX5rD23agJgEAC0ouDjufjCMHL4DkaVkOnFbHzP+nR2Mq7pcjdiPNIt9tj8B6cI\n+PRh/E+tt2iEJJ4lzlfj0uEqjqexmSBaMgY+pFb6ESg42EPQjRQ95oBoyZfp+uL/0\n+KC3+Hh+EgmZGIFPZy2HneVfusiBUz2/YTOoqFkzmHalJe9Yvl2+dO0SUC7i6TUdJ\n++ugSr/91hkjQC52LXgHzurH4zOz7ZjzRtZgUIG3oOx8mtEDf46eJ0IUsr+tWJqOp\n+ce5xFh6nkKfS92B7YjGJ4YrkBHC7F9vmbrtIeuWiaxGzVqhHFmLvQe+4xyOpRgHM\n+kcyD5uJNmSMO9gT3udut4hd0yUKg5rdqaUzqsvv19eNL/pZ7aBK2aDAK/yAi1T7X\n+/nrhBJAU49zg1JRS6atRnhKSyd7wRSwVPJAXfVuelHsUgenSdLmSBxRha+9mL6Lb\n+bLK/Dij/0r2fyhBJx4pV6V1n4BpHjv5ivkpgCvOupx8wx3PIxZq/rx+hK+ZBe2EQ\n+7vq8rmLfBkSavHWyNxXEKWQed+mFS3d+Qsoy90bi7gQygIYNZOIBYwsy+qjCZ3om\n+LwkzRjypH23ps7WmiaoenOaCjRYooNL4qtQwNVaDGYwvbMnXJ8Vb4/2j/Riz7+Ui\n+BBVww+Wd72Fml/OFPDFep6HG/PuwFB9m5hmfSzrA01TIdjcWljtTDneufbkCDQRR\n+ZVe6ARAAvi1IAxn9xKQCCqhsoKOiXNbpnmf6lYnoEwGtgI+0a0YQwtzm39P5T8P0\n+esZ65/Re6jCCHLc23/urFPfW9VfrKPmNJncyzlx7OopJ7G1MWdRLEUzwqSaglC6x\n+Zb4r1xR6eq2lBX6CAa5Q+AuAqkoGCEiYBpTyKij4sXE0c+Y9nIDIZhru7EnZvpL3\n+SQvxzFryQLbWCGri0x9GKXZ2ZcDM7jRi/P+iX6yX6sVvOvyKz6NW2BI5OmpI1JbJ\n+3fIXt/R6Wl2xpAFL/pxtYTYbfL6277HWtLDTqIkkRFKh64JdkH8n4G4m6VNUtGEu\n+qP3SxtyShauxY44WzR0YX4rag6tU2Hks6h1JmyF8aQTBAkdP7UrQ0oxZ8f+iG9n6\n+3GtTxgw2NyrqVMx3kBLm8DipyslbA2wCeZLrW6Co0j3pebJsDrMP/3zcmbJqRSLq\n+qnkcxA4gn5j/N0oe8t26Y2WjovndhoR0QQxw8D/BKoMXbl0lvvRAtcnWtyG0COut\n+AGB2PUbGdAX2Ky+uYKrG4uhu1edfV8JZVvB7NIQGzM2P8F9PrDRz7EtG6z7ky/pq\n+HQwRbqwLWGs4QpQmHZchFmXH7pHmLC8i29W+xYhdeUstvx7oESbunICGrPjJOShJ\n+G4191Zg0m/M6jeWV/v+piUXe3YVrgs42UWFusm5ZIduPUfgqUtkAEQEAAYkEPgQY\n+AQoACQUCUWVXugIbLgIpCRCUTTX5rD23asFdIAQZAQoABgUCUWVXugAKCRAu659c\n+wJUmwaduEACCiiRpBeKF5fSaM0cTb97hAHVQJL9Wk3xvA49YuROsSwtCzq9v+js5\n+f/fE+QV/dIQUNwifEPQk8MqUVKpe1lIXwRp23GinzDAnOhfWnECqrMdR0dP99D49\n+Zb7Dd4LDvP9c0mYtnX/78qQilxWmXhzDXcunnPsfCqsrduk9hMwkjmIrWFeSWSAg\n+BEJDuZ4WLuqjni1udth0iZtZYrDaDgX/RWcTFW8QCc5hLsCRcInAxb75AWfWq6i/\n+s3Ibg5tGm4+UfqGbFPuNyy6ow3ggqkovBp6ABMxe8dAYVXSmM2tKWZXBb3L6eho8\n+QKKzyoezqpbQ2YUaYZ8XAdLuumXCtAHKP3/DI1JBefE0mxi1CXjdLK9sE5OO5KNt\n+FXR8Dnot5C4BHrcaF6Iq2sqbhPxnhcDrEwv2mUgruD7n04LKIztAG0A35rcu6A2i\n+IUq/PsXjS/5rX/p4CeYvnTTspXkhXgkvfhWz1cISXyfcNTWBKwOsLW4lY8bi05cv\n+4Axl88tTg2dNYXIxSK7Jtu1YCEsZ8uaT3AAiTp1sKAOcRX8hIOTmPPxMxbIm8yg1\n+jl71ovsV5rAyuVTUouFnljXyuLWXLotUOkmC6DjJUuRaxzt23/eByJ45x94T/A2U\n+iT1oU+voigQGARrDkApXlgSI4oekg3Zgq57y6toV9F7o9A1PMtBq3AvDD/0as1K0\n+wCRZIXinSwW2F6tFnVV+z+vvE0i54yHaskkuJYZRSQ/yJR1VgmW/BtAr7ooXF7l+\n+9g7XOH7D8T28h+m4ABLN5ZDOxfTMZuV5Y4MnELh4dlBIfKGG2kjmW8+y/PUqMMGE\n+BYRmGOD1qtWvFYoZ2ss5yrlvfenRRhQbIYSRz/YiT8OTogaNcYNpArUwT4z+05af\n+kdxx0AaqauHqKRo/XTO5GIZQ6NbtPH6G++2Ie+oP8AyBWEpL3rvjZpzn7jxTBXMc\n+MOMmhnb0Go4hD+BSphgDTZOgMLOLcorjb1Ct2VnajxPZD0aTB13SCgZjJhs9j3on\n+EoI3gTHkRgiBjMBNtw7iaAumIRgrDwGzyuIL6bbyfDnbE02zxCqkYP6P0u48FGLs\n+E4U60GrYSlFxa1MexF+HIPgqWsTOv4D2zXEJYvm1XEu1VOGQUkw7J5RFTDxHgkbh\n+qvmkZ492iW2IC4L9hSdSqiZ5LhD2JwpgrMt8vrCzVitkjYQnXJ6WbWYfCybPsmLb\n+mfQ03i9E+a50UC2SGDf8e3oxImAbbXLP/LyI7oczCxyb0EzcQlIIOtBgl3gI6KAh\n+PTRQGeHCzIOSgUf7B0ihY7qiDeR1OshvTY0wdykdS0c+hzwuS5TZvfY4YM7Tssvt\n+XwbdK0Zpx/oDtRHpuDMGKJBV2LWAZYkEbFsmtg==\n+=3o2I\n+-----END PGP PUBLIC KEY BLOCK-----"
      },
      {
        "sha": "fe44c0fbd4eb3b57ff658f48a1e7af67e2d25dda",
        "filename": "contrib/gitian-downloader/jonasschnelli-key.pgp",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-downloader/jonasschnelli-key.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-downloader/jonasschnelli-key.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-downloader/jonasschnelli-key.pgp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "96140fe171651577d56ce75c3ce50b81026dadac",
        "filename": "contrib/gitian-downloader/jonasschnelli.pgp",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/contrib/gitian-downloader/jonasschnelli.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/contrib/gitian-downloader/jonasschnelli.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-downloader/jonasschnelli.pgp?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6"
      },
      {
        "sha": "4406e6d5be02c1e9006c6ecccc1e4c7c0dbad60c",
        "filename": "contrib/gitian-downloader/luke-jr-key.pgp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-downloader/luke-jr-key.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/gitian-downloader/luke-jr-key.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-downloader/luke-jr-key.pgp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "0d19da30399b0a11be458948974e2b7ab45380a7",
        "filename": "contrib/init/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/init/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/init/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -4,6 +4,7 @@ SystemD: bitcoind.service\n Upstart: bitcoind.conf\n OpenRC:  bitcoind.openrc\n          bitcoind.openrcconf\n+CentOS:  bitcoind.init\n \n have been made available to assist packagers in creating node packages here.\n "
      },
      {
        "sha": "db5061874b3a923278fa11d4f3117fca19da1bcc",
        "filename": "contrib/init/bitcoind.init",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/init/bitcoind.init",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/init/bitcoind.init",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.init?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,67 @@\n+#!/bin/bash\n+#\n+#  bitcoind The bitcoin core server.\n+#\n+#\n+# chkconfig: 345 80 20\n+# description: bitcoind\n+# processname: bitcoind\n+#\n+\n+# Source function library.\n+. /etc/init.d/functions\n+\n+# you can override defaults in /etc/sysconfig/bitcoind, see below\n+if [ -f /etc/sysconfig/bitcoind ]; then\n+        . /etc/sysconfig/bitcoind\n+fi\n+\n+RETVAL=0\n+\n+prog=bitcoind\n+# you can override the lockfile via BITCOIND_LOCKFILE in /etc/sysconfig/bitcoind\n+lockfile=${BITCOIND_LOCKFILE-/var/lock/subsys/bitcoind}\n+\n+# bitcoind defaults to /usr/bin/bitcoind, override with BITCOIND_BIN\n+bitcoind=${BITCOIND_BIN-/usr/bin/bitcoind}\n+\n+# bitcoind opts default to -disablewallet, override with BITCOIND_OPTS\n+bitcoind_opts=${BITCOIND_OPTS--disablewallet}\n+\n+start() {\n+    echo -n $\"Starting $prog: \"\n+    daemon $DAEMONOPTS $bitcoind $bitcoind_opts\n+    RETVAL=$?\n+    echo\n+    [ $RETVAL -eq 0 ] && touch $lockfile\n+    return $RETVAL\n+}\n+\n+stop() {\n+    echo -n $\"Stopping $prog: \"\n+    killproc $prog\n+    RETVAL=$?\n+    echo\n+    [ $RETVAL -eq 0 ] && rm -f $lockfile\n+    return $RETVAL\n+}\n+\n+case \"$1\" in\n+    start)\n+        start\n+        ;;\n+    stop)\n+        stop\n+        ;;\n+    status)\n+        status $prog\n+        ;;\n+    restart)\n+        stop\n+        start\n+        ;;\n+    *)\n+        echo \"Usage: service $prog {start|stop|status|restart}\"\n+        exit 1\n+        ;;\n+esac"
      },
      {
        "sha": "a94f03680d34061bd3e92bab9dd54a36f521f797",
        "filename": "contrib/init/bitcoind.openrc",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/init/bitcoind.openrc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/init/bitcoind.openrc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrc?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -12,12 +12,14 @@ BITCOIND_CONFIGFILE=${BITCOIND_CONFIGFILE:-/etc/bitcoin/bitcoin.conf}\n BITCOIND_PIDDIR=${BITCOIND_PIDDIR:-/var/run/bitcoind}\n BITCOIND_PIDFILE=${BITCOIND_PIDFILE:-${BITCOIND_PIDDIR}/bitcoind.pid}\n BITCOIND_DATADIR=${BITCOIND_DATADIR:-${BITCOIND_DEFAULT_DATADIR}}\n-BITCOIND_USER=${BITCOIND_USER:-bitcoin}\n+BITCOIND_USER=${BITCOIND_USER:-${BITCOIN_USER:-bitcoin}}\n BITCOIND_GROUP=${BITCOIND_GROUP:-bitcoin}\n BITCOIND_BIN=${BITCOIND_BIN:-/usr/bin/bitcoind}\n+BITCOIND_NICE=${BITCOIND_NICE:-${NICELEVEL:-0}}\n+BITCOIND_OPTS=\"${BITCOIND_OPTS:-${BITCOIN_OPTS}}\"\n \n name=\"Bitcoin Core Daemon\"\n-description=\"Bitcoin crypto-currency p2p network daemon\"\n+description=\"Bitcoin cryptocurrency P2P network daemon\"\n \n command=\"/usr/bin/bitcoind\"\n command_args=\"-pid=\\\"${BITCOIND_PIDFILE}\\\" \\\n@@ -28,7 +30,7 @@ command_args=\"-pid=\\\"${BITCOIND_PIDFILE}\\\" \\\n \n required_files=\"${BITCOIND_CONFIGFILE}\"\n start_stop_daemon_args=\"-u ${BITCOIND_USER} \\\n-\t\t\t-N ${BITCOIND_NICE:-0} -w 2000\"\n+\t\t\t-N ${BITCOIND_NICE} -w 2000\"\n pidfile=\"${BITCOIND_PIDFILE}\"\n retry=60\n "
      },
      {
        "sha": "38da02e66c1e7a46688afea10e8dfc9dbbb38959",
        "filename": "contrib/linearize/example-linearize.cfg",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/linearize/example-linearize.cfg",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/linearize/example-linearize.cfg",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/example-linearize.cfg?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -4,13 +4,23 @@ rpcuser=someuser\n rpcpassword=somepassword\n host=127.0.0.1\n port=8332\n+#port=18332\n \n # bootstrap.dat hashlist settings (linearize-hashes)\n max_height=313000\n \n # bootstrap.dat input/output settings (linearize-data)\n+\n+# mainnet\n netmagic=f9beb4d9\n+genesis=000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\n input=/home/example/.bitcoin/blocks\n+\n+# testnet\n+#netmagic=0b110907\n+#genesis=000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\n+#input=/home/example/.bitcoin/testnet3/blocks\n+\n output_file=/home/example/Downloads/bootstrap.dat\n hashlist=hashlist.txt\n split_year=1"
      },
      {
        "sha": "7947c6bf7263e49c5a263f3d283dc112a25f64cb",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -205,7 +205,7 @@ def run(self):\n \n \t\t\tinMagic = inhdr[:4]\n \t\t\tif (inMagic != self.settings['netmagic']):\n-\t\t\t\tprint(\"Invalid magic: \" + inMagic)\n+\t\t\t\tprint(\"Invalid magic: \" + inMagic.encode('hex'))\n \t\t\t\treturn\n \t\t\tinLenLE = inhdr[4:]\n \t\t\tsu = struct.unpack(\"<I\", inLenLE)\n@@ -265,6 +265,8 @@ def run(self):\n \n \tif 'netmagic' not in settings:\n \t\tsettings['netmagic'] = 'f9beb4d9'\n+\tif 'genesis' not in settings:\n+\t\tsettings['genesis'] = '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n \tif 'input' not in settings:\n \t\tsettings['input'] = 'input'\n \tif 'hashlist' not in settings:\n@@ -291,7 +293,7 @@ def run(self):\n \tblkindex = get_block_hashes(settings)\n \tblkmap = mkblockmap(blkindex)\n \n-\tif not \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\" in blkmap:\n+\tif not settings['genesis'] in blkmap:\n \t\tprint(\"Genesis block not found in hashlist\")\n \telse:\n \t\tBlockDataCopier(settings, blkindex, blkmap).run()"
      },
      {
        "sha": "ca19b207c06c31ab722f3a9eb4f9d5f3a4a8f6de",
        "filename": "contrib/macdeploy/DS_Store",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/DS_Store",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/DS_Store",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/DS_Store?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "6163734e623bd3a21ac5e1ef83a42dd45febe746",
        "filename": "contrib/macdeploy/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -11,5 +11,5 @@ This script should not be run manually, instead, after building as usual:\n During the process, the disk image window will pop up briefly where the fancy\n settings are applied. This is normal, please do not interfere.\n \n-When finished, it will produce `Bitcoin-Qt.dmg`.\n+When finished, it will produce `Bitcoin-Core.dmg`.\n "
      },
      {
        "sha": "f88a2ae74bdb33afc2806b6403ea8c0191b096ca",
        "filename": "contrib/macdeploy/background.png",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/background.png?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "fdc4f4ca4a07ea4c6082ee1357b6ec7e8db99d72",
        "filename": "contrib/macdeploy/background.psd",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background.psd",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background.psd",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/background.psd?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "4b44ac672e627be82bb9b74dac0016057b11c126",
        "filename": "contrib/macdeploy/background.tiff",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background.tiff",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background.tiff",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/background.tiff?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "4858183f75c382a9b8d75ae4fb8a74abd830615f",
        "filename": "contrib/macdeploy/background@2x.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background@2x.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/background@2x.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/background@2x.png?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "169f6904385e2b0772b7921cda4f435e2774b9bc",
        "filename": "contrib/macdeploy/detached-sig-apply.sh",
        "status": "modified",
        "additions": 10,
        "deletions": 11,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/detached-sig-apply.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/detached-sig-apply.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/detached-sig-apply.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,11 +1,10 @@\n #!/bin/sh\n set -e\n \n-UNSIGNED=$1\n-SIGNATURE=$2\n+UNSIGNED=\"$1\"\n+SIGNATURE=\"$2\"\n ARCH=x86_64\n ROOTDIR=dist\n-BUNDLE=${ROOTDIR}/Bitcoin-Qt.app\n TEMPDIR=signed.temp\n OUTDIR=signed-app\n \n@@ -31,21 +30,21 @@ if [ -z \"${CODESIGN_ALLOCATE}\" ]; then\n   CODESIGN_ALLOCATE=${TEMPDIR}/codesign_allocate\n fi\n \n-for i in `find ${TEMPDIR} -name \"*.sign\"`; do\n-  SIZE=`stat -c %s ${i}`\n-  TARGET_FILE=`echo ${i} | sed 's/\\.sign$//'`\n+find ${TEMPDIR} -name \"*.sign\" | while read i; do\n+  SIZE=`stat -c %s \"${i}\"`\n+  TARGET_FILE=\"`echo \"${i}\" | sed 's/\\.sign$//'`\"\n \n   echo \"Allocating space for the signature of size ${SIZE} in ${TARGET_FILE}\"\n-  ${CODESIGN_ALLOCATE} -i ${TARGET_FILE} -a ${ARCH} ${SIZE} -o ${i}.tmp\n+  ${CODESIGN_ALLOCATE} -i \"${TARGET_FILE}\" -a ${ARCH} ${SIZE} -o \"${i}.tmp\"\n \n-  OFFSET=`${PAGESTUFF} ${i}.tmp -p | tail -2 | grep offset | sed 's/[^0-9]*//g'`\n+  OFFSET=`${PAGESTUFF} \"${i}.tmp\" -p | tail -2 | grep offset | sed 's/[^0-9]*//g'`\n   if [ -z ${QUIET} ]; then\n     echo \"Attaching signature at offset ${OFFSET}\"\n   fi\n \n-  dd if=$i of=${i}.tmp bs=1 seek=${OFFSET} count=${SIZE} 2>/dev/null\n-  mv ${i}.tmp ${TARGET_FILE}\n-  rm ${i}\n+  dd if=\"$i\" of=\"${i}.tmp\" bs=1 seek=${OFFSET} count=${SIZE} 2>/dev/null\n+  mv \"${i}.tmp\" \"${TARGET_FILE}\"\n+  rm \"${i}\"\n   echo \"Success.\"\n done\n mv ${TEMPDIR}/${ROOTDIR} ${OUTDIR}"
      },
      {
        "sha": "fd7314bd7e1fb20d4afaaa7f18b1159048872a4f",
        "filename": "contrib/macdeploy/detached-sig-create.sh",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/detached-sig-create.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/detached-sig-create.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/detached-sig-create.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -2,7 +2,7 @@\n set -e\n \n ROOTDIR=dist\n-BUNDLE=${ROOTDIR}/Bitcoin-Qt.app\n+BUNDLE=\"${ROOTDIR}/Bitcoin Core.app\"\n CODESIGN=codesign\n TEMPDIR=sign.temp\n TEMPLIST=${TEMPDIR}/signatures.txt\n@@ -19,19 +19,19 @@ mkdir -p ${TEMPDIR}\n \n ${CODESIGN} -f --file-list ${TEMPLIST} \"$@\" \"${BUNDLE}\"\n \n-for i in `grep -v CodeResources ${TEMPLIST}`; do\n-  TARGETFILE=\"${BUNDLE}/`echo ${i} | sed \"s|.*${BUNDLE}/||\"`\"\n-  SIZE=`pagestuff $i -p | tail -2 | grep size | sed 's/[^0-9]*//g'`\n-  OFFSET=`pagestuff $i -p | tail -2 | grep offset | sed 's/[^0-9]*//g'`\n+grep -v CodeResources < \"${TEMPLIST}\" | while read i; do\n+  TARGETFILE=\"${BUNDLE}/`echo \"${i}\" | sed \"s|.*${BUNDLE}/||\"`\"\n+  SIZE=`pagestuff \"$i\" -p | tail -2 | grep size | sed 's/[^0-9]*//g'`\n+  OFFSET=`pagestuff \"$i\" -p | tail -2 | grep offset | sed 's/[^0-9]*//g'`\n   SIGNFILE=\"${TEMPDIR}/${TARGETFILE}.sign\"\n-  DIRNAME=\"`dirname ${SIGNFILE}`\"\n+  DIRNAME=\"`dirname \"${SIGNFILE}\"`\"\n   mkdir -p \"${DIRNAME}\"\n   echo \"Adding detached signature for: ${TARGETFILE}. Size: ${SIZE}. Offset: ${OFFSET}\"\n-  dd if=$i of=${SIGNFILE} bs=1 skip=${OFFSET} count=${SIZE} 2>/dev/null\n+  dd if=\"$i\" of=\"${SIGNFILE}\" bs=1 skip=${OFFSET} count=${SIZE} 2>/dev/null\n done\n \n-for i in `grep CodeResources ${TEMPLIST}`; do\n-  TARGETFILE=\"${BUNDLE}/`echo ${i} | sed \"s|.*${BUNDLE}/||\"`\"\n+grep CodeResources < \"${TEMPLIST}\" | while read i; do\n+  TARGETFILE=\"${BUNDLE}/`echo \"${i}\" | sed \"s|.*${BUNDLE}/||\"`\"\n   RESOURCE=\"${TEMPDIR}/${TARGETFILE}\"\n   DIRNAME=\"`dirname \"${RESOURCE}\"`\"\n   mkdir -p \"${DIRNAME}\"\n@@ -41,6 +41,6 @@ done\n \n rm ${TEMPLIST}\n \n-tar -C ${TEMPDIR} -czf ${OUT} .\n-rm -rf ${TEMPDIR}\n+tar -C \"${TEMPDIR}\" -czf \"${OUT}\" .\n+rm -rf \"${TEMPDIR}\"\n echo \"Created ${OUT}\""
      },
      {
        "sha": "a333f5dccdcbc2cbe1a5b24ad0cf1a02df548979",
        "filename": "contrib/macdeploy/fancy.plist",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/fancy.plist",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/fancy.plist",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/fancy.plist?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -10,7 +10,7 @@\n \t\t<integer>620</integer>\n \t</array>\n \t<key>background_picture</key>\n-\t<string>background.png</string>\n+\t<string>background.tiff</string>\n \t<key>icon_size</key>\n \t<integer>96</integer>\n \t<key>applications_symlink</key>\n@@ -22,7 +22,7 @@\n \t\t\t<integer>370</integer>\n \t\t\t<integer>156</integer>\n \t\t</array>\n-\t\t<key>Bitcoin-Qt.app</key>\n+\t\t<key>Bitcoin Core.app</key>\n \t\t<array>\n \t\t\t<integer>128</integer>\n \t\t\t<integer>156</integer>"
      },
      {
        "sha": "a625987ca768191cd1a0dd5a55a408ac66656899",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -155,7 +155,7 @@ class FrameworkInfo(object):\n class ApplicationBundleInfo(object):\n     def __init__(self, path):\n         self.path = path\n-        appName = os.path.splitext(os.path.basename(path))[0]\n+        appName = \"Bitcoin-Qt\"\n         self.binaryPath = os.path.join(path, \"Contents\", \"MacOS\", appName)\n         if not os.path.exists(self.binaryPath):\n             raise RuntimeError(\"Could not find bundle binary for \" + path)\n@@ -596,7 +596,7 @@ if os.path.exists(\"dist\"):\n \n # ------------------------------------------------\n \n-target = os.path.join(\"dist\", app_bundle)\n+target = os.path.join(\"dist\", \"Bitcoin Core.app\")\n \n if verbose >= 2:\n     print \"+ Copying source bundle +\"\n@@ -767,7 +767,7 @@ if config.dmg is not None:\n         for path, dirs, files in os.walk(\"dist\"):\n             for file in files:\n                 size += os.path.getsize(os.path.join(path, file))\n-        size += int(size * 0.1)\n+        size += int(size * 0.15)\n         \n         if verbose >= 3:\n             print \"Creating temp image for modification...\"\n@@ -791,7 +791,8 @@ if config.dmg is not None:\n             print \"+ Applying fancy settings +\"\n         \n         if fancy.has_key(\"background_picture\"):\n-            bg_path = os.path.join(disk_root, os.path.basename(fancy[\"background_picture\"]))\n+            bg_path = os.path.join(disk_root, \".background\", os.path.basename(fancy[\"background_picture\"]))\n+            os.mkdir(os.path.dirname(bg_path))\n             if verbose >= 3:\n                 print fancy[\"background_picture\"], \"->\", bg_path\n             shutil.copy2(fancy[\"background_picture\"], bg_path)\n@@ -836,7 +837,7 @@ if config.dmg is not None:\n                 items_positions.append(itemscript.substitute(params))\n \n         params = {\n-            \"disk\" : \"Bitcoin-Qt\",\n+            \"disk\" : \"Bitcoin-Core\",\n             \"window_bounds\" : \"300,300,800,620\",\n             \"icon_size\" : \"96\",\n             \"background_commands\" : \"\",\n@@ -849,8 +850,8 @@ if config.dmg is not None:\n         if bg_path is not None:\n             # Set background file, then call SetFile to make it invisible.\n             # (note: making it invisible first makes set background picture fail)\n-            bgscript = Template(\"\"\"set background picture of theViewOptions to file \"$bgpic\"\n-                   do shell script \"SetFile -a V /Volumes/$disk/$bgpic\" \"\"\")\n+            bgscript = Template(\"\"\"set background picture of theViewOptions to file \".background:$bgpic\"\n+                   do shell script \"SetFile -a V /Volumes/$disk/.background/$bgpic\" \"\"\")\n             params[\"background_commands\"] = bgscript.substitute({\"bgpic\" : os.path.basename(bg_path), \"disk\" : params[\"disk\"]})\n \n         s = appscript.substitute(params)"
      },
      {
        "sha": "6b5137e7b54e545f4ea2211009b1b3e65bebf304",
        "filename": "contrib/verify-commits/gpg.sh",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/gpg.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/gpg.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/gpg.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,15 @@\n+#!/bin/sh\n+INPUT=$(</dev/stdin)\n+VALID=false\n+IFS=$'\\n'\n+for LINE in $(echo \"$INPUT\" | gpg --trust-model always \"$@\" 2>/dev/null); do\n+\tcase \"$LINE\" in \"[GNUPG:] VALIDSIG\"*)\n+\t\twhile read KEY; do\n+\t\t\tcase \"$LINE\" in \"[GNUPG:] VALIDSIG $KEY \"*) VALID=true;; esac\n+\t\tdone < ./contrib/verify-commits/trusted-keys\n+\tesac\n+done\n+if ! $VALID; then\n+\texit 1\n+fi\n+echo \"$INPUT\" | gpg --trust-model always \"$@\" 2>/dev/null"
      },
      {
        "sha": "607c0cac45ef6e7ca1bc674e4a3085cfa6b7e1cc",
        "filename": "contrib/verify-commits/pre-push-hook.sh",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/pre-push-hook.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/pre-push-hook.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/pre-push-hook.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,16 @@\n+#!/bin/bash\n+if ! [[ \"$2\" =~ [git@]?[www.]?github.com[:|/]bitcoin/bitcoin[.git]? ]]; then\n+    exit 0\n+fi\n+\n+while read LINE; do\n+    set -- A $LINE\n+    if [ \"$4\" != \"refs/heads/master\" ]; then\n+        continue\n+    fi\n+    if ! ./contrib/verify-commits/verify-commits.sh $3 > /dev/null 2>&1; then\n+        echo \"ERROR: A commit is not signed, can't push\"\n+        ./contrib/verify-commits/verify-commits.sh\n+        exit 1\n+    fi\n+done < /dev/stdin"
      },
      {
        "sha": "eb13f8762e573a1ff2ac89377f2b15de057cf5c6",
        "filename": "contrib/verify-commits/trusted-git-root",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/trusted-git-root",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/trusted-git-root",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/trusted-git-root?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1 @@\n+053038e5ba116cb319fb85f3cb3e062cf1b3df15"
      },
      {
        "sha": "658ad0375badbfb88ee89322dd170b41666de9f1",
        "filename": "contrib/verify-commits/trusted-keys",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/trusted-keys",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/trusted-keys",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/trusted-keys?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,5 @@\n+71A3B16735405025D447E8F274810B012346C9A6\n+1F4410F6A89268CE3197A84C57896D2FF8F0B657\n+01CDF4627A3B88AAE4A571C87588242FBE38D3A8\n+AF8BE07C7049F3A26B239D5325B3083201782B2F\n+81291FA67D2C379A006A053FEAB5AF94D9E9ABE7"
      },
      {
        "sha": "5841fa2077aa8a882cd12701a6882b12788f7bdf",
        "filename": "contrib/verify-commits/verify-commits.sh",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/verify-commits.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/contrib/verify-commits/verify-commits.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/verify-commits.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,51 @@\n+#!/bin/sh\n+\n+DIR=$(dirname \"$0\")\n+\n+echo \"Please verify all commits in the following list are not evil:\"\n+git log \"$DIR\"\n+\n+VERIFIED_ROOT=$(cat \"${DIR}/trusted-git-root\")\n+\n+HAVE_FAILED=false\n+IS_SIGNED () {\n+\tif [ $1 = $VERIFIED_ROOT ]; then\n+\t\treturn 0;\n+\tfi\n+\tif ! git -c \"gpg.program=${DIR}/gpg.sh\" verify-commit $1 > /dev/null 2>&1; then\n+\t\treturn 1;\n+\tfi\n+\tlocal PARENTS=$(git show -s --format=format:%P $1)\n+\tfor PARENT in $PARENTS; do\n+\t\tif IS_SIGNED $PARENT > /dev/null; then\n+\t\t\treturn 0;\n+\t\tfi\n+\tdone\n+\tif ! \"$HAVE_FAILED\"; then\n+\t\techo \"No parent of $1 was signed with a trusted key!\" > /dev/stderr\n+\t\techo \"Parents are:\" > /dev/stderr\n+\t\tfor PARENT in $PARENTS; do\n+\t\t\tgit show -s $PARENT > /dev/stderr\n+\t\tdone\n+\t\tHAVE_FAILED=true\n+\tfi\n+\treturn 1;\n+}\n+\n+if [ x\"$1\" = \"x\" ]; then\n+\tTEST_COMMIT=\"HEAD\"\n+else\n+\tTEST_COMMIT=\"$1\"\n+fi\n+\n+IS_SIGNED \"$TEST_COMMIT\"\n+RES=$?\n+if [ \"$RES\" = 1 ]; then\n+\tif ! \"$HAVE_FAILED\"; then\n+\t\techo \"$TEST_COMMIT was not signed with a trusted key!\"\n+\tfi\n+else\n+\techo \"There is a valid path from $TEST_COMMIT to $VERIFIED_ROOT where all commits are signed!\"\n+fi\n+\n+exit $RES"
      },
      {
        "sha": "1f163897b9ef70c68bef39aba3bac5092b0aedd3",
        "filename": "depends/.gitignore",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/.gitignore?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -3,3 +3,7 @@ work/\n built/\n sources/\n config.site\n+x86_64*\n+i686*\n+mips*\n+arm*"
      },
      {
        "sha": "ef5a20e6c36aa9c9cbb0fa9334ec8d24824a0bc2",
        "filename": "depends/Makefile",
        "status": "modified",
        "additions": 34,
        "deletions": 7,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/Makefile?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,7 +6,6 @@ SDK_PATH ?= $(BASEDIR)/SDKs\n NO_QT ?=\n NO_WALLET ?=\n NO_UPNP ?=\n-USE_LINUX_STATIC_QT5 ?=\n FALLBACK_DOWNLOAD_PATH ?= https://bitcoincore.org/depends-sources\n \n BUILD = $(shell ./config.guess)\n@@ -92,12 +91,12 @@ include funcs.mk\n toolchain_path=$($($(host_arch)_$(host_os)_native_toolchain)_prefixbin)\n final_build_id_long+=$(shell $(build_SHA256SUM) config.site.in)\n final_build_id+=$(shell echo -n $(final_build_id_long) | $(build_SHA256SUM) | cut -c-$(HASH_LENGTH))\n-$(host_prefix)/.stamp_$(final_build_id): | $(native_packages) $(packages)\n+$(host_prefix)/.stamp_$(final_build_id): $(native_packages) $(packages)\n \t$(AT)rm -rf $(@D)\n \t$(AT)mkdir -p $(@D)\n-\t$(AT)echo copying packages: $|\n+\t$(AT)echo copying packages: $^\n \t$(AT)echo to: $(@D)\n-\t$(AT)cd $(@D); $(foreach package,$|, tar xf $($(package)_cached); )\n+\t$(AT)cd $(@D); $(foreach package,$^, tar xf $($(package)_cached); )\n \t$(AT)touch $@\n \n $(host_prefix)/share/config.site : config.site.in $(host_prefix)/.stamp_$(final_build_id)\n@@ -122,13 +121,41 @@ $(host_prefix)/share/config.site : config.site.in $(host_prefix)/.stamp_$(final_\n             $< > $@\n \t$(AT)touch $@\n \n-install: $(host_prefix)/share/config.site\n-download-one: $(all_sources)\n+\n+define check_or_remove_cached\n+  mkdir -p $(BASE_CACHE)/$(host)/$(package) && cd $(BASE_CACHE)/$(host)/$(package); \\\n+  $(build_SHA256SUM) -c $($(package)_cached_checksum) >/dev/null 2>/dev/null || \\\n+  ( rm -f $($(package)_cached_checksum); \\\n+    if test -f \"$($(package)_cached)\"; then echo \"Checksum mismatch for $(package). Forcing rebuild..\"; rm -f $($(package)_cached_checksum) $($(package)_cached); fi )\n+endef\n+\n+define check_or_remove_sources\n+  mkdir -p $($(package)_source_dir); cd $($(package)_source_dir); \\\n+  $(build_SHA256SUM) -c $($(package)_fetched) >/dev/null 2>/dev/null || \\\n+    ( if test -f $($(package)_all_sources); then echo \"Checksum missing or mismatched for $(package) source. Forcing re-download.\"; fi; \\\n+      rm -f $($(package)_all_sources) $($(1)_fetched))\n+endef\n+\n+check-packages:\n+\t@$(foreach package,$(all_packages),$(call check_or_remove_cached,$(package));)\n+check-sources:\n+\t@$(foreach package,$(all_packages),$(call check_or_remove_sources,$(package));)\n+\n+$(host_prefix)/share/config.site: check-packages\n+\n+check-packages: check-sources\n+\n+install: check-packages $(host_prefix)/share/config.site\n+\n+\n+download-one: check-sources $(all_sources)\n+\n download-osx:\n \t@$(MAKE) -s HOST=x86_64-apple-darwin11 download-one\n download-linux:\n \t@$(MAKE) -s HOST=x86_64-unknown-linux-gnu download-one\n download-win:\n \t@$(MAKE) -s HOST=x86_64-w64-mingw32 download-one\n download: download-osx download-linux download-win\n-.PHONY: install cached download-one download-osx download-linux download-win download\n+\n+.PHONY: install cached download-one download-osx download-linux download-win download check-packages check-sources"
      },
      {
        "sha": "2dc0b9e47e0622f578dd9c5ea93d3777825ff40a",
        "filename": "depends/README.md",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,56 @@\n+### Usage\n+\n+To build dependencies for the current arch+OS:\n+\n+    make\n+\n+To build for another arch/OS:\n+\n+    make HOST=host-platform-triplet\n+\n+For example:\n+\n+    make HOST=x86_64-w64-mingw32 -j4\n+\n+A prefix will be generated that's suitable for plugging into Bitcoin's\n+configure. In the above example, a dir named i686-w64-mingw32 will be\n+created. To use it for Bitcoin:\n+\n+    ./configure --prefix=`pwd`/depends/x86_64-w64-mingw32\n+\n+Common `host-platform-triplets` for cross compilation are:\n+\n+- `i686-w64-mingw32` for Win32\n+- `x86_64-w64-mingw32` for Win64\n+- `x86_64-apple-darwin11` for MacOSX\n+- `arm-linux-gnueabihf` for Linux ARM\n+\n+No other options are needed, the paths are automatically configured.\n+\n+Dependency Options:\n+The following can be set when running make: make FOO=bar\n+\n+    SOURCES_PATH: downloaded sources will be placed here\n+    BASE_CACHE: built packages will be placed here\n+    SDK_PATH: Path where sdk's can be found (used by OSX)\n+    FALLBACK_DOWNLOAD_PATH: If a source file can't be fetched, try here before giving up\n+    NO_QT: Don't download/build/cache qt and its dependencies\n+    NO_WALLET: Don't download/build/cache libs needed to enable the wallet\n+    NO_UPNP: Don't download/build/cache packages needed for enabling upnp\n+    DEBUG: disable some optimizations and enable more runtime checking\n+\n+If some packages are not built, for example `make NO_WALLET=1`, the appropriate\n+options will be passed to bitcoin's configure. In this case, `--disable-wallet`.\n+\n+Additional targets:\n+\n+    download: run 'make download' to fetch all sources without building them\n+    download-osx: run 'make download-osx' to fetch all sources needed for osx builds\n+    download-win: run 'make download-win' to fetch all sources needed for win builds\n+    download-linux: run 'make download-linux' to fetch all sources needed for linux builds\n+\n+### Other documentation\n+\n+- [description.md](description.md): General description of the depends system\n+- [packages.md](packages.md): Steps for adding packages\n+"
      },
      {
        "sha": "f5aa5314a1f3217231c2c3da832652083f89f627",
        "filename": "depends/README.usage",
        "status": "removed",
        "additions": 0,
        "deletions": 35,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/depends/README.usage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/depends/README.usage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/README.usage?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1,35 +0,0 @@\n-To build dependencies for the current arch+OS:\n-    make\n-To build for another arch/OS:\n-  make HOST=host-platform-triplet && make HOST=host-platform-triplet\n-  (For example: make HOST=i686-w64-mingw32 -j4)\n-\n-A prefix will be generated that's suitable for plugging into Bitcoin's\n-configure. In the above example, a dir named i686-w64-mingw32 will be\n-created. To use it for Bitcoin:\n-\n-./configure --prefix=`pwd`/depends/i686-w64-mingw32\n-\n-No other options are needed, the paths are automatically configured.\n-\n-Dependency Options:\n-The following can be set when running make: make FOO=bar\n-\n-SOURCES_PATH: downloaded sources will be placed here\n-BASE_CACHE: built packages will be placed here\n-SDK_PATH: Path where sdk's can be found (used by OSX)\n-FALLBACK_DOWNLOAD_PATH: If a source file can't be fetched, try here before giving up\n-NO_QT: Don't download/build/cache qt and its dependencies\n-NO_WALLET: Don't download/build/cache libs needed to enable the wallet\n-NO_UPNP: Don't download/build/cache packages needed for enabling upnp\n-DEBUG: disable some optimizations and enable more runtime checking\n-USE_LINUX_STATIC_QT5: Build a static qt5 rather than shared qt4. Linux only.\n-\n-If some packages are not built, for example 'make NO_WALLET=1', the appropriate\n-options will be passed to bitcoin's configure. In this case, --disable-wallet.\n-\n-Additional targets:\n-download: run 'make download' to fetch all sources without building them\n-download-osx: run 'make download-osx' to fetch all sources needed for osx builds\n-download-win: run 'make download-win' to fetch all sources needed for win builds\n-download-linux: run 'make download-linux' to fetch all sources needed for linux builds"
      },
      {
        "sha": "f7eb141e75a921f7b87b97983ac1bd8949995716",
        "filename": "depends/config.guess",
        "status": "modified",
        "additions": 29,
        "deletions": 11,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/config.guess",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/config.guess",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.guess?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,8 +1,8 @@\n #! /bin/sh\n # Attempt to guess a canonical system name.\n-#   Copyright 1992-2014 Free Software Foundation, Inc.\n+#   Copyright 1992-2015 Free Software Foundation, Inc.\n \n-timestamp='2014-03-23'\n+timestamp='2015-03-04'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -24,12 +24,12 @@ timestamp='2014-03-23'\n # program.  This Exception is an additional permission under section 7\n # of the GNU General Public License, version 3 (\"GPLv3\").\n #\n-# Originally written by Per Bothner.\n+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.\n #\n # You can get the latest version of this script from:\n # http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\n #\n-# Please send patches with a ChangeLog entry to config-patches@gnu.org.\n+# Please send patches to <config-patches@gnu.org>.\n \n \n me=`echo \"$0\" | sed -e 's,.*/,,'`\n@@ -50,7 +50,7 @@ version=\"\\\n GNU config.guess ($timestamp)\n \n Originally written by Per Bothner.\n-Copyright 1992-2014 Free Software Foundation, Inc.\n+Copyright 1992-2015 Free Software Foundation, Inc.\n \n This is free software; see the source for copying conditions.  There is NO\n warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n@@ -168,20 +168,27 @@ case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n \t# Note: NetBSD doesn't particularly care about the vendor\n \t# portion of the name.  We always set it to \"unknown\".\n \tsysctl=\"sysctl -n hw.machine_arch\"\n-\tUNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \\\n-\t    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`\n+\tUNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \\\n+\t    /sbin/$sysctl 2>/dev/null || \\\n+\t    /usr/sbin/$sysctl 2>/dev/null || \\\n+\t    echo unknown)`\n \tcase \"${UNAME_MACHINE_ARCH}\" in\n \t    armeb) machine=armeb-unknown ;;\n \t    arm*) machine=arm-unknown ;;\n \t    sh3el) machine=shl-unknown ;;\n \t    sh3eb) machine=sh-unknown ;;\n \t    sh5el) machine=sh5le-unknown ;;\n+\t    earmv*)\n+\t\tarch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\\(armv[0-9]\\).*$,\\1,'`\n+\t\tendian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\\(eb\\)$,\\1,p'`\n+\t\tmachine=${arch}${endian}-unknown\n+\t\t;;\n \t    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;\n \tesac\n \t# The Operating System including object format, if it has switched\n \t# to ELF recently, or will in the future.\n \tcase \"${UNAME_MACHINE_ARCH}\" in\n-\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n+\t    arm*|earm*|i386|m68k|ns32k|sh3*|sparc|vax)\n \t\teval $set_cc_for_build\n \t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n \t\t\t| grep -q __ELF__\n@@ -197,6 +204,13 @@ case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n \t\tos=netbsd\n \t\t;;\n \tesac\n+\t# Determine ABI tags.\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    earm*)\n+\t\texpr='s/^earmv[0-9]/-eabi/;s/eb$//'\n+\t\tabi=`echo ${UNAME_MACHINE_ARCH} | sed -e \"$expr\"`\n+\t\t;;\n+\tesac\n \t# The OS release\n \t# Debian GNU/NetBSD machines have a different userland, and\n \t# thus, need a distinct triplet. However, they do not need\n@@ -213,7 +227,7 @@ case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n \t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n \t# contains redundant information, the shorter form:\n \t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n-\techo \"${machine}-${os}${release}\"\n+\techo \"${machine}-${os}${release}${abi}\"\n \texit ;;\n     *:Bitrig:*:*)\n \tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n@@ -579,8 +593,9 @@ EOF\n \telse\n \t\tIBM_ARCH=powerpc\n \tfi\n-\tif [ -x /usr/bin/oslevel ] ; then\n-\t\tIBM_REV=`/usr/bin/oslevel`\n+\tif [ -x /usr/bin/lslpp ] ; then\n+\t\tIBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |\n+\t\t\t   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`\n \telse\n \t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n \tfi\n@@ -932,6 +947,9 @@ EOF\n     crisv32:Linux:*:*)\n \techo ${UNAME_MACHINE}-axis-linux-${LIBC}\n \texit ;;\n+    e2k:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n     frv:Linux:*:*)\n \techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n \texit ;;"
      },
      {
        "sha": "8f1229c6f7dd1c177c4747b8637125803c155707",
        "filename": "depends/config.sub",
        "status": "modified",
        "additions": 26,
        "deletions": 10,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/config.sub",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/config.sub",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.sub?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,8 +1,8 @@\n #! /bin/sh\n # Configuration validation subroutine script.\n-#   Copyright 1992-2014 Free Software Foundation, Inc.\n+#   Copyright 1992-2015 Free Software Foundation, Inc.\n \n-timestamp='2014-05-01'\n+timestamp='2015-03-08'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -25,7 +25,7 @@ timestamp='2014-05-01'\n # of the GNU General Public License, version 3 (\"GPLv3\").\n \n \n-# Please send patches with a ChangeLog entry to config-patches@gnu.org.\n+# Please send patches to <config-patches@gnu.org>.\n #\n # Configuration subroutine to validate and canonicalize a configuration type.\n # Supply the specified configuration type as an argument.\n@@ -68,7 +68,7 @@ Report bugs and patches to <config-patches@gnu.org>.\"\n version=\"\\\n GNU config.sub ($timestamp)\n \n-Copyright 1992-2014 Free Software Foundation, Inc.\n+Copyright 1992-2015 Free Software Foundation, Inc.\n \n This is free software; see the source for copying conditions.  There is NO\n warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n@@ -117,7 +117,7 @@ maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n case $maybe_os in\n   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \\\n   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \\\n-  knetbsd*-gnu* | netbsd*-gnu* | \\\n+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \\\n   kopensolaris*-gnu* | \\\n   storm-chaos* | os2-emx* | rtmk-nova*)\n     os=-$maybe_os\n@@ -259,8 +259,8 @@ case $basic_machine in\n \t| bfin \\\n \t| c4x | c8051 | clipper \\\n \t| d10v | d30v | dlx | dsp16xx \\\n-\t| epiphany \\\n-\t| fido | fr30 | frv \\\n+\t| e2k | epiphany \\\n+\t| fido | fr30 | frv | ft32 \\\n \t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n \t| hexagon \\\n \t| i370 | i860 | i960 | ia64 \\\n@@ -302,6 +302,7 @@ case $basic_machine in\n \t| pdp10 | pdp11 | pj | pjl \\\n \t| powerpc | powerpc64 | powerpc64le | powerpcle \\\n \t| pyramid \\\n+\t| riscv32 | riscv64 \\\n \t| rl78 | rx \\\n \t| score \\\n \t| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \\\n@@ -312,6 +313,7 @@ case $basic_machine in\n \t| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \\\n \t| ubicom32 \\\n \t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n+\t| visium \\\n \t| we32k \\\n \t| x86 | xc16x | xstormy16 | xtensa \\\n \t| z8k | z80)\n@@ -326,6 +328,9 @@ case $basic_machine in\n \tc6x)\n \t\tbasic_machine=tic6x-unknown\n \t\t;;\n+\tleon|leon[3-9])\n+\t\tbasic_machine=sparc-$basic_machine\n+\t\t;;\n \tm6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)\n \t\tbasic_machine=$basic_machine-unknown\n \t\tos=-none\n@@ -376,7 +381,7 @@ case $basic_machine in\n \t| c[123]* | c30-* | [cjt]90-* | c4x-* \\\n \t| c8051-* | clipper-* | craynv-* | cydra-* \\\n \t| d10v-* | d30v-* | dlx-* \\\n-\t| elxsi-* \\\n+\t| e2k-* | elxsi-* \\\n \t| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \\\n \t| h8300-* | h8500-* \\\n \t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n@@ -436,6 +441,7 @@ case $basic_machine in\n \t| ubicom32-* \\\n \t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n \t| vax-* \\\n+\t| visium-* \\\n \t| we32k-* \\\n \t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n \t| xstormy16-* | xtensa*-* \\\n@@ -512,6 +518,9 @@ case $basic_machine in\n \t\tbasic_machine=i386-pc\n \t\tos=-aros\n \t\t;;\n+        asmjs)\n+\t\tbasic_machine=asmjs-unknown\n+\t\t;;\n \taux)\n \t\tbasic_machine=m68k-apple\n \t\tos=-aux\n@@ -773,6 +782,9 @@ case $basic_machine in\n \t\tbasic_machine=m68k-isi\n \t\tos=-sysv\n \t\t;;\n+\tleon-*|leon[3-9]-*)\n+\t\tbasic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`\n+\t\t;;\n \tm68knommu)\n \t\tbasic_machine=m68k-unknown\n \t\tos=-linux\n@@ -828,6 +840,10 @@ case $basic_machine in\n \t\tbasic_machine=powerpc-unknown\n \t\tos=-morphos\n \t\t;;\n+\tmoxiebox)\n+\t\tbasic_machine=moxie-unknown\n+\t\tos=-moxiebox\n+\t\t;;\n \tmsdos)\n \t\tbasic_machine=i386-pc\n \t\tos=-msdos\n@@ -1360,7 +1376,7 @@ case $os in\n \t      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \\\n \t      | -sym* | -kopensolaris* | -plan9* \\\n \t      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \\\n-\t      | -aos* | -aros* \\\n+\t      | -aos* | -aros* | -cloudabi* \\\n \t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n \t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n \t      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \\\n@@ -1373,7 +1389,7 @@ case $os in\n \t      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n \t      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \\\n \t      | -linux-newlib* | -linux-musl* | -linux-uclibc* \\\n-\t      | -uxpv* | -beos* | -mpeix* | -udk* \\\n+\t      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \\\n \t      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \\\n \t      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \\\n \t      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \\"
      },
      {
        "sha": "74f9ef3f205ec0e12f6ac9e75f03da81dd7d96e7",
        "filename": "depends/description.md",
        "status": "renamed",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/description.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/description.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/description.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,28 +1,26 @@\n-This is a system of building and caching dependencies necessary for building\n-Bitcoin.\n-\n+This is a system of building and caching dependencies necessary for building Bitcoin. \n There are several features that make it different from most similar systems:\n \n-- It is designed to be builder and host agnostic\n+### It is designed to be builder and host agnostic\n \n In theory, binaries for any target OS/architecture can be created, from a\n builder running any OS/architecture. In practice, build-side tools must be\n-specified when the defaults don't fit, and packages must be ammended to work\n+specified when the defaults don't fit, and packages must be amended to work\n on new hosts. For now, a build architecture of x86_64 is assumed, either on\n Linux or OSX.\n \n-- No reliance on timestamps\n+### No reliance on timestamps\n \n File presence is used to determine what needs to be built. This makes the\n results distributable and easily digestable by automated builders.\n \n-- Each build only has its specified dependencies available at build-time.\n+### Each build only has its specified dependencies available at build-time.\n \n For each build, the sysroot is wiped and the (recursive) dependencies are\n installed. This makes each build deterministic, since there will never be any\n unknown files available to cause side-effects.\n \n-- Each package is cached and only rebuilt as needed.\n+### Each package is cached and only rebuilt as needed.\n \n Before building, a unique build-id is generated for each package. This id\n consists of a hash of all files used to build the package (Makefiles, packages,\n@@ -32,7 +30,7 @@ any other package that depends on it. If any of the main makefiles (Makefile,\n funcs.mk, etc) are changed, all packages will be rebuilt. After building, the\n results are cached into a tarball that can be re-used and distributed.\n \n-- Package build results are (relatively) deterministic.\n+### Package build results are (relatively) deterministic.\n \n Each package is configured and patched so that it will yield the same\n build-results with each consequent build, within a reasonable set of\n@@ -41,13 +39,13 @@ beyond the scope of this system. Additionally, the toolchain itself must be\n capable of deterministic results. When revisions are properly bumped, a cached\n build should represent an exact single payload.\n \n-- Sources are fetched and verified automatically\n+### Sources are fetched and verified automatically\n \n Each package must define its source location and checksum. The build will fail\n if the fetched source does not match. Sources may be pre-seeded and/or cached\n as desired.\n \n-- Self-cleaning\n+### Self-cleaning\n \n Build and staging dirs are wiped after use, and any previous version of a\n cached result is removed following a successful build. Automated builders",
        "previous_filename": "depends/README"
      },
      {
        "sha": "050a9b132137e5aa0a24ff3448abadbe0733dc62",
        "filename": "depends/funcs.mk",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/funcs.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/funcs.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/funcs.mk?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -53,12 +53,14 @@ $(1)_staging_prefix_dir:=$$($(1)_staging_dir)$($($(1)_type)_prefix)\n $(1)_extract_dir:=$(base_build_dir)/$(host)/$(1)/$($(1)_version)-$($(1)_build_id)\n $(1)_download_dir:=$(base_download_dir)/$(1)-$($(1)_version)\n $(1)_build_dir:=$$($(1)_extract_dir)/$$($(1)_build_subdir)\n+$(1)_cached_checksum:=$(BASE_CACHE)/$(host)/$(1)/$(1)-$($(1)_version)-$($(1)_build_id).tar.gz.hash\n $(1)_patch_dir:=$(base_build_dir)/$(host)/$(1)/$($(1)_version)-$($(1)_build_id)/.patches-$($(1)_build_id)\n $(1)_prefixbin:=$($($(1)_type)_prefix)/bin/\n $(1)_cached:=$(BASE_CACHE)/$(host)/$(1)/$(1)-$($(1)_version)-$($(1)_build_id).tar.gz\n+$(1)_all_sources=$($(1)_file_name) $($(1)_extra_sources)\n \n #stamps\n-$(1)_fetched=$$($(1)_source_dir)/download-stamps/.stamp_fetched-$(1)-$($(1)_file_name)\n+$(1)_fetched=$(SOURCES_PATH)/download-stamps/.stamp_fetched-$(1)-$($(1)_file_name).hash\n $(1)_extracted=$$($(1)_extract_dir)/.stamp_extracted\n $(1)_preprocessed=$$($(1)_extract_dir)/.stamp_preprocessed\n $(1)_cleaned=$$($(1)_extract_dir)/.stamp_cleaned\n@@ -154,7 +156,10 @@ endef\n define int_add_cmds\n $($(1)_fetched):\n \t$(AT)mkdir -p $$(@D) $(SOURCES_PATH)\n+\t$(AT)rm -f $$@\n+\t$(AT)touch $$@\n \t$(AT)cd $$(@D); $(call $(1)_fetch_cmds,$(1))\n+\t$(AT)cd $($(1)_source_dir); $(foreach source,$($(1)_all_sources),$(build_SHA256SUM) $(source) >> $$(@);)\n \t$(AT)touch $$@\n $($(1)_extracted): | $($(1)_fetched)\n \t$(AT)echo Extracting $(1)...\n@@ -195,17 +200,19 @@ $($(1)_cached): | $($(1)_dependencies) $($(1)_postprocessed)\n \t$(AT)rm -rf $$(@D) && mkdir -p $$(@D)\n \t$(AT)mv $$($(1)_staging_dir)/$$(@F) $$(@)\n \t$(AT)rm -rf $($(1)_staging_dir)\n+$($(1)_cached_checksum): $($(1)_cached)\n+\t$(AT)cd $$(@D); $(build_SHA256SUM) $$(<F) > $$(@)\n \n .PHONY: $(1)\n-$(1): | $($(1)_cached)\n-.SECONDARY: $($(1)_postprocessed) $($(1)_staged) $($(1)_built) $($(1)_configured) $($(1)_preprocessed) $($(1)_extracted) $($(1)_fetched)\n+$(1): | $($(1)_cached_checksum)\n+.SECONDARY: $($(1)_cached) $($(1)_postprocessed) $($(1)_staged) $($(1)_built) $($(1)_configured) $($(1)_preprocessed) $($(1)_extracted) $($(1)_fetched)\n \n endef\n \n # These functions create the build targets for each package. They must be\n # broken down into small steps so that each part is done for all packages\n # before moving on to the next step. Otherwise, a package's info\n-# (build-id for example) would only be avilable to another package if it\n+# (build-id for example) would only be available to another package if it\n # happened to be computed already.\n \n #set the type for host/build packages."
      },
      {
        "sha": "7c80362509e989e975e499e0242009e7e098ddf4",
        "filename": "depends/packages.md",
        "status": "renamed",
        "additions": 74,
        "deletions": 55,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -4,119 +4,137 @@ variables, and defining build commands.\n The package \"mylib\" will be used here as an example\n \n General tips:\n-mylib_foo is written as $(package)_foo in order to make recipes more similar.\n+- mylib_foo is written as $(package)_foo in order to make recipes more similar.\n \n-Identifiers:\n+## Identifiers\n Each package is required to define at least these variables:\n-  $(package)_version:\n+\n+    $(package)_version:\n     Version of the upstream library or program. If there is no version, a\n     placeholder such as 1.0 can be used.\n-  $(package)_download_path:\n+\n+    $(package)_download_path:\n     Location of the upstream source, without the file-name. Usually http or\n     ftp.\n-  $(package)_file_name:\n+\n+    $(package)_file_name:\n     The upstream source filename available at the download path.\n-  $(package)_sha256_hash:\n+\n+    $(package)_sha256_hash:\n     The sha256 hash of the upstream file\n \n These variables are optional:\n-  $(package)_build_subdir:\n+\n+    $(package)_build_subdir:\n     cd to this dir before running configure/build/stage commands.\n-  $(package)_download_file:\n+    \n+    $(package)_download_file:\n     The file-name of the upstream source if it differs from how it should be\n     stored locally. This can be used to avoid storing file-names with strange\n     characters.\n-  $(package)_dependencies:\n+    \n+    $(package)_dependencies:\n     Names of any other packages that this one depends on.\n-  $(package)_patches:\n+    \n+    $(package)_patches:\n     Filenames of any patches needed to build the package\n \n+    $(package)_extra_sources:\n+    Any extra files that will be fetched via $(package)_fetch_cmds. These are\n+    specified so that they can be fetched and verified via 'make download'.\n+\n \n-Build Variables:\n+## Build Variables:\n After defining the main identifiers, build variables may be added or customized\n before running the build commands. They should be added to a function called\n $(package)_set_vars. For example:\n \n-define $(package)_set_vars\n-...\n-endef\n+    define $(package)_set_vars\n+    ...\n+    endef\n \n Most variables can be prefixed with the host, architecture, or both, to make\n the modifications specific to that case. For example:\n \n-  Universal:         $(package)_cc=gcc\n-  Linux only:        $(package)_linux_cc=gcc\n-  x86_64 only:       $(package)_x86_64_cc = gcc\n-  x86_64 linux only: $(package)_x86_64_linux_cc = gcc\n+    Universal:     $(package)_cc=gcc\n+    Linux only:    $(package)_linux_cc=gcc\n+    x86_64 only:       $(package)_x86_64_cc = gcc\n+    x86_64 linux only: $(package)_x86_64_linux_cc = gcc\n \n These variables may be set to override or append their default values.\n-  $(package)_cc\n-  $(package)_cxx\n-  $(package)_objc\n-  $(package)_objcxx\n-  $(package)_ar\n-  $(package)_ranlib\n-  $(package)_libtool\n-  $(package)_nm\n-  $(package)_cflags\n-  $(package)_cxxflags\n-  $(package)_ldflags\n-  $(package)_cppflags\n-  $(package)_config_env\n-  $(package)_build_env\n-  $(package)_stage_env\n-  $(package)_build_opts\n-  $(package)_config_opts\n+\n+    $(package)_cc\n+    $(package)_cxx\n+    $(package)_objc\n+    $(package)_objcxx\n+    $(package)_ar\n+    $(package)_ranlib\n+    $(package)_libtool\n+    $(package)_nm\n+    $(package)_cflags\n+    $(package)_cxxflags\n+    $(package)_ldflags\n+    $(package)_cppflags\n+    $(package)_config_env\n+    $(package)_build_env\n+    $(package)_stage_env\n+    $(package)_build_opts\n+    $(package)_config_opts\n \n The *_env variables are used to add environment variables to the respective\n commands.\n \n Many variables respect a debug/release suffix as well, in order to use them for\n only the appropriate build config. For example:\n-  $(package)_cflags_release = -O3\n-  $(package)_cflags_i686_debug = -g\n-  $(package)_config_opts_release = --disable-debug\n+\n+    $(package)_cflags_release = -O3\n+    $(package)_cflags_i686_debug = -g\n+    $(package)_config_opts_release = --disable-debug\n \n These will be used in addition to the options that do not specify\n debug/release. All builds are considered to be release unless DEBUG=1 is set by\n-the user.\n+the user. Other variables may be defined as needed.\n \n-Other variables may be defined as needed.\n-\n-Build commands:\n+## Build commands:\n \n   For each build, a unique build dir and staging dir are created. For example,\n-  work/build/mylib/1.0-1adac830f6e and work/staging/mylib/1.0-1adac830f6e.\n+  `work/build/mylib/1.0-1adac830f6e` and `work/staging/mylib/1.0-1adac830f6e`.\n \n   The following build commands are available for each recipe:\n \n-  $(package)_fetch_cmds:\n+    $(package)_fetch_cmds:\n     Runs from: build dir\n     Fetch the source file. If undefined, it will be fetched and verified\n     against its hash.\n-  $(package)_extract_cmds:\n+\n+    $(package)_extract_cmds:\n     Runs from: build dir\n     Verify the source file against its hash and extract it. If undefined, the\n     source is assumed to be a tarball.\n-  $(package)_preprocess_cmds:\n+\n+    $(package)_preprocess_cmds:\n     Runs from: build dir/$(package)_build_subdir\n     Preprocess the source as necessary. If undefined, does nothing.\n-  $(package)_config_cmds:\n+\n+    $(package)_config_cmds:\n     Runs from: build dir/$(package)_build_subdir\n     Configure the source. If undefined, does nothing.\n-  $(package)_build_cmds:\n+\n+    $(package)_build_cmds:\n     Runs from: build dir/$(package)_build_subdir\n     Build the source. If undefined, does nothing.\n-  $(package)_stage_cmds:\n+\n+    $(package)_stage_cmds:\n     Runs from: build dir/$(package)_build_subdir\n     Stage the build results. If undefined, does nothing.\n \n   The following variables are available for each recipe:\n-  $(1)_staging_dir: package's destination sysroot path\n-  $(1)_staging_prefix_dir: prefix path inside of the package's staging dir\n-  $(1)_extract_dir: path to the package's extracted sources\n-  $(1)_build_dir: path where configure/build/stage commands will be run\n-  $(1)_patch_dir: path where the package's patches (if any) are found\n+    \n+    $(1)_staging_dir: package's destination sysroot path\n+    $(1)_staging_prefix_dir: prefix path inside of the package's staging dir\n+    $(1)_extract_dir: path to the package's extracted sources\n+    $(1)_build_dir: path where configure/build/stage commands will be run\n+    $(1)_patch_dir: path where the package's patches (if any) are found\n \n Notes on build commands:\n \n@@ -125,4 +143,5 @@ configure step to (usually) correctly configure automatically. Any\n $($(package)_config_opts) will be appended.\n \n Most autotools projects can be properly staged using:\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n+\n+    $(MAKE) DESTDIR=$($(package)_staging_dir) install",
        "previous_filename": "depends/README.packages"
      },
      {
        "sha": "28f2bd6f25343de809c9b2c568bd88b778bb26ec",
        "filename": "depends/packages/libxcb.mk",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages/libxcb.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages/libxcb.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libxcb.mk?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -13,8 +13,13 @@ define $(package)_preprocess_cmds\n   sed \"s/pthread-stubs//\" -i configure\n endef\n \n+# Don't install xcb headers to the default path in order to work around a qt\n+# build issue: https://bugreports.qt.io/browse/QTBUG-34748\n+# When using qt's internal libxcb, it may end up finding the real headers in\n+# depends staging. Use a non-default path to avoid that.\n+\n define $(package)_config_cmds\n-  $($(package)_autoconf)\n+  $($(package)_autoconf) --includedir=$(host_prefix)/include/xcb-shared\n endef\n \n define $(package)_build_cmds"
      },
      {
        "sha": "1c1bcf199a0bd20fcf3c5f0cea83cedeb9cb6d04",
        "filename": "depends/packages/native_cctools.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages/native_cctools.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages/native_cctools.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_cctools.mk?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -9,6 +9,8 @@ $(package)_clang_download_path=http://llvm.org/releases/$($(package)_clang_versi\n $(package)_clang_download_file=clang+llvm-$($(package)_clang_version)-amd64-Ubuntu-12.04.2.tar.gz\n $(package)_clang_file_name=clang-llvm-$($(package)_clang_version)-amd64-Ubuntu-12.04.2.tar.gz\n $(package)_clang_sha256_hash=60d8f69f032d62ef61bf527857ebb933741ec3352d4d328c5516aa520662dab7\n+$(package)_extra_sources=$($(package)_clang_file_name)\n+\n define $(package)_fetch_cmds\n $(call fetch_file,$(package),$($(package)_download_path),$($(package)_download_file),$($(package)_file_name),$($(package)_sha256_hash)) && \\\n $(call fetch_file,$(package),$($(package)_clang_download_path),$($(package)_clang_download_file),$($(package)_clang_file_name),$($(package)_clang_sha256_hash))"
      },
      {
        "sha": "03908aba599ed82d375eb340f3837957dbcb5efe",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -4,15 +4,10 @@ native_packages := native_ccache native_comparisontool\n qt_native_packages = native_protobuf\n qt_packages = qrencode protobuf\n \n-qt46_linux_packages = qt46 expat dbus libxcb xcb_proto libXau xproto freetype libX11 xextproto libXext xtrans libICE libSM\n-qt5_linux_packages= qt expat dbus libxcb xcb_proto libXau xproto freetype fontconfig libX11 xextproto libXext xtrans\n-\n+qt_linux_packages= qt expat dbus libxcb xcb_proto libXau xproto freetype fontconfig libX11 xextproto libXext xtrans\n qt_darwin_packages=qt\n qt_mingw32_packages=qt\n \n-qt_linux_$(USE_LINUX_STATIC_QT5):=$(qt5_linux_packages)\n-qt_linux_:=$(qt46_linux_packages)\n-qt_linux_packages:=$(qt_linux_$(USE_LINUX_STATIC_QT5))\n \n wallet_packages=bdb\n "
      },
      {
        "sha": "3bdbba32a455474b845fac17d218be163a7c7690",
        "filename": "depends/patches/qt/fix-xcb-include-order.patch",
        "status": "modified",
        "additions": 29,
        "deletions": 19,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/patches/qt/fix-xcb-include-order.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/depends/patches/qt/fix-xcb-include-order.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix-xcb-include-order.patch?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,21 +1,31 @@\n---- old/qtbase/src/plugins/platforms/xcb/xcb-plugin.pro\t2014-07-30 18:17:27.384458441 -0400\n-+++ new/qtbase/src/plugins/platforms/xcb/xcb-plugin.pro\t2014-07-30 18:18:28.620459303 -0400\n-@@ -101,10 +101,6 @@\n-     }\n- }\n- \n--DEFINES += $$QMAKE_DEFINES_XCB\n--LIBS += $$QMAKE_LIBS_XCB\n+--- old/qtbase/src/plugins/platforms/xcb/xcb-plugin.pro 2015-03-17 02:06:42.705930685 +0000\n++++ new/qtbase/src/plugins/platforms/xcb/xcb-plugin.pro 2015-03-17 02:08:41.281926351 +0000\n+@@ -103,7 +103,6 @@\n+\n+ DEFINES += $$QMAKE_DEFINES_XCB\n+ LIBS += $$QMAKE_LIBS_XCB\n -QMAKE_CXXFLAGS += $$QMAKE_CFLAGS_XCB\n--\n+\n  CONFIG += qpa/genericunixfontdatabase\n- \n- contains(QT_CONFIG, dbus) {\n-@@ -141,3 +137,7 @@\n-         INCLUDEPATH += ../../../3rdparty/xkbcommon/xkbcommon/\n-     }\n- }\n-+\n-+DEFINES += $$QMAKE_DEFINES_XCB\n-+LIBS += $$QMAKE_LIBS_XCB\n-+INCLUDEPATH += $$QMAKE_CFLAGS_XCB\n+\n+@@ -118,7 +117,8 @@\n+ contains(QT_CONFIG, xcb-qt) {\n+     DEFINES += XCB_USE_RENDER\n+     XCB_DIR = ../../../3rdparty/xcb\n+-    INCLUDEPATH += $$XCB_DIR/include $$XCB_DIR/sysinclude\n++    QMAKE_CFLAGS += -I$$XCB_DIR/include -I$$XCB_DIR/sysinclude $$QMAKE_CFLAGS_XCB\n++    QMAKE_CXXFLAGS += -I$$XCB_DIR/include -I$$XCB_DIR/sysinclude $$QMAKE_CFLAGS_XCB\n+     LIBS += -lxcb -L$$OUT_PWD/xcb-static -lxcb-static\n+ } else {\n+     LIBS += -lxcb -lxcb-image -lxcb-icccm -lxcb-sync -lxcb-xfixes -lxcb-shm -lxcb-randr\n+--- old/qtbase/src/plugins/platforms/xcb/xcb-static/xcb-static.pro      2015-03-17 02:07:04.641929383 +0000\n++++ new/qtbase/src/plugins/platforms/xcb/xcb-static/xcb-static.pro      2015-03-17 02:10:15.485922059 +0000\n+@@ -8,7 +8,7 @@\n+\n+ XCB_DIR = ../../../../3rdparty/xcb\n+\n+-INCLUDEPATH += $$XCB_DIR/include $$XCB_DIR/include/xcb $$XCB_DIR/sysinclude\n++QMAKE_CFLAGS += -I$$XCB_DIR/include -I$$XCB_DIR/include/xcb -I$$XCB_DIR/sysinclude $$QMAKE_CFLAGS_XCB\n+\n+ # ignore compiler warnings in 3rdparty code\n+ QMAKE_CFLAGS_STATIC_LIB+=-w"
      },
      {
        "sha": "e3be27d706af986994e13811fcb1ec873b1ac1af",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -3,7 +3,7 @@ Bitcoin Core 0.10.99\n \n Setup\n ---------------------\n-[Bitcoin Core](http://bitcoin.org/en/download) is the original Bitcoin client and it builds the backbone of the network. However, it downloads and stores the entire history of Bitcoin transactions (which is currently several GBs); depending on the speed of your computer and network connection, the synchronization process can take anywhere from a few hours to a day or more. Thankfully you only have to do this once. If you would like the process to go faster you can [download the blockchain directly](bootstrap.md).\n+[Bitcoin Core](http://bitcoin.org/en/download) is the original Bitcoin client and it builds the backbone of the network. However, it downloads and stores the entire history of Bitcoin transactions (which is currently several GBs); depending on the speed of your computer and network connection, the synchronization process can take anywhere from a few hours to a day or more.\n \n Running\n ---------------------\n@@ -43,6 +43,7 @@ The following are developer notes on how to build Bitcoin on your native platfor\n \n - [OSX Build Notes](build-osx.md)\n - [Unix Build Notes](build-unix.md)\n+- [Gitian Building Guide](gitian-building.md)\n \n Development\n ---------------------\n@@ -54,7 +55,11 @@ The Bitcoin repo's [root README](https://github.com/bitcoin/bitcoin/blob/master/\n - [Release Process](release-process.md)\n - [Source Code Documentation (External Link)](https://dev.visucore.com/bitcoin/doxygen/)\n - [Translation Process](translation_process.md)\n+- [Translation Strings Policy](translation_strings_policy.md)\n - [Unit Tests](unit-tests.md)\n+- [Unauthenticated REST Interface](REST-interface.md)\n+- [BIPS](bips.md)\n+- [Dnsseed Policy](dnsseed-policy.md)\n \n ### Resources\n * Discuss on the [BitcoinTalk](https://bitcointalk.org/) forums, in the [Development & Technical Discussion board](https://bitcointalk.org/index.php?board=6.0)."
      },
      {
        "sha": "e8af46e0e49076f9ba986e5c29a788b6d022f6fb",
        "filename": "doc/README_osx.txt",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/README_osx.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/README_osx.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_osx.txt?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,6 +1,6 @@\n Deterministic OSX Dmg Notes.\n \n-Working OSX DMG's are created in Linux by combining a recent clang,\n+Working OSX DMGs are created in Linux by combining a recent clang,\n the Apple's binutils (ld, ar, etc), and DMG authoring tools.\n \n Apple uses clang extensively for development and has upstreamed the necessary\n@@ -58,7 +58,7 @@ libdmg-hfsplus project is used to compress it. There are several bugs in this\n tool and its maintainer has seemingly abandoned the project. It has been forked\n and is available (with fixes) here: https://github.com/theuni/libdmg-hfsplus .\n \n-The 'dmg' tool has the ability to create DMG's from scratch as well, but this\n+The 'dmg' tool has the ability to create DMGs from scratch as well, but this\n functionality is broken. Only the compression feature is currently used.\n Ideally, the creation could be fixed and genisoimage would no longer be necessary.\n "
      },
      {
        "sha": "0b718d664e32320c05fe002238281f89677369cf",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 62,
        "deletions": 5,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,13 +5,18 @@ The REST API can be enabled with the `-rest` option.\n \n Supported API\n -------------\n-`GET /rest/tx/TX-HASH.{bin|hex|json}`\n+\n+####Transactions\n+`GET /rest/tx/<TX-HASH>.<bin|hex|json>`\n \n Given a transaction hash,\n Returns a transaction, in binary, hex-encoded binary or JSON formats.\n \n-`GET /rest/block/BLOCK-HASH.{bin|hex|json}`\n-`GET /rest/block/notxdetails/BLOCK-HASH.{bin|hex|json}`\n+For full TX query capability, one must enable the transaction index via \"txindex=1\" command line / configuration option.\n+\n+####Blocks\n+`GET /rest/block/<BLOCK-HASH>.<bin|hex|json>`\n+`GET /rest/block/notxdetails/<BLOCK-HASH>.<bin|hex|json>`\n \n Given a block hash,\n Returns a block, in binary, hex-encoded binary or JSON formats.\n@@ -20,8 +25,60 @@ The HTTP request and response are both handled entirely in-memory, thus making m\n \n With the /notxdetails/ option JSON response will only contain the transaction hash instead of the complete transaction details. The option only affects the JSON response.\n \n-For full TX query capability, one must enable the transaction index via \"txindex=1\" command line / configuration option.\n+####Blockheaders\n+`GET /rest/headers/<COUNT>/<BLOCK-HASH>.<bin|hex>`\n+\n+Given a block hash,\n+Returns <COUNT> amount of blockheaders in upward direction.\n+\n+JSON is not supported.\n+\n+####Chaininfos\n+`GET /rest/chaininfo.json`\n+\n+Returns various state info regarding block chain processing.\n+Only supports JSON as output format.\n+* chain : (string) current network name as defined in BIP70 (main, test, regtest)\n+* blocks : (numeric) the current number of blocks processed in the server\n+* headers : (numeric) the current number of headers we have validated\n+* bestblockhash : (string) the hash of the currently best block\n+* difficulty : (numeric) the current difficulty\n+* verificationprogress : (numeric) estimate of verification progress [0..1]\n+* chainwork : (string) total amount of work in active chain, in hexadecimal\n+\n+####Query UTXO set\n+`GET /rest/getutxos.<bin|hex|json>`\n+\n+The getutxo command allows querying of the UTXO set given a set of outpoints.\n+See BIP64 for input and output serialisation:\n+https://github.com/bitcoin/bips/blob/master/bip-0064.mediawiki\n+\n+Example:\n+```\n+$ curl --data '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"b2cdfd7b89def827ff8af7cd9bff7627ff72e5e8b0f71210f92ea7a4000c5d75\",\"n\":0}]}' localhost:18332/rest/getutxos.json 2>/dev/null | json_pp\n+{\n+   \"chaintipHash\" : \"00000000fb01a7f3745a717f8caebee056c484e6e0bfe4a9591c235bb70506fb\",\n+   \"chainHeight\" : 325347,\n+   \"utxos\" : [\n+      {\n+         \"scriptPubKey\" : {\n+            \"addresses\" : [\n+               \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n+            ],\n+            \"type\" : \"pubkeyhash\",\n+            \"hex\" : \"76a9141c7cebb529b86a04c683dfa87be49de35bcf589e88ac\",\n+            \"reqSigs\" : 1,\n+            \"asm\" : \"OP_DUP OP_HASH160 1c7cebb529b86a04c683dfa87be49de35bcf589e OP_EQUALVERIFY OP_CHECKSIG\"\n+         },\n+         \"value\" : 8.8687,\n+         \"height\" : 2147483647,\n+         \"txvers\" : 1\n+      }\n+   ],\n+   \"bitmap\" : \"1\"\n+}\n+```\n \n Risks\n -------------\n-Running a webbrowser on the same node with a REST enabled bitcoind can be a risk. Accessing prepared XSS websites could read out tx/block data of your node by placing links like `<script src=\"http://127.0.0.1:1234/tx/json/1234567890\">` which might break the nodes privacy.\n\\ No newline at end of file\n+Running a webbrowser on the same node with a REST enabled bitcoind can be a risk. Accessing prepared XSS websites could read out tx/block data of your node by placing links like `<script src=\"http://127.0.0.1:8332/rest/tx/1234567890.json\">` which might break the nodes privacy."
      },
      {
        "sha": "ebba64a61a83be22995f6c0bb67a55288f7db6a3",
        "filename": "doc/assets-attribution.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/assets-attribution.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/assets-attribution.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/assets-attribution.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -22,6 +22,7 @@ The following is a list of assets used in the bitcoin source and their proper at\n     src/qt/res/icons/receive.png, src/qt/res/icons/remove.png,\n     src/qt/res/icons/send.png, src/qt/res/icons/synced.png,\n     src/qt/res/icons/transaction*.png, src/qt/res/icons/tx_output.png,\n+    src/qt/res/icons/warning.png\n \n Jonas Schnelli\n -----------------------"
      },
      {
        "sha": "90e98ed4197414d15cc9ada3917e3c10a86eba01",
        "filename": "doc/bips.md",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/bips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/bips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bips.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,18 @@\n+BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.10.0**):\n+\n+* [`BIP 11`](https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki): Multisig outputs are standard since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).\n+* [`BIP 13`](https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki): The address format for P2SH addresses has been implemented since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).\n+* [`BIP 14`](https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki): The subversion string is being used as User Agent since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).\n+* [`BIP 16`](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki): The pay-to-script-hash evaluation rules have been implemented since **v0.6.0**, and took effect on *April 1st 2012* ([PR #748](https://github.com/bitcoin/bitcoin/pull/748)).\n+* [`BIP 21`](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki): The URI format for Bitcoin payments has been implemented since **v0.6.0** ([PR #176](https://github.com/bitcoin/bitcoin/pull/176)).\n+* [`BIP 22`](https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki): The 'getblocktemplate' (GBT) RPC protocol for mining has been implemented since **v0.7.0** ([PR #936](https://github.com/bitcoin/bitcoin/pull/936)).\n+* [`BIP 23`](https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki): Some extensions to GBT have been implemented since **v0.10.0rc1**, including longpolling and block proposals ([PR #1816](https://github.com/bitcoin/bitcoin/pull/1816)).\n+* [`BIP 30`](https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki): The evaluation rules to forbid creating new transactions with the same txid as previous not-fully-spent transactions were implemented since **v0.6.0**, and the rule took effect on *March 15th 2012* ([PR #915](https://github.com/bitcoin/bitcoin/pull/915)).\n+* [`BIP 31`](https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki): The 'pong' protocol message (and the protocol version bump to 60001) has been implemented since **v0.6.1** ([PR #1081](https://github.com/bitcoin/bitcoin/pull/1081)).\n+* [`BIP 34`](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki): The rule that requires blocks to contain their height (number) in the coinbase input, and the introduction of version 2 blocks has been implemented since **v0.7.0**. The rule took effect for version 2 blocks as of *block 224413* (March 5th 2013), and version 1 blocks are no longer allowed since *block 227931* (March 25th 2013) ([PR #1526](https://github.com/bitcoin/bitcoin/pull/1526)).\n+* [`BIP 35`](https://github.com/bitcoin/bips/blob/master/bip-0035.mediawiki): The 'mempool' protocol message (and the protocol version bump to 60002) has been implemented since **v0.7.0** ([PR #1641](https://github.com/bitcoin/bitcoin/pull/1641)).\n+* [`BIP 37`](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki): The bloom filtering for transaction relaying, partial merkle trees for blocks, and the protocol version bump to 70001 (enabling low-bandwidth SPV clients) has been implemented since **v0.8.0** ([PR #1795](https://github.com/bitcoin/bitcoin/pull/1795)).\n+* [`BIP 42`](https://github.com/bitcoin/bips/blob/master/bip-0042.mediawiki): The bug that would have caused the subsidy schedule to resume after block 13440000 was fixed in **v0.9.2** ([PR #3842](https://github.com/bitcoin/bitcoin/pull/3842)).\n+* [`BIP 61`](https://github.com/bitcoin/bips/blob/master/bip-0061.mediawiki): The 'reject' protocol message (and the protocol version bump to 70002) was added in **v0.9.0** ([PR #3185](https://github.com/bitcoin/bitcoin/pull/3185)).\n+* [`BIP 66`](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki): The strict DER rules and associated version 3 blocks have been implemented since **v0.10.0** ([PR #5713](https://github.com/bitcoin/bitcoin/pull/5713)).\n+* [`BIP 70`](https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki) [`71`](https://github.com/bitcoin/bips/blob/master/bip-0071.mediawiki) [`72`](https://github.com/bitcoin/bips/blob/master/bip-0072.mediawiki): Payment Protocol support has been available in Bitcoin Core GUI since **v0.9.0** ([PR #5216](https://github.com/bitcoin/bitcoin/pull/5216))."
      },
      {
        "sha": "b84fd24b11d9270a5c3b23dfdb2b2e77ede2ecbd",
        "filename": "doc/bootstrap.md",
        "status": "removed",
        "additions": 0,
        "deletions": 56,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/bootstrap.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/bootstrap.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bootstrap.md?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1,56 +0,0 @@\n-### Bootstrap the Blockchain Synchronization\n-\n-Normally the Bitcoin client will download the transaction and network information, called the blockchain, from the network by syncing with the other clients. This process can take quite some time as the [Bitcoin blockchain](https://blockchain.info/charts/blocks-size) is growing bigger and bigger for each day. Luckily there is a safe and fast way to speed up this process. We'll show you how to bootstrap your blockchain to bring your client up to speed in just a few simple steps.\n-\n-### Requirements\n-\n-- A fresh install of the Bitcoin client software.\n-\n-### Download the blockchain via BitTorrent\n-\n-Jeff Garzik, Bitcoin Core developer, offers an [torrent file](https://bitcointalk.org/index.php?topic=145386.0) for bootstrapping purposes that is updated often. BitTorrent is a protocol that speeds up the downloading of large files by using the other clients in the network. Examples of free and safe open source clients are [Deluge](http://deluge-torrent.org/) or [qBittorrent](http://www.qbittorrent.org/). A guide to installing and configuring the torrent clients can be found [here](http://dev.deluge-torrent.org/wiki/UserGuide) for Deluge and [here](http://qbforums.shiki.hu/) for qBittorrent. A further in-depth tutorial on BitTorrent can be found [here](http://www.howtogeek.com/howto/31846/bittorrent-for-beginners-how-get-started-downloading-torrents/).\n-\n-With the client installed we'll proceed to download the blockchain torrent file. Use the following magnet link:\n-\n-\tmagnet:?xt=urn:btih:2d4e6c1f96c5d5fb260dff92aea4e600227f1aea&dn=bootstrap.dat&tr=udp://tracker.openbittorrent.com:80&tr=udp://tracker.publicbt.com:80&tr=udp://tracker.ccc.de:80&tr=udp://tracker.istole.it:80\n-\t\n- or go to [Jeff Garzik's topic](https://bitcointalk.org/index.php?topic=145386.0) for a signed magnet link. Alternatively you can use the [.torrent file](http://sourceforge.net/projects/bitcoin/files/Bitcoin/blockchain/bootstrap.dat.torrent/download) found on SourceForge.\n-     \n-![Fig1](img/bootstrap1.png)\n-\n-The download page should look like this, with a countdown to the download. If it does not work click the direct download link.\n-\n-The torrent client installed will recognize the download of the torrent file. Save the bootstrap.dat file to the folder you use for downloads. The image below shows the torrent download in qBittorrent, with current speed and ETA highlighted.\n-\n-![Fig2](img/bootstrap2.png)\n-\n-### Importing the blockchain\n-Exit the Bitcoin client software if you have it running. Be sure not to have an actively used wallet in use. We are going to copy the download of the blockchain to the Bitcoin client data directory. You should run the client software at least once so it can generate the data directory. Copy the downloaded bootstrap.dat file into the Bitcoin data folder.\n-\n-**For Windows users:**\n-Open explorer, and type into the address bar:\n-\n-\t%APPDATA%\\Bitcoin\n-    \n-This will open up the data folder. It should look like the image below. Copy over the bootstrap.dat from your download folder to this directory.\n-![Fig4](img/bootstrap4.png)\n-\n-**For OSX users:**\n-Open Finder by pressing Press [shift] + [cmd] + [g] and enter:\n-\n-\t~/Library/Application Support/Bitcoin/\n-    \n-**For Linux users:**\n-The directory is hidden in your User folder. Go to:\n-\n-\t~/.bitcoin/\n-    \n-### Importing the blockchain\n-Now start the Bitcoin client software. It should show \"Importing blocks from disk\" like the image below. \n-![Fig5](img/bootstrap5.png)\n-\n-Wait until the import finishes. The client will download the last days not covered by the import. Congratulations you have successfully imported the blockchain!\n-\n-### Is this safe?\n-\n-Yes, the above method is safe. The download contains only raw blockchain data and the client verifies this on import. Do not download the blockchain from unofficial sources, especially if they provide `*.rev` and `*.sst` files. These files are not verified and can contain malicious edits."
      },
      {
        "sha": "02adff06151df2278966925a0e4a0b52185c9bd8",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,6 +1,6 @@\n Mac OS X Build Instructions and Notes\n ====================================\n-This guide will show you how to build bitcoind(headless client) for OSX.\n+This guide will show you how to build bitcoind (headless client) for OSX.\n \n Notes\n -----\n@@ -100,7 +100,7 @@ Creating a release build\n ------------------------\n You can ignore this section if you are building `bitcoind` for your own use.\n \n-bitcoind/bitcoin-cli binaries are not included in the Bitcoin-Qt.app bundle.\n+bitcoind/bitcoin-cli binaries are not included in the Bitcoin-Core.app bundle.\n \n If you are building `bitcoind` or `Bitcoin-Qt` for others, your build machine should be set up\n as follows for maximum compatibility:\n@@ -111,7 +111,7 @@ All dependencies should be compiled with these flags:\n  -arch x86_64\n  -isysroot $(xcode-select --print-path)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.7.sdk\n \n-Once dependencies are compiled, see [doc/release-process.md](release-process.md) for how the Bitcoin-Qt.app\n+Once dependencies are compiled, see [doc/release-process.md](release-process.md) for how the Bitcoin-Core.app\n bundle is packaged and signed to create the .dmg disk image that is distributed.\n \n Running"
      },
      {
        "sha": "f70bf7f1febf9deec6e004bc16238d512f8ae87a",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -159,7 +159,7 @@ tar -xzvf db-4.8.30.NC.tar.gz\n \n # Build the library and install to our prefix\n cd db-4.8.30.NC/build_unix/\n-#  Note: Do a static build so that it can be embedded into the exectuable, instead of having to find a .so at runtime\n+#  Note: Do a static build so that it can be embedded into the executable, instead of having to find a .so at runtime\n ../dist/configure --enable-cxx --disable-shared --with-pic --prefix=$BDB_PREFIX\n make install\n \n@@ -195,12 +195,12 @@ Hardening enables the following features:\n \n * Position Independent Executable\n     Build position independent code to take advantage of Address Space Layout Randomization\n-    offered by some kernels. An attacker who is able to cause execution of code at an arbitrary\n-    memory location is thwarted if he doesn't know where anything useful is located.\n+    offered by some kernels. Attackers who can cause execution of code at an arbitrary memory\n+    location are thwarted if they don't know where anything useful is located.\n     The stack and heap are randomly located by default but this allows the code section to be\n     randomly located as well.\n \n-    On an Amd64 processor where a library was not compiled with -fPIC, this will cause an error\n+    On an AMD64 processor where a library was not compiled with -fPIC, this will cause an error\n     such as: \"relocation R_X86_64_32 against `......' can not be used when making a shared object;\"\n \n     To test that you have built PIE executable, install scanelf, part of paxutils, and use:"
      },
      {
        "sha": "8f7db31d596c953019523f924ffbc2e03c01ccd2",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -53,7 +53,7 @@ bool function(int arg1, const char *arg2)\n ```\n A complete list of `@xxx` commands can be found at http://www.stack.nl/~dimitri/doxygen/manual/commands.html.\n As Doxygen recognizes the comments by the delimiters (`/**` and `*/` in this case), you don't\n-*need* to provide any commands for a comment to be valid, just a description text is fine. \n+*need* to provide any commands for a comment to be valid; just a description text is fine.\n \n To describe a class use the same construct above the class definition:\n ```c++\n@@ -175,12 +175,12 @@ Threads\n Pull Request Terminology\n ------------------------\n \n-Concept ACK - Agree with the idea and overall direction, but haven't reviewed the code changes or tested them.\n+Concept ACK - Agree with the idea and overall direction, but have neither reviewed nor tested the code changes.\n \n utACK (untested ACK) - Reviewed and agree with the code changes but haven't actually tested them.\n \n Tested ACK - Reviewed the code changes and have verified the functionality or bug fix.\n \n ACK -  A loose ACK can be confusing. It's best to avoid them unless it's a documentation/comment only change in which case there is nothing to test/verify; therefore the tested/untested distinction is not there.\n \n-NACK - Disagree with the code changes/concept. Should be accompanied by an explanation. \n+NACK - Disagree with the code changes/concept. Should be accompanied by an explanation."
      },
      {
        "sha": "506e171153dceb3a197c55445c757f04a9bed856",
        "filename": "doc/dnsseed-policy.md",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/dnsseed-policy.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/dnsseed-policy.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dnsseed-policy.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,19 +7,17 @@ As such, DNS seeds must be run by entities which have some minimum\n level of trust within the Bitcoin community.\n \n Other implementations of Bitcoin software may also use the same\n-seeds and may be more exposed. In light of this exposure this\n-document establishes some basic expectations for the expectations\n-for the operation of dnsseeds.\n+seeds and may be more exposed. In light of this exposure, this \n+document establishes some basic expectations for operating dnsseeds.\n \n-0. A DNS seed operating organization or person is expected\n-to follow good host security practices and maintain control of\n-their serving infrastructure and not sell or transfer control of their\n-DNS seed. Any hosting services contracted by the operator are\n-equally expected to uphold these expectations.\n+0. A DNS seed operating organization or person is expected to follow good\n+host security practices, maintain control of applicable infrastructure,\n+and not sell or transfer control of the DNS seed. Any hosting services\n+contracted by the operator are equally expected to uphold these expectations.\n \n 1. The DNS seed results must consist exclusively of fairly selected and\n functioning Bitcoin nodes from the public network to the best of the\n-operators understanding and capability.\n+operator's understanding and capability.\n \n 2. For the avoidance of doubt, the results may be randomized but must not\n single-out any group of hosts to receive different results unless due to an\n@@ -29,7 +27,7 @@ urgent technical necessity and disclosed.\n \n 4. Any logging of DNS queries should be only that which is necessary\n for the operation of the service or urgent health of the Bitcoin\n-network and must not be retained longer than necessary or disclosed\n+network and must not be retained longer than necessary nor disclosed\n to any third party.\n \n 5. Information gathered as a result of the operators node-spidering"
      },
      {
        "sha": "1fa5b5f989ea63ca9f3adee4cc798888142785e2",
        "filename": "doc/gitian-building.md",
        "status": "modified",
        "additions": 21,
        "deletions": 23,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/gitian-building.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/gitian-building.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -24,7 +24,7 @@ Table of Contents\n - [Connecting to the VM](#connecting-to-the-vm)\n - [Setting up Debian for gitian building](#setting-up-debian-for-gitian-building)\n - [Installing gitian](#installing-gitian)\n-- [Setting up gitian images](#setting-up-gitian-images)\n+- [Setting up the gitian image](#setting-up-the-gitian-image)\n - [Getting and building the inputs](#getting-and-building-the-inputs)\n - [Building Bitcoin](#building-bitcoin)\n - [Building an alternative repository](#building-an-alternative-repository)\n@@ -74,11 +74,11 @@ In the VirtualBox GUI click \"Create\" and choose the following parameters in the\n - Disk size: at least 40GB; as low as 20GB *may* be possible, but better to err on the safe side \n - Push the `Create` button\n \n-Get the [Debian 7.4 net installer](http://ftp.at.debian.org/debian-jigdo/current/amd64/iso-cd/debian-7.4.0-amd64-netinst.iso) (a more recent minor version should also work, see also [Debian Network installation](https://www.debian.org/CD/netinst/)).\n+Get the [Debian 7.8 net installer](http://cdimage.debian.org/debian-cd/7.8.0/amd64/iso-cd/debian-7.8.0-amd64-netinst.iso) (a more recent minor version should also work, see also [Debian Network installation](https://www.debian.org/CD/netinst/)).\n This DVD image can be validated using a SHA256 hashing tool, for example on\n Unixy OSes by entering the following in a terminal:\n \n-    echo \"b712a141bc60269db217d3b3e456179bd6b181645f90e4aac9c42ed63de492e9  debian-7.4.0-amd64-netinst.iso\" | sha256sum -c\n+    echo \"e39c36d6adc0fd86c6edb0e03e22919086c883b37ca194d063b8e3e8f6ff6a3a  debian-7.8.0-amd64-netinst.iso\" | sha256sum -c\n     # (must return OK)\n \n After creating the VM, we need to configure it. \n@@ -87,7 +87,7 @@ After creating the VM, we need to configure it.\n \n ![](gitian-building/network_settings.png)\n \n-- Click `Advanced`, then `Port Forwarding`. We want to set up a port through where we can reach the VM to get files in and out.\n+- Click `Advanced`, then `Port Forwarding`. We want to set up a port through which we can reach the VM to get files in and out.\n - Create a new rule by clicking the plus icon.\n \n ![](gitian-building/port_forwarding_rules.png)\n@@ -109,9 +109,9 @@ Then start the VM. On the first launch you will be asked for a CD or DVD image.\n Installing Debian\n ------------------\n \n-In this section it will be explained how to install Debian on the newly created VM.\n+This section will explain how to install Debian on the newly created VM.\n \n-- Choose the non-graphical installer.  We do not need the graphical environment, it will only increase installation time and disk usage.\n+- Choose the non-graphical installer.  We do not need the graphical environment; it will only increase installation time and disk usage.\n \n ![](gitian-building/debian_install_1_boot_menu.png)\n \n@@ -144,7 +144,7 @@ and proceed, just press `Enter`. To select a different button, press `Tab`.\n \n ![](gitian-building/debian_install_9_user_password.png)\n \n-- The installer will set up the clock using a time server, this process should be automatic\n+- The installer will set up the clock using a time server; this process should be automatic\n - Set up the clock: choose a time zone (depends on the locale settings that you picked earlier; specifics don't matter)  \n \n ![](gitian-building/debian_install_10_configure_clock.png)\n@@ -277,24 +277,21 @@ cd ..\n \n **Note**: When sudo asks for a password, enter the password for the user *debian* not for *root*.\n \n-Clone the git repositories for bitcoin and gitian and then checkout the bitcoin version that you want to build.\n+Clone the git repositories for bitcoin and gitian.\n \n ```bash\n git clone https://github.com/devrandom/gitian-builder.git\n git clone https://github.com/bitcoin/bitcoin\n-cd bitcoin\n-git checkout v${VERSION}\n-cd ..\n ```\n \n-Setting up gitian images\n+Setting up the gitian image\n -------------------------\n \n-Gitian needs virtual images of the operating system to build in.\n-Currently this is Ubuntu Precise for x86_64.\n-These images will be copied and used every time that a build is started to\n+Gitian needs a virtual image of the operating system to build in.\n+Currently this is Ubuntu Precise x86_64.\n+This image will be copied and used every time that a build is started to\n make sure that the build is deterministic.\n-Creating the images will take a while, but only has to be done once.\n+Creating the image will take a while, but only has to be done once.\n \n Execute the following as user `debian`:\n \n@@ -303,7 +300,7 @@ cd gitian-builder\n bin/make-base-vm --lxc --arch amd64 --suite precise\n ```\n \n-There will be a lot of warnings printed during build of the images. These can be ignored.\n+There will be a lot of warnings printed during build of the image. These can be ignored.\n \n **Note**: When sudo asks for a password, enter the password for the user *debian* not for *root*.\n \n@@ -322,13 +319,14 @@ To build Bitcoin (for Linux, OSX and Windows) just follow the steps under 'perfo\n gitian builds' in [doc/release-process.md](release-process.md) in the bitcoin repository.\n \n This may take a long time as it also builds the dependencies needed for each descriptor.\n-These dependencies will be cached after a successful build to avoid rebuilding them when possible.\n+These dependencies will be cached after a successful build to avoid rebuilding them where possible.\n \n At any time you can check the package installation and build progress with\n \n ```bash\n tail -f var/install.log\n tail -f var/build.log\n+```\n \n Output from `gbuild` will look something like\n \n@@ -373,7 +371,7 @@ COMMIT=2014_03_windows_unicode_path\n Signing externally\n -------------------\n \n-If you want to do the PGP signing on another device that's also possible; just define `SIGNER` as mentioned\n+If you want to do the PGP signing on another device, that's also possible; just define `SIGNER` as mentioned\n and follow the steps in the build process as normal.\n \n     gpg: skipped \"laanwj\": secret key not available\n@@ -382,9 +380,9 @@ When you execute `gsign` you will get an error from GPG, which can be ignored. C\n in `gitian.sigs` to your signing machine and do\n \n ```bash\n-    gpg --detach-sign ${VERSION}-linux/${SIGNER}/bitcoin-build.assert\n-    gpg --detach-sign ${VERSION}-win/${SIGNER}/bitcoin-build.assert\n-    gpg --detach-sign ${VERSION}-osx/${SIGNER}/bitcoin-build.assert\n+    gpg --detach-sign ${VERSION}-linux/${SIGNER}/bitcoin-linux-build.assert\n+    gpg --detach-sign ${VERSION}-win/${SIGNER}/bitcoin-win-build.assert\n+    gpg --detach-sign ${VERSION}-osx-unsigned/${SIGNER}/bitcoin-osx-build.assert\n ```\n \n This will create the `.sig` files that can be committed together with the `.assert` files to assert your\n@@ -395,4 +393,4 @@ Uploading signatures\n \n After building and signing you can push your signatures (both the `.assert` and `.assert.sig` files) to the\n [bitcoin/gitian.sigs](https://github.com/bitcoin/gitian.sigs/) repository, or if that's not possible create a pull\n-request. You can also mail the files to me (laanwj@gmail.com) and I'll commit them.\n+request. You can also mail the files to Wladimir (laanwj@gmail.com) and he will commit them."
      },
      {
        "sha": "075930791b6e7adfa28671acf2768adaff400bb3",
        "filename": "doc/img/bootstrap1.png",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap1.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap1.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/img/bootstrap1.png?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6"
      },
      {
        "sha": "6461f818107f733391fc14443f07d6c9e4444358",
        "filename": "doc/img/bootstrap2.png",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap2.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap2.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/img/bootstrap2.png?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6"
      },
      {
        "sha": "ad69737922e6fe1e61990f9a00ed0494e90479af",
        "filename": "doc/img/bootstrap4.png",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap4.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap4.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/img/bootstrap4.png?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6"
      },
      {
        "sha": "d8d9baaf37acf58203b5c51857fb049ac894a310",
        "filename": "doc/img/bootstrap5.png",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap5.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/doc/img/bootstrap5.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/img/bootstrap5.png?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6"
      },
      {
        "sha": "1f206a6c02546580baa8fd6bdb053d9d8e4d7981",
        "filename": "doc/init.md",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/init.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/init.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/init.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,6 +8,7 @@ can be found in the contrib/init folder.\n     contrib/init/bitcoind.openrc:     OpenRC compatible SysV style init script\n     contrib/init/bitcoind.openrcconf: OpenRC conf.d file\n     contrib/init/bitcoind.conf:       Upstart service configuration file\n+    contrib/init/bitcoind.init:       CentOS compatible SysV style init script\n \n 1. Service User\n ---------------------------------\n@@ -49,6 +50,7 @@ Configuration file:  /etc/bitcoin/bitcoin.conf\n Data directory:      /var/lib/bitcoind\n PID file:            /var/run/bitcoind/bitcoind.pid (OpenRC and Upstart)\n                      /var/lib/bitcoind/bitcoind.pid (systemd)\n+Lock file:           /var/lock/subsys/bitcoind (CentOS)\n \n The configuration file, PID directory (if applicable) and data directory\n should all be owned by the bitcoin user and group.  It is advised for security\n@@ -61,7 +63,7 @@ can then be controlled by group membership.\n \n 4a) systemd\n \n-Installing this .service file consists on just copying it to\n+Installing this .service file consists of just copying it to\n /usr/lib/systemd/system directory, followed by the command\n \"systemctl daemon-reload\" in order to update running systemd configuration.\n \n@@ -81,7 +83,15 @@ Drop bitcoind.conf in /etc/init.  Test by running \"service bitcoind start\"\n it will automatically start on reboot.\n \n NOTE: This script is incompatible with CentOS 5 and Amazon Linux 2014 as they\n-use old versions of Upstart and do not supply the start-stop-daemon uitility.\n+use old versions of Upstart and do not supply the start-stop-daemon utility.\n+\n+4d) CentOS\n+\n+Copy bitcoind.init to /etc/init.d/bitcoind. Test by running \"service bitcoind start\".\n+\n+Using this script, you can adjust the path and flags to the bitcoind program by \n+setting the BITCOIND and FLAGS environment variables in the file \n+/etc/sysconfig/bitcoind. You can also use the DAEMONOPTS environment variable here.\n \n 5. Auto-respawn\n -----------------------------------"
      },
      {
        "sha": "acff1dc6b6c4691d601d706fd695d4bacb9713c0",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 300,
        "deletions": 0,
        "changes": 300,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,3 +1,303 @@\n (note: this is a temporary file, to be added-to by anybody, and moved to\n release-notes at release time)\n \n+Notable changes\n+===============\n+\n+Block file pruning\n+----------------------\n+\n+This release supports running a fully validating node without maintaining a copy \n+of the raw block and undo data on disk. To recap, there are four types of data \n+related to the blockchain in the bitcoin system: the raw blocks as received over \n+the network (blk???.dat), the undo data (rev???.dat), the block index and the \n+UTXO set (both LevelDB databases). The databases are built from the raw data.\n+\n+Block pruning allows Bitcoin Core to delete the raw block and undo data once \n+it's been validated and used to build the databases. At that point, the raw data \n+is used only to relay blocks to other nodes, to handle reorganizations, to look \n+up old transactions (if -txindex is enabled or via the RPC/REST interfaces), or \n+for rescanning the wallet. The block index continues to hold the metadata about \n+all blocks in the blockchain.\n+\n+The user specifies how much space to allot for block & undo files. The minimum \n+allowed is 550MB. Note that this is in addition to whatever is required for the \n+block index and UTXO databases. The minimum was chosen so that Bitcoin Core will \n+be able to maintain at least 288 blocks on disk (two days worth of blocks at 10 \n+minutes per block). In rare instances it is possible that the amount of space \n+used will exceed the pruning target in order to keep the required last 288 \n+blocks on disk.\n+\n+Block pruning works during initial sync in the same way as during steady state, \n+by deleting block files \"as you go\" whenever disk space is allocated. Thus, if \n+the user specifies 550MB, once that level is reached the program will begin \n+deleting the oldest block and undo files, while continuing to download the \n+blockchain.\n+\n+For now, block pruning disables block relay.  In the future, nodes with block \n+pruning will at a minimum relay \"new\" blocks, meaning blocks that extend their \n+active chain. \n+\n+Block pruning is currently incompatible with running a wallet due to the fact \n+that block data is used for rescanning the wallet and importing keys or \n+addresses (which require a rescan.) However, running the wallet with block \n+pruning will be supported in the near future, subject to those limitations.\n+\n+Block pruning is also incompatible with -txindex and will automatically disable \n+it.\n+\n+Once you have pruned blocks, going back to unpruned state requires \n+re-downloading the entire blockchain. To do this, re-start the node with \n+-reindex. Note also that any problem that would cause a user to reindex (e.g., \n+disk corruption) will cause a pruned node to redownload the entire blockchain. \n+Finally, note that when a pruned node reindexes, it will delete any blk???.dat \n+and rev???.dat files in the data directory prior to restarting the download.\n+\n+To enable block pruning on the command line:\n+\n+- `-prune=N`: where N is the number of MB to allot for raw block & undo data.\n+\n+Modified RPC calls:\n+\n+- `getblockchaininfo` now includes whether we are in pruned mode or not.\n+- `getblock` will check if the block's data has been pruned and if so, return an \n+error.\n+- `getrawtransaction` will no longer be able to locate a transaction that has a \n+UTXO but where its block file has been pruned. \n+\n+Pruning is disabled by default.\n+\n+Big endian support\n+--------------------\n+\n+Experimental support for big-endian CPU architectures was added in this\n+release. This has been tested on at least MIPS and PPC hosts. The build\n+system will automatically detect the endianness of the target.\n+\n+Memory usage optimization\n+--------------------------\n+\n+There have been many changes in this release to reduce the default memory usage\n+of a node, among which:\n+\n+- Accurate UTXO cache size accounting (#6102); this makes the option `-dbcache`\n+  precise, where is did a gross underestimation of memory usage before\n+- Reduce size of per-peer data structure (#6064 and others); this increases the\n+  number of connections that can be supported with the same amount of memory\n+- Reduce the number of threads (#5964, #5679); lowers the amount of (esp.\n+  virtual) memory needed\n+\n+Privacy: Disable wallet transaction broadcast\n+----------------------------------------------\n+\n+This release adds an option `-walletbroadcast=0` to prevent automatic\n+transaction broadcast and rebroadcast (#5951). This option allows separating\n+transaction submission from the node functionality.\n+\n+Making use of this, third-party scripts can be written to take care of\n+transaction (re)broadcast:\n+\n+- Send the transaction as normal, either through RPC or the GUI\n+- Retrieve the transaction data through RPC using `gettransaction` (NOT\n+  `getrawtransaction`). The `hex` field of the result will contain the raw\n+  hexadecimal representation of the transaction\n+- The transaction can then be broadcasted through arbitrary mechanisms\n+  supported by the script\n+\n+One such application is selective Tor usage, where the node runs on the normal\n+internet but transactions are broadcasted over Tor.\n+\n+Privacy: Stream isolation for Tor\n+----------------------------------\n+\n+This release adds functionality to create a new circuit for every peer\n+connection, when the software is used with Tor. The new option,\n+`-proxyrandomize`, is on by default.\n+\n+When enabled, every outgoing connection will (potentially) go through a\n+different exit node. That significantly reduces the chance to get unlucky and\n+pick a single exit node that is either malicious, or widely banned from the P2P\n+network. This improves connection reliability as well as privacy, especially\n+for the initial connections.\n+\n+**Important note:** If a non-Tor SOCKS5 proxy is configured that supports\n+authentication, but doesn't require it, this change may cause it to reject\n+connections. A user and password is sent where they weren't before. This setup\n+is exceedingly rare, but in this case `-proxyrandomize=0` can be passed to\n+disable the behavior.\n+\n+0.11.0 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and REST\n+- #5461 `5f7279a` signrawtransaction: validate private key\n+- #5444 `103f66b` Add /rest/headers/<count>/<hash>.<ext>\n+- #4964 `95ecc0a` Add scriptPubKey field to validateaddress RPC call\n+- #5476 `c986972` Add time offset into getpeerinfo output\n+- #5540 `84eba47` Add unconfirmed and immature balances to getwalletinfo\n+- #5599 `40e96a3` Get rid of the internal miner's hashmeter\n+- #5711 `87ecfb0` Push down RPC locks\n+- #5754 `1c4e3f9` fix getblocktemplate lock issue\n+- #5756 `5d901d8` Fix getblocktemplate_proposals test by mining one block\n+- #5548 `d48ce48` Add /rest/chaininfos\n+- #5992 `4c4f1b4` Push down RPC reqWallet flag\n+- #6036 `585b5db` Show zero value txouts in listunspent\n+- #5199 `6364408` Add RPC call `gettxoutproof` to generate and verify merkle blocks\n+- #5418 `16341cc` Report missing inputs in sendrawtransaction\n+- #5937 `40f5e8d` show script verification errors in signrawtransaction result\n+- #5420 `1fd2d39` getutxos REST command (based on Bip64)\n+\n+### Configuration and command-line options\n+- #5636 `a353ad4` Add option `-allowselfsignedrootcertificate` to allow self signed root certs (for testing payment requests)\n+- #5900 `3e8a1f2` Add a consistency check `-checkblockindex` for the block chain data structures\n+- #5951 `7efc9cf` Make it possible to disable wallet transaction broadcast (using `-walletbroadcast=0`)\n+- #5911 `b6ea3bc` privacy: Stream isolation for Tor (on by default, use `-proxyrandomize=0` to disable)\n+- #5863 `c271304` Add autoprune functionality (`-prune=<size>`)\n+\n+### Block and transaction handling\n+- #5367 `dcc1304` Do all block index writes in a batch\n+- #5253 `203632d` Check against MANDATORY flags prior to accepting to mempool\n+- #5459 `4406c3e` Reject headers that build on an invalid parent\n+- #5481 `055f3ae` Apply AreSane() checks to the fees from the network\n+- #5580 `40d65eb` Preemptively catch a few potential bugs\n+- #5349 `f55c5e9` Implement test for merkle tree malleability in CPartialMerkleTree\n+- #5564 `a89b837` clarify obscure uses of EvalScript()\n+- #5521 `8e4578a` Reject non-final txs even in testnet/regtest\n+- #5707 `6af674e` Change hardcoded character constants to descriptive named constants for db keys\n+- #5286 `fcf646c` Change the default maximum OP_RETURN size to 80 bytes\n+- #5710 `175d86e` Add more information to errors in ReadBlockFromDisk\n+- #5948 `b36f1ce` Use GetAncestor to compute new target\n+- #5959 `a0bfc69` Add additional block index consistency checks\n+- #6058 `7e0e7f8` autoprune minor post-merge improvements\n+- #5159 `2cc1372` New fee estimation code\n+- #6102 `6fb90d8` Implement accurate UTXO cache size accounting\n+- #6129 `2a82298` Bug fix for clearing fCheckForPruning\n+- #5947 `e9af4e6` Alert if it is very likely we are getting a bad chain\n+\n+### P2P protocol and network code\n+- #5507 `844ace9` Prevent DOS attacks on in-flight data structures\n+- #5770 `32a8b6a` Sanitize command strings before logging them\n+- #5859 `dd4ffce` Add correct bool combiner for net signals\n+- #5876 `8e4fd0c` Add a NODE_GETUTXO service bit and document NODE_NETWORK\n+- #6028 `b9311fb` Move nLastTry from CAddress to CAddrInfo\n+- #5662 `5048465` Change download logic to allow calling getdata on inbound peers\n+- #5971 `18d2832` replace absolute sleep with conditional wait\n+- #5918 `7bf5d5e` Use equivalent PoW for non-main-chain requests\n+- #6059 `f026ab6` chainparams: use SeedSpec6's rather than CAddress's for fixed seeds\n+- #6080 `31c0bf1` Add jonasschnellis dns seeder\n+- #5976 `9f7809f` Reduce download timeouts as blocks arrive\n+\n+### Validation\n+- #5143 `48e1765` Implement BIP62 rule 6\n+- #5713 `41e6e4c` Implement BIP66\n+\n+### Build system\n+- #5501 `c76c9d2` Add mips, mipsel and aarch64 to depends platforms\n+- #5334 `cf87536` libbitcoinconsensus: Add pkg-config support\n+- #5514 `ed11d53` Fix 'make distcheck'\n+- #5505 `a99ef7d` Build winshutdownmonitor.cpp on Windows only\n+- #5582 `e8a6639` Osx toolchain update\n+- #5684 `ab64022` osx: bump build sdk to 10.9\n+- #5695 `23ef5b7` depends: latest config.guess and config.sub\n+- #5509 `31dedb4` Fixes when compiling in c++11 mode\n+- #5819 `f8e68f7` release: use static libstdc++ and disable reduced exports by default\n+- #5510 `7c3fbc3` Big endian support\n+- #5149 `c7abfa5` Add script to verify all merge commits are signed\n+- #6082 `7abbb7e` qt: disable qt tests when one of the checks for the gui fails\n+\n+### Wallet\n+- #2340 `811c71d` Discourage fee sniping with nLockTime\n+- #5485 `d01bcc4` Enforce minRelayTxFee on wallet created tx and add a maxtxfee option\n+- #5508 `9a5cabf` Add RandAddSeedPerfmon to MakeNewKey\n+- #4805 `8204e19` Do not flush the wallet in AddToWalletIfInvolvingMe(..)\n+- #5319 `93b7544` Clean up wallet encryption code\n+- #5831 `df5c246` Subtract fee from amount\n+- #6076 `6c97fd1` wallet: fix boost::get usage with boost 1.58\n+- #5511 `23c998d` Sort pending wallet transactions before reaccepting\n+- #6126 `26e08a1` Change default nTxConfirmTarget to 2\n+\n+### GUI\n+- #5219 `f3af0c8` New icons\n+- #5228 `bb3c75b` HiDPI (retina) support for splash screen\n+- #5258 `73cbf0a` The RPC Console should be a QWidget to make window more independent\n+- #5488 `851dfc7` Light blue icon color for regtest\n+- #5547 `a39aa74` New icon for the debug window\n+- #5493 `e515309` Adopt style colour for button icons\n+- #5557 `70477a0` On close of splashscreen interrupt verifyDB\n+- #5559 `83be8fd` Make the command-line-args dialog better\n+- #5144 `c5380a9` Elaborate on signverify message dialog warning\n+- #5489 `d1aa3c6` Optimize PNG files\n+- #5649 `e0cd2f5` Use text-color icons for system tray Send/Receive menu entries\n+- #5651 `848f55d` Coin Control: Use U+2248 \"ALMOST EQUAL TO\" rather than a simple tilde\n+- #5626 `ab0d798` Fix icon sizes and column width\n+- #5683 `c7b22aa` add new osx dmg background picture\n+- #5620 `7823598` Payment request expiration bug fix\n+- #5729 `9c4a5a5` Allow unit changes for read-only BitcoinAmountField\n+- #5753 `0f44672` Add bitcoin logo to about screen\n+- #5629 `a956586` Prevent amount overflow problem with payment requests\n+- #5830 `215475a` Don't save geometry for options and about/help window\n+- #5793 `d26f0b2` Honor current network when creating autostart link\n+- #5847 `f238add` Startup script for centos, with documentation\n+- #5915 `5bd3a92` Fix a static qt5 crash when using certain versions of libxcb\n+- #5898 `bb56781` Fix rpc console font size to flexible metrics\n+- #5467 `bc8535b` Payment request / server work - part 2\n+- #6161 `180c164` Remove movable option for toolbar\n+- #6160 `0d862c2` Overviewpage: make sure warning icons gets colored\n+\n+### Tests\n+- #5453 `2f2d337` Add ability to run single test manually to RPC tests\n+- #5421 `886eb57` Test unexecuted OP_CODESEPARATOR\n+- #5530 `565b300` Additional rpc tests\n+- #5611 `37b185c` Fix spurious windows test failures after 012598880c\n+- #5613 `2eda47b` Fix smartfees test for change to relay policy\n+- #5612 `e3f5727` Fix zapwallettxes test\n+- #5642 `30a5b5f` Prepare paymentservertests for new unit tests\n+- #5784 `e3a3cd7` Fix usage of NegateSignatureS in script_tests\n+- #5813 `ee9f2bf` Add unit tests for next difficulty calculations\n+- #5855 `d7989c0` Travis: run unit tests in different orders\n+- #5852 `cdae53e` Reinitialize state in between individual unit tests.\n+- #5883 `164d7b6` tests: add a BasicTestingSetup and apply to all tests\n+- #5940 `446bb70` Regression test for ResendWalletTransactions\n+- #6052 `cf7adad` fix and enable bip32 unit test\n+- #6039 `734f80a` tests: Error when setgenerate is used on regtest\n+- #6074 `948beaf` Correct the PUSHDATA4 minimal encoding test in script_invalid.json\n+- #6032 `e08886d` Stop nodes after RPC tests, even with --nocleanup\n+- #6075 `df1609f` Add additional script edge condition tests\n+- #5981 `da38dc6` Python P2P testing \n+- #5958 `9ef00c3` Add multisig rpc tests\n+- #6112 `fec5c0e` Add more script edge condition tests\n+\n+### Miscellaneous\n+- #5457, #5506, #5952, #6047 Update libsecp256k1\n+- #5437 `84857e8` Add missing CAutoFile::IsNull() check in main\n+- #5490 `ec20fd7` Replace uint256/uint160 with opaque blobs where possible\n+- #5654, #5764 Adding jonasschnelli's GPG key\n+- #5477 `5f04d1d` OS X 10.10: LSSharedFileListItemResolve() is deprecated\n+- #5679 `beff11a` Get rid of DetectShutdownThread\n+- #5787 `9bd8c9b` Add fanquake PGP key\n+- #5366 `47a79bb` No longer check osx compatibility in RenameThread\n+- #5689 `07f4386` openssl: abstract out OPENSSL_cleanse\n+- #5708 `8b298ca` Add list of implemented BIPs\n+- #5809 `46bfbe7` Add bitcoin-cli man page\n+- #5839 `86eb461` keys: remove libsecp256k1 verification until it's actually supported\n+- #5749 `d734d87` Help messages correctly formatted (79 chars)\n+- #5884 `7077fe6` BUGFIX: Stack around the variable 'rv' was corrupted\n+- #5849 `41259ca` contrib/init/bitcoind.openrc: Compatibility with previous OpenRC init script variables\n+- #5950 `41113e3` Fix locale fallback and guard tests against invalid locale settings\n+- #5965 `7c6bfb1` Add git-subtree-check.sh script\n+- #6033 `1623f6e` FreeBSD, OpenBSD thread renaming\n+- #6064 `b46e7c2` Several changes to mruset\n+- #6104 `3e2559c` Show an init message while activating best chain\n+- #6125 `351f73e` Clean up parsing of bool command line args\n+- #5964 `b4c219b` Lightweight task scheduler\n+- #6116 `30dc3c1` [OSX] rename Bitcoin-Qt.app to Bitcoin-Core.app\n+- #6168 `b3024f0` contrib/linearize: Support linearization of testnet blocks\n+- #6098 `7708fcd` Update Windows resource files (and add one for bitcoin-tx)\n+- #6159 `e1412d3` Catch errors on datadir lock and pidfile delete\n+\n+[up to date until #5976]"
      },
      {
        "sha": "986b8832ec1893a5cc061ea14ac609e7836fbb4f",
        "filename": "doc/release-notes/release-notes-0.10.0.md",
        "status": "added",
        "additions": 762,
        "deletions": 0,
        "changes": 762,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.10.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.10.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.0.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,762 @@\n+Bitcoin Core version 0.10.0 is now available from:\n+\n+  https://bitcoin.org/bin/0.10.0/\n+\n+This is a new major version release, bringing both new features and\n+bug fixes.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  https://github.com/bitcoin/bitcoin/issues\n+\n+Upgrading and downgrading\n+=========================\n+\n+How to Upgrade\n+--------------\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+Downgrading warning\n+---------------------\n+\n+Because release 0.10.0 makes use of headers-first synchronization and parallel\n+block download (see further), the block files and databases are not\n+backwards-compatible with older versions of Bitcoin Core or other software:\n+\n+* Blocks will be stored on disk out of order (in the order they are\n+received, really), which makes it incompatible with some tools or\n+other programs. Reindexing using earlier versions will also not work\n+anymore as a result of this.\n+\n+* The block index database will now hold headers for which no block is\n+stored on disk, which earlier versions won't support.\n+\n+If you want to be able to downgrade smoothly, make a backup of your entire data\n+directory. Without this your node will need start syncing (or importing from\n+bootstrap.dat) anew afterwards. It is possible that the data from a completely\n+synchronised 0.10 node may be usable in older versions as-is, but this is not\n+supported and may break as soon as the older version attempts to reindex.\n+\n+This does not affect wallet forward or backward compatibility.\n+\n+\n+Notable changes\n+===============\n+\n+Faster synchronization\n+----------------------\n+\n+Bitcoin Core now uses 'headers-first synchronization'. This means that we first\n+ask peers for block headers (a total of 27 megabytes, as of December 2014) and\n+validate those. In a second stage, when the headers have been discovered, we\n+download the blocks. However, as we already know about the whole chain in\n+advance, the blocks can be downloaded in parallel from all available peers.\n+\n+In practice, this means a much faster and more robust synchronization. On\n+recent hardware with a decent network link, it can be as little as 3 hours\n+for an initial full synchronization. You may notice a slower progress in the\n+very first few minutes, when headers are still being fetched and verified, but\n+it should gain speed afterwards.\n+\n+A few RPCs were added/updated as a result of this:\n+- `getblockchaininfo` now returns the number of validated headers in addition to\n+the number of validated blocks.\n+- `getpeerinfo` lists both the number of blocks and headers we know we have in\n+common with each peer. While synchronizing, the heights of the blocks that we\n+have requested from peers (but haven't received yet) are also listed as\n+'inflight'.\n+- A new RPC `getchaintips` lists all known branches of the block chain,\n+including those we only have headers for.\n+\n+Transaction fee changes\n+-----------------------\n+\n+This release automatically estimates how high a transaction fee (or how\n+high a priority) transactions require to be confirmed quickly. The default\n+settings will create transactions that confirm quickly; see the new\n+'txconfirmtarget' setting to control the tradeoff between fees and\n+confirmation times. Fees are added by default unless the 'sendfreetransactions' \n+setting is enabled.\n+\n+Prior releases used hard-coded fees (and priorities), and would\n+sometimes create transactions that took a very long time to confirm.\n+\n+Statistics used to estimate fees and priorities are saved in the\n+data directory in the `fee_estimates.dat` file just before\n+program shutdown, and are read in at startup.\n+\n+New command line options for transaction fee changes:\n+- `-txconfirmtarget=n` : create transactions that have enough fees (or priority)\n+so they are likely to begin confirmation within n blocks (default: 1). This setting\n+is over-ridden by the -paytxfee option.\n+- `-sendfreetransactions` : Send transactions as zero-fee transactions if possible \n+(default: 0)\n+\n+New RPC commands for fee estimation:\n+- `estimatefee nblocks` : Returns approximate fee-per-1,000-bytes needed for\n+a transaction to begin confirmation within nblocks. Returns -1 if not enough\n+transactions have been observed to compute a good estimate.\n+- `estimatepriority nblocks` : Returns approximate priority needed for\n+a zero-fee transaction to begin confirmation within nblocks. Returns -1 if not\n+enough free transactions have been observed to compute a good\n+estimate.\n+\n+RPC access control changes\n+--------------------------\n+\n+Subnet matching for the purpose of access control is now done\n+by matching the binary network address, instead of with string wildcard matching.\n+For the user this means that `-rpcallowip` takes a subnet specification, which can be\n+\n+- a single IP address (e.g. `1.2.3.4` or `fe80::0012:3456:789a:bcde`)\n+- a network/CIDR (e.g. `1.2.3.0/24` or `fe80::0000/64`)\n+- a network/netmask (e.g. `1.2.3.4/255.255.255.0` or `fe80::0012:3456:789a:bcde/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`)\n+\n+An arbitrary number of `-rpcallow` arguments can be given. An incoming connection will be accepted if its origin address\n+matches one of them.\n+\n+For example:\n+\n+| 0.9.x and before                           | 0.10.x                                |\n+|--------------------------------------------|---------------------------------------|\n+| `-rpcallowip=192.168.1.1`                  | `-rpcallowip=192.168.1.1` (unchanged) |\n+| `-rpcallowip=192.168.1.*`                  | `-rpcallowip=192.168.1.0/24`          |\n+| `-rpcallowip=192.168.*`                    | `-rpcallowip=192.168.0.0/16`          |\n+| `-rpcallowip=*` (dangerous!)               | `-rpcallowip=::/0` (still dangerous!) |\n+\n+Using wildcards will result in the rule being rejected with the following error in debug.log:\n+\n+    Error: Invalid -rpcallowip subnet specification: *. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\n+\n+\n+REST interface\n+--------------\n+\n+A new HTTP API is exposed when running with the `-rest` flag, which allows\n+unauthenticated access to public node data.\n+\n+It is served on the same port as RPC, but does not need a password, and uses\n+plain HTTP instead of JSON-RPC.\n+\n+Assuming a local RPC server running on port 8332, it is possible to request:\n+- Blocks: http://localhost:8332/rest/block/*HASH*.*EXT*\n+- Blocks without transactions: http://localhost:8332/rest/block/notxdetails/*HASH*.*EXT*\n+- Transactions (requires `-txindex`): http://localhost:8332/rest/tx/*HASH*.*EXT*\n+\n+In every case, *EXT* can be `bin` (for raw binary data), `hex` (for hex-encoded\n+binary) or `json`.\n+\n+For more details, see the `doc/REST-interface.md` document in the repository.\n+\n+RPC Server \"Warm-Up\" Mode\n+-------------------------\n+\n+The RPC server is started earlier now, before most of the expensive\n+intialisations like loading the block index.  It is available now almost\n+immediately after starting the process.  However, until all initialisations\n+are done, it always returns an immediate error with code -28 to all calls.\n+\n+This new behaviour can be useful for clients to know that a server is already\n+started and will be available soon (for instance, so that they do not\n+have to start it themselves).\n+\n+Improved signing security\n+-------------------------\n+\n+For 0.10 the security of signing against unusual attacks has been\n+improved by making the signatures constant time and deterministic.\n+\n+This change is a result of switching signing to use libsecp256k1\n+instead of OpenSSL. Libsecp256k1 is a cryptographic library\n+optimized for the curve Bitcoin uses which was created by Bitcoin\n+Core developer Pieter Wuille.\n+\n+There exist attacks[1] against most ECC implementations where an\n+attacker on shared virtual machine hardware could extract a private\n+key if they could cause a target to sign using the same key hundreds\n+of times. While using shared hosts and reusing keys are inadvisable\n+for other reasons, it's a better practice to avoid the exposure.\n+\n+OpenSSL has code in their source repository for derandomization\n+and reduction in timing leaks that we've eagerly wanted to use for a\n+long time, but this functionality has still not made its\n+way into a released version of OpenSSL. Libsecp256k1 achieves\n+significantly stronger protection: As far as we're aware this is\n+the only deployed implementation of constant time signing for\n+the curve Bitcoin uses and we have reason to believe that\n+libsecp256k1 is better tested and more thoroughly reviewed\n+than the implementation in OpenSSL.\n+\n+[1] https://eprint.iacr.org/2014/161.pdf\n+\n+Watch-only wallet support\n+-------------------------\n+\n+The wallet can now track transactions to and from wallets for which you know\n+all addresses (or scripts), even without the private keys.\n+\n+This can be used to track payments without needing the private keys online on a\n+possibly vulnerable system. In addition, it can help for (manual) construction\n+of multisig transactions where you are only one of the signers.\n+\n+One new RPC, `importaddress`, is added which functions similarly to\n+`importprivkey`, but instead takes an address or script (in hexadecimal) as\n+argument.  After using it, outputs credited to this address or script are\n+considered to be received, and transactions consuming these outputs will be\n+considered to be sent.\n+\n+The following RPCs have optional support for watch-only:\n+`getbalance`, `listreceivedbyaddress`, `listreceivedbyaccount`,\n+`listtransactions`, `listaccounts`, `listsinceblock`, `gettransaction`. See the\n+RPC documentation for those methods for more information.\n+\n+Compared to using `getrawtransaction`, this mechanism does not require\n+`-txindex`, scales better, integrates better with the wallet, and is compatible\n+with future block chain pruning functionality. It does mean that all relevant\n+addresses need to added to the wallet before the payment, though.\n+\n+Consensus library\n+-----------------\n+\n+Starting from 0.10.0, the Bitcoin Core distribution includes a consensus library.\n+\n+The purpose of this library is to make the verification functionality that is\n+critical to Bitcoin's consensus available to other applications, e.g. to language\n+bindings such as [python-bitcoinlib](https://pypi.python.org/pypi/python-bitcoinlib) or\n+alternative node implementations.\n+\n+This library is called `libbitcoinconsensus.so` (or, `.dll` for Windows).\n+Its interface is defined in the C header [bitcoinconsensus.h](https://github.com/bitcoin/bitcoin/blob/0.10/src/script/bitcoinconsensus.h).\n+\n+In its initial version the API includes two functions:\n+\n+- `bitcoinconsensus_verify_script` verifies a script. It returns whether the indicated input of the provided serialized transaction \n+correctly spends the passed scriptPubKey under additional constraints indicated by flags\n+- `bitcoinconsensus_version` returns the API version, currently at an experimental `0`\n+\n+The functionality is planned to be extended to e.g. UTXO management in upcoming releases, but the interface\n+for existing methods should remain stable.\n+\n+Standard script rules relaxed for P2SH addresses\n+------------------------------------------------\n+\n+The IsStandard() rules have been almost completely removed for P2SH\n+redemption scripts, allowing applications to make use of any valid\n+script type, such as \"n-of-m OR y\", hash-locked oracle addresses, etc.\n+While the Bitcoin protocol has always supported these types of script,\n+actually using them on mainnet has been previously inconvenient as\n+standard Bitcoin Core nodes wouldn't relay them to miners, nor would\n+most miners include them in blocks they mined.\n+\n+bitcoin-tx\n+----------\n+\n+It has been observed that many of the RPC functions offered by bitcoind are\n+\"pure functions\", and operate independently of the bitcoind wallet. This\n+included many of the RPC \"raw transaction\" API functions, such as\n+createrawtransaction.\n+\n+bitcoin-tx is a newly introduced command line utility designed to enable easy\n+manipulation of bitcoin transactions. A summary of its operation may be\n+obtained via \"bitcoin-tx --help\" Transactions may be created or signed in a\n+manner similar to the RPC raw tx API. Transactions may be updated, deleting\n+inputs or outputs, or appending new inputs and outputs. Custom scripts may be\n+easily composed using a simple text notation, borrowed from the bitcoin test\n+suite.\n+\n+This tool may be used for experimenting with new transaction types, signing\n+multi-party transactions, and many other uses. Long term, the goal is to\n+deprecate and remove \"pure function\" RPC API calls, as those do not require a\n+server round-trip to execute.\n+\n+Other utilities \"bitcoin-key\" and \"bitcoin-script\" have been proposed, making\n+key and script operations easily accessible via command line.\n+\n+Mining and relay policy enhancements\n+------------------------------------\n+\n+Bitcoin Core's block templates are now for version 3 blocks only, and any mining\n+software relying on its `getblocktemplate` must be updated in parallel to use\n+libblkmaker either version 0.4.2 or any version from 0.5.1 onward.\n+If you are solo mining, this will affect you the moment you upgrade Bitcoin\n+Core, which must be done prior to BIP66 achieving its 951/1001 status.\n+If you are mining with the stratum mining protocol: this does not affect you.\n+If you are mining with the getblocktemplate protocol to a pool: this will affect\n+you at the pool operator's discretion, which must be no later than BIP66\n+achieving its 951/1001 status.\n+\n+The `prioritisetransaction` RPC method has been added to enable miners to\n+manipulate the priority of transactions on an individual basis.\n+\n+Bitcoin Core now supports BIP 22 long polling, so mining software can be\n+notified immediately of new templates rather than having to poll periodically.\n+\n+Support for BIP 23 block proposals is now available in Bitcoin Core's\n+`getblocktemplate` method. This enables miners to check the basic validity of\n+their next block before expending work on it, reducing risks of accidental\n+hardforks or mining invalid blocks.\n+\n+Two new options to control mining policy:\n+- `-datacarrier=0/1` : Relay and mine \"data carrier\" (OP_RETURN) transactions\n+if this is 1.\n+- `-datacarriersize=n` : Maximum size, in bytes, we consider acceptable for\n+\"data carrier\" outputs.\n+\n+The relay policy has changed to more properly implement the desired behavior of not \n+relaying free (or very low fee) transactions unless they have a priority above the \n+AllowFreeThreshold(), in which case they are relayed subject to the rate limiter.\n+\n+BIP 66: strict DER encoding for signatures\n+------------------------------------------\n+\n+Bitcoin Core 0.10 implements BIP 66, which introduces block version 3, and a new\n+consensus rule, which prohibits non-DER signatures. Such transactions have been\n+non-standard since Bitcoin v0.8.0 (released in February 2013), but were\n+technically still permitted inside blocks.\n+\n+This change breaks the dependency on OpenSSL's signature parsing, and is\n+required if implementations would want to remove all of OpenSSL from the\n+consensus code.\n+\n+The same miner-voting mechanism as in BIP 34 is used: when 751 out of a\n+sequence of 1001 blocks have version number 3 or higher, the new consensus\n+rule becomes active for those blocks. When 951 out of a sequence of 1001\n+blocks have version number 3 or higher, it becomes mandatory for all blocks.\n+\n+Backward compatibility with current mining software is NOT provided, thus miners\n+should read the first paragraph of \"Mining and relay policy enhancements\" above.\n+\n+0.10.0 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect external\n+behavior, not code moves, refactors or string updates.\n+\n+RPC:\n+- `f923c07` Support IPv6 lookup in bitcoin-cli even when IPv6 only bound on localhost\n+- `b641c9c` Fix addnode \"onetry\": Connect with OpenNetworkConnection\n+- `171ca77` estimatefee / estimatepriority RPC methods\n+- `b750cf1` Remove cli functionality from bitcoind\n+- `f6984e8` Add \"chain\" to getmininginfo, improve help in getblockchaininfo\n+- `99ddc6c` Add nLocalServices info to RPC getinfo\n+- `cf0c47b` Remove getwork() RPC call\n+- `2a72d45` prioritisetransaction <txid> <priority delta> <priority tx fee>\n+- `e44fea5` Add an option `-datacarrier` to allow users to disable relaying/mining data carrier transactions\n+- `2ec5a3d` Prevent easy RPC memory exhaustion attack\n+- `d4640d7` Added argument to getbalance to include watchonly addresses and fixed errors in balance calculation\n+- `83f3543` Added argument to listaccounts to include watchonly addresses\n+- `952877e` Showing 'involvesWatchonly' property for transactions returned by 'listtransactions' and 'listsinceblock'. It is only appended when the transaction involves a watchonly address\n+- `d7d5d23` Added argument to listtransactions and listsinceblock to include watchonly addresses\n+- `f87ba3d` added includeWatchonly argument to 'gettransaction' because it affects balance calculation\n+- `0fa2f88` added includedWatchonly argument to listreceivedbyaddress/...account\n+- `6c37f7f` `getrawchangeaddress`: fail when keypool exhausted and wallet locked\n+- `ff6a7af` getblocktemplate: longpolling support\n+- `c4a321f` Add peerid to getpeerinfo to allow correlation with the logs\n+- `1b4568c` Add vout to ListTransactions output\n+- `b33bd7a` Implement \"getchaintips\" RPC command to monitor blockchain forks\n+- `733177e` Remove size limit in RPC client, keep it in server\n+- `6b5b7cb` Categorize rpc help overview\n+- `6f2c26a` Closely track mempool byte total. Add \"getmempoolinfo\" RPC\n+- `aa82795` Add detailed network info to getnetworkinfo RPC\n+- `01094bd` Don't reveal whether password is <20 or >20 characters in RPC\n+- `57153d4` rpc: Compute number of confirmations of a block from block height\n+- `ff36cbe` getnetworkinfo: export local node's client sub-version string\n+- `d14d7de` SanitizeString: allow '(' and ')'\n+- `31d6390` Fixed setaccount accepting foreign address\n+- `b5ec5fe` update getnetworkinfo help with subversion\n+- `ad6e601` RPC additions after headers-first\n+- `33dfbf5` rpc: Fix leveldb iterator leak, and flush before `gettxoutsetinfo`\n+- `2aa6329` Enable customising node policy for datacarrier data size with a -datacarriersize option\n+- `f877aaa` submitblock: Use a temporary CValidationState to determine accurately the outcome of ProcessBlock\n+- `e69a587` submitblock: Support for returning specific rejection reasons\n+- `af82884` Add \"warmup mode\" for RPC server\n+- `e2655e0` Add unauthenticated HTTP REST interface to public blockchain data\n+- `683dc40` Disable SSLv3 (in favor of TLS) for the RPC client and server\n+- `44b4c0d` signrawtransaction: validate private key\n+- `9765a50` Implement BIP 23 Block Proposal\n+- `f9de17e` Add warning comment to getinfo\n+\n+Command-line options:\n+- `ee21912` Use netmasks instead of wildcards for IP address matching\n+- `deb3572` Add `-rpcbind` option to allow binding RPC port on a specific interface\n+- `96b733e` Add `-version` option to get just the version\n+- `1569353` Add `-stopafterblockimport` option\n+- `77cbd46` Let -zapwallettxes recover transaction meta data\n+- `1c750db` remove -tor compatibility code (only allow -onion)\n+- `4aaa017` rework help messages for fee-related options\n+- `4278b1d` Clarify error message when invalid -rpcallowip\n+- `6b407e4` -datadir is now allowed in config files\n+- `bdd5b58` Add option `-sysperms` to disable 077 umask (create new files with system default umask)\n+- `cbe39a3` Add \"bitcoin-tx\" command line utility and supporting modules\n+- `dbca89b` Trigger -alertnotify if network is upgrading without you\n+- `ad96e7c` Make -reindex cope with out-of-order blocks\n+- `16d5194` Skip reindexed blocks individually\n+- `ec01243` --tracerpc option for regression tests\n+- `f654f00` Change -genproclimit default to 1\n+- `3c77714` Make -proxy set all network types, avoiding a connect leak\n+- `57be955` Remove -printblock, -printblocktree, and -printblockindex\n+- `ad3d208` remove -maxorphanblocks config parameter since it is no longer functional\n+\n+Block and transaction handling:\n+- `7a0e84d` ProcessGetData(): abort if a block file is missing from disk\n+- `8c93bf4` LoadBlockIndexDB(): Require block db reindex if any `blk*.dat` files are missing\n+- `77339e5` Get rid of the static chainMostWork (optimization)\n+- `4e0eed8` Allow ActivateBestChain to release its lock on cs_main\n+- `18e7216` Push cs_mains down in ProcessBlock\n+- `fa126ef` Avoid undefined behavior using CFlatData in CScript serialization\n+- `7f3b4e9` Relax IsStandard rules for pay-to-script-hash transactions\n+- `c9a0918` Add a skiplist to the CBlockIndex structure\n+- `bc42503` Use unordered_map for CCoinsViewCache with salted hash (optimization)\n+- `d4d3fbd` Do not flush the cache after every block outside of IBD (optimization)\n+- `ad08d0b` Bugfix: make CCoinsViewMemPool support pruned entries in underlying cache\n+- `5734d4d` Only remove actualy failed blocks from setBlockIndexValid\n+- `d70bc52` Rework block processing benchmark code\n+- `714a3e6` Only keep setBlockIndexValid entries that are possible improvements\n+- `ea100c7` Reduce maximum coinscache size during verification (reduce memory usage)\n+- `4fad8e6` Reject transactions with excessive numbers of sigops\n+- `b0875eb` Allow BatchWrite to destroy its input, reducing copying (optimization)\n+- `92bb6f2` Bypass reloading blocks from disk (optimization)\n+- `2e28031` Perform CVerifyDB on pcoinsdbview instead of pcoinsTip (reduce memory usage)\n+- `ab15b2e` Avoid copying undo data (optimization)\n+- `341735e` Headers-first synchronization\n+- `afc32c5` Fix rebuild-chainstate feature and improve its performance\n+- `e11b2ce` Fix large reorgs\n+- `ed6d1a2` Keep information about all block files in memory\n+- `a48f2d6` Abstract context-dependent block checking from acceptance\n+- `7e615f5` Fixed mempool sync after sending a transaction\n+- `51ce901` Improve chainstate/blockindex disk writing policy\n+- `a206950` Introduce separate flushing modes\n+- `9ec75c5` Add a locking mechanism to IsInitialBlockDownload to ensure it never goes from false to true\n+- `868d041` Remove coinbase-dependant transactions during reorg\n+- `723d12c` Remove txn which are invalidated by coinbase maturity during reorg\n+- `0cb8763` Check against MANDATORY flags prior to accepting to mempool\n+- `8446262` Reject headers that build on an invalid parent\n+- `008138c` Bugfix: only track UTXO modification after lookup\n+\n+P2P protocol and network code:\n+- `f80cffa` Do not trigger a DoS ban if SCRIPT_VERIFY_NULLDUMMY fails\n+- `c30329a` Add testnet DNS seed of Alex Kotenko\n+- `45a4baf` Add testnet DNS seed of Andreas Schildbach\n+- `f1920e8` Ping automatically every 2 minutes (unconditionally)\n+- `806fd19` Allocate receive buffers in on the fly\n+- `6ecf3ed` Display unknown commands received\n+- `aa81564` Track peers' available blocks\n+- `caf6150` Use async name resolving to improve net thread responsiveness\n+- `9f4da19` Use pong receive time rather than processing time\n+- `0127a9b` remove SOCKS4 support from core and GUI, use SOCKS5\n+- `40f5cb8` Send rejects and apply DoS scoring for errors in direct block validation\n+- `dc942e6` Introduce whitelisted peers\n+- `c994d2e` prevent SOCKET leak in BindListenPort()\n+- `a60120e` Add built-in seeds for .onion\n+- `60dc8e4` Allow -onlynet=onion to be used\n+- `3a56de7` addrman: Do not propagate obviously poor addresses onto the network\n+- `6050ab6` netbase: Make SOCKS5 negotiation interruptible\n+- `604ee2a` Remove tx from AlreadyAskedFor list once we receive it, not when we process it\n+- `efad808` Avoid reject message feedback loops\n+- `71697f9` Separate protocol versioning from clientversion\n+- `20a5f61` Don't relay alerts to peers before version negotiation\n+- `b4ee0bd` Introduce preferred download peers\n+- `845c86d` Do not use third party services for IP detection\n+- `12a49ca` Limit the number of new addressses to accumulate\n+- `35e408f` Regard connection failures as attempt for addrman\n+- `a3a7317` Introduce 10 minute block download timeout\n+- `3022e7d` Require sufficent priority for relay of free transactions\n+- `58fda4d` Update seed IPs, based on bitcoin.sipa.be crawler data\n+- `18021d0` Remove bitnodes.io from dnsseeds.\n+\n+Validation:\n+- `6fd7ef2` Also switch the (unused) verification code to low-s instead of even-s\n+- `584a358` Do merkle root and txid duplicates check simultaneously\n+- `217a5c9` When transaction outputs exceed inputs, show the offending amounts so as to aid debugging\n+- `f74fc9b` Print input index when signature validation fails, to aid debugging\n+- `6fd59ee` script.h: set_vch() should shift a >32 bit value\n+- `d752ba8` Add SCRIPT_VERIFY_SIGPUSHONLY (BIP62 rule 2) (test only)\n+- `698c6ab` Add SCRIPT_VERIFY_MINIMALDATA (BIP62 rules 3 and 4) (test only)\n+- `ab9edbd` script: create sane error return codes for script validation and remove logging\n+- `219a147` script: check ScriptError values in script tests\n+- `0391423` Discourage NOPs reserved for soft-fork upgrades\n+- `98b135f` Make STRICTENC invalid pubkeys fail the script rather than the opcode\n+- `307f7d4` Report script evaluation failures in log and reject messages\n+- `ace39db` consensus: guard against openssl's new strict DER checks\n+- `12b7c44` Improve robustness of DER recoding code\n+- `76ce5c8` fail immediately on an empty signature\n+\n+Build system:\n+- `f25e3ad` Fix build in OS X 10.9\n+- `65e8ba4` build: Switch to non-recursive make\n+- `460b32d` build: fix broken boost chrono check on some platforms\n+- `9ce0774` build: Fix windows configure when using --with-qt-libdir\n+- `ea96475` build: Add mention of --disable-wallet to bdb48 error messages\n+- `1dec09b` depends: add shared dependency builder\n+- `c101c76` build: Add --with-utils (bitcoin-cli and bitcoin-tx, default=yes). Help string consistency tweaks. Target sanity check fix\n+- `e432a5f` build: add option for reducing exports (v2)\n+- `6134b43` Fixing condition 'sabotaging' MSVC build\n+- `af0bd5e` osx: fix signing to make Gatekeeper happy (again)\n+- `a7d1f03` build: fix dynamic boost check when --with-boost= is used\n+- `d5fd094` build: fix qt test build when libprotobuf is in a non-standard path\n+- `2cf5f16` Add libbitcoinconsensus library\n+- `914868a` build: add a deterministic dmg signer \n+- `2d375fe` depends: bump openssl to 1.0.1k\n+- `b7a4ecc` Build: Only check for boost when building code that requires it\n+\n+Wallet:\n+- `b33d1f5` Use fee/priority estimates in wallet CreateTransaction\n+- `4b7b1bb` Sanity checks for estimates\n+- `c898846` Add support for watch-only addresses\n+- `d5087d1` Use script matching rather than destination matching for watch-only\n+- `d88af56` Fee fixes\n+- `a35b55b` Dont run full check every time we decrypt wallet\n+- `3a7c348` Fix make_change to not create half-satoshis\n+- `f606bb9` fix a possible memory leak in CWalletDB::Recover\n+- `870da77` fix possible memory leaks in CWallet::EncryptWallet\n+- `ccca27a` Watch-only fixes\n+- `9b1627d` [Wallet] Reduce minTxFee for transaction creation to 1000 satoshis\n+- `a53fd41` Deterministic signing\n+- `15ad0b5` Apply AreSane() checks to the fees from the network\n+- `11855c1` Enforce minRelayTxFee on wallet created tx and add a maxtxfee option\n+\n+GUI:\n+- `c21c74b` osx: Fix missing dock menu with qt5\n+- `b90711c` Fix Transaction details shows wrong To:\n+- `516053c` Make links in 'About Bitcoin Core' clickable\n+- `bdc83e8` Ensure payment request network matches client network\n+- `65f78a1` Add GUI view of peer information\n+- `06a91d9` VerifyDB progress reporting\n+- `fe6bff2` Add BerkeleyDB version info to RPCConsole\n+- `b917555` PeerTableModel: Fix potential deadlock. #4296\n+- `dff0e3b` Improve rpc console history behavior\n+- `95a9383` Remove CENT-fee-rule from coin control completely\n+- `56b07d2` Allow setting listen via GUI\n+- `d95ba75` Log messages with type>QtDebugMsg as non-debug\n+- `8969828` New status bar Unit Display Control and related changes\n+- `674c070` seed OpenSSL PNRG with Windows event data\n+- `509f926` Payment request parsing on startup now only changes network if a valid network name is specified\n+- `acd432b` Prevent balloon-spam after rescan\n+- `7007402` Implement SI-style (thin space) thoudands separator\n+- `91cce17` Use fixed-point arithmetic in amount spinbox\n+- `bdba2dd` Remove an obscure option no-one cares about\n+- `bd0aa10` Replace the temporary file hack currently used to change Bitcoin-Qt's dock icon (OS X) with a buffer-based solution\n+- `94e1b9e` Re-work overviewpage UI\n+- `8bfdc9a` Better looking trayicon\n+- `b197bf3` disable tray interactions when client model set to 0\n+- `1c5f0af` Add column Watch-only to transactions list\n+- `21f139b` Fix tablet crash. closes #4854\n+- `e84843c` Broken addresses on command line no longer trigger testnet\n+- `a49f11d` Change splash screen to normal window\n+- `1f9be98` Disable App Nap on OSX 10.9+\n+- `27c3e91` Add proxy to options overridden if necessary\n+- `4bd1185` Allow \"emergency\" shutdown during startup\n+- `d52f072` Don't show wallet options in the preferences menu when running with -disablewallet\n+- `6093aa1` Qt: QProgressBar CPU-Issue workaround\n+- `0ed9675` [Wallet] Add global boolean whether to send free transactions (default=true)\n+- `ed3e5e4` [Wallet] Add global boolean whether to pay at least the custom fee (default=true)\n+- `e7876b2` [Wallet] Prevent user from paying a non-sense fee\n+- `c1c9d5b` Add Smartfee to GUI\n+- `e0a25c5` Make askpassphrase dialog behave more sanely\n+- `94b362d` On close of splashscreen interrupt verifyDB\n+- `b790d13` English translation update\n+- `8543b0d` Correct tooltip on address book page\n+\n+Tests:\n+- `b41e594` Fix script test handling of empty scripts\n+- `d3a33fc` Test CHECKMULTISIG with m == 0 and n == 0\n+- `29c1749` Let tx (in)valid tests use any SCRIPT_VERIFY flag\n+- `6380180` Add rejection of non-null CHECKMULTISIG dummy values\n+- `21bf3d2` Add tests for BoostAsioToCNetAddr\n+- `b5ad5e7` Add Python test for -rpcbind and -rpcallowip\n+- `9ec0306` Add CODESEPARATOR/FindAndDelete() tests\n+- `75ebced` Added many rpc wallet tests\n+- `0193fb8` Allow multiple regression tests to run at once\n+- `92a6220` Hook up sanity checks\n+- `3820e01` Extend and move all crypto tests to crypto_tests.cpp\n+- `3f9a019` added list/get received by address/ account tests\n+- `a90689f` Remove timing-based signature cache unit test\n+- `236982c` Add skiplist unit tests\n+- `f4b00be` Add CChain::GetLocator() unit test\n+- `b45a6e8` Add test for getblocktemplate longpolling\n+- `cdf305e` Set -discover=0 in regtest framework\n+- `ed02282` additional test for OP_SIZE in script_valid.json\n+- `0072d98` script tests: BOOLAND, BOOLOR decode to integer\n+- `833ff16` script tests: values that overflow to 0 are true\n+- `4cac5db` script tests: value with trailing 0x00 is true\n+- `89101c6` script test: test case for 5-byte bools\n+- `d2d9dc0` script tests: add tests for CHECKMULTISIG limits\n+- `d789386` Add \"it works\" test for bitcoin-tx\n+- `df4d61e` Add bitcoin-tx tests\n+- `aa41ac2` Test IsPushOnly() with invalid push\n+- `6022b5d` Make `script_{valid,invalid}.json` validation flags configurable\n+- `8138cbe` Add automatic script test generation, and actual checksig tests\n+- `ed27e53` Add coins_tests with a large randomized CCoinViewCache test\n+- `9df9cf5` Make SCRIPT_VERIFY_STRICTENC compatible with BIP62\n+- `dcb9846` Extend getchaintips RPC test\n+- `554147a` Ensure MINIMALDATA invalid tests can only fail one way\n+- `dfeec18` Test every numeric-accepting opcode for correct handling of the numeric minimal encoding rule\n+- `2b62e17` Clearly separate PUSHDATA and numeric argument MINIMALDATA tests\n+- `16d78bd` Add valid invert of invalid every numeric opcode tests\n+- `f635269` tests: enable alertnotify test for Windows\n+- `7a41614` tests: allow rpc-tests to get filenames for bitcoind and bitcoin-cli from the environment\n+- `5122ea7` tests: fix forknotify.py on windows\n+- `fa7f8cd` tests: remove old pull-tester scripts\n+- `7667850` tests: replace the old (unused since Travis) tests with new rpc test scripts\n+- `f4e0aef` Do signature-s negation inside the tests\n+- `1837987` Optimize -regtest setgenerate block generation\n+- `2db4c8a` Fix node ranges in the test framework\n+- `a8b2ce5` regression test only setmocktime RPC call\n+- `daf03e7` RPC tests: create initial chain with specific timestamps\n+- `8656dbb` Port/fix txnmall.sh regression test\n+- `ca81587` Test the exact order of CHECKMULTISIG sig/pubkey evaluation\n+- `7357893` Prioritize and display -testsafemode status in UI\n+- `f321d6b` Add key generation/verification to ECC sanity check\n+- `132ea9b` miner_tests: Disable checkpoints so they don't fail the subsidy-change test\n+- `bc6cb41` QA RPC tests: Add tests block block proposals\n+- `f67a9ce` Use deterministically generated script tests\n+- `11d7a7d` [RPC] add rpc-test for http keep-alive (persistent connections)\n+- `34318d7` RPC-test based on invalidateblock for mempool coinbase spends\n+- `76ec867` Use actually valid transactions for script tests\n+- `c8589bf` Add actual signature tests\n+- `e2677d7` Fix smartfees test for change to relay policy\n+- `263b65e` tests: run sanity checks in tests too\n+\n+Miscellaneous:\n+- `122549f` Fix incorrect checkpoint data for testnet3\n+- `5bd02cf` Log used config file to debug.log on startup\n+- `68ba85f` Updated Debian example bitcoin.conf with config from wiki + removed some cruft and updated comments\n+- `e5ee8f0` Remove -beta suffix\n+- `38405ac` Add comment regarding experimental-use service bits\n+- `be873f6` Issue warning if collecting RandSeed data failed\n+- `8ae973c` Allocate more space if necessary in RandSeedAddPerfMon\n+- `675bcd5` Correct comment for 15-of-15 p2sh script size\n+- `fda3fed` libsecp256k1 integration\n+- `2e36866` Show nodeid instead of addresses in log (for anonymity) unless otherwise requested\n+- `cd01a5e` Enable paranoid corruption checks in LevelDB >= 1.16\n+- `9365937` Add comment about never updating nTimeOffset past 199 samples\n+- `403c1bf` contrib: remove getwork-based pyminer (as getwork API call has been removed)\n+- `0c3e101` contrib: Added systemd .service file in order to help distributions integrate bitcoind\n+- `0a0878d` doc: Add new DNSseed policy\n+- `2887bff` Update coding style and add .clang-format\n+- `5cbda4f` Changed LevelDB cursors to use scoped pointers to ensure destruction when going out of scope\n+- `b4a72a7` contrib/linearize: split output files based on new-timestamp-year or max-file-size\n+- `e982b57` Use explicit fflush() instead of setvbuf()\n+- `234bfbf` contrib: Add init scripts and docs for Upstart and OpenRC\n+- `01c2807` Add warning about the merkle-tree algorithm duplicate txid flaw\n+- `d6712db` Also create pid file in non-daemon mode\n+- `772ab0e` contrib: use batched JSON-RPC in linarize-hashes (optimization)\n+- `7ab4358` Update bash-completion for v0.10\n+- `6e6a36c` contrib: show pull # in prompt for github-merge script\n+- `5b9f842` Upgrade leveldb to 1.18, make chainstate databases compatible between ARM and x86 (issue #2293)\n+- `4e7c219` Catch UTXO set read errors and shutdown\n+- `867c600` Catch LevelDB errors during flush\n+- `06ca065` Fix CScriptID(const CScript& in) in empty script case\n+\n+Credits\n+=======\n+\n+Thanks to everyone who contributed to this release:\n+\n+- 21E14\n+- Adam Weiss\n+- Aitor Pazos\n+- Alexander Jeng\n+- Alex Morcos\n+- Alon Muroch\n+- Andreas Schildbach\n+- Andrew Poelstra\n+- Andy Alness\n+- Ashley Holman\n+- Benedict Chan\n+- Ben Holden-Crowther\n+- Bryan Bishop\n+- BtcDrak\n+- Christian von Roques\n+- Clinton Christian\n+- Cory Fields\n+- Cozz Lovan\n+- daniel\n+- Daniel Kraft\n+- David Hill\n+- Derek701\n+- dexX7\n+- dllud\n+- Dominyk Tiller\n+- Doug\n+- elichai\n+- elkingtowa\n+- ENikS\n+- Eric Shaw\n+- Federico Bond\n+- Francis GASCHET\n+- Gavin Andresen\n+- Giuseppe Mazzotta\n+- Glenn Willen\n+- Gregory Maxwell\n+- gubatron\n+- HarryWu\n+- himynameismartin\n+- Huang Le\n+- Ian Carroll\n+- imharrywu\n+- Jameson Lopp\n+- Janusz Lenar\n+- JaSK\n+- Jeff Garzik\n+- JL2035\n+- Johnathan Corgan\n+- Jonas Schnelli\n+- jtimon\n+- Julian Haight\n+- Kamil Domanski\n+- kazcw\n+- kevin\n+- kiwigb\n+- Kosta Zertsekel\n+- LongShao007\n+- Luke Dashjr\n+- Mark Friedenbach\n+- Mathy Vanvoorden\n+- Matt Corallo\n+- Matthew Bogosian\n+- Micha\n+- Michael Ford\n+- Mike Hearn\n+- mrbandrews\n+- mruddy\n+- ntrgn\n+- Otto Allmendinger\n+- paveljanik\n+- Pavel Vasin\n+- Peter Todd\n+- phantomcircuit\n+- Philip Kaufmann\n+- Pieter Wuille\n+- pryds\n+- randy-waterhouse\n+- R E Broadley\n+- Rose Toomey\n+- Ross Nicoll\n+- Roy Badami\n+- Ruben Dario Ponticelli\n+- Rune K. Svendsen\n+- Ryan X. Charles\n+- Saivann\n+- sandakersmann\n+- SergioDemianLerner\n+- shshshsh\n+- sinetek\n+- Stuart Cardall\n+- Suhas Daftuar\n+- Tawanda Kembo\n+- Teran McKinney\n+- tm314159\n+- Tom Harding\n+- Trevin Hofmann\n+- Whit J\n+- Wladimir J. van der Laan\n+- Yoichi Hirai\n+- Zak Wilcox\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "5e939600a06d99bddf6896a658fcfa9c4d9ba48c",
        "filename": "doc/release-notes/release-notes-0.10.1.md",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.10.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.10.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.1.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,143 @@\n+Bitcoin Core version 0.10.1 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.10.1/>\n+\n+This is a new minor version release, bringing bug fixes and translation \n+updates. It is recommended to upgrade to this version.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+Upgrading and downgrading\n+=========================\n+\n+How to Upgrade\n+--------------\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+Downgrade warning\n+------------------\n+\n+Because release 0.10.0 and later makes use of headers-first synchronization and\n+parallel block download (see further), the block files and databases are not\n+backwards-compatible with pre-0.10 versions of Bitcoin Core or other software:\n+\n+* Blocks will be stored on disk out of order (in the order they are\n+received, really), which makes it incompatible with some tools or\n+other programs. Reindexing using earlier versions will also not work\n+anymore as a result of this.\n+\n+* The block index database will now hold headers for which no block is\n+stored on disk, which earlier versions won't support.\n+\n+If you want to be able to downgrade smoothly, make a backup of your entire data\n+directory. Without this your node will need start syncing (or importing from\n+bootstrap.dat) anew afterwards. It is possible that the data from a completely\n+synchronised 0.10 node may be usable in older versions as-is, but this is not\n+supported and may break as soon as the older version attempts to reindex.\n+\n+This does not affect wallet forward or backward compatibility.\n+\n+Notable changes\n+===============\n+\n+This is a minor release and hence there are no notable changes.\n+For the notable changes in 0.10, refer to the release notes for the\n+0.10.0 release at https://github.com/bitcoin/bitcoin/blob/v0.10.0/doc/release-notes.md\n+\n+0.10.1 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect external\n+behavior, not code moves, refactors or string updates.\n+\n+RPC:\n+- `7f502be` fix crash: createmultisig and addmultisigaddress\n+- `eae305f` Fix missing lock in submitblock\n+\n+Block (database) and transaction handling:\n+- `1d2cdd2` Fix InvalidateBlock to add chainActive.Tip to setBlockIndexCandidates\n+- `c91c660` fix InvalidateBlock to repopulate setBlockIndexCandidates\n+- `002c8a2` fix possible block db breakage during re-index\n+- `a1f425b` Add (optional) consistency check for the block chain data structures\n+- `1c62e84` Keep mempool consistent during block-reorgs\n+- `57d1f46` Fix CheckBlockIndex for reindex\n+- `bac6fca` Set nSequenceId when a block is fully linked\n+\n+P2P protocol and network code:\n+- `78f64ef` don't trickle for whitelisted nodes\n+- `ca301bf` Reduce fingerprinting through timestamps in 'addr' messages.\n+- `200f293` Ignore getaddr messages on Outbound connections.\n+- `d5d8998` Limit message sizes before transfer\n+- `aeb9279` Better fingerprinting protection for non-main-chain getdatas.\n+- `cf0218f` Make addrman's bucket placement deterministic (countermeasure 1 against eclipse attacks, see http://cs-people.bu.edu/heilman/eclipse/)\n+- `0c6f334` Always use a 50% chance to choose between tried and new entries (countermeasure 2 against eclipse attacks)\n+- `214154e` Do not bias outgoing connections towards fresh addresses (countermeasure 2 against eclipse attacks)\n+- `aa587d4` Scale up addrman (countermeasure 6 against eclipse attacks)\n+- `139cd81` Cap nAttempts penalty at 8 and switch to pow instead of a division loop\n+\n+Validation:\n+- `d148f62` Acquire CCheckQueue's lock to avoid race condition\n+\n+Build system:\n+- `8752b5c` 0.10 fix for crashes on OSX 10.6\n+\n+Wallet:\n+- N/A\n+\n+GUI:\n+- `2c08406` some mac specifiy cleanup (memory handling, unnecessary code)\n+- `81145a6` fix OSX dock icon window reopening\n+- `786cf72` fix a issue where \"command line options\"-action overwrite \"Preference\"-action (on OSX)\n+\n+Tests:\n+- `1117378` add RPC test for InvalidateBlock\n+\n+Miscellaneous:\n+- `c9e022b` Initialization: set Boost path locale in main thread\n+- `23126a0` Sanitize command strings before logging them.\n+- `323de27` Initialization: setup environment before starting QT tests\n+- `7494e09` Initialization: setup environment before starting tests\n+- `df45564` Initialization: set fallback locale as environment variable\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Cory Fields\n+- dexX7\n+- fsb4000\n+- Gavin Andresen\n+- Gregory Maxwell\n+- Ivan Pustogarov\n+- Jonas Schnelli\n+- Matt Corallo\n+- mrbandrews\n+- Pieter Wuille\n+- Ruben de Vries\n+- Suhas Daftuar\n+- Wladimir J. van der Laan\n+\n+And all those who contributed additional code review and/or security research:\n+- 21E14\n+- Alison Kendler\n+- Aviv Zohar\n+- Ethan Heilman\n+- Evil-Knievel\n+- fanquake\n+- Jeff Garzik\n+- Jonas Nick\n+- Luke Dashjr\n+- Patrick Strateman\n+- Philip Kaufmann\n+- Sergio Demian Lerner\n+- Sharon Goldberg\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "192ed69d299811b8b662f28905f73479266be820",
        "filename": "doc/release-notes/release-notes-0.10.2.md",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.10.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.10.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.2.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,86 @@\n+Bitcoin Core version 0.10.2 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.10.2/>\n+\n+This is a new minor version release, bringing minor bug fixes and translation \n+updates. It is recommended to upgrade to this version.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+Upgrading and downgrading\n+=========================\n+\n+How to Upgrade\n+--------------\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+Downgrade warning\n+------------------\n+\n+Because release 0.10.0 and later makes use of headers-first synchronization and\n+parallel block download (see further), the block files and databases are not\n+backwards-compatible with pre-0.10 versions of Bitcoin Core or other software:\n+\n+* Blocks will be stored on disk out of order (in the order they are\n+received, really), which makes it incompatible with some tools or\n+other programs. Reindexing using earlier versions will also not work\n+anymore as a result of this.\n+\n+* The block index database will now hold headers for which no block is\n+stored on disk, which earlier versions won't support.\n+\n+If you want to be able to downgrade smoothly, make a backup of your entire data\n+directory. Without this your node will need start syncing (or importing from\n+bootstrap.dat) anew afterwards. It is possible that the data from a completely\n+synchronised 0.10 node may be usable in older versions as-is, but this is not\n+supported and may break as soon as the older version attempts to reindex.\n+\n+This does not affect wallet forward or backward compatibility.\n+\n+Notable changes\n+===============\n+\n+This fixes a serious problem on Windows with data directories that have non-ASCII\n+characters (https://github.com/bitcoin/bitcoin/issues/6078).\n+\n+For other platforms there are no notable changes.\n+\n+For the notable changes in 0.10, refer to the release notes\n+at https://github.com/bitcoin/bitcoin/blob/v0.10.0/doc/release-notes.md\n+\n+0.10.2 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect external\n+behavior, not code moves, refactors or string updates.\n+\n+Wallet:\n+- `824c011` fix boost::get usage with boost 1.58\n+\n+Miscellaneous:\n+- `da65606` Avoid crash on start in TestBlockValidity with gen=1.\n+- `424ae66` don't imbue boost::filesystem::path with locale \"C\" on windows (fixes #6078)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Cory Fields\n+- Gregory Maxwell\n+- Jonas Schnelli\n+- Wladimir J. van der Laan\n+\n+And all those who contributed additional code review and/or security research:\n+\n+- dexX7\n+- Pieter Wuille\n+- vayvanne\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "7ee73246a9b043d643226551b29143857e44bac9",
        "filename": "doc/release-notes/release-notes-0.9.4.md",
        "status": "added",
        "additions": 95,
        "deletions": 0,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.9.4.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.9.4.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.4.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,95 @@\n+Bitcoin Core version 0.9.4 is now available from:\n+\n+  https://bitcoin.org/bin/0.9.4/\n+\n+This is a new minor version release, bringing only bug fixes and updated\n+translations. Upgrading to this release is recommended.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  https://github.com/bitcoin/bitcoin/issues\n+\n+How to Upgrade\n+===============\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+OpenSSL Warning\n+================\n+\n+OpenSSL 1.0.0p / 1.0.1k was recently released and is being pushed out by\n+various operating system maintainers. Review by Gregory Maxwell determined that\n+this update is incompatible with the Bitcoin system and could lead to consensus\n+forks.\n+\n+Bitcoin Core released binaries from https://bitcoin.org are unaffected,\n+as are any built with the gitian deterministic build system.\n+\n+However, if you are running either\n+\n+- The Ubuntu PPA from https://launchpad.net/~bitcoin/+archive/ubuntu/bitcoin\n+- A third-party or self-compiled Bitcoin Core\n+\n+upgrade to Bitcoin Core 0.9.4, which includes a workaround, **before** updating\n+OpenSSL.\n+\n+The incompatibility is due to the OpenSSL update changing the\n+behavior of ECDSA validation to reject any signature which is\n+not encoded in a very rigid manner. This was a result of\n+OpenSSL's change for CVE-2014-8275 \"Certificate fingerprints\n+can be modified\".\n+\n+We are specifically aware of potential hard-forks due to signature\n+encoding handling and had been hoping to close them via BIP62 in 0.10.\n+BIP62's purpose is to improve transaction malleability handling and\n+as a side effect rigidly defines the encoding for signatures, but the\n+overall scope of BIP62 has made it take longer than we'd like to\n+deploy.\n+\n+0.9.4 changelog\n+================\n+\n+Validation:\n+- `b8e81b7` consensus: guard against openssl's new strict DER checks\n+- `60c51f1` fail immediately on an empty signature\n+- `037bfef` Improve robustness of DER recoding code\n+\n+Command-line options:\n+- `cd5164a` Make -proxy set all network types, avoiding a connect leak.\n+\n+P2P:\n+- `bb424e4` Limit the number of new addressses to accumulate\n+\n+RPC:\n+- `0a94661` Disable SSLv3 (in favor of TLS) for the RPC client and server.\n+\n+Build system:\n+- `f047dfa` gitian: openssl-1.0.1i.tar.gz -> openssl-1.0.1k.tar.gz\n+- `5b9f78d` build: Fix OSX build when using Homebrew and qt5\n+- `ffab1dd` Keep symlinks when copying into .app bundle\n+- `613247f` osx: fix signing to make Gatekeeper happy (again)\n+\n+Miscellaneous:\n+- `25b49b5` Refactor -alertnotify code\n+- `2743529` doc: Add instructions for consistent Mac OS X build names\n+\n+Credits\n+--------\n+\n+Thanks to who contributed to this release, at least:\n+\n+- Cory Fields\n+- Gavin Andresen\n+- Gregory Maxwell\n+- Jeff Garzik\n+- Luke Dashjr\n+- Matt Corallo\n+- Pieter Wuille\n+- Saivann\n+- Sergio Demian Lerner\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "bed0af9879bf44e651b8726426d0209c4c75ef96",
        "filename": "doc/release-notes/release-notes-0.9.5.md",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.9.5.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-notes/release-notes-0.9.5.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.5.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,60 @@\n+Bitcoin Core version 0.9.5 is now available from:\n+\n+  https://bitcoin.org/bin/0.9.5/\n+\n+This is a new minor version release, with the goal of backporting BIP66. There\n+are also a few bug fixes and updated translations. Upgrading to this release is\n+recommended.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  https://github.com/bitcoin/bitcoin/issues\n+\n+How to Upgrade\n+===============\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+Notable changes\n+================\n+\n+Mining and relay policy enhancements\n+------------------------------------\n+\n+Bitcoin Core's block templates are now for version 3 blocks only, and any mining\n+software relying on its `getblocktemplate` must be updated in parallel to use\n+libblkmaker either version 0.4.2 or any version from 0.5.1 onward.\n+If you are solo mining, this will affect you the moment you upgrade Bitcoin\n+Core, which must be done prior to BIP66 achieving its 951/1001 status.\n+If you are mining with the stratum mining protocol: this does not affect you.\n+If you are mining with the getblocktemplate protocol to a pool: this will affect\n+you at the pool operator's discretion, which must be no later than BIP66\n+achieving its 951/1001 status.\n+\n+0.9.5 changelog\n+================\n+\n+- `74f29c2` Check pindexBestForkBase for null\n+- `9cd1dd9` Fix priority calculation in CreateTransaction\n+- `6b4163b` Sanitize command strings before logging them.\n+- `3230b32` Raise version of created blocks, and enforce DERSIG in mempool\n+- `989d499` Backport of some of BIP66's tests\n+- `ab03660` Implement BIP 66 validation rules and switchover logic\n+- `8438074` build: fix dynamic boost check when --with-boost= is used\n+\n+Credits\n+--------\n+\n+Thanks to who contributed to this release, at least:\n+\n+- 21E14\n+- Alex Morcos\n+- Cory Fields\n+- Gregory Maxwell\n+- Pieter Wuille\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "cdcee0ec36da640c96695c9d10853a7b4523ce48",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 14,
        "deletions": 6,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -130,17 +130,25 @@ gpg --digest-algo sha256 --clearsign SHA256SUMS # outputs SHA256SUMS.asc\n rm SHA256SUMS\n ```\n (the digest algorithm is forced to sha256 to avoid confusion of the `Hash:` header that GPG adds with the SHA256 used for the files)\n+Note: check that SHA256SUMS itself doesn't end up in SHA256SUMS, which is a spurious/nonsensical entry.\n \n - Upload zips and installers, as well as `SHA256SUMS.asc` from last step, to the bitcoin.org server\n+  into `/var/www/bin/bitcoin-core-${VERSION}`\n \n - Update bitcoin.org version\n \n-  - Make a pull request to add a file named `YYYY-MM-DD-vX.Y.Z.md` with the release notes\n-  to https://github.com/bitcoin/bitcoin.org/tree/master/_releases\n-   ([Example for 0.9.2.1](https://raw.githubusercontent.com/bitcoin/bitcoin.org/master/_releases/2014-06-19-v0.9.2.1.md)).\n+  - First, check to see if the Bitcoin.org maintainers have prepared a\n+    release: https://github.com/bitcoin/bitcoin.org/labels/Releases\n \n-  - After the pull request is merged, the website will automatically show the newest version, as well\n-    as update the OS download links. Ping Saivann in case anything goes wrong\n+      - If they have, it will have previously failed their Travis CI\n+        checks because the final release files weren't uploaded.\n+        Trigger a Travis CI rebuild---if it passes, merge.\n+\n+  - If they have not prepared a release, follow the Bitcoin.org release\n+    instructions: https://github.com/bitcoin/bitcoin.org#release-notes\n+\n+  - After the pull request is merged, the website will automatically show the newest version within 15 minutes, as well\n+    as update the OS download links. Ping @saivann/@harding (saivann/harding on Freenode) in case anything goes wrong\n \n - Announce the release:\n \n@@ -156,4 +164,4 @@ rm SHA256SUMS\n \n - Add release notes for the new version to the directory `doc/release-notes` in git master\n \n-- Celebrate \n+- Celebrate"
      },
      {
        "sha": "3653e5302194fd8796b2468c4bc438d6c6dc6c03",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -32,7 +32,7 @@ QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n ### Creating a pull-request\n For general PRs, you shouldn\u2019t include any updates to the translation source files. They will be updated periodically, primarily around pre-releases, allowing time for any new phrases to be translated before public releases. This is also important in avoiding translation related merge conflicts.\n \n-When an updated source file is merged into the Github repo,  Transifex will automatically detect it (although it can take several hours). Once processed, the new strings will show up as \"Remaining\" in the Transifex web interface and are ready for translators.\n+When an updated source file is merged into the Github repo, Transifex will automatically detect it (although it can take several hours). Once processed, the new strings will show up as \"Remaining\" in the Transifex web interface and are ready for translators.\n \n To create the pull-request, use the following commands:\n ```\n@@ -108,4 +108,4 @@ To create a new language template, you will need to edit the languages manifest\n ### Questions and general assistance\n The Bitcoin-Core translation maintainers include *tcatm, seone, Diapolo, wumpus and luke-jr*.You can find them, and others, in the Freenode IRC chatroom - `irc.freenode.net #bitcoin-dev`.\n \n-If you are a translator, you should also subscribe to the mailing list, https://groups.google.com/forum/#!forum/bitcoin-translators. Announcements will be posted during application pre-releases to notify translators to check for updates.\n\\ No newline at end of file\n+If you are a translator, you should also subscribe to the mailing list, https://groups.google.com/forum/#!forum/bitcoin-translators. Announcements will be posted during application pre-releases to notify translators to check for updates."
      },
      {
        "sha": "6824b1d8ef4cb4e6557b578fd7a01008e9359042",
        "filename": "doc/translation_strings_policy.md",
        "status": "added",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/translation_strings_policy.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/translation_strings_policy.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_strings_policy.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,72 @@\n+Translation Strings Policy\n+===========================\n+\n+This document provides guidelines for internationalization of the Bitcoin Core software. \n+\n+How to translate?\n+------------------\n+\n+To mark a message as translatable\n+\n+- In GUI source code (under `src/qt`): use `tr(\"...\")`\n+\n+- In non-GUI source code (under `src`): use `_(\"...\")`\n+\n+No internationalization is used for e.g. developer scripts outside `src`.\n+\n+Strings to be translated\n+-------------------------\n+\n+On a high level, these strings are to be translated:\n+\n+- GUI strings, anything that appears in a dialog or window\n+\n+- Command-line option documentation\n+\n+### GUI strings\n+\n+Anything that appears to the user in the GUI is to be translated. This includes labels, menu items, button texts, tooltips and window titles.\n+This includes messages passed to the GUI through the UI interface through `InitMessage`, `ThreadSafeMessageBox` or `ShowProgress`.\n+\n+### Command-line options\n+\n+Documentation for the command line options in the output of `--help` should be translated as well.\n+\n+Make sure that default values do not end up in the string, but use string formatting like `strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), 100)`. Putting default values in strings has led to accidental translations in the past, and forces the string to be retranslated every time the value changes.\n+\n+Do not translate messages that are only shown to developers, such as those that only appear when `--help-debug` is used.\n+\n+General recommendations\n+------------------------\n+\n+### Avoid unnecessary translation strings\n+\n+Try not to burden translators with translating messages that are e.g. slight variations of other messages.\n+In the GUI, avoid the use of text where an icon or symbol will do.\n+Make sure that placeholder texts in forms don't end up in the list of strings to be translated (use `<string notr=\"true\">`).\n+\n+### Make translated strings understandable\n+\n+Try to write translation strings in an understandable way, for both the user and the translator. Avoid overly technical or detailed messages\n+\n+### Do not translate internal errors\n+\n+Do not translate internal errors, or log messages, or messages that appear on the RPC interface. If an error is to be shown to the user,\n+use a generic message, then log the detailed message to the log. E.g. \"Error: A fatal internal error occurred, see debug.log for details\".\n+This helps troubleshooting; if the error is the same for everyone, the likelihood is increased that it can be found using a search engine.\n+\n+### Avoid fragments\n+\n+Avoid dividing up a message into fragments. Translators see every string separately, so may misunderstand the context if the messages are not self-contained.\n+\n+### Avoid HTML in translation strings\n+\n+There have been difficulties with use of HTML in translation strings; translators should not be able to accidentally affect the formatting of messages.\n+This may sometimes be at conflict with the recommendation in the previous section.\n+\n+### String freezes\n+\n+During a string freeze (often before a major release), no translation strings are to be added, modified or removed.\n+\n+This can be checked by executing `make translate` in the `src` directory, then verifying that `bitcoin_en.ts` remains unchanged.\n+"
      },
      {
        "sha": "72613054b91deb68c5fdd3bb3e9e30ca563959cb",
        "filename": "doc/unit-tests.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/unit-tests.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/doc/unit-tests.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/unit-tests.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -12,7 +12,7 @@ To add more bitcoind tests, add `BOOST_AUTO_TEST_CASE` functions to the existing\n .cpp files in the test/ directory or add new .cpp files that\n implement new BOOST_AUTO_TEST_SUITE sections.\n \n-To run the bitcoin-qt tests manually, launch src/qt/test/bitcoin-qt_test\n+To run the bitcoin-qt tests manually, launch src/qt/test/test_bitcoin-qt\n \n To add more bitcoin-qt tests, add them to the `src/qt/test/` directory and\n the `src/qt/test/test_main.cpp` file."
      },
      {
        "sha": "88772a9c32b23d03323308e68f75b8e827514a78",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -22,20 +22,55 @@ testScripts=(\n     'txn_doublespend.py'\n     'txn_doublespend.py --mineblock'\n     'getchaintips.py'\n+    'rawtransactions.py'\n     'rest.py'\n     'mempool_spendcoinbase.py'\n     'mempool_coinbase_spends.py'\n     'httpbasics.py'\n     'zapwallettxes.py'\n+    'proxy_test.py'\n+    'merkle_blocks.py'\n+    'signrawtransactions.py'\n+    'walletbackup.py'\n+);\n+testScriptsExt=(\n+    'bipdersig-p2p.py'\n+    'bipdersig.py'\n+    'getblocktemplate_longpoll.py'\n+    'getblocktemplate_proposals.py'\n+    'pruning.py'\n+    'forknotify.py'\n+    'invalidateblock.py'\n+    'keypool.py'\n+    'receivedby.py'\n+    'reindex.py'\n+    'rpcbind_test.py'\n+#   'script_test.py'\n+    'smartfees.py'\n+    'maxblocksinflight.py'\n+    'invalidblockrequest.py'\n+    'rawtransactions.py'\n #    'forknotify.py'\n );\n+\n+extArg=\"-extended\"\n+passOn=${@#$extArg}\n+\n if [ \"x${ENABLE_BITCOIND}${ENABLE_UTILS}${ENABLE_WALLET}\" = \"x111\" ]; then\n     for (( i = 0; i < ${#testScripts[@]}; i++ ))\n     do\n-        if [ -z \"$1\" ] || [ \"$1\" == \"${testScripts[$i]}\" ] || [ \"$1.py\" == \"${testScripts[$i]}\" ]\n+        if [ -z \"$1\" ] || [ \"${1:0:1}\" == \"-\" ] || [ \"$1\" == \"${testScripts[$i]}\" ] || [ \"$1.py\" == \"${testScripts[$i]}\" ]\n         then\n             echo -e \"Running testscript \\033[1m${testScripts[$i]}...\\033[0m\"\n-            ${BUILDDIR}/qa/rpc-tests/${testScripts[$i]} --srcdir \"${BUILDDIR}/src\"\n+            ${BUILDDIR}/qa/rpc-tests/${testScripts[$i]} --srcdir \"${BUILDDIR}/src\" ${passOn}\n+        fi\n+    done\n+    for (( i = 0; i < ${#testScriptsExt[@]}; i++ ))\n+    do\n+        if [ \"$1\" == $extArg ] || [ \"$1\" == \"${testScriptsExt[$i]}\" ] || [ \"$1.py\" == \"${testScriptsExt[$i]}\" ]\n+        then\n+            echo -e \"Running \\033[1m2nd level\\033[0m testscript \\033[1m${testScriptsExt[$i]}...\\033[0m\"\n+            ${BUILDDIR}/qa/rpc-tests/${testScriptsExt[$i]} --srcdir \"${BUILDDIR}/src\" ${passOn}\n         fi\n     done\n else"
      },
      {
        "sha": "6221c93d8b93aaf98a59cdce184e34514a34c756",
        "filename": "qa/rpc-tests/README.md",
        "status": "modified",
        "additions": 21,
        "deletions": 9,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/README.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,29 +6,41 @@ Git subtree of [https://github.com/jgarzik/python-bitcoinrpc](https://github.com\n Changes to python-bitcoinrpc should be made upstream, and then\n pulled here using git subtree.\n \n-### [test_framework.py](test_framework.py)\n+### [test_framework/test_framework.py](test_framework/test_framework.py)\n Base class for new regression tests.\n \n-### [listtransactions.py](listtransactions.py)\n-Tests for the listtransactions RPC call.\n-\n-### [util.py](util.sh)\n+### [test_framework/util.py](test_framework/util.py)\n Generally useful functions.\n \n Bash-based tests, to be ported to Python:\n -----------------------------------------\n-- wallet.sh : Exercise wallet send/receive code.\n-- walletbackup.sh : Exercise wallet backup / dump / import\n-- txnmall.sh : Test proper accounting of malleable transactions\n - conflictedbalance.sh : More testing of malleable transaction handling\n \n Notes\n =====\n \n+You can run a single test by calling `qa/pull-tester/rpc-tests.sh <testname>`.\n+\n+Run all possible tests with `qa/pull-tester/rpc-tests.sh -extended`.\n+\n+Possible options:\n+\n+````\n+-h, --help       show this help message and exit\n+  --nocleanup      Leave bitcoinds and test.* datadir on exit or error\n+  --noshutdown     Don't stop bitcoinds after the test execution\n+  --srcdir=SRCDIR  Source directory containing bitcoind/bitcoin-cli (default:\n+                   ../../src)\n+  --tmpdir=TMPDIR  Root directory for datadirs\n+  --tracerpc       Print out all RPC calls as they are made\n+```\n+\n+If you set the environment variable `PYTHON_DEBUG=1` you will get some debug output (example: `PYTHON_DEBUG=1 qa/pull-tester/rpc-tests.sh wallet`). \n+\n A 200-block -regtest blockchain and wallets for four nodes\n is created the first time a regression test is run and\n is stored in the cache/ directory. Each node has 25 mature\n-blocks (25*50=1250 BTC) in their wallet.\n+blocks (25*50=1250 BTC) in its wallet.\n \n After the first run, the cache/ blockchain and wallets are\n copied into a temporary directory and used as the initial"
      },
      {
        "sha": "41717377b217a90fcd123cfd0da1d11ec71af9fa",
        "filename": "qa/rpc-tests/bipdersig-p2p.py",
        "status": "added",
        "additions": 183,
        "deletions": 0,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig-p2p.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,183 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import CScript\n+from binascii import hexlify, unhexlify\n+import cStringIO\n+import time\n+\n+# A canonical signature consists of: \n+# <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n+def unDERify(tx):\n+    '''\n+    Make the signature in vin 0 of a tx non-DER-compliant,\n+    by adding padding after the S-value.\n+    '''\n+    scriptSig = CScript(tx.vin[0].scriptSig)\n+    newscript = []\n+    for i in scriptSig:\n+        if (len(newscript) == 0):\n+            newscript.append(i[0:-1] + '\\0' + i[-1])\n+        else:\n+            newscript.append(i)\n+    tx.vin[0].scriptSig = CScript(newscript)\n+    \n+'''\n+This test is meant to exercise BIP66 (DER SIG).\n+Connect to a single node.\n+Mine 2 (version 2) blocks (save the coinbases for later).\n+Generate 98 more version 2 blocks, verify the node accepts.\n+Mine 749 version 3 blocks, verify the node accepts.\n+Check that the new DERSIG rules are not enforced on the 750th version 3 block.\n+Check that the new DERSIG rules are enforced on the 751st version 3 block.\n+Mine 199 new version blocks.\n+Mine 1 old-version block.\n+Mine 1 new version block.\n+Mine 1 old version block, see that the node rejects.\n+'''\n+            \n+class BIP66Test(ComparisonTestFramework):\n+\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir, \n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=2']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def create_transaction(self, node, coinbase, to_address, amount):\n+        from_txid = node.getblock(coinbase)['tx'][0]\n+        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def get_tests(self):\n+\n+        self.coinbase_blocks = self.nodes[0].generate(2)\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+        self.last_block_time = time.time()\n+\n+        ''' 98 more version 2 blocks '''\n+        test_blocks = []\n+        for i in xrange(98):\n+            block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+            block.nVersion = 2\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        ''' Mine 749 version 3 blocks '''\n+        test_blocks = []\n+        for i in xrange(749):\n+            block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+            block.nVersion = 3\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        ''' \n+        Check that the new DERSIG rules are not enforced in the 750th\n+        version 3 block.\n+        '''\n+        spendtx = self.create_transaction(self.nodes[0],\n+                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n+        unDERify(spendtx)\n+        spendtx.rehash()\n+\n+        block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+\n+        self.last_block_time += 1\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        ''' \n+        Check that the new DERSIG rules are enforced in the 751st version 3\n+        block.\n+        '''\n+        spendtx = self.create_transaction(self.nodes[0],\n+                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+        unDERify(spendtx)\n+        spendtx.rehash()\n+\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        yield TestInstance([[block, False]])\n+\n+        ''' Mine 199 new version blocks on last valid tip '''\n+        test_blocks = []\n+        for i in xrange(199):\n+            block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+            block.nVersion = 3\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        ''' Mine 1 old version block '''\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 2\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        ''' Mine 1 new version block '''\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        ''' Mine 1 old version block, should be invalid '''\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 2\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        yield TestInstance([[block, False]])\n+\n+if __name__ == '__main__':\n+    BIP66Test().main()"
      },
      {
        "sha": "243f816f652647739a8f3833fbede7f3f96f4478",
        "filename": "qa/rpc-tests/bipdersig.py",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/bipdersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/bipdersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,89 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test the BIP66 changeover logic\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import os\n+import shutil\n+\n+class BIP66Test(BitcoinTestFramework):\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, []))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockversion=2\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockversion=3\"]))\n+        connect_nodes(self.nodes[1], 0)\n+        connect_nodes(self.nodes[2], 0)\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        cnt = self.nodes[0].getblockcount()\n+\n+        # Mine some old-version blocks\n+        self.nodes[1].generate(100)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 100):\n+            raise AssertionError(\"Failed to mine 100 version=2 blocks\")\n+\n+        # Mine 750 new-version blocks\n+        for i in xrange(15):\n+            self.nodes[2].generate(50)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 850):\n+            raise AssertionError(\"Failed to mine 750 version=3 blocks\")\n+\n+        # TODO: check that new DERSIG rules are not enforced\n+\n+        # Mine 1 new-version block\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 851):\n+            raise AssertionFailure(\"Failed to mine a version=3 blocks\")\n+\n+        # TODO: check that new DERSIG rules are enforced\n+\n+        # Mine 198 new-version blocks\n+        for i in xrange(2):\n+            self.nodes[2].generate(99)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 1049):\n+            raise AssertionError(\"Failed to mine 198 version=3 blocks\")\n+\n+        # Mine 1 old-version block\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 1050):\n+            raise AssertionError(\"Failed to mine a version=2 block after 949 version=3 blocks\")\n+\n+        # Mine 1 new-version blocks\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 1051):\n+            raise AssertionError(\"Failed to mine a version=3 block\")\n+\n+        # Mine 1 old-version blocks\n+        try:\n+            self.nodes[1].generate(1)\n+            raise AssertionError(\"Succeeded to mine a version=2 block after 950 version=3 blocks\")\n+        except JSONRPCException:\n+            pass\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 1051):\n+            raise AssertionError(\"Accepted a version=2 block after 950 version=3 blocks\")\n+\n+        # Mine 1 new-version blocks\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        if (self.nodes[0].getblockcount() != cnt + 1052):\n+            raise AssertionError(\"Failed to mine a version=3 block\")\n+\n+if __name__ == '__main__':\n+    BIP66Test().main()"
      },
      {
        "sha": "7e4409737437a139b105a0c83e295d1de5a34acb",
        "filename": "qa/rpc-tests/conflictedbalance.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/conflictedbalance.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/conflictedbalance.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/conflictedbalance.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -49,7 +49,7 @@ B2ARGS=\"-datadir=$D2 -debug=mempool\"\n $BITCOIND $B2ARGS &\n B2PID=$!\n \n-# Wait until all four nodes are at the same block number\n+# Wait until both nodes are at the same block number\n function WaitBlocks {\n     while :\n     do\n@@ -84,11 +84,11 @@ WaitPeers \"$B1ARGS\" 1\n \n # 2 block, 50 XBT each == 100 XBT\n # These will be transactions \"A\" and \"B\"\n-$CLI $B1ARGS setgenerate true 2\n+$CLI $B1ARGS generate 2\n \n WaitBlocks\n # 100 blocks, 0 mature == 0 XBT\n-$CLI $B2ARGS setgenerate true 100\n+$CLI $B2ARGS generate 100\n WaitBlocks\n \n CheckBalance \"$B1ARGS\" 100\n@@ -130,7 +130,7 @@ WaitPeers \"$B1ARGS\" 1\n \n # Having B2 mine the next block puts the mutated\n # transaction C in the chain:\n-$CLI $B2ARGS setgenerate true 1\n+$CLI $B2ARGS generate 1\n WaitBlocks\n \n # B1 should still be able to spend 100, because D is conflicted"
      },
      {
        "sha": "0acef8e30b650bdbe4907f32b1bf15fe4a63d4ba",
        "filename": "qa/rpc-tests/forknotify.py",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/forknotify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/forknotify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/forknotify.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,9 +7,8 @@\n # Test -alertnotify \n #\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n import os\n import shutil\n \n@@ -34,12 +33,12 @@ def setup_network(self):\n \n     def run_test(self):\n         # Mine 51 up-version blocks\n-        self.nodes[1].setgenerate(True, 51)\n+        self.nodes[1].generate(51)\n         self.sync_all()\n         # -alertnotify should trigger on the 51'st,\n         # but mine and sync another to give\n         # -alertnotify time to write\n-        self.nodes[1].setgenerate(True, 1)\n+        self.nodes[1].generate(1)\n         self.sync_all()\n \n         with open(self.alert_filename, 'r') as f:\n@@ -49,9 +48,9 @@ def run_test(self):\n             raise AssertionError(\"-alertnotify did not warn of up-version blocks\")\n \n         # Mine more up-version blocks, should not get more alerts:\n-        self.nodes[1].setgenerate(True, 1)\n+        self.nodes[1].generate(1)\n         self.sync_all()\n-        self.nodes[1].setgenerate(True, 1)\n+        self.nodes[1].generate(1)\n         self.sync_all()\n \n         with open(self.alert_filename, 'r') as f:"
      },
      {
        "sha": "aab456242288f9ea2c5b7ce54cbf07d479f5257e",
        "filename": "qa/rpc-tests/getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getblocktemplate_longpoll.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -3,9 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n \n \n def check_array_result(object_array, to_match, expected):\n@@ -51,7 +50,7 @@ class GetBlockTemplateLPTest(BitcoinTestFramework):\n \n     def run_test(self):\n         print \"Warning: this test will take about 70 seconds in the best case. Be patient.\"\n-        self.nodes[0].setgenerate(True, 10)\n+        self.nodes[0].generate(10)\n         templat = self.nodes[0].getblocktemplate()\n         longpollid = templat['longpollid']\n         # longpollid should not change between successive invocations if nothing else happens\n@@ -66,15 +65,15 @@ def run_test(self):\n         assert(thr.is_alive())\n \n         # Test 2: test that longpoll will terminate if another node generates a block\n-        self.nodes[1].setgenerate(True, 1)  # generate a block on another node\n+        self.nodes[1].generate(1)  # generate a block on another node\n         # check that thread will exit now that new transaction entered mempool\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert(not thr.is_alive())\n \n         # Test 3: test that longpoll will terminate if we generate a block ourselves\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n-        self.nodes[0].setgenerate(True, 1)  # generate a block on another node\n+        self.nodes[0].generate(1)  # generate a block on another node\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert(not thr.is_alive())\n "
      },
      {
        "sha": "aca0cd7495d2881bf7c62a70a8779404e802bfe9",
        "filename": "qa/rpc-tests/getblocktemplate_proposals.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/getblocktemplate_proposals.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/getblocktemplate_proposals.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getblocktemplate_proposals.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -3,9 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n \n from binascii import a2b_hex, b2a_hex\n from hashlib import sha256\n@@ -95,6 +94,7 @@ class GetBlockTemplateProposalTest(BitcoinTestFramework):\n \n     def run_test(self):\n         node = self.nodes[0]\n+        node.generate(1) # Mine a block to leave initial block download\n         tmpl = node.getblocktemplate()\n         if 'coinbasetxn' not in tmpl:\n             rawcoinbase = encodeUNum(tmpl['height'])"
      },
      {
        "sha": "6a2bcb2969731fdc9e8b35e2ab79e291edefd327",
        "filename": "qa/rpc-tests/getchaintips.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getchaintips.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,8 +7,8 @@\n # on chains of different lengths, and join the network together again.\n # This gives us two tips, verify that it works.\n \n-from test_framework import BitcoinTestFramework\n-from util import assert_equal\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n \n class GetChainTipsTest (BitcoinTestFramework):\n \n@@ -23,8 +23,8 @@ def run_test (self):\n \n         # Split the network and build two chains of different lengths.\n         self.split_network ()\n-        self.nodes[0].setgenerate (True, 10);\n-        self.nodes[2].setgenerate (True, 20);\n+        self.nodes[0].generate(10);\n+        self.nodes[2].generate(20);\n         self.sync_all ()\n \n         tips = self.nodes[1].getchaintips ()"
      },
      {
        "sha": "64ba49df64d43e6bb1bd5c84900caf20da48e663",
        "filename": "qa/rpc-tests/httpbasics.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/httpbasics.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/httpbasics.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/httpbasics.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,8 +7,8 @@\n # Test REST interface\n #\n \n-from test_framework import BitcoinTestFramework\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n import base64\n \n try:"
      },
      {
        "sha": "2b9c8154e0384db6a276199e9214c351a9da7291",
        "filename": "qa/rpc-tests/invalidateblock.py",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/invalidateblock.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,75 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test InvalidateBlock code\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class InvalidateTest(BitcoinTestFramework):\n+    \n+        \n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+                 \n+    def setup_network(self):\n+        self.nodes = []\n+        self.is_network_split = False \n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        \n+    def run_test(self):\n+        print \"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\"\n+        print \"Mine 4 blocks on Node 0\"\n+        self.nodes[0].generate(4)\n+        assert(self.nodes[0].getblockcount() == 4)\n+        besthash = self.nodes[0].getbestblockhash()\n+\n+        print \"Mine competing 6 blocks on Node 1\"\n+        self.nodes[1].generate(6)\n+        assert(self.nodes[1].getblockcount() == 6)\n+\n+        print \"Connect nodes to force a reorg\"\n+        connect_nodes_bi(self.nodes,0,1)\n+        sync_blocks(self.nodes[0:2])\n+        assert(self.nodes[0].getblockcount() == 6)\n+        badhash = self.nodes[1].getblockhash(2)\n+\n+        print \"Invalidate block 2 on node 0 and verify we reorg to node 0's original chain\"\n+        self.nodes[0].invalidateblock(badhash)\n+        newheight = self.nodes[0].getblockcount()\n+        newhash = self.nodes[0].getbestblockhash()\n+        if (newheight != 4 or newhash != besthash):\n+            raise AssertionError(\"Wrong tip for node0, hash %s, height %d\"%(newhash,newheight))\n+\n+        print \"\\nMake sure we won't reorg to a lower work chain:\"\n+        connect_nodes_bi(self.nodes,1,2)\n+        print \"Sync node 2 to node 1 so both have 6 blocks\"\n+        sync_blocks(self.nodes[1:3])\n+        assert(self.nodes[2].getblockcount() == 6)\n+        print \"Invalidate block 5 on node 1 so its tip is now at 4\"\n+        self.nodes[1].invalidateblock(self.nodes[1].getblockhash(5))\n+        assert(self.nodes[1].getblockcount() == 4)\n+        print \"Invalidate block 3 on node 2, so its tip is now 2\"\n+        self.nodes[2].invalidateblock(self.nodes[2].getblockhash(3))\n+        assert(self.nodes[2].getblockcount() == 2)\n+        print \"..and then mine a block\"\n+        self.nodes[2].generate(1)\n+        print \"Verify all nodes are at the right height\"\n+        time.sleep(5)\n+        for i in xrange(3):\n+            print i,self.nodes[i].getblockcount()\n+        assert(self.nodes[2].getblockcount() == 3)\n+        assert(self.nodes[0].getblockcount() == 4)\n+        node1height = self.nodes[1].getblockcount()\n+        if node1height < 4:\n+            raise AssertionError(\"Node 1 reorged to a lower height: %d\"%node1height)\n+\n+if __name__ == '__main__':\n+    InvalidateTest().main()"
      },
      {
        "sha": "64b8e263957921601518d3e33c8f4370dfbe7df7",
        "filename": "qa/rpc-tests/invalidblockrequest.py",
        "status": "added",
        "additions": 115,
        "deletions": 0,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/invalidblockrequest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/invalidblockrequest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/invalidblockrequest.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,115 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.comptool import TestManager, TestInstance\n+from test_framework.mininode import *\n+from test_framework.blocktools import *\n+import logging\n+import copy\n+import time\n+\n+\n+'''\n+In this test we connect to one node over p2p, and test block requests:\n+1) Valid blocks should be requested and become chain tip.\n+2) Invalid block with duplicated transaction should be re-requested.\n+3) Invalid block with bad coinbase value should be rejected and not\n+re-requested.\n+'''\n+\n+# Use the ComparisonTestFramework with 1 node: only use --testbinary.\n+class InvalidBlockRequestTest(ComparisonTestFramework):\n+\n+    ''' Can either run this test as 1 node with expected answers, or two and compare them. \n+        Change the \"outcome\" variable from each TestInstance object to only do the comparison. '''\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        self.tip = None\n+        self.block_time = None\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def get_tests(self):\n+        if self.tip is None:\n+            self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.block_time = int(time.time())+1\n+\n+        '''\n+        Create a new block with an anyone-can-spend coinbase\n+        '''\n+        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block.solve()\n+        # Save the coinbase for later\n+        self.block1 = block\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        '''\n+        Now we need that block to mature so we can spend the coinbase.\n+        '''\n+        test = TestInstance(sync_every_block=False)\n+        for i in xrange(100):\n+            block = create_block(self.tip, create_coinbase(), self.block_time)\n+            block.solve()\n+            self.tip = block.sha256\n+            self.block_time += 1\n+            test.blocks_and_transactions.append([block, True])\n+        yield test\n+\n+        '''\n+        Now we use merkle-root malleability to generate an invalid block with\n+        same blockheader.\n+        Manufacture a block with 3 transactions (coinbase, spend of prior\n+        coinbase, spend of that spend).  Duplicate the 3rd transaction to \n+        leave merkle root and blockheader unchanged but invalidate the block.\n+        '''\n+        block2 = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+\n+        # chr(81) is OP_TRUE\n+        tx1 = create_transaction(self.block1.vtx[0], 0, chr(81), 50*100000000)\n+        tx2 = create_transaction(tx1, 0, chr(81), 50*100000000)\n+\n+        block2.vtx.extend([tx1, tx2])\n+        block2.hashMerkleRoot = block2.calc_merkle_root()\n+        block2.rehash()\n+        block2.solve()\n+        orig_hash = block2.sha256\n+        block2_orig = copy.deepcopy(block2)\n+\n+        # Mutate block 2\n+        block2.vtx.append(tx2)\n+        assert_equal(block2.hashMerkleRoot, block2.calc_merkle_root())\n+        assert_equal(orig_hash, block2.rehash())\n+        assert(block2_orig.vtx != block2.vtx)\n+\n+        self.tip = block2.sha256\n+        yield TestInstance([[block2, False], [block2_orig, True]])\n+\n+        '''\n+        Make sure that a totally screwed up block is not valid.\n+        '''\n+        block3 = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block3.vtx[0].vout[0].nValue = 100*100000000 # Too high!\n+        block3.vtx[0].sha256=None\n+        block3.vtx[0].calc_sha256()\n+        block3.hashMerkleRoot = block3.calc_merkle_root()\n+        block3.rehash()\n+        block3.solve()\n+\n+        yield TestInstance([[block3, False]])\n+\n+\n+if __name__ == '__main__':\n+    InvalidBlockRequestTest().main()"
      },
      {
        "sha": "aee29a596ae011d3a6cc07a6323ceddc7095ef53",
        "filename": "qa/rpc-tests/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/keypool.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,16 +8,14 @@\n # Add python-bitcoinrpc to module search path:\n import os\n import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n \n import json\n import shutil\n import subprocess\n import tempfile\n import traceback\n \n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.util import *\n \n \n def check_array_result(object_array, to_match, expected):"
      },
      {
        "sha": "eeae2d2fa2f47d9995d03f2da36ad1c267b22bac",
        "filename": "qa/rpc-tests/listtransactions.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/listtransactions.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,9 +5,8 @@\n \n # Exercise the listtransactions API\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n \n \n def check_array_result(object_array, to_match, expected):\n@@ -44,7 +43,7 @@ def run_test(self):\n                            {\"txid\":txid},\n                            {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":0})\n         # mine a block, confirmations should change:\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         self.sync_all()\n         check_array_result(self.nodes[0].listtransactions(),\n                            {\"txid\":txid},"
      },
      {
        "sha": "a601147ce832f024f5d1e7d680e931aa6916457c",
        "filename": "qa/rpc-tests/maxblocksinflight.py",
        "status": "added",
        "additions": 101,
        "deletions": 0,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxblocksinflight.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,101 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import logging\n+\n+'''\n+In this test we connect to one node over p2p, send it numerous inv's, and\n+compare the resulting number of getdata requests to a max allowed value.  We\n+test for exceeding 128 blocks in flight, which was the limit an 0.9 client will\n+reach. [0.10 clients shouldn't request more than 16 from a single peer.]\n+'''\n+MAX_REQUESTS = 128\n+\n+class TestManager(NodeConnCB):\n+    # set up NodeConnCB callbacks, overriding base class\n+    def on_getdata(self, conn, message):\n+        self.log.debug(\"got getdata %s\" % repr(message))\n+        # Log the requests\n+        for inv in message.inv:\n+            if inv.hash not in self.blockReqCounts:\n+                self.blockReqCounts[inv.hash] = 0\n+            self.blockReqCounts[inv.hash] += 1\n+\n+    def on_close(self, conn):\n+        if not self.disconnectOkay:\n+            raise EarlyDisconnectError(0)\n+\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.log = logging.getLogger(\"BlockRelayTest\")\n+        self.create_callback_map()\n+\n+    def add_new_connection(self, connection):\n+        self.connection = connection\n+        self.blockReqCounts = {}\n+        self.disconnectOkay = False\n+\n+    def run(self):\n+        try:\n+            fail = False\n+            self.connection.rpc.generate(1) # Leave IBD\n+\n+            numBlocksToGenerate = [ 8, 16, 128, 1024 ]\n+            for count in range(len(numBlocksToGenerate)):\n+                current_invs = []\n+                for i in range(numBlocksToGenerate[count]):\n+                    current_invs.append(CInv(2, random.randrange(0, 1<<256)))\n+                    if len(current_invs) >= 50000:\n+                        self.connection.send_message(msg_inv(current_invs))\n+                        current_invs = []\n+                if len(current_invs) > 0:\n+                    self.connection.send_message(msg_inv(current_invs))\n+                \n+                # Wait and see how many blocks were requested\n+                time.sleep(2)\n+\n+                total_requests = 0\n+                with mininode_lock:\n+                    for key in self.blockReqCounts:\n+                        total_requests += self.blockReqCounts[key]\n+                        if self.blockReqCounts[key] > 1:\n+                            raise AssertionError(\"Error, test failed: block %064x requested more than once\" % key)\n+                if total_requests > MAX_REQUESTS:\n+                    raise AssertionError(\"Error, too many blocks (%d) requested\" % total_requests)\n+                print \"Round %d: success (total requests: %d)\" % (count, total_requests)\n+        except AssertionError as e:\n+            print \"TEST FAILED: \", e.args\n+\n+        self.disconnectOkay = True\n+        self.connection.disconnect_node()\n+\n+        \n+class MaxBlocksInFlightTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n+                          help=\"Binary to test max block requests behavior\")\n+\n+    def setup_chain(self):\n+        print \"Initializing test directory \"+self.options.tmpdir\n+        initialize_chain_clean(self.options.tmpdir, 1)\n+\n+    def setup_network(self):\n+        self.nodes = start_nodes(1, self.options.tmpdir, \n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager()\n+        test.add_new_connection(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test))\n+        NetworkThread().start()  # Start up network handling in another thread\n+        test.run()\n+\n+if __name__ == '__main__':\n+    MaxBlocksInFlightTest().main()"
      },
      {
        "sha": "c64a15b9f5d31e794869e99cb27e130a956c252f",
        "filename": "qa/rpc-tests/mempool_coinbase_spends.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/mempool_coinbase_spends.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/mempool_coinbase_spends.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_coinbase_spends.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,9 +8,8 @@\n # that spend (directly or indirectly) coinbase transactions.\n #\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n import os\n import shutil\n \n@@ -41,7 +40,7 @@ def run_test(self):\n \n         # Mine three blocks. After this, nodes[0] blocks\n         # 101, 102, and 103 are spend-able.\n-        new_blocks = self.nodes[1].setgenerate(True, 4)\n+        new_blocks = self.nodes[1].generate(4)\n         self.sync_all()\n \n         node0_address = self.nodes[0].getnewaddress()\n@@ -62,15 +61,15 @@ def run_test(self):\n         # Broadcast and mine spend_102 and 103:\n         spend_102_id = self.nodes[0].sendrawtransaction(spend_102_raw)\n         spend_103_id = self.nodes[0].sendrawtransaction(spend_103_raw)\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n \n         # Create 102_1 and 103_1:\n         spend_102_1_raw = self.create_tx(spend_102_id, node1_address, 50)\n         spend_103_1_raw = self.create_tx(spend_103_id, node1_address, 50)\n \n         # Broadcast and mine 103_1:\n         spend_103_1_id = self.nodes[0].sendrawtransaction(spend_103_1_raw)\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n \n         # ... now put spend_101 and spend_102_1 in memory pools:\n         spend_101_id = self.nodes[0].sendrawtransaction(spend_101_raw)"
      },
      {
        "sha": "19c74bb751409607f324e78b14cbf2d28fed5149",
        "filename": "qa/rpc-tests/mempool_resurrect_test.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/mempool_resurrect_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/mempool_resurrect_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_resurrect_test.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,9 +8,8 @@\n # the blockchain is re-organized.\n #\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n import os\n import shutil\n \n@@ -34,7 +33,6 @@ def create_tx(self, from_txid, to_address, amount):\n \n     def run_test(self):\n         node0_address = self.nodes[0].getnewaddress()\n-\n         # Spend block 1/2/3's coinbase transactions\n         # Mine a block.\n         # Create three more transactions, spending the spends\n@@ -51,12 +49,12 @@ def run_test(self):\n         spends1_id = [ self.nodes[0].sendrawtransaction(tx) for tx in spends1_raw ]\n \n         blocks = []\n-        blocks.extend(self.nodes[0].setgenerate(True, 1))\n+        blocks.extend(self.nodes[0].generate(1))\n \n         spends2_raw = [ self.create_tx(txid, node0_address, 49.99) for txid in spends1_id ]\n         spends2_id = [ self.nodes[0].sendrawtransaction(tx) for tx in spends2_raw ]\n \n-        blocks.extend(self.nodes[0].setgenerate(True, 1))\n+        blocks.extend(self.nodes[0].generate(1))\n \n         # mempool should be empty, all txns confirmed\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n@@ -76,7 +74,7 @@ def run_test(self):\n             assert(tx[\"confirmations\"] == 0)\n \n         # Generate another block, they should all get mined\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         # mempool should be empty, all txns confirmed\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n         for txid in spends1_id+spends2_id:"
      },
      {
        "sha": "fc17c50692fb4bf50a3809c1325ee24c32dc40f8",
        "filename": "qa/rpc-tests/mempool_spendcoinbase.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/mempool_spendcoinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/mempool_spendcoinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_spendcoinbase.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -13,9 +13,8 @@\n # but less mature coinbase spends are NOT.\n #\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n import os\n import shutil\n \n@@ -58,7 +57,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getrawmempool(), [ spend_101_id ])\n \n         # mine a block, spend_101 should get confirmed\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n \n         # ... and now height 102 can be spent:"
      },
      {
        "sha": "72a80ce6ca5fc8243ed076c2fefa94c5f8cb31c6",
        "filename": "qa/rpc-tests/merkle_blocks.py",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/merkle_blocks.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,89 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test merkleblock fetch/validation\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import os\n+import shutil\n+\n+class MerkleBlockTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+        assert_equal(self.nodes[1].getbalance(), 0)\n+        assert_equal(self.nodes[2].getbalance(), 0)\n+\n+        node0utxos = self.nodes[0].listunspent(1)\n+        tx1 = self.nodes[0].createrawtransaction([node0utxos.pop()], {self.nodes[1].getnewaddress(): 50})\n+        txid1 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx1)[\"hex\"])\n+        tx2 = self.nodes[0].createrawtransaction([node0utxos.pop()], {self.nodes[1].getnewaddress(): 50})\n+        txid2 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx2)[\"hex\"])\n+        assert_raises(JSONRPCException, self.nodes[0].gettxoutproof, [txid1])\n+\n+        self.nodes[0].generate(1)\n+        blockhash = self.nodes[0].getblockhash(chain_height + 1)\n+        self.sync_all()\n+\n+        txlist = []\n+        blocktxn = self.nodes[0].getblock(blockhash, True)[\"tx\"]\n+        txlist.append(blocktxn[1])\n+        txlist.append(blocktxn[2])\n+\n+        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1])), [txid1])\n+        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2])), txlist)\n+        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2], blockhash)), txlist)\n+\n+        txin_spent = self.nodes[1].listunspent(1).pop()\n+        tx3 = self.nodes[1].createrawtransaction([txin_spent], {self.nodes[0].getnewaddress(): 50})\n+        self.nodes[0].sendrawtransaction(self.nodes[1].signrawtransaction(tx3)[\"hex\"])\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txid_spent = txin_spent[\"txid\"]\n+        txid_unspent = txid1 if txin_spent[\"txid\"] != txid1 else txid2\n+\n+        # We cant find the block from a fully-spent tx\n+        assert_raises(JSONRPCException, self.nodes[2].gettxoutproof, [txid_spent])\n+        # ...but we can if we specify the block\n+        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_spent], blockhash)), [txid_spent])\n+        # ...or if the first tx is not fully-spent\n+        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_unspent])), [txid_unspent])\n+        try:\n+            assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2])), txlist)\n+        except JSONRPCException:\n+            assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid2, txid1])), txlist)\n+        # ...or if we have a -txindex\n+        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[3].gettxoutproof([txid_spent])), [txid_spent])\n+\n+if __name__ == '__main__':\n+    MerkleBlockTest().main()"
      },
      {
        "sha": "9a9b2f53007d4d4e90573cfa0f869f1c4e34068d",
        "filename": "qa/rpc-tests/proxy_test.py",
        "status": "added",
        "additions": 146,
        "deletions": 0,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/proxy_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/proxy_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/proxy_test.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,146 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+import socket\n+import traceback, sys\n+from binascii import hexlify\n+import time, os\n+\n+from test_framework.socks5 import Socks5Configuration, Socks5Command, Socks5Server, AddressType\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+'''\n+Test plan:\n+- Start bitcoind's with different proxy configurations\n+- Use addnode to initiate connections\n+- Verify that proxies are connected to, and the right connection command is given\n+- Proxy configurations to test on bitcoind side:\n+    - `-proxy` (proxy everything)\n+    - `-onion` (proxy just onions)\n+    - `-proxyrandomize` Circuit randomization\n+- Proxy configurations to test on proxy side,\n+    - support no authentication (other proxy)\n+    - support no authentication + user/pass authentication (Tor)\n+    - proxy on IPv6\n+\n+- Create various proxies (as threads)\n+- Create bitcoinds that connect to them\n+- Manipulate the bitcoinds using addnode (onetry) an observe effects\n+\n+addnode connect to IPv4\n+addnode connect to IPv6\n+addnode connect to onion\n+addnode connect to generic DNS name\n+'''\n+\n+class ProxyTest(BitcoinTestFramework):        \n+    def __init__(self):\n+        # Create two proxies on different ports\n+        # ... one unauthenticated\n+        self.conf1 = Socks5Configuration()\n+        self.conf1.addr = ('127.0.0.1', 13000 + (os.getpid() % 1000))\n+        self.conf1.unauth = True\n+        self.conf1.auth = False\n+        # ... one supporting authenticated and unauthenticated (Tor)\n+        self.conf2 = Socks5Configuration()\n+        self.conf2.addr = ('127.0.0.1', 14000 + (os.getpid() % 1000))\n+        self.conf2.unauth = True\n+        self.conf2.auth = True\n+        # ... one on IPv6 with similar configuration\n+        self.conf3 = Socks5Configuration()\n+        self.conf3.af = socket.AF_INET6\n+        self.conf3.addr = ('::1', 15000 + (os.getpid() % 1000))\n+        self.conf3.unauth = True\n+        self.conf3.auth = True\n+\n+        self.serv1 = Socks5Server(self.conf1)\n+        self.serv1.start()\n+        self.serv2 = Socks5Server(self.conf2)\n+        self.serv2.start()\n+        self.serv3 = Socks5Server(self.conf3)\n+        self.serv3.start()\n+\n+    def setup_nodes(self):\n+        # Note: proxies are not used to connect to local nodes\n+        # this is because the proxy to use is based on CService.GetNetwork(), which return NET_UNROUTABLE for localhost\n+        return start_nodes(4, self.options.tmpdir, extra_args=[\n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf1.addr),'-proxyrandomize=1'], \n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf1.addr),'-onion=%s:%i' % (self.conf2.addr),'-proxyrandomize=0'], \n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf2.addr),'-proxyrandomize=1'], \n+            ['-listen', '-debug=net', '-debug=proxy', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0']\n+            ])\n+\n+    def node_test(self, node, proxies, auth):\n+        rv = []\n+        # Test: outgoing IPv4 connection through node\n+        node.addnode(\"15.61.23.23:1234\", \"onetry\")\n+        cmd = proxies[0].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"15.61.23.23\")\n+        assert_equal(cmd.port, 1234)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        # Test: outgoing IPv6 connection through node\n+        node.addnode(\"[1233:3432:2434:2343:3234:2345:6546:4534]:5443\", \"onetry\")\n+        cmd = proxies[1].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"1233:3432:2434:2343:3234:2345:6546:4534\")\n+        assert_equal(cmd.port, 5443)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        # Test: outgoing onion connection through node\n+        node.addnode(\"bitcoinostk4e4re.onion:8333\", \"onetry\")\n+        cmd = proxies[2].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"bitcoinostk4e4re.onion\")\n+        assert_equal(cmd.port, 8333)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        # Test: outgoing DNS name connection through node\n+        node.addnode(\"node.noumenon:8333\", \"onetry\")\n+        cmd = proxies[3].queue.get()\n+        assert(isinstance(cmd, Socks5Command))\n+        assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n+        assert_equal(cmd.addr, \"node.noumenon\")\n+        assert_equal(cmd.port, 8333)\n+        if not auth:\n+            assert_equal(cmd.username, None)\n+            assert_equal(cmd.password, None)\n+        rv.append(cmd)\n+\n+        return rv\n+\n+    def run_test(self):\n+        # basic -proxy\n+        self.node_test(self.nodes[0], [self.serv1, self.serv1, self.serv1, self.serv1], False)\n+\n+        # -proxy plus -onion\n+        self.node_test(self.nodes[1], [self.serv1, self.serv1, self.serv2, self.serv1], False)\n+\n+        # -proxy plus -onion, -proxyrandomize\n+        rv = self.node_test(self.nodes[2], [self.serv2, self.serv2, self.serv2, self.serv2], True)\n+        # Check that credentials as used for -proxyrandomize connections are unique\n+        credentials = set((x.username,x.password) for x in rv)\n+        assert_equal(len(credentials), 4)\n+\n+        # proxy on IPv6 localhost\n+        self.node_test(self.nodes[3], [self.serv3, self.serv3, self.serv3, self.serv3], False)\n+        \n+if __name__ == '__main__':\n+    ProxyTest().main()\n+"
      },
      {
        "sha": "2824c51ce7d0e03456713439be9cf09e0cdc73ff",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "added",
        "additions": 356,
        "deletions": 0,
        "changes": 356,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,356 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test pruning code\n+# ********\n+# WARNING:\n+# This test uses 4GB of disk space.\n+# This test takes 30 mins or more (up to 2 hours)\n+# ********\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import os.path\n+\n+def calc_usage(blockdir):\n+    return sum(os.path.getsize(blockdir+f) for f in os.listdir(blockdir) if os.path.isfile(blockdir+f))/(1024*1024)\n+\n+class PruneTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        self.utxo = []\n+        self.address = [\"\",\"\"]\n+\n+        # Some pre-processing to create a bunch of OP_RETURN txouts to insert into transactions we create\n+        # So we have big transactions and full blocks to fill up our block files\n+\n+        # create one script_pubkey\n+        script_pubkey = \"6a4d0200\" #OP_RETURN OP_PUSH2 512 bytes\n+        for i in xrange (512):\n+            script_pubkey = script_pubkey + \"01\"\n+        # concatenate 128 txouts of above script_pubkey which we'll insert before the txout for change\n+        self.txouts = \"81\"\n+        for k in xrange(128):\n+            # add txout value\n+            self.txouts = self.txouts + \"0000000000000000\"\n+            # add length of script_pubkey\n+            self.txouts = self.txouts + \"fd0402\"\n+            # add script_pubkey\n+            self.txouts = self.txouts + script_pubkey\n+\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.is_network_split = False\n+\n+        # Create nodes 0 and 1 to mine\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n+\n+        # Create node 2 to test pruning\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n+        self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n+\n+        self.address[0] = self.nodes[0].getnewaddress()\n+        self.address[1] = self.nodes[1].getnewaddress()\n+\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[1], 2)\n+        connect_nodes(self.nodes[2], 0)\n+        sync_blocks(self.nodes[0:3])\n+\n+    def create_big_chain(self):\n+        # Start by creating some coinbases we can spend later\n+        self.nodes[1].generate(200)\n+        sync_blocks(self.nodes[0:2])\n+        self.nodes[0].generate(150)\n+        # Then mine enough full blocks to create more than 550MB of data\n+        for i in xrange(645):\n+            self.mine_full_block(self.nodes[0], self.address[0])\n+\n+        sync_blocks(self.nodes[0:3])\n+\n+    def test_height_min(self):\n+        if not os.path.isfile(self.prunedir+\"blk00000.dat\"):\n+            raise AssertionError(\"blk00000.dat is missing, pruning too early\")\n+        print \"Success\"\n+        print \"Though we're already using more than 550MB, current usage:\", calc_usage(self.prunedir)\n+        print \"Mining 25 more blocks should cause the first block file to be pruned\"\n+        # Pruning doesn't run until we're allocating another chunk, 20 full blocks past the height cutoff will ensure this\n+        for i in xrange(25):\n+            self.mine_full_block(self.nodes[0],self.address[0])\n+\n+        waitstart = time.time()\n+        while os.path.isfile(self.prunedir+\"blk00000.dat\"):\n+            time.sleep(0.1)\n+            if time.time() - waitstart > 10:\n+                raise AssertionError(\"blk00000.dat not pruned when it should be\")\n+\n+        print \"Success\"\n+        usage = calc_usage(self.prunedir)\n+        print \"Usage should be below target:\", usage\n+        if (usage > 550):\n+            raise AssertionError(\"Pruning target not being met\")\n+\n+    def create_chain_with_staleblocks(self):\n+        # Create stale blocks in manageable sized chunks\n+        print \"Mine 24 (stale) blocks on Node 1, followed by 25 (main chain) block reorg from Node 0, for 12 rounds\"\n+\n+        for j in xrange(12):\n+            # Disconnect node 0 so it can mine a longer reorg chain without knowing about node 1's soon-to-be-stale chain\n+            # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n+            # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n+            stop_node(self.nodes[0],0)\n+            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n+            # Mine 24 blocks in node 1\n+            self.utxo = self.nodes[1].listunspent()\n+            for i in xrange(24):\n+                if j == 0:\n+                    self.mine_full_block(self.nodes[1],self.address[1])\n+                else:\n+                    self.nodes[1].generate(1) #tx's already in mempool from previous disconnects\n+\n+            # Reorg back with 25 block chain from node 0\n+            self.utxo = self.nodes[0].listunspent()\n+            for i in xrange(25): \n+                self.mine_full_block(self.nodes[0],self.address[0])\n+\n+            # Create connections in the order so both nodes can see the reorg at the same time\n+            connect_nodes(self.nodes[1], 0)\n+            connect_nodes(self.nodes[2], 0)\n+            sync_blocks(self.nodes[0:3])\n+\n+        print \"Usage can be over target because of high stale rate:\", calc_usage(self.prunedir)\n+\n+    def reorg_test(self):\n+        # Node 1 will mine a 300 block chain starting 287 blocks back from Node 0 and Node 2's tip\n+        # This will cause Node 2 to do a reorg requiring 288 blocks of undo data to the reorg_test chain\n+        # Reboot node 1 to clear its mempool (hopefully make the invalidate faster)\n+        # Lower the block max size so we don't keep mining all our big mempool transactions (from disconnected blocks)\n+        stop_node(self.nodes[1],1)\n+        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n+\n+        height = self.nodes[1].getblockcount()\n+        print \"Current block height:\", height\n+\n+        invalidheight = height-287\n+        badhash = self.nodes[1].getblockhash(invalidheight)\n+        print \"Invalidating block at height:\",invalidheight,badhash\n+        self.nodes[1].invalidateblock(badhash)\n+\n+        # We've now switched to our previously mined-24 block fork on node 1, but thats not what we want\n+        # So invalidate that fork as well, until we're on the same chain as node 0/2 (but at an ancestor 288 blocks ago)\n+        mainchainhash = self.nodes[0].getblockhash(invalidheight - 1)\n+        curhash = self.nodes[1].getblockhash(invalidheight - 1)\n+        while curhash != mainchainhash:\n+            self.nodes[1].invalidateblock(curhash)\n+            curhash = self.nodes[1].getblockhash(invalidheight - 1)\n+\n+        assert(self.nodes[1].getblockcount() == invalidheight - 1)\n+        print \"New best height\", self.nodes[1].getblockcount()\n+\n+        # Reboot node1 to clear those giant tx's from mempool\n+        stop_node(self.nodes[1],1)\n+        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n+\n+        print \"Generating new longer chain of 300 more blocks\"\n+        self.nodes[1].generate(300)\n+\n+        print \"Reconnect nodes\"\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[2], 1)\n+        sync_blocks(self.nodes[0:3])\n+\n+        print \"Verify height on node 2:\",self.nodes[2].getblockcount()\n+        print \"Usage possibly still high bc of stale blocks in block files:\", calc_usage(self.prunedir)\n+\n+        print \"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\"\n+        self.nodes[0].generate(220) #node 0 has many large tx's in its mempool from the disconnects\n+        sync_blocks(self.nodes[0:3])\n+\n+        usage = calc_usage(self.prunedir)\n+        print \"Usage should be below target:\", usage\n+        if (usage > 550):\n+            raise AssertionError(\"Pruning target not being met\")\n+\n+        return invalidheight,badhash\n+\n+    def reorg_back(self):\n+        # Verify that a block on the old main chain fork has been pruned away\n+        try:\n+            self.nodes[2].getblock(self.forkhash)\n+            raise AssertionError(\"Old block wasn't pruned so can't test redownload\")\n+        except JSONRPCException as e:\n+            print \"Will need to redownload block\",self.forkheight\n+\n+        # Verify that we have enough history to reorg back to the fork point\n+        # Although this is more than 288 blocks, because this chain was written more recently\n+        # and only its other 299 small and 220 large block are in the block files after it,\n+        # its expected to still be retained\n+        self.nodes[2].getblock(self.nodes[2].getblockhash(self.forkheight))\n+\n+        first_reorg_height = self.nodes[2].getblockcount()\n+        curchainhash = self.nodes[2].getblockhash(self.mainchainheight)\n+        self.nodes[2].invalidateblock(curchainhash)\n+        goalbestheight = self.mainchainheight\n+        goalbesthash = self.mainchainhash2\n+\n+        # As of 0.10 the current block download logic is not able to reorg to the original chain created in\n+        # create_chain_with_stale_blocks because it doesn't know of any peer thats on that chain from which to\n+        # redownload its missing blocks.\n+        # Invalidate the reorg_test chain in node 0 as well, it can successfully switch to the original chain\n+        # because it has all the block data.\n+        # However it must mine enough blocks to have a more work chain than the reorg_test chain in order\n+        # to trigger node 2's block download logic.\n+        # At this point node 2 is within 288 blocks of the fork point so it will preserve its ability to reorg\n+        if self.nodes[2].getblockcount() < self.mainchainheight:\n+            blocks_to_mine = first_reorg_height + 1 - self.mainchainheight\n+            print \"Rewind node 0 to prev main chain to mine longer chain to trigger redownload. Blocks needed:\", blocks_to_mine\n+            self.nodes[0].invalidateblock(curchainhash)\n+            assert(self.nodes[0].getblockcount() == self.mainchainheight)\n+            assert(self.nodes[0].getbestblockhash() == self.mainchainhash2)\n+            goalbesthash = self.nodes[0].generate(blocks_to_mine)[-1]\n+            goalbestheight = first_reorg_height + 1\n+\n+        print \"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\"\n+        waitstart = time.time()\n+        while self.nodes[2].getblockcount() < goalbestheight:\n+            time.sleep(0.1)\n+            if time.time() - waitstart > 900:\n+                raise AssertionError(\"Node 2 didn't reorg to proper height\")\n+        assert(self.nodes[2].getbestblockhash() == goalbesthash)\n+        # Verify we can now have the data for a block previously pruned\n+        assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n+\n+    def mine_full_block(self, node, address):\n+        # Want to create a full block\n+        # We'll generate a 66k transaction below, and 14 of them is close to the 1MB block limit\n+        for j in xrange(14):\n+            if len(self.utxo) < 14:\n+                self.utxo = node.listunspent()\n+            inputs=[]\n+            outputs = {}\n+            t = self.utxo.pop()\n+            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n+            remchange = t[\"amount\"] - Decimal(\"0.001000\")\n+            outputs[address]=remchange\n+            # Create a basic transaction that will send change back to ourself after account for a fee\n+            # And then insert the 128 generated transaction outs in the middle rawtx[92] is where the #\n+            # of txouts is stored and is the only thing we overwrite from the original transaction\n+            rawtx = node.createrawtransaction(inputs, outputs)\n+            newtx = rawtx[0:92]\n+            newtx = newtx + self.txouts\n+            newtx = newtx + rawtx[94:]\n+            # Appears to be ever so slightly faster to sign with SIGHASH_NONE\n+            signresult = node.signrawtransaction(newtx,None,None,\"NONE\")\n+            txid = node.sendrawtransaction(signresult[\"hex\"], True)\n+        # Mine a full sized block which will be these transactions we just created\n+        node.generate(1)\n+\n+\n+    def run_test(self):\n+        print \"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\"\n+        print \"Mining a big blockchain of 995 blocks\"\n+        self.create_big_chain()\n+        # Chain diagram key:\n+        # *   blocks on main chain\n+        # +,&,$,@ blocks on other forks\n+        # X   invalidated block\n+        # N1  Node 1\n+        #\n+        # Start by mining a simple chain that all nodes have\n+        # N0=N1=N2 **...*(995)\n+\n+        print \"Check that we haven't started pruning yet because we're below PruneAfterHeight\"\n+        self.test_height_min()\n+        # Extend this chain past the PruneAfterHeight\n+        # N0=N1=N2 **...*(1020)\n+\n+        print \"Check that we'll exceed disk space target if we have a very high stale block rate\"\n+        self.create_chain_with_staleblocks()\n+        # Disconnect N0\n+        # And mine a 24 block chain on N1 and a separate 25 block chain on N0\n+        # N1=N2 **...*+...+(1044)\n+        # N0    **...**...**(1045)\n+        #\n+        # reconnect nodes causing reorg on N1 and N2\n+        # N1=N2 **...*(1020) *...**(1045)\n+        #                   \\\n+        #                    +...+(1044)\n+        #\n+        # repeat this process until you have 12 stale forks hanging off the\n+        # main chain on N1 and N2\n+        # N0    *************************...***************************(1320)\n+        #\n+        # N1=N2 **...*(1020) *...**(1045) *..         ..**(1295) *...**(1320)\n+        #                   \\            \\                      \\\n+        #                    +...+(1044)  &..                    $...$(1319)\n+\n+        # Save some current chain state for later use\n+        self.mainchainheight = self.nodes[2].getblockcount()   #1320\n+        self.mainchainhash2 = self.nodes[2].getblockhash(self.mainchainheight)\n+\n+        print \"Check that we can survive a 288 block reorg still\"\n+        (self.forkheight,self.forkhash) = self.reorg_test() #(1033, )\n+        # Now create a 288 block reorg by mining a longer chain on N1\n+        # First disconnect N1\n+        # Then invalidate 1033 on main chain and 1032 on fork so height is 1032 on main chain\n+        # N1   **...*(1020) **...**(1032)X..\n+        #                  \\\n+        #                   ++...+(1031)X..\n+        #\n+        # Now mine 300 more blocks on N1\n+        # N1    **...*(1020) **...**(1032) @@...@(1332)\n+        #                 \\               \\\n+        #                  \\               X...\n+        #                   \\                 \\\n+        #                    ++...+(1031)X..   ..\n+        #\n+        # Reconnect nodes and mine 220 more blocks on N1\n+        # N1    **...*(1020) **...**(1032) @@...@@@(1552)\n+        #                 \\               \\\n+        #                  \\               X...\n+        #                   \\                 \\\n+        #                    ++...+(1031)X..   ..\n+        #\n+        # N2    **...*(1020) **...**(1032) @@...@@@(1552)\n+        #                 \\               \\\n+        #                  \\               *...**(1320)\n+        #                   \\                 \\\n+        #                    ++...++(1044)     ..\n+        #\n+        # N0    ********************(1032) @@...@@@(1552) \n+        #                                 \\\n+        #                                  *...**(1320)\n+\n+        print \"Test that we can rerequest a block we previously pruned if needed for a reorg\"\n+        self.reorg_back()\n+        # Verify that N2 still has block 1033 on current chain (@), but not on main chain (*)\n+        # Invalidate 1033 on current chain (@) on N2 and we should be able to reorg to\n+        # original main chain (*), but will require redownload of some blocks\n+        # In order to have a peer we think we can download from, must also perform this invalidation\n+        # on N0 and mine a new longest chain to trigger.\n+        # Final result:\n+        # N0    ********************(1032) **...****(1553)\n+        #                                 \\\n+        #                                  X@...@@@(1552)\n+        #\n+        # N2    **...*(1020) **...**(1032) **...****(1553)\n+        #                 \\               \\\n+        #                  \\               X@...@@@(1552)\n+        #                   \\\n+        #                    +..\n+        #\n+        # N1 doesn't change because 1033 on main chain (*) is invalid\n+\n+        print \"Done\"\n+\n+if __name__ == '__main__':\n+    PruneTest().main()"
      },
      {
        "sha": "0d20b6487c61e7d1bde93acf4a14b7a89083a16d",
        "filename": "qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/.gitignore?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1 +0,0 @@\n-*.pyc"
      },
      {
        "sha": "43cdb1c03844881f8f73961d7cde57a140cc42c3",
        "filename": "qa/rpc-tests/python-bitcoinrpc/setup.py",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/qa/rpc-tests/python-bitcoinrpc/setup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/qa/rpc-tests/python-bitcoinrpc/setup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/python-bitcoinrpc/setup.py?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1,15 +0,0 @@\n-#!/usr/bin/env python2\n-\n-from distutils.core import setup\n-\n-setup(name='python-bitcoinrpc',\n-      version='0.1',\n-      description='Enhanced version of python-jsonrpc for use with Bitcoin',\n-      long_description=open('README').read(),\n-      author='Jeff Garzik',\n-      author_email='<jgarzik@exmulti.com>',\n-      maintainer='Jeff Garzik',\n-      maintainer_email='<jgarzik@exmulti.com>',\n-      url='http://www.github.com/jgarzik/python-bitcoinrpc',\n-      packages=['bitcoinrpc'],\n-      classifiers=['License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)', 'Operating System :: OS Independent'])"
      },
      {
        "sha": "1378514c84363fa2d8e37bf5f2c488f5d1a22e8d",
        "filename": "qa/rpc-tests/rawtransactions.py",
        "status": "added",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rawtransactions.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,144 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test re-org scenarios with a mempool that contains transactions\n+# that spend (directly or indirectly) coinbase transactions.\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from pprint import pprint\n+from time import sleep\n+\n+# Create one-input, one-output, no-fee transaction:\n+class RawTransactionsTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        #connect to a local machine for debugging\n+        #url = \"http://bitcoinrpc:DP6DvqZtqXarpeNWyN3LZTFchCCyCUuHwNF7E8pX99x1@%s:%d\" % ('127.0.0.1', 18332)\n+        #proxy = AuthServiceProxy(url)\n+        #proxy.url = url # store URL on proxy for info\n+        #self.nodes.append(proxy)\n+\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+\n+        #prepare some coins for multiple *rawtransaction commands\n+        self.nodes[2].generate(1)\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.5);\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.0);\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0);\n+        self.sync_all()\n+        self.nodes[0].generate(5)\n+        self.sync_all()\n+\n+        #########################################\n+        # sendrawtransaction with missing input #\n+        #########################################\n+        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1}] #won't exists\n+        outputs = { self.nodes[0].getnewaddress() : 4.998 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawtx   = self.nodes[2].signrawtransaction(rawtx)\n+\n+        errorString = \"\"\n+        try:\n+            rawtx   = self.nodes[2].sendrawtransaction(rawtx['hex'])\n+        except JSONRPCException,e:\n+            errorString = e.error['message']\n+\n+        assert_equal(\"Missing inputs\" in errorString, True);\n+\n+        #########################\n+        # RAW TX MULTISIG TESTS #\n+        #########################\n+        # 2of2 test\n+        addr1 = self.nodes[2].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[2].validateaddress(addr1)\n+        addr2Obj = self.nodes[2].validateaddress(addr2)\n+\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        mSigObjValid = self.nodes[2].validateaddress(mSigObj)\n+\n+        #use balance deltas instead of absolute values\n+        bal = self.nodes[2].getbalance()\n+\n+        # send 1.2 BTC to msig adr\n+        txId       = self.nodes[0].sendtoaddress(mSigObj, 1.2);\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), bal+Decimal('1.20000000')) #node2 has both keys of the 2of2 ms addr., tx should affect the balance\n+\n+\n+\n+\n+        # 2of3 test from different nodes\n+        bal = self.nodes[2].getbalance()\n+        addr1 = self.nodes[1].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+        addr3 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[1].validateaddress(addr1)\n+        addr2Obj = self.nodes[2].validateaddress(addr2)\n+        addr3Obj = self.nodes[2].validateaddress(addr3)\n+\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])\n+        mSigObjValid = self.nodes[2].validateaddress(mSigObj)\n+\n+        txId       = self.nodes[0].sendtoaddress(mSigObj, 2.2);\n+        decTx = self.nodes[0].gettransaction(txId)\n+        rawTx = self.nodes[0].decoderawtransaction(decTx['hex'])\n+        sPK = rawTx['vout'][0]['scriptPubKey']['hex']\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        #THIS IS A INCOMPLETE FEATURE\n+        #NODE2 HAS TWO OF THREE KEY AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n+        assert_equal(self.nodes[2].getbalance(), bal) #for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n+\n+        txDetails = self.nodes[0].gettransaction(txId, True)\n+        rawTx = self.nodes[0].decoderawtransaction(txDetails['hex'])\n+        vout = False\n+        for outpoint in rawTx['vout']:\n+            if outpoint['value'] == Decimal('2.20000000'):\n+                vout = outpoint\n+                break;\n+\n+        bal = self.nodes[0].getbalance()\n+        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex']}]\n+        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n+        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawTxPartialSigned = self.nodes[1].signrawtransaction(rawTx, inputs)\n+        assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n+        \n+        rawTxSigned = self.nodes[2].signrawtransaction(rawTx, inputs)\n+        assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n+        self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n+        rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n+\n+if __name__ == '__main__':\n+    RawTransactionsTest().main()"
      },
      {
        "sha": "16d6bd4cf1cbc3574bf4d51037ff46ceb4e1a181",
        "filename": "qa/rpc-tests/receivedby.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/receivedby.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,9 +5,8 @@\n \n # Exercise the listreceivedbyaddress API\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n \n \n def get_sub_array_from_array(object_array, to_match):\n@@ -69,7 +68,7 @@ def run_test(self):\n                            { },\n                            True)\n         #Bury Tx under 10 block so it will be returned by listreceivedbyaddress\n-        self.nodes[1].setgenerate(True, 10)\n+        self.nodes[1].generate(10)\n         self.sync_all()\n         check_array_result(self.nodes[1].listreceivedbyaddress(),\n                            {\"address\":addr},\n@@ -106,7 +105,7 @@ def run_test(self):\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n \n         #Bury Tx under 10 block so it will be returned by the default getreceivedbyaddress\n-        self.nodes[1].setgenerate(True, 10)\n+        self.nodes[1].generate(10)\n         self.sync_all()\n         balance = self.nodes[1].getreceivedbyaddress(addr)\n         if balance != Decimal(\"0.1\"):\n@@ -136,7 +135,7 @@ def run_test(self):\n         if balance != balance_by_account:\n             raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n \n-        self.nodes[1].setgenerate(True, 10)\n+        self.nodes[1].generate(10)\n         self.sync_all()\n         # listreceivedbyaccount should return updated account balance\n         check_array_result(self.nodes[1].listreceivedbyaccount(),"
      },
      {
        "sha": "f2e3f248ea5fa2d0cfeb83d7bdf89909a1386323",
        "filename": "qa/rpc-tests/reindex.py",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/reindex.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,33 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test -reindex with CheckBlockIndex\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import os.path\n+\n+class ReindexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 1)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.is_network_split = False\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+\n+    def run_test(self):\n+        self.nodes[0].generate(3)\n+        stop_node(self.nodes[0], 0)\n+        wait_bitcoinds()\n+        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\", \"-reindex\", \"-checkblockindex=1\"])\n+        assert_equal(self.nodes[0].getblockcount(), 3)\n+        print \"Success\"\n+\n+if __name__ == '__main__':\n+    ReindexTest().main()"
      },
      {
        "sha": "fdb2508f5e231ae55cb9e39de056293c84ad17d8",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 190,
        "deletions": 12,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,9 +7,13 @@\n # Test REST interface\n #\n \n-from test_framework import BitcoinTestFramework\n-from util import *\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from struct import *\n+import binascii\n import json\n+import StringIO\n \n try:\n     import http.client as httplib\n@@ -20,45 +24,210 @@\n except ImportError:\n     import urlparse\n \n-def http_get_call(host, port, path, response_object = 0):\n+def deser_uint256(f):\n+    r = 0\n+    for i in range(8):\n+        t = unpack(b\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+#allows simple http get calls with a request body\n+def http_get_call(host, port, path, requestdata = '', response_object = 0):\n     conn = httplib.HTTPConnection(host, port)\n-    conn.request('GET', path)\n+    conn.request('GET', path, requestdata)\n \n     if response_object:\n         return conn.getresponse()\n \n     return conn.getresponse().read()\n \n-\n class RESTTest (BitcoinTestFramework):\n     FORMAT_SEPARATOR = \".\"\n \n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+        self.is_network_split=False\n+        self.sync_all()\n+        \n     def run_test(self):\n         url = urlparse.urlparse(self.nodes[0].url)\n+        print \"Mining blocks...\"\n+        \n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        self.nodes[2].generate(100)\n+        self.sync_all()\n+        \n+        assert_equal(self.nodes[0].getbalance(), 50)\n+        \n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        self.sync_all()\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        bb_hash = self.nodes[0].getbestblockhash()\n+        \n+        assert_equal(self.nodes[1].getbalance(), Decimal(\"0.1\")) #balance now should be 0.1 on node 1\n+        \n+        # load the latest 0.1 tx over the REST API\n+        json_string = http_get_call(url.hostname, url.port, '/rest/tx/'+txid+self.FORMAT_SEPARATOR+\"json\")\n+        json_obj = json.loads(json_string)\n+        vintx = json_obj['vin'][0]['txid'] # get the vin to later check for utxo (should be spent by then)\n+        # get n of 0.1 outpoint \n+        n = 0\n+        for vout in json_obj['vout']:\n+            if vout['value'] == 0.1:\n+                n = vout['n']\n+        \n+        \n+        ######################################\n+        # GETUTXOS: query a unspent outpoint #\n+        ######################################\n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        \n+        #check chainTip response\n+        assert_equal(json_obj['chaintipHash'], bb_hash)\n+        \n+        #make sure there is one utxo\n+        assert_equal(len(json_obj['utxos']), 1)\n+        assert_equal(json_obj['utxos'][0]['value'], 0.1)\n+        \n+        \n+        ################################################\n+        # GETUTXOS: now query a already spent outpoint #\n+        ################################################\n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+vintx+'\",\"n\":0}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        \n+        #check chainTip response\n+        assert_equal(json_obj['chaintipHash'], bb_hash)\n+\n+        #make sure there is no utox in the response because this oupoint has been spent\n+        assert_equal(len(json_obj['utxos']), 0)\n+        \n+        #check bitmap\n+        assert_equal(json_obj['bitmap'], \"0\")\n+        \n+        \n+        ##################################################\n+        # GETUTXOS: now check both with the same request #\n+        ##################################################\n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'},{\"txid\":\"'+vintx+'\",\"n\":0}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1)\n+        assert_equal(json_obj['bitmap'], \"10\")\n+        \n+        #test binary response\n         bb_hash = self.nodes[0].getbestblockhash()\n \n+        binaryRequest = b'\\x01\\x02'\n+        binaryRequest += binascii.unhexlify(txid)\n+        binaryRequest += pack(\"i\", n);\n+        binaryRequest += binascii.unhexlify(vintx);\n+        binaryRequest += pack(\"i\", 0);\n+        \n+        bin_response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', binaryRequest)\n+        \n+        output = StringIO.StringIO()\n+        output.write(bin_response)\n+        output.seek(0)\n+        chainHeight = unpack(\"i\", output.read(4))[0]\n+        hashFromBinResponse = hex(deser_uint256(output))[2:].zfill(65).rstrip(\"L\")\n+        \n+        assert_equal(bb_hash, hashFromBinResponse) #check if getutxo's chaintip during calculation was fine\n+        assert_equal(chainHeight, 102) #chain height must be 102\n+        \n+        \n+        ############################\n+        # GETUTXOS: mempool checks #\n+        ############################\n+\n+        # do a tx and don't sync\n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        json_string = http_get_call(url.hostname, url.port, '/rest/tx/'+txid+self.FORMAT_SEPARATOR+\"json\")\n+        json_obj = json.loads(json_string)\n+        vintx = json_obj['vin'][0]['txid'] # get the vin to later check for utxo (should be spent by then)\n+        # get n of 0.1 outpoint \n+        n = 0\n+        for vout in json_obj['vout']:\n+            if vout['value'] == 0.1:\n+                n = vout['n']\n+        \n+        json_request = '{\"checkmempool\":false,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 0) #there should be a outpoint because it has just added to the mempool\n+        \n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1) #there should be a outpoint because it has just added to the mempool\n+        \n+        #do some invalid requests\n+        json_request = '{\"checkmempool'\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        assert_equal(response.status, 500) #must be a 500 because we send a invalid json request\n+        \n+        json_request = '{\"checkmempool'\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', json_request, True)\n+        assert_equal(response.status, 500) #must be a 500 because we send a invalid bin request\n+        \n+        #test limits\n+        json_request = '{\"checkmempool\":true,\"outpoints\":['\n+        for x in range(0, 200):\n+            json_request += '{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'},'\n+        json_request = json_request.rstrip(\",\")\n+        json_request+=\"]}\";\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        assert_equal(response.status, 500) #must be a 500 because we exceeding the limits\n+        \n+        json_request = '{\"checkmempool\":true,\"outpoints\":['\n+        for x in range(0, 90):\n+            json_request += '{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'},'\n+        json_request = json_request.rstrip(\",\")\n+        json_request+=\"]}\";\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        assert_equal(response.status, 200) #must be a 500 because we exceeding the limits\n+\n+        self.nodes[0].generate(1) #generate block to not affect upcomming tests\n+        self.sync_all()\n+        \n+        ################\n+        # /rest/block/ #\n+        ################\n+        \n         # check binary format\n-        response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n+        response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", \"\", True)\n         assert_equal(response.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 80)\n         response_str = response.read()\n \n         # compare with block header\n-        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n+        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", \"\", True)\n         assert_equal(response_header.status, 200)\n         assert_equal(int(response_header.getheader('content-length')), 80)\n         response_header_str = response_header.read()\n         assert_equal(response_str[0:80], response_header_str)\n \n         # check block hex format\n-        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n         assert_equal(response_hex.status, 200)\n         assert_greater_than(int(response_hex.getheader('content-length')), 160)\n         response_hex_str = response_hex.read()\n         assert_equal(response_str.encode(\"hex\")[0:160], response_hex_str[0:160])\n \n         # compare with hex block header\n-        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n         assert_equal(response_header_hex.status, 200)\n         assert_greater_than(int(response_header_hex.getheader('content-length')), 160)\n         response_header_hex_str = response_header_hex.read()\n@@ -77,9 +246,11 @@ def run_test(self):\n         assert_equal(json_obj['txid'], tx_hash)\n \n         # check hex format response\n-        hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n-        assert_equal(response.status, 200)\n+        hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n+        assert_equal(hex_string.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 10)\n+        \n+\n \n         # check block tx details\n         # let's make 3 tx and mine them on node 1\n@@ -90,7 +261,7 @@ def run_test(self):\n         self.sync_all()\n \n         # now mine the transactions\n-        newblockhash = self.nodes[1].setgenerate(True, 1)\n+        newblockhash = self.nodes[1].generate(1)\n         self.sync_all()\n \n         #check if the 3 tx show up in the new block\n@@ -106,5 +277,12 @@ def run_test(self):\n         for tx in txs:\n             assert_equal(tx in json_obj['tx'], True)\n \n+        #test rest bestblock\n+        bb_hash = self.nodes[0].getbestblockhash()\n+        \n+        json_string = http_get_call(url.hostname, url.port, '/rest/chaininfo.json')\n+        json_obj = json.loads(json_string)\n+        assert_equal(json_obj['bestblockhash'], bb_hash)\n+\n if __name__ == '__main__':\n     RESTTest ().main ()"
      },
      {
        "sha": "04110c283176f19aba3706fa1b704424f471809c",
        "filename": "qa/rpc-tests/rpcbind_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcbind_test.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,17 +8,15 @@\n # Add python-bitcoinrpc to module search path:\n import os\n import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n \n import json\n import shutil\n import subprocess\n import tempfile\n import traceback\n \n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n-from netutil import *\n+from test_framework.util import *\n+from test_framework.netutil import *\n \n def run_bind_test(tmpdir, allow_ips, connect_to, addresses, expected):\n     '''"
      },
      {
        "sha": "860fa56b64f301905cdcf8446c2dda16ed5da29a",
        "filename": "qa/rpc-tests/script_test.py",
        "status": "added",
        "additions": 253,
        "deletions": 0,
        "changes": 253,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/script_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/script_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/script_test.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,253 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+'''\n+Test notes:\n+This test uses the script_valid and script_invalid tests from the unittest\n+framework to do end-to-end testing where we compare that two nodes agree on\n+whether blocks containing a given test script are valid.\n+\n+We generally ignore the script flags associated with each test (since we lack\n+the precision to test each script using those flags in this framework), but\n+for tests with SCRIPT_VERIFY_P2SH, we can use a block time after the BIP16 \n+switchover date to try to test with that flag enabled (and for tests without\n+that flag, we use a block time before the switchover date).\n+\n+NOTE: This test is very slow and may take more than 40 minutes to run.\n+'''\n+\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.mininode import *\n+from test_framework.blocktools import *\n+from test_framework.script import *\n+import logging\n+import copy\n+import json\n+\n+script_valid_file   = \"../../src/test/data/script_valid.json\"\n+script_invalid_file = \"../../src/test/data/script_invalid.json\"\n+\n+# Pass in a set of json files to open. \n+class ScriptTestFile(object):\n+\n+    def __init__(self, files):\n+        self.files = files\n+        self.index = -1\n+        self.data = []\n+\n+    def load_files(self):\n+        for f in self.files:\n+            self.data.extend(json.loads(open(os.path.dirname(os.path.abspath(__file__))+\"/\"+f).read()))\n+\n+    # Skip over records that are not long enough to be tests\n+    def get_records(self):\n+        while (self.index < len(self.data)):\n+            if len(self.data[self.index]) >= 3:\n+                yield self.data[self.index]\n+            self.index += 1\n+\n+\n+# Helper for parsing the flags specified in the .json files\n+SCRIPT_VERIFY_NONE = 0\n+SCRIPT_VERIFY_P2SH = 1 \n+SCRIPT_VERIFY_STRICTENC = 1 << 1\n+SCRIPT_VERIFY_DERSIG = 1 << 2\n+SCRIPT_VERIFY_LOW_S = 1 << 3\n+SCRIPT_VERIFY_NULLDUMMY = 1 << 4\n+SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5\n+SCRIPT_VERIFY_MINIMALDATA = 1 << 6\n+SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7\n+SCRIPT_VERIFY_CLEANSTACK = 1 << 8\n+\n+flag_map = { \n+    \"\": SCRIPT_VERIFY_NONE,\n+    \"NONE\": SCRIPT_VERIFY_NONE, \n+    \"P2SH\": SCRIPT_VERIFY_P2SH,\n+    \"STRICTENC\": SCRIPT_VERIFY_STRICTENC,\n+    \"DERSIG\": SCRIPT_VERIFY_DERSIG,\n+    \"LOW_S\": SCRIPT_VERIFY_LOW_S,\n+    \"NULLDUMMY\": SCRIPT_VERIFY_NULLDUMMY,\n+    \"SIGPUSHONLY\": SCRIPT_VERIFY_SIGPUSHONLY,\n+    \"MINIMALDATA\": SCRIPT_VERIFY_MINIMALDATA,\n+    \"DISCOURAGE_UPGRADABLE_NOPS\": SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS,\n+    \"CLEANSTACK\": SCRIPT_VERIFY_CLEANSTACK,\n+}\n+\n+def ParseScriptFlags(flag_string):\n+    flags = 0\n+    for x in flag_string.split(\",\"):\n+        if x in flag_map:\n+            flags |= flag_map[x]\n+        else:\n+            print \"Error: unrecognized script flag: \", x\n+    return flags\n+\n+'''\n+Given a string that is a scriptsig or scriptpubkey from the .json files above,\n+convert it to a CScript()\n+'''\n+# Replicates behavior from core_read.cpp\n+def ParseScript(json_script):\n+    script = json_script.split(\" \")\n+    parsed_script = CScript()\n+    for x in script:\n+        if len(x) == 0:\n+            # Empty string, ignore.\n+            pass\n+        elif x.isdigit() or (len(x) >= 1 and x[0] == \"-\" and x[1:].isdigit()):\n+            # Number\n+            n = int(x, 0)\n+            if (n == -1) or (n >= 1 and n <= 16):\n+                parsed_script = CScript(bytes(parsed_script) + bytes(CScript([n])))\n+            else:\n+                parsed_script += CScriptNum(int(x, 0))\n+        elif x.startswith(\"0x\"):\n+            # Raw hex data, inserted NOT pushed onto stack:\n+            for i in xrange(2, len(x), 2):\n+                parsed_script = CScript(bytes(parsed_script) + bytes(chr(int(x[i:i+2],16))))\n+        elif x.startswith(\"'\") and x.endswith(\"'\") and len(x) >= 2:\n+            # Single-quoted string, pushed as data.\n+            parsed_script += CScript([x[1:-1]])\n+        else:\n+            # opcode, e.g. OP_ADD or ADD:\n+            tryopname = \"OP_\" + x\n+            if tryopname in OPCODES_BY_NAME:\n+                parsed_script += CScriptOp(OPCODES_BY_NAME[\"OP_\" + x])\n+            else:\n+                print \"ParseScript: error parsing '%s'\" % x\n+                return \"\"\n+    return parsed_script\n+            \n+class TestBuilder(object):\n+    def create_credit_tx(self, scriptPubKey):\n+        # self.tx1 is a coinbase transaction, modeled after the one created by script_tests.cpp\n+        # This allows us to reuse signatures created in the unit test framework.\n+        self.tx1 = create_coinbase()                 # this has a bip34 scriptsig,\n+        self.tx1.vin[0].scriptSig = CScript([0, 0])  # but this matches the unit tests\n+        self.tx1.vout[0].nValue = 0\n+        self.tx1.vout[0].scriptPubKey = scriptPubKey\n+        self.tx1.rehash()\n+    def create_spend_tx(self, scriptSig):\n+        self.tx2 = create_transaction(self.tx1, 0, CScript(), 0)\n+        self.tx2.vin[0].scriptSig = scriptSig\n+        self.tx2.vout[0].scriptPubKey = CScript()\n+        self.tx2.rehash()\n+    def rehash(self):\n+        self.tx1.rehash()\n+        self.tx2.rehash()\n+\n+# This test uses the (default) two nodes provided by ComparisonTestFramework,\n+# specified on the command line with --testbinary and --refbinary.\n+# See comptool.py\n+class ScriptTest(ComparisonTestFramework):\n+\n+    def run_test(self):\n+        # Set up the comparison tool TestManager\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+\n+        # Load scripts\n+        self.scripts = ScriptTestFile([script_valid_file, script_invalid_file])\n+        self.scripts.load_files()\n+\n+        # Some variables we re-use between test instances (to build blocks)\n+        self.tip = None\n+        self.block_time = None\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+        test.run()\n+\n+    def generate_test_instance(self, pubkeystring, scriptsigstring):\n+        scriptpubkey = ParseScript(pubkeystring)\n+        scriptsig = ParseScript(scriptsigstring)\n+\n+        test = TestInstance(sync_every_block=False)\n+        test_build = TestBuilder()\n+        test_build.create_credit_tx(scriptpubkey)\n+        test_build.create_spend_tx(scriptsig)\n+        test_build.rehash()\n+\n+        block = create_block(self.tip, test_build.tx1, self.block_time)\n+        self.block_time += 1\n+        block.solve()\n+        self.tip = block.sha256\n+        test.blocks_and_transactions = [[block, True]]\n+\n+        for i in xrange(100):\n+            block = create_block(self.tip, create_coinbase(), self.block_time)\n+            self.block_time += 1\n+            block.solve()\n+            self.tip = block.sha256\n+            test.blocks_and_transactions.append([block, True])\n+\n+        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block.vtx.append(test_build.tx2)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        test.blocks_and_transactions.append([block, None])\n+        return test   \n+\n+    # This generates the tests for TestManager.\n+    def get_tests(self):\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.block_time = 1333230000  # before the BIP16 switchover\n+\n+        '''\n+        Create a new block with an anyone-can-spend coinbase\n+        '''\n+        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block.solve()\n+        self.tip = block.sha256\n+        yield TestInstance(objects=[[block, True]])\n+\n+        '''\n+        Build out to 100 blocks total, maturing the coinbase.\n+        '''\n+        test = TestInstance(objects=[], sync_every_block=False, sync_every_tx=False)\n+        for i in xrange(100):\n+            b = create_block(self.tip, create_coinbase(), self.block_time)\n+            b.solve()\n+            test.blocks_and_transactions.append([b, True])\n+            self.tip = b.sha256\n+            self.block_time += 1\n+        yield test\n+ \n+        ''' Iterate through script tests. '''\n+        counter = 0\n+        for script_test in self.scripts.get_records():\n+            ''' Reset the blockchain to genesis block + 100 blocks. '''\n+            if self.nodes[0].getblockcount() > 101:\n+                self.nodes[0].invalidateblock(self.nodes[0].getblockhash(102))\n+                self.nodes[1].invalidateblock(self.nodes[1].getblockhash(102))\n+\n+            self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+            [scriptsig, scriptpubkey, flags] = script_test[0:3]\n+            flags = ParseScriptFlags(flags)\n+\n+            # We can use block time to determine whether the nodes should be\n+            # enforcing BIP16.\n+            #\n+            # We intentionally let the block time grow by 1 each time.\n+            # This forces the block hashes to differ between tests, so that\n+            # a call to invalidateblock doesn't interfere with a later test.\n+            if (flags & SCRIPT_VERIFY_P2SH):\n+                self.block_time = 1333238400 + counter # Advance to enforcing BIP16\n+            else:\n+                self.block_time = 1333230000 + counter # Before the BIP16 switchover\n+\n+            print \"Script test: [%s]\" % script_test\n+\n+            yield self.generate_test_instance(scriptpubkey, scriptsig)\n+            counter += 1\n+\n+if __name__ == '__main__':\n+    ScriptTest().main()"
      },
      {
        "sha": "d51d6ee6106e05ba8c0689371c1c45a188fca832",
        "filename": "qa/rpc-tests/signrawtransactions.py",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/signrawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/signrawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/signrawtransactions.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,109 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+\n+class SignRawTransactionsTest(BitcoinTestFramework):\n+    \"\"\"Tests transaction signing via RPC command \"signrawtransaction\".\"\"\"\n+\n+    def setup_chain(self):\n+        print('Initializing test directory ' + self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 1)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(1, self.options.tmpdir)\n+        self.is_network_split = False\n+\n+    def successful_signing_test(self):\n+        \"\"\"Creates and signs a valid raw transaction with one input.\n+\n+        Expected results:\n+\n+        1) The transaction has a complete set of signatures\n+        2) No script verification error occurred\"\"\"\n+        privKeys = ['cUeKHd5orzT3mz8P9pxyREHfsWtVfgsfDjiZZBcjUBAaGk1BTj7N']\n+\n+        inputs = [\n+            # Valid pay-to-pubkey script\n+            {'txid': '9b907ef1e3c26fc71fe4a4b3580bc75264112f95050014157059c736f0202e71', 'vout': 0,\n+             'scriptPubKey': '76a91460baa0f494b38ce3c940dea67f3804dc52d1fb9488ac'}\n+        ]\n+\n+        outputs = {'mpLQjfK79b7CCV4VMJWEWAj5Mpx8Up5zxB': 0.1}\n+\n+        rawTx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        rawTxSigned = self.nodes[0].signrawtransaction(rawTx, inputs, privKeys)\n+\n+        # 1) The transaction has a complete set of signatures\n+        assert 'complete' in rawTxSigned\n+        assert_equal(rawTxSigned['complete'], True)\n+\n+        # 2) No script verification error occurred\n+        assert 'errors' not in rawTxSigned\n+\n+    def script_verification_error_test(self):\n+        \"\"\"Creates and signs a raw transaction with valid (vin 0), invalid (vin 1) and one missing (vin 2) input script.\n+\n+        Expected results:\n+\n+        3) The transaction has no complete set of signatures\n+        4) Two script verification errors occurred\n+        5) Script verification errors have certain properties (\"txid\", \"vout\", \"scriptSig\", \"sequence\", \"error\")\n+        6) The verification errors refer to the invalid (vin 1) and missing input (vin 2)\"\"\"\n+        privKeys = ['cUeKHd5orzT3mz8P9pxyREHfsWtVfgsfDjiZZBcjUBAaGk1BTj7N']\n+\n+        inputs = [\n+            # Valid pay-to-pubkey script\n+            {'txid': '9b907ef1e3c26fc71fe4a4b3580bc75264112f95050014157059c736f0202e71', 'vout': 0},\n+            # Invalid script\n+            {'txid': '5b8673686910442c644b1f4993d8f7753c7c8fcb5c87ee40d56eaeef25204547', 'vout': 7},\n+            # Missing scriptPubKey\n+            {'txid': '9b907ef1e3c26fc71fe4a4b3580bc75264112f95050014157059c736f0202e71', 'vout': 1},\n+        ]\n+\n+        scripts = [\n+            # Valid pay-to-pubkey script\n+            {'txid': '9b907ef1e3c26fc71fe4a4b3580bc75264112f95050014157059c736f0202e71', 'vout': 0,\n+             'scriptPubKey': '76a91460baa0f494b38ce3c940dea67f3804dc52d1fb9488ac'},\n+            # Invalid script\n+            {'txid': '5b8673686910442c644b1f4993d8f7753c7c8fcb5c87ee40d56eaeef25204547', 'vout': 7,\n+             'scriptPubKey': 'badbadbadbad'}\n+        ]\n+\n+        outputs = {'mpLQjfK79b7CCV4VMJWEWAj5Mpx8Up5zxB': 0.1}\n+\n+        rawTx = self.nodes[0].createrawtransaction(inputs, outputs)\n+        rawTxSigned = self.nodes[0].signrawtransaction(rawTx, scripts, privKeys)\n+\n+        # 3) The transaction has no complete set of signatures\n+        assert 'complete' in rawTxSigned\n+        assert_equal(rawTxSigned['complete'], False)\n+\n+        # 4) Two script verification errors occurred\n+        assert 'errors' in rawTxSigned\n+        assert_equal(len(rawTxSigned['errors']), 2)\n+\n+        # 5) Script verification errors have certain properties\n+        assert 'txid' in rawTxSigned['errors'][0]\n+        assert 'vout' in rawTxSigned['errors'][0]\n+        assert 'scriptSig' in rawTxSigned['errors'][0]\n+        assert 'sequence' in rawTxSigned['errors'][0]\n+        assert 'error' in rawTxSigned['errors'][0]\n+\n+        # 6) The verification errors refer to the invalid (vin 1) and missing input (vin 2)\n+        assert_equal(rawTxSigned['errors'][0]['txid'], inputs[1]['txid'])\n+        assert_equal(rawTxSigned['errors'][0]['vout'], inputs[1]['vout'])\n+        assert_equal(rawTxSigned['errors'][1]['txid'], inputs[2]['txid'])\n+        assert_equal(rawTxSigned['errors'][1]['vout'], inputs[2]['vout'])\n+\n+    def run_test(self):\n+        self.successful_signing_test()\n+        self.script_verification_error_test()\n+\n+\n+if __name__ == '__main__':\n+    SignRawTransactionsTest().main()"
      },
      {
        "sha": "c15c5fda09aa333ba844eb8233bce5abe992bf37",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 226,
        "deletions": 60,
        "changes": 286,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,92 +1,258 @@\n #!/usr/bin/env python2\n-# Copyright (c) 2014 The Bitcoin Core developers\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #\n # Test fee estimation code\n #\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Construct 2 trivial P2SH's and the ScriptSigs that spend them\n+# So we can create many many transactions without needing to spend\n+# time signing.\n+P2SH_1 = \"2MySexEGVzZpRgNQ1JdjdP5bRETznm3roQ2\" # P2SH of \"OP_1 OP_DROP\"\n+P2SH_2 = \"2NBdpwq8Aoo1EEKEXPNrKvr5xQr3M9UfcZA\" # P2SH of \"OP_2 OP_DROP\"\n+# Associated ScriptSig's to spend satisfy P2SH_1 and P2SH_2\n+# 4 bytes of OP_TRUE and push 2-byte redeem script of \"OP_1 OP_DROP\" or \"OP_2 OP_DROP\"\n+SCRIPT_SIG = [\"0451025175\", \"0451025275\"]\n+\n+def satoshi_round(amount):\n+    return  Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n+def small_txpuzzle_randfee(from_node, conflist, unconflist, amount, min_fee, fee_increment):\n+    '''\n+    Create and send a transaction with a random fee.\n+    The transaction pays to a trival P2SH script, and assumes that its inputs\n+    are of the same form.\n+    The function takes a list of confirmed outputs and unconfirmed outputs\n+    and attempts to use the confirmed list first for its inputs.\n+    It adds the newly created outputs to the unconfirmed list.\n+    Returns (raw transaction, fee)\n+    '''\n+    # It's best to exponentially distribute our random fees\n+    # because the buckets are exponentially spaced.\n+    # Exponentially distributed from 1-128 * fee_increment\n+    rand_fee = float(fee_increment)*(1.1892**random.randint(0,28))\n+    # Total fee ranges from min_fee to min_fee + 127*fee_increment\n+    fee = min_fee - fee_increment + satoshi_round(rand_fee)\n+    inputs = []\n+    total_in = Decimal(\"0.00000000\")\n+    while total_in <= (amount + fee) and len(conflist) > 0:\n+        t = conflist.pop(0)\n+        total_in += t[\"amount\"]\n+        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]} )\n+    if total_in <= amount + fee:\n+        while total_in <= (amount + fee) and len(unconflist) > 0:\n+            t = unconflist.pop(0)\n+            total_in += t[\"amount\"]\n+            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]} )\n+        if total_in <= amount + fee:\n+            raise RuntimeError(\"Insufficient funds: need %d, have %d\"%(amount+fee, total_in))\n+    outputs = {}\n+    outputs[P2SH_1] = total_in - amount - fee\n+    outputs[P2SH_2] = amount\n+    rawtx = from_node.createrawtransaction(inputs, outputs)\n+    # Createrawtransaction constructions a transaction that is ready to be signed\n+    # These transactions don't need to be signed, but we still have to insert the ScriptSig\n+    # that will satisfy the ScriptPubKey.\n+    completetx = rawtx[0:10]\n+    inputnum = 0\n+    for inp in inputs:\n+        completetx += rawtx[10+82*inputnum:82+82*inputnum]\n+        completetx += SCRIPT_SIG[inp[\"vout\"]]\n+        completetx += rawtx[84+82*inputnum:92+82*inputnum]\n+        inputnum += 1\n+    completetx += rawtx[10+82*inputnum:]\n+    txid = from_node.sendrawtransaction(completetx, True)\n+    unconflist.append({ \"txid\" : txid, \"vout\" : 0 , \"amount\" : total_in - amount - fee})\n+    unconflist.append({ \"txid\" : txid, \"vout\" : 1 , \"amount\" : amount})\n+\n+    return (completetx, fee)\n+\n+def split_inputs(from_node, txins, txouts, initial_split = False):\n+    '''\n+    We need to generate a lot of very small inputs so we can generate a ton of transactions\n+    and they will have low priority.\n+    This function takes an input from txins, and creates and sends a transaction\n+    which splits the value into 2 outputs which are appended to txouts.\n+    '''\n+    prevtxout = txins.pop()\n+    inputs = []\n+    outputs = {}\n+    inputs.append({ \"txid\" : prevtxout[\"txid\"], \"vout\" : prevtxout[\"vout\"] })\n+    half_change = satoshi_round(prevtxout[\"amount\"]/2)\n+    rem_change = prevtxout[\"amount\"] - half_change  - Decimal(\"0.00001000\")\n+    outputs[P2SH_1] = half_change\n+    outputs[P2SH_2] = rem_change\n+    rawtx = from_node.createrawtransaction(inputs, outputs)\n+    # If this is the initial split we actually need to sign the transaction\n+    # Otherwise we just need to insert the property ScriptSig\n+    if (initial_split) :\n+        completetx = from_node.signrawtransaction(rawtx)[\"hex\"]\n+    else :\n+        completetx = rawtx[0:82] + SCRIPT_SIG[prevtxout[\"vout\"]] + rawtx[84:]\n+    txid = from_node.sendrawtransaction(completetx, True)\n+    txouts.append({ \"txid\" : txid, \"vout\" : 0 , \"amount\" : half_change})\n+    txouts.append({ \"txid\" : txid, \"vout\" : 1 , \"amount\" : rem_change})\n+\n+def check_estimates(node, fees_seen, max_invalid, print_estimates = True):\n+    '''\n+    This function calls estimatefee and verifies that the estimates\n+    meet certain invariants.\n+    '''\n+    all_estimates = [ node.estimatefee(i) for i in range(1,26) ]\n+    if print_estimates:\n+        print([str(all_estimates[e-1]) for e in [1,2,3,6,15,25]])\n+    delta = 1.0e-6 # account for rounding error\n+    last_e = max(fees_seen)\n+    for e in filter(lambda x: x >= 0, all_estimates):\n+        # Estimates should be within the bounds of what transactions fees actually were:\n+        if float(e)+delta < min(fees_seen) or float(e)-delta > max(fees_seen):\n+            raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"\n+                                 %(float(e), min(fees_seen), max(fees_seen)))\n+        # Estimates should be monotonically decreasing\n+        if float(e)-delta > last_e:\n+            raise AssertionError(\"Estimated fee (%f) larger than last fee (%f) for lower number of confirms\"\n+                                 %(float(e),float(last_e)))\n+        last_e = e\n+    valid_estimate = False\n+    invalid_estimates = 0\n+    for e in all_estimates:\n+        if e >= 0:\n+            valid_estimate = True\n+        else:\n+            invalid_estimates += 1\n+        # Once we're at a high enough confirmation count that we can give an estimate\n+        # We should have estimates for all higher confirmation counts\n+        if valid_estimate and e < 0:\n+            raise AssertionError(\"Invalid estimate appears at higher confirm count than valid estimate\")\n+    # Check on the expected number of different confirmation counts\n+    # that we might not have valid estimates for\n+    if invalid_estimates > max_invalid:\n+        raise AssertionError(\"More than (%d) invalid estimates\"%(max_invalid))\n+    return all_estimates\n+\n \n class EstimateFeeTest(BitcoinTestFramework):\n \n     def setup_network(self):\n+        '''\n+        We'll setup the network to have 3 nodes that all mine with different parameters.\n+        But first we need to use one node to create a lot of small low priority outputs\n+        which we will use to generate our transactions.\n+        '''\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir,\n-                            [\"-debug=mempool\", \"-debug=estimatefee\", \"-relaypriority=0\"]))\n-        # Node1 mines small-but-not-tiny blocks, and allows free transactions.\n+        # Use node0 to mine blocks for input splitting\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n+                                                              \"-relaypriority=0\", \"-whitelist=127.0.0.1\"]))\n+\n+        print(\"This test is time consuming, please be patient\")\n+        print(\"Splitting inputs to small size so we can generate low priority tx's\")\n+        self.txouts = []\n+        self.txouts2 = []\n+        # Split a coinbase into two transaction puzzle outputs\n+        split_inputs(self.nodes[0], self.nodes[0].listunspent(0), self.txouts, True)\n+\n+        # Mine\n+        while (len(self.nodes[0].getrawmempool()) > 0):\n+            self.nodes[0].generate(1)\n+\n+        # Repeatedly split those 2 outputs, doubling twice for each rep\n+        # Use txouts to monitor the available utxo, since these won't be tracked in wallet\n+        reps = 0\n+        while (reps < 5):\n+            #Double txouts to txouts2\n+            while (len(self.txouts)>0):\n+                split_inputs(self.nodes[0], self.txouts, self.txouts2)\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.nodes[0].generate(1)\n+            #Double txouts2 to txouts\n+            while (len(self.txouts2)>0):\n+                split_inputs(self.nodes[0], self.txouts2, self.txouts)\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.nodes[0].generate(1)\n+            reps += 1\n+        print(\"Finished splitting\")\n+\n+        # Now we can connect the other nodes, didn't want to connect them earlier\n+        # so the estimates would not be affected by the splitting transactions\n+        # Node1 mines small blocks but that are bigger than the expected transaction rate,\n+        # and allows free transactions.\n         # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n-        # so blockmaxsize of 2,000 is really just 1,000 bytes (room enough for\n-        # 6 or 7 transactions)\n+        # (17k is room enough for 110 or so transactions)\n         self.nodes.append(start_node(1, self.options.tmpdir,\n-                                [\"-blockprioritysize=1500\", \"-blockmaxsize=2000\",\n-                                 \"-debug=mempool\", \"-debug=estimatefee\", \"-relaypriority=0\"]))\n+                                     [\"-blockprioritysize=1500\", \"-blockmaxsize=18000\",\n+                                      \"-maxorphantx=1000\", \"-relaypriority=0\", \"-debug=estimatefee\"]))\n         connect_nodes(self.nodes[1], 0)\n \n         # Node2 is a stingy miner, that\n-        # produces very small blocks (room for only 3 or so transactions)\n-        node2args = [ \"-blockprioritysize=0\", \"-blockmaxsize=1500\",\n-                      \"-debug=mempool\", \"-debug=estimatefee\", \"-relaypriority=0\"]\n+        # produces too small blocks (room for only 70 or so transactions)\n+        node2args = [\"-blockprioritysize=0\", \"-blockmaxsize=12000\", \"-maxorphantx=1000\", \"-relaypriority=0\"]\n+\n         self.nodes.append(start_node(2, self.options.tmpdir, node2args))\n-        connect_nodes(self.nodes[2], 0)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[2], 1)\n \n         self.is_network_split = False\n         self.sync_all()\n-        \n+\n+    def transact_and_mine(self, numblocks, mining_node):\n+        min_fee = Decimal(\"0.00001\")\n+        # We will now mine numblocks blocks generating on average 100 transactions between each block\n+        # We shuffle our confirmed txout set before each set of transactions\n+        # small_txpuzzle_randfee will use the transactions that have inputs already in the chain when possible\n+        # resorting to tx's that depend on the mempool when those run out\n+        for i in range(numblocks):\n+            random.shuffle(self.confutxo)\n+            for j in range(random.randrange(100-50,100+50)):\n+                from_index = random.randint(1,2)\n+                (txhex, fee) = small_txpuzzle_randfee(self.nodes[from_index], self.confutxo,\n+                                                      self.memutxo, Decimal(\"0.005\"), min_fee, min_fee)\n+                tx_kbytes = (len(txhex)/2)/1000.0\n+                self.fees_per_kb.append(float(fee)/tx_kbytes)\n+            sync_mempools(self.nodes[0:3],.1)\n+            mined = mining_node.getblock(mining_node.generate(1)[0],True)[\"tx\"]\n+            sync_blocks(self.nodes[0:3],.1)\n+            #update which txouts are confirmed\n+            newmem = []\n+            for utx in self.memutxo:\n+                if utx[\"txid\"] in mined:\n+                    self.confutxo.append(utx)\n+                else:\n+                    newmem.append(utx)\n+            self.memutxo = newmem\n \n     def run_test(self):\n-        # Prime the memory pool with pairs of transactions\n-        # (high-priority, random fee and zero-priority, random fee)\n-        min_fee = Decimal(\"0.001\")\n-        fees_per_kb = [];\n-        for i in range(12):\n-            (txid, txhex, fee) = random_zeropri_transaction(self.nodes, Decimal(\"1.1\"),\n-                                                            min_fee, min_fee, 20)\n-            tx_kbytes = (len(txhex)/2)/1000.0\n-            fees_per_kb.append(float(fee)/tx_kbytes)\n-\n-        # Mine blocks with node2 until the memory pool clears:\n-        count_start = self.nodes[2].getblockcount()\n-        while len(self.nodes[2].getrawmempool()) > 0:\n-            self.nodes[2].setgenerate(True, 1)\n-            self.sync_all()\n-\n-        all_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n-        print(\"Fee estimates, super-stingy miner: \"+str([str(e) for e in all_estimates]))\n+        self.fees_per_kb = []\n+        self.memutxo = []\n+        self.confutxo = self.txouts # Start with the set of confirmed txouts after splitting\n+        print(\"Checking estimates for 1/2/3/6/15/25 blocks\")\n+        print(\"Creating transactions and mining them with a huge block size\")\n+        # Create transactions and mine 20 big blocks with node 0 such that the mempool is always emptied\n+        self.transact_and_mine(30, self.nodes[0])\n+        check_estimates(self.nodes[1], self.fees_per_kb, 1)\n \n-        # Estimates should be within the bounds of what transactions fees actually were:\n-        delta = 1.0e-6 # account for rounding error\n-        for e in filter(lambda x: x >= 0, all_estimates):\n-            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n-                raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n-\n-        # Generate transactions while mining 30 more blocks, this time with node1:\n-        for i in range(30):\n-            for j in range(random.randrange(6-4,6+4)):\n-                (txid, txhex, fee) = random_transaction(self.nodes, Decimal(\"1.1\"),\n-                                                        Decimal(\"0.0\"), min_fee, 20)\n-                tx_kbytes = (len(txhex)/2)/1000.0\n-                fees_per_kb.append(float(fee)/tx_kbytes)\n-            self.nodes[1].setgenerate(True, 1)\n-            self.sync_all()\n+        print(\"Creating transactions and mining them with a block size that can't keep up\")\n+        # Create transactions and mine 30 small blocks with node 2, but create txs faster than we can mine\n+        self.transact_and_mine(20, self.nodes[2])\n+        check_estimates(self.nodes[1], self.fees_per_kb, 3)\n \n-        all_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n-        print(\"Fee estimates, more generous miner: \"+str([ str(e) for e in all_estimates]))\n-        for e in filter(lambda x: x >= 0, all_estimates):\n-            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n-                raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+        print(\"Creating transactions and mining them at a block size that is just big enough\")\n+        # Generate transactions while mining 40 more blocks, this time with node1\n+        # which mines blocks with capacity just above the rate that transactions are being created\n+        self.transact_and_mine(40, self.nodes[1])\n+        check_estimates(self.nodes[1], self.fees_per_kb, 2)\n \n         # Finish by mining a normal-sized block:\n-        while len(self.nodes[0].getrawmempool()) > 0:\n-            self.nodes[0].setgenerate(True, 1)\n-            self.sync_all()\n-\n-        final_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n-        print(\"Final fee estimates: \"+str([ str(e) for e in final_estimates]))\n+        while len(self.nodes[1].getrawmempool()) > 0:\n+            self.nodes[1].generate(1)\n \n+        sync_blocks(self.nodes[0:3],.1)\n+        print(\"Final estimates after emptying mempools\")\n+        check_estimates(self.nodes[1], self.fees_per_kb, 2)\n \n if __name__ == '__main__':\n     EstimateFeeTest().main()"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "qa/rpc-tests/test_framework/__init__.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/__init__.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/__init__.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/__init__.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "previous_filename": "qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/__init__.py"
      },
      {
        "sha": "bc7d655fdfe97c912d945c5d534948dc6848623c",
        "filename": "qa/rpc-tests/test_framework/authproxy.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/authproxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/authproxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/authproxy.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "previous_filename": "qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/authproxy.py"
      },
      {
        "sha": "b0c58ccd474474cd9507add8fe49255b14a5ea9b",
        "filename": "qa/rpc-tests/test_framework/bignum.py",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/bignum.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/bignum.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/bignum.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,102 @@\n+#\n+#\n+# bignum.py\n+#\n+# This file is copied from python-bitcoinlib.\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+\"\"\"Bignum routines\"\"\"\n+\n+from __future__ import absolute_import, division, print_function, unicode_literals\n+\n+import struct\n+\n+\n+# generic big endian MPI format\n+\n+def bn_bytes(v, have_ext=False):\n+    ext = 0\n+    if have_ext:\n+        ext = 1\n+    return ((v.bit_length()+7)//8) + ext\n+\n+def bn2bin(v):\n+    s = bytearray()\n+    i = bn_bytes(v)\n+    while i > 0:\n+        s.append((v >> ((i-1) * 8)) & 0xff)\n+        i -= 1\n+    return s\n+\n+def bin2bn(s):\n+    l = 0\n+    for ch in s:\n+        l = (l << 8) | ch\n+    return l\n+\n+def bn2mpi(v):\n+    have_ext = False\n+    if v.bit_length() > 0:\n+        have_ext = (v.bit_length() & 0x07) == 0\n+\n+    neg = False\n+    if v < 0:\n+        neg = True\n+        v = -v\n+\n+    s = struct.pack(b\">I\", bn_bytes(v, have_ext))\n+    ext = bytearray()\n+    if have_ext:\n+        ext.append(0)\n+    v_bin = bn2bin(v)\n+    if neg:\n+        if have_ext:\n+            ext[0] |= 0x80\n+        else:\n+            v_bin[0] |= 0x80\n+    return s + ext + v_bin\n+\n+def mpi2bn(s):\n+    if len(s) < 4:\n+        return None\n+    s_size = bytes(s[:4])\n+    v_len = struct.unpack(b\">I\", s_size)[0]\n+    if len(s) != (v_len + 4):\n+        return None\n+    if v_len == 0:\n+        return 0\n+\n+    v_str = bytearray(s[4:])\n+    neg = False\n+    i = v_str[0]\n+    if i & 0x80:\n+        neg = True\n+        i &= ~0x80\n+        v_str[0] = i\n+\n+    v = bin2bn(v_str)\n+\n+    if neg:\n+        return -v\n+    return v\n+\n+# bitcoin-specific little endian format, with implicit size\n+def mpi2vch(s):\n+    r = s[4:]           # strip size\n+    r = r[::-1]         # reverse string, converting BE->LE\n+    return r\n+\n+def bn2vch(v):\n+    return bytes(mpi2vch(bn2mpi(v)))\n+\n+def vch2mpi(s):\n+    r = struct.pack(b\">I\", len(s))   # size\n+    r += s[::-1]            # reverse string, converting LE->BE\n+    return r\n+\n+def vch2bn(s):\n+    return mpi2bn(vch2mpi(s))\n+"
      },
      {
        "sha": "c57b6df81bbb03b3182d15f29b1b0dc424648453",
        "filename": "qa/rpc-tests/test_framework/blockstore.py",
        "status": "added",
        "additions": 127,
        "deletions": 0,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/blockstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/blockstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blockstore.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,127 @@\n+# BlockStore: a helper class that keeps a map of blocks and implements\n+#             helper functions for responding to getheaders and getdata,\n+#             and for constructing a getheaders message\n+#\n+\n+from mininode import *\n+import dbm\n+\n+class BlockStore(object):\n+    def __init__(self, datadir):\n+        self.blockDB = dbm.open(datadir + \"/blocks\", 'c')\n+        self.currentBlock = 0L\n+    \n+    def close(self):\n+        self.blockDB.close()\n+\n+    def get(self, blockhash):\n+        serialized_block = None\n+        try:\n+            serialized_block = self.blockDB[repr(blockhash)]\n+        except KeyError:\n+            return None\n+        f = cStringIO.StringIO(serialized_block)\n+        ret = CBlock()\n+        ret.deserialize(f)\n+        ret.calc_sha256()\n+        return ret\n+\n+    # Note: this pulls full blocks out of the database just to retrieve\n+    # the headers -- perhaps we could keep a separate data structure\n+    # to avoid this overhead.\n+    def headers_for(self, locator, hash_stop, current_tip=None):\n+        if current_tip is None:\n+            current_tip = self.currentBlock\n+        current_block = self.get(current_tip)\n+        if current_block is None:\n+            return None\n+\n+        response = msg_headers()\n+        headersList = [ CBlockHeader(current_block) ]\n+        maxheaders = 2000\n+        while (headersList[0].sha256 not in locator.vHave):\n+            prevBlockHash = headersList[0].hashPrevBlock\n+            prevBlock = self.get(prevBlockHash)\n+            if prevBlock is not None:\n+                headersList.insert(0, CBlockHeader(prevBlock))\n+            else:\n+                break\n+        headersList = headersList[:maxheaders] # truncate if we have too many\n+        hashList = [x.sha256 for x in headersList]\n+        index = len(headersList)\n+        if (hash_stop in hashList):\n+            index = hashList.index(hash_stop)+1\n+        response.headers = headersList[:index]\n+        return response\n+\n+    def add_block(self, block):\n+        block.calc_sha256()\n+        try:\n+            self.blockDB[repr(block.sha256)] = bytes(block.serialize())\n+        except TypeError as e:\n+            print \"Unexpected error: \", sys.exc_info()[0], e.args\n+        self.currentBlock = block.sha256\n+\n+    def get_blocks(self, inv):\n+        responses = []\n+        for i in inv:\n+            if (i.type == 2): # MSG_BLOCK\n+                block = self.get(i.hash)\n+                if block is not None:\n+                    responses.append(msg_block(block))\n+        return responses\n+\n+    def get_locator(self, current_tip=None):\n+        if current_tip is None:\n+            current_tip = self.currentBlock\n+        r = []\n+        counter = 0\n+        step = 1\n+        lastBlock = self.get(current_tip)\n+        while lastBlock is not None:\n+            r.append(lastBlock.hashPrevBlock)\n+            for i in range(step):\n+                lastBlock = self.get(lastBlock.hashPrevBlock)\n+                if lastBlock is None:\n+                    break\n+            counter += 1\n+            if counter > 10:\n+                step *= 2\n+        locator = CBlockLocator()\n+        locator.vHave = r\n+        return locator\n+\n+class TxStore(object):\n+    def __init__(self, datadir):\n+        self.txDB = dbm.open(datadir + \"/transactions\", 'c')\n+\n+    def close(self):\n+        self.txDB.close()\n+\n+    def get(self, txhash):\n+        serialized_tx = None\n+        try:\n+            serialized_tx = self.txDB[repr(txhash)]\n+        except KeyError:\n+            return None\n+        f = cStringIO.StringIO(serialized_tx)\n+        ret = CTransaction()\n+        ret.deserialize(f)\n+        ret.calc_sha256()\n+        return ret\n+\n+    def add_transaction(self, tx):\n+        tx.calc_sha256()\n+        try:\n+            self.txDB[repr(tx.sha256)] = bytes(tx.serialize())\n+        except TypeError as e:\n+            print \"Unexpected error: \", sys.exc_info()[0], e.args\n+\n+    def get_transactions(self, inv):\n+        responses = []\n+        for i in inv:\n+            if (i.type == 1): # MSG_TX\n+                tx = self.get(i.hash)\n+                if tx is not None:\n+                    responses.append(msg_tx(tx))\n+        return responses"
      },
      {
        "sha": "f397fe7cd6ebbc56344b460048f0529b59e0bdc2",
        "filename": "qa/rpc-tests/test_framework/blocktools.py",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blocktools.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,65 @@\n+# blocktools.py - utilities for manipulating blocks and transactions\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from mininode import *\n+from script import CScript, CScriptOp\n+\n+# Create a block (with regtest difficulty)\n+def create_block(hashprev, coinbase, nTime=None):\n+    block = CBlock()\n+    if nTime is None:\n+        import time\n+        block.nTime = int(time.time()+600)\n+    else:\n+        block.nTime = nTime\n+    block.hashPrevBlock = hashprev\n+    block.nBits = 0x207fffff # Will break after a difficulty adjustment...\n+    block.vtx.append(coinbase)\n+    block.hashMerkleRoot = block.calc_merkle_root()\n+    block.calc_sha256()\n+    return block\n+\n+def serialize_script_num(value):\n+    r = bytearray(0)\n+    if value == 0:\n+        return r\n+    neg = value < 0\n+    absvalue = -value if neg else value\n+    while (absvalue):\n+        r.append(chr(absvalue & 0xff))\n+        absvalue >>= 8\n+    if r[-1] & 0x80:\n+        r.append(0x80 if neg else 0)\n+    elif neg:\n+        r[-1] |= 0x80\n+    return r\n+\n+counter=1\n+# Create an anyone-can-spend coinbase transaction, assuming no miner fees\n+def create_coinbase(heightAdjust = 0):\n+    global counter\n+    coinbase = CTransaction()\n+    coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), \n+                ser_string(serialize_script_num(counter+heightAdjust)), 0xffffffff))\n+    counter += 1\n+    coinbaseoutput = CTxOut()\n+    coinbaseoutput.nValue = 50*100000000\n+    halvings = int((counter+heightAdjust)/150) # regtest\n+    coinbaseoutput.nValue >>= halvings\n+    coinbaseoutput.scriptPubKey = \"\"\n+    coinbase.vout = [ coinbaseoutput ]\n+    coinbase.calc_sha256()\n+    return coinbase\n+\n+# Create a transaction with an anyone-can-spend output, that spends the\n+# nth output of prevtx.\n+def create_transaction(prevtx, n, sig, value):\n+    tx = CTransaction()\n+    assert(n < len(prevtx.vout))\n+    tx.vin.append(CTxIn(COutPoint(prevtx.sha256, n), sig, 0xffffffff))\n+    tx.vout.append(CTxOut(value, \"\"))\n+    tx.calc_sha256()\n+    return tx"
      },
      {
        "sha": "23a979250cf17dfbbb28005cf8dd0dc36544c65f",
        "filename": "qa/rpc-tests/test_framework/comptool.py",
        "status": "added",
        "additions": 341,
        "deletions": 0,
        "changes": 341,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/comptool.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,341 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from mininode import *\n+from blockstore import BlockStore, TxStore\n+from util import p2p_port\n+\n+'''\n+This is a tool for comparing two or more bitcoinds to each other\n+using a script provided.\n+\n+To use, create a class that implements get_tests(), and pass it in\n+as the test generator to TestManager.  get_tests() should be a python\n+generator that returns TestInstance objects.  See below for definition.\n+'''\n+\n+# TestNode behaves as follows:\n+# Configure with a BlockStore and TxStore\n+# on_inv: log the message but don't request\n+# on_headers: log the chain tip\n+# on_pong: update ping response map (for synchronization)\n+# on_getheaders: provide headers via BlockStore\n+# on_getdata: provide blocks via BlockStore\n+\n+global mininode_lock\n+\n+class TestNode(NodeConnCB):\n+\n+    def __init__(self, block_store, tx_store):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.conn = None\n+        self.bestblockhash = None\n+        self.block_store = block_store\n+        self.block_request_map = {}\n+        self.tx_store = tx_store\n+        self.tx_request_map = {}\n+\n+        # When the pingmap is non-empty we're waiting for \n+        # a response\n+        self.pingMap = {} \n+        self.lastInv = []\n+\n+    def add_connection(self, conn):\n+        self.conn = conn\n+\n+    def on_headers(self, conn, message):\n+        if len(message.headers) > 0:\n+            best_header = message.headers[-1]\n+            best_header.calc_sha256()\n+            self.bestblockhash = best_header.sha256\n+\n+    def on_getheaders(self, conn, message):\n+        response = self.block_store.headers_for(message.locator, message.hashstop)\n+        if response is not None:\n+            conn.send_message(response)\n+\n+    def on_getdata(self, conn, message):\n+        [conn.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n+        [conn.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n+\n+        for i in message.inv:\n+            if i.type == 1:\n+                self.tx_request_map[i.hash] = True\n+            elif i.type == 2:\n+                self.block_request_map[i.hash] = True\n+\n+    def on_inv(self, conn, message):\n+        self.lastInv = [x.hash for x in message.inv]\n+\n+    def on_pong(self, conn, message):\n+        try:\n+            del self.pingMap[message.nonce]\n+        except KeyError:\n+            raise AssertionError(\"Got pong for unknown ping [%s]\" % repr(message))\n+\n+    def send_inv(self, obj):\n+        mtype = 2 if isinstance(obj, CBlock) else 1\n+        self.conn.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n+\n+    def send_getheaders(self):\n+        # We ask for headers from their last tip.\n+        m = msg_getheaders()\n+        m.locator = self.block_store.get_locator(self.bestblockhash)\n+        self.conn.send_message(m)\n+\n+    # This assumes BIP31\n+    def send_ping(self, nonce):\n+        self.pingMap[nonce] = True\n+        self.conn.send_message(msg_ping(nonce))\n+\n+    def received_ping_response(self, nonce):\n+        return nonce not in self.pingMap\n+\n+    def send_mempool(self):\n+        self.lastInv = []\n+        self.conn.send_message(msg_mempool())\n+\n+# TestInstance:\n+#\n+# Instances of these are generated by the test generator, and fed into the\n+# comptool.\n+#\n+# \"blocks_and_transactions\" should be an array of [obj, True/False/None]:\n+#  - obj is either a CBlock or a CTransaction, and \n+#  - the second value indicates whether the object should be accepted\n+#    into the blockchain or mempool (for tests where we expect a certain\n+#    answer), or \"None\" if we don't expect a certain answer and are just\n+#    comparing the behavior of the nodes being tested.\n+# sync_every_block: if True, then each block will be inv'ed, synced, and\n+#    nodes will be tested based on the outcome for the block.  If False,\n+#    then inv's accumulate until all blocks are processed (or max inv size\n+#    is reached) and then sent out in one inv message.  Then the final block\n+#    will be synced across all connections, and the outcome of the final \n+#    block will be tested.\n+# sync_every_tx: analagous to behavior for sync_every_block, except if outcome\n+#    on the final tx is None, then contents of entire mempool are compared\n+#    across all connections.  (If outcome of final tx is specified as true\n+#    or false, then only the last tx is tested against outcome.)\n+\n+class TestInstance(object):\n+    def __init__(self, objects=[], sync_every_block=True, sync_every_tx=False):\n+        self.blocks_and_transactions = objects\n+        self.sync_every_block = sync_every_block\n+        self.sync_every_tx = sync_every_tx\n+\n+class TestManager(object):\n+\n+    def __init__(self, testgen, datadir):\n+        self.test_generator = testgen\n+        self.connections    = []\n+        self.block_store    = BlockStore(datadir)\n+        self.tx_store       = TxStore(datadir)\n+        self.ping_counter   = 1\n+\n+    def add_all_connections(self, nodes):\n+        for i in range(len(nodes)):\n+            # Create a p2p connection to each node\n+            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), \n+                        nodes[i], TestNode(self.block_store, self.tx_store)))\n+            # Make sure the TestNode (callback class) has a reference to its\n+            # associated NodeConn\n+            self.connections[-1].cb.add_connection(self.connections[-1])\n+\n+    def wait_for_verack(self):\n+        sleep_time = 0.05\n+        max_tries = 10 / sleep_time  # Wait at most 10 seconds\n+        while max_tries > 0:\n+            done = True\n+            with mininode_lock:\n+                for c in self.connections:\n+                    if c.cb.verack_received is False:\n+                        done = False\n+                        break\n+            if done:\n+                break\n+            time.sleep(sleep_time)\n+\n+    def wait_for_pings(self, counter):\n+        received_pongs = False\n+        while received_pongs is not True:\n+            time.sleep(0.05)\n+            received_pongs = True\n+            with mininode_lock:\n+                for c in self.connections:\n+                    if c.cb.received_ping_response(counter) is not True:\n+                        received_pongs = False\n+                        break\n+\n+    # sync_blocks: Wait for all connections to request the blockhash given\n+    # then send get_headers to find out the tip of each node, and synchronize\n+    # the response by using a ping (and waiting for pong with same nonce).\n+    def sync_blocks(self, blockhash, num_blocks):\n+        # Wait for nodes to request block (50ms sleep * 20 tries * num_blocks)\n+        max_tries = 20*num_blocks\n+        while max_tries > 0:\n+            with mininode_lock:\n+                results = [ blockhash in c.cb.block_request_map and\n+                            c.cb.block_request_map[blockhash] for c in self.connections ]\n+            if False not in results:\n+                break\n+            time.sleep(0.05)\n+            max_tries -= 1\n+\n+        # --> error if not requested\n+        if max_tries == 0:\n+            # print [ c.cb.block_request_map for c in self.connections ]\n+            raise AssertionError(\"Not all nodes requested block\")\n+        # --> Answer request (we did this inline!)\n+\n+        # Send getheaders message\n+        [ c.cb.send_getheaders() for c in self.connections ]\n+\n+        # Send ping and wait for response -- synchronization hack\n+        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        self.wait_for_pings(self.ping_counter)\n+        self.ping_counter += 1\n+\n+    # Analogous to sync_block (see above)\n+    def sync_transaction(self, txhash, num_events):\n+        # Wait for nodes to request transaction (50ms sleep * 20 tries * num_events)\n+        max_tries = 20*num_events\n+        while max_tries > 0:\n+            with mininode_lock:\n+                results = [ txhash in c.cb.tx_request_map and\n+                            c.cb.tx_request_map[txhash] for c in self.connections ]\n+            if False not in results:\n+                break\n+            time.sleep(0.05)\n+            max_tries -= 1\n+\n+        # --> error if not requested\n+        if max_tries == 0:\n+            # print [ c.cb.tx_request_map for c in self.connections ]\n+            raise AssertionError(\"Not all nodes requested transaction\")\n+        # --> Answer request (we did this inline!)\n+\n+        # Get the mempool\n+        [ c.cb.send_mempool() for c in self.connections ]\n+\n+        # Send ping and wait for response -- synchronization hack\n+        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        self.wait_for_pings(self.ping_counter)\n+        self.ping_counter += 1\n+\n+        # Sort inv responses from each node\n+        with mininode_lock:\n+            [ c.cb.lastInv.sort() for c in self.connections ]\n+\n+    # Verify that the tip of each connection all agree with each other, and\n+    # with the expected outcome (if given)\n+    def check_results(self, blockhash, outcome):\n+        with mininode_lock:\n+            for c in self.connections:\n+                if outcome is None:\n+                    if c.cb.bestblockhash != self.connections[0].cb.bestblockhash:\n+                        return False\n+                elif ((c.cb.bestblockhash == blockhash) != outcome):\n+                    # print c.cb.bestblockhash, blockhash, outcome\n+                    return False\n+            return True\n+\n+    # Either check that the mempools all agree with each other, or that\n+    # txhash's presence in the mempool matches the outcome specified.\n+    # This is somewhat of a strange comparison, in that we're either comparing\n+    # a particular tx to an outcome, or the entire mempools altogether;\n+    # perhaps it would be useful to add the ability to check explicitly that\n+    # a particular tx's existence in the mempool is the same across all nodes.\n+    def check_mempool(self, txhash, outcome):\n+        with mininode_lock:\n+            for c in self.connections:\n+                if outcome is None:\n+                    # Make sure the mempools agree with each other\n+                    if c.cb.lastInv != self.connections[0].cb.lastInv:\n+                        # print c.rpc.getrawmempool()\n+                        return False\n+                elif ((txhash in c.cb.lastInv) != outcome):\n+                    # print c.rpc.getrawmempool(), c.cb.lastInv\n+                    return False\n+            return True\n+\n+    def run(self):\n+        # Wait until verack is received\n+        self.wait_for_verack()\n+\n+        test_number = 1\n+        for test_instance in self.test_generator.get_tests():\n+            # We use these variables to keep track of the last block\n+            # and last transaction in the tests, which are used\n+            # if we're not syncing on every block or every tx.\n+            [ block, block_outcome ] = [ None, None ]\n+            [ tx, tx_outcome ] = [ None, None ]\n+            invqueue = []\n+\n+            for b_or_t, outcome in test_instance.blocks_and_transactions:\n+                # Determine if we're dealing with a block or tx\n+                if isinstance(b_or_t, CBlock):  # Block test runner\n+                    block = b_or_t\n+                    block_outcome = outcome\n+                    # Add to shared block_store, set as current block\n+                    with mininode_lock:\n+                        self.block_store.add_block(block)\n+                        for c in self.connections:\n+                            c.cb.block_request_map[block.sha256] = False\n+                    # Either send inv's to each node and sync, or add\n+                    # to invqueue for later inv'ing.\n+                    if (test_instance.sync_every_block):\n+                        [ c.cb.send_inv(block) for c in self.connections ]\n+                        self.sync_blocks(block.sha256, 1)\n+                        if (not self.check_results(block.sha256, outcome)):\n+                            raise AssertionError(\"Test failed at test %d\" % test_number)\n+                    else:\n+                        invqueue.append(CInv(2, block.sha256))\n+                else:  # Tx test runner\n+                    assert(isinstance(b_or_t, CTransaction))\n+                    tx = b_or_t\n+                    tx_outcome = outcome\n+                    # Add to shared tx store and clear map entry\n+                    with mininode_lock:\n+                        self.tx_store.add_transaction(tx)\n+                        for c in self.connections:\n+                            c.cb.tx_request_map[tx.sha256] = False\n+                    # Again, either inv to all nodes or save for later\n+                    if (test_instance.sync_every_tx):\n+                        [ c.cb.send_inv(tx) for c in self.connections ]\n+                        self.sync_transaction(tx.sha256, 1)\n+                        if (not self.check_mempool(tx.sha256, outcome)):\n+                            raise AssertionError(\"Test failed at test %d\" % test_number)\n+                    else:\n+                        invqueue.append(CInv(1, tx.sha256))\n+                # Ensure we're not overflowing the inv queue\n+                if len(invqueue) == MAX_INV_SZ:\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    invqueue = []\n+\n+            # Do final sync if we weren't syncing on every block or every tx.\n+            if (not test_instance.sync_every_block and block is not None):\n+                if len(invqueue) > 0:\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    invqueue = []\n+                self.sync_blocks(block.sha256,\n+                                 len(test_instance.blocks_and_transactions))\n+                if (not self.check_results(block.sha256, block_outcome)):\n+                    raise AssertionError(\"Block test failed at test %d\" % test_number)\n+            if (not test_instance.sync_every_tx and tx is not None):\n+                if len(invqueue) > 0:\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    invqueue = []\n+                self.sync_transaction(tx.sha256, len(test_instance.blocks_and_transactions))\n+                if (not self.check_mempool(tx.sha256, tx_outcome)):\n+                    raise AssertionError(\"Mempool test failed at test %d\" % test_number)\n+\n+            print \"Test %d: PASS\" % test_number, [ c.rpc.getblockcount() for c in self.connections ]\n+            test_number += 1\n+\n+        self.block_store.close()\n+        self.tx_store.close()\n+        [ c.disconnect_node() for c in self.connections ]"
      },
      {
        "sha": "b7d78e74fa83d0b003d96a4f77421c8d13db1cba",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "added",
        "additions": 1256,
        "deletions": 0,
        "changes": 1256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,1256 @@\n+# mininode.py - Bitcoin P2P network half-a-node\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# This python code was modified from ArtForz' public domain  half-a-node, as\n+# found in the mini-node branch of http://github.com/jgarzik/pynode.\n+#\n+# NodeConn: an object which manages p2p connectivity to a bitcoin node\n+# NodeConnCB: a base class that describes the interface for receiving\n+#             callbacks with network messages from a NodeConn\n+# CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n+#     data structures that should map to corresponding structures in\n+#     bitcoin/primitives\n+# msg_block, msg_tx, msg_headers, etc.:\n+#     data structures that represent network messages\n+# ser_*, deser_*: functions that handle serialization/deserialization\n+\n+\n+import struct\n+import socket\n+import asyncore\n+import binascii\n+import time\n+import sys\n+import random\n+import cStringIO\n+import hashlib\n+from threading import RLock\n+from threading import Thread\n+import logging\n+import copy\n+\n+BIP0031_VERSION = 60000\n+MY_VERSION = 60001  # past bip-31 for ping/pong\n+MY_SUBVERSION = \"/python-mininode-tester:0.0.1/\"\n+\n+MAX_INV_SZ = 50000\n+\n+# Keep our own socket map for asyncore, so that we can track disconnects\n+# ourselves (to workaround an issue with closing an asyncore socket when \n+# using select)\n+mininode_socket_map = dict()\n+\n+# One lock for synchronizing all data access between the networking thread (see\n+# NetworkThread below) and the thread running the test logic.  For simplicity,\n+# NodeConn acquires this lock whenever delivering a message to to a NodeConnCB,\n+# and whenever adding anything to the send buffer (in send_message()).  This\n+# lock should be acquired in the thread running the test logic to synchronize\n+# access to any data shared with the NodeConnCB or NodeConn.\n+mininode_lock = RLock()\n+\n+# Serialization/deserialization tools\n+def sha256(s):\n+    return hashlib.new('sha256', s).digest()\n+\n+\n+def hash256(s):\n+    return sha256(sha256(s))\n+\n+\n+def deser_string(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return f.read(nit)\n+\n+\n+def ser_string(s):\n+    if len(s) < 253:\n+        return chr(len(s)) + s\n+    elif len(s) < 0x10000:\n+        return chr(253) + struct.pack(\"<H\", len(s)) + s\n+    elif len(s) < 0x100000000L:\n+        return chr(254) + struct.pack(\"<I\", len(s)) + s\n+    return chr(255) + struct.pack(\"<Q\", len(s)) + s\n+\n+\n+def deser_uint256(f):\n+    r = 0L\n+    for i in xrange(8):\n+        t = struct.unpack(\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+\n+def ser_uint256(u):\n+    rs = \"\"\n+    for i in xrange(8):\n+        rs += struct.pack(\"<I\", u & 0xFFFFFFFFL)\n+        u >>= 32\n+    return rs\n+\n+\n+def uint256_from_str(s):\n+    r = 0L\n+    t = struct.unpack(\"<IIIIIIII\", s[:32])\n+    for i in xrange(8):\n+        r += t[i] << (i * 32)\n+    return r\n+\n+\n+def uint256_from_compact(c):\n+    nbytes = (c >> 24) & 0xFF\n+    v = (c & 0xFFFFFFL) << (8 * (nbytes - 3))\n+    return v\n+\n+\n+def deser_vector(f, c):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = c()\n+        t.deserialize(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += i.serialize()\n+    return r\n+\n+\n+def deser_uint256_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = deser_uint256(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_uint256_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += ser_uint256(i)\n+    return r\n+\n+\n+def deser_string_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = deser_string(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_string_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for sv in l:\n+        r += ser_string(sv)\n+    return r\n+\n+\n+def deser_int_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = struct.unpack(\"<i\", f.read(4))[0]\n+        r.append(t)\n+    return r\n+\n+\n+def ser_int_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += struct.pack(\"<i\", i)\n+    return r\n+\n+\n+# Objects that map to bitcoind objects, which can be serialized/deserialized\n+\n+class CAddress(object):\n+    def __init__(self):\n+        self.nServices = 1\n+        self.pchReserved = \"\\x00\" * 10 + \"\\xff\" * 2\n+        self.ip = \"0.0.0.0\"\n+        self.port = 0\n+\n+    def deserialize(self, f):\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.pchReserved = f.read(12)\n+        self.ip = socket.inet_ntoa(f.read(4))\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += self.pchReserved\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n+                                                         self.ip, self.port)\n+\n+\n+class CInv(object):\n+    typemap = {\n+        0: \"Error\",\n+        1: \"TX\",\n+        2: \"Block\"}\n+\n+    def __init__(self, t=0, h=0L):\n+        self.type = t\n+        self.hash = h\n+\n+    def deserialize(self, f):\n+        self.type = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hash = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.type)\n+        r += ser_uint256(self.hash)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CInv(type=%s hash=%064x)\" \\\n+            % (self.typemap[self.type], self.hash)\n+\n+\n+class CBlockLocator(object):\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.vHave = []\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vHave = deser_uint256_vector(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256_vector(self.vHave)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n+            % (self.nVersion, repr(self.vHave))\n+\n+\n+class COutPoint(object):\n+    def __init__(self, hash=0, n=0):\n+        self.hash = hash\n+        self.n = n\n+\n+    def deserialize(self, f):\n+        self.hash = deser_uint256(f)\n+        self.n = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += ser_uint256(self.hash)\n+        r += struct.pack(\"<I\", self.n)\n+        return r\n+\n+    def __repr__(self):\n+        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n+\n+\n+class CTxIn(object):\n+    def __init__(self, outpoint=None, scriptSig=\"\", nSequence=0):\n+        if outpoint is None:\n+            self.prevout = COutPoint()\n+        else:\n+            self.prevout = outpoint\n+        self.scriptSig = scriptSig\n+        self.nSequence = nSequence\n+\n+    def deserialize(self, f):\n+        self.prevout = COutPoint()\n+        self.prevout.deserialize(f)\n+        self.scriptSig = deser_string(f)\n+        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.prevout.serialize()\n+        r += ser_string(self.scriptSig)\n+        r += struct.pack(\"<I\", self.nSequence)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n+            % (repr(self.prevout), binascii.hexlify(self.scriptSig),\n+               self.nSequence)\n+\n+\n+class CTxOut(object):\n+    def __init__(self, nValue=0, scriptPubKey=\"\"):\n+        self.nValue = nValue\n+        self.scriptPubKey = scriptPubKey\n+\n+    def deserialize(self, f):\n+        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n+        self.scriptPubKey = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<q\", self.nValue)\n+        r += ser_string(self.scriptPubKey)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n+            % (self.nValue // 100000000, self.nValue % 100000000,\n+               binascii.hexlify(self.scriptPubKey))\n+\n+\n+class CTransaction(object):\n+    def __init__(self, tx=None):\n+        if tx is None:\n+            self.nVersion = 1\n+            self.vin = []\n+            self.vout = []\n+            self.nLockTime = 0\n+            self.sha256 = None\n+            self.hash = None\n+        else:\n+            self.nVersion = tx.nVersion\n+            self.vin = copy.deepcopy(tx.vin)\n+            self.vout = copy.deepcopy(tx.vout)\n+            self.nLockTime = tx.nLockTime\n+            self.sha256 = None\n+            self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vin = deser_vector(f, CTxIn)\n+        self.vout = deser_vector(f, CTxOut)\n+        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            self.sha256 = uint256_from_str(hash256(self.serialize()))\n+        self.hash = hash256(self.serialize())[::-1].encode('hex_codec')\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        for tout in self.vout:\n+            if tout.nValue < 0 or tout.nValue > 21000000L * 100000000L:\n+                return False\n+        return True\n+\n+    def __repr__(self):\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), self.nLockTime)\n+\n+\n+class CBlockHeader(object):\n+    def __init__(self, header=None):\n+        if header is None:\n+            self.set_null()\n+        else:\n+            self.nVersion = header.nVersion\n+            self.hashPrevBlock = header.hashPrevBlock\n+            self.hashMerkleRoot = header.hashMerkleRoot\n+            self.nTime = header.nTime\n+            self.nBits = header.nBits\n+            self.nNonce = header.nNonce\n+            self.sha256 = header.sha256\n+            self.hash = header.hash\n+            self.calc_sha256()\n+\n+    def set_null(self):\n+        self.nVersion = 1\n+        self.hashPrevBlock = 0\n+        self.hashMerkleRoot = 0\n+        self.nTime = 0\n+        self.nBits = 0\n+        self.nNonce = 0\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hashPrevBlock = deser_uint256(f)\n+        self.hashMerkleRoot = deser_uint256(f)\n+        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256(self.hashPrevBlock)\n+        r += ser_uint256(self.hashMerkleRoot)\n+        r += struct.pack(\"<I\", self.nTime)\n+        r += struct.pack(\"<I\", self.nBits)\n+        r += struct.pack(\"<I\", self.nNonce)\n+        return r\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            r = \"\"\n+            r += struct.pack(\"<i\", self.nVersion)\n+            r += ser_uint256(self.hashPrevBlock)\n+            r += ser_uint256(self.hashMerkleRoot)\n+            r += struct.pack(\"<I\", self.nTime)\n+            r += struct.pack(\"<I\", self.nBits)\n+            r += struct.pack(\"<I\", self.nNonce)\n+            self.sha256 = uint256_from_str(hash256(r))\n+            self.hash = hash256(r)[::-1].encode('hex_codec')\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+        return self.sha256\n+\n+    def __repr__(self):\n+        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce)\n+\n+\n+class CBlock(CBlockHeader):\n+    def __init__(self, header=None):\n+        super(CBlock, self).__init__(header)\n+        self.vtx = []\n+\n+    def deserialize(self, f):\n+        super(CBlock, self).deserialize(f)\n+        self.vtx = deser_vector(f, CTransaction)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += super(CBlock, self).serialize()\n+        r += ser_vector(self.vtx)\n+        return r\n+\n+    def calc_merkle_root(self):\n+        hashes = []\n+        for tx in self.vtx:\n+            tx.calc_sha256()\n+            hashes.append(ser_uint256(tx.sha256))\n+        while len(hashes) > 1:\n+            newhashes = []\n+            for i in xrange(0, len(hashes), 2):\n+                i2 = min(i+1, len(hashes)-1)\n+                newhashes.append(hash256(hashes[i] + hashes[i2]))\n+            hashes = newhashes\n+        return uint256_from_str(hashes[0])\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        if self.sha256 > target:\n+            return False\n+        for tx in self.vtx:\n+            if not tx.is_valid():\n+                return False\n+        if self.calc_merkle_root() != self.hashMerkleRoot:\n+            return False\n+        return True\n+\n+    def solve(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        while self.sha256 > target:\n+            self.nNonce += 1\n+            self.rehash()\n+\n+    def __repr__(self):\n+        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n+\n+\n+class CUnsignedAlert(object):\n+    def __init__(self):\n+        self.nVersion = 1\n+        self.nRelayUntil = 0\n+        self.nExpiration = 0\n+        self.nID = 0\n+        self.nCancel = 0\n+        self.setCancel = []\n+        self.nMinVer = 0\n+        self.nMaxVer = 0\n+        self.setSubVer = []\n+        self.nPriority = 0\n+        self.strComment = \"\"\n+        self.strStatusBar = \"\"\n+        self.strReserved = \"\"\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nRelayUntil = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nExpiration = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nID = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nCancel = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setCancel = deser_int_vector(f)\n+        self.nMinVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nMaxVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setSubVer = deser_string_vector(f)\n+        self.nPriority = struct.unpack(\"<i\", f.read(4))[0]\n+        self.strComment = deser_string(f)\n+        self.strStatusBar = deser_string(f)\n+        self.strReserved = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<q\", self.nRelayUntil)\n+        r += struct.pack(\"<q\", self.nExpiration)\n+        r += struct.pack(\"<i\", self.nID)\n+        r += struct.pack(\"<i\", self.nCancel)\n+        r += ser_int_vector(self.setCancel)\n+        r += struct.pack(\"<i\", self.nMinVer)\n+        r += struct.pack(\"<i\", self.nMaxVer)\n+        r += ser_string_vector(self.setSubVer)\n+        r += struct.pack(\"<i\", self.nPriority)\n+        r += ser_string(self.strComment)\n+        r += ser_string(self.strStatusBar)\n+        r += ser_string(self.strReserved)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CUnsignedAlert(nVersion %d, nRelayUntil %d, nExpiration %d, nID %d, nCancel %d, nMinVer %d, nMaxVer %d, nPriority %d, strComment %s, strStatusBar %s, strReserved %s)\" \\\n+            % (self.nVersion, self.nRelayUntil, self.nExpiration, self.nID,\n+               self.nCancel, self.nMinVer, self.nMaxVer, self.nPriority,\n+               self.strComment, self.strStatusBar, self.strReserved)\n+\n+\n+class CAlert(object):\n+    def __init__(self):\n+        self.vchMsg = \"\"\n+        self.vchSig = \"\"\n+\n+    def deserialize(self, f):\n+        self.vchMsg = deser_string(f)\n+        self.vchSig = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += ser_string(self.vchMsg)\n+        r += ser_string(self.vchSig)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAlert(vchMsg.sz %d, vchSig.sz %d)\" \\\n+            % (len(self.vchMsg), len(self.vchSig))\n+\n+\n+# Objects that correspond to messages on the wire\n+class msg_version(object):\n+    command = \"version\"\n+\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.nServices = 1\n+        self.nTime = time.time()\n+        self.addrTo = CAddress()\n+        self.addrFrom = CAddress()\n+        self.nNonce = random.getrandbits(64)\n+        self.strSubVer = MY_SUBVERSION\n+        self.nStartingHeight = -1\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        if self.nVersion == 10300:\n+            self.nVersion = 300\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n+        self.addrTo = CAddress()\n+        self.addrTo.deserialize(f)\n+        if self.nVersion >= 106:\n+            self.addrFrom = CAddress()\n+            self.addrFrom.deserialize(f)\n+            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n+            self.strSubVer = deser_string(f)\n+            if self.nVersion >= 209:\n+                self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n+            else:\n+                self.nStartingHeight = None\n+        else:\n+            self.addrFrom = None\n+            self.nNonce = None\n+            self.strSubVer = None\n+            self.nStartingHeight = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += struct.pack(\"<q\", self.nTime)\n+        r += self.addrTo.serialize()\n+        r += self.addrFrom.serialize()\n+        r += struct.pack(\"<Q\", self.nNonce)\n+        r += ser_string(self.strSubVer)\n+        r += struct.pack(\"<i\", self.nStartingHeight)\n+        return r\n+\n+    def __repr__(self):\n+        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i)' \\\n+            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n+               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n+               self.strSubVer, self.nStartingHeight)\n+\n+\n+class msg_verack(object):\n+    command = \"verack\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_verack()\"\n+\n+\n+class msg_addr(object):\n+    command = \"addr\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress)\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs)\n+\n+    def __repr__(self):\n+        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_alert(object):\n+    command = \"alert\"\n+\n+    def __init__(self):\n+        self.alert = CAlert()\n+\n+    def deserialize(self, f):\n+        self.alert = CAlert()\n+        self.alert.deserialize(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.alert.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_alert(alert=%s)\" % (repr(self.alert), )\n+\n+\n+class msg_inv(object):\n+    command = \"inv\"\n+\n+    def __init__(self, inv=None):\n+        if inv is None:\n+            self.inv = []\n+        else:\n+            self.inv = inv\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getdata(object):\n+    command = \"getdata\"\n+\n+    def __init__(self):\n+        self.inv = []\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getblocks(object):\n+    command = \"getblocks\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0L\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+class msg_tx(object):\n+    command = \"tx\"\n+\n+    def __init__(self, tx=CTransaction()):\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.tx.deserialize(f)\n+\n+    def serialize(self):\n+        return self.tx.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n+\n+\n+class msg_block(object):\n+    command = \"block\"\n+\n+    def __init__(self, block=None):\n+        if block is None:\n+            self.block = CBlock()\n+        else:\n+            self.block = block\n+\n+    def deserialize(self, f):\n+        self.block.deserialize(f)\n+\n+    def serialize(self):\n+        return self.block.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_block(block=%s)\" % (repr(self.block))\n+\n+\n+class msg_getaddr(object):\n+    command = \"getaddr\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_getaddr()\"\n+\n+\n+class msg_ping_prebip31(object):\n+    command = \"ping\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_ping() (pre-bip31)\"\n+\n+\n+class msg_ping(object):\n+    command = \"ping\"\n+\n+    def __init__(self, nonce=0L):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_ping(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_pong(object):\n+    command = \"pong\"\n+\n+    def __init__(self, nonce=0L):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_pong(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_mempool(object):\n+    command = \"mempool\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_mempool()\"\n+\n+\n+# getheaders message has\n+# number of entries\n+# vector of hashes\n+# hash_stop (hash of last desired block header, 0 to get as many as possible)\n+class msg_getheaders(object):\n+    command = \"getheaders\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0L\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+# headers message has\n+# <count> <vector of block headers>\n+class msg_headers(object):\n+    command = \"headers\"\n+\n+    def __init__(self):\n+        self.headers = []\n+\n+    def deserialize(self, f):\n+        # comment in bitcoind indicates these should be deserialized as blocks\n+        blocks = deser_vector(f, CBlock)\n+        for x in blocks:\n+            self.headers.append(CBlockHeader(x))\n+\n+    def serialize(self):\n+        blocks = [CBlock(x) for x in self.headers]\n+        return ser_vector(blocks)\n+\n+    def __repr__(self):\n+        return \"msg_headers(headers=%s)\" % repr(self.headers)\n+\n+\n+class msg_reject(object):\n+    command = \"reject\"\n+\n+    def __init__(self):\n+        self.message = \"\"\n+        self.code = \"\"\n+        self.reason = \"\"\n+        self.data = 0L\n+\n+    def deserialize(self, f):\n+        self.message = deser_string(f)\n+        self.code = struct.unpack(\"<B\", f.read(1))[0]\n+        self.reason = deser_string(f)\n+        if (self.message == \"block\" or self.message == \"tx\"):\n+            self.data = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = ser_string(self.message)\n+        r += struct.pack(\"<B\", self.code)\n+        r += ser_string(self.reason)\n+        if (self.message == \"block\" or self.message == \"tx\"):\n+            r += ser_uint256(self.data)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reject: %s %d %s [%064x]\" \\\n+            % (self.message, self.code, self.reason, self.data)\n+\n+\n+# This is what a callback should look like for NodeConn\n+# Reimplement the on_* functions to provide handling for events\n+class NodeConnCB(object):\n+    def __init__(self):\n+        self.verack_received = False\n+\n+    # Derived classes should call this function once to set the message map\n+    # which associates the derived classes' functions to incoming messages\n+    def create_callback_map(self):\n+        self.cbmap = {\n+            \"version\": self.on_version,\n+            \"verack\": self.on_verack,\n+            \"addr\": self.on_addr,\n+            \"alert\": self.on_alert,\n+            \"inv\": self.on_inv,\n+            \"getdata\": self.on_getdata,\n+            \"getblocks\": self.on_getblocks,\n+            \"tx\": self.on_tx,\n+            \"block\": self.on_block,\n+            \"getaddr\": self.on_getaddr,\n+            \"ping\": self.on_ping,\n+            \"pong\": self.on_pong,\n+            \"headers\": self.on_headers,\n+            \"getheaders\": self.on_getheaders,\n+            \"reject\": self.on_reject,\n+            \"mempool\": self.on_mempool\n+        }\n+\n+    def deliver(self, conn, message):\n+        with mininode_lock:\n+            try:\n+                self.cbmap[message.command](conn, message)\n+            except:\n+                print \"ERROR delivering %s (%s)\" % (repr(message),\n+                                                    sys.exc_info()[0])\n+\n+    def on_version(self, conn, message):\n+        if message.nVersion >= 209:\n+            conn.send_message(msg_verack())\n+        conn.ver_send = min(MY_VERSION, message.nVersion)\n+        if message.nVersion < 209:\n+            conn.ver_recv = conn.ver_send\n+\n+    def on_verack(self, conn, message):\n+        conn.ver_recv = conn.ver_send\n+        self.verack_received = True\n+\n+    def on_inv(self, conn, message):\n+        want = msg_getdata()\n+        for i in message.inv:\n+            if i.type != 0:\n+                want.inv.append(i)\n+        if len(want.inv):\n+            conn.send_message(want)\n+\n+    def on_addr(self, conn, message): pass\n+    def on_alert(self, conn, message): pass\n+    def on_getdata(self, conn, message): pass\n+    def on_getblocks(self, conn, message): pass\n+    def on_tx(self, conn, message): pass\n+    def on_block(self, conn, message): pass\n+    def on_getaddr(self, conn, message): pass\n+    def on_headers(self, conn, message): pass\n+    def on_getheaders(self, conn, message): pass\n+    def on_ping(self, conn, message):\n+        if conn.ver_send > BIP0031_VERSION:\n+            conn.send_message(msg_pong(message.nonce))\n+    def on_reject(self, conn, message): pass\n+    def on_close(self, conn): pass\n+    def on_mempool(self, conn): pass\n+    def on_pong(self, conn, message): pass\n+\n+\n+# The actual NodeConn class\n+# This class provides an interface for a p2p connection to a specified node\n+class NodeConn(asyncore.dispatcher):\n+    messagemap = {\n+        \"version\": msg_version,\n+        \"verack\": msg_verack,\n+        \"addr\": msg_addr,\n+        \"alert\": msg_alert,\n+        \"inv\": msg_inv,\n+        \"getdata\": msg_getdata,\n+        \"getblocks\": msg_getblocks,\n+        \"tx\": msg_tx,\n+        \"block\": msg_block,\n+        \"getaddr\": msg_getaddr,\n+        \"ping\": msg_ping,\n+        \"pong\": msg_pong,\n+        \"headers\": msg_headers,\n+        \"getheaders\": msg_getheaders,\n+        \"reject\": msg_reject,\n+        \"mempool\": msg_mempool\n+    }\n+    MAGIC_BYTES = {\n+        \"mainnet\": \"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n+        \"testnet3\": \"\\x0b\\x11\\x09\\x07\",  # testnet3\n+        \"regtest\": \"\\xfa\\xbf\\xb5\\xda\"    # regtest\n+    }\n+\n+    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n+        asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n+        self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n+        self.dstaddr = dstaddr\n+        self.dstport = dstport\n+        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n+        self.sendbuf = \"\"\n+        self.recvbuf = \"\"\n+        self.ver_send = 209\n+        self.ver_recv = 209\n+        self.last_sent = 0\n+        self.state = \"connecting\"\n+        self.network = net\n+        self.cb = callback\n+        self.disconnect = False\n+\n+        # stuff version msg into sendbuf\n+        vt = msg_version()\n+        vt.addrTo.ip = self.dstaddr\n+        vt.addrTo.port = self.dstport\n+        vt.addrFrom.ip = \"0.0.0.0\"\n+        vt.addrFrom.port = 0\n+        self.send_message(vt, True)\n+        print 'MiniNode: Connecting to Bitcoin Node IP # ' + dstaddr + ':' \\\n+            + str(dstport)\n+\n+        try:\n+            self.connect((dstaddr, dstport))\n+        except:\n+            self.handle_close()\n+        self.rpc = rpc\n+\n+    def show_debug_msg(self, msg):\n+        self.log.debug(msg)\n+\n+    def handle_connect(self):\n+        self.show_debug_msg(\"MiniNode: Connected & Listening: \\n\")\n+        self.state = \"connected\"\n+\n+    def handle_close(self):\n+        self.show_debug_msg(\"MiniNode: Closing Connection to %s:%d... \"\n+                            % (self.dstaddr, self.dstport))\n+        self.state = \"closed\"\n+        self.recvbuf = \"\"\n+        self.sendbuf = \"\"\n+        try:\n+            self.close()\n+        except:\n+            pass\n+        self.cb.on_close(self)\n+\n+    def handle_read(self):\n+        try:\n+            t = self.recv(8192)\n+            if len(t) > 0:\n+                self.recvbuf += t\n+                self.got_data()\n+        except:\n+            pass\n+\n+    def readable(self):\n+        return True\n+\n+    def writable(self):\n+        with mininode_lock:\n+            length = len(self.sendbuf)\n+        return (length > 0)\n+\n+    def handle_write(self):\n+        with mininode_lock:\n+            try:\n+                sent = self.send(self.sendbuf)\n+            except:\n+                self.handle_close()\n+                return\n+            self.sendbuf = self.sendbuf[sent:]\n+\n+    def got_data(self):\n+        while True:\n+            if len(self.recvbuf) < 4:\n+                return\n+            if self.recvbuf[:4] != self.MAGIC_BYTES[self.network]:\n+                raise ValueError(\"got garbage %s\" % repr(self.recvbuf))\n+            if self.ver_recv < 209:\n+                if len(self.recvbuf) < 4 + 12 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = None\n+                if len(self.recvbuf) < 4 + 12 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4:4+12+4+msglen]\n+                self.recvbuf = self.recvbuf[4+12+4+msglen:]\n+            else:\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = self.recvbuf[4+12+4:4+12+4+4]\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n+                th = sha256(msg)\n+                h = sha256(th)\n+                if checksum != h[:4]:\n+                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n+                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+            if command in self.messagemap:\n+                f = cStringIO.StringIO(msg)\n+                t = self.messagemap[command]()\n+                t.deserialize(f)\n+                self.got_message(t)\n+            else:\n+                self.show_debug_msg(\"Unknown command: '\" + command + \"' \" +\n+                                    repr(msg))\n+\n+    def send_message(self, message, pushbuf=False):\n+        if self.state != \"connected\" and not pushbuf:\n+            return\n+        self.show_debug_msg(\"Send %s\" % repr(message))\n+        command = message.command\n+        data = message.serialize()\n+        tmsg = self.MAGIC_BYTES[self.network]\n+        tmsg += command\n+        tmsg += \"\\x00\" * (12 - len(command))\n+        tmsg += struct.pack(\"<I\", len(data))\n+        if self.ver_send >= 209:\n+            th = sha256(data)\n+            h = sha256(th)\n+            tmsg += h[:4]\n+        tmsg += data\n+        with mininode_lock:\n+            self.sendbuf += tmsg\n+            self.last_sent = time.time()\n+\n+    def got_message(self, message):\n+        if message.command == \"version\":\n+            if message.nVersion <= BIP0031_VERSION:\n+                self.messagemap['ping'] = msg_ping_prebip31\n+        if self.last_sent + 30 * 60 < time.time():\n+            self.send_message(self.messagemap['ping']())\n+        self.show_debug_msg(\"Recv %s\" % repr(message))\n+        self.cb.deliver(self, message)\n+\n+    def disconnect_node(self):\n+        self.disconnect = True\n+\n+\n+class NetworkThread(Thread):\n+    def run(self):\n+        while mininode_socket_map:\n+            # We check for whether to disconnect outside of the asyncore\n+            # loop to workaround the behavior of asyncore when using\n+            # select\n+            disconnected = []\n+            for fd, obj in mininode_socket_map.items():\n+                if obj.disconnect:\n+                    disconnected.append(obj)\n+            [ obj.handle_close() for obj in disconnected ]\n+            asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n+\n+\n+# An exception we can raise if we detect a potential disconnect\n+# (p2p or rpc) before the test is complete\n+class EarlyDisconnectError(Exception):\n+    def __init__(self, value):\n+        self.value = value\n+\n+    def __str__(self):\n+        return repr(self.value)"
      },
      {
        "sha": "b30a88a4f783a3f39daa16987dec6ad55fe7e39c",
        "filename": "qa/rpc-tests/test_framework/netutil.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/netutil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/netutil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/netutil.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "previous_filename": "qa/rpc-tests/netutil.py"
      },
      {
        "sha": "e37ab5d45acc85e8d3223b5c5a5a824ea9dc2438",
        "filename": "qa/rpc-tests/test_framework/script.py",
        "status": "added",
        "additions": 896,
        "deletions": 0,
        "changes": 896,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/script.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,896 @@\n+#\n+# script.py\n+#\n+# This file is modified from python-bitcoinlib.\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+\"\"\"Scripts\n+\n+Functionality to build scripts, as well as SignatureHash().\n+\"\"\"\n+\n+from __future__ import absolute_import, division, print_function, unicode_literals\n+\n+from test_framework.mininode import CTransaction, CTxOut, hash256\n+\n+import sys\n+bchr = chr\n+bord = ord\n+if sys.version > '3':\n+    long = int\n+    bchr = lambda x: bytes([x])\n+    bord = lambda x: x\n+\n+import copy\n+import struct\n+\n+import test_framework.bignum\n+\n+MAX_SCRIPT_SIZE = 10000\n+MAX_SCRIPT_ELEMENT_SIZE = 520\n+MAX_SCRIPT_OPCODES = 201\n+\n+OPCODE_NAMES = {}\n+\n+_opcode_instances = []\n+class CScriptOp(int):\n+    \"\"\"A single script opcode\"\"\"\n+    __slots__ = []\n+\n+    @staticmethod\n+    def encode_op_pushdata(d):\n+        \"\"\"Encode a PUSHDATA op, returning bytes\"\"\"\n+        if len(d) < 0x4c:\n+            return b'' + bchr(len(d)) + d # OP_PUSHDATA\n+        elif len(d) <= 0xff:\n+            return b'\\x4c' + bchr(len(d)) + d # OP_PUSHDATA1\n+        elif len(d) <= 0xffff:\n+            return b'\\x4d' + struct.pack(b'<H', len(d)) + d # OP_PUSHDATA2\n+        elif len(d) <= 0xffffffff:\n+            return b'\\x4e' + struct.pack(b'<I', len(d)) + d # OP_PUSHDATA4\n+        else:\n+            raise ValueError(\"Data too long to encode in a PUSHDATA op\")\n+\n+    @staticmethod\n+    def encode_op_n(n):\n+        \"\"\"Encode a small integer op, returning an opcode\"\"\"\n+        if not (0 <= n <= 16):\n+            raise ValueError('Integer must be in range 0 <= n <= 16, got %d' % n)\n+\n+        if n == 0:\n+            return OP_0\n+        else:\n+            return CScriptOp(OP_1 + n-1)\n+\n+    def decode_op_n(self):\n+        \"\"\"Decode a small integer opcode, returning an integer\"\"\"\n+        if self == OP_0:\n+            return 0\n+\n+        if not (self == OP_0 or OP_1 <= self <= OP_16):\n+            raise ValueError('op %r is not an OP_N' % self)\n+\n+        return int(self - OP_1+1)\n+\n+    def is_small_int(self):\n+        \"\"\"Return true if the op pushes a small integer to the stack\"\"\"\n+        if 0x51 <= self <= 0x60 or self == 0:\n+            return True\n+        else:\n+            return False\n+\n+    def __str__(self):\n+        return repr(self)\n+\n+    def __repr__(self):\n+        if self in OPCODE_NAMES:\n+            return OPCODE_NAMES[self]\n+        else:\n+            return 'CScriptOp(0x%x)' % self\n+\n+    def __new__(cls, n):\n+        try:\n+            return _opcode_instances[n]\n+        except IndexError:\n+            assert len(_opcode_instances) == n\n+            _opcode_instances.append(super(CScriptOp, cls).__new__(cls, n))\n+            return _opcode_instances[n]\n+\n+# Populate opcode instance table\n+for n in range(0xff+1):\n+    CScriptOp(n)\n+\n+\n+# push value\n+OP_0 = CScriptOp(0x00)\n+OP_FALSE = OP_0\n+OP_PUSHDATA1 = CScriptOp(0x4c)\n+OP_PUSHDATA2 = CScriptOp(0x4d)\n+OP_PUSHDATA4 = CScriptOp(0x4e)\n+OP_1NEGATE = CScriptOp(0x4f)\n+OP_RESERVED = CScriptOp(0x50)\n+OP_1 = CScriptOp(0x51)\n+OP_TRUE=OP_1\n+OP_2 = CScriptOp(0x52)\n+OP_3 = CScriptOp(0x53)\n+OP_4 = CScriptOp(0x54)\n+OP_5 = CScriptOp(0x55)\n+OP_6 = CScriptOp(0x56)\n+OP_7 = CScriptOp(0x57)\n+OP_8 = CScriptOp(0x58)\n+OP_9 = CScriptOp(0x59)\n+OP_10 = CScriptOp(0x5a)\n+OP_11 = CScriptOp(0x5b)\n+OP_12 = CScriptOp(0x5c)\n+OP_13 = CScriptOp(0x5d)\n+OP_14 = CScriptOp(0x5e)\n+OP_15 = CScriptOp(0x5f)\n+OP_16 = CScriptOp(0x60)\n+\n+# control\n+OP_NOP = CScriptOp(0x61)\n+OP_VER = CScriptOp(0x62)\n+OP_IF = CScriptOp(0x63)\n+OP_NOTIF = CScriptOp(0x64)\n+OP_VERIF = CScriptOp(0x65)\n+OP_VERNOTIF = CScriptOp(0x66)\n+OP_ELSE = CScriptOp(0x67)\n+OP_ENDIF = CScriptOp(0x68)\n+OP_VERIFY = CScriptOp(0x69)\n+OP_RETURN = CScriptOp(0x6a)\n+\n+# stack ops\n+OP_TOALTSTACK = CScriptOp(0x6b)\n+OP_FROMALTSTACK = CScriptOp(0x6c)\n+OP_2DROP = CScriptOp(0x6d)\n+OP_2DUP = CScriptOp(0x6e)\n+OP_3DUP = CScriptOp(0x6f)\n+OP_2OVER = CScriptOp(0x70)\n+OP_2ROT = CScriptOp(0x71)\n+OP_2SWAP = CScriptOp(0x72)\n+OP_IFDUP = CScriptOp(0x73)\n+OP_DEPTH = CScriptOp(0x74)\n+OP_DROP = CScriptOp(0x75)\n+OP_DUP = CScriptOp(0x76)\n+OP_NIP = CScriptOp(0x77)\n+OP_OVER = CScriptOp(0x78)\n+OP_PICK = CScriptOp(0x79)\n+OP_ROLL = CScriptOp(0x7a)\n+OP_ROT = CScriptOp(0x7b)\n+OP_SWAP = CScriptOp(0x7c)\n+OP_TUCK = CScriptOp(0x7d)\n+\n+# splice ops\n+OP_CAT = CScriptOp(0x7e)\n+OP_SUBSTR = CScriptOp(0x7f)\n+OP_LEFT = CScriptOp(0x80)\n+OP_RIGHT = CScriptOp(0x81)\n+OP_SIZE = CScriptOp(0x82)\n+\n+# bit logic\n+OP_INVERT = CScriptOp(0x83)\n+OP_AND = CScriptOp(0x84)\n+OP_OR = CScriptOp(0x85)\n+OP_XOR = CScriptOp(0x86)\n+OP_EQUAL = CScriptOp(0x87)\n+OP_EQUALVERIFY = CScriptOp(0x88)\n+OP_RESERVED1 = CScriptOp(0x89)\n+OP_RESERVED2 = CScriptOp(0x8a)\n+\n+# numeric\n+OP_1ADD = CScriptOp(0x8b)\n+OP_1SUB = CScriptOp(0x8c)\n+OP_2MUL = CScriptOp(0x8d)\n+OP_2DIV = CScriptOp(0x8e)\n+OP_NEGATE = CScriptOp(0x8f)\n+OP_ABS = CScriptOp(0x90)\n+OP_NOT = CScriptOp(0x91)\n+OP_0NOTEQUAL = CScriptOp(0x92)\n+\n+OP_ADD = CScriptOp(0x93)\n+OP_SUB = CScriptOp(0x94)\n+OP_MUL = CScriptOp(0x95)\n+OP_DIV = CScriptOp(0x96)\n+OP_MOD = CScriptOp(0x97)\n+OP_LSHIFT = CScriptOp(0x98)\n+OP_RSHIFT = CScriptOp(0x99)\n+\n+OP_BOOLAND = CScriptOp(0x9a)\n+OP_BOOLOR = CScriptOp(0x9b)\n+OP_NUMEQUAL = CScriptOp(0x9c)\n+OP_NUMEQUALVERIFY = CScriptOp(0x9d)\n+OP_NUMNOTEQUAL = CScriptOp(0x9e)\n+OP_LESSTHAN = CScriptOp(0x9f)\n+OP_GREATERTHAN = CScriptOp(0xa0)\n+OP_LESSTHANOREQUAL = CScriptOp(0xa1)\n+OP_GREATERTHANOREQUAL = CScriptOp(0xa2)\n+OP_MIN = CScriptOp(0xa3)\n+OP_MAX = CScriptOp(0xa4)\n+\n+OP_WITHIN = CScriptOp(0xa5)\n+\n+# crypto\n+OP_RIPEMD160 = CScriptOp(0xa6)\n+OP_SHA1 = CScriptOp(0xa7)\n+OP_SHA256 = CScriptOp(0xa8)\n+OP_HASH160 = CScriptOp(0xa9)\n+OP_HASH256 = CScriptOp(0xaa)\n+OP_CODESEPARATOR = CScriptOp(0xab)\n+OP_CHECKSIG = CScriptOp(0xac)\n+OP_CHECKSIGVERIFY = CScriptOp(0xad)\n+OP_CHECKMULTISIG = CScriptOp(0xae)\n+OP_CHECKMULTISIGVERIFY = CScriptOp(0xaf)\n+\n+# expansion\n+OP_NOP1 = CScriptOp(0xb0)\n+OP_NOP2 = CScriptOp(0xb1)\n+OP_NOP3 = CScriptOp(0xb2)\n+OP_NOP4 = CScriptOp(0xb3)\n+OP_NOP5 = CScriptOp(0xb4)\n+OP_NOP6 = CScriptOp(0xb5)\n+OP_NOP7 = CScriptOp(0xb6)\n+OP_NOP8 = CScriptOp(0xb7)\n+OP_NOP9 = CScriptOp(0xb8)\n+OP_NOP10 = CScriptOp(0xb9)\n+\n+# template matching params\n+OP_SMALLINTEGER = CScriptOp(0xfa)\n+OP_PUBKEYS = CScriptOp(0xfb)\n+OP_PUBKEYHASH = CScriptOp(0xfd)\n+OP_PUBKEY = CScriptOp(0xfe)\n+\n+OP_INVALIDOPCODE = CScriptOp(0xff)\n+\n+VALID_OPCODES = {\n+    OP_1NEGATE,\n+    OP_RESERVED,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_13,\n+    OP_14,\n+    OP_15,\n+    OP_16,\n+\n+    OP_NOP,\n+    OP_VER,\n+    OP_IF,\n+    OP_NOTIF,\n+    OP_VERIF,\n+    OP_VERNOTIF,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_VERIFY,\n+    OP_RETURN,\n+\n+    OP_TOALTSTACK,\n+    OP_FROMALTSTACK,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_3DUP,\n+    OP_2OVER,\n+    OP_2ROT,\n+    OP_2SWAP,\n+    OP_IFDUP,\n+    OP_DEPTH,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_NIP,\n+    OP_OVER,\n+    OP_PICK,\n+    OP_ROLL,\n+    OP_ROT,\n+    OP_SWAP,\n+    OP_TUCK,\n+\n+    OP_CAT,\n+    OP_SUBSTR,\n+    OP_LEFT,\n+    OP_RIGHT,\n+    OP_SIZE,\n+\n+    OP_INVERT,\n+    OP_AND,\n+    OP_OR,\n+    OP_XOR,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_RESERVED1,\n+    OP_RESERVED2,\n+\n+    OP_1ADD,\n+    OP_1SUB,\n+    OP_2MUL,\n+    OP_2DIV,\n+    OP_NEGATE,\n+    OP_ABS,\n+    OP_NOT,\n+    OP_0NOTEQUAL,\n+\n+    OP_ADD,\n+    OP_SUB,\n+    OP_MUL,\n+    OP_DIV,\n+    OP_MOD,\n+    OP_LSHIFT,\n+    OP_RSHIFT,\n+\n+    OP_BOOLAND,\n+    OP_BOOLOR,\n+    OP_NUMEQUAL,\n+    OP_NUMEQUALVERIFY,\n+    OP_NUMNOTEQUAL,\n+    OP_LESSTHAN,\n+    OP_GREATERTHAN,\n+    OP_LESSTHANOREQUAL,\n+    OP_GREATERTHANOREQUAL,\n+    OP_MIN,\n+    OP_MAX,\n+\n+    OP_WITHIN,\n+\n+    OP_RIPEMD160,\n+    OP_SHA1,\n+    OP_SHA256,\n+    OP_HASH160,\n+    OP_HASH256,\n+    OP_CODESEPARATOR,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGVERIFY,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+\n+    OP_NOP1,\n+    OP_NOP2,\n+    OP_NOP3,\n+    OP_NOP4,\n+    OP_NOP5,\n+    OP_NOP6,\n+    OP_NOP7,\n+    OP_NOP8,\n+    OP_NOP9,\n+    OP_NOP10,\n+\n+    OP_SMALLINTEGER,\n+    OP_PUBKEYS,\n+    OP_PUBKEYHASH,\n+    OP_PUBKEY,\n+}\n+\n+OPCODE_NAMES.update({\n+    OP_0 : 'OP_0',\n+    OP_PUSHDATA1 : 'OP_PUSHDATA1',\n+    OP_PUSHDATA2 : 'OP_PUSHDATA2',\n+    OP_PUSHDATA4 : 'OP_PUSHDATA4',\n+    OP_1NEGATE : 'OP_1NEGATE',\n+    OP_RESERVED : 'OP_RESERVED',\n+    OP_1 : 'OP_1',\n+    OP_2 : 'OP_2',\n+    OP_3 : 'OP_3',\n+    OP_4 : 'OP_4',\n+    OP_5 : 'OP_5',\n+    OP_6 : 'OP_6',\n+    OP_7 : 'OP_7',\n+    OP_8 : 'OP_8',\n+    OP_9 : 'OP_9',\n+    OP_10 : 'OP_10',\n+    OP_11 : 'OP_11',\n+    OP_12 : 'OP_12',\n+    OP_13 : 'OP_13',\n+    OP_14 : 'OP_14',\n+    OP_15 : 'OP_15',\n+    OP_16 : 'OP_16',\n+    OP_NOP : 'OP_NOP',\n+    OP_VER : 'OP_VER',\n+    OP_IF : 'OP_IF',\n+    OP_NOTIF : 'OP_NOTIF',\n+    OP_VERIF : 'OP_VERIF',\n+    OP_VERNOTIF : 'OP_VERNOTIF',\n+    OP_ELSE : 'OP_ELSE',\n+    OP_ENDIF : 'OP_ENDIF',\n+    OP_VERIFY : 'OP_VERIFY',\n+    OP_RETURN : 'OP_RETURN',\n+    OP_TOALTSTACK : 'OP_TOALTSTACK',\n+    OP_FROMALTSTACK : 'OP_FROMALTSTACK',\n+    OP_2DROP : 'OP_2DROP',\n+    OP_2DUP : 'OP_2DUP',\n+    OP_3DUP : 'OP_3DUP',\n+    OP_2OVER : 'OP_2OVER',\n+    OP_2ROT : 'OP_2ROT',\n+    OP_2SWAP : 'OP_2SWAP',\n+    OP_IFDUP : 'OP_IFDUP',\n+    OP_DEPTH : 'OP_DEPTH',\n+    OP_DROP : 'OP_DROP',\n+    OP_DUP : 'OP_DUP',\n+    OP_NIP : 'OP_NIP',\n+    OP_OVER : 'OP_OVER',\n+    OP_PICK : 'OP_PICK',\n+    OP_ROLL : 'OP_ROLL',\n+    OP_ROT : 'OP_ROT',\n+    OP_SWAP : 'OP_SWAP',\n+    OP_TUCK : 'OP_TUCK',\n+    OP_CAT : 'OP_CAT',\n+    OP_SUBSTR : 'OP_SUBSTR',\n+    OP_LEFT : 'OP_LEFT',\n+    OP_RIGHT : 'OP_RIGHT',\n+    OP_SIZE : 'OP_SIZE',\n+    OP_INVERT : 'OP_INVERT',\n+    OP_AND : 'OP_AND',\n+    OP_OR : 'OP_OR',\n+    OP_XOR : 'OP_XOR',\n+    OP_EQUAL : 'OP_EQUAL',\n+    OP_EQUALVERIFY : 'OP_EQUALVERIFY',\n+    OP_RESERVED1 : 'OP_RESERVED1',\n+    OP_RESERVED2 : 'OP_RESERVED2',\n+    OP_1ADD : 'OP_1ADD',\n+    OP_1SUB : 'OP_1SUB',\n+    OP_2MUL : 'OP_2MUL',\n+    OP_2DIV : 'OP_2DIV',\n+    OP_NEGATE : 'OP_NEGATE',\n+    OP_ABS : 'OP_ABS',\n+    OP_NOT : 'OP_NOT',\n+    OP_0NOTEQUAL : 'OP_0NOTEQUAL',\n+    OP_ADD : 'OP_ADD',\n+    OP_SUB : 'OP_SUB',\n+    OP_MUL : 'OP_MUL',\n+    OP_DIV : 'OP_DIV',\n+    OP_MOD : 'OP_MOD',\n+    OP_LSHIFT : 'OP_LSHIFT',\n+    OP_RSHIFT : 'OP_RSHIFT',\n+    OP_BOOLAND : 'OP_BOOLAND',\n+    OP_BOOLOR : 'OP_BOOLOR',\n+    OP_NUMEQUAL : 'OP_NUMEQUAL',\n+    OP_NUMEQUALVERIFY : 'OP_NUMEQUALVERIFY',\n+    OP_NUMNOTEQUAL : 'OP_NUMNOTEQUAL',\n+    OP_LESSTHAN : 'OP_LESSTHAN',\n+    OP_GREATERTHAN : 'OP_GREATERTHAN',\n+    OP_LESSTHANOREQUAL : 'OP_LESSTHANOREQUAL',\n+    OP_GREATERTHANOREQUAL : 'OP_GREATERTHANOREQUAL',\n+    OP_MIN : 'OP_MIN',\n+    OP_MAX : 'OP_MAX',\n+    OP_WITHIN : 'OP_WITHIN',\n+    OP_RIPEMD160 : 'OP_RIPEMD160',\n+    OP_SHA1 : 'OP_SHA1',\n+    OP_SHA256 : 'OP_SHA256',\n+    OP_HASH160 : 'OP_HASH160',\n+    OP_HASH256 : 'OP_HASH256',\n+    OP_CODESEPARATOR : 'OP_CODESEPARATOR',\n+    OP_CHECKSIG : 'OP_CHECKSIG',\n+    OP_CHECKSIGVERIFY : 'OP_CHECKSIGVERIFY',\n+    OP_CHECKMULTISIG : 'OP_CHECKMULTISIG',\n+    OP_CHECKMULTISIGVERIFY : 'OP_CHECKMULTISIGVERIFY',\n+    OP_NOP1 : 'OP_NOP1',\n+    OP_NOP2 : 'OP_NOP2',\n+    OP_NOP3 : 'OP_NOP3',\n+    OP_NOP4 : 'OP_NOP4',\n+    OP_NOP5 : 'OP_NOP5',\n+    OP_NOP6 : 'OP_NOP6',\n+    OP_NOP7 : 'OP_NOP7',\n+    OP_NOP8 : 'OP_NOP8',\n+    OP_NOP9 : 'OP_NOP9',\n+    OP_NOP10 : 'OP_NOP10',\n+    OP_SMALLINTEGER : 'OP_SMALLINTEGER',\n+    OP_PUBKEYS : 'OP_PUBKEYS',\n+    OP_PUBKEYHASH : 'OP_PUBKEYHASH',\n+    OP_PUBKEY : 'OP_PUBKEY',\n+    OP_INVALIDOPCODE : 'OP_INVALIDOPCODE',\n+})\n+\n+OPCODES_BY_NAME = {\n+    'OP_0' : OP_0,\n+    'OP_PUSHDATA1' : OP_PUSHDATA1,\n+    'OP_PUSHDATA2' : OP_PUSHDATA2,\n+    'OP_PUSHDATA4' : OP_PUSHDATA4,\n+    'OP_1NEGATE' : OP_1NEGATE,\n+    'OP_RESERVED' : OP_RESERVED,\n+    'OP_1' : OP_1,\n+    'OP_2' : OP_2,\n+    'OP_3' : OP_3,\n+    'OP_4' : OP_4,\n+    'OP_5' : OP_5,\n+    'OP_6' : OP_6,\n+    'OP_7' : OP_7,\n+    'OP_8' : OP_8,\n+    'OP_9' : OP_9,\n+    'OP_10' : OP_10,\n+    'OP_11' : OP_11,\n+    'OP_12' : OP_12,\n+    'OP_13' : OP_13,\n+    'OP_14' : OP_14,\n+    'OP_15' : OP_15,\n+    'OP_16' : OP_16,\n+    'OP_NOP' : OP_NOP,\n+    'OP_VER' : OP_VER,\n+    'OP_IF' : OP_IF,\n+    'OP_NOTIF' : OP_NOTIF,\n+    'OP_VERIF' : OP_VERIF,\n+    'OP_VERNOTIF' : OP_VERNOTIF,\n+    'OP_ELSE' : OP_ELSE,\n+    'OP_ENDIF' : OP_ENDIF,\n+    'OP_VERIFY' : OP_VERIFY,\n+    'OP_RETURN' : OP_RETURN,\n+    'OP_TOALTSTACK' : OP_TOALTSTACK,\n+    'OP_FROMALTSTACK' : OP_FROMALTSTACK,\n+    'OP_2DROP' : OP_2DROP,\n+    'OP_2DUP' : OP_2DUP,\n+    'OP_3DUP' : OP_3DUP,\n+    'OP_2OVER' : OP_2OVER,\n+    'OP_2ROT' : OP_2ROT,\n+    'OP_2SWAP' : OP_2SWAP,\n+    'OP_IFDUP' : OP_IFDUP,\n+    'OP_DEPTH' : OP_DEPTH,\n+    'OP_DROP' : OP_DROP,\n+    'OP_DUP' : OP_DUP,\n+    'OP_NIP' : OP_NIP,\n+    'OP_OVER' : OP_OVER,\n+    'OP_PICK' : OP_PICK,\n+    'OP_ROLL' : OP_ROLL,\n+    'OP_ROT' : OP_ROT,\n+    'OP_SWAP' : OP_SWAP,\n+    'OP_TUCK' : OP_TUCK,\n+    'OP_CAT' : OP_CAT,\n+    'OP_SUBSTR' : OP_SUBSTR,\n+    'OP_LEFT' : OP_LEFT,\n+    'OP_RIGHT' : OP_RIGHT,\n+    'OP_SIZE' : OP_SIZE,\n+    'OP_INVERT' : OP_INVERT,\n+    'OP_AND' : OP_AND,\n+    'OP_OR' : OP_OR,\n+    'OP_XOR' : OP_XOR,\n+    'OP_EQUAL' : OP_EQUAL,\n+    'OP_EQUALVERIFY' : OP_EQUALVERIFY,\n+    'OP_RESERVED1' : OP_RESERVED1,\n+    'OP_RESERVED2' : OP_RESERVED2,\n+    'OP_1ADD' : OP_1ADD,\n+    'OP_1SUB' : OP_1SUB,\n+    'OP_2MUL' : OP_2MUL,\n+    'OP_2DIV' : OP_2DIV,\n+    'OP_NEGATE' : OP_NEGATE,\n+    'OP_ABS' : OP_ABS,\n+    'OP_NOT' : OP_NOT,\n+    'OP_0NOTEQUAL' : OP_0NOTEQUAL,\n+    'OP_ADD' : OP_ADD,\n+    'OP_SUB' : OP_SUB,\n+    'OP_MUL' : OP_MUL,\n+    'OP_DIV' : OP_DIV,\n+    'OP_MOD' : OP_MOD,\n+    'OP_LSHIFT' : OP_LSHIFT,\n+    'OP_RSHIFT' : OP_RSHIFT,\n+    'OP_BOOLAND' : OP_BOOLAND,\n+    'OP_BOOLOR' : OP_BOOLOR,\n+    'OP_NUMEQUAL' : OP_NUMEQUAL,\n+    'OP_NUMEQUALVERIFY' : OP_NUMEQUALVERIFY,\n+    'OP_NUMNOTEQUAL' : OP_NUMNOTEQUAL,\n+    'OP_LESSTHAN' : OP_LESSTHAN,\n+    'OP_GREATERTHAN' : OP_GREATERTHAN,\n+    'OP_LESSTHANOREQUAL' : OP_LESSTHANOREQUAL,\n+    'OP_GREATERTHANOREQUAL' : OP_GREATERTHANOREQUAL,\n+    'OP_MIN' : OP_MIN,\n+    'OP_MAX' : OP_MAX,\n+    'OP_WITHIN' : OP_WITHIN,\n+    'OP_RIPEMD160' : OP_RIPEMD160,\n+    'OP_SHA1' : OP_SHA1,\n+    'OP_SHA256' : OP_SHA256,\n+    'OP_HASH160' : OP_HASH160,\n+    'OP_HASH256' : OP_HASH256,\n+    'OP_CODESEPARATOR' : OP_CODESEPARATOR,\n+    'OP_CHECKSIG' : OP_CHECKSIG,\n+    'OP_CHECKSIGVERIFY' : OP_CHECKSIGVERIFY,\n+    'OP_CHECKMULTISIG' : OP_CHECKMULTISIG,\n+    'OP_CHECKMULTISIGVERIFY' : OP_CHECKMULTISIGVERIFY,\n+    'OP_NOP1' : OP_NOP1,\n+    'OP_NOP2' : OP_NOP2,\n+    'OP_NOP3' : OP_NOP3,\n+    'OP_NOP4' : OP_NOP4,\n+    'OP_NOP5' : OP_NOP5,\n+    'OP_NOP6' : OP_NOP6,\n+    'OP_NOP7' : OP_NOP7,\n+    'OP_NOP8' : OP_NOP8,\n+    'OP_NOP9' : OP_NOP9,\n+    'OP_NOP10' : OP_NOP10,\n+    'OP_SMALLINTEGER' : OP_SMALLINTEGER,\n+    'OP_PUBKEYS' : OP_PUBKEYS,\n+    'OP_PUBKEYHASH' : OP_PUBKEYHASH,\n+    'OP_PUBKEY' : OP_PUBKEY,\n+}\n+\n+class CScriptInvalidError(Exception):\n+    \"\"\"Base class for CScript exceptions\"\"\"\n+    pass\n+\n+class CScriptTruncatedPushDataError(CScriptInvalidError):\n+    \"\"\"Invalid pushdata due to truncation\"\"\"\n+    def __init__(self, msg, data):\n+        self.data = data\n+        super(CScriptTruncatedPushDataError, self).__init__(msg)\n+\n+# This is used, eg, for blockchain heights in coinbase scripts (bip34)\n+class CScriptNum(object):\n+    def __init__(self, d=0):\n+        self.value = d\n+\n+    @staticmethod\n+    def encode(obj):\n+        r = bytearray(0)\n+        if obj.value == 0:\n+            return bytes(r)\n+        neg = obj.value < 0\n+        absvalue = -obj.value if neg else obj.value\n+        while (absvalue):\n+            r.append(chr(absvalue & 0xff))\n+            absvalue >>= 8\n+        if r[-1] & 0x80:\n+            r.append(0x80 if neg else 0)\n+        elif neg:\n+            r[-1] |= 0x80\n+        return bytes(bchr(len(r)) + r)\n+\n+\n+class CScript(bytes):\n+    \"\"\"Serialized script\n+\n+    A bytes subclass, so you can use this directly whenever bytes are accepted.\n+    Note that this means that indexing does *not* work - you'll get an index by\n+    byte rather than opcode. This format was chosen for efficiency so that the\n+    general case would not require creating a lot of little CScriptOP objects.\n+\n+    iter(script) however does iterate by opcode.\n+    \"\"\"\n+    @classmethod\n+    def __coerce_instance(cls, other):\n+        # Coerce other into bytes\n+        if isinstance(other, CScriptOp):\n+            other = bchr(other)\n+        elif isinstance(other, CScriptNum):\n+            if (other.value == 0):\n+                other = bchr(CScriptOp(OP_0))\n+            else:\n+                other = CScriptNum.encode(other)\n+        elif isinstance(other, (int, long)):\n+            if 0 <= other <= 16:\n+                other = bytes(bchr(CScriptOp.encode_op_n(other)))\n+            elif other == -1:\n+                other = bytes(bchr(OP_1NEGATE))\n+            else:\n+                other = CScriptOp.encode_op_pushdata(bignum.bn2vch(other))\n+        elif isinstance(other, (bytes, bytearray)):\n+            other = CScriptOp.encode_op_pushdata(other)\n+        return other\n+\n+    def __add__(self, other):\n+        # Do the coercion outside of the try block so that errors in it are\n+        # noticed.\n+        other = self.__coerce_instance(other)\n+\n+        try:\n+            # bytes.__add__ always returns bytes instances unfortunately\n+            return CScript(super(CScript, self).__add__(other))\n+        except TypeError:\n+            raise TypeError('Can not add a %r instance to a CScript' % other.__class__)\n+\n+    def join(self, iterable):\n+        # join makes no sense for a CScript()\n+        raise NotImplementedError\n+\n+    def __new__(cls, value=b''):\n+        if isinstance(value, bytes) or isinstance(value, bytearray):\n+            return super(CScript, cls).__new__(cls, value)\n+        else:\n+            def coerce_iterable(iterable):\n+                for instance in iterable:\n+                    yield cls.__coerce_instance(instance)\n+            # Annoyingly on both python2 and python3 bytes.join() always\n+            # returns a bytes instance even when subclassed.\n+            return super(CScript, cls).__new__(cls, b''.join(coerce_iterable(value)))\n+\n+    def raw_iter(self):\n+        \"\"\"Raw iteration\n+\n+        Yields tuples of (opcode, data, sop_idx) so that the different possible\n+        PUSHDATA encodings can be accurately distinguished, as well as\n+        determining the exact opcode byte indexes. (sop_idx)\n+        \"\"\"\n+        i = 0\n+        while i < len(self):\n+            sop_idx = i\n+            opcode = bord(self[i])\n+            i += 1\n+\n+            if opcode > OP_PUSHDATA4:\n+                yield (opcode, None, sop_idx)\n+            else:\n+                datasize = None\n+                pushdata_type = None\n+                if opcode < OP_PUSHDATA1:\n+                    pushdata_type = 'PUSHDATA(%d)' % opcode\n+                    datasize = opcode\n+\n+                elif opcode == OP_PUSHDATA1:\n+                    pushdata_type = 'PUSHDATA1'\n+                    if i >= len(self):\n+                        raise CScriptInvalidError('PUSHDATA1: missing data length')\n+                    datasize = bord(self[i])\n+                    i += 1\n+\n+                elif opcode == OP_PUSHDATA2:\n+                    pushdata_type = 'PUSHDATA2'\n+                    if i + 1 >= len(self):\n+                        raise CScriptInvalidError('PUSHDATA2: missing data length')\n+                    datasize = bord(self[i]) + (bord(self[i+1]) << 8)\n+                    i += 2\n+\n+                elif opcode == OP_PUSHDATA4:\n+                    pushdata_type = 'PUSHDATA4'\n+                    if i + 3 >= len(self):\n+                        raise CScriptInvalidError('PUSHDATA4: missing data length')\n+                    datasize = bord(self[i]) + (bord(self[i+1]) << 8) + (bord(self[i+2]) << 16) + (bord(self[i+3]) << 24)\n+                    i += 4\n+\n+                else:\n+                    assert False # shouldn't happen\n+\n+\n+                data = bytes(self[i:i+datasize])\n+\n+                # Check for truncation\n+                if len(data) < datasize:\n+                    raise CScriptTruncatedPushDataError('%s: truncated data' % pushdata_type, data)\n+\n+                i += datasize\n+\n+                yield (opcode, data, sop_idx)\n+\n+    def __iter__(self):\n+        \"\"\"'Cooked' iteration\n+\n+        Returns either a CScriptOP instance, an integer, or bytes, as\n+        appropriate.\n+\n+        See raw_iter() if you need to distinguish the different possible\n+        PUSHDATA encodings.\n+        \"\"\"\n+        for (opcode, data, sop_idx) in self.raw_iter():\n+            if data is not None:\n+                yield data\n+            else:\n+                opcode = CScriptOp(opcode)\n+\n+                if opcode.is_small_int():\n+                    yield opcode.decode_op_n()\n+                else:\n+                    yield CScriptOp(opcode)\n+\n+    def __repr__(self):\n+        # For Python3 compatibility add b before strings so testcases don't\n+        # need to change\n+        def _repr(o):\n+            if isinstance(o, bytes):\n+                return \"x('%s')\" % binascii.hexlify(o).decode('utf8')\n+            else:\n+                return repr(o)\n+\n+        ops = []\n+        i = iter(self)\n+        while True:\n+            op = None\n+            try:\n+                op = _repr(next(i))\n+            except CScriptTruncatedPushDataError as err:\n+                op = '%s...<ERROR: %s>' % (_repr(err.data), err)\n+                break\n+            except CScriptInvalidError as err:\n+                op = '<ERROR: %s>' % err\n+                break\n+            except StopIteration:\n+                break\n+            finally:\n+                if op is not None:\n+                    ops.append(op)\n+\n+        return \"CScript([%s])\" % ', '.join(ops)\n+\n+    def GetSigOpCount(self, fAccurate):\n+        \"\"\"Get the SigOp count.\n+\n+        fAccurate - Accurately count CHECKMULTISIG, see BIP16 for details.\n+\n+        Note that this is consensus-critical.\n+        \"\"\"\n+        n = 0\n+        lastOpcode = OP_INVALIDOPCODE\n+        for (opcode, data, sop_idx) in self.raw_iter():\n+            if opcode in (OP_CHECKSIG, OP_CHECKSIGVERIFY):\n+                n += 1\n+            elif opcode in (OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY):\n+                if fAccurate and (OP_1 <= lastOpcode <= OP_16):\n+                    n += opcode.decode_op_n()\n+                else:\n+                    n += 20\n+            lastOpcode = opcode\n+        return n\n+\n+\n+SIGHASH_ALL = 1\n+SIGHASH_NONE = 2\n+SIGHASH_SINGLE = 3\n+SIGHASH_ANYONECANPAY = 0x80\n+\n+def FindAndDelete(script, sig):\n+    \"\"\"Consensus critical, see FindAndDelete() in Satoshi codebase\"\"\"\n+    r = b''\n+    last_sop_idx = sop_idx = 0\n+    skip = True\n+    for (opcode, data, sop_idx) in script.raw_iter():\n+        if not skip:\n+            r += script[last_sop_idx:sop_idx]\n+        last_sop_idx = sop_idx\n+        if script[sop_idx:sop_idx + len(sig)] == sig:\n+            skip = True\n+        else:\n+            skip = False\n+    if not skip:\n+        r += script[last_sop_idx:]\n+    return CScript(r)\n+\n+\n+def SignatureHash(script, txTo, inIdx, hashtype):\n+    \"\"\"Consensus-correct SignatureHash\n+\n+    Returns (hash, err) to precisely match the consensus-critical behavior of\n+    the SIGHASH_SINGLE bug. (inIdx is *not* checked for validity)\n+    \"\"\"\n+    HASH_ONE = b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n+\n+    if inIdx >= len(txTo.vin):\n+        return (HASH_ONE, \"inIdx %d out of range (%d)\" % (inIdx, len(txTo.vin)))\n+    txtmp = CTransaction(txTo)\n+\n+    for txin in txtmp.vin:\n+        txin.scriptSig = b''\n+    txtmp.vin[inIdx].scriptSig = FindAndDelete(script, CScript([OP_CODESEPARATOR]))\n+\n+    if (hashtype & 0x1f) == SIGHASH_NONE:\n+        txtmp.vout = []\n+\n+        for i in range(len(txtmp.vin)):\n+            if i != inIdx:\n+                txtmp.vin[i].nSequence = 0\n+\n+    elif (hashtype & 0x1f) == SIGHASH_SINGLE:\n+        outIdx = inIdx\n+        if outIdx >= len(txtmp.vout):\n+            return (HASH_ONE, \"outIdx %d out of range (%d)\" % (outIdx, len(txtmp.vout)))\n+\n+        tmp = txtmp.vout[outIdx]\n+        txtmp.vout = []\n+        for i in range(outIdx):\n+            txtmp.vout.append(CTxOut())\n+        txtmp.vout.append(tmp)\n+\n+        for i in range(len(txtmp.vin)):\n+            if i != inIdx:\n+                txtmp.vin[i].nSequence = 0\n+\n+    if hashtype & SIGHASH_ANYONECANPAY:\n+        tmp = txtmp.vin[inIdx]\n+        txtmp.vin = []\n+        txtmp.vin.append(tmp)\n+\n+    s = txtmp.serialize()\n+    s += struct.pack(b\"<I\", hashtype)\n+\n+    hash = hash256(s)\n+\n+    return (hash, None)"
      },
      {
        "sha": "1dbfb98d5d3dd6892825aeaec8e37ca0d1566a98",
        "filename": "qa/rpc-tests/test_framework/socks5.py",
        "status": "added",
        "additions": 160,
        "deletions": 0,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/socks5.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/socks5.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/socks5.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,160 @@\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+'''\n+Dummy Socks5 server for testing.\n+'''\n+from __future__ import print_function, division, unicode_literals\n+import socket, threading, Queue\n+import traceback, sys\n+\n+### Protocol constants\n+class Command:\n+    CONNECT = 0x01\n+\n+class AddressType:\n+    IPV4 = 0x01\n+    DOMAINNAME = 0x03\n+    IPV6 = 0x04\n+\n+### Utility functions\n+def recvall(s, n):\n+    '''Receive n bytes from a socket, or fail'''\n+    rv = bytearray()\n+    while n > 0:\n+        d = s.recv(n)\n+        if not d:\n+            raise IOError('Unexpected end of stream')\n+        rv.extend(d)\n+        n -= len(d)\n+    return rv\n+\n+### Implementation classes\n+class Socks5Configuration(object):\n+    '''Proxy configuration'''\n+    def __init__(self):\n+        self.addr = None # Bind address (must be set)\n+        self.af = socket.AF_INET # Bind address family\n+        self.unauth = False  # Support unauthenticated\n+        self.auth = False  # Support authentication\n+\n+class Socks5Command(object):\n+    '''Information about an incoming socks5 command'''\n+    def __init__(self, cmd, atyp, addr, port, username, password):\n+        self.cmd = cmd # Command (one of Command.*)\n+        self.atyp = atyp # Address type (one of AddressType.*)\n+        self.addr = addr # Address\n+        self.port = port # Port to connect to\n+        self.username = username\n+        self.password = password\n+    def __repr__(self):\n+        return 'Socks5Command(%s,%s,%s,%s,%s,%s)' % (self.cmd, self.atyp, self.addr, self.port, self.username, self.password)\n+\n+class Socks5Connection(object):\n+    def __init__(self, serv, conn, peer):\n+        self.serv = serv\n+        self.conn = conn\n+        self.peer = peer\n+\n+    def handle(self):\n+        '''\n+        Handle socks5 request according to RFC1928\n+        '''\n+        try:\n+            # Verify socks version\n+            ver = recvall(self.conn, 1)[0]\n+            if ver != 0x05:\n+                raise IOError('Invalid socks version %i' % ver)\n+            # Choose authentication method\n+            nmethods = recvall(self.conn, 1)[0]\n+            methods = bytearray(recvall(self.conn, nmethods))\n+            method = None\n+            if 0x02 in methods and self.serv.conf.auth:\n+                method = 0x02 # username/password\n+            elif 0x00 in methods and self.serv.conf.unauth:\n+                method = 0x00 # unauthenticated\n+            if method is None:\n+                raise IOError('No supported authentication method was offered')\n+            # Send response\n+            self.conn.sendall(bytearray([0x05, method]))\n+            # Read authentication (optional)\n+            username = None\n+            password = None\n+            if method == 0x02:\n+                ver = recvall(self.conn, 1)[0]\n+                if ver != 0x01:\n+                    raise IOError('Invalid auth packet version %i' % ver)\n+                ulen = recvall(self.conn, 1)[0]\n+                username = str(recvall(self.conn, ulen))\n+                plen = recvall(self.conn, 1)[0]\n+                password = str(recvall(self.conn, plen))\n+                # Send authentication response\n+                self.conn.sendall(bytearray([0x01, 0x00]))\n+\n+            # Read connect request\n+            (ver,cmd,rsv,atyp) = recvall(self.conn, 4)\n+            if ver != 0x05:\n+                raise IOError('Invalid socks version %i in connect request' % ver)\n+            if cmd != Command.CONNECT:\n+                raise IOError('Unhandled command %i in connect request' % cmd)\n+\n+            if atyp == AddressType.IPV4:\n+                addr = recvall(self.conn, 4)\n+            elif atyp == AddressType.DOMAINNAME:\n+                n = recvall(self.conn, 1)[0]\n+                addr = str(recvall(self.conn, n))\n+            elif atyp == AddressType.IPV6:\n+                addr = recvall(self.conn, 16)\n+            else:\n+                raise IOError('Unknown address type %i' % atyp)\n+            port_hi,port_lo = recvall(self.conn, 2)\n+            port = (port_hi << 8) | port_lo\n+\n+            # Send dummy response\n+            self.conn.sendall(bytearray([0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))\n+\n+            cmdin = Socks5Command(cmd, atyp, addr, port, username, password)\n+            self.serv.queue.put(cmdin)\n+            print('Proxy: ', cmdin)\n+            # Fall through to disconnect\n+        except Exception,e:\n+            traceback.print_exc(file=sys.stderr)\n+            self.serv.queue.put(e)\n+        finally:\n+            self.conn.close()\n+\n+class Socks5Server(object):\n+    def __init__(self, conf):\n+        self.conf = conf\n+        self.s = socket.socket(conf.af)\n+        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n+        self.s.bind(conf.addr)\n+        self.s.listen(5)\n+        self.running = False\n+        self.thread = None\n+        self.queue = Queue.Queue() # report connections and exceptions to client\n+\n+    def run(self):\n+        while self.running:\n+            (sockconn, peer) = self.s.accept()\n+            if self.running:\n+                conn = Socks5Connection(self, sockconn, peer)\n+                thread = threading.Thread(None, conn.handle)\n+                thread.daemon = True\n+                thread.start()\n+    \n+    def start(self):\n+        assert(not self.running)\n+        self.running = True\n+        self.thread = threading.Thread(None, self.run)\n+        self.thread.daemon = True\n+        self.thread.start()\n+\n+    def stop(self):\n+        self.running = False\n+        # connect to self to end run loop\n+        s = socket.socket(self.conf.af)\n+        s.connect(self.conf.addr)\n+        s.close()\n+        self.thread.join()\n+"
      },
      {
        "sha": "5671431f6e2a67052c308368b99f0f0437922316",
        "filename": "qa/rpc-tests/test_framework/test_framework.py",
        "status": "renamed",
        "additions": 42,
        "deletions": 5,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/test_framework.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,13 +8,12 @@\n # Add python-bitcoinrpc to module search path:\n import os\n import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n \n import shutil\n import tempfile\n import traceback\n \n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n \n \n@@ -89,8 +88,10 @@ def main(self):\n         parser = optparse.OptionParser(usage=\"%prog [options]\")\n         parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n                           help=\"Leave bitcoinds and test.* datadir on exit or error\")\n+        parser.add_option(\"--noshutdown\", dest=\"noshutdown\", default=False, action=\"store_true\",\n+                          help=\"Don't stop bitcoinds after the test execution\")\n         parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n-                          help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n+                          help=\"Source directory containing bitcoind/bitcoin-cli (default: %default)\")\n         parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n                           help=\"Root directory for datadirs\")\n         parser.add_option(\"--tracerpc\", dest=\"trace_rpc\", default=False, action=\"store_true\",\n@@ -128,10 +129,15 @@ def main(self):\n             print(\"Unexpected exception caught during testing: \"+str(e))\n             traceback.print_tb(sys.exc_info()[2])\n \n-        if not self.options.nocleanup:\n-            print(\"Cleaning up\")\n+        if not self.options.noshutdown:\n+            print(\"Stopping nodes\")\n             stop_nodes(self.nodes)\n             wait_bitcoinds()\n+        else:\n+            print(\"Note: bitcoinds were not stopped and may still be running\")\n+\n+        if not self.options.nocleanup and not self.options.noshutdown:\n+            print(\"Cleaning up\")\n             shutil.rmtree(self.options.tmpdir)\n \n         if success:\n@@ -140,3 +146,34 @@ def main(self):\n         else:\n             print(\"Failed\")\n             sys.exit(1)\n+\n+\n+# Test framework for doing p2p comparison testing, which sets up some bitcoind\n+# binaries:\n+# 1 binary: test binary\n+# 2 binaries: 1 test binary, 1 ref binary\n+# n>2 binaries: 1 test binary, n-1 ref binaries\n+\n+class ComparisonTestFramework(BitcoinTestFramework):\n+\n+    # Can override the num_nodes variable to indicate how many nodes to run.\n+    def __init__(self):\n+        self.num_nodes = 2\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n+                          help=\"bitcoind binary to test\")\n+        parser.add_option(\"--refbinary\", dest=\"refbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n+                          help=\"bitcoind binary to use for reference nodes (if any)\")\n+\n+    def setup_chain(self):\n+        print \"Initializing test directory \"+self.options.tmpdir\n+        initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n+\n+    def setup_network(self):\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n+                                    extra_args=[['-debug', '-whitelist=127.0.0.1']] * self.num_nodes,\n+                                    binary=[self.options.testbinary] +\n+                                           [self.options.refbinary]*(self.num_nodes-1))",
        "previous_filename": "qa/rpc-tests/test_framework.py"
      },
      {
        "sha": "c236ec26025370f2a921e2acbf4e66a12e7ad60f",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "renamed",
        "additions": 26,
        "deletions": 13,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,7 +8,6 @@\n # Add python-bitcoinrpc to module search path:\n import os\n import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n \n from decimal import Decimal, ROUND_DOWN\n import json\n@@ -18,7 +17,7 @@\n import time\n import re\n \n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n \n def p2p_port(n):\n@@ -33,17 +32,17 @@ def check_json_precision():\n     if satoshis != 2000000000000003:\n         raise RuntimeError(\"JSON encode/decode loses precision\")\n \n-def sync_blocks(rpc_connections):\n+def sync_blocks(rpc_connections, wait=1):\n     \"\"\"\n     Wait until everybody has the same block count\n     \"\"\"\n     while True:\n         counts = [ x.getblockcount() for x in rpc_connections ]\n         if counts == [ counts[0] ]*len(counts):\n             break\n-        time.sleep(1)\n+        time.sleep(wait)\n \n-def sync_mempools(rpc_connections):\n+def sync_mempools(rpc_connections, wait=1):\n     \"\"\"\n     Wait until everybody has the same transactions in their memory\n     pools\n@@ -56,7 +55,7 @@ def sync_mempools(rpc_connections):\n                 num_match = num_match+1\n         if num_match == len(rpc_connections):\n             break\n-        time.sleep(1)\n+        time.sleep(wait)\n \n bitcoind_processes = {}\n \n@@ -88,8 +87,12 @@ def initialize_chain(test_dir):\n             if i > 0:\n                 args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n             bitcoind_processes[i] = subprocess.Popen(args)\n+            if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+                print \"initialize_chain: bitcoind started, calling bitcoin-cli -rpcwait getblockcount\"\n             subprocess.check_call([ os.getenv(\"BITCOINCLI\", \"bitcoin-cli\"), \"-datadir=\"+datadir,\n                                     \"-rpcwait\", \"getblockcount\"], stdout=devnull)\n+            if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+                print \"initialize_chain: bitcoin-cli -rpcwait getblockcount completed\"\n         devnull.close()\n         rpcs = []\n         for i in range(4):\n@@ -109,7 +112,7 @@ def initialize_chain(test_dir):\n             for peer in range(4):\n                 for j in range(25):\n                     set_node_times(rpcs, block_time)\n-                    rpcs[peer].setgenerate(True, 1)\n+                    rpcs[peer].generate(1)\n                     block_time += 10*60\n                 # Must sync before next peer starts generating blocks\n                 sync_blocks(rpcs)\n@@ -158,30 +161,40 @@ def _rpchost_to_args(rpchost):\n         rv += ['-rpcport=' + rpcport]\n     return rv\n \n-def start_node(i, dirname, extra_args=None, rpchost=None):\n+def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n     \"\"\"\n     Start a bitcoind and return RPC connection to it\n     \"\"\"\n     datadir = os.path.join(dirname, \"node\"+str(i))\n-    args = [ os.getenv(\"BITCOIND\", \"bitcoind\"), \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\", \"-rest\" ]\n+    if binary is None:\n+        binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n+    args = [ binary, \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\", \"-rest\" ]\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args)\n     devnull = open(\"/dev/null\", \"w+\")\n+    if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+        print \"start_node: bitcoind started, calling bitcoin-cli -rpcwait getblockcount\"\n     subprocess.check_call([ os.getenv(\"BITCOINCLI\", \"bitcoin-cli\"), \"-datadir=\"+datadir] +\n                           _rpchost_to_args(rpchost)  +\n                           [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n+    if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+        print \"start_node: calling bitcoin-cli -rpcwait getblockcount returned\"\n     devnull.close()\n     url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n-    proxy = AuthServiceProxy(url)\n+    if timewait is not None:\n+        proxy = AuthServiceProxy(url, timeout=timewait)\n+    else:\n+        proxy = AuthServiceProxy(url)\n     proxy.url = url # store URL on proxy for info\n     return proxy\n \n-def start_nodes(num_nodes, dirname, extra_args=None, rpchost=None):\n+def start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, binary=None):\n     \"\"\"\n     Start multiple bitcoinds, return RPC connections to them\n     \"\"\"\n     if extra_args is None: extra_args = [ None for i in range(num_nodes) ]\n-    return [ start_node(i, dirname, extra_args[i], rpchost) for i in range(num_nodes) ]\n+    if binary is None: binary = [ None for i in range(num_nodes) ]\n+    return [ start_node(i, dirname, extra_args[i], rpchost, binary=binary[i]) for i in range(num_nodes) ]\n \n def log_filename(dirname, n_node, logname):\n     return os.path.join(dirname, \"node\"+str(n_node), \"regtest\", logname)\n@@ -269,7 +282,7 @@ def send_zeropri_transaction(from_node, to_node, amount, fee):\n     Create&broadcast a zero-priority transaction.\n     Returns (txid, hex-encoded-txdata)\n     Ensures transaction is zero-priority by first creating a send-to-self,\n-    then using it's output\n+    then using its output\n     \"\"\"\n \n     # Create a send-to-self with confirmed inputs:",
        "previous_filename": "qa/rpc-tests/util.py"
      },
      {
        "sha": "99dcdae55220896b7dc5206da6a40fe7638dda5d",
        "filename": "qa/rpc-tests/txn_doublespend.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txn_doublespend.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,10 +7,9 @@\n # Test proper accounting with malleable transactions\n #\n \n-from test_framework import BitcoinTestFramework\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n from decimal import Decimal\n-from util import *\n import os\n import shutil\n \n@@ -58,7 +57,7 @@ def run_test(self):\n         \n         # Have node0 mine a block:\n         if (self.options.mine_block):\n-            self.nodes[0].setgenerate(True, 1)\n+            self.nodes[0].generate(1)\n             sync_blocks(self.nodes[0:2])\n \n         tx1 = self.nodes[0].gettransaction(txid1)\n@@ -88,11 +87,11 @@ def run_test(self):\n         # Now give doublespend to miner:\n         mutated_txid = self.nodes[2].sendrawtransaction(doublespend[\"hex\"])\n         # ... mine a block...\n-        self.nodes[2].setgenerate(True, 1)\n+        self.nodes[2].generate(1)\n \n         # Reconnect the split network, and sync chain:\n         connect_nodes(self.nodes[1], 2)\n-        self.nodes[2].setgenerate(True, 1)  # Mine another block to make sure we sync\n+        self.nodes[2].generate(1)  # Mine another block to make sure we sync\n         sync_blocks(self.nodes)\n \n         # Re-fetch transaction info:"
      },
      {
        "sha": "46dc7765b6a1f482a66574524ed9e4f6dea23911",
        "filename": "qa/rpc-tests/wallet.py",
        "status": "modified",
        "additions": 125,
        "deletions": 10,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -16,17 +16,17 @@\n #   h) node0 should now have 2 unspent outputs;  send these to node2 via raw tx broadcast by node1\n #   i) have node1 mine a block\n #   j) check balances - node0 should have 0, node2 should have 100\n+#   k) test ResendWalletTransactions - create transactions, startup fourth node, make sure it syncs\n #\n \n-from test_framework import BitcoinTestFramework\n-from util import *\n-\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n \n class WalletTest (BitcoinTestFramework):\n \n     def setup_chain(self):\n         print(\"Initializing test directory \"+self.options.tmpdir)\n-        initialize_chain_clean(self.options.tmpdir, 3)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n \n     def setup_network(self, split=False):\n         self.nodes = start_nodes(3, self.options.tmpdir)\n@@ -39,14 +39,14 @@ def setup_network(self, split=False):\n     def run_test (self):\n         print \"Mining blocks...\"\n \n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n \n         walletinfo = self.nodes[0].getwalletinfo()\n         assert_equal(walletinfo['immature_balance'], 50)\n         assert_equal(walletinfo['balance'], 0)\n \n         self.sync_all()\n-        self.nodes[1].setgenerate(True, 101)\n+        self.nodes[1].generate(101)\n         self.sync_all()\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n@@ -61,12 +61,12 @@ def run_test (self):\n         walletinfo = self.nodes[0].getwalletinfo()\n         assert_equal(walletinfo['immature_balance'], 0)\n \n-        # Have node0 mine a block, thus he will collect his own fee. \n-        self.nodes[0].setgenerate(True, 1)\n+        # Have node0 mine a block, thus it will collect its own fee.\n+        self.nodes[0].generate(1)\n         self.sync_all()\n \n         # Have node1 generate 100 blocks (so node0 can recover the fee)\n-        self.nodes[1].setgenerate(True, 100)\n+        self.nodes[1].generate(100)\n         self.sync_all()\n \n         # node0 should end up with 100 btc in block rewards plus fees, but\n@@ -95,13 +95,128 @@ def run_test (self):\n         self.nodes[1].sendrawtransaction(txns_to_send[1][\"hex\"], True)\n \n         # Have node1 mine a block to confirm transactions:\n-        self.nodes[1].setgenerate(True, 1)\n+        self.nodes[1].generate(1)\n         self.sync_all()\n \n         assert_equal(self.nodes[0].getbalance(), 0)\n         assert_equal(self.nodes[2].getbalance(), 100)\n         assert_equal(self.nodes[2].getbalance(\"from1\"), 100-21)\n \n+        # Send 10 BTC normal\n+        address = self.nodes[0].getnewaddress(\"test\")\n+        self.nodes[2].settxfee(Decimal('0.001'))\n+        txid = self.nodes[2].sendtoaddress(address, 10, \"\", \"\", False)\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), Decimal('89.99900000'))\n+        assert_equal(self.nodes[0].getbalance(), Decimal('10.00000000'))\n+\n+        # Send 10 BTC with subtract fee from amount\n+        txid = self.nodes[2].sendtoaddress(address, 10, \"\", \"\", True)\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), Decimal('79.99900000'))\n+        assert_equal(self.nodes[0].getbalance(), Decimal('19.99900000'))\n+\n+        # Sendmany 10 BTC\n+        txid = self.nodes[2].sendmany('from1', {address: 10}, 0, \"\", [])\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), Decimal('69.99800000'))\n+        assert_equal(self.nodes[0].getbalance(), Decimal('29.99900000'))\n+\n+        # Sendmany 10 BTC with subtract fee from amount\n+        txid = self.nodes[2].sendmany('from1', {address: 10}, 0, \"\", [address])\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), Decimal('59.99800000'))\n+        assert_equal(self.nodes[0].getbalance(), Decimal('39.99800000'))\n+\n+        # Test ResendWalletTransactions:\n+        # Create a couple of transactions, then start up a fourth\n+        # node (nodes[3]) and ask nodes[0] to rebroadcast.\n+        # EXPECT: nodes[3] should have those transactions in its mempool.\n+        txid1 = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        txid2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        sync_mempools(self.nodes)\n+\n+        self.nodes.append(start_node(3, self.options.tmpdir))\n+        connect_nodes_bi(self.nodes, 0, 3)\n+        sync_blocks(self.nodes)\n+\n+        relayed = self.nodes[0].resendwallettransactions()\n+        assert_equal(set(relayed), set([txid1, txid2]))\n+        sync_mempools(self.nodes)\n+\n+        assert(txid1 in self.nodes[3].getrawmempool())\n+        \n+        #check if we can list zero value tx as available coins\n+        #1. create rawtx\n+        #2. hex-changed one output to 0.0 \n+        #3. sign and send\n+        #4. check if recipient (node0) can list the zero value tx\n+        usp = self.nodes[1].listunspent()\n+        inputs = [{\"txid\":usp[0]['txid'], \"vout\":usp[0]['vout']}]\n+        outputs = {self.nodes[1].getnewaddress(): 49.998, self.nodes[0].getnewaddress(): 11.11}\n+        \n+        rawTx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\") #replace 11.11 with 0.0 (int32)\n+        decRawTx = self.nodes[1].decoderawtransaction(rawTx)\n+        signedRawTx = self.nodes[1].signrawtransaction(rawTx)\n+        decRawTx = self.nodes[1].decoderawtransaction(signedRawTx['hex'])\n+        zeroValueTxid= decRawTx['txid']\n+        sendResp = self.nodes[1].sendrawtransaction(signedRawTx['hex'])\n+        \n+        self.sync_all()\n+        self.nodes[1].generate(1) #mine a block\n+        self.sync_all()\n+        \n+        unspentTxs = self.nodes[0].listunspent() #zero value tx must be in listunspents output\n+        found = False\n+        for uTx in unspentTxs:\n+            if uTx['txid'] == zeroValueTxid:\n+                found = True\n+                assert_equal(uTx['amount'], Decimal('0.00000000'));\n+        assert(found)\n+        \n+        #do some -walletbroadcast tests\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+        self.nodes = start_nodes(3, self.options.tmpdir, [[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"]])\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+        self.sync_all()\n \n+        txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2);\n+        txObjNotBroadcasted = self.nodes[0].gettransaction(txIdNotBroadcasted)\n+        self.nodes[1].generate(1) #mine a block, tx should not be in there\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), Decimal('59.99800000')); #should not be changed because tx was not broadcasted\n+        \n+        #now broadcast from another node, mine a block, sync, and check the balance\n+        self.nodes[1].sendrawtransaction(txObjNotBroadcasted['hex'])\n+        self.nodes[1].generate(1)\n+        self.sync_all()\n+        txObjNotBroadcasted = self.nodes[0].gettransaction(txIdNotBroadcasted)\n+        assert_equal(self.nodes[2].getbalance(), Decimal('61.99800000')); #should not be\n+        \n+        #create another tx\n+        txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2);\n+        \n+        #restart the nodes with -walletbroadcast=1\n+        stop_nodes(self.nodes)\n+        wait_bitcoinds()\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+        sync_blocks(self.nodes)\n+        \n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+        \n+        #tx should be added to balance because after restarting the nodes tx should be broadcastet\n+        assert_equal(self.nodes[2].getbalance(), Decimal('63.99800000')); #should not be\n+        \n if __name__ == '__main__':\n     WalletTest ().main ()"
      },
      {
        "sha": "da100d7fc0d04d84186c551c10e7e29b05f28fd0",
        "filename": "qa/rpc-tests/walletbackup.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/walletbackup.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -33,8 +33,8 @@\n and confirm again balances are correct.\n \"\"\"\n \n-from test_framework import BitcoinTestFramework\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n from random import randint\n import logging\n logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)\n@@ -77,7 +77,7 @@ def do_one_round(self):\n         # Have the miner (node3) mine a block.\n         # Must sync mempools before mining.\n         sync_mempools(self.nodes)\n-        self.nodes[3].setgenerate(True, 1)\n+        self.nodes[3].generate(1)\n \n     # As above, this mirrors the original bash test.\n     def start_three(self):\n@@ -101,13 +101,13 @@ def erase_three(self):\n \n     def run_test(self):\n         logging.info(\"Generating initial blockchain\")\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n-        self.nodes[1].setgenerate(True, 1)\n+        self.nodes[1].generate(1)\n         sync_blocks(self.nodes)\n-        self.nodes[2].setgenerate(True, 1)\n+        self.nodes[2].generate(1)\n         sync_blocks(self.nodes)\n-        self.nodes[3].setgenerate(True, 100)\n+        self.nodes[3].generate(100)\n         sync_blocks(self.nodes)\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n@@ -134,7 +134,7 @@ def run_test(self):\n             self.do_one_round()\n \n         # Generate 101 more blocks, so any fees paid mature\n-        self.nodes[3].setgenerate(True, 101)\n+        self.nodes[3].generate(101)\n         self.sync_all()\n \n         balance0 = self.nodes[0].getbalance()"
      },
      {
        "sha": "0ec8ec53648c0f8d51a62dc1dddc57df20919945",
        "filename": "qa/rpc-tests/zapwallettxes.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/qa/rpc-tests/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/zapwallettxes.py?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -3,8 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-from test_framework import BitcoinTestFramework\n-from util import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n \n \n class ZapWalletTXesTest (BitcoinTestFramework):\n@@ -23,17 +23,17 @@ def setup_network(self, split=False):\n \n     def run_test (self):\n         print \"Mining blocks...\"\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         self.sync_all()\n-        self.nodes[1].setgenerate(True, 101)\n+        self.nodes[1].generate(101)\n         self.sync_all()\n         \n         assert_equal(self.nodes[0].getbalance(), 50)\n         \n         txid0 = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 11)\n         txid1 = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 10)\n         self.sync_all()\n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         self.sync_all()\n         \n         txid2 = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 11)"
      },
      {
        "sha": "cbd060c268e4b9aa5ff96c932fcea5ab273f264d",
        "filename": "share/certs/PrivateKeyNotes.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/share/certs/PrivateKeyNotes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/share/certs/PrivateKeyNotes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/certs/PrivateKeyNotes.md?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,7 +7,7 @@ signing requests.\n \n For OSX, the private key was generated by Keychain.app on Gavin's main work machine.\n The key and certificate is in a separate, passphrase-protected keychain file that is\n-unlocked to sign the Bitcoin-Qt.app bundle.\n+unlocked to sign the Bitcoin-Core.app bundle.\n \n For Windows, the private key was generated by Firefox running on Gavin's main work machine.\n The key and certificate were exported into a separate, passphrase-protected PKCS#12 file, and\n@@ -17,7 +17,7 @@ Threat analysis\n --\n \n Gavin is a single point of failure. He could be coerced to divulge the secret signing keys,\n-allowing somebody to distribute a Bitcoin-Qt.app or bitcoin-qt-setup.exe with a valid\n+allowing somebody to distribute a Bitcoin-Core.app or bitcoin-qt-setup.exe with a valid\n signature but containing a malicious binary.\n \n Or the machine Gavin uses to sign the binaries could be compromised, either remotely or"
      },
      {
        "sha": "a15cb34e47ae64e213e5b921e008cdca64edb8a6",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -22,7 +22,7 @@ if [ -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/\n \n     # if latest commit is tagged and not dirty, then override using the tag name\n     RAWDESC=$(git describe --abbrev=0 2>/dev/null)\n-    if [ \"$(git rev-parse HEAD)\" = \"$(git rev-list -1 $RAWDESC)\" ]; then\n+    if [ \"$(git rev-parse HEAD)\" = \"$(git rev-list -1 $RAWDESC 2>/dev/null)\" ]; then\n         git diff-index --quiet HEAD -- && DESC=$RAWDESC\n     fi\n "
      },
      {
        "sha": "1c2f770418b7cc746441727d6eb5330f890f8e42",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 82,
        "deletions": 67,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -14,7 +14,7 @@ $(LIBLEVELDB): $(LIBMEMENV)\n $(LIBLEVELDB) $(LIBMEMENV):\n \t@echo \"Building LevelDB ...\" && $(MAKE) -C $(@D) $(@F) CXX=\"$(CXX)\" \\\n \t  CC=\"$(CC)\" PLATFORM=$(TARGET_OS) AR=\"$(AR)\" $(LEVELDB_TARGET_FLAGS) \\\n-          OPT=\"$(CXXFLAGS) $(CPPFLAGS)\"\n+          OPT=\"$(CXXFLAGS) $(CPPFLAGS) -D__STDC_LIMIT_MACROS\"\n endif\n \n BITCOIN_CONFIG_INCLUDES=-I$(builddir)/config\n@@ -72,25 +72,28 @@ endif\n BITCOIN_CORE_H = \\\n   addrman.h \\\n   alert.h \\\n-  allocators.h \\\n   amount.h \\\n   arith_uint256.h \\\n   base58.h \\\n   bloom.h \\\n   chain.h \\\n-  chainparamsbase.h \\\n   chainparams.h \\\n+  chainparamsbase.h \\\n   chainparamsseeds.h \\\n   checkpoints.h \\\n   checkqueue.h \\\n   clientversion.h \\\n   coincontrol.h \\\n   coins.h \\\n   compat.h \\\n+  compat/byteswap.h \\\n+  compat/endian.h \\\n+  compat/sanity.h \\\n   compressor.h \\\n+  consensus/consensus.h \\\n+  consensus/params.h \\\n+  consensus/validation.h \\\n   core_io.h \\\n-  crypter.h \\\n-  db.h \\\n   eccryptoverify.h \\\n   ecwrapper.h \\\n   hash.h \\\n@@ -100,12 +103,14 @@ BITCOIN_CORE_H = \\\n   leveldbwrapper.h \\\n   limitedmap.h \\\n   main.h \\\n+  memusage.h \\\n   merkleblock.h \\\n   miner.h \\\n   mruset.h \\\n-  netbase.h \\\n   net.h \\\n+  netbase.h \\\n   noui.h \\\n+  policy/fees.h \\\n   pow.h \\\n   primitives/block.h \\\n   primitives/transaction.h \\\n@@ -115,14 +120,19 @@ BITCOIN_CORE_H = \\\n   rpcclient.h \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n+  scheduler.h \\\n   script/interpreter.h \\\n-  script/script_error.h \\\n   script/script.h \\\n+  script/script_error.h \\\n   script/sigcache.h \\\n   script/sign.h \\\n   script/standard.h \\\n   serialize.h \\\n   streams.h \\\n+  support/allocators/secure.h \\\n+  support/allocators/zeroafterfree.h \\\n+  support/cleanse.h \\\n+  support/pagelocker.h \\\n   sync.h \\\n   threadsafety.h \\\n   timedata.h \\\n@@ -136,11 +146,13 @@ BITCOIN_CORE_H = \\\n   utilmoneystr.h \\\n   utilstrencodings.h \\\n   utiltime.h \\\n+  validationinterface.h \\\n   version.h \\\n-  walletdb.h \\\n-  wallet.h \\\n-  wallet_ismine.h \\\n-  compat/sanity.h\n+  wallet/crypter.h \\\n+  wallet/db.h \\\n+  wallet/wallet.h \\\n+  wallet/wallet_ismine.h \\\n+  wallet/walletdb.h\n \n JSON_H = \\\n   json/json_spirit.h \\\n@@ -174,6 +186,7 @@ libbitcoin_server_a_SOURCES = \\\n   miner.cpp \\\n   net.cpp \\\n   noui.cpp \\\n+  policy/fees.cpp \\\n   pow.cpp \\\n   rest.cpp \\\n   rpcblockchain.cpp \\\n@@ -186,61 +199,57 @@ libbitcoin_server_a_SOURCES = \\\n   timedata.cpp \\\n   txdb.cpp \\\n   txmempool.cpp \\\n+  validationinterface.cpp \\\n   $(JSON_H) \\\n   $(BITCOIN_CORE_H)\n \n # wallet: shared between bitcoind and bitcoin-qt, but only linked\n # when wallet enabled\n libbitcoin_wallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_SOURCES = \\\n-  db.cpp \\\n-  crypter.cpp \\\n-  rpcdump.cpp \\\n-  rpcwallet.cpp \\\n-  wallet.cpp \\\n-  wallet_ismine.cpp \\\n-  walletdb.cpp \\\n+  wallet/crypter.cpp \\\n+  wallet/db.cpp \\\n+  wallet/rpcdump.cpp \\\n+  wallet/rpcwallet.cpp \\\n+  wallet/wallet.cpp \\\n+  wallet/wallet_ismine.cpp \\\n+  wallet/walletdb.cpp \\\n   $(BITCOIN_CORE_H)\n \n # crypto primitives library\n crypto_libbitcoin_crypto_a_CPPFLAGS = $(BITCOIN_CONFIG_INCLUDES)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n-  crypto/sha1.cpp \\\n-  crypto/sha256.cpp \\\n-  crypto/sha512.cpp \\\n-  crypto/hmac_sha256.cpp \\\n-  crypto/rfc6979_hmac_sha256.cpp \\\n-  crypto/hmac_sha512.cpp \\\n-  crypto/ripemd160.cpp \\\n   crypto/common.h \\\n-  crypto/sha256.h \\\n-  crypto/sha512.h \\\n+  crypto/hmac_sha256.cpp \\\n   crypto/hmac_sha256.h \\\n-  crypto/rfc6979_hmac_sha256.h \\\n+  crypto/hmac_sha512.cpp \\\n   crypto/hmac_sha512.h \\\n+  crypto/ripemd160.cpp \\\n+  crypto/ripemd160.h \\\n+  crypto/sha1.cpp \\\n   crypto/sha1.h \\\n-  crypto/ripemd160.h\n+  crypto/sha256.cpp \\\n+  crypto/sha256.h \\\n+  crypto/sha512.cpp \\\n+  crypto/sha512.h\n \n # univalue JSON library\n univalue_libbitcoin_univalue_a_SOURCES = \\\n   univalue/univalue.cpp \\\n-  univalue/univalue_read.cpp \\\n-  univalue/univalue_write.cpp \\\n+  univalue/univalue.h \\\n   univalue/univalue_escapes.h \\\n-  univalue/univalue.h\n+  univalue/univalue_read.cpp \\\n+  univalue/univalue_write.cpp\n \n # common: shared between bitcoind, and bitcoin-qt and non-server tools\n libbitcoin_common_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_common_a_SOURCES = \\\n-  allocators.cpp \\\n-  arith_uint256.cpp \\\n   amount.cpp \\\n+  arith_uint256.cpp \\\n   base58.cpp \\\n   chainparams.cpp \\\n   coins.cpp \\\n   compressor.cpp \\\n-  primitives/block.cpp \\\n-  primitives/transaction.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\\n   eccryptoverify.cpp \\\n@@ -249,27 +258,32 @@ libbitcoin_common_a_SOURCES = \\\n   key.cpp \\\n   keystore.cpp \\\n   netbase.cpp \\\n+  primitives/block.cpp \\\n+  primitives/transaction.cpp \\\n   protocol.cpp \\\n   pubkey.cpp \\\n+  scheduler.cpp \\\n   script/interpreter.cpp \\\n   script/script.cpp \\\n+  script/script_error.cpp \\\n   script/sign.cpp \\\n   script/standard.cpp \\\n-  script/script_error.cpp \\\n   $(BITCOIN_CORE_H)\n \n # util: shared between all executables.\n # This library *must* be included to make sure that the glibc\n # backward-compatibility objects and their sanity checks are linked.\n libbitcoin_util_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_util_a_SOURCES = \\\n+  support/pagelocker.cpp \\\n   chainparamsbase.cpp \\\n   clientversion.cpp \\\n   compat/glibc_sanity.cpp \\\n   compat/glibcxx_sanity.cpp \\\n   compat/strnlen.cpp \\\n   random.cpp \\\n   rpcprotocol.cpp \\\n+  support/cleanse.cpp \\\n   sync.cpp \\\n   uint256.cpp \\\n   util.cpp \\\n@@ -280,7 +294,6 @@ libbitcoin_util_a_SOURCES = \\\n \n if GLIBC_BACK_COMPAT\n libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n-libbitcoin_util_a_SOURCES += compat/glibcxx_compat.cpp\n endif\n \n # cli: shared between bitcoin-cli and bitcoin-qt\n@@ -293,6 +306,14 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n #\n \n # bitcoind binary #\n+bitcoind_SOURCES = bitcoind.cpp\n+bitcoind_CPPFLAGS = $(BITCOIN_INCLUDES)\n+bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+\n+if TARGET_WINDOWS\n+bitcoind_SOURCES += bitcoind-res.rc\n+endif\n+\n bitcoind_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n@@ -306,51 +327,47 @@ bitcoind_LDADD = \\\n if ENABLE_WALLET\n bitcoind_LDADD += libbitcoin_wallet.a\n endif\n-bitcoind_SOURCES = bitcoind.cpp\n+\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n #\n \n+# bitcoin-cli binary #\n+bitcoin_cli_SOURCES = bitcoin-cli.cpp\n+bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES)\n+bitcoin_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+\n if TARGET_WINDOWS\n-bitcoind_SOURCES += bitcoind-res.rc\n+bitcoin_cli_SOURCES += bitcoin-cli-res.rc\n endif\n \n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n-bitcoind_CPPFLAGS = $(BITCOIN_INCLUDES)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-\n-# bitcoin-cli binary #\n bitcoin_cli_LDADD = \\\n   $(LIBBITCOIN_CLI) \\\n   $(LIBBITCOIN_UTIL) \\\n-  $(BOOST_LIBS) \\\n-  $(SSL_LIBS) \\\n-  $(CRYPTO_LIBS)\n-\n-bitcoin_cli_SOURCES = \\\n-  bitcoin-cli.cpp\n+  $(LIBSECP256K1)\n \n-bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES)\n+bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS)\n #\n \n # bitcoin-tx binary #\n+bitcoin_tx_SOURCES = bitcoin-tx.cpp\n+bitcoin_tx_CPPFLAGS = $(BITCOIN_INCLUDES)\n+bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+\n+if TARGET_WINDOWS\n+bitcoin_tx_SOURCES += bitcoin-tx-res.rc\n+endif\n+\n bitcoin_tx_LDADD = \\\n   $(LIBBITCOIN_UNIVALUE) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO) \\\n-  $(LIBSECP256K1) \\\n-  $(BOOST_LIBS) \\\n-  $(CRYPTO_LIBS)\n+  $(LIBSECP256K1)\n \n-bitcoin_tx_SOURCES = bitcoin-tx.cpp\n-bitcoin_tx_CPPFLAGS = $(BITCOIN_INCLUDES)\n+bitcoin_tx_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n #\n-bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-\n-if TARGET_WINDOWS\n-bitcoin_cli_SOURCES += bitcoin-cli-res.rc\n-endif\n-bitcoin_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n+# bitcoinconsensus library #\n if BUILD_BITCOIN_LIBS\n include_HEADERS = script/bitcoinconsensus.h\n libbitcoinconsensus_la_SOURCES = \\\n@@ -372,16 +389,14 @@ libbitcoinconsensus_la_SOURCES = \\\n \n if GLIBC_BACK_COMPAT\n   libbitcoinconsensus_la_SOURCES += compat/glibc_compat.cpp\n-  libbitcoinconsensus_la_SOURCES += compat/glibcxx_compat.cpp\n endif\n \n libbitcoinconsensus_la_LDFLAGS = -no-undefined $(RELDFLAGS)\n libbitcoinconsensus_la_LIBADD = $(CRYPTO_LIBS)\n libbitcoinconsensus_la_CPPFLAGS = $(CRYPTO_CFLAGS) -I$(builddir)/obj -DBUILD_BITCOIN_INTERNAL\n-if USE_LIBSECP256K1\n-libbitcoinconsensus_la_LIBADD += secp256k1/libsecp256k1.la\n-endif\n+\n endif\n+#\n \n CLEANFILES = leveldb/libleveldb.a leveldb/libmemenv.a *.gcda *.gcno\n "
      },
      {
        "sha": "6b7c42285d6e210b8a8853afd2dd1e48a67bf915",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -256,6 +256,7 @@ RES_ICONS = \\\n   qt/res/icons/tx_input.png \\\n   qt/res/icons/tx_output.png \\\n   qt/res/icons/tx_mined.png \\\n+  qt/res/icons/warning.png \\\n   qt/res/icons/verify.png\n \n BITCOIN_QT_CPP = \\"
      },
      {
        "sha": "099714811716d965687a88f85304bc5ca3f0bb11",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -20,8 +20,6 @@ EXTRA_DIST += \\\n JSON_TEST_FILES = \\\n   test/data/script_valid.json \\\n   test/data/base58_keys_valid.json \\\n-  test/data/sig_canonical.json \\\n-  test/data/sig_noncanonical.json \\\n   test/data/base58_encode_decode.json \\\n   test/data/base58_keys_invalid.json \\\n   test/data/script_invalid.json \\\n@@ -41,6 +39,7 @@ BITCOIN_TESTS =\\\n   test/base32_tests.cpp \\\n   test/base58_tests.cpp \\\n   test/base64_tests.cpp \\\n+  test/bip32_tests.cpp \\\n   test/bloom_tests.cpp \\\n   test/checkblock_tests.cpp \\\n   test/Checkpoints_tests.cpp \\\n@@ -52,13 +51,17 @@ BITCOIN_TESTS =\\\n   test/hash_tests.cpp \\\n   test/key_tests.cpp \\\n   test/main_tests.cpp \\\n+  test/mempool_tests.cpp \\\n   test/miner_tests.cpp \\\n   test/mruset_tests.cpp \\\n   test/multisig_tests.cpp \\\n   test/netbase_tests.cpp \\\n   test/pmt_tests.cpp \\\n+  test/policyestimator_tests.cpp \\\n+  test/pow_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n+  test/scheduler_tests.cpp \\\n   test/script_P2SH_tests.cpp \\\n   test/script_tests.cpp \\\n   test/scriptnum_tests.cpp \\\n@@ -67,6 +70,7 @@ BITCOIN_TESTS =\\\n   test/sigopcount_tests.cpp \\\n   test/skiplist_tests.cpp \\\n   test/test_bitcoin.cpp \\\n+  test/test_bitcoin.h \\\n   test/timedata_tests.cpp \\\n   test/transaction_tests.cpp \\\n   test/uint256_tests.cpp \\\n@@ -76,7 +80,7 @@ BITCOIN_TESTS =\\\n if ENABLE_WALLET\n BITCOIN_TESTS += \\\n   test/accounting_tests.cpp \\\n-  test/wallet_tests.cpp \\\n+  wallet/test/wallet_tests.cpp \\\n   test/rpc_wallet_tests.cpp\n endif\n "
      },
      {
        "sha": "c41ee3f9fce566cc77a80629ba4e8f386161e691",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 133,
        "deletions": 172,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -10,34 +10,27 @@\n \n using namespace std;\n \n-int CAddrInfo::GetTriedBucket(const std::vector<unsigned char>& nKey) const\n+int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n {\n-    CDataStream ss1(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchKey = GetKey();\n-    ss1 << nKey << vchKey;\n-    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n-\n-    CDataStream ss2(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchGroupKey = GetGroup();\n-    ss2 << nKey << vchGroupKey << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP);\n-    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetHash().GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetHash().GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n }\n \n-int CAddrInfo::GetNewBucket(const std::vector<unsigned char>& nKey, const CNetAddr& src) const\n+int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n {\n-    CDataStream ss1(SER_GETHASH, 0);\n-    std::vector<unsigned char> vchGroupKey = GetGroup();\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n-    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n-    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).GetCheapHash();\n-\n-    CDataStream ss2(SER_GETHASH, 0);\n-    ss2 << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n-    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).GetCheapHash();\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << vchSourceGroupKey).GetHash().GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetHash().GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n }\n \n+int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+{\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? 'N' : 'K') << nBucket << GetKey()).GetHash().GetCheapHash();\n+    return hash1 % ADDRMAN_BUCKET_SIZE;\n+}\n+\n bool CAddrInfo::IsTerrible(int64_t nNow) const\n {\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n@@ -70,15 +63,12 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     if (nSinceLastTry < 0)\n         nSinceLastTry = 0;\n \n-    fChance *= 600.0 / (600.0 + nSinceLastSeen);\n-\n     // deprioritize very recent attempts away\n     if (nSinceLastTry < 60 * 10)\n         fChance *= 0.01;\n \n-    // deprioritize 50% after each failed attempt\n-    for (int n = 0; n < nAttempts; n++)\n-        fChance /= 1.5;\n+    // deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.\n+    fChance *= pow(0.66, min(nAttempts, 8));\n \n     return fChance;\n }\n@@ -128,130 +118,81 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n     vRandom[nRndPos2] = nId1;\n }\n \n-int CAddrMan::SelectTried(int nKBucket)\n+void CAddrMan::Delete(int nId)\n {\n-    std::vector<int>& vTried = vvTried[nKBucket];\n-\n-    // randomly shuffle the first few elements (using the entire list)\n-    // find the least recently tried among them\n-    int64_t nOldest = -1;\n-    int nOldestPos = -1;\n-    for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++) {\n-        int nPos = GetRandInt(vTried.size() - i) + i;\n-        int nTemp = vTried[nPos];\n-        vTried[nPos] = vTried[i];\n-        vTried[i] = nTemp;\n-        assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n-        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n-            nOldest = nTemp;\n-            nOldestPos = nPos;\n-        }\n-    }\n+    assert(mapInfo.count(nId) != 0);\n+    CAddrInfo& info = mapInfo[nId];\n+    assert(!info.fInTried);\n+    assert(info.nRefCount == 0);\n \n-    return nOldestPos;\n+    SwapRandom(info.nRandomPos, vRandom.size() - 1);\n+    vRandom.pop_back();\n+    mapAddr.erase(info);\n+    mapInfo.erase(nId);\n+    nNew--;\n }\n \n-int CAddrMan::ShrinkNew(int nUBucket)\n+void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n {\n-    assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n-    std::set<int>& vNew = vvNew[nUBucket];\n-\n-    // first look for deletable items\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n-        assert(mapInfo.count(*it));\n-        CAddrInfo& info = mapInfo[*it];\n-        if (info.IsTerrible()) {\n-            if (--info.nRefCount == 0) {\n-                SwapRandom(info.nRandomPos, vRandom.size() - 1);\n-                vRandom.pop_back();\n-                mapAddr.erase(info);\n-                mapInfo.erase(*it);\n-                nNew--;\n-            }\n-            vNew.erase(it);\n-            return 0;\n-        }\n-    }\n-\n-    // otherwise, select four randomly, and pick the oldest of those to replace\n-    int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n-    int nI = 0;\n-    int nOldest = -1;\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n-        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3]) {\n-            assert(nOldest == -1 || mapInfo.count(*it) == 1);\n-            if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n-                nOldest = *it;\n+    // if there is an entry in the specified bucket, delete it.\n+    if (vvNew[nUBucket][nUBucketPos] != -1) {\n+        int nIdDelete = vvNew[nUBucket][nUBucketPos];\n+        CAddrInfo& infoDelete = mapInfo[nIdDelete];\n+        assert(infoDelete.nRefCount > 0);\n+        infoDelete.nRefCount--;\n+        vvNew[nUBucket][nUBucketPos] = -1;\n+        if (infoDelete.nRefCount == 0) {\n+            Delete(nIdDelete);\n         }\n-        nI++;\n-    }\n-    assert(mapInfo.count(nOldest) == 1);\n-    CAddrInfo& info = mapInfo[nOldest];\n-    if (--info.nRefCount == 0) {\n-        SwapRandom(info.nRandomPos, vRandom.size() - 1);\n-        vRandom.pop_back();\n-        mapAddr.erase(info);\n-        mapInfo.erase(nOldest);\n-        nNew--;\n     }\n-    vNew.erase(nOldest);\n-\n-    return 1;\n }\n \n-void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n+void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n {\n-    assert(vvNew[nOrigin].count(nId) == 1);\n-\n     // remove the entry from all new buckets\n-    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n-        if ((*it).erase(nId))\n+    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+        int pos = info.GetBucketPosition(nKey, true, bucket);\n+        if (vvNew[bucket][pos] == nId) {\n+            vvNew[bucket][pos] = -1;\n             info.nRefCount--;\n+        }\n     }\n     nNew--;\n \n     assert(info.nRefCount == 0);\n \n     // which tried bucket to move the entry to\n     int nKBucket = info.GetTriedBucket(nKey);\n-    std::vector<int>& vTried = vvTried[nKBucket];\n-\n-    // first check whether there is place to just add it\n-    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n-        vTried.push_back(nId);\n-        nTried++;\n-        info.fInTried = true;\n-        return;\n-    }\n-\n-    // otherwise, find an item to evict\n-    int nPos = SelectTried(nKBucket);\n-\n-    // find which new bucket it belongs to\n-    assert(mapInfo.count(vTried[nPos]) == 1);\n-    int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n-    std::set<int>& vNew = vvNew[nUBucket];\n-\n-    // remove the to-be-replaced tried entry from the tried set\n-    CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n-    infoOld.fInTried = false;\n-    infoOld.nRefCount = 1;\n-    // do not update nTried, as we are going to move something else there immediately\n-\n-    // check whether there is place in that one,\n-    if (vNew.size() < ADDRMAN_NEW_BUCKET_SIZE) {\n-        // if so, move it back there\n-        vNew.insert(vTried[nPos]);\n-    } else {\n-        // otherwise, move it to the new bucket nId came from (there is certainly place there)\n-        vvNew[nOrigin].insert(vTried[nPos]);\n+    int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n+\n+    // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n+    if (vvTried[nKBucket][nKBucketPos] != -1) {\n+        // find an item to evict\n+        int nIdEvict = vvTried[nKBucket][nKBucketPos];\n+        assert(mapInfo.count(nIdEvict) == 1);\n+        CAddrInfo& infoOld = mapInfo[nIdEvict];\n+\n+        // Remove the to-be-evicted item from the tried set.\n+        infoOld.fInTried = false;\n+        vvTried[nKBucket][nKBucketPos] = -1;\n+        nTried--;\n+\n+        // find which new bucket it belongs to\n+        int nUBucket = infoOld.GetNewBucket(nKey);\n+        int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);\n+        ClearNew(nUBucket, nUBucketPos);\n+        assert(vvNew[nUBucket][nUBucketPos] == -1);\n+\n+        // Enter it into the new set again.\n+        infoOld.nRefCount = 1;\n+        vvNew[nUBucket][nUBucketPos] = nIdEvict;\n+        nNew++;\n     }\n-    nNew++;\n+    assert(vvTried[nKBucket][nKBucketPos] == -1);\n \n-    vTried[nPos] = nId;\n-    // we just overwrote an entry in vTried; no need to update nTried\n+    vvTried[nKBucket][nKBucketPos] = nId;\n+    nTried++;\n     info.fInTried = true;\n-    return;\n }\n \n void CAddrMan::Good_(const CService& addr, int64_t nTime)\n@@ -272,20 +213,21 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     // update info\n     info.nLastSuccess = nTime;\n     info.nLastTry = nTime;\n-    info.nTime = nTime;\n     info.nAttempts = 0;\n+    // nTime is not updated here, to avoid leaking information about\n+    // currently-connected peers.\n \n     // if it is already in the tried set, don't do anything else\n     if (info.fInTried)\n         return;\n \n     // find a bucket it is in now\n-    int nRnd = GetRandInt(vvNew.size());\n+    int nRnd = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n-    for (unsigned int n = 0; n < vvNew.size(); n++) {\n-        int nB = (n + nRnd) % vvNew.size();\n-        std::set<int>& vNew = vvNew[nB];\n-        if (vNew.count(nId)) {\n+    for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        int nB = (n + nRnd) % ADDRMAN_NEW_BUCKET_COUNT;\n+        int nBpos = info.GetBucketPosition(nKey, true, nB);\n+        if (vvNew[nB][nBpos] == nId) {\n             nUBucket = nB;\n             break;\n         }\n@@ -299,7 +241,7 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n \n     // move nId to the tried tables\n-    MakeTried(info, nId, nUBucket);\n+    MakeTried(info, nId);\n }\n \n bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n@@ -347,12 +289,25 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     }\n \n     int nUBucket = pinfo->GetNewBucket(nKey, source);\n-    std::set<int>& vNew = vvNew[nUBucket];\n-    if (!vNew.count(nId)) {\n-        pinfo->nRefCount++;\n-        if (vNew.size() == ADDRMAN_NEW_BUCKET_SIZE)\n-            ShrinkNew(nUBucket);\n-        vvNew[nUBucket].insert(nId);\n+    int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);\n+    if (vvNew[nUBucket][nUBucketPos] != nId) {\n+        bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n+        if (!fInsert) {\n+            CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n+            if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n+                // Overwrite the existing new table entry.\n+                fInsert = true;\n+            }\n+        }\n+        if (fInsert) {\n+            ClearNew(nUBucket, nUBucketPos);\n+            pinfo->nRefCount++;\n+            vvNew[nUBucket][nUBucketPos] = nId;\n+        } else {\n+            if (pinfo->nRefCount == 0) {\n+                Delete(nId);\n+            }\n+        }\n     }\n     return fNew;\n }\n@@ -376,24 +331,23 @@ void CAddrMan::Attempt_(const CService& addr, int64_t nTime)\n     info.nAttempts++;\n }\n \n-CAddress CAddrMan::Select_(int nUnkBias)\n+CAddrInfo CAddrMan::Select_()\n {\n     if (size() == 0)\n-        return CAddress();\n+        return CAddrInfo();\n \n-    double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n-    double nCorNew = sqrt(nNew) * nUnkBias;\n-    if ((nCorTried + nCorNew) * GetRandInt(1 << 30) / (1 << 30) < nCorTried) {\n+    // Use a 50% chance for choosing between tried and new table entries.\n+    if (nTried > 0 && (nNew == 0 || GetRandInt(2) == 0)) {\n         // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nKBucket = GetRandInt(vvTried.size());\n-            std::vector<int>& vTried = vvTried[nKBucket];\n-            if (vTried.size() == 0)\n+            int nKBucket = GetRandInt(ADDRMAN_TRIED_BUCKET_COUNT);\n+            int nKBucketPos = GetRandInt(ADDRMAN_BUCKET_SIZE);\n+            if (vvTried[nKBucket][nKBucketPos] == -1)\n                 continue;\n-            int nPos = GetRandInt(vTried.size());\n-            assert(mapInfo.count(vTried[nPos]) == 1);\n-            CAddrInfo& info = mapInfo[vTried[nPos]];\n+            int nId = vvTried[nKBucket][nKBucketPos];\n+            assert(mapInfo.count(nId) == 1);\n+            CAddrInfo& info = mapInfo[nId];\n             if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n@@ -402,16 +356,13 @@ CAddress CAddrMan::Select_(int nUnkBias)\n         // use a new node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nUBucket = GetRandInt(vvNew.size());\n-            std::set<int>& vNew = vvNew[nUBucket];\n-            if (vNew.size() == 0)\n+            int nUBucket = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n+            int nUBucketPos = GetRandInt(ADDRMAN_BUCKET_SIZE);\n+            if (vvNew[nUBucket][nUBucketPos] == -1)\n                 continue;\n-            int nPos = GetRandInt(vNew.size());\n-            std::set<int>::iterator it = vNew.begin();\n-            while (nPos--)\n-                it++;\n-            assert(mapInfo.count(*it) == 1);\n-            CAddrInfo& info = mapInfo[*it];\n+            int nId = vvNew[nUBucket][nUBucketPos];\n+            assert(mapInfo.count(nId) == 1);\n+            CAddrInfo& info = mapInfo[nId];\n             if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n@@ -459,29 +410,39 @@ int CAddrMan::Check_()\n     if (mapNew.size() != nNew)\n         return -10;\n \n-    for (int n = 0; n < vvTried.size(); n++) {\n-        std::vector<int>& vTried = vvTried[n];\n-        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++) {\n-            if (!setTried.count(*it))\n-                return -11;\n-            setTried.erase(*it);\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+             if (vvTried[n][i] != -1) {\n+                 if (!setTried.count(vvTried[n][i]))\n+                     return -11;\n+                 if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey) != n)\n+                     return -17;\n+                 if (mapInfo[vvTried[n][i]].GetBucketPosition(nKey, false, n) != i)\n+                     return -18;\n+                 setTried.erase(vvTried[n][i]);\n+             }\n         }\n     }\n \n-    for (int n = 0; n < vvNew.size(); n++) {\n-        std::set<int>& vNew = vvNew[n];\n-        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++) {\n-            if (!mapNew.count(*it))\n-                return -12;\n-            if (--mapNew[*it] == 0)\n-                mapNew.erase(*it);\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[n][i] != -1) {\n+                if (!mapNew.count(vvNew[n][i]))\n+                    return -12;\n+                if (mapInfo[vvNew[n][i]].GetBucketPosition(nKey, true, n) != i)\n+                    return -19;\n+                if (--mapNew[vvNew[n][i]] == 0)\n+                    mapNew.erase(vvNew[n][i]);\n+            }\n         }\n     }\n \n     if (setTried.size())\n         return -13;\n     if (mapNew.size())\n         return -15;\n+    if (nKey.IsNull())\n+        return -16;\n \n     return 0;\n }"
      },
      {
        "sha": "373b0f39f3749ea386ea666d7172509df5eba994",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 140,
        "deletions": 85,
        "changes": 225,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -17,21 +17,22 @@\n #include <stdint.h>\n #include <vector>\n \n-/** \n- * Extended statistics about a CAddress \n+/**\n+ * Extended statistics about a CAddress\n  */\n class CAddrInfo : public CAddress\n {\n+public:\n+    //! last try whatsoever by us (memory only)\n+    int64_t nLastTry;\n+\n private:\n     //! where knowledge about this address first came from\n     CNetAddr source;\n \n     //! last successful connection by us\n     int64_t nLastSuccess;\n \n-    //! last try whatsoever by us:\n-    // int64_t CAddress::nLastTry\n-\n     //! connection attempts since last successful attempt\n     int nAttempts;\n \n@@ -79,17 +80,20 @@ class CAddrInfo : public CAddress\n     }\n \n     //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const std::vector<unsigned char> &nKey) const;\n+    int GetTriedBucket(const uint256 &nKey) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const;\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const std::vector<unsigned char> &nKey) const\n+    int GetNewBucket(const uint256 &nKey) const\n     {\n         return GetNewBucket(nKey, source);\n     }\n \n+    //! Calculate in which position of a bucket to store this entry.\n+    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n+\n     //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n     bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n \n@@ -101,20 +105,20 @@ class CAddrInfo : public CAddress\n /** Stochastic address manager\n  *\n  * Design goals:\n- *  * Keep the address tables in-memory, and asynchronously dump the entire to able in peers.dat.\n+ *  * Keep the address tables in-memory, and asynchronously dump the entire table to peers.dat.\n  *  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.\n  *\n  * To that end:\n  *  * Addresses are organized into buckets.\n- *    * Address that have not yet been tried go into 256 \"new\" buckets.\n- *      * Based on the address range (/16 for IPv4) of source of the information, 32 buckets are selected at random\n- *      * The actual bucket is chosen from one of these, based on the range the address itself is located.\n- *      * One single address can occur in up to 4 different buckets, to increase selection chances for addresses that\n+ *    * Addresses that have not yet been tried go into 1024 \"new\" buckets.\n+ *      * Based on the address range (/16 for IPv4) of the source of information, 64 buckets are selected at random.\n+ *      * The actual bucket is chosen from one of these, based on the range in which the address itself is located.\n+ *      * One single address can occur in up to 8 different buckets to increase selection chances for addresses that\n  *        are seen frequently. The chance for increasing this multiplicity decreases exponentially.\n  *      * When adding a new address to a full bucket, a randomly chosen entry (with a bias favoring less recently seen\n  *        ones) is removed from it first.\n- *    * Addresses of nodes that are known to be accessible go into 64 \"tried\" buckets.\n- *      * Each address range selects at random 4 of these buckets.\n+ *    * Addresses of nodes that are known to be accessible go into 256 \"tried\" buckets.\n+ *      * Each address range selects at random 8 of these buckets.\n  *      * The actual bucket is chosen from one of these, based on the full address.\n  *      * When adding a new good address to a full bucket, a randomly chosen entry (with a bias favoring less recently\n  *        tried ones) is evicted from it, back to the \"new\" buckets.\n@@ -125,28 +129,22 @@ class CAddrInfo : public CAddress\n  */\n \n //! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT 64\n-\n-//! maximum allowed number of entries in buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_SIZE 64\n+#define ADDRMAN_TRIED_BUCKET_COUNT 256\n \n //! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT 256\n+#define ADDRMAN_NEW_BUCKET_COUNT 1024\n \n-//! maximum allowed number of entries in buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_SIZE 64\n+//! maximum allowed number of entries in buckets for new and tried addresses\n+#define ADDRMAN_BUCKET_SIZE 64\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n-#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 4\n+#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n \n //! over how many buckets entries with new addresses originating from a single group are spread\n-#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 32\n+#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 64\n \n //! in how many buckets for entries with new addresses a single address may occur\n-#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 4\n-\n-//! how many entries in a bucket with tried addresses are inspected, when selecting one to replace\n-#define ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT 4\n+#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 8\n \n //! how old addresses can maximally be\n #define ADDRMAN_HORIZON_DAYS 30\n@@ -176,7 +174,7 @@ class CAddrMan\n     mutable CCriticalSection cs;\n \n     //! secret key to randomize bucket select with\n-    std::vector<unsigned char> nKey;\n+    uint256 nKey;\n \n     //! last used nId\n     int nIdCount;\n@@ -194,13 +192,13 @@ class CAddrMan\n     int nTried;\n \n     //! list of \"tried\" buckets\n-    std::vector<std::vector<int> > vvTried;\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE];\n \n     //! number of (unique) \"new\" entries\n     int nNew;\n \n     //! list of \"new\" buckets\n-    std::vector<std::set<int> > vvNew;\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE];\n \n protected:\n \n@@ -214,17 +212,14 @@ class CAddrMan\n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2);\n \n-    //! Return position in given bucket to replace.\n-    int SelectTried(int nKBucket);\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId);\n \n-    //! Remove an element from a \"new\" bucket.\n-    //! This is the only place where actual deletions occur.\n-    //! Elements are never deleted while in the \"tried\" table, only possibly evicted back to the \"new\" table.\n-    int ShrinkNew(int nUBucket);\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId);\n \n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    //! @pre vvUnkown[nOrigin].count(nId) != 0\n-    void MakeTried(CAddrInfo& info, int nId, int nOrigin);\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos);\n \n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, int64_t nTime);\n@@ -236,8 +231,7 @@ class CAddrMan\n     void Attempt_(const CService &addr, int64_t nTime);\n \n     //! Select an address to connect to.\n-    //! nUnkBias determines how much to favor new addresses over tried ones (min=0, max=100)\n-    CAddress Select_(int nUnkBias);\n+    CAddrInfo Select_();\n \n #ifdef DEBUG_ADDRMAN\n     //! Perform consistency check. Returns an error code or zero.\n@@ -253,17 +247,21 @@ class CAddrMan\n public:\n     /**\n      * serialized format:\n-     * * version byte (currently 0)\n-     * * nKey\n+     * * version byte (currently 1)\n+     * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)\n      * * nNew\n      * * nTried\n-     * * number of \"new\" buckets\n+     * * number of \"new\" buckets XOR 2**30\n      * * all nNew addrinfos in vvNew\n      * * all nTried addrinfos in vvTried\n      * * for each bucket:\n      *   * number of elements\n      *   * for each element: index\n      *\n+     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n+     * as incompatible. This is necessary because it did not check the version number on\n+     * deserialization.\n+     *\n      * Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n      * they are instead reconstructed from the other information.\n      *\n@@ -275,48 +273,53 @@ class CAddrMan\n      *\n      * We don't use ADD_SERIALIZE_METHODS since the serialization and deserialization code has\n      * very little in common.\n-     *\n      */\n     template<typename Stream>\n     void Serialize(Stream &s, int nType, int nVersionDummy) const\n     {\n         LOCK(cs);\n \n-        unsigned char nVersion = 0;\n+        unsigned char nVersion = 1;\n         s << nVersion;\n+        s << ((unsigned char)32);\n         s << nKey;\n         s << nNew;\n         s << nTried;\n \n-        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n+        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n         s << nUBuckets;\n         std::map<int, int> mapUnkIds;\n         int nIds = 0;\n         for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            if (nIds == nNew) break; // this means nNew was wrong, oh ow\n             mapUnkIds[(*it).first] = nIds;\n             const CAddrInfo &info = (*it).second;\n             if (info.nRefCount) {\n+                assert(nIds != nNew); // this means nNew was wrong, oh ow\n                 s << info;\n                 nIds++;\n             }\n         }\n         nIds = 0;\n         for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n-            if (nIds == nTried) break; // this means nTried was wrong, oh ow\n             const CAddrInfo &info = (*it).second;\n             if (info.fInTried) {\n+                assert(nIds != nTried); // this means nTried was wrong, oh ow\n                 s << info;\n                 nIds++;\n             }\n         }\n-        for (std::vector<std::set<int> >::const_iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n-            const std::set<int> &vNew = (*it);\n-            int nSize = vNew.size();\n+        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+            int nSize = 0;\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+                if (vvNew[bucket][i] != -1)\n+                    nSize++;\n+            }\n             s << nSize;\n-            for (std::set<int>::const_iterator it2 = vNew.begin(); it2 != vNew.end(); it2++) {\n-                int nIndex = mapUnkIds[*it2];\n-                s << nIndex;\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+                if (vvNew[bucket][i] != -1) {\n+                    int nIndex = mapUnkIds[vvNew[bucket][i]];\n+                    s << nIndex;\n+                }\n             }\n         }\n     }\n@@ -326,79 +329,132 @@ class CAddrMan\n     {\n         LOCK(cs);\n \n+        Clear();\n+\n         unsigned char nVersion;\n         s >> nVersion;\n+        unsigned char nKeySize;\n+        s >> nKeySize;\n+        if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman deserialization\");\n         s >> nKey;\n         s >> nNew;\n         s >> nTried;\n-\n         int nUBuckets = 0;\n         s >> nUBuckets;\n-        nIdCount = 0;\n-        mapInfo.clear();\n-        mapAddr.clear();\n-        vRandom.clear();\n-        vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n-        vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n+        if (nVersion != 0) {\n+            nUBuckets ^= (1 << 30);\n+        }\n+\n+        // Deserialize entries from the new table.\n         for (int n = 0; n < nNew; n++) {\n             CAddrInfo &info = mapInfo[n];\n             s >> info;\n             mapAddr[info] = n;\n             info.nRandomPos = vRandom.size();\n             vRandom.push_back(n);\n-            if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n-                vvNew[info.GetNewBucket(nKey)].insert(n);\n-                info.nRefCount++;\n+            if (nVersion != 1 || nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n+                // In case the new table data cannot be used (nVersion unknown, or bucket count wrong),\n+                // immediately try to give them a reference based on their primary source address.\n+                int nUBucket = info.GetNewBucket(nKey);\n+                int nUBucketPos = info.GetBucketPosition(nKey, true, nUBucket);\n+                if (vvNew[nUBucket][nUBucketPos] == -1) {\n+                    vvNew[nUBucket][nUBucketPos] = n;\n+                    info.nRefCount++;\n+                }\n             }\n         }\n         nIdCount = nNew;\n+\n+        // Deserialize entries from the tried table.\n         int nLost = 0;\n         for (int n = 0; n < nTried; n++) {\n             CAddrInfo info;\n             s >> info;\n-            std::vector<int> &vTried = vvTried[info.GetTriedBucket(nKey)];\n-            if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n+            int nKBucket = info.GetTriedBucket(nKey);\n+            int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n+            if (vvTried[nKBucket][nKBucketPos] == -1) {\n                 info.nRandomPos = vRandom.size();\n                 info.fInTried = true;\n                 vRandom.push_back(nIdCount);\n                 mapInfo[nIdCount] = info;\n                 mapAddr[info] = nIdCount;\n-                vTried.push_back(nIdCount);\n+                vvTried[nKBucket][nKBucketPos] = nIdCount;\n                 nIdCount++;\n             } else {\n                 nLost++;\n             }\n         }\n         nTried -= nLost;\n-        for (int b = 0; b < nUBuckets; b++) {\n-            std::set<int> &vNew = vvNew[b];\n+\n+        // Deserialize positions in the new table (if possible).\n+        for (int bucket = 0; bucket < nUBuckets; bucket++) {\n             int nSize = 0;\n             s >> nSize;\n             for (int n = 0; n < nSize; n++) {\n                 int nIndex = 0;\n                 s >> nIndex;\n-                CAddrInfo &info = mapInfo[nIndex];\n-                if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n-                    info.nRefCount++;\n-                    vNew.insert(nIndex);\n+                if (nIndex >= 0 && nIndex < nNew) {\n+                    CAddrInfo &info = mapInfo[nIndex];\n+                    int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n+                    if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n+                        info.nRefCount++;\n+                        vvNew[bucket][nUBucketPos] = nIndex;\n+                    }\n                 }\n             }\n         }\n+\n+        // Prune new entries with refcount 0 (as a result of collisions).\n+        int nLostUnk = 0;\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ) {\n+            if (it->second.fInTried == false && it->second.nRefCount == 0) {\n+                std::map<int, CAddrInfo>::const_iterator itCopy = it++;\n+                Delete(itCopy->first);\n+                nLostUnk++;\n+            } else {\n+                it++;\n+            }\n+        }\n+        if (nLost + nLostUnk > 0) {\n+            LogPrint(\"addrman\", \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n+        }\n+\n+        Check();\n     }\n \n     unsigned int GetSerializeSize(int nType, int nVersion) const\n     {\n         return (CSizeComputer(nType, nVersion) << *this).size();\n     }\n \n-    CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n+    void Clear()\n     {\n-         nKey.resize(32);\n-         GetRandBytes(&nKey[0], 32);\n+        std::vector<int>().swap(vRandom);\n+        nKey = GetRandHash();\n+        for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+                vvNew[bucket][entry] = -1;\n+            }\n+        }\n+        for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; bucket++) {\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+                vvTried[bucket][entry] = -1;\n+            }\n+        }\n+\n+        nIdCount = 0;\n+        nTried = 0;\n+        nNew = 0;\n+    }\n \n-         nIdCount = 0;\n-         nTried = 0;\n-         nNew = 0;\n+    CAddrMan()\n+    {\n+        Clear();\n+    }\n+\n+    ~CAddrMan()\n+    {\n+        nKey.SetNull();\n     }\n \n     //! Return the number of (unique) addresses in all tables.\n@@ -475,15 +531,14 @@ class CAddrMan\n \n     /**\n      * Choose an address to connect to.\n-     * nUnkBias determines how much \"new\" entries are favored over \"tried\" ones (0-100).\n      */\n-    CAddress Select(int nUnkBias = 50)\n+    CAddrInfo Select()\n     {\n-        CAddress addrRet;\n+        CAddrInfo addrRet;\n         {\n             LOCK(cs);\n             Check();\n-            addrRet = Select_(nUnkBias);\n+            addrRet = Select_();\n             Check();\n         }\n         return addrRet;"
      },
      {
        "sha": "aa7ac748dad6ac124578d107feb960dda14f3b40",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,7 +5,6 @@\n \n #include \"alert.h\"\n \n-#include \"chainparams.h\"\n #include \"clientversion.h\"\n #include \"net.h\"\n #include \"pubkey.h\"\n@@ -145,11 +144,11 @@ bool CAlert::RelayTo(CNode* pnode) const\n     return false;\n }\n \n-bool CAlert::CheckSignature() const\n+bool CAlert::CheckSignature(const std::vector<unsigned char>& alertKey) const\n {\n-    CPubKey key(Params().AlertKey());\n+    CPubKey key(alertKey);\n     if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n-        return error(\"CAlert::CheckSignature() : verify signature failed\");\n+        return error(\"CAlert::CheckSignature(): verify signature failed\");\n \n     // Now unserialize the data\n     CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n@@ -169,9 +168,9 @@ CAlert CAlert::getAlertByHash(const uint256 &hash)\n     return retval;\n }\n \n-bool CAlert::ProcessAlert(bool fThread)\n+bool CAlert::ProcessAlert(const std::vector<unsigned char>& alertKey, bool fThread)\n {\n-    if (!CheckSignature())\n+    if (!CheckSignature(alertKey))\n         return false;\n     if (!IsInEffect())\n         return false;"
      },
      {
        "sha": "746967c4aff3699a5ddff1eda589e1ebdd58d0ac",
        "filename": "src/alert.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/alert.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/alert.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -100,8 +100,8 @@ class CAlert : public CUnsignedAlert\n     bool AppliesTo(int nVersion, std::string strSubVerIn) const;\n     bool AppliesToMe() const;\n     bool RelayTo(CNode* pnode) const;\n-    bool CheckSignature() const;\n-    bool ProcessAlert(bool fThread = true); // fThread means run -alertnotify in a free-running thread\n+    bool CheckSignature(const std::vector<unsigned char>& alertKey) const;\n+    bool ProcessAlert(const std::vector<unsigned char>& alertKey, bool fThread = true); // fThread means run -alertnotify in a free-running thread\n     static void Notify(const std::string& strMessage, bool fThread);\n \n     /*"
      },
      {
        "sha": "2e613635761d8622032ff85c51f506548700f70d",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,6 +7,7 @@\n \n #include \"uint256.h\"\n #include \"utilstrencodings.h\"\n+#include \"crypto/common.h\"\n \n #include <stdio.h>\n #include <string.h>\n@@ -246,14 +247,14 @@ uint32_t arith_uint256::GetCompact(bool fNegative) const\n uint256 ArithToUint256(const arith_uint256 &a)\n {\n     uint256 b;\n-    // TODO: needs bswap32 on big-endian\n-    memcpy(b.begin(), a.pn, a.size());\n+    for(int x=0; x<a.WIDTH; ++x)\n+        WriteLE32(b.begin() + x*4, a.pn[x]);\n     return b;\n }\n arith_uint256 UintToArith256(const uint256 &a)\n {\n     arith_uint256 b;\n-    // TODO: needs bswap32 on big-endian\n-    memcpy(b.pn, a.begin(), a.size());\n+    for(int x=0; x<b.WIDTH; ++x)\n+        b.pn[x] = ReadLE32(a.begin() + x*4);\n     return b;\n }"
      },
      {
        "sha": "103c78bb8e398785f1d1c4d31d556ab290386d85",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -287,4 +287,4 @@ class arith_uint256 : public base_uint<256> {\n uint256 ArithToUint256(const arith_uint256 &);\n arith_uint256 UintToArith256(const uint256 &);\n \n-#endif // BITCOIN_UINT256_H\n+#endif // BITCOIN_ARITH_UINT256_H"
      },
      {
        "sha": "c8091850560a73065d48d52466199f5c9f0c6acf",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -172,7 +172,7 @@ bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)\n     vchData.resize(vchTemp.size() - nVersionBytes);\n     if (!vchData.empty())\n         memcpy(&vchData[0], &vchTemp[nVersionBytes], vchData.size());\n-    OPENSSL_cleanse(&vchTemp[0], vchData.size());\n+    memory_cleanse(&vchTemp[0], vchData.size());\n     return true;\n }\n "
      },
      {
        "sha": "787979c8270ecf1e91b73b18f5b2c22da24e19ee",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,10 +6,10 @@\n /**\n  * Why base-58 instead of standard base-64 encoding?\n  * - Don't want 0OIl characters that look the same in some fonts and\n- *      could be used to create visually identical looking account numbers.\n- * - A string with non-alphanumeric characters is not as easily accepted as an account number.\n+ *      could be used to create visually identical looking data.\n+ * - A string with non-alphanumeric characters is not as easily accepted as input.\n  * - E-mail usually won't line-break if there's no punctuation to break at.\n- * - Double-clicking selects the whole number as one word if it's all alphanumeric.\n+ * - Double-clicking selects the whole string as one word if it's all alphanumeric.\n  */\n #ifndef BITCOIN_BASE58_H\n #define BITCOIN_BASE58_H\n@@ -19,6 +19,7 @@\n #include \"pubkey.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n+#include \"support/allocators/zeroafterfree.h\"\n \n #include <string>\n #include <vector>"
      },
      {
        "sha": "1e4aa609bb54f5a770f743057df499ac2c0c5030",
        "filename": "src/bitcoin-cli-res.rc",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-cli-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-cli-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli-res.rc?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -17,13 +17,13 @@ BEGIN\n         BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n         BEGIN\n             VALUE \"CompanyName\",        \"Bitcoin\"\n-            VALUE \"FileDescription\",    \"Bitcoin-cli (OSS RPC client for Bitcoin)\"\n+            VALUE \"FileDescription\",    \"bitcoin-cli (JSON-RPC client for Bitcoin Core)\"\n             VALUE \"FileVersion\",        VER_FILEVERSION_STR\n             VALUE \"InternalName\",       \"bitcoin-cli\"\n             VALUE \"LegalCopyright\",     COPYRIGHT_STR\n             VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n             VALUE \"OriginalFilename\",   \"bitcoin-cli.exe\"\n-            VALUE \"ProductName\",        \"Bitcoin-cli\"\n+            VALUE \"ProductName\",        \"bitcoin-cli\"\n             VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n         END\n     END"
      },
      {
        "sha": "1269d7a119fd5b6e0d82009f98ec16571ee07a82",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 17,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -12,29 +12,27 @@\n \n #include <boost/filesystem/operations.hpp>\n \n-#define _(x) std::string(x) /* Keep the _() around in case gettext or such will be used later to translate non-UI */\n-\n using namespace std;\n using namespace json_spirit;\n \n std::string HelpMessageCli()\n {\n     string strUsage;\n-    strUsage += _(\"Options:\") + \"\\n\";\n-    strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-    strUsage += \"  -conf=<file>           \" + strprintf(_(\"Specify configuration file (default: %s)\"), \"bitcoin.conf\") + \"\\n\";\n-    strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-    strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-    strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                                \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n-    strUsage += \"  -rpcconnect=<ip>       \" + strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), \"127.0.0.1\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), 8332, 18332) + \"\\n\";\n-    strUsage += \"  -rpcwait               \" + _(\"Wait for RPC server to start\") + \"\\n\";\n-    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-    strUsage += \"  -rpcssl                \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n+    strUsage += HelpMessageGroup(_(\"Options:\"));\n+    strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n+    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), \"bitcoin.conf\"));\n+    strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n+    strUsage += HelpMessageOpt(\"-testnet\", _(\"Use the test network\"));\n+    strUsage += HelpMessageOpt(\"-regtest\", _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n+                                             \"solved instantly. This is intended for regression testing tools and app development.\"));\n+    strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), \"127.0.0.1\"));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), 8332, 18332));\n+    strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n+    strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n+    strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n+\n+    strUsage += HelpMessageGroup(_(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"));\n+    strUsage += HelpMessageOpt(\"-rpcssl\", _(\"Use OpenSSL (https) for JSON-RPC connections\"));\n \n     return strUsage;\n }"
      },
      {
        "sha": "3e49b820bc5ae8a472ab8eebe9d2c2275cb82685",
        "filename": "src/bitcoin-tx-res.rc",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-tx-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-tx-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx-res.rc?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,35 @@\n+#include <windows.h>             // needed for VERSIONINFO\n+#include \"clientversion.h\"       // holds the needed client version information\n+\n+#define VER_PRODUCTVERSION     CLIENT_VERSION_MAJOR,CLIENT_VERSION_MINOR,CLIENT_VERSION_REVISION,CLIENT_VERSION_BUILD\n+#define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_REVISION) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n+#define VER_FILEVERSION        VER_PRODUCTVERSION\n+#define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n+\n+VS_VERSION_INFO VERSIONINFO\n+FILEVERSION     VER_FILEVERSION\n+PRODUCTVERSION  VER_PRODUCTVERSION\n+FILEOS          VOS_NT_WINDOWS32\n+FILETYPE        VFT_APP\n+BEGIN\n+    BLOCK \"StringFileInfo\"\n+    BEGIN\n+        BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n+        BEGIN\n+            VALUE \"CompanyName\",        \"Bitcoin\"\n+            VALUE \"FileDescription\",    \"bitcoin-tx (CLI Bitcoin transaction editor utility)\"\n+            VALUE \"FileVersion\",        VER_FILEVERSION_STR\n+            VALUE \"InternalName\",       \"bitcoin-tx\"\n+            VALUE \"LegalCopyright\",     COPYRIGHT_STR\n+            VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n+            VALUE \"OriginalFilename\",   \"bitcoin-tx.exe\"\n+            VALUE \"ProductName\",        \"bitcoin-tx\"\n+            VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n+        END\n+    END\n+\n+    BLOCK \"VarFileInfo\"\n+    BEGIN\n+        VALUE \"Translation\", 0x0, 1252 // language neutral - multilingual (decimal)\n+    END\n+END"
      },
      {
        "sha": "c82d4f93a8da7a68f78de87b3a7d8fc748fc9cd6",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 35,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -4,18 +4,17 @@\n \n #include \"base58.h\"\n #include \"clientversion.h\"\n-#include \"primitives/block.h\" // for MAX_BLOCK_SIZE\n-#include \"primitives/transaction.h\"\n-#include \"core_io.h\"\n #include \"coins.h\"\n+#include \"consensus/consensus.h\"\n+#include \"core_io.h\"\n #include \"keystore.h\"\n+#include \"primitives/transaction.h\"\n #include \"script/script.h\"\n #include \"script/sign.h\"\n-#include \"ui_interface.h\" // for _(...)\n #include \"univalue/univalue.h\"\n #include \"util.h\"\n-#include \"utilstrencodings.h\"\n #include \"utilmoneystr.h\"\n+#include \"utilstrencodings.h\"\n \n #include <stdio.h>\n \n@@ -26,7 +25,6 @@ using namespace std;\n \n static bool fCreateBlank;\n static map<string,UniValue> registers;\n-CClientUIInterface uiInterface;\n \n static bool AppInitRawTx(int argc, char* argv[])\n {\n@@ -54,38 +52,34 @@ static bool AppInitRawTx(int argc, char* argv[])\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n-        strUsage = _(\"Options:\") + \"\\n\";\n-        strUsage += \"  -?                      \" + _(\"This help message\") + \"\\n\";\n-        strUsage += \"  -create                 \" + _(\"Create new, empty TX.\") + \"\\n\";\n-        strUsage += \"  -json                   \" + _(\"Select JSON output\") + \"\\n\";\n-        strUsage += \"  -txid                   \" + _(\"Output only the hex-encoded transaction id of the resultant transaction.\") + \"\\n\";\n-        strUsage += \"  -regtest                \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n-        strUsage += \"  -testnet                \" + _(\"Use the test network\") + \"\\n\";\n-        strUsage += \"\\n\";\n+        strUsage = HelpMessageGroup(_(\"Options:\"));\n+        strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n+        strUsage += HelpMessageOpt(\"-create\", _(\"Create new, empty TX.\"));\n+        strUsage += HelpMessageOpt(\"-json\", _(\"Select JSON output\"));\n+        strUsage += HelpMessageOpt(\"-txid\", _(\"Output only the hex-encoded transaction id of the resultant transaction.\"));\n+        strUsage += HelpMessageOpt(\"-regtest\", _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\"));\n+        strUsage += HelpMessageOpt(\"-testnet\", _(\"Use the test network\"));\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n-\n-        strUsage = _(\"Commands:\") + \"\\n\";\n-        strUsage += \"  delin=N                \" + _(\"Delete input N from TX\") + \"\\n\";\n-        strUsage += \"  delout=N               \" + _(\"Delete output N from TX\") + \"\\n\";\n-        strUsage += \"  in=TXID:VOUT           \" + _(\"Add input to TX\") + \"\\n\";\n-        strUsage += \"  locktime=N             \" + _(\"Set TX lock time to N\") + \"\\n\";\n-        strUsage += \"  nversion=N             \" + _(\"Set TX version to N\") + \"\\n\";\n-        strUsage += \"  outaddr=VALUE:ADDRESS  \" + _(\"Add address-based output to TX\") + \"\\n\";\n-        strUsage += \"  outscript=VALUE:SCRIPT \" + _(\"Add raw script output to TX\") + \"\\n\";\n-        strUsage += \"  sign=SIGHASH-FLAGS     \" + _(\"Add zero or more signatures to transaction\") + \"\\n\";\n-        strUsage += \"      This command requires JSON registers:\\n\";\n-        strUsage += \"      prevtxs=JSON object\\n\";\n-        strUsage += \"      privatekeys=JSON object\\n\";\n-        strUsage += \"      See signrawtransaction docs for format of sighash flags, JSON objects.\\n\";\n-        strUsage += \"\\n\";\n+        strUsage = HelpMessageGroup(_(\"Commands:\"));\n+        strUsage += HelpMessageOpt(\"delin=N\", _(\"Delete input N from TX\"));\n+        strUsage += HelpMessageOpt(\"delout=N\", _(\"Delete output N from TX\"));\n+        strUsage += HelpMessageOpt(\"in=TXID:VOUT\", _(\"Add input to TX\"));\n+        strUsage += HelpMessageOpt(\"locktime=N\", _(\"Set TX lock time to N\"));\n+        strUsage += HelpMessageOpt(\"nversion=N\", _(\"Set TX version to N\"));\n+        strUsage += HelpMessageOpt(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"));\n+        strUsage += HelpMessageOpt(\"outscript=VALUE:SCRIPT\", _(\"Add raw script output to TX\"));\n+        strUsage += HelpMessageOpt(\"sign=SIGHASH-FLAGS\", _(\"Add zero or more signatures to transaction\") + \". \" +\n+            _(\"This command requires JSON registers:\") +\n+            _(\"prevtxs=JSON object\") + \", \" +\n+            _(\"privatekeys=JSON object\") + \". \" +\n+            _(\"See signrawtransaction docs for format of sighash flags, JSON objects.\"));\n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n-        strUsage = _(\"Register Commands:\") + \"\\n\";\n-        strUsage += \"  load=NAME:FILENAME     \" + _(\"Load JSON file FILENAME into register NAME\") + \"\\n\";\n-        strUsage += \"  set=NAME:JSON-STRING   \" + _(\"Set register NAME to given JSON-STRING\") + \"\\n\";\n-        strUsage += \"\\n\";\n+        strUsage = HelpMessageGroup(_(\"Register Commands:\"));\n+        strUsage += HelpMessageOpt(\"load=NAME:FILENAME\", _(\"Load JSON file FILENAME into register NAME\"));\n+        strUsage += HelpMessageOpt(\"set=NAME:JSON-STRING\", _(\"Set register NAME to given JSON-STRING\"));\n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n         return false;\n@@ -436,7 +430,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n         BOOST_FOREACH(const CTransaction& txv, txVariants) {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, SignatureChecker(mergedTx, i)))\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i)))\n             fComplete = false;\n     }\n \n@@ -448,9 +442,18 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     tx = mergedTx;\n }\n \n+class Secp256k1Init\n+{\n+public:\n+    Secp256k1Init() { ECC_Start(); }\n+    ~Secp256k1Init() { ECC_Stop(); }\n+};\n+\n static void MutateTx(CMutableTransaction& tx, const string& command,\n                      const string& commandVal)\n {\n+    boost::scoped_ptr<Secp256k1Init> ecc;\n+\n     if (command == \"nversion\")\n         MutateTxVersion(tx, commandVal);\n     else if (command == \"locktime\")\n@@ -468,8 +471,10 @@ static void MutateTx(CMutableTransaction& tx, const string& command,\n     else if (command == \"outscript\")\n         MutateTxAddOutScript(tx, commandVal);\n \n-    else if (command == \"sign\")\n+    else if (command == \"sign\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxSign(tx, commandVal);\n+    }\n \n     else if (command == \"load\")\n         RegisterLoad(commandVal);"
      },
      {
        "sha": "3a64acd5d194d1393d5a44022c44a9ba1637541d",
        "filename": "src/bitcoind-res.rc",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoind-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoind-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind-res.rc?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -17,13 +17,13 @@ BEGIN\n         BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n         BEGIN\n             VALUE \"CompanyName\",        \"Bitcoin\"\n-            VALUE \"FileDescription\",    \"Bitcoind (OSS daemon/client for Bitcoin)\"\n+            VALUE \"FileDescription\",    \"bitcoind (Bitcoin node with a JSON-RPC server)\"\n             VALUE \"FileVersion\",        VER_FILEVERSION_STR\n             VALUE \"InternalName\",       \"bitcoind\"\n             VALUE \"LegalCopyright\",     COPYRIGHT_STR\n             VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n             VALUE \"OriginalFilename\",   \"bitcoind.exe\"\n-            VALUE \"ProductName\",        \"Bitcoind\"\n+            VALUE \"ProductName\",        \"bitcoind\"\n             VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n         END\n     END"
      },
      {
        "sha": "cce687ac98cb0a1eedfbd22bae852322f029840d",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 16,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,7 +8,7 @@\n #include \"init.h\"\n #include \"main.h\"\n #include \"noui.h\"\n-#include \"ui_interface.h\"\n+#include \"scheduler.h\"\n #include \"util.h\"\n \n #include <boost/algorithm/string/predicate.hpp>\n@@ -21,7 +21,7 @@\n  *\n  * \\section intro_sec Introduction\n  *\n- * This is the developer documentation of the reference client for an experimental new digital currency called Bitcoin (http://www.bitcoin.org/),\n+ * This is the developer documentation of the reference client for an experimental new digital currency called Bitcoin (https://www.bitcoin.org/),\n  * which enables instant payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer technology to operate\n  * with no central authority: managing transactions and issuing money are carried out collectively by the network.\n  *\n@@ -33,7 +33,7 @@\n \n static bool fDaemon;\n \n-void DetectShutdownThread(boost::thread_group* threadGroup)\n+void WaitForShutdown(boost::thread_group* threadGroup)\n {\n     bool fShutdown = ShutdownRequested();\n     // Tell the main threads to shutdown.\n@@ -56,7 +56,7 @@ void DetectShutdownThread(boost::thread_group* threadGroup)\n bool AppInit(int argc, char* argv[])\n {\n     boost::thread_group threadGroup;\n-    boost::thread* detectShutdownThread = NULL;\n+    CScheduler scheduler;\n \n     bool fRet = false;\n \n@@ -144,8 +144,7 @@ bool AppInit(int argc, char* argv[])\n #endif\n         SoftSetBoolArg(\"-server\", true);\n \n-        detectShutdownThread = new boost::thread(boost::bind(&DetectShutdownThread, &threadGroup));\n-        fRet = AppInit2(threadGroup);\n+        fRet = AppInit2(threadGroup, scheduler);\n     }\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInit()\");\n@@ -155,20 +154,12 @@ bool AppInit(int argc, char* argv[])\n \n     if (!fRet)\n     {\n-        if (detectShutdownThread)\n-            detectShutdownThread->interrupt();\n-\n         threadGroup.interrupt_all();\n         // threadGroup.join_all(); was left out intentionally here, because we didn't re-test all of\n         // the startup-failure cases to make sure they don't result in a hang due to some\n         // thread-blocking-waiting-for-another-thread-during-startup case\n-    }\n-\n-    if (detectShutdownThread)\n-    {\n-        detectShutdownThread->join();\n-        delete detectShutdownThread;\n-        detectShutdownThread = NULL;\n+    } else {\n+        WaitForShutdown(&threadGroup);\n     }\n     Shutdown();\n "
      },
      {
        "sha": "36cba491c4eb6e4709c28da444c61c82fb3c4797",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 16,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -21,22 +21,33 @@\n using namespace std;\n \n CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n-/**\n- * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n- * - nElements * log(fp rate) / ln(2)^2\n- * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n- */\n-vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n-/**\n- * The ideal number of hash functions is filter size * ln(2) / number of elements\n- * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n- * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n- */\n-isFull(false),\n-isEmpty(false),\n-nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n-nTweak(nTweakIn),\n-nFlags(nFlagsIn)\n+    /**\n+     * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n+     * - nElements * log(fp rate) / ln(2)^2\n+     * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n+     */\n+    vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+    /**\n+     * The ideal number of hash functions is filter size * ln(2) / number of elements\n+     * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n+     * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n+     */\n+    isFull(false),\n+    isEmpty(false),\n+    nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n+    nTweak(nTweakIn),\n+    nFlags(nFlagsIn)\n+{\n+}\n+\n+// Private constructor used by CRollingBloomFilter\n+CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn) :\n+    vData((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)) / 8),\n+    isFull(false),\n+    isEmpty(true),\n+    nHashFuncs((unsigned int)(vData.size() * 8 / nElements * LN2)),\n+    nTweak(nTweakIn),\n+    nFlags(BLOOM_UPDATE_NONE)\n {\n }\n \n@@ -197,3 +208,43 @@ void CBloomFilter::UpdateEmptyFull()\n     isFull = full;\n     isEmpty = empty;\n }\n+\n+CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate, unsigned int nTweak) :\n+    b1(nElements * 2, fpRate, nTweak), b2(nElements * 2, fpRate, nTweak)\n+{\n+    // Implemented using two bloom filters of 2 * nElements each.\n+    // We fill them up, and clear them, staggered, every nElements\n+    // inserted, so at least one always contains the last nElements\n+    // inserted.\n+    nBloomSize = nElements * 2;\n+    nInsertions = 0;\n+}\n+\n+void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n+{\n+    if (nInsertions == 0) {\n+        b1.clear();\n+    } else if (nInsertions == nBloomSize / 2) {\n+        b2.clear();\n+    }\n+    b1.insert(vKey);\n+    b2.insert(vKey);\n+    if (++nInsertions == nBloomSize) {\n+        nInsertions = 0;\n+    }\n+}\n+\n+bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n+{\n+    if (nInsertions < nBloomSize / 2) {\n+        return b2.contains(vKey);\n+    }\n+    return b1.contains(vKey);\n+}\n+\n+void CRollingBloomFilter::clear()\n+{\n+    b1.clear();\n+    b2.clear();\n+    nInsertions = 0;\n+}"
      },
      {
        "sha": "bb17f59c863ce71af4d9d82e7ffbdd4648dedfe5",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 32,
        "deletions": 4,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -32,14 +32,14 @@ enum bloomflags\n \n /**\n  * BloomFilter is a probabilistic filter which SPV clients provide\n- * so that we can filter the transactions we sends them.\n+ * so that we can filter the transactions we send them.\n  * \n  * This allows for significantly more efficient transaction and block downloads.\n  * \n- * Because bloom filters are probabilistic, an SPV node can increase the false-\n- * positive rate, making us send them transactions which aren't actually theirs, \n+ * Because bloom filters are probabilistic, a SPV node can increase the false-\n+ * positive rate, making us send it transactions which aren't actually its,\n  * allowing clients to trade more bandwidth for more privacy by obfuscating which\n- * keys are owned by them.\n+ * keys are controlled by them.\n  */\n class CBloomFilter\n {\n@@ -53,6 +53,10 @@ class CBloomFilter\n \n     unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n+    // Private constructor for CRollingBloomFilter, no restrictions on size\n+    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+    friend class CRollingBloomFilter;\n+\n public:\n     /**\n      * Creates a new bloom filter which will provide the given fp rate when filled with the given number of elements\n@@ -97,4 +101,28 @@ class CBloomFilter\n     void UpdateEmptyFull();\n };\n \n+/**\n+ * RollingBloomFilter is a probabilistic \"keep track of most recently inserted\" set.\n+ * Construct it with the number of items to keep track of, and a false-positive rate.\n+ *\n+ * contains(item) will always return true if item was one of the last N things\n+ * insert()'ed ... but may also return true for items that were not inserted.\n+ */\n+class CRollingBloomFilter\n+{\n+public:\n+    CRollingBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+\n+    void insert(const std::vector<unsigned char>& vKey);\n+    bool contains(const std::vector<unsigned char>& vKey) const;\n+\n+    void clear();\n+\n+private:\n+    unsigned int nBloomSize;\n+    unsigned int nInsertions;\n+    CBloomFilter b1, b2;\n+};\n+\n+\n #endif // BITCOIN_BLOOM_H"
      },
      {
        "sha": "01be2d6e5c940c817b6e27ceec24789a861b81c1",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -48,6 +48,12 @@ struct CDiskBlockPos\n \n     void SetNull() { nFile = -1; nPos = 0; }\n     bool IsNull() const { return (nFile == -1); }\n+\n+    std::string ToString() const\n+    {\n+        return strprintf(\"CBlockDiskPos(nFile=%i, nPos=%i)\", nFile, nPos);\n+    }\n+\n };\n \n enum BlockStatus {\n@@ -68,7 +74,7 @@ enum BlockStatus {\n      */\n     BLOCK_VALID_TRANSACTIONS =    3,\n \n-    //! Outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30.\n+    //! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30.\n     //! Implies all parents are also at least CHAIN.\n     BLOCK_VALID_CHAIN        =    4,\n "
      },
      {
        "sha": "5f400b265cec9208ba0519ebb003de02dea793c4",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 180,
        "changes": 269,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,7 +5,6 @@\n \n #include \"chainparams.h\"\n \n-#include \"random.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n@@ -15,116 +14,50 @@\n \n using namespace std;\n \n-struct SeedSpec6 {\n-    uint8_t addr[16];\n-    uint16_t port;\n-};\n-\n #include \"chainparamsseeds.h\"\n \n /**\n  * Main network\n  */\n-\n-//! Convert the pnSeeds6 array into usable address objects.\n-static void convertSeed6(std::vector<CAddress> &vSeedsOut, const SeedSpec6 *data, unsigned int count)\n-{\n-    // It'll only connect to one or two seed nodes because once it connects,\n-    // it'll get a pile of addresses with newer timestamps.\n-    // Seed nodes are given a random 'last seen time' of between one and two\n-    // weeks ago.\n-    const int64_t nOneWeek = 7*24*60*60;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-        struct in6_addr ip;\n-        memcpy(&ip, data[i].addr, sizeof(ip));\n-        CAddress addr(CService(ip, data[i].port));\n-        addr.nTime = GetTime() - GetRand(nOneWeek) - nOneWeek;\n-        vSeedsOut.push_back(addr);\n-    }\n-}\n-\n /**\n  * What makes a good checkpoint block?\n  * + Is surrounded by blocks with reasonable timestamps\n  *   (no blocks before with a timestamp after, none after with\n  *    timestamp before)\n  * + Contains no strange transactions\n  */\n-static Checkpoints::MapCheckpoints mapCheckpoints =\n-        boost::assign::map_list_of\n-        ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n-        ( 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n-        ( 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n-        (105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n-        (134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n-        (168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n-        (193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n-        (210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n-        (216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n-        (225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n-        (250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n-        (279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n-        (295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n-        ;\n-static const Checkpoints::CCheckpointData data = {\n-        &mapCheckpoints,\n-        1397080064, // * UNIX timestamp of last checkpoint block\n-        36544669,   // * total number of transactions between genesis and last checkpoint\n-                    //   (the tx=... number in the SetBestChain debug.log lines)\n-        60000.0     // * estimated number of transactions per day after checkpoint\n-    };\n-\n-static Checkpoints::MapCheckpoints mapCheckpointsTestnet =\n-        boost::assign::map_list_of\n-        ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\"))\n-        ;\n-static const Checkpoints::CCheckpointData dataTestnet = {\n-        &mapCheckpointsTestnet,\n-        1337966069,\n-        1488,\n-        300\n-    };\n-\n-static Checkpoints::MapCheckpoints mapCheckpointsRegtest =\n-        boost::assign::map_list_of\n-        ( 0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n-        ;\n-static const Checkpoints::CCheckpointData dataRegtest = {\n-        &mapCheckpointsRegtest,\n-        0,\n-        0,\n-        0\n-    };\n \n class CMainParams : public CChainParams {\n public:\n     CMainParams() {\n         strNetworkID = \"main\";\n+        consensus.nSubsidyHalvingInterval = 210000;\n+        consensus.nMajorityEnforceBlockUpgrade = 750;\n+        consensus.nMajorityRejectBlockOutdated = 950;\n+        consensus.nMajorityWindow = 1000;\n+        consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n+        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n+        consensus.nPowTargetSpacing = 10 * 60;\n+        consensus.fPowAllowMinDifficultyBlocks = false;\n         /** \n          * The message start string is designed to be unlikely to occur in normal data.\n          * The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n-         * a large 4-byte int at any alignment.\n+         * a large 32-bit integer with any alignment.\n          */\n         pchMessageStart[0] = 0xf9;\n         pchMessageStart[1] = 0xbe;\n         pchMessageStart[2] = 0xb4;\n         pchMessageStart[3] = 0xd9;\n         vAlertPubKey = ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\");\n         nDefaultPort = 8333;\n-        bnProofOfWorkLimit = ~arith_uint256(0) >> 32;\n-        nSubsidyHalvingInterval = 210000;\n-        nEnforceBlockUpgradeMajority = 750;\n-        nRejectBlockOutdatedMajority = 950;\n-        nToCheckBlockUpgradeMajority = 1000;\n         nMinerThreads = 0;\n-        nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        nTargetSpacing = 10 * 60;\n+        nPruneAfterHeight = 100000;\n \n         /**\n-         * Build the genesis block. Note that the output of the genesis coinbase cannot\n-         * be spent as it did not originally exist in the database.\n-         * \n+         * Build the genesis block. Note that the output of its generation\n+         * transaction cannot be spent since it did not originally exist in the\n+         * database.\n+         *\n          * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)\n          *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n          *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)\n@@ -146,37 +79,52 @@ class CMainParams : public CChainParams {\n         genesis.nBits    = 0x1d00ffff;\n         genesis.nNonce   = 2083236893;\n \n-        hashGenesisBlock = genesis.GetHash();\n-        assert(hashGenesisBlock == uint256S(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\"));\n+        consensus.hashGenesisBlock = genesis.GetHash();\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\"));\n         assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n \n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.sipa.be\", \"seed.bitcoin.sipa.be\"));\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"dnsseed.bluematt.me\"));\n-        vSeeds.push_back(CDNSSeedData(\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\"));\n-        vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\"));\n-        vSeeds.push_back(CDNSSeedData(\"xf2.org\", \"bitseed.xf2.org\"));\n+        vSeeds.push_back(CDNSSeedData(\"bitcoin.sipa.be\", \"seed.bitcoin.sipa.be\")); // Pieter Wuille\n+        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"dnsseed.bluematt.me\")); // Matt Corallo\n+        vSeeds.push_back(CDNSSeedData(\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\")); // Luke Dashjr\n+        vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\")); // Christian Decker\n+        vSeeds.push_back(CDNSSeedData(\"xf2.org\", \"bitseed.xf2.org\")); // Jeff Garzik\n+        vSeeds.push_back(CDNSSeedData(\"bitcoin.jonasschnelli.ch\", \"seed.bitcoin.jonasschnelli.ch\")); // Jonas Schnelli\n \n-        base58Prefixes[PUBKEY_ADDRESS] = boost::assign::list_of(0);\n-        base58Prefixes[SCRIPT_ADDRESS] = boost::assign::list_of(5);\n-        base58Prefixes[SECRET_KEY] =     boost::assign::list_of(128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E);\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4);\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n+        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4).convert_to_container<std::vector<unsigned char> >();\n \n-        convertSeed6(vFixedSeeds, pnSeed6_main, ARRAYLEN(pnSeed6_main));\n+        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));\n \n         fRequireRPCPassword = true;\n         fMiningRequiresPeers = true;\n-        fDefaultCheckMemPool = false;\n-        fAllowMinDifficultyBlocks = false;\n+        fDefaultConsistencyChecks = false;\n         fRequireStandard = true;\n         fMineBlocksOnDemand = false;\n-        fSkipProofOfWorkCheck = false;\n         fTestnetToBeDeprecatedFieldRPC = false;\n-    }\n \n-    const Checkpoints::CCheckpointData& Checkpoints() const \n-    {\n-        return data;\n+        checkpointData = (Checkpoints::CCheckpointData) {\n+            boost::assign::map_list_of\n+            ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n+            ( 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n+            ( 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n+            (105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n+            (134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n+            (168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n+            (193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n+            (210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n+            (216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n+            (225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n+            (250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n+            (279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n+            (295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")),\n+            1397080064, // * UNIX timestamp of last checkpoint block\n+            36544669,   // * total number of transactions between genesis and last checkpoint\n+                        //   (the tx=... number in the SetBestChain debug.log lines)\n+            60000.0     // * estimated number of transactions per day after checkpoint\n+        };\n     }\n };\n static CMainParams mainParams;\n@@ -188,24 +136,24 @@ class CTestNetParams : public CMainParams {\n public:\n     CTestNetParams() {\n         strNetworkID = \"test\";\n+        consensus.nMajorityEnforceBlockUpgrade = 51;\n+        consensus.nMajorityRejectBlockOutdated = 75;\n+        consensus.nMajorityWindow = 100;\n+        consensus.fPowAllowMinDifficultyBlocks = true;\n         pchMessageStart[0] = 0x0b;\n         pchMessageStart[1] = 0x11;\n         pchMessageStart[2] = 0x09;\n         pchMessageStart[3] = 0x07;\n         vAlertPubKey = ParseHex(\"04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a\");\n         nDefaultPort = 18333;\n-        nEnforceBlockUpgradeMajority = 51;\n-        nRejectBlockOutdatedMajority = 75;\n-        nToCheckBlockUpgradeMajority = 100;\n         nMinerThreads = 0;\n-        nTargetTimespan = 14 * 24 * 60 * 60; //! two weeks\n-        nTargetSpacing = 10 * 60;\n+        nPruneAfterHeight = 1000;\n \n         //! Modify the testnet genesis block so the timestamp is valid for a later start.\n         genesis.nTime = 1296688602;\n         genesis.nNonce = 414098458;\n-        hashGenesisBlock = genesis.GetHash();\n-        assert(hashGenesisBlock == uint256S(\"0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\"));\n+        consensus.hashGenesisBlock = genesis.GetHash();\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\"));\n \n         vFixedSeeds.clear();\n         vSeeds.clear();\n@@ -214,25 +162,29 @@ class CTestNetParams : public CMainParams {\n         vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"testnet-seed.bluematt.me\"));\n         vSeeds.push_back(CDNSSeedData(\"bitcoin.schildbach.de\", \"testnet-seed.bitcoin.schildbach.de\"));\n \n-        base58Prefixes[PUBKEY_ADDRESS] = boost::assign::list_of(111);\n-        base58Prefixes[SCRIPT_ADDRESS] = boost::assign::list_of(196);\n-        base58Prefixes[SECRET_KEY]     = boost::assign::list_of(239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF);\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94);\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n+        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n \n-        convertSeed6(vFixedSeeds, pnSeed6_test, ARRAYLEN(pnSeed6_test));\n+        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));\n \n         fRequireRPCPassword = true;\n         fMiningRequiresPeers = true;\n-        fDefaultCheckMemPool = false;\n-        fAllowMinDifficultyBlocks = true;\n+        fDefaultConsistencyChecks = false;\n         fRequireStandard = false;\n         fMineBlocksOnDemand = false;\n         fTestnetToBeDeprecatedFieldRPC = true;\n-    }\n-    const Checkpoints::CCheckpointData& Checkpoints() const \n-    {\n-        return dataTestnet;\n+\n+        checkpointData = (Checkpoints::CCheckpointData) {\n+            boost::assign::map_list_of\n+            ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")),\n+            1337966069,\n+            1488,\n+            300\n+        };\n+\n     }\n };\n static CTestNetParams testNetParams;\n@@ -244,88 +196,47 @@ class CRegTestParams : public CTestNetParams {\n public:\n     CRegTestParams() {\n         strNetworkID = \"regtest\";\n+        consensus.nSubsidyHalvingInterval = 150;\n+        consensus.nMajorityEnforceBlockUpgrade = 750;\n+        consensus.nMajorityRejectBlockOutdated = 950;\n+        consensus.nMajorityWindow = 1000;\n+        consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         pchMessageStart[0] = 0xfa;\n         pchMessageStart[1] = 0xbf;\n         pchMessageStart[2] = 0xb5;\n         pchMessageStart[3] = 0xda;\n-        nSubsidyHalvingInterval = 150;\n-        nEnforceBlockUpgradeMajority = 750;\n-        nRejectBlockOutdatedMajority = 950;\n-        nToCheckBlockUpgradeMajority = 1000;\n         nMinerThreads = 1;\n-        nTargetTimespan = 14 * 24 * 60 * 60; //! two weeks\n-        nTargetSpacing = 10 * 60;\n-        bnProofOfWorkLimit = ~arith_uint256(0) >> 1;\n         genesis.nTime = 1296688602;\n         genesis.nBits = 0x207fffff;\n         genesis.nNonce = 2;\n-        hashGenesisBlock = genesis.GetHash();\n+        consensus.hashGenesisBlock = genesis.GetHash();\n         nDefaultPort = 18444;\n-        assert(hashGenesisBlock == uint256S(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\n+        nPruneAfterHeight = 1000;\n \n         vFixedSeeds.clear(); //! Regtest mode doesn't have any fixed seeds.\n         vSeeds.clear();  //! Regtest mode doesn't have any DNS seeds.\n \n         fRequireRPCPassword = false;\n         fMiningRequiresPeers = false;\n-        fDefaultCheckMemPool = true;\n-        fAllowMinDifficultyBlocks = true;\n+        fDefaultConsistencyChecks = true;\n         fRequireStandard = false;\n         fMineBlocksOnDemand = true;\n         fTestnetToBeDeprecatedFieldRPC = false;\n-    }\n-    const Checkpoints::CCheckpointData& Checkpoints() const \n-    {\n-        return dataRegtest;\n-    }\n-};\n-static CRegTestParams regTestParams;\n \n-/**\n- * Unit test\n- */\n-class CUnitTestParams : public CMainParams, public CModifiableParams {\n-public:\n-    CUnitTestParams() {\n-        strNetworkID = \"unittest\";\n-        nDefaultPort = 18445;\n-        vFixedSeeds.clear(); //! Unit test mode doesn't have any fixed seeds.\n-        vSeeds.clear();  //! Unit test mode doesn't have any DNS seeds.\n-\n-        fRequireRPCPassword = false;\n-        fMiningRequiresPeers = false;\n-        fDefaultCheckMemPool = true;\n-        fAllowMinDifficultyBlocks = false;\n-        fMineBlocksOnDemand = true;\n+        checkpointData = (Checkpoints::CCheckpointData){\n+            boost::assign::map_list_of\n+            ( 0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")),\n+            0,\n+            0,\n+            0\n+        };\n     }\n-\n-    const Checkpoints::CCheckpointData& Checkpoints() const \n-    {\n-        // UnitTest share the same checkpoints as MAIN\n-        return data;\n-    }\n-\n-    //! Published setters to allow changing values in unit test cases\n-    virtual void setSubsidyHalvingInterval(int anSubsidyHalvingInterval)  { nSubsidyHalvingInterval=anSubsidyHalvingInterval; }\n-    virtual void setEnforceBlockUpgradeMajority(int anEnforceBlockUpgradeMajority)  { nEnforceBlockUpgradeMajority=anEnforceBlockUpgradeMajority; }\n-    virtual void setRejectBlockOutdatedMajority(int anRejectBlockOutdatedMajority)  { nRejectBlockOutdatedMajority=anRejectBlockOutdatedMajority; }\n-    virtual void setToCheckBlockUpgradeMajority(int anToCheckBlockUpgradeMajority)  { nToCheckBlockUpgradeMajority=anToCheckBlockUpgradeMajority; }\n-    virtual void setDefaultCheckMemPool(bool afDefaultCheckMemPool)  { fDefaultCheckMemPool=afDefaultCheckMemPool; }\n-    virtual void setAllowMinDifficultyBlocks(bool afAllowMinDifficultyBlocks) {  fAllowMinDifficultyBlocks=afAllowMinDifficultyBlocks; }\n-    virtual void setSkipProofOfWorkCheck(bool afSkipProofOfWorkCheck) { fSkipProofOfWorkCheck = afSkipProofOfWorkCheck; }\n };\n-static CUnitTestParams unitTestParams;\n-\n+static CRegTestParams regTestParams;\n \n static CChainParams *pCurrentParams = 0;\n \n-CModifiableParams *ModifiableParams()\n-{\n-   assert(pCurrentParams);\n-   assert(pCurrentParams==&unitTestParams);\n-   return (CModifiableParams*)&unitTestParams;\n-}\n-\n const CChainParams &Params() {\n     assert(pCurrentParams);\n     return *pCurrentParams;\n@@ -339,8 +250,6 @@ CChainParams &Params(CBaseChainParams::Network network) {\n             return testNetParams;\n         case CBaseChainParams::REGTEST:\n             return regTestParams;\n-        case CBaseChainParams::UNITTEST:\n-            return unitTestParams;\n         default:\n             assert(false && \"Unimplemented network\");\n             return mainParams;"
      },
      {
        "sha": "8044b553e19a29be2fbb39e8960b2f83daa214d3",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 23,
        "deletions": 60,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,19 +8,23 @@\n \n #include \"chainparamsbase.h\"\n #include \"checkpoints.h\"\n+#include \"consensus/params.h\"\n #include \"primitives/block.h\"\n #include \"protocol.h\"\n-#include \"arith_uint256.h\"\n \n #include <vector>\n \n-typedef unsigned char MessageStartChars[MESSAGE_START_SIZE];\n-\n struct CDNSSeedData {\n     std::string name, host;\n     CDNSSeedData(const std::string &strName, const std::string &strHost) : name(strName), host(strHost) {}\n };\n \n+struct SeedSpec6 {\n+    uint8_t addr[16];\n+    uint16_t port;\n+};\n+\n+\n /**\n  * CChainParams defines various tweakable parameters of a given instance of the\n  * Bitcoin system. There are three: the main network on which people trade goods\n@@ -41,34 +45,22 @@ class CChainParams\n         MAX_BASE58_TYPES\n     };\n \n-    const uint256& HashGenesisBlock() const { return hashGenesisBlock; }\n-    const MessageStartChars& MessageStart() const { return pchMessageStart; }\n+    const Consensus::Params& GetConsensus() const { return consensus; }\n+    const CMessageHeader::MessageStartChars& MessageStart() const { return pchMessageStart; }\n     const std::vector<unsigned char>& AlertKey() const { return vAlertPubKey; }\n     int GetDefaultPort() const { return nDefaultPort; }\n-    const arith_uint256& ProofOfWorkLimit() const { return bnProofOfWorkLimit; }\n-    int SubsidyHalvingInterval() const { return nSubsidyHalvingInterval; }\n-    /** Used to check majorities for block version upgrade */\n-    int EnforceBlockUpgradeMajority() const { return nEnforceBlockUpgradeMajority; }\n-    int RejectBlockOutdatedMajority() const { return nRejectBlockOutdatedMajority; }\n-    int ToCheckBlockUpgradeMajority() const { return nToCheckBlockUpgradeMajority; }\n \n     /** Used if GenerateBitcoins is called with a negative number of threads */\n     int DefaultMinerThreads() const { return nMinerThreads; }\n     const CBlock& GenesisBlock() const { return genesis; }\n     bool RequireRPCPassword() const { return fRequireRPCPassword; }\n     /** Make miner wait to have peers to avoid wasting work */\n     bool MiningRequiresPeers() const { return fMiningRequiresPeers; }\n-    /** Default value for -checkmempool argument */\n-    bool DefaultCheckMemPool() const { return fDefaultCheckMemPool; }\n-    /** Allow mining of a min-difficulty block */\n-    bool AllowMinDifficultyBlocks() const { return fAllowMinDifficultyBlocks; }\n-    /** Skip proof-of-work check: allow mining of any difficulty block */\n-    bool SkipProofOfWorkCheck() const { return fSkipProofOfWorkCheck; }\n-    /** Make standard checks */\n+    /** Default value for -checkmempool and -checkblockindex argument */\n+    bool DefaultConsistencyChecks() const { return fDefaultConsistencyChecks; }\n+    /** Policy: Filter transactions that do not match well-defined patterns */\n     bool RequireStandard() const { return fRequireStandard; }\n-    int64_t TargetTimespan() const { return nTargetTimespan; }\n-    int64_t TargetSpacing() const { return nTargetSpacing; }\n-    int64_t Interval() const { return nTargetTimespan / nTargetSpacing; }\n+    int64_t PruneAfterHeight() const { return nPruneAfterHeight; }\n     /** Make miner stop after a block is found. In RPC, don't return until nGenProcLimit blocks are generated */\n     bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n     /** In the future use NetworkIDString() for RPC fields */\n@@ -77,70 +69,41 @@ class CChainParams\n     std::string NetworkIDString() const { return strNetworkID; }\n     const std::vector<CDNSSeedData>& DNSSeeds() const { return vSeeds; }\n     const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n-    const std::vector<CAddress>& FixedSeeds() const { return vFixedSeeds; }\n-    virtual const Checkpoints::CCheckpointData& Checkpoints() const = 0;\n+    const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n+    const Checkpoints::CCheckpointData& Checkpoints() const { return checkpointData; }\n protected:\n     CChainParams() {}\n \n-    uint256 hashGenesisBlock;\n-    MessageStartChars pchMessageStart;\n+    Consensus::Params consensus;\n+    CMessageHeader::MessageStartChars pchMessageStart;\n     //! Raw pub key bytes for the broadcast alert signing key.\n     std::vector<unsigned char> vAlertPubKey;\n     int nDefaultPort;\n-    arith_uint256 bnProofOfWorkLimit;\n-    int nSubsidyHalvingInterval;\n-    int nEnforceBlockUpgradeMajority;\n-    int nRejectBlockOutdatedMajority;\n-    int nToCheckBlockUpgradeMajority;\n-    int64_t nTargetTimespan;\n-    int64_t nTargetSpacing;\n     int nMinerThreads;\n+    uint64_t nPruneAfterHeight;\n     std::vector<CDNSSeedData> vSeeds;\n     std::vector<unsigned char> base58Prefixes[MAX_BASE58_TYPES];\n     std::string strNetworkID;\n     CBlock genesis;\n-    std::vector<CAddress> vFixedSeeds;\n+    std::vector<SeedSpec6> vFixedSeeds;\n     bool fRequireRPCPassword;\n     bool fMiningRequiresPeers;\n-    bool fDefaultCheckMemPool;\n-    bool fAllowMinDifficultyBlocks;\n+    bool fDefaultConsistencyChecks;\n     bool fRequireStandard;\n     bool fMineBlocksOnDemand;\n-    bool fSkipProofOfWorkCheck;\n     bool fTestnetToBeDeprecatedFieldRPC;\n+    Checkpoints::CCheckpointData checkpointData;\n };\n \n-/** \n- * Modifiable parameters interface is used by test cases to adapt the parameters in order\n- * to test specific features more easily. Test cases should always restore the previous\n- * values after finalization.\n- */\n-\n-class CModifiableParams {\n-public:\n-    //! Published setters to allow changing values in unit test cases\n-    virtual void setSubsidyHalvingInterval(int anSubsidyHalvingInterval) =0;\n-    virtual void setEnforceBlockUpgradeMajority(int anEnforceBlockUpgradeMajority)=0;\n-    virtual void setRejectBlockOutdatedMajority(int anRejectBlockOutdatedMajority)=0;\n-    virtual void setToCheckBlockUpgradeMajority(int anToCheckBlockUpgradeMajority)=0;\n-    virtual void setDefaultCheckMemPool(bool aDefaultCheckMemPool)=0;\n-    virtual void setAllowMinDifficultyBlocks(bool aAllowMinDifficultyBlocks)=0;\n-    virtual void setSkipProofOfWorkCheck(bool aSkipProofOfWorkCheck)=0;\n-};\n-\n-\n /**\n- * Return the currently selected parameters. This won't change after app startup\n- * outside of the unit tests.\n+ * Return the currently selected parameters. This won't change after app\n+ * startup, except for unit tests.\n  */\n const CChainParams &Params();\n \n /** Return parameters for the given network. */\n CChainParams &Params(CBaseChainParams::Network network);\n \n-/** Get modifiable network parameters (UNITTEST only) */\n-CModifiableParams *ModifiableParams();\n-\n /** Sets the params returned by Params() to those for the given network. */\n void SelectParams(CBaseChainParams::Network network);\n "
      },
      {
        "sha": "7d82d689ec45f9f96bcae66da6f196db4ee8323b",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -82,9 +82,6 @@ void SelectBaseParams(CBaseChainParams::Network network)\n     case CBaseChainParams::REGTEST:\n         pCurrentBaseParams = &regTestParams;\n         break;\n-    case CBaseChainParams::UNITTEST:\n-        pCurrentBaseParams = &unitTestParams;\n-        break;\n     default:\n         assert(false && \"Unimplemented network\");\n         return;"
      },
      {
        "sha": "4369d0aef7e3c7dae75062c37fb6e33c899d20fe",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -19,7 +19,6 @@ class CBaseChainParams\n         MAIN,\n         TESTNET,\n         REGTEST,\n-        UNITTEST,\n \n         MAX_NETWORK_TYPES\n     };\n@@ -35,8 +34,8 @@ class CBaseChainParams\n };\n \n /**\n- * Return the currently selected parameters. This won't change after app startup\n- * outside of the unit tests.\n+ * Return the currently selected parameters. This won't change after app\n+ * startup, except for unit tests.\n  */\n const CBaseChainParams& BaseParams();\n "
      },
      {
        "sha": "20244861399bf182994c7d24b30cad274b084bef",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 22,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -15,30 +15,26 @@\n namespace Checkpoints {\n \n     /**\n-     * How many times we expect transactions after the last checkpoint to\n-     * be slower. This number is a compromise, as it can't be accurate for\n-     * every system. When reindexing from a fast disk with a slow CPU, it\n+     * How many times slower we expect checking transactions after the last\n+     * checkpoint to be (from checking signatures, which is skipped up to the\n+     * last checkpoint). This number is a compromise, as it can't be accurate\n+     * for every system. When reindexing from a fast disk with a slow CPU, it\n      * can be up to 20, while when downloading from a slow network with a\n      * fast multicore CPU, it won't be much higher than 1.\n      */\n     static const double SIGCHECK_VERIFICATION_FACTOR = 5.0;\n \n-    bool fEnabled = true;\n-\n-    bool CheckBlock(int nHeight, const uint256& hash)\n+    bool CheckBlock(const CCheckpointData& data, int nHeight, const uint256& hash)\n     {\n-        if (!fEnabled)\n-            return true;\n-\n-        const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n+        const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n         MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n         if (i == checkpoints.end()) return true;\n         return hash == i->second;\n     }\n \n     //! Guess how far we are in the verification process at the given block index\n-    double GuessVerificationProgress(CBlockIndex *pindex, bool fSigchecks) {\n+    double GuessVerificationProgress(const CCheckpointData& data, CBlockIndex *pindex, bool fSigchecks) {\n         if (pindex==NULL)\n             return 0.0;\n \n@@ -50,8 +46,6 @@ namespace Checkpoints {\n         // Work is defined as: 1.0 per transaction before the last checkpoint, and\n         // fSigcheckVerificationFactor per transaction after.\n \n-        const CCheckpointData &data = Params().Checkpoints();\n-\n         if (pindex->nChainTx <= data.nTransactionsLastCheckpoint) {\n             double nCheapBefore = pindex->nChainTx;\n             double nCheapAfter = data.nTransactionsLastCheckpoint - pindex->nChainTx;\n@@ -69,22 +63,19 @@ namespace Checkpoints {\n         return fWorkBefore / (fWorkBefore + fWorkAfter);\n     }\n \n-    int GetTotalBlocksEstimate()\n+    int GetTotalBlocksEstimate(const CCheckpointData& data)\n     {\n-        if (!fEnabled)\n-            return 0;\n+        const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n-        const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n+        if (checkpoints.empty())\n+            return 0;\n \n         return checkpoints.rbegin()->first;\n     }\n \n-    CBlockIndex* GetLastCheckpoint()\n+    CBlockIndex* GetLastCheckpoint(const CCheckpointData& data)\n     {\n-        if (!fEnabled)\n-            return NULL;\n-\n-        const MapCheckpoints& checkpoints = *Params().Checkpoints().mapCheckpoints;\n+        const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n         BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)\n         {"
      },
      {
        "sha": "a720f096c0911ee2ec089917480de97a00d414d6",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 6,
        "deletions": 8,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -11,7 +11,7 @@\n \n class CBlockIndex;\n \n-/** \n+/**\n  * Block-chain checkpoints are compiled-in sanity checks.\n  * They are updated every release or three.\n  */\n@@ -20,24 +20,22 @@ namespace Checkpoints\n typedef std::map<int, uint256> MapCheckpoints;\n \n struct CCheckpointData {\n-    const MapCheckpoints *mapCheckpoints;\n+    MapCheckpoints mapCheckpoints;\n     int64_t nTimeLastCheckpoint;\n     int64_t nTransactionsLastCheckpoint;\n     double fTransactionsPerDay;\n };\n \n //! Returns true if block passes checkpoint checks\n-bool CheckBlock(int nHeight, const uint256& hash);\n+bool CheckBlock(const CCheckpointData& data, int nHeight, const uint256& hash);\n \n //! Return conservative estimate of total number of blocks, 0 if unknown\n-int GetTotalBlocksEstimate();\n+int GetTotalBlocksEstimate(const CCheckpointData& data);\n \n //! Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n-CBlockIndex* GetLastCheckpoint();\n+CBlockIndex* GetLastCheckpoint(const CCheckpointData& data);\n \n-double GuessVerificationProgress(CBlockIndex* pindex, bool fSigchecks = true);\n-\n-extern bool fEnabled;\n+double GuessVerificationProgress(const CCheckpointData& data, CBlockIndex* pindex, bool fSigchecks = true);\n \n } //namespace Checkpoints\n "
      },
      {
        "sha": "20ba25bb419dd3ecdd6c3316e02f128b0d529889",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -54,7 +54,7 @@ class CCheckQueue\n \n     /**\n      * Number of verifications that haven't completed yet.\n-     * This includes elements that are not anymore in queue, but still in\n+     * This includes elements that are no longer queued, but still in the\n      * worker's own batches.\n      */\n     unsigned int nTodo;\n@@ -81,7 +81,7 @@ class CCheckQueue\n                     fAllOk &= fOk;\n                     nTodo -= nNow;\n                     if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master he can exit and return the result\n+                        // We processed the last element; inform the master it can exit and return the result\n                         condMaster.notify_one();\n                 } else {\n                     // first iteration\n@@ -136,7 +136,7 @@ class CCheckQueue\n         Loop();\n     }\n \n-    //! Wait until execution finishes, and return whether all evaluations where successful.\n+    //! Wait until execution finishes, and return whether all evaluations were successful.\n     bool Wait()\n     {\n         return Loop(true);\n@@ -161,7 +161,12 @@ class CCheckQueue\n     {\n     }\n \n-    friend class CCheckQueueControl<T>;\n+    bool IsIdle()\n+    {\n+        boost::unique_lock<boost::mutex> lock(mutex);\n+        return (nTotal == nIdle && nTodo == 0 && fAllOk == true);\n+    }\n+\n };\n \n /** \n@@ -180,9 +185,8 @@ class CCheckQueueControl\n     {\n         // passed queue is supposed to be unused, or NULL\n         if (pqueue != NULL) {\n-            assert(pqueue->nTotal == pqueue->nIdle);\n-            assert(pqueue->nTodo == 0);\n-            assert(pqueue->fAllOk == true);\n+            bool isIdle = pqueue->IsIdle();\n+            assert(isIdle);\n         }\n     }\n "
      },
      {
        "sha": "a41d5a310d6b9cb9b9e0537c2b2c3a4f96fbd866",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 3,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"coins.h\"\n \n+#include \"memusage.h\"\n #include \"random.h\"\n \n #include <assert.h>\n@@ -57,13 +58,17 @@ bool CCoinsViewBacked::GetStats(CCoinsStats &stats) const { return base->GetStat\n \n CCoinsKeyHasher::CCoinsKeyHasher() : salt(GetRandHash()) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false) { }\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), cachedCoinsUsage(0) { }\n \n CCoinsViewCache::~CCoinsViewCache()\n {\n     assert(!hasModifier);\n }\n \n+size_t CCoinsViewCache::DynamicMemoryUsage() const {\n+    return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n+}\n+\n CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n     CCoinsMap::iterator it = cacheCoins.find(txid);\n     if (it != cacheCoins.end())\n@@ -78,6 +83,7 @@ CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n     }\n+    cachedCoinsUsage += memusage::DynamicUsage(ret->second.coins);\n     return ret;\n }\n \n@@ -93,6 +99,7 @@ bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n     assert(!hasModifier);\n     std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n+    size_t cachedCoinUsage = 0;\n     if (ret.second) {\n         if (!base->GetCoins(txid, ret.first->second.coins)) {\n             // The parent view does not have this entry; mark it as fresh.\n@@ -102,10 +109,12 @@ CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n             // The parent view only has a pruned entry for this; mark it as fresh.\n             ret.first->second.flags = CCoinsCacheEntry::FRESH;\n         }\n+    } else {\n+        cachedCoinUsage = memusage::DynamicUsage(ret.first->second.coins);\n     }\n     // Assume that whenever ModifyCoins is called, the entry will be modified.\n     ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first);\n+    return CCoinsModifier(*this, ret.first, cachedCoinUsage);\n }\n \n const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n@@ -150,17 +159,21 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                     assert(it->second.flags & CCoinsCacheEntry::FRESH);\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n                     entry.coins.swap(it->second.coins);\n+                    cachedCoinsUsage += memusage::DynamicUsage(entry.coins);\n                     entry.flags = CCoinsCacheEntry::DIRTY | CCoinsCacheEntry::FRESH;\n                 }\n             } else {\n                 if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n                     // The grandparent does not have an entry, and the child is\n                     // modified and being pruned. This means we can just delete\n                     // it from the parent.\n+                    cachedCoinsUsage -= memusage::DynamicUsage(itUs->second.coins);\n                     cacheCoins.erase(itUs);\n                 } else {\n                     // A normal modification.\n+                    cachedCoinsUsage -= memusage::DynamicUsage(itUs->second.coins);\n                     itUs->second.coins.swap(it->second.coins);\n+                    cachedCoinsUsage += memusage::DynamicUsage(itUs->second.coins);\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n                 }\n             }\n@@ -175,6 +188,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    cachedCoinsUsage = 0;\n     return fOk;\n }\n \n@@ -232,7 +246,7 @@ double CCoinsViewCache::GetPriority(const CTransaction &tx, int nHeight) const\n     return tx.ComputePriority(dResult);\n }\n \n-CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_) : cache(cache_), it(it_) {\n+CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage) : cache(cache_), it(it_), cachedCoinUsage(usage) {\n     assert(!cache.hasModifier);\n     cache.hasModifier = true;\n }\n@@ -242,7 +256,11 @@ CCoinsModifier::~CCoinsModifier()\n     assert(cache.hasModifier);\n     cache.hasModifier = false;\n     it->second.coins.Cleanup();\n+    cache.cachedCoinsUsage -= cachedCoinUsage; // Subtract the old usage\n     if ((it->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n         cache.cacheCoins.erase(it);\n+    } else {\n+        // If the coin still exists after the modification, add the new usage\n+        cache.cachedCoinsUsage += memusage::DynamicUsage(it->second.coins);\n     }\n }"
      },
      {
        "sha": "a4671645df5db0e770b066481fb0d9d7e235a52c",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_COINS_H\n \n #include \"compressor.h\"\n+#include \"memusage.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n@@ -252,6 +253,15 @@ class CCoins\n                 return false;\n         return true;\n     }\n+\n+    size_t DynamicMemoryUsage() const {\n+        size_t ret = memusage::DynamicUsage(vout);\n+        BOOST_FOREACH(const CTxOut &out, vout) {\n+            const std::vector<unsigned char> *script = &out.scriptPubKey;\n+            ret += memusage::DynamicUsage(*script);\n+        }\n+        return ret;\n+    }\n };\n \n class CCoinsKeyHasher\n@@ -356,7 +366,8 @@ class CCoinsModifier\n private:\n     CCoinsViewCache& cache;\n     CCoinsMap::iterator it;\n-    CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_);\n+    size_t cachedCoinUsage; // Cached memory usage of the CCoins object before modification\n+    CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage);\n \n public:\n     CCoins* operator->() { return &it->second.coins; }\n@@ -372,13 +383,17 @@ class CCoinsViewCache : public CCoinsViewBacked\n     /* Whether this cache has an active modifier. */\n     bool hasModifier;\n \n+\n     /**\n      * Make mutable so that we can \"fill the cache\" even from Get-methods\n      * declared as \"const\".  \n      */\n     mutable uint256 hashBlock;\n     mutable CCoinsMap cacheCoins;\n \n+    /* Cached dynamic memory usage for the inner CCoins objects. */\n+    mutable size_t cachedCoinsUsage;\n+\n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n     ~CCoinsViewCache();\n@@ -414,6 +429,9 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Calculate the size of the cache (in number of transactions)\n     unsigned int GetCacheSize() const;\n \n+    //! Calculate the size of the cache (in bytes)\n+    size_t DynamicMemoryUsage() const;\n+\n     /** \n      * Amount of bitcoins coming in to a transaction\n      * Note that lightweight clients may not know anything besides the hash of previous transactions,"
      },
      {
        "sha": "899220bdc549053927edf86a29bc415310fb5eba",
        "filename": "src/compat/byteswap.h",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/compat/byteswap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/compat/byteswap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/byteswap.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,47 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COMPAT_BYTESWAP_H\n+#define BITCOIN_COMPAT_BYTESWAP_H\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include <stdint.h>\n+\n+#if defined(HAVE_BYTESWAP_H)\n+#include <byteswap.h>\n+#endif\n+\n+#if HAVE_DECL_BSWAP_16 == 0\n+inline uint16_t bswap_16(uint16_t x)\n+{\n+    return (x >> 8) | ((x & 0x00ff) << 8);\n+}\n+#endif // HAVE_DECL_BSWAP16\n+\n+#if HAVE_DECL_BSWAP_32 == 0\n+inline uint32_t bswap_32(uint32_t x)\n+{\n+    return (((x & 0xff000000U) >> 24) | ((x & 0x00ff0000U) >>  8) |\n+            ((x & 0x0000ff00U) <<  8) | ((x & 0x000000ffU) << 24));\n+}\n+#endif // HAVE_DECL_BSWAP32\n+\n+#if HAVE_DECL_BSWAP_64 == 0\n+inline uint64_t bswap_64(uint64_t x)\n+{\n+     return (((x & 0xff00000000000000ull) >> 56)\n+          | ((x & 0x00ff000000000000ull) >> 40)\n+          | ((x & 0x0000ff0000000000ull) >> 24)\n+          | ((x & 0x000000ff00000000ull) >> 8)\n+          | ((x & 0x00000000ff000000ull) << 8)\n+          | ((x & 0x0000000000ff0000ull) << 24)\n+          | ((x & 0x000000000000ff00ull) << 40)\n+          | ((x & 0x00000000000000ffull) << 56));\n+}\n+#endif // HAVE_DECL_BSWAP64\n+\n+#endif // BITCOIN_COMPAT_BYTESWAP_H"
      },
      {
        "sha": "4d041d655411738476ecbc1e5c96e845452d8b8f",
        "filename": "src/compat/endian.h",
        "status": "added",
        "additions": 194,
        "deletions": 0,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/compat/endian.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/compat/endian.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/endian.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,194 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COMPAT_ENDIAN_H\n+#define BITCOIN_COMPAT_ENDIAN_H\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include <stdint.h>\n+\n+#include \"compat/byteswap.h\"\n+\n+#if defined(HAVE_ENDIAN_H)\n+#include <endian.h>\n+#endif\n+\n+#if defined(WORDS_BIGENDIAN)\n+\n+#if HAVE_DECL_HTOBE16 == 0\n+inline uint16_t htobe16(uint16_t host_16bits)\n+{\n+    return host_16bits;\n+}\n+#endif // HAVE_DECL_HTOBE16\n+\n+#if HAVE_DECL_HTOLE16 == 0\n+inline uint16_t htole16(uint16_t host_16bits)\n+{\n+    return bswap_16(host_16bits);\n+}\n+#endif // HAVE_DECL_HTOLE16\n+\n+#if HAVE_DECL_BE16TOH == 0\n+inline uint16_t be16toh(uint16_t big_endian_16bits)\n+{\n+    return big_endian_16bits;\n+}\n+#endif // HAVE_DECL_BE16TOH\n+\n+#if HAVE_DECL_LE16TOH == 0\n+inline uint16_t le16toh(uint16_t little_endian_16bits)\n+{\n+    return bswap_16(little_endian_16bits);\n+}\n+#endif // HAVE_DECL_LE16TOH\n+\n+#if HAVE_DECL_HTOBE32 == 0\n+inline uint32_t htobe32(uint32_t host_32bits)\n+{\n+    return host_32bits;\n+}\n+#endif // HAVE_DECL_HTOBE32\n+\n+#if HAVE_DECL_HTOLE32 == 0\n+inline uint32_t htole32(uint32_t host_32bits)\n+{\n+    return bswap_32(host_32bits);\n+}\n+#endif // HAVE_DECL_HTOLE32\n+\n+#if HAVE_DECL_BE32TOH == 0\n+inline uint32_t be32toh(uint32_t big_endian_32bits)\n+{\n+    return big_endian_32bits;\n+}\n+#endif // HAVE_DECL_BE32TOH\n+\n+#if HAVE_DECL_LE32TOH == 0\n+inline uint32_t le32toh(uint32_t little_endian_32bits)\n+{\n+    return bswap_32(little_endian_32bits);\n+}\n+#endif // HAVE_DECL_LE32TOH\n+\n+#if HAVE_DECL_HTOBE64 == 0\n+inline uint64_t htobe64(uint64_t host_64bits)\n+{\n+    return host_64bits;\n+}\n+#endif // HAVE_DECL_HTOBE64\n+\n+#if HAVE_DECL_HTOLE64 == 0\n+inline uint64_t htole64(uint64_t host_64bits)\n+{\n+    return bswap_64(host_64bits);\n+}\n+#endif // HAVE_DECL_HTOLE64\n+\n+#if HAVE_DECL_BE64TOH == 0\n+inline uint64_t be64toh(uint64_t big_endian_64bits)\n+{\n+    return big_endian_64bits;\n+}\n+#endif // HAVE_DECL_BE64TOH\n+\n+#if HAVE_DECL_LE64TOH == 0\n+inline uint64_t le64toh(uint64_t little_endian_64bits)\n+{\n+    return bswap_64(little_endian_64bits);\n+}\n+#endif // HAVE_DECL_LE64TOH\n+\n+#else // WORDS_BIGENDIAN\n+\n+#if HAVE_DECL_HTOBE16 == 0\n+inline uint16_t htobe16(uint16_t host_16bits)\n+{\n+    return bswap_16(host_16bits);\n+}\n+#endif // HAVE_DECL_HTOBE16\n+\n+#if HAVE_DECL_HTOLE16 == 0\n+inline uint16_t htole16(uint16_t host_16bits)\n+{\n+    return host_16bits;\n+}\n+#endif // HAVE_DECL_HTOLE16\n+\n+#if HAVE_DECL_BE16TOH == 0\n+inline uint16_t be16toh(uint16_t big_endian_16bits)\n+{\n+    return bswap_16(big_endian_16bits);\n+}\n+#endif // HAVE_DECL_BE16TOH\n+\n+#if HAVE_DECL_LE16TOH == 0\n+inline uint16_t le16toh(uint16_t little_endian_16bits)\n+{\n+    return little_endian_16bits;\n+}\n+#endif // HAVE_DECL_LE16TOH\n+\n+#if HAVE_DECL_HTOBE32 == 0\n+inline uint32_t htobe32(uint32_t host_32bits)\n+{\n+    return bswap_32(host_32bits);\n+}\n+#endif // HAVE_DECL_HTOBE32\n+\n+#if HAVE_DECL_HTOLE32 == 0\n+inline uint32_t htole32(uint32_t host_32bits)\n+{\n+    return host_32bits;\n+}\n+#endif // HAVE_DECL_HTOLE32\n+\n+#if HAVE_DECL_BE32TOH == 0\n+inline uint32_t be32toh(uint32_t big_endian_32bits)\n+{\n+    return bswap_32(big_endian_32bits);\n+}\n+#endif // HAVE_DECL_BE32TOH\n+\n+#if HAVE_DECL_LE32TOH == 0\n+inline uint32_t le32toh(uint32_t little_endian_32bits)\n+{\n+    return little_endian_32bits;\n+}\n+#endif // HAVE_DECL_LE32TOH\n+\n+#if HAVE_DECL_HTOBE64 == 0\n+inline uint64_t htobe64(uint64_t host_64bits)\n+{\n+    return bswap_64(host_64bits);\n+}\n+#endif // HAVE_DECL_HTOBE64\n+\n+#if HAVE_DECL_HTOLE64 == 0\n+inline uint64_t htole64(uint64_t host_64bits)\n+{\n+    return host_64bits;\n+}\n+#endif // HAVE_DECL_HTOLE64\n+\n+#if HAVE_DECL_BE64TOH == 0\n+inline uint64_t be64toh(uint64_t big_endian_64bits)\n+{\n+    return bswap_64(big_endian_64bits);\n+}\n+#endif // HAVE_DECL_BE64TOH\n+\n+#if HAVE_DECL_LE64TOH == 0\n+inline uint64_t le64toh(uint64_t little_endian_64bits)\n+{\n+    return little_endian_64bits;\n+}\n+#endif // HAVE_DECL_LE64TOH\n+\n+#endif // WORDS_BIGENDIAN\n+\n+#endif // BITCOIN_COMPAT_ENDIAN_H"
      },
      {
        "sha": "4f2771e57a086ca983cec57b42376c003d480da8",
        "filename": "src/compat/glibcxx_compat.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 94,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/src/compat/glibcxx_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/src/compat/glibcxx_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_compat.cpp?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1,94 +0,0 @@\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <cstddef>\n-#include <istream>\n-#include <stdexcept>\n-#include <typeinfo>\n-\n-#ifndef _GLIBCXX_USE_NOEXCEPT\n-#define _GLIBCXX_USE_NOEXCEPT throw()\n-#endif\n-\n-namespace std\n-{\n-const char* bad_exception::what() const throw()\n-{\n-    return \"std::bad_exception\";\n-}\n-\n-const char* bad_cast::what() const throw()\n-{\n-    return \"std::bad_cast\";\n-}\n-\n-const char* bad_alloc::what() const throw()\n-{\n-    return \"std::bad_alloc\";\n-}\n-\n-namespace __detail\n-{\n-struct _List_node_base {\n-    void _M_hook(std::__detail::_List_node_base* const __position) throw() __attribute__((used))\n-    {\n-        _M_next = __position;\n-        _M_prev = __position->_M_prev;\n-        __position->_M_prev->_M_next = this;\n-        __position->_M_prev = this;\n-    }\n-\n-    void _M_unhook() __attribute__((used))\n-    {\n-        _List_node_base* const __next_node = _M_next;\n-        _List_node_base* const __prev_node = _M_prev;\n-        __prev_node->_M_next = __next_node;\n-        __next_node->_M_prev = __prev_node;\n-    }\n-\n-    _List_node_base* _M_next;\n-    _List_node_base* _M_prev;\n-};\n-} // namespace detail\n-\n-template ostream& ostream::_M_insert(bool);\n-template ostream& ostream::_M_insert(long);\n-template ostream& ostream::_M_insert(double);\n-template ostream& ostream::_M_insert(unsigned long);\n-template ostream& ostream::_M_insert(const void*);\n-template ostream& __ostream_insert(ostream&, const char*, streamsize);\n-template istream& istream::_M_extract(long&);\n-template istream& istream::_M_extract(unsigned short&);\n-\n-out_of_range::~out_of_range() _GLIBCXX_USE_NOEXCEPT {}\n-\n-length_error::~length_error() _GLIBCXX_USE_NOEXCEPT {}\n-\n-// Used with permission.\n-// See: https://github.com/madlib/madlib/commit/c3db418c0d34d6813608f2137fef1012ce03043d\n-\n-void ctype<char>::_M_widen_init() const\n-{\n-    char __tmp[sizeof(_M_widen)];\n-    for (unsigned __i = 0; __i < sizeof(_M_widen); ++__i)\n-        __tmp[__i] = __i;\n-    do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);\n-\n-    _M_widen_ok = 1;\n-    // Set _M_widen_ok to 2 if memcpy can't be used.\n-    for (unsigned __i = 0; __i < sizeof(_M_widen); ++__i)\n-        if (__tmp[__i] != _M_widen[__i]) {\n-            _M_widen_ok = 2;\n-            break;\n-        }\n-}\n-\n-void __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__));\n-void __throw_out_of_range_fmt(const char* err, ...)\n-{\n-    // Safe and over-simplified version. Ignore the format and print it as-is.\n-    __throw_out_of_range(err);\n-}\n-\n-} // namespace std"
      },
      {
        "sha": "9c5b7d4ffb0ea7179ad0ff6a8c5b2b4688aef144",
        "filename": "src/consensus/consensus.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n+#define BITCOIN_CONSENSUS_CONSENSUS_H\n+\n+/** The maximum allowed size for a serialized block, in bytes (network rule) */\n+static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+/** The maximum allowed number of signature check operations in a block (network rule) */\n+static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n+/** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n+static const int COINBASE_MATURITY = 100;\n+/** Threshold for nLockTime: below this value it is interpreted as block number, otherwise as UNIX timestamp. */\n+static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n+\n+#endif // BITCOIN_CONSENSUS_CONSENSUS_H"
      },
      {
        "sha": "c480a1cce19832b2bf55b570a7bfaa3b9e088d6f",
        "filename": "src/consensus/params.h",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,31 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSENSUS_PARAMS_H\n+#define BITCOIN_CONSENSUS_PARAMS_H\n+\n+#include \"uint256.h\"\n+\n+namespace Consensus {\n+/**\n+ * Parameters that influence chain consensus.\n+ */\n+struct Params {\n+    uint256 hashGenesisBlock;\n+    int nSubsidyHalvingInterval;\n+    /** Used to check majorities for block version upgrade */\n+    int nMajorityEnforceBlockUpgrade;\n+    int nMajorityRejectBlockOutdated;\n+    int nMajorityWindow;\n+    /** Proof of work parameters */\n+    uint256 powLimit;\n+    bool fPowAllowMinDifficultyBlocks;\n+    int64_t nPowTargetSpacing;\n+    int64_t nPowTargetTimespan;\n+    int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }\n+};\n+} // namespace Consensus\n+\n+#endif // BITCOIN_CONSENSUS_PARAMS_H"
      },
      {
        "sha": "c92bec4fae5a8db11e3a0fc3adbf406ad1ed061f",
        "filename": "src/consensus/validation.h",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,80 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSENSUS_VALIDATION_H\n+#define BITCOIN_CONSENSUS_VALIDATION_H\n+\n+#include <string>\n+\n+/** \"reject\" message codes */\n+static const unsigned char REJECT_MALFORMED = 0x01;\n+static const unsigned char REJECT_INVALID = 0x10;\n+static const unsigned char REJECT_OBSOLETE = 0x11;\n+static const unsigned char REJECT_DUPLICATE = 0x12;\n+static const unsigned char REJECT_NONSTANDARD = 0x40;\n+static const unsigned char REJECT_DUST = 0x41;\n+static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n+static const unsigned char REJECT_CHECKPOINT = 0x43;\n+\n+/** Capture information about block/transaction validation */\n+class CValidationState {\n+private:\n+    enum mode_state {\n+        MODE_VALID,   //! everything ok\n+        MODE_INVALID, //! network rule violation (DoS value may be set)\n+        MODE_ERROR,   //! run-time error\n+    } mode;\n+    int nDoS;\n+    std::string strRejectReason;\n+    unsigned char chRejectCode;\n+    bool corruptionPossible;\n+public:\n+    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+    bool DoS(int level, bool ret = false,\n+             unsigned char chRejectCodeIn=0, std::string strRejectReasonIn=\"\",\n+             bool corruptionIn=false) {\n+        chRejectCode = chRejectCodeIn;\n+        strRejectReason = strRejectReasonIn;\n+        corruptionPossible = corruptionIn;\n+        if (mode == MODE_ERROR)\n+            return ret;\n+        nDoS += level;\n+        mode = MODE_INVALID;\n+        return ret;\n+    }\n+    bool Invalid(bool ret = false,\n+                 unsigned char _chRejectCode=0, std::string _strRejectReason=\"\") {\n+        return DoS(0, ret, _chRejectCode, _strRejectReason);\n+    }\n+    bool Error(std::string strRejectReasonIn=\"\") {\n+        if (mode == MODE_VALID)\n+            strRejectReason = strRejectReasonIn;\n+        mode = MODE_ERROR;\n+        return false;\n+    }\n+    bool IsValid() const {\n+        return mode == MODE_VALID;\n+    }\n+    bool IsInvalid() const {\n+        return mode == MODE_INVALID;\n+    }\n+    bool IsError() const {\n+        return mode == MODE_ERROR;\n+    }\n+    bool IsInvalid(int &nDoSOut) const {\n+        if (IsInvalid()) {\n+            nDoSOut = nDoS;\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool CorruptionPossible() const {\n+        return corruptionPossible;\n+    }\n+    unsigned char GetRejectCode() const { return chRejectCode; }\n+    std::string GetRejectReason() const { return strRejectReason; }\n+};\n+\n+#endif // BITCOIN_CONSENSUS_VALIDATION_H"
      },
      {
        "sha": "580c72f5a6480f1e884120d78b51fb628fe515dc",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 11,
        "deletions": 65,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -11,110 +11,56 @@\n \n #include <stdint.h>\n \n-#if defined(HAVE_ENDIAN_H)\n-#include <endian.h>\n-#endif\n+#include \"compat/endian.h\"\n+\n+uint16_t static inline ReadLE16(const unsigned char* ptr)\n+{\n+    return le16toh(*((uint16_t*)ptr));\n+}\n \n uint32_t static inline ReadLE32(const unsigned char* ptr)\n {\n-#if HAVE_DECL_LE32TOH == 1\n     return le32toh(*((uint32_t*)ptr));\n-#elif !defined(WORDS_BIGENDIAN)\n-    return *((uint32_t*)ptr);\n-#else\n-    return ((uint32_t)ptr[3] << 24 | (uint32_t)ptr[2] << 16 | (uint32_t)ptr[1] << 8 | (uint32_t)ptr[0]);\n-#endif\n }\n \n uint64_t static inline ReadLE64(const unsigned char* ptr)\n {\n-#if HAVE_DECL_LE64TOH == 1\n     return le64toh(*((uint64_t*)ptr));\n-#elif !defined(WORDS_BIGENDIAN)\n-    return *((uint64_t*)ptr);\n-#else\n-    return ((uint64_t)ptr[7] << 56 | (uint64_t)ptr[6] << 48 | (uint64_t)ptr[5] << 40 | (uint64_t)ptr[4] << 32 |\n-            (uint64_t)ptr[3] << 24 | (uint64_t)ptr[2] << 16 | (uint64_t)ptr[1] << 8 | (uint64_t)ptr[0]);\n-#endif\n+}\n+\n+void static inline WriteLE16(unsigned char* ptr, uint16_t x)\n+{\n+    *((uint16_t*)ptr) = htole16(x);\n }\n \n void static inline WriteLE32(unsigned char* ptr, uint32_t x)\n {\n-#if HAVE_DECL_HTOLE32 == 1\n     *((uint32_t*)ptr) = htole32(x);\n-#elif !defined(WORDS_BIGENDIAN)\n-    *((uint32_t*)ptr) = x;\n-#else\n-    ptr[3] = x >> 24;\n-    ptr[2] = x >> 16;\n-    ptr[1] = x >> 8;\n-    ptr[0] = x;\n-#endif\n }\n \n void static inline WriteLE64(unsigned char* ptr, uint64_t x)\n {\n-#if HAVE_DECL_HTOLE64 == 1\n     *((uint64_t*)ptr) = htole64(x);\n-#elif !defined(WORDS_BIGENDIAN)\n-    *((uint64_t*)ptr) = x;\n-#else\n-    ptr[7] = x >> 56;\n-    ptr[6] = x >> 48;\n-    ptr[5] = x >> 40;\n-    ptr[4] = x >> 32;\n-    ptr[3] = x >> 24;\n-    ptr[2] = x >> 16;\n-    ptr[1] = x >> 8;\n-    ptr[0] = x;\n-#endif\n }\n \n uint32_t static inline ReadBE32(const unsigned char* ptr)\n {\n-#if HAVE_DECL_BE32TOH == 1\n     return be32toh(*((uint32_t*)ptr));\n-#else\n-    return ((uint32_t)ptr[0] << 24 | (uint32_t)ptr[1] << 16 | (uint32_t)ptr[2] << 8 | (uint32_t)ptr[3]);\n-#endif\n }\n \n uint64_t static inline ReadBE64(const unsigned char* ptr)\n {\n-#if HAVE_DECL_BE64TOH == 1\n     return be64toh(*((uint64_t*)ptr));\n-#else\n-    return ((uint64_t)ptr[0] << 56 | (uint64_t)ptr[1] << 48 | (uint64_t)ptr[2] << 40 | (uint64_t)ptr[3] << 32 |\n-            (uint64_t)ptr[4] << 24 | (uint64_t)ptr[5] << 16 | (uint64_t)ptr[6] << 8 | (uint64_t)ptr[7]);\n-#endif\n }\n \n void static inline WriteBE32(unsigned char* ptr, uint32_t x)\n {\n-#if HAVE_DECL_HTOBE32 == 1\n     *((uint32_t*)ptr) = htobe32(x);\n-#else\n-    ptr[0] = x >> 24;\n-    ptr[1] = x >> 16;\n-    ptr[2] = x >> 8;\n-    ptr[3] = x;\n-#endif\n }\n \n void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n {\n-#if HAVE_DECL_HTOBE64 == 1\n     *((uint64_t*)ptr) = htobe64(x);\n-#else\n-    ptr[0] = x >> 56;\n-    ptr[1] = x >> 48;\n-    ptr[2] = x >> 40;\n-    ptr[3] = x >> 32;\n-    ptr[4] = x >> 24;\n-    ptr[5] = x >> 16;\n-    ptr[6] = x >> 8;\n-    ptr[7] = x;\n-#endif\n }\n \n #endif // BITCOIN_CRYPTO_COMMON_H"
      },
      {
        "sha": "a8c971c3ba98d7ef8ddc99359a948b434470d52a",
        "filename": "src/crypto/rfc6979_hmac_sha256.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 47,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/src/crypto/rfc6979_hmac_sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/src/crypto/rfc6979_hmac_sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/rfc6979_hmac_sha256.cpp?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1,47 +0,0 @@\n-// Copyright (c) 2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"crypto/rfc6979_hmac_sha256.h\"\n-\n-#include <string.h>\n-\n-#include <algorithm>\n-\n-static const unsigned char zero[1] = {0x00};\n-static const unsigned char one[1] = {0x01};\n-\n-RFC6979_HMAC_SHA256::RFC6979_HMAC_SHA256(const unsigned char* key, size_t keylen, const unsigned char* msg, size_t msglen) : retry(false)\n-{\n-    memset(V, 0x01, sizeof(V));\n-    memset(K, 0x00, sizeof(K));\n-\n-    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Write(zero, sizeof(zero)).Write(key, keylen).Write(msg, msglen).Finalize(K);\n-    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n-    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Write(one, sizeof(one)).Write(key, keylen).Write(msg, msglen).Finalize(K);\n-    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n-}\n-\n-RFC6979_HMAC_SHA256::~RFC6979_HMAC_SHA256()\n-{\n-    memset(V, 0x01, sizeof(V));\n-    memset(K, 0x00, sizeof(K));\n-}\n-\n-void RFC6979_HMAC_SHA256::Generate(unsigned char* output, size_t outputlen)\n-{\n-    if (retry) {\n-        CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Write(zero, sizeof(zero)).Finalize(K);\n-        CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n-    }\n-\n-    while (outputlen > 0) {\n-        CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n-        size_t len = std::min(outputlen, sizeof(V));\n-        memcpy(output, V, len);\n-        output += len;\n-        outputlen -= len;\n-    }\n-\n-    retry = true;\n-}"
      },
      {
        "sha": "f3a54a5d1188929784f16737279dfc3119dacbb7",
        "filename": "src/crypto/rfc6979_hmac_sha256.h",
        "status": "removed",
        "additions": 0,
        "deletions": 36,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/src/crypto/rfc6979_hmac_sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6/src/crypto/rfc6979_hmac_sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/rfc6979_hmac_sha256.h?ref=b6acd4563d3b96b244e61b87b9f08c0eb61ecaa6",
        "patch": "@@ -1,36 +0,0 @@\n-// Copyright (c) 2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_RFC6979_HMAC_SHA256_H\n-#define BITCOIN_RFC6979_HMAC_SHA256_H\n-\n-#include \"crypto/hmac_sha256.h\"\n-\n-#include <stdint.h>\n-#include <stdlib.h>\n-\n-/** The RFC 6979 PRNG using HMAC-SHA256. */\n-class RFC6979_HMAC_SHA256\n-{\n-private:\n-    unsigned char V[CHMAC_SHA256::OUTPUT_SIZE];\n-    unsigned char K[CHMAC_SHA256::OUTPUT_SIZE];\n-    bool retry;\n-\n-public:\n-    /**\n-     * Construct a new RFC6979 PRNG, using the given key and message.\n-     * The message is assumed to be already hashed.\n-     */\n-    RFC6979_HMAC_SHA256(const unsigned char* key, size_t keylen, const unsigned char* msg, size_t msglen);\n-\n-    /**\n-     * Generate a byte array.\n-     */\n-    void Generate(unsigned char* output, size_t outputlen);\n-\n-    ~RFC6979_HMAC_SHA256();\n-};\n-\n-#endif // BITCOIN_RFC6979_HMAC_SHA256_H"
      },
      {
        "sha": "9711293e38695c69496f0c609c0f6b600798c54a",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -3,7 +3,10 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"hash.h\"\n+#include \"crypto/common.h\"\n #include \"crypto/hmac_sha512.h\"\n+#include \"pubkey.h\"\n+\n \n inline uint32_t ROTL32(uint32_t x, int8_t r)\n {\n@@ -23,10 +26,10 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n         //----------\n         // body\n-        const uint32_t* blocks = (const uint32_t*)(&vDataToHash[0] + nblocks * 4);\n+        const uint8_t* blocks = &vDataToHash[0] + nblocks * 4;\n \n         for (int i = -nblocks; i; i++) {\n-            uint32_t k1 = blocks[i];\n+            uint32_t k1 = ReadLE32(blocks + i*4);\n \n             k1 *= c1;\n             k1 = ROTL32(k1, 15);\n@@ -69,15 +72,12 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n     return h1;\n }\n \n-void BIP32Hash(const unsigned char chainCode[32], unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64])\n+void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64])\n {\n     unsigned char num[4];\n     num[0] = (nChild >> 24) & 0xFF;\n     num[1] = (nChild >> 16) & 0xFF;\n     num[2] = (nChild >>  8) & 0xFF;\n     num[3] = (nChild >>  0) & 0xFF;\n-    CHMAC_SHA512(chainCode, 32).Write(&header, 1)\n-                               .Write(data, 32)\n-                               .Write(num, 4)\n-                               .Finalize(output);\n+    CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }"
      },
      {
        "sha": "0771555623975cceaedf9eb4518f6b5e4a5e6833",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -14,6 +14,8 @@\n \n #include <vector>\n \n+typedef uint256 ChainCode;\n+\n /** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */\n class CHash256 {\n private:\n@@ -159,6 +161,6 @@ uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL\n \n unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\n \n-void BIP32Hash(const unsigned char chainCode[32], unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n+void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n \n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "f4136f09e9a75aeca88aa87e09975b1a597704b8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 331,
        "deletions": 200,
        "changes": 531,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -13,20 +13,22 @@\n #include \"amount.h\"\n #include \"checkpoints.h\"\n #include \"compat/sanity.h\"\n+#include \"consensus/validation.h\"\n #include \"key.h\"\n #include \"main.h\"\n #include \"miner.h\"\n #include \"net.h\"\n #include \"rpcserver.h\"\n #include \"script/standard.h\"\n+#include \"scheduler.h\"\n #include \"txdb.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n+#include \"validationinterface.h\"\n #ifdef ENABLE_WALLET\n-#include \"db.h\"\n-#include \"wallet.h\"\n-#include \"walletdb.h\"\n+#include \"wallet/wallet.h\"\n+#include \"wallet/walletdb.h\"\n #endif\n \n #include <stdint.h>\n@@ -38,7 +40,9 @@\n \n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/replace.hpp>\n+#include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n+#include <boost/function.hpp>\n #include <boost/interprocess/sync/file_lock.hpp>\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n@@ -52,7 +56,7 @@ bool fFeeEstimatesInitialized = false;\n \n #ifdef WIN32\n // Win32 LevelDB doesn't use filedescriptors, and the ones used for\n-// accessing block files, don't count towards to fd_set size limit\n+// accessing block files don't count towards the fd_set size limit\n // anyway.\n #define MIN_CORE_FILEDESCRIPTORS 0\n #else\n@@ -68,7 +72,7 @@ enum BindFlags {\n };\n \n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n-CClientUIInterface uiInterface;\n+CClientUIInterface uiInterface; // Declared but not defined in ui_interface.h\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -123,7 +127,7 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());\n             // Starting the shutdown sequence and returning false to the caller would be\n             // interpreted as 'entry not found' (as opposed to unable to read data), and\n-            // could lead to invalid interpration. Just exit immediately, as we can't\n+            // could lead to invalid interpretation. Just exit immediately, as we can't\n             // continue anyway, and all writes should be atomic.\n             abort();\n         }\n@@ -151,7 +155,7 @@ void Shutdown()\n     StopRPCThreads();\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n-        bitdb.Flush(false);\n+        pwalletMain->Flush(false);\n     GenerateBitcoins(false, NULL, 0);\n #endif\n     StopNode();\n@@ -184,16 +188,21 @@ void Shutdown()\n     }\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n-        bitdb.Flush(true);\n+        pwalletMain->Flush(true);\n #endif\n #ifndef WIN32\n-    boost::filesystem::remove(GetPidFile());\n+    try {\n+        boost::filesystem::remove(GetPidFile());\n+    } catch (const boost::filesystem::filesystem_error& e) {\n+        LogPrintf(\"%s: Unable to remove pidfile: %s\\n\", __func__, e.what());\n+    }\n #endif\n     UnregisterAllValidationInterfaces();\n #ifdef ENABLE_WALLET\n     delete pwalletMain;\n     pwalletMain = NULL;\n #endif\n+    ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n \n@@ -234,159 +243,196 @@ bool static Bind(const CService &addr, unsigned int flags) {\n     return true;\n }\n \n+void OnRPCStopped()\n+{\n+    cvBlockChange.notify_all();\n+    LogPrint(\"rpc\", \"RPC stopped.\\n\");\n+}\n+\n+void OnRPCPreCommand(const CRPCCommand& cmd)\n+{\n+    // Observe safe mode\n+    string strWarning = GetWarnings(\"rpc\");\n+    if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\", false) &&\n+        !cmd.okSafeMode)\n+        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, string(\"Safe mode: \") + strWarning);\n+}\n+\n std::string HelpMessage(HelpMessageMode mode)\n {\n+\n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n-    string strUsage = _(\"Options:\") + \"\\n\";\n-    strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-    strUsage += \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") + \"\\n\";\n-    strUsage += \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n-    strUsage += \"  -checkblocks=<n>       \" + strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), 288) + \"\\n\";\n-    strUsage += \"  -checklevel=<n>        \" + strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), 3) + \"\\n\";\n-    strUsage += \"  -conf=<file>           \" + strprintf(_(\"Specify configuration file (default: %s)\"), \"bitcoin.conf\") + \"\\n\";\n+    string strUsage = HelpMessageGroup(_(\"Options:\"));\n+    strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n+    strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"));\n+    strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n+    strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), 288));\n+    strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), 3));\n+    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), \"bitcoin.conf\"));\n     if (mode == HMM_BITCOIND)\n     {\n #if !defined(WIN32)\n-        strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n+        strUsage += HelpMessageOpt(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"));\n #endif\n     }\n-    strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-    strUsage += \"  -dbcache=<n>           \" + strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache) + \"\\n\";\n-    strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -maxorphantx=<n>       \" + strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS) + \"\\n\";\n-    strUsage += \"  -par=<n>               \" + strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"), -(int)boost::thread::hardware_concurrency(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS) + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n+    strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n+    strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+    strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n+        -(int)boost::thread::hardware_concurrency(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n #ifndef WIN32\n-    strUsage += \"  -pid=<file>            \" + strprintf(_(\"Specify pid file (default: %s)\"), \"bitcoind.pid\") + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-pid=<file>\", strprintf(_(\"Specify pid file (default: %s)\"), \"bitcoind.pid\"));\n #endif\n-    strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\"on startup\") + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by pruning (deleting) old blocks. This mode disables wallet support and is incompatible with -txindex. \"\n+            \"Warning: Reverting this setting requires re-downloading the entire blockchain. \"\n+            \"(default: 0 = disable pruning blocks, >%u = target size in MiB to use for block files)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n+    strUsage += HelpMessageOpt(\"-reindex\", _(\"Rebuild block chain index from current blk000??.dat files on startup\"));\n #if !defined(WIN32)\n-    strUsage += \"  -sysperms              \" + _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\") + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"));\n #endif\n-    strUsage += \"  -txindex               \" + strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), 0) + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"Connection options:\") + \"\\n\";\n-    strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\";\n-    strUsage += \"  -banscore=<n>          \" + strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), 100) + \"\\n\";\n-    strUsage += \"  -bantime=<n>           \" + strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), 86400) + \"\\n\";\n-    strUsage += \"  -bind=<addr>           \" + _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") + \"\\n\";\n-    strUsage += \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\";\n-    strUsage += \"  -discover              \" + _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\") + \"\\n\";\n-    strUsage += \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + _(\"(default: 1)\") + \"\\n\";\n-    strUsage += \"  -dnsseed               \" + _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect)\") + \"\\n\";\n-    strUsage += \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\";\n-    strUsage += \"  -forcednsseed          \" + strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), 0) + \"\\n\";\n-    strUsage += \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\";\n-    strUsage += \"  -maxconnections=<n>    \" + strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), 125) + \"\\n\";\n-    strUsage += \"  -maxreceivebuffer=<n>  \" + strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), 5000) + \"\\n\";\n-    strUsage += \"  -maxsendbuffer=<n>     \" + strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), 1000) + \"\\n\";\n-    strUsage += \"  -onion=<ip:port>       \" + strprintf(_(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\") + \"\\n\";\n-    strUsage += \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\") + \"\\n\";\n-    strUsage += \"  -permitbaremultisig    \" + strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), 1) + \"\\n\";\n-    strUsage += \"  -port=<port>           \" + strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), 8333, 18333) + \"\\n\";\n-    strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through SOCKS5 proxy\") + \"\\n\";\n-    strUsage += \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\";\n-    strUsage += \"  -timeout=<n>           \" + strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT) + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), 0));\n+\n+    strUsage += HelpMessageGroup(_(\"Connection options:\"));\n+    strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open\"));\n+    strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), 100));\n+    strUsage += HelpMessageOpt(\"-bantime=<n>\", strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), 86400));\n+    strUsage += HelpMessageOpt(\"-bind=<addr>\", _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"));\n+    strUsage += HelpMessageOpt(\"-connect=<ip>\", _(\"Connect only to the specified node(s)\"));\n+    strUsage += HelpMessageOpt(\"-discover\", _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"));\n+    strUsage += HelpMessageOpt(\"-dns\", _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + _(\"(default: 1)\"));\n+    strUsage += HelpMessageOpt(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect)\"));\n+    strUsage += HelpMessageOpt(\"-externalip=<ip>\", _(\"Specify your own public address\"));\n+    strUsage += HelpMessageOpt(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n+    strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), 125));\n+    strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), 5000));\n+    strUsage += HelpMessageOpt(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), 1000));\n+    strUsage += HelpMessageOpt(\"-onion=<ip:port>\", strprintf(_(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\"));\n+    strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n+    strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), 1));\n+    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), 8333, 18333));\n+    strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n+    strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), 1));\n+    strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n+    strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n #ifdef USE_UPNP\n #if USE_UPNP\n-    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening)\"));\n #else\n-    strUsage += \"  -upnp                  \" + strprintf(_(\"Use UPnP to map the listening port (default: %u)\"), 0) + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-upnp\", strprintf(_(\"Use UPnP to map the listening port (default: %u)\"), 0));\n #endif\n #endif\n-    strUsage += \"  -whitebind=<addr>      \" + _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\") + \"\\n\";\n-    strUsage += \"  -whitelist=<netmask>   \" + _(\"Whitelist peers connecting from the given netmask or IP address. Can be specified multiple times.\") + \"\\n\";\n-    strUsage += \"                         \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\") + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"));\n+    strUsage += HelpMessageOpt(\"-whitelist=<netmask>\", _(\"Whitelist peers connecting from the given netmask or IP address. Can be specified multiple times.\") +\n+        \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n+        \n \n #ifdef ENABLE_WALLET\n-    strUsage += \"\\n\" + _(\"Wallet options:\") + \"\\n\";\n-    strUsage += \"  -disablewallet         \" + _(\"Do not load the wallet and disable wallet RPC calls\") + \"\\n\";\n-    strUsage += \"  -keypool=<n>           \" + strprintf(_(\"Set key pool size to <n> (default: %u)\"), 100) + \"\\n\";\n+    strUsage += HelpMessageGroup(_(\"Wallet options:\"));\n+    strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n+    strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), 100));\n     if (GetBoolArg(\"-help-debug\", false))\n-        strUsage += \"  -mintxfee=<amt>        \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"), FormatMoney(CWallet::minTxFee.GetFeePerK())) + \"\\n\";\n-    strUsage += \"  -paytxfee=<amt>        \" + strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())) + \"\\n\";\n-    strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -sendfreetransactions  \" + strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0) + \"\\n\";\n-    strUsage += \"  -spendzeroconfchange   \" + strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1) + \"\\n\";\n-    strUsage += \"  -txconfirmtarget=<n>   \" + strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), 1) + \"\\n\";\n-    strUsage += \"  -maxtxfee=<amt>        \" + strprintf(_(\"Maximum total fees to use in a single wallet transaction, setting too low may abort large transactions (default: %s)\"), FormatMoney(maxTxFee)) + \"\\n\";\n-    strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\") + \"\\n\";\n-    strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n-    strUsage += \"  -zapwallettxes=<mode>  \" + _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") + \"\\n\";\n-    strUsage += \"                         \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\") + \"\\n\";\n+        strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"),\n+            FormatMoney(CWallet::minTxFee.GetFeePerK())));\n+    strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())));\n+    strUsage += HelpMessageOpt(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-sendfreetransactions\", strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1));\n+    strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n+    strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees to use in a single wallet transaction; setting this too low may abort large transactions (default: %s)\"),\n+        FormatMoney(maxTxFee)));\n+    strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-wallet=<file>\", _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\"));\n+    strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), true));\n+    strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n+    strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n+        \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"));\n+                    \n #endif\n \n-    strUsage += \"\\n\" + _(\"Debugging/Testing options:\") + \"\\n\";\n+    strUsage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n-        strUsage += \"  -checkpoints           \" + strprintf(_(\"Only accept block chain matching built-in checkpoints (default: %u)\"), 1) + \"\\n\";\n-        strUsage += \"  -dblogsize=<n>         \" + strprintf(_(\"Flush database activity from memory pool to disk log every <n> megabytes (default: %u)\"), 100) + \"\\n\";\n-        strUsage += \"  -disablesafemode       \" + strprintf(_(\"Disable safemode, override a real safe mode event (default: %u)\"), 0) + \"\\n\";\n-        strUsage += \"  -testsafemode          \" + strprintf(_(\"Force safe mode (default: %u)\"), 0) + \"\\n\";\n-        strUsage += \"  -dropmessagestest=<n>  \" + _(\"Randomly drop 1 of every <n> network messages\") + \"\\n\";\n-        strUsage += \"  -fuzzmessagestest=<n>  \" + _(\"Randomly fuzz 1 of every <n> network messages\") + \"\\n\";\n-        strUsage += \"  -flushwallet           \" + strprintf(_(\"Run a thread to flush wallet periodically (default: %u)\"), 1) + \"\\n\";\n-        strUsage += \"  -stopafterblockimport  \" + strprintf(_(\"Stop running after importing blocks from disk (default: %u)\"), 0) + \"\\n\";\n+        strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(_(\"Only accept block chain matching built-in checkpoints (default: %u)\"), 1));\n+        strUsage += HelpMessageOpt(\"-dblogsize=<n>\", strprintf(_(\"Flush database activity from memory pool to disk log every <n> megabytes (default: %u)\"), 100));\n+        strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(_(\"Disable safemode, override a real safe mode event (default: %u)\"), 0));\n+        strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(_(\"Force safe mode (default: %u)\"), 0));\n+        strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", _(\"Randomly drop 1 of every <n> network messages\"));\n+        strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", _(\"Randomly fuzz 1 of every <n> network messages\"));\n+        strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(_(\"Run a thread to flush wallet periodically (default: %u)\"), 1));\n+        strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(_(\"Stop running after importing blocks from disk (default: %u)\"), 0));\n     }\n-    strUsage += \"  -debug=<category>      \" + strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \"\\n\";\n-    strUsage += \"                         \" + _(\"If <category> is not supplied, output all debugging information.\") + \"\\n\";\n-    strUsage += \"                         \" + _(\"<category> can be:\");\n-    strUsage +=                                 \" addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n+    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net, proxy, prune\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n-        strUsage += \", qt\";\n-    strUsage += \".\\n\";\n+        debugCategories += \", qt\";\n+    strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n+        _(\"If <category> is not supplied, output all debugging information.\") + _(\"<category> can be:\") + \" \" + debugCategories + \".\");\n #ifdef ENABLE_WALLET\n-    strUsage += \"  -gen                   \" + strprintf(_(\"Generate coins (default: %u)\"), 0) + \"\\n\";\n-    strUsage += \"  -genproclimit=<n>      \" + strprintf(_(\"Set the number of threads for coin generation if enabled (-1 = all cores, default: %d)\"), 1) + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-gen\", strprintf(_(\"Generate coins (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-genproclimit=<n>\", strprintf(_(\"Set the number of threads for coin generation if enabled (-1 = all cores, default: %d)\"), 1));\n #endif\n-    strUsage += \"  -help-debug            \" + _(\"Show all debugging options (usage: --help -help-debug)\") + \"\\n\";\n-    strUsage += \"  -logips                \" + strprintf(_(\"Include IP addresses in debug output (default: %u)\"), 0) + \"\\n\";\n-    strUsage += \"  -logtimestamps         \" + strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), 1) + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"));\n+    strUsage += HelpMessageOpt(\"-logips\", strprintf(_(\"Include IP addresses in debug output (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-logtimestamps\", strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), 1));\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n-        strUsage += \"  -limitfreerelay=<n>    \" + strprintf(_(\"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default:%u)\"), 15) + \"\\n\";\n-        strUsage += \"  -relaypriority         \" + strprintf(_(\"Require high priority for relaying free or low-fee transactions (default:%u)\"), 1) + \"\\n\";\n-        strUsage += \"  -maxsigcachesize=<n>   \" + strprintf(_(\"Limit size of signature cache to <n> entries (default: %u)\"), 50000) + \"\\n\";\n+        strUsage += HelpMessageOpt(\"-limitfreerelay=<n>\", strprintf(_(\"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default: %u)\"), 15));\n+        strUsage += HelpMessageOpt(\"-relaypriority\", strprintf(_(\"Require high priority for relaying free or low-fee transactions (default: %u)\"), 1));\n+        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(_(\"Limit size of signature cache to <n> entries (default: %u)\"), 50000));\n     }\n-    strUsage += \"  -minrelaytxfee=<amt>   \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying (default: %s)\"), FormatMoney(::minRelayTxFee.GetFeePerK())) + \"\\n\";\n-    strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n+    strUsage += HelpMessageOpt(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying (default: %s)\"), FormatMoney(::minRelayTxFee.GetFeePerK())));\n+    strUsage += HelpMessageOpt(\"-printtoconsole\", _(\"Send trace/debug info to console instead of debug.log file\"));\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n-        strUsage += \"  -printpriority         \" + strprintf(_(\"Log transaction priority and fee per kB when mining blocks (default: %u)\"), 0) + \"\\n\";\n-        strUsage += \"  -privdb                \" + strprintf(_(\"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\"), 1) + \"\\n\";\n-        strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \"\\n\";\n-        strUsage += \"                         \" + _(\"This is intended for regression testing tools and app development.\") + \"\\n\";\n-        strUsage += \"                         \" + _(\"In this mode -genproclimit controls how many blocks are generated immediately.\") + \"\\n\";\n+        strUsage += HelpMessageOpt(\"-printpriority\", strprintf(_(\"Log transaction priority and fee per kB when mining blocks (default: %u)\"), 0));\n+        strUsage += HelpMessageOpt(\"-privdb\", strprintf(_(\"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\"), 1));\n+        strUsage += HelpMessageOpt(\"-regtest\", _(\"Enter regression test mode, which uses a special chain in which blocks can be solved instantly.\") + \" \" +\n+            _(\"This is intended for regression testing tools and app development.\") + \" \" +\n+            _(\"In this mode -genproclimit controls how many blocks are generated immediately.\"));\n+    }\n+    strUsage += HelpMessageOpt(\"-shrinkdebugfile\", _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\"));\n+    strUsage += HelpMessageOpt(\"-testnet\", _(\"Use the test network\"));\n+\n+    strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n+    strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), 1));\n+    strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n+\n+    strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n+    strUsage += HelpMessageOpt(\"-blockminsize=<n>\", strprintf(_(\"Set minimum block size in bytes (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n+    strUsage += HelpMessageOpt(\"-blockprioritysize=<n>\", strprintf(_(\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"), DEFAULT_BLOCK_PRIORITY_SIZE));\n+\n+    strUsage += HelpMessageGroup(_(\"RPC server options:\"));\n+    strUsage += HelpMessageOpt(\"-server\", _(\"Accept command line and JSON-RPC commands\"));\n+    strUsage += HelpMessageOpt(\"-rest\", strprintf(_(\"Accept public REST requests (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-rpcbind=<addr>\", _(\"Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6. This option can be specified multiple times (default: bind to all interfaces)\"));\n+    strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n+    strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), 8332, 18332));\n+    strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n+    strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), 4));\n+    strUsage += HelpMessageOpt(\"-rpckeepalive\", strprintf(_(\"RPC support for HTTP persistent connections (default: %d)\"), 1));\n+\n+    strUsage += HelpMessageGroup(_(\"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"));\n+    strUsage += HelpMessageOpt(\"-rpcssl\", _(\"Use OpenSSL (https) for JSON-RPC connections\"));\n+    strUsage += HelpMessageOpt(\"-rpcsslcertificatechainfile=<file.cert>\", strprintf(_(\"Server certificate file (default: %s)\"), \"server.cert\"));\n+    strUsage += HelpMessageOpt(\"-rpcsslprivatekeyfile=<file.pem>\", strprintf(_(\"Server private key (default: %s)\"), \"server.pem\"));\n+    strUsage += HelpMessageOpt(\"-rpcsslciphers=<ciphers>\", strprintf(_(\"Acceptable ciphers (default: %s)\"), \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\"));\n+\n+    if (mode == HMM_BITCOIN_QT)\n+    {\n+        strUsage += HelpMessageGroup(_(\"UI Options:\"));\n+        if (GetBoolArg(\"-help-debug\", false)) {\n+            strUsage += HelpMessageOpt(\"-allowselfsignedrootcertificates\", _(\"Allow self signed root certificates (default: 0)\"));\n+        }\n+        strUsage += HelpMessageOpt(\"-choosedatadir\", _(\"Choose data directory on startup (default: 0)\"));\n+        strUsage += HelpMessageOpt(\"-lang=<lang>\", _(\"Set language, for example \\\"de_DE\\\" (default: system locale)\"));\n+        strUsage += HelpMessageOpt(\"-min\", _(\"Start minimized\"));\n+        strUsage += HelpMessageOpt(\"-rootcertificates=<file>\", _(\"Set SSL root certificates for payment request (default: -system-)\"));\n+        strUsage += HelpMessageOpt(\"-splash\", _(\"Show splash screen on startup (default: 1)\"));\n     }\n-    strUsage += \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n-    strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"Node relay options:\") + \"\\n\";\n-    strUsage += \"  -datacarrier           \" + strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), 1) + \"\\n\";\n-    strUsage += \"  -datacarriersize       \" + strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY) + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"Block creation options:\") + \"\\n\";\n-    strUsage += \"  -blockminsize=<n>      \" + strprintf(_(\"Set minimum block size in bytes (default: %u)\"), 0) + \"\\n\";\n-    strUsage += \"  -blockmaxsize=<n>      \" + strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE) + \"\\n\";\n-    strUsage += \"  -blockprioritysize=<n> \" + strprintf(_(\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"), DEFAULT_BLOCK_PRIORITY_SIZE) + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"RPC server options:\") + \"\\n\";\n-    strUsage += \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\";\n-    strUsage += \"  -rest                  \" + strprintf(_(\"Accept public REST requests (default: %u)\"), 0) + \"\\n\";\n-    strUsage += \"  -rpcbind=<addr>        \" + _(\"Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6. This option can be specified multiple times (default: bind to all interfaces)\") + \"\\n\";\n-    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), 8332, 18332) + \"\\n\";\n-    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\") + \"\\n\";\n-    strUsage += \"  -rpcthreads=<n>        \" + strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), 4) + \"\\n\";\n-    strUsage += \"  -rpckeepalive          \" + strprintf(_(\"RPC support for HTTP persistent connections (default: %d)\"), 1) + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-    strUsage += \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcsslcertificatechainfile=<file.cert>  \" + strprintf(_(\"Server certificate file (default: %s)\"), \"server.cert\") + \"\\n\";\n-    strUsage += \"  -rpcsslprivatekeyfile=<file.pem>         \" + strprintf(_(\"Server private key (default: %s)\"), \"server.pem\") + \"\\n\";\n-    strUsage += \"  -rpcsslciphers=<ciphers>                 \" + strprintf(_(\"Acceptable ciphers (default: %s)\"), \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\") + \"\\n\";\n \n     return strUsage;\n }\n@@ -424,10 +470,33 @@ struct CImportingNow\n     }\n };\n \n+\n+// If we're using -prune with -reindex, then delete block files that will be ignored by the\n+// reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile\n+// is missing, and since pruning works by deleting the oldest block file first, just check\n+// for block file 0, and if it doesn't exist, delete all the block files in the\n+// directory (since they won't be read by the reindex but will take up disk space).\n+void DeleteAllBlockFiles()\n+{\n+    if (boost::filesystem::exists(GetBlockPosFilename(CDiskBlockPos(0, 0), \"blk\")))\n+        return;\n+\n+    LogPrintf(\"Removing all blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n+    boost::filesystem::path blocksdir = GetDataDir() / \"blocks\";\n+    for (boost::filesystem::directory_iterator it(blocksdir); it != boost::filesystem::directory_iterator(); it++) {\n+        if (is_regular_file(*it)) {\n+            if ((it->path().filename().string().length() == 12) &&\n+                (it->path().filename().string().substr(8,4) == \".dat\") &&\n+                ((it->path().filename().string().substr(0,3) == \"blk\") ||\n+                 (it->path().filename().string().substr(0,3) == \"rev\")))\n+                boost::filesystem::remove(it->path());\n+        }\n+    }\n+}\n+\n void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n {\n     RenameThread(\"bitcoin-loadblk\");\n-\n     // -reindex\n     if (fReindex) {\n         CImportingNow imp;\n@@ -503,7 +572,7 @@ bool InitSanityCheck(void)\n /** Initialize bitcoin.\n  *  @pre Parameters should be parsed and config file should be read.\n  */\n-bool AppInit2(boost::thread_group& threadGroup)\n+bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n {\n     // ********************************************************* Step 1: setup\n #ifdef _MSC_VER\n@@ -569,6 +638,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n #endif\n \n     // ********************************************************* Step 2: parameter interactions\n+    const CChainParams& chainparams = Params();\n \n     // Set this early so that parameter interactions go to console\n     fPrintToConsole = GetBoolArg(\"-printtoconsole\", false);\n@@ -598,6 +668,10 @@ bool AppInit2(boost::thread_group& threadGroup)\n         // to protect privacy, do not listen by default if a default proxy server is specified\n         if (SoftSetBoolArg(\"-listen\", false))\n             LogPrintf(\"%s: parameter interaction: -proxy set -> setting -listen=0\\n\", __func__);\n+        // to protect privacy, do not use UPNP when a proxy is set. The user may still specify -listen=1\n+        // to listen locally, so don't rely on this happening through -listen below.\n+        if (SoftSetBoolArg(\"-upnp\", false))\n+            LogPrintf(\"%s: parameter interaction: -proxy set -> setting -upnp=0\\n\", __func__);\n         // to protect privacy, do not discover addresses by default\n         if (SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -proxy set -> setting -discover=0\\n\", __func__);\n@@ -639,6 +713,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (nFD - MIN_CORE_FILEDESCRIPTORS < nMaxConnections)\n         nMaxConnections = nFD - MIN_CORE_FILEDESCRIPTORS;\n \n+    // if using block pruning, then disable txindex\n+    // also disable the wallet (for now, until SPV support is implemented in wallet)\n+    if (GetArg(\"-prune\", 0)) {\n+        if (GetBoolArg(\"-txindex\", false))\n+            return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n+#ifdef ENABLE_WALLET\n+        if (!GetBoolArg(\"-disablewallet\", false)) {\n+            if (SoftSetBoolArg(\"-disablewallet\", true))\n+                LogPrintf(\"%s : parameter interaction: -prune -> setting -disablewallet=1\\n\", __func__);\n+            else\n+                return InitError(_(\"Can't run with a wallet in prune mode.\"));\n+        }\n+#endif\n+    }\n+\n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n     fDebug = !mapMultiArgs[\"-debug\"].empty();\n@@ -660,9 +749,10 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (GetBoolArg(\"-benchmark\", false))\n         InitWarning(_(\"Warning: Unsupported argument -benchmark ignored, use -debug=bench.\"));\n \n-    // Checkmempool defaults to true in regtest mode\n-    mempool.setSanityCheck(GetBoolArg(\"-checkmempool\", Params().DefaultCheckMemPool()));\n-    Checkpoints::fEnabled = GetBoolArg(\"-checkpoints\", true);\n+    // Checkmempool and checkblockindex default to true in regtest mode\n+    mempool.setSanityCheck(GetBoolArg(\"-checkmempool\", chainparams.DefaultConsistencyChecks()));\n+    fCheckBlockIndex = GetBoolArg(\"-checkblockindex\", chainparams.DefaultConsistencyChecks());\n+    fCheckpointsEnabled = GetBoolArg(\"-checkpoints\", true);\n \n     // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency\n     nScriptCheckThreads = GetArg(\"-par\", DEFAULT_SCRIPTCHECK_THREADS);\n@@ -674,6 +764,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n         nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS;\n \n     fServer = GetBoolArg(\"-server\", false);\n+\n+    // block pruning; get the amount of disk space (in MB) to allot for block & undo files\n+    int64_t nSignedPruneTarget = GetArg(\"-prune\", 0) * 1024 * 1024;\n+    if (nSignedPruneTarget < 0) {\n+        return InitError(_(\"Prune cannot be configured with a negative value.\"));\n+    }\n+    nPruneTarget = (uint64_t) nSignedPruneTarget;\n+    if (nPruneTarget) {\n+        if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) {\n+            return InitError(strprintf(_(\"Prune configured below the minimum of %d MB.  Please use a higher number.\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n+        }\n+        LogPrintf(\"Prune configured to target %uMiB on disk for block and undo files.\\n\", nPruneTarget / 1024 / 1024);\n+        fPruneMode = true;\n+    }\n+\n #ifdef ENABLE_WALLET\n     bool fDisableWallet = GetBoolArg(\"-disablewallet\", false);\n #endif\n@@ -740,18 +845,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n                                        mapArgs[\"-maxtxfee\"], ::minRelayTxFee.ToString()));\n         }\n     }\n-    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", 1);\n-    bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n-    fSendFreeTransactions = GetArg(\"-sendfreetransactions\", false);\n+    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n+    bSpendZeroConfChange = GetBoolArg(\"-spendzeroconfchange\", true);\n+    fSendFreeTransactions = GetBoolArg(\"-sendfreetransactions\", false);\n \n     std::string strWalletFile = GetArg(\"-wallet\", \"wallet.dat\");\n #endif // ENABLE_WALLET\n \n-    fIsBareMultisigStd = GetArg(\"-permitbaremultisig\", true) != 0;\n+    fIsBareMultisigStd = GetBoolArg(\"-permitbaremultisig\", true);\n     nMaxDatacarrierBytes = GetArg(\"-datacarriersize\", nMaxDatacarrierBytes);\n \n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n+    // Initialize elliptic curve code\n+    ECC_Start();\n+\n     // Sanity check\n     if (!InitSanityCheck())\n         return InitError(_(\"Initialization sanity check failed. Bitcoin Core is shutting down.\"));\n@@ -766,9 +874,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n     if (file) fclose(file);\n-    static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n-    if (!lock.try_lock())\n-        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.\"), strDataDir));\n+\n+    try {\n+        static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n+        if (!lock.try_lock())\n+            return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.\"), strDataDir));\n+    } catch(const boost::interprocess::interprocess_exception& e) {\n+        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.\") + \" %s.\", strDataDir, e.what()));\n+    }\n+\n #ifndef WIN32\n     CreatePidFile(GetPidFile(), getpid());\n #endif\n@@ -794,6 +908,10 @@ bool AppInit2(boost::thread_group& threadGroup)\n             threadGroup.create_thread(&ThreadScriptCheck);\n     }\n \n+    // Start the lightweight task scheduler thread\n+    CScheduler::Function serviceLoop = boost::bind(&CScheduler::serviceQueue, &scheduler);\n+    threadGroup.create_thread(boost::bind(&TraceThread<CScheduler::Function>, \"scheduler\", serviceLoop));\n+\n     /* Start the RPC server already.  It will be started in \"warmup\" mode\n      * and not really process calls already (but it will signify connections\n      * that the server is there and will be ready later).  Warmup mode will\n@@ -802,6 +920,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (fServer)\n     {\n         uiInterface.InitMessage.connect(SetRPCWarmupStatus);\n+        RPCServer::OnStopped(&OnRPCStopped);\n+        RPCServer::OnPreCommand(&OnRPCPreCommand);\n         StartRPCThreads();\n     }\n \n@@ -813,47 +933,17 @@ bool AppInit2(boost::thread_group& threadGroup)\n         LogPrintf(\"Using wallet %s\\n\", strWalletFile);\n         uiInterface.InitMessage(_(\"Verifying wallet...\"));\n \n-        if (!bitdb.Open(GetDataDir()))\n-        {\n-            // try moving the database env out of the way\n-            boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n-            boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%d.bak\", GetTime());\n-            try {\n-                boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n-                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n-            } catch (const boost::filesystem::filesystem_error&) {\n-                 // failure is ok (well, not really, but it's not worse than what we started with)\n-            }\n-\n-            // try again\n-            if (!bitdb.Open(GetDataDir())) {\n-                // if it still fails, it probably means we can't even create the database env\n-                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir);\n-                return InitError(msg);\n-            }\n-        }\n-\n-        if (GetBoolArg(\"-salvagewallet\", false))\n-        {\n-            // Recover readable keypairs:\n-            if (!CWalletDB::Recover(bitdb, strWalletFile, true))\n-                return false;\n-        }\n-\n-        if (boost::filesystem::exists(GetDataDir() / strWalletFile))\n-        {\n-            CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n-            if (r == CDBEnv::RECOVER_OK)\n-            {\n-                string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n-                                         \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n-                                         \" your balance or transactions are incorrect you should\"\n-                                         \" restore from a backup.\"), strDataDir);\n-                InitWarning(msg);\n-            }\n-            if (r == CDBEnv::RECOVER_FAIL)\n-                return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n-        }\n+        std::string warningString;\n+        std::string errorString;\n+        \n+        if (!CWallet::Verify(strWalletFile, warningString, errorString))\n+            return false;\n+        \n+        if (!warningString.empty())\n+            InitWarning(warningString);\n+        if (!errorString.empty())\n+            return InitError(warningString);\n+        \n     } // (!fDisableWallet)\n #endif // ENABLE_WALLET\n     // ********************************************************* Step 6: network initialization\n@@ -884,10 +974,10 @@ bool AppInit2(boost::thread_group& threadGroup)\n         }\n     }\n \n-    CService addrProxy;\n+    proxyType addrProxy;\n     bool fProxy = false;\n     if (mapArgs.count(\"-proxy\")) {\n-        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n+        addrProxy = proxyType(CService(mapArgs[\"-proxy\"], 9050), GetBoolArg(\"-proxyrandomize\", true));\n         if (!addrProxy.IsValid())\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"]));\n \n@@ -897,14 +987,14 @@ bool AppInit2(boost::thread_group& threadGroup)\n         fProxy = true;\n     }\n \n-    // -onion can override normal proxy, -noonion disables tor entirely\n+    // -onion can override normal proxy, -noonion disables connecting to .onion entirely\n     if (!(mapArgs.count(\"-onion\") && mapArgs[\"-onion\"] == \"0\") &&\n         (fProxy || mapArgs.count(\"-onion\"))) {\n-        CService addrOnion;\n+        proxyType addrOnion;\n         if (!mapArgs.count(\"-onion\"))\n             addrOnion = addrProxy;\n         else\n-            addrOnion = CService(mapArgs[\"-onion\"], 9050);\n+            addrOnion = proxyType(CService(mapArgs[\"-onion\"], 9050), GetBoolArg(\"-proxyrandomize\", true));\n         if (!addrOnion.IsValid())\n             return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs[\"-onion\"]));\n         SetProxy(NET_TOR, addrOnion);\n@@ -977,7 +1067,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             } catch (const boost::filesystem::filesystem_error& e) {\n                 // Note: hardlink creation failing is not a disaster, it just means\n                 // blocks will get re-downloaded from peers.\n-                LogPrintf(\"Error hardlinking blk%04u.dat : %s\\n\", i, e.what());\n+                LogPrintf(\"Error hardlinking blk%04u.dat: %s\\n\", i, e.what());\n                 break;\n             }\n         }\n@@ -988,18 +1078,20 @@ bool AppInit2(boost::thread_group& threadGroup)\n     }\n \n     // cache size calculations\n-    size_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n-    if (nTotalCache < (nMinDbCache << 20))\n-        nTotalCache = (nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n-    else if (nTotalCache > (nMaxDbCache << 20))\n-        nTotalCache = (nMaxDbCache << 20); // total cache cannot be greater than nMaxDbCache\n-    size_t nBlockTreeDBCache = nTotalCache / 8;\n+    int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n+    nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n+    nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greated than nMaxDbcache\n+    int64_t nBlockTreeDBCache = nTotalCache / 8;\n     if (nBlockTreeDBCache > (1 << 21) && !GetBoolArg(\"-txindex\", false))\n         nBlockTreeDBCache = (1 << 21); // block tree db cache shouldn't be larger than 2 MiB\n     nTotalCache -= nBlockTreeDBCache;\n-    size_t nCoinDBCache = nTotalCache / 2; // use half of the remaining cache for coindb cache\n+    int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache\n     nTotalCache -= nCoinDBCache;\n-    nCoinCacheSize = nTotalCache / 300; // coins in memory require around 300 bytes\n+    nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache\n+    LogPrintf(\"Cache configuration:\\n\");\n+    LogPrintf(\"* Using %.1fMiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n+    LogPrintf(\"* Using %.1fMiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n+    LogPrintf(\"* Using %.1fMiB for in-memory UTXO set\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024));\n \n     bool fLoaded = false;\n     while (!fLoaded) {\n@@ -1022,8 +1114,12 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n                 pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n \n-                if (fReindex)\n+                if (fReindex) {\n                     pblocktree->WriteReindexing(true);\n+                    //If we're reindexing in prune mode, wipe away all our block and undo data files\n+                    if (fPruneMode)\n+                        DeleteAllBlockFiles();\n+                }\n \n                 if (!LoadBlockIndex()) {\n                     strLoadError = _(\"Error loading block database\");\n@@ -1032,7 +1128,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && mapBlockIndex.count(Params().HashGenesisBlock()) == 0)\n+                if (!mapBlockIndex.empty() && mapBlockIndex.count(chainparams.GetConsensus().hashGenesisBlock) == 0)\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n \n                 // Initialize the block index (no-op if non-empty database was already loaded)\n@@ -1047,7 +1143,18 @@ bool AppInit2(boost::thread_group& threadGroup)\n                     break;\n                 }\n \n+                // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n+                // in the past, but is now trying to run unpruned.\n+                if (fHavePruned && !fPruneMode) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain\");\n+                    break;\n+                }\n+\n                 uiInterface.InitMessage(_(\"Verifying blocks...\"));\n+                if (fHavePruned && GetArg(\"-checkblocks\", 288) > MIN_BLOCKS_TO_KEEP) {\n+                    LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; -checkblocks=%d may fail\\n\",\n+                        MIN_BLOCKS_TO_KEEP, GetArg(\"-checkblocks\", 288));\n+                }\n                 if (!CVerifyDB().VerifyDB(pcoinsdbview, GetArg(\"-checklevel\", 3),\n                               GetArg(\"-checkblocks\", 288))) {\n                     strLoadError = _(\"Corrupted block database detected\");\n@@ -1098,6 +1205,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n         mempool.ReadFeeEstimates(est_filein);\n     fFeeEstimatesInitialized = true;\n \n+    // if prune mode, unset NODE_NETWORK and prune block files\n+    if (fPruneMode) {\n+        LogPrintf(\"Unsetting NODE_NETWORK on prune mode\\n\");\n+        nLocalServices &= ~NODE_NETWORK;\n+        if (!fReindex) {\n+            PruneAndFlush();\n+        }\n+    }\n+\n     // ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n     if (fDisableWallet) {\n@@ -1211,6 +1327,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n             // Restore wallet transaction metadata after -zapwallettxes=1\n             if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n             {\n+                CWalletDB walletdb(strWalletFile);\n+\n                 BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n                 {\n                     uint256 hash = wtxOld.GetHash();\n@@ -1226,20 +1344,22 @@ bool AppInit2(boost::thread_group& threadGroup)\n                         copyTo->fFromMe = copyFrom->fFromMe;\n                         copyTo->strFromAccount = copyFrom->strFromAccount;\n                         copyTo->nOrderPos = copyFrom->nOrderPos;\n-                        copyTo->WriteToDisk();\n+                        copyTo->WriteToDisk(&walletdb);\n                     }\n                 }\n             }\n         }\n+        pwalletMain->SetBroadcastTransactions(GetBoolArg(\"-walletbroadcast\", true));\n     } // (!fDisableWallet)\n #else // ENABLE_WALLET\n-    LogPrintf(\"No wallet compiled in!\\n\");\n+    LogPrintf(\"No wallet support compiled in!\\n\");\n #endif // !ENABLE_WALLET\n     // ********************************************************* Step 9: import blocks\n \n     if (mapArgs.count(\"-blocknotify\"))\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n+    uiInterface.InitMessage(_(\"Activating best chain...\"));\n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n     if (!ActivateBestChain(state))\n@@ -1252,6 +1372,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n             vImportFiles.push_back(strFile);\n     }\n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n+    if (chainActive.Tip() == NULL) {\n+        LogPrintf(\"Waiting for genesis block to be imported...\\n\");\n+        while (!fRequestShutdown && chainActive.Tip() == NULL)\n+            MilliSleep(10);\n+    }\n \n     // ********************************************************* Step 10: start node\n \n@@ -1272,7 +1397,13 @@ bool AppInit2(boost::thread_group& threadGroup)\n     LogPrintf(\"mapAddressBook.size() = %u\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n #endif\n \n-    StartNode(threadGroup);\n+    StartNode(threadGroup, scheduler);\n+\n+    // Monitor the chain, and alert if we get blocks much quicker or slower than expected\n+    int64_t nPowTargetSpacing = Params().GetConsensus().nPowTargetSpacing;\n+    CScheduler::Function f = boost::bind(&PartitionCheck, &IsInitialBlockDownload,\n+                                         boost::ref(cs_main), boost::cref(chainActive), nPowTargetSpacing);\n+    scheduler.scheduleEvery(f, nPowTargetSpacing);\n \n #ifdef ENABLE_WALLET\n     // Generate coins in the background"
      },
      {
        "sha": "dcb2b293608c8d7771bd9396fadaabd0f5bf250d",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <string>\n \n+class CScheduler;\n class CWallet;\n \n namespace boost\n@@ -20,7 +21,7 @@ extern CWallet* pwalletMain;\n void StartShutdown();\n bool ShutdownRequested();\n void Shutdown();\n-bool AppInit2(boost::thread_group& threadGroup);\n+bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler);\n \n /** The help message mode determines what help message to show */\n enum HelpMessageMode {"
      },
      {
        "sha": "b772dff333c6efc72cc8a6ddfa7adedcc3ec6391",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 53,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,30 +5,16 @@\n #include \"key.h\"\n \n #include \"arith_uint256.h\"\n+#include \"crypto/common.h\"\n #include \"crypto/hmac_sha512.h\"\n-#include \"crypto/rfc6979_hmac_sha256.h\"\n #include \"eccryptoverify.h\"\n #include \"pubkey.h\"\n #include \"random.h\"\n \n #include <secp256k1.h>\n #include \"ecwrapper.h\"\n \n-//! anonymous namespace\n-namespace {\n-\n-class CSecp256k1Init {\n-public:\n-    CSecp256k1Init() {\n-        secp256k1_start(SECP256K1_START_SIGN);\n-    }\n-    ~CSecp256k1Init() {\n-        secp256k1_stop();\n-    }\n-};\n-static CSecp256k1Init instance_of_csecp256k1;\n-\n-} // anon namespace\n+static secp256k1_context_t* secp256k1_context = NULL;\n \n bool CKey::Check(const unsigned char *vch) {\n     return eccrypto::Check(vch);\n@@ -44,7 +30,7 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n }\n \n bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n-    if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+    if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n     fCompressed = fCompressedIn;\n     fValid = true;\n@@ -57,7 +43,7 @@ CPrivKey CKey::GetPrivKey() const {\n     int privkeylen, ret;\n     privkey.resize(279);\n     privkeylen = 279;\n-    ret = secp256k1_ec_privkey_export(begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n+    ret = secp256k1_ec_privkey_export(secp256k1_context, begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n     assert(ret);\n     privkey.resize(privkeylen);\n     return privkey;\n@@ -67,7 +53,7 @@ CPubKey CKey::GetPubKey() const {\n     assert(fValid);\n     CPubKey result;\n     int clen = 65;\n-    int ret = secp256k1_ec_pubkey_create((unsigned char*)result.begin(), &clen, begin(), fCompressed);\n+    int ret = secp256k1_ec_pubkey_create(secp256k1_context, (unsigned char*)result.begin(), &clen, begin(), fCompressed);\n     assert((int)result.size() == clen);\n     assert(ret);\n     assert(result.IsValid());\n@@ -78,19 +64,13 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_\n     if (!fValid)\n         return false;\n     vchSig.resize(72);\n-    RFC6979_HMAC_SHA256 prng(begin(), 32, (unsigned char*)&hash, 32);\n-    do {\n-        uint256 nonce;\n-        prng.Generate((unsigned char*)&nonce, 32);\n-        nonce = ArithToUint256(UintToArith256(nonce) + test_case);\n-        int nSigLen = 72;\n-        int ret = secp256k1_ecdsa_sign((const unsigned char*)&hash, (unsigned char*)&vchSig[0], &nSigLen, begin(), (unsigned char*)&nonce);\n-        nonce = uint256();\n-        if (ret) {\n-            vchSig.resize(nSigLen);\n-            return true;\n-        }\n-    } while(true);\n+    int nSigLen = 72;\n+    unsigned char extra_entropy[32] = {0};\n+    WriteLE32(extra_entropy, test_case);\n+    int ret = secp256k1_ecdsa_sign(secp256k1_context, hash.begin(), (unsigned char*)&vchSig[0], &nSigLen, begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : NULL);\n+    assert(ret);\n+    vchSig.resize(nSigLen);\n+    return true;\n }\n \n bool CKey::VerifyPubKey(const CPubKey& pubkey) const {\n@@ -101,7 +81,7 @@ bool CKey::VerifyPubKey(const CPubKey& pubkey) const {\n     std::string str = \"Bitcoin key verification\\n\";\n     GetRandBytes(rnd, sizeof(rnd));\n     uint256 hash;\n-    CHash256().Write((unsigned char*)str.data(), str.size()).Write(rnd, sizeof(rnd)).Finalize((unsigned char*)&hash);\n+    CHash256().Write((unsigned char*)str.data(), str.size()).Write(rnd, sizeof(rnd)).Finalize(hash.begin());\n     std::vector<unsigned char> vchSig;\n     Sign(hash, vchSig);\n     return pubkey.Verify(hash, vchSig);\n@@ -112,22 +92,15 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n         return false;\n     vchSig.resize(65);\n     int rec = -1;\n-    RFC6979_HMAC_SHA256 prng(begin(), 32, (unsigned char*)&hash, 32);\n-    do {\n-        uint256 nonce;\n-        prng.Generate((unsigned char*)&nonce, 32);\n-        int ret = secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, &vchSig[1], begin(), (unsigned char*)&nonce, &rec);\n-        nonce = uint256();\n-        if (ret)\n-            break;\n-    } while(true);\n+    int ret = secp256k1_ecdsa_sign_compact(secp256k1_context, hash.begin(), &vchSig[1], begin(), secp256k1_nonce_function_rfc6979, NULL, &rec);\n+    assert(ret);\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n     return true;\n }\n \n bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n-    if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+    if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n@@ -138,7 +111,7 @@ bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n     return VerifyPubKey(vchPubKey);\n }\n \n-bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n+bool CKey::Derive(CKey& keyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const {\n     assert(IsValid());\n     assert(IsCompressed());\n     unsigned char out[64];\n@@ -151,9 +124,9 @@ bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild\n         assert(begin() + 32 == end());\n         BIP32Hash(cc, nChild, 0, begin(), out);\n     }\n-    memcpy(ccChild, out+32, 32);\n+    memcpy(ccChild.begin(), out+32, 32);\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n-    bool ret = secp256k1_ec_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n+    bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context, (unsigned char*)keyChild.begin(), out);\n     UnlockObject(out);\n     keyChild.fCompressed = true;\n     keyChild.fValid = ret;\n@@ -165,7 +138,7 @@ bool CExtKey::Derive(CExtKey &out, unsigned int nChild) const {\n     CKeyID id = key.GetPubKey().GetID();\n     memcpy(&out.vchFingerprint[0], &id, 4);\n     out.nChild = nChild;\n-    return key.Derive(out.key, out.vchChainCode, nChild, vchChainCode);\n+    return key.Derive(out.key, out.chaincode, nChild, chaincode);\n }\n \n void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n@@ -174,7 +147,7 @@ void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n     LockObject(out);\n     CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out);\n     key.Set(&out[0], &out[32], true);\n-    memcpy(vchChainCode, &out[32], 32);\n+    memcpy(chaincode.begin(), &out[32], 32);\n     UnlockObject(out);\n     nDepth = 0;\n     nChild = 0;\n@@ -187,7 +160,7 @@ CExtPubKey CExtKey::Neuter() const {\n     memcpy(&ret.vchFingerprint[0], &vchFingerprint[0], 4);\n     ret.nChild = nChild;\n     ret.pubkey = key.GetPubKey();\n-    memcpy(&ret.vchChainCode[0], &vchChainCode[0], 32);\n+    ret.chaincode = chaincode;\n     return ret;\n }\n \n@@ -196,7 +169,7 @@ void CExtKey::Encode(unsigned char code[74]) const {\n     memcpy(code+1, vchFingerprint, 4);\n     code[5] = (nChild >> 24) & 0xFF; code[6] = (nChild >> 16) & 0xFF;\n     code[7] = (nChild >>  8) & 0xFF; code[8] = (nChild >>  0) & 0xFF;\n-    memcpy(code+9, vchChainCode, 32);\n+    memcpy(code+9, chaincode.begin(), 32);\n     code[41] = 0;\n     assert(key.size() == 32);\n     memcpy(code+42, key.begin(), 32);\n@@ -206,18 +179,45 @@ void CExtKey::Decode(const unsigned char code[74]) {\n     nDepth = code[0];\n     memcpy(vchFingerprint, code+1, 4);\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n-    memcpy(vchChainCode, code+9, 32);\n+    memcpy(chaincode.begin(), code+9, 32);\n     key.Set(code+42, code+74, true);\n }\n \n bool ECC_InitSanityCheck() {\n-#if !defined(USE_SECP256K1)\n     if (!CECKey::SanityCheck()) {\n         return false;\n     }\n-#endif\n     CKey key;\n     key.MakeNewKey(true);\n     CPubKey pubkey = key.GetPubKey();\n     return key.VerifyPubKey(pubkey);\n }\n+\n+\n+void ECC_Start() {\n+    assert(secp256k1_context == NULL);\n+\n+    secp256k1_context_t *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    assert(ctx != NULL);\n+\n+    {\n+        // Pass in a random blinding seed to the secp256k1 context.\n+        unsigned char seed[32];\n+        LockObject(seed);\n+        GetRandBytes(seed, 32);\n+        bool ret = secp256k1_context_randomize(ctx, seed);\n+        assert(ret);\n+        UnlockObject(seed);\n+    }\n+\n+    secp256k1_context = ctx;\n+}\n+\n+void ECC_Stop() {\n+    secp256k1_context_t *ctx = secp256k1_context;\n+    secp256k1_context = NULL;\n+\n+    if (ctx) {\n+        secp256k1_context_destroy(ctx);\n+    }\n+}"
      },
      {
        "sha": "021eac2a8dd77786591e0414eafd21c3bdb8151b",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,16 +6,14 @@\n #ifndef BITCOIN_KEY_H\n #define BITCOIN_KEY_H\n \n-#include \"allocators.h\"\n+#include \"pubkey.h\"\n #include \"serialize.h\"\n+#include \"support/allocators/secure.h\"\n #include \"uint256.h\"\n \n #include <stdexcept>\n #include <vector>\n \n-class CPubKey;\n-\n-struct CExtPubKey;\n \n /** \n  * secp256k1:\n@@ -124,8 +122,7 @@ class CKey\n \n     /**\n      * Create a DER-serialized signature.\n-     * The test_case parameter tweaks the deterministic nonce, and is only for\n-     * testing. It should be zero for normal use.\n+     * The test_case parameter tweaks the deterministic nonce.\n      */\n     bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig, uint32_t test_case = 0) const;\n \n@@ -139,7 +136,7 @@ class CKey\n     bool SignCompact(const uint256& hash, std::vector<unsigned char>& vchSig) const;\n \n     //! Derive BIP32 child key.\n-    bool Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n+    bool Derive(CKey& keyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n \n     /**\n      * Verify thoroughly whether a private key and a public key match.\n@@ -158,13 +155,13 @@ struct CExtKey {\n     unsigned char nDepth;\n     unsigned char vchFingerprint[4];\n     unsigned int nChild;\n-    unsigned char vchChainCode[32];\n+    ChainCode chaincode;\n     CKey key;\n \n     friend bool operator==(const CExtKey& a, const CExtKey& b)\n     {\n         return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n-               memcmp(&a.vchChainCode[0], &b.vchChainCode[0], 32) == 0 && a.key == b.key;\n+               a.chaincode == b.chaincode && a.key == b.key;\n     }\n \n     void Encode(unsigned char code[74]) const;\n@@ -174,7 +171,13 @@ struct CExtKey {\n     void SetMaster(const unsigned char* seed, unsigned int nSeedLen);\n };\n \n-/** Check that required EC support is available at runtime */\n+/** Initialize the elliptic curve support. May not be called twice without calling ECC_Stop first. */\n+void ECC_Start(void);\n+\n+/** Deinitialize the elliptic curve support. No-op if ECC_Start wasn't called first. */\n+void ECC_Stop(void);\n+\n+/** Check that required EC support is available at runtime. */\n bool ECC_InitSanityCheck(void);\n \n #endif // BITCOIN_KEY_H"
      },
      {
        "sha": "3bae24b7b946c5a029ba4581ee6f98418e45d866",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,10 +5,7 @@\n \n #include \"keystore.h\"\n \n-#include \"crypter.h\"\n #include \"key.h\"\n-#include \"script/script.h\"\n-#include \"script/standard.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>\n@@ -36,7 +33,7 @@ bool CBasicKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n {\n     if (redeemScript.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-        return error(\"CBasicKeyStore::AddCScript() : redeemScripts > %i bytes are invalid\", MAX_SCRIPT_ELEMENT_SIZE);\n+        return error(\"CBasicKeyStore::AddCScript(): redeemScripts > %i bytes are invalid\", MAX_SCRIPT_ELEMENT_SIZE);\n \n     LOCK(cs_KeyStore);\n     mapScripts[CScriptID(redeemScript)] = redeemScript;"
      },
      {
        "sha": "4a4b6d20afe7270ec1a6397925905e185513d674",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,14 +8,13 @@\n \n #include \"key.h\"\n #include \"pubkey.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n #include \"sync.h\"\n \n #include <boost/signals2/signal.hpp>\n #include <boost/variant.hpp>\n \n-class CScript;\n-class CScriptID;\n-\n /** A virtual base class for key stores */\n class CKeyStore\n {"
      },
      {
        "sha": "651348300e1279404c4d97a5a983ed33b6d3278f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 874,
        "deletions": 371,
        "changes": 1245,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "9bf7bbb2f856487c0e15ba6c4bb2ba106930ae77",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 65,
        "deletions": 117,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -14,10 +14,10 @@\n #include \"chain.h\"\n #include \"chainparams.h\"\n #include \"coins.h\"\n+#include \"consensus/consensus.h\"\n+#include \"net.h\"\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n-#include \"net.h\"\n-#include \"pow.h\"\n #include \"script/script.h\"\n #include \"script/sigcache.h\"\n #include \"script/standard.h\"\n@@ -54,8 +54,6 @@ static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 50000;\n /** The maximum size for transactions we're willing to relay/mine */\n static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n-/** The maximum allowed number of signature check operations in a block (network rule) */\n-static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n /** Maximum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n@@ -68,10 +66,6 @@ static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n /** The pre-allocation chunk size for rev?????.dat files (since 0.8) */\n static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n-/** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n-static const int COINBASE_MATURITY = 100;\n-/** Threshold for nLockTime: below this value it is interpreted as block number, otherwise as UNIX timestamp. */\n-static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n /** Maximum number of script-checking threads allowed */\n static const int MAX_SCRIPTCHECK_THREADS = 16;\n /** -par default (number of script-checking threads, 0 = auto) */\n@@ -81,28 +75,20 @@ static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 16;\n /** Timeout in seconds during which a peer must stall block download progress before being disconnected. */\n static const unsigned int BLOCK_STALLING_TIMEOUT = 2;\n /** Number of headers sent in one getheaders result. We rely on the assumption that if a peer sends\n- *  less than this number, we reached their tip. Changing this value is a protocol upgrade. */\n+ *  less than this number, we reached its tip. Changing this value is a protocol upgrade. */\n static const unsigned int MAX_HEADERS_RESULTS = 2000;\n /** Size of the \"block download window\": how far ahead of our current height do we fetch?\n  *  Larger windows tolerate larger download speed differences between peer, but increase the potential\n  *  degree of disordering of blocks on disk (which make reindexing and in the future perhaps pruning\n  *  harder). We'll probably want to make this a per-peer adaptive value at some point. */\n static const unsigned int BLOCK_DOWNLOAD_WINDOW = 1024;\n-/** Time to wait (in seconds) between writing blockchain state to disk. */\n-static const unsigned int DATABASE_WRITE_INTERVAL = 3600;\n+/** Time to wait (in seconds) between writing blocks/block index to disk. */\n+static const unsigned int DATABASE_WRITE_INTERVAL = 60 * 60;\n+/** Time to wait (in seconds) between flushing chainstate to disk. */\n+static const unsigned int DATABASE_FLUSH_INTERVAL = 24 * 60 * 60;\n /** Maximum length of reject messages. */\n static const unsigned int MAX_REJECT_MESSAGE_LENGTH = 111;\n \n-/** \"reject\" message codes */\n-static const unsigned char REJECT_MALFORMED = 0x01;\n-static const unsigned char REJECT_INVALID = 0x10;\n-static const unsigned char REJECT_OBSOLETE = 0x11;\n-static const unsigned char REJECT_DUPLICATE = 0x12;\n-static const unsigned char REJECT_NONSTANDARD = 0x40;\n-static const unsigned char REJECT_DUST = 0x41;\n-static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n-static const unsigned char REJECT_CHECKPOINT = 0x43;\n-\n struct BlockHasher\n {\n     size_t operator()(const uint256& hash) const { return hash.GetCheapHash(); }\n@@ -116,15 +102,16 @@ extern BlockMap mapBlockIndex;\n extern uint64_t nLastBlockTx;\n extern uint64_t nLastBlockSize;\n extern const std::string strMessageMagic;\n-extern int64_t nTimeBestReceived;\n extern CWaitableCriticalSection csBestBlock;\n extern CConditionVariable cvBlockChange;\n extern bool fImporting;\n extern bool fReindex;\n extern int nScriptCheckThreads;\n extern bool fTxIndex;\n extern bool fIsBareMultisigStd;\n-extern unsigned int nCoinCacheSize;\n+extern bool fCheckBlockIndex;\n+extern bool fCheckpointsEnabled;\n+extern size_t nCoinCacheUsage;\n extern CFeeRate minRelayTxFee;\n \n /** Best header we've seen so far (used for getheaders queries' starting points). */\n@@ -133,14 +120,25 @@ extern CBlockIndex *pindexBestHeader;\n /** Minimum disk space required - used in CheckDiskSpace() */\n static const uint64_t nMinDiskSpace = 52428800;\n \n-/** Register a wallet to receive updates from core */\n-void RegisterValidationInterface(CValidationInterface* pwalletIn);\n-/** Unregister a wallet from core */\n-void UnregisterValidationInterface(CValidationInterface* pwalletIn);\n-/** Unregister all wallets from core */\n-void UnregisterAllValidationInterfaces();\n-/** Push an updated transaction to all registered wallets */\n-void SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL);\n+/** Pruning-related variables and constants */\n+/** True if any block files have ever been pruned. */\n+extern bool fHavePruned;\n+/** True if we're running in -prune mode. */\n+extern bool fPruneMode;\n+/** Number of MiB of block files that we're trying to stay below. */\n+extern uint64_t nPruneTarget;\n+/** Block files containing a block-height within MIN_BLOCKS_TO_KEEP of chainActive.Tip() will not be pruned. */\n+static const signed int MIN_BLOCKS_TO_KEEP = 288;\n+\n+// Require that user allocate at least 550MB for block & undo files (blk???.dat and rev???.dat)\n+// At 1MB per block, 288 blocks = 288MB.\n+// Add 15% for Undo data = 331MB\n+// Add 20% for Orphan block rate = 397MB\n+// We want the low water mark after pruning to be at least 397 MB and since we prune in\n+// full block file chunks, we need the high water mark which triggers the prune to be\n+// one 128MB block file + added 15% undo data = 147MB greater for a total of 545MB\n+// Setting the target to > than 550MB will make it likely we can respect the target.\n+static const signed int MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n \n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n@@ -152,7 +150,7 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n  * block is made active. Note that it does not, however, guarantee that the\n  * specific block passed to it has been checked for validity!\n  * \n- * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface - this will have its BlockChecked method called whenever *any* block completes validation.\n+ * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface (see validationinterface.h) - this will have its BlockChecked method called whenever *any* block completes validation.\n  * @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n  * @param[in]   pblock  The block we want to process.\n  * @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its location.\n@@ -177,10 +175,17 @@ bool LoadBlockIndex();\n void UnloadBlockIndex();\n /** Process protocol messages received from a given node */\n bool ProcessMessages(CNode* pfrom);\n-/** Send queued protocol messages to be sent to a give node */\n+/**\n+ * Send queued protocol messages to be sent to a give node.\n+ *\n+ * @param[in]   pto             The node which we are sending messages to.\n+ * @param[in]   fSendTrickle    When true send the trickled data, otherwise trickle the data until true.\n+ */\n bool SendMessages(CNode* pto, bool fSendTrickle);\n /** Run an instance of the script checking thread */\n void ThreadScriptCheck();\n+/** Try to detect Partition (network isolation) attacks against us */\n+void PartitionCheck(bool (*initialDownloadCheck)(), CCriticalSection& cs, const CChain& chain, int64_t nPowTargetSpacing);\n /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n bool IsInitialBlockDownload();\n /** Format a string that describes several potential problems detected by the core */\n@@ -189,23 +194,44 @@ std::string GetWarnings(std::string strFor);\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n /** Find the best known block, and make it the tip of the block chain */\n bool ActivateBestChain(CValidationState &state, CBlock *pblock = NULL);\n-CAmount GetBlockValue(int nHeight, const CAmount& nFees);\n+CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);\n+\n+/**\n+ * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.\n+ * The user sets the target (in MB) on the command line or in config file.  This will be run on startup and whenever new\n+ * space is allocated in a block or undo file, staying below the target. Changing back to unpruned requires a reindex\n+ * (which in this case means the blockchain must be re-downloaded.)\n+ *\n+ * Pruning functions are called from FlushStateToDisk when the global fCheckForPruning flag has been set.\n+ * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n+ * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 10 on regtest).\n+ * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n+ * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n+ * A db flag records the fact that at least some block files have been pruned.\n+ *\n+ * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned\n+ */\n+void FindFilesToPrune(std::set<int>& setFilesToPrune);\n+\n+/**\n+ *  Actually unlink the specified files\n+ */\n+void UnlinkPrunedFiles(std::set<int>& setFilesToPrune);\n \n /** Create a new block index entry for a given block hash */\n CBlockIndex * InsertBlockIndex(uint256 hash);\n-/** Abort with a message */\n-bool AbortNode(const std::string &msg, const std::string &userMessage=\"\");\n /** Get statistics from node state */\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch);\n /** Flush all state, indexes and buffers to disk. */\n void FlushStateToDisk();\n-\n+/** Prune block files and flush state to disk. */\n+void PruneAndFlush();\n \n /** (try to) add transaction to memory pool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, bool fRejectInsaneFee=false);\n+                        bool* pfMissingInputs, bool fRejectAbsurdFee=false);\n \n \n struct CNodeStateStats {\n@@ -336,7 +362,7 @@ class CScriptCheck\n \n \n /** Functions for disk access for blocks */\n-bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos);\n+bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart);\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos);\n bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex);\n \n@@ -423,69 +449,6 @@ class CBlockFileInfo\n      }\n };\n \n-/** Capture information about block/transaction validation */\n-class CValidationState {\n-private:\n-    enum mode_state {\n-        MODE_VALID,   //! everything ok\n-        MODE_INVALID, //! network rule violation (DoS value may be set)\n-        MODE_ERROR,   //! run-time error\n-    } mode;\n-    int nDoS;\n-    std::string strRejectReason;\n-    unsigned char chRejectCode;\n-    bool corruptionPossible;\n-public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n-             unsigned char chRejectCodeIn=0, std::string strRejectReasonIn=\"\",\n-             bool corruptionIn=false) {\n-        chRejectCode = chRejectCodeIn;\n-        strRejectReason = strRejectReasonIn;\n-        corruptionPossible = corruptionIn;\n-        if (mode == MODE_ERROR)\n-            return ret;\n-        nDoS += level;\n-        mode = MODE_INVALID;\n-        return ret;\n-    }\n-    bool Invalid(bool ret = false,\n-                 unsigned char _chRejectCode=0, std::string _strRejectReason=\"\") {\n-        return DoS(0, ret, _chRejectCode, _strRejectReason);\n-    }\n-    bool Error(std::string strRejectReasonIn=\"\") {\n-        if (mode == MODE_VALID)\n-            strRejectReason = strRejectReasonIn;\n-        mode = MODE_ERROR;\n-        return false;\n-    }\n-    bool Abort(const std::string &msg) {\n-        AbortNode(msg);\n-        return Error(msg);\n-    }\n-    bool IsValid() const {\n-        return mode == MODE_VALID;\n-    }\n-    bool IsInvalid() const {\n-        return mode == MODE_INVALID;\n-    }\n-    bool IsError() const {\n-        return mode == MODE_ERROR;\n-    }\n-    bool IsInvalid(int &nDoSOut) const {\n-        if (IsInvalid()) {\n-            nDoSOut = nDoS;\n-            return true;\n-        }\n-        return false;\n-    }\n-    bool CorruptionPossible() const {\n-        return corruptionPossible;\n-    }\n-    unsigned char GetRejectCode() const { return chRejectCode; }\n-    std::string GetRejectReason() const { return strRejectReason; }\n-};\n-\n /** RAII wrapper for VerifyDB: Verify consistency of the block and coin databases */\n class CVerifyDB {\n public:\n@@ -512,19 +475,4 @@ extern CCoinsViewCache *pcoinsTip;\n /** Global variable that points to the active block tree (protected by cs_main) */\n extern CBlockTreeDB *pblocktree;\n \n-\n-class CValidationInterface {\n-protected:\n-    virtual void SyncTransaction(const CTransaction &tx, const CBlock *pblock) {};\n-    virtual void EraseFromWallet(const uint256 &hash) {};\n-    virtual void SetBestChain(const CBlockLocator &locator) {};\n-    virtual void UpdatedTransaction(const uint256 &hash) {};\n-    virtual void Inventory(const uint256 &hash) {};\n-    virtual void ResendWalletTransactions() {};\n-    virtual void BlockChecked(const CBlock&, const CValidationState&) {};\n-    friend void ::RegisterValidationInterface(CValidationInterface*);\n-    friend void ::UnregisterValidationInterface(CValidationInterface*);\n-    friend void ::UnregisterAllValidationInterfaces();\n-};\n-\n #endif // BITCOIN_MAIN_H"
      },
      {
        "sha": "9f7de9e2e165d595b60e0540bd68ce9bc1acc997",
        "filename": "src/memusage.h",
        "status": "added",
        "additions": 111,
        "deletions": 0,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2015 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MEMUSAGE_H\n+#define BITCOIN_MEMUSAGE_H\n+\n+#include <stdlib.h>\n+\n+#include <map>\n+#include <set>\n+#include <vector>\n+\n+#include <boost/unordered_set.hpp>\n+#include <boost/unordered_map.hpp>\n+\n+namespace memusage\n+{\n+\n+/** Compute the total memory used by allocating alloc bytes. */\n+static size_t MallocUsage(size_t alloc);\n+\n+/** Compute the memory used for dynamically allocated but owned data structures.\n+ *  For generic data types, this is *not* recursive. DynamicUsage(vector<vector<int> >)\n+ *  will compute the memory used for the vector<int>'s, but not for the ints inside.\n+ *  This is for efficiency reasons, as these functions are intended to be fast. If\n+ *  application data structures require more accurate inner accounting, they should\n+ *  do the recursion themselves, or use more efficient caching + updating on modification.\n+ */\n+template<typename X> static size_t DynamicUsage(const std::vector<X>& v);\n+template<typename X> static size_t DynamicUsage(const std::set<X>& s);\n+template<typename X, typename Y> static size_t DynamicUsage(const std::map<X, Y>& m);\n+template<typename X, typename Y> static size_t DynamicUsage(const boost::unordered_set<X, Y>& s);\n+template<typename X, typename Y, typename Z> static size_t DynamicUsage(const boost::unordered_map<X, Y, Z>& s);\n+template<typename X> static size_t DynamicUsage(const X& x);\n+\n+static inline size_t MallocUsage(size_t alloc)\n+{\n+    // Measured on libc6 2.19 on Linux.\n+    if (sizeof(void*) == 8) {\n+        return ((alloc + 31) >> 4) << 4;\n+    } else if (sizeof(void*) == 4) {\n+        return ((alloc + 15) >> 3) << 3;\n+    } else {\n+        assert(0);\n+    }\n+}\n+\n+// STL data structures\n+\n+template<typename X>\n+struct stl_tree_node\n+{\n+private:\n+    int color;\n+    void* parent;\n+    void* left;\n+    void* right;\n+    X x;\n+};\n+\n+template<typename X>\n+static inline size_t DynamicUsage(const std::vector<X>& v)\n+{\n+    return MallocUsage(v.capacity() * sizeof(X));\n+}\n+\n+template<typename X>\n+static inline size_t DynamicUsage(const std::set<X>& s)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<X>)) * s.size();\n+}\n+\n+template<typename X, typename Y>\n+static inline size_t DynamicUsage(const std::map<X, Y>& m)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >)) * m.size();\n+}\n+\n+// Boost data structures\n+\n+template<typename X>\n+struct boost_unordered_node : private X\n+{\n+private:\n+    void* ptr;\n+};\n+\n+template<typename X, typename Y>\n+static inline size_t DynamicUsage(const boost::unordered_set<X, Y>& s)\n+{\n+    return MallocUsage(sizeof(boost_unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+}\n+\n+template<typename X, typename Y, typename Z>\n+static inline size_t DynamicUsage(const boost::unordered_map<X, Y, Z>& m)\n+{\n+    return MallocUsage(sizeof(boost_unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+}\n+\n+// Dispatch to class method as fallback\n+\n+template<typename X>\n+static inline size_t DynamicUsage(const X& x)\n+{\n+    return x.DynamicMemoryUsage();\n+}\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "4d90fd8cd7dfe6eb6036fb5718f201e8891a627e",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 3,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,7 +6,7 @@\n #include \"merkleblock.h\"\n \n #include \"hash.h\"\n-#include \"primitives/block.h\" // for MAX_BLOCK_SIZE\n+#include \"consensus/consensus.h\"\n #include \"utilstrencodings.h\"\n \n using namespace std;\n@@ -37,6 +37,29 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n     txn = CPartialMerkleTree(vHashes, vMatch);\n }\n \n+CMerkleBlock::CMerkleBlock(const CBlock& block, const std::set<uint256>& txids)\n+{\n+    header = block.GetBlockHeader();\n+\n+    vector<bool> vMatch;\n+    vector<uint256> vHashes;\n+\n+    vMatch.reserve(block.vtx.size());\n+    vHashes.reserve(block.vtx.size());\n+\n+    for (unsigned int i = 0; i < block.vtx.size(); i++)\n+    {\n+        const uint256& hash = block.vtx[i].GetHash();\n+        if (txids.count(hash))\n+            vMatch.push_back(true);\n+        else\n+            vMatch.push_back(false);\n+        vHashes.push_back(hash);\n+    }\n+\n+    txn = CPartialMerkleTree(vHashes, vMatch);\n+}\n+\n uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid) {\n     if (height == 0) {\n         // hash at height 0 is the txids themself\n@@ -96,8 +119,8 @@ uint256 CPartialMerkleTree::TraverseAndExtract(int height, unsigned int pos, uns\n         if (pos*2+1 < CalcTreeWidth(height-1)) {\n             right = TraverseAndExtract(height-1, pos*2+1, nBitsUsed, nHashUsed, vMatch);\n             if (right == left) {\n-                // If the left and right branch should never be identical as the transaction\n-                // hashes covered by them must be unique.\n+                // The left and right branches should never be identical, as the transaction\n+                // hashes covered by them must each be unique.\n                 fBad = true;\n             }\n         } else {"
      },
      {
        "sha": "904c22abc2b942f4a004c275b9a50f83327e93a3",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -104,7 +104,7 @@ class CPartialMerkleTree\n         }\n     }\n \n-    /** Construct a partial merkle tree from a list of transaction id's, and a mask that selects a subset of them */\n+    /** Construct a partial merkle tree from a list of transaction ids, and a mask that selects a subset of them */\n     CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n \n     CPartialMerkleTree();\n@@ -139,6 +139,11 @@ class CMerkleBlock\n      */\n     CMerkleBlock(const CBlock& block, CBloomFilter& filter);\n \n+    // Create from a CBlock, matching the txids in the set\n+    CMerkleBlock(const CBlock& block, const std::set<uint256>& txids);\n+\n+    CMerkleBlock() {}\n+\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>"
      },
      {
        "sha": "7a57b42e30b303d029237c58a55aeeedd5b2846d",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 57,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,16 +6,19 @@\n #include \"miner.h\"\n \n #include \"amount.h\"\n-#include \"primitives/transaction.h\"\n+#include \"chainparams.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n #include \"hash.h\"\n #include \"main.h\"\n #include \"net.h\"\n #include \"pow.h\"\n+#include \"primitives/transaction.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #ifdef ENABLE_WALLET\n-#include \"wallet.h\"\n+#include \"wallet/wallet.h\"\n #endif\n \n #include <boost/thread.hpp>\n@@ -78,17 +81,18 @@ class TxPriorityCompare\n     }\n };\n \n-void UpdateTime(CBlockHeader* pblock, const CBlockIndex* pindexPrev)\n+void UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n {\n     pblock->nTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n \n     // Updating time can change work required on testnet:\n-    if (Params().AllowMinDifficultyBlocks())\n-        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock);\n+    if (consensusParams.fPowAllowMinDifficultyBlocks)\n+        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, consensusParams);\n }\n \n CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n {\n+    const CChainParams& chainparams = Params();\n     // Create new block\n     auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n     if(!pblocktemplate.get())\n@@ -318,21 +322,21 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         LogPrintf(\"CreateNewBlock(): total size %u\\n\", nBlockSize);\n \n         // Compute final coinbase transaction.\n-        txNew.vout[0].nValue = GetBlockValue(nHeight, nFees);\n+        txNew.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n         txNew.vin[0].scriptSig = CScript() << nHeight << OP_0;\n         pblock->vtx[0] = txNew;\n         pblocktemplate->vTxFees[0] = -nFees;\n \n         // Fill in header\n         pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n-        UpdateTime(pblock, pindexPrev);\n-        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock);\n+        UpdateTime(pblock, Params().GetConsensus(), pindexPrev);\n+        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, Params().GetConsensus());\n         pblock->nNonce         = 0;\n         pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n \n         CValidationState state;\n         if (!TestBlockValidity(state, *pblock, pindexPrev, false, false))\n-            throw std::runtime_error(\"CreateNewBlock() : TestBlockValidity failed\");\n+            throw std::runtime_error(\"CreateNewBlock(): TestBlockValidity failed\");\n     }\n \n     return pblocktemplate.release();\n@@ -362,8 +366,6 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n //\n // Internal miner\n //\n-double dHashesPerSec = 0.0;\n-int64_t nHPSTimerStart = 0;\n \n //\n // ScanHash scans nonces looking for a hash with at least some zero bits.\n@@ -393,10 +395,8 @@ bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phas\n             return true;\n \n         // If nothing found after trying for a while, return -1\n-        if ((nNonce & 0xffff) == 0)\n-            return false;\n         if ((nNonce & 0xfff) == 0)\n-            boost::this_thread::interruption_point();\n+            return false;\n     }\n }\n \n@@ -419,7 +419,7 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n     {\n         LOCK(cs_main);\n         if (pblock->hashPrevBlock != chainActive.Tip()->GetBlockHash())\n-            return error(\"BitcoinMiner : generated block is stale\");\n+            return error(\"BitcoinMiner: generated block is stale\");\n     }\n \n     // Remove key from key pool\n@@ -434,7 +434,7 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n     // Process this block the same as if we had received it from another node\n     CValidationState state;\n     if (!ProcessNewBlock(state, NULL, pblock))\n-        return error(\"BitcoinMiner : ProcessNewBlock, block not accepted\");\n+        return error(\"BitcoinMiner: ProcessNewBlock, block not accepted\");\n \n     return true;\n }\n@@ -444,18 +444,27 @@ void static BitcoinMiner(CWallet *pwallet)\n     LogPrintf(\"BitcoinMiner started\\n\");\n     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n     RenameThread(\"bitcoin-miner\");\n+    const CChainParams& chainparams = Params();\n \n     // Each thread has its own key and counter\n     CReserveKey reservekey(pwallet);\n     unsigned int nExtraNonce = 0;\n \n     try {\n         while (true) {\n-            if (Params().MiningRequiresPeers()) {\n+            if (chainparams.MiningRequiresPeers()) {\n                 // Busy-wait for the network to come online so we don't waste time mining\n                 // on an obsolete chain. In regtest mode we expect to fly solo.\n-                while (vNodes.empty())\n+                do {\n+                    bool fvNodesEmpty;\n+                    {\n+                        LOCK(cs_vNodes);\n+                        fvNodesEmpty = vNodes.empty();\n+                    }\n+                    if (!fvNodesEmpty && !IsInitialBlockDownload())\n+                        break;\n                     MilliSleep(1000);\n+                } while (true);\n             }\n \n             //\n@@ -483,14 +492,9 @@ void static BitcoinMiner(CWallet *pwallet)\n             arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n             uint256 hash;\n             uint32_t nNonce = 0;\n-            uint32_t nOldNonce = 0;\n             while (true) {\n-                bool fFound = ScanHash(pblock, nNonce, &hash);\n-                uint32_t nHashesDone = nNonce - nOldNonce;\n-                nOldNonce = nNonce;\n-\n                 // Check if something found\n-                if (fFound)\n+                if (ScanHash(pblock, nNonce, &hash))\n                 {\n                     if (UintToArith256(hash) <= hashTarget)\n                     {\n@@ -505,46 +509,17 @@ void static BitcoinMiner(CWallet *pwallet)\n                         SetThreadPriority(THREAD_PRIORITY_LOWEST);\n \n                         // In regression test mode, stop mining after a block is found.\n-                        if (Params().MineBlocksOnDemand())\n+                        if (chainparams.MineBlocksOnDemand())\n                             throw boost::thread_interrupted();\n \n                         break;\n                     }\n                 }\n \n-                // Meter hashes/sec\n-                static int64_t nHashCounter;\n-                if (nHPSTimerStart == 0)\n-                {\n-                    nHPSTimerStart = GetTimeMillis();\n-                    nHashCounter = 0;\n-                }\n-                else\n-                    nHashCounter += nHashesDone;\n-                if (GetTimeMillis() - nHPSTimerStart > 4000)\n-                {\n-                    static CCriticalSection cs;\n-                    {\n-                        LOCK(cs);\n-                        if (GetTimeMillis() - nHPSTimerStart > 4000)\n-                        {\n-                            dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n-                            nHPSTimerStart = GetTimeMillis();\n-                            nHashCounter = 0;\n-                            static int64_t nLogTime;\n-                            if (GetTime() - nLogTime > 30 * 60)\n-                            {\n-                                nLogTime = GetTime();\n-                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n-                            }\n-                        }\n-                    }\n-                }\n-\n                 // Check for stop or if block needs to be rebuilt\n                 boost::this_thread::interruption_point();\n                 // Regtest mode doesn't require peers\n-                if (vNodes.empty() && Params().MiningRequiresPeers())\n+                if (vNodes.empty() && chainparams.MiningRequiresPeers())\n                     break;\n                 if (nNonce >= 0xffff0000)\n                     break;\n@@ -554,8 +529,8 @@ void static BitcoinMiner(CWallet *pwallet)\n                     break;\n \n                 // Update nTime every few seconds\n-                UpdateTime(pblock, pindexPrev);\n-                if (Params().AllowMinDifficultyBlocks())\n+                UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n+                if (chainparams.GetConsensus().fPowAllowMinDifficultyBlocks)\n                 {\n                     // Changing pblock->nTime can change work required on testnet:\n                     hashTarget.SetCompact(pblock->nBits);\n@@ -568,6 +543,11 @@ void static BitcoinMiner(CWallet *pwallet)\n         LogPrintf(\"BitcoinMiner terminated\\n\");\n         throw;\n     }\n+    catch (const std::runtime_error &e)\n+    {\n+        LogPrintf(\"BitcoinMiner runtime error: %s\\n\", e.what());\n+        return;\n+    }\n }\n \n void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads)"
      },
      {
        "sha": "96a6b70ecd7e66766156942dd0e0c5fb673d6334",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -14,6 +14,7 @@ class CBlockIndex;\n class CReserveKey;\n class CScript;\n class CWallet;\n+namespace Consensus { struct Params; };\n \n struct CBlockTemplate\n {\n@@ -29,9 +30,6 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn);\n CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey);\n /** Modify the extranonce in a block */\n void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n-void UpdateTime(CBlockHeader* block, const CBlockIndex* pindexPrev);\n-\n-extern double dHashesPerSec;\n-extern int64_t nHPSTimerStart;\n+void UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);\n \n #endif // BITCOIN_MINER_H"
      },
      {
        "sha": "398aa173bf1e3c788e35a388116becc16d7ba201",
        "filename": "src/mruset.h",
        "status": "modified",
        "additions": 16,
        "deletions": 20,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/mruset.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/mruset.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mruset.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,12 +1,12 @@\n-// Copyright (c) 2012 The Bitcoin Core developers\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_MRUSET_H\n #define BITCOIN_MRUSET_H\n \n-#include <deque>\n #include <set>\n+#include <vector>\n #include <utility>\n \n /** STL-like set container that only keeps the most recent N elements. */\n@@ -22,11 +22,13 @@ class mruset\n \n protected:\n     std::set<T> set;\n-    std::deque<T> queue;\n-    size_type nMaxSize;\n+    std::vector<iterator> order;\n+    size_type first_used;\n+    size_type first_unused;\n+    const size_type nMaxSize;\n \n public:\n-    mruset(size_type nMaxSizeIn = 0) { nMaxSize = nMaxSizeIn; }\n+    mruset(size_type nMaxSizeIn = 1) : nMaxSize(nMaxSizeIn) { clear(); }\n     iterator begin() const { return set.begin(); }\n     iterator end() const { return set.end(); }\n     size_type size() const { return set.size(); }\n@@ -36,7 +38,9 @@ class mruset\n     void clear()\n     {\n         set.clear();\n-        queue.clear();\n+        order.assign(nMaxSize, set.end());\n+        first_used = 0;\n+        first_unused = 0;\n     }\n     bool inline friend operator==(const mruset<T>& a, const mruset<T>& b) { return a.set == b.set; }\n     bool inline friend operator==(const mruset<T>& a, const std::set<T>& b) { return a.set == b; }\n@@ -45,25 +49,17 @@ class mruset\n     {\n         std::pair<iterator, bool> ret = set.insert(x);\n         if (ret.second) {\n-            if (nMaxSize && queue.size() == nMaxSize) {\n-                set.erase(queue.front());\n-                queue.pop_front();\n+            if (set.size() == nMaxSize + 1) {\n+                set.erase(order[first_used]);\n+                order[first_used] = set.end();\n+                if (++first_used == nMaxSize) first_used = 0;\n             }\n-            queue.push_back(x);\n+            order[first_unused] = ret.first;\n+            if (++first_unused == nMaxSize) first_unused = 0;\n         }\n         return ret;\n     }\n     size_type max_size() const { return nMaxSize; }\n-    size_type max_size(size_type s)\n-    {\n-        if (s)\n-            while (queue.size() > s) {\n-                set.erase(queue.front());\n-                queue.pop_front();\n-            }\n-        nMaxSize = s;\n-        return nMaxSize;\n-    }\n };\n \n #endif // BITCOIN_MRUSET_H"
      },
      {
        "sha": "6849d792633c8ff95042eba82ed63273aa6096c0",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 23,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -13,7 +13,9 @@\n #include \"chainparams.h\"\n #include \"clientversion.h\"\n #include \"primitives/transaction.h\"\n+#include \"scheduler.h\"\n #include \"ui_interface.h\"\n+#include \"crypto/common.h\"\n \n #ifdef WIN32\n #include <string.h>\n@@ -99,6 +101,7 @@ NodeId nLastNodeId = 0;\n CCriticalSection cs_nLastNodeId;\n \n static CSemaphore *semOutbound = NULL;\n+boost::condition_variable messageHandlerCondition;\n \n // Signals for message handling\n static CNodeSignals g_signals;\n@@ -140,6 +143,27 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     return nBestScore >= 0;\n }\n \n+//! Convert the pnSeeds6 array into usable address objects.\n+static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn)\n+{\n+    // It'll only connect to one or two seed nodes because once it connects,\n+    // it'll get a pile of addresses with newer timestamps.\n+    // Seed nodes are given a random 'last seen time' of between one and two\n+    // weeks ago.\n+    const int64_t nOneWeek = 7*24*60*60;\n+    std::vector<CAddress> vSeedsOut;\n+    vSeedsOut.reserve(vSeedsIn.size());\n+    for (std::vector<SeedSpec6>::const_iterator i(vSeedsIn.begin()); i != vSeedsIn.end(); ++i)\n+    {\n+        struct in6_addr ip;\n+        memcpy(&ip, i->addr, sizeof(ip));\n+        CAddress addr(CService(ip, i->port));\n+        addr.nTime = GetTime() - GetRand(nOneWeek) - nOneWeek;\n+        vSeedsOut.push_back(addr);\n+    }\n+    return vSeedsOut;\n+}\n+\n // get best local address for a particular peer as a CAddress\n // Otherwise, return the unroutable 0.0.0.0 but filled in with\n // the normal parameters, since the IP may be changed to a useful\n@@ -509,7 +533,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n         // get current incomplete message, or create a new one\n         if (vRecvMsg.empty() ||\n             vRecvMsg.back().complete())\n-            vRecvMsg.push_back(CNetMessage(SER_NETWORK, nRecvVersion));\n+            vRecvMsg.push_back(CNetMessage(Params().MessageStart(), SER_NETWORK, nRecvVersion));\n \n         CNetMessage& msg = vRecvMsg.back();\n \n@@ -523,11 +547,18 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n         if (handled < 0)\n                 return false;\n \n+        if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n+            LogPrint(\"net\", \"Oversized message from peer=%i, disconnecting\", GetId());\n+            return false;\n+        }\n+\n         pch += handled;\n         nBytes -= handled;\n \n-        if (msg.complete())\n+        if (msg.complete()) {\n             msg.nTime = GetTimeMicros();\n+            messageHandlerCondition.notify_one();\n+        }\n     }\n \n     return true;\n@@ -1020,7 +1051,7 @@ void ThreadMapPort()\n         catch (const boost::thread_interrupted&)\n         {\n             r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n-            LogPrintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+            LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n             freeUPNPDevlist(devlist); devlist = 0;\n             FreeUPNPUrls(&urls);\n             throw;\n@@ -1186,7 +1217,7 @@ void ThreadOpenConnections()\n             static bool done = false;\n             if (!done) {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n-                addrman.Add(Params().FixedSeeds(), CNetAddr(\"127.0.0.1\"));\n+                addrman.Add(convertSeed6(Params().FixedSeeds()), CNetAddr(\"127.0.0.1\"));\n                 done = true;\n             }\n         }\n@@ -1215,8 +1246,7 @@ void ThreadOpenConnections()\n         int nTries = 0;\n         while (true)\n         {\n-            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n-            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n+            CAddrInfo addr = addrman.Select();\n \n             // if we selected an invalid address, restart\n             if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n@@ -1353,6 +1383,9 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n \n void ThreadMessageHandler()\n {\n+    boost::mutex condition_mutex;\n+    boost::unique_lock<boost::mutex> lock(condition_mutex);\n+    \n     SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n     while (true)\n     {\n@@ -1400,7 +1433,7 @@ void ThreadMessageHandler()\n             {\n                 TRY_LOCK(pnode->cs_vSend, lockSend);\n                 if (lockSend)\n-                    g_signals.SendMessages(pnode, pnode == pnodeTrickle);\n+                    g_signals.SendMessages(pnode, pnode == pnodeTrickle || pnode->fWhitelisted);\n             }\n             boost::this_thread::interruption_point();\n         }\n@@ -1412,7 +1445,7 @@ void ThreadMessageHandler()\n         }\n \n         if (fSleep)\n-            MilliSleep(100);\n+            messageHandlerCondition.timed_wait(lock, boost::posix_time::microsec_clock::universal_time() + boost::posix_time::milliseconds(100));\n     }\n }\n \n@@ -1558,7 +1591,7 @@ void static Discover(boost::thread_group& threadGroup)\n #endif\n }\n \n-void StartNode(boost::thread_group& threadGroup)\n+void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler)\n {\n     uiInterface.InitMessage(_(\"Loading addresses...\"));\n     // Load addresses for peers.dat\n@@ -1608,7 +1641,7 @@ void StartNode(boost::thread_group& threadGroup)\n     threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"msghand\", &ThreadMessageHandler));\n \n     // Dump network addresses\n-    threadGroup.create_thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses, DUMP_ADDRESSES_INTERVAL * 1000));\n+    scheduler.scheduleEvery(&DumpAddresses, DUMP_ADDRESSES_INTERVAL);\n }\n \n bool StopNode()\n@@ -1797,21 +1830,21 @@ bool CAddrDB::Write(const CAddrMan& addr)\n     FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n     CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n-        return error(\"%s : Failed to open file %s\", __func__, pathTmp.string());\n+        return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n \n     // Write and commit header, data\n     try {\n         fileout << ssPeers;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Serialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n     }\n     FileCommit(fileout.Get());\n     fileout.fclose();\n \n     // replace existing peers.dat, if any, with new peers.dat.XXXX\n     if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"%s : Rename-into-place failed\", __func__);\n+        return error(\"%s: Rename-into-place failed\", __func__);\n \n     return true;\n }\n@@ -1822,7 +1855,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n     FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n     CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n-        return error(\"%s : Failed to open file %s\", __func__, pathAddr.string());\n+        return error(\"%s: Failed to open file %s\", __func__, pathAddr.string());\n \n     // use file size to size memory buffer\n     int fileSize = boost::filesystem::file_size(pathAddr);\n@@ -1840,7 +1873,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n         filein >> hashIn;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n     filein.fclose();\n \n@@ -1849,7 +1882,7 @@ bool CAddrDB::Read(CAddrMan& addr)\n     // verify stored checksum matches input data\n     uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n     if (hashIn != hashTmp)\n-        return error(\"%s : Checksum mismatch, data corrupted\", __func__);\n+        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n \n     unsigned char pchMsgTmp[4];\n     try {\n@@ -1858,13 +1891,13 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"%s : Invalid network magic number\", __func__);\n+            return error(\"%s: Invalid network magic number\", __func__);\n \n         // de-serialize address data into one CAddrMan object\n         ssPeers >> addr;\n     }\n     catch (const std::exception& e) {\n-        return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     return true;\n@@ -1873,7 +1906,10 @@ bool CAddrDB::Read(CAddrMan& addr)\n unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }\n \n-CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), setAddrKnown(5000)\n+CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) :\n+    ssSend(SER_NETWORK, INIT_PROTO_VERSION),\n+    addrKnown(5000, 0.001, insecure_rand()),\n+    setInventoryKnown(SendBufferSize() / 1000)\n {\n     nServices = 0;\n     hSocket = hSocketIn;\n@@ -1902,7 +1938,6 @@ CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fIn\n     nStartingHeight = -1;\n     fGetAddr = false;\n     fRelayTxes = false;\n-    setInventoryKnown.max_size(SendBufferSize() / 1000);\n     pfilter = new CBloomFilter();\n     nPingNonceSent = 0;\n     nPingUsecStart = 0;\n@@ -1970,8 +2005,8 @@ void CNode::BeginMessage(const char* pszCommand) EXCLUSIVE_LOCK_FUNCTION(cs_vSen\n {\n     ENTER_CRITICAL_SECTION(cs_vSend);\n     assert(ssSend.size() == 0);\n-    ssSend << CMessageHeader(pszCommand, 0);\n-    LogPrint(\"net\", \"sending: %s \", pszCommand);\n+    ssSend << CMessageHeader(Params().MessageStart(), pszCommand, 0);\n+    LogPrint(\"net\", \"sending: %s \", SanitizeString(pszCommand));\n }\n \n void CNode::AbortMessage() UNLOCK_FUNCTION(cs_vSend)\n@@ -2002,7 +2037,7 @@ void CNode::EndMessage() UNLOCK_FUNCTION(cs_vSend)\n \n     // Set the size\n     unsigned int nSize = ssSend.size() - CMessageHeader::HEADER_SIZE;\n-    memcpy((char*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], &nSize, sizeof(nSize));\n+    WriteLE32((uint8_t*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n \n     // Set the checksum\n     uint256 hash = Hash(ssSend.begin() + CMessageHeader::HEADER_SIZE, ssSend.end());"
      },
      {
        "sha": "17502b97ebead019c0482fa6ee7008c0a05fce7b",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 27,
        "deletions": 12,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -32,6 +32,7 @@\n \n class CAddrMan;\n class CBlockIndex;\n+class CScheduler;\n class CNode;\n \n namespace boost {\n@@ -46,6 +47,8 @@ static const int TIMEOUT_INTERVAL = 20 * 60;\n static const unsigned int MAX_INV_SZ = 50000;\n /** The maximum number of new addresses to accumulate before announcing. */\n static const unsigned int MAX_ADDR_TO_SEND = 1000;\n+/** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n /** -listen default */\n static const bool DEFAULT_LISTEN = true;\n /** -upnp default */\n@@ -70,18 +73,33 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n void MapPort(bool fUseUPnP);\n unsigned short GetListenPort();\n bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n-void StartNode(boost::thread_group& threadGroup);\n+void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler);\n bool StopNode();\n void SocketSendData(CNode *pnode);\n \n typedef int NodeId;\n \n+struct CombinerAll\n+{\n+    typedef bool result_type;\n+\n+    template<typename I>\n+    bool operator()(I first, I last) const\n+    {\n+        while (first != last) {\n+            if (!(*first)) return false;\n+            ++first;\n+        }\n+        return true;\n+    }\n+};\n+\n // Signals for message handling\n struct CNodeSignals\n {\n     boost::signals2::signal<int ()> GetHeight;\n-    boost::signals2::signal<bool (CNode*)> ProcessMessages;\n-    boost::signals2::signal<bool (CNode*, bool)> SendMessages;\n+    boost::signals2::signal<bool (CNode*), CombinerAll> ProcessMessages;\n+    boost::signals2::signal<bool (CNode*, bool), CombinerAll> SendMessages;\n     boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;\n     boost::signals2::signal<void (NodeId)> FinalizeNode;\n };\n@@ -183,7 +201,7 @@ class CNetMessage {\n \n     int64_t nTime;                  // time (in microseconds) of message receipt.\n \n-    CNetMessage(int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn) {\n+    CNetMessage(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), hdr(pchMessageStartIn), vRecv(nTypeIn, nVersionIn) {\n         hdrbuf.resize(24);\n         in_data = false;\n         nHdrPos = 0;\n@@ -254,8 +272,8 @@ class CNode\n     bool fDisconnect;\n     // We use fRelayTxes for two purposes -\n     // a) it allows us to not relay tx invs before receiving the peer's version message\n-    // b) the peer may tell us in their version message that we should not relay tx invs\n-    //    until they have initialized their bloom filter.\n+    // b) the peer may tell us in its version message that we should not relay tx invs\n+    //    until it has initialized its bloom filter.\n     bool fRelayTxes;\n     CSemaphoreGrant grantOutbound;\n     CCriticalSection cs_filter;\n@@ -283,7 +301,7 @@ class CNode\n \n     // flood relay\n     std::vector<CAddress> vAddrToSend;\n-    mruset<CAddress> setAddrKnown;\n+    CRollingBloomFilter addrKnown;\n     bool fGetAddr;\n     std::set<uint256> setKnown;\n \n@@ -363,15 +381,15 @@ class CNode\n \n     void AddAddressKnown(const CAddress& addr)\n     {\n-        setAddrKnown.insert(addr);\n+        addrKnown.insert(addr.GetKey());\n     }\n \n     void PushAddress(const CAddress& addr)\n     {\n         // Known checking here is only to save space from duplicates.\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n-        if (addr.IsValid() && !setAddrKnown.count(addr)) {\n+        if (addr.IsValid() && !addrKnown.contains(addr.GetKey())) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n                 vAddrToSend[insecure_rand() % vAddrToSend.size()] = addr;\n             } else {\n@@ -570,9 +588,6 @@ class CNode\n         }\n     }\n \n-    bool IsSubscribed(unsigned int nChannel);\n-    void Subscribe(unsigned int nChannel, unsigned int nHops=0);\n-    void CancelSubscribe(unsigned int nChannel);\n     void CloseSocketDisconnect();\n \n     // Denial-of-service detection/prevention"
      },
      {
        "sha": "41cc18d3cd80c10e126cceb0c501644088537763",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 115,
        "deletions": 75,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -12,6 +12,7 @@\n #include \"hash.h\"\n #include \"sync.h\"\n #include \"uint256.h\"\n+#include \"random.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n@@ -38,7 +39,7 @@ using namespace std;\n \n // Settings\n static proxyType proxyInfo[NET_MAX];\n-static CService nameProxy;\n+static proxyType nameProxy;\n static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n bool fNameLookup = false;\n@@ -285,59 +286,100 @@ bool static InterruptibleRecv(char* data, size_t len, int timeout, SOCKET& hSock\n     return len == 0;\n }\n \n-bool static Socks5(string strDest, int port, SOCKET& hSocket)\n+struct ProxyCredentials\n+{\n+    std::string username;\n+    std::string password;\n+};\n+\n+/** Connect using SOCKS5 (as described in RFC1928) */\n+static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, SOCKET& hSocket)\n {\n     LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n-    if (strDest.size() > 255)\n-    {\n+    if (strDest.size() > 255) {\n         CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n     }\n-    char pszSocks5Init[] = \"\\5\\1\\0\";\n-    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n-\n-    ssize_t ret = send(hSocket, pszSocks5Init, nSize, MSG_NOSIGNAL);\n-    if (ret != nSize)\n-    {\n+    // Accepted authentication methods\n+    std::vector<uint8_t> vSocks5Init;\n+    vSocks5Init.push_back(0x05);\n+    if (auth) {\n+        vSocks5Init.push_back(0x02); // # METHODS\n+        vSocks5Init.push_back(0x00); // X'00' NO AUTHENTICATION REQUIRED\n+        vSocks5Init.push_back(0x02); // X'02' USERNAME/PASSWORD (RFC1929)\n+    } else {\n+        vSocks5Init.push_back(0x01); // # METHODS\n+        vSocks5Init.push_back(0x00); // X'00' NO AUTHENTICATION REQUIRED\n+    }\n+    ssize_t ret = send(hSocket, (const char*)begin_ptr(vSocks5Init), vSocks5Init.size(), MSG_NOSIGNAL);\n+    if (ret != (ssize_t)vSocks5Init.size()) {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet1[2];\n-    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n-    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n-    {\n+    if (pchRet1[0] != 0x05) {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to initialize\");\n     }\n-    string strSocks5(\"\\5\\1\");\n-    strSocks5 += '\\000'; strSocks5 += '\\003';\n-    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n-    strSocks5 += strDest;\n-    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n-    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n-    ret = send(hSocket, strSocks5.data(), strSocks5.size(), MSG_NOSIGNAL);\n-    if (ret != (ssize_t)strSocks5.size())\n-    {\n+    if (pchRet1[1] == 0x02 && auth) {\n+        // Perform username/password authentication (as described in RFC1929)\n+        std::vector<uint8_t> vAuth;\n+        vAuth.push_back(0x01);\n+        if (auth->username.size() > 255 || auth->password.size() > 255)\n+            return error(\"Proxy username or password too long\");\n+        vAuth.push_back(auth->username.size());\n+        vAuth.insert(vAuth.end(), auth->username.begin(), auth->username.end());\n+        vAuth.push_back(auth->password.size());\n+        vAuth.insert(vAuth.end(), auth->password.begin(), auth->password.end());\n+        ret = send(hSocket, (const char*)begin_ptr(vAuth), vAuth.size(), MSG_NOSIGNAL);\n+        if (ret != (ssize_t)vAuth.size()) {\n+            CloseSocket(hSocket);\n+            return error(\"Error sending authentication to proxy\");\n+        }\n+        LogPrint(\"proxy\", \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n+        char pchRetA[2];\n+        if (!InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n+            CloseSocket(hSocket);\n+            return error(\"Error reading proxy authentication response\");\n+        }\n+        if (pchRetA[0] != 0x01 || pchRetA[1] != 0x00) {\n+            CloseSocket(hSocket);\n+            return error(\"Proxy authentication unsuccesful\");\n+        }\n+    } else if (pchRet1[1] == 0x00) {\n+        // Perform no authentication\n+    } else {\n+        CloseSocket(hSocket);\n+        return error(\"Proxy requested wrong authentication method %02x\", pchRet1[1]);\n+    }\n+    std::vector<uint8_t> vSocks5;\n+    vSocks5.push_back(0x05); // VER protocol version\n+    vSocks5.push_back(0x01); // CMD CONNECT\n+    vSocks5.push_back(0x00); // RSV Reserved\n+    vSocks5.push_back(0x03); // ATYP DOMAINNAME\n+    vSocks5.push_back(strDest.size()); // Length<=255 is checked at beginning of function\n+    vSocks5.insert(vSocks5.end(), strDest.begin(), strDest.end());\n+    vSocks5.push_back((port >> 8) & 0xFF);\n+    vSocks5.push_back((port >> 0) & 0xFF);\n+    ret = send(hSocket, (const char*)begin_ptr(vSocks5), vSocks5.size(), MSG_NOSIGNAL);\n+    if (ret != (ssize_t)vSocks5.size()) {\n         CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet2[4];\n-    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n-    if (pchRet2[0] != 0x05)\n-    {\n+    if (pchRet2[0] != 0x05) {\n         CloseSocket(hSocket);\n         return error(\"Proxy failed to accept request\");\n     }\n-    if (pchRet2[1] != 0x00)\n-    {\n+    if (pchRet2[1] != 0x00) {\n         CloseSocket(hSocket);\n         switch (pchRet2[1])\n         {\n@@ -352,8 +394,7 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n             default:   return error(\"Proxy error: unknown\");\n         }\n     }\n-    if (pchRet2[2] != 0x00)\n-    {\n+    if (pchRet2[2] != 0x00) {\n         CloseSocket(hSocket);\n         return error(\"Error: malformed proxy response\");\n     }\n@@ -375,13 +416,11 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         }\n         default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n     }\n-    if (!ret)\n-    {\n+    if (!ret) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket))\n-    {\n+    if (!InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) {\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n@@ -471,7 +510,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     return true;\n }\n \n-bool SetProxy(enum Network net, CService addrProxy) {\n+bool SetProxy(enum Network net, const proxyType &addrProxy) {\n     assert(net >= 0 && net < NET_MAX);\n     if (!addrProxy.IsValid())\n         return false;\n@@ -489,15 +528,15 @@ bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     return true;\n }\n \n-bool SetNameProxy(CService addrProxy) {\n+bool SetNameProxy(const proxyType &addrProxy) {\n     if (!addrProxy.IsValid())\n         return false;\n     LOCK(cs_proxyInfos);\n     nameProxy = addrProxy;\n     return true;\n }\n \n-bool GetNameProxy(CService &nameProxyOut) {\n+bool GetNameProxy(proxyType &nameProxyOut) {\n     LOCK(cs_proxyInfos);\n     if(!nameProxy.IsValid())\n         return false;\n@@ -513,37 +552,49 @@ bool HaveNameProxy() {\n bool IsProxy(const CNetAddr &addr) {\n     LOCK(cs_proxyInfos);\n     for (int i = 0; i < NET_MAX; i++) {\n-        if (addr == (CNetAddr)proxyInfo[i])\n+        if (addr == (CNetAddr)proxyInfo[i].proxy)\n             return true;\n     }\n     return false;\n }\n \n-bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed)\n+static bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed)\n {\n-    proxyType proxy;\n-    if (outProxyConnectionFailed)\n-        *outProxyConnectionFailed = false;\n-    // no proxy needed (none set for target network)\n-    if (!GetProxy(addrDest.GetNetwork(), proxy))\n-        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n-\n     SOCKET hSocket = INVALID_SOCKET;\n-\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy, hSocket, nTimeout)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, hSocket, nTimeout)) {\n         if (outProxyConnectionFailed)\n             *outProxyConnectionFailed = true;\n         return false;\n     }\n     // do socks negotiation\n-    if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n-        return false;\n+    if (proxy.randomize_credentials) {\n+        ProxyCredentials random_auth;\n+        random_auth.username = strprintf(\"%i\", insecure_rand());\n+        random_auth.password = strprintf(\"%i\", insecure_rand());\n+        if (!Socks5(strDest, (unsigned short)port, &random_auth, hSocket))\n+            return false;\n+    } else {\n+        if (!Socks5(strDest, (unsigned short)port, 0, hSocket))\n+            return false;\n+    }\n \n     hSocketRet = hSocket;\n     return true;\n }\n \n+bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed)\n+{\n+    proxyType proxy;\n+    if (outProxyConnectionFailed)\n+        *outProxyConnectionFailed = false;\n+\n+    if (GetProxy(addrDest.GetNetwork(), proxy))\n+        return ConnectThroughProxy(proxy, addrDest.ToStringIP(), addrDest.GetPort(), hSocketRet, nTimeout, outProxyConnectionFailed);\n+    else // no proxy needed (none set for target network)\n+        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n+}\n+\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout, bool *outProxyConnectionFailed)\n {\n     string strDest;\n@@ -554,9 +605,7 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n \n     SplitHostPort(string(pszDest), port, strDest);\n \n-    SOCKET hSocket = INVALID_SOCKET;\n-\n-    CService nameProxy;\n+    proxyType nameProxy;\n     GetNameProxy(nameProxy);\n \n     CService addrResolved(CNetAddr(strDest, fNameLookup && !HaveNameProxy()), port);\n@@ -569,18 +618,7 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n \n     if (!HaveNameProxy())\n         return false;\n-    // first connect to name proxy server\n-    if (!ConnectSocketDirectly(nameProxy, hSocket, nTimeout)) {\n-        if (outProxyConnectionFailed)\n-            *outProxyConnectionFailed = true;\n-        return false;\n-    }\n-    // do socks negotiation\n-    if (!Socks5(strDest, (unsigned short)port, hSocket))\n-        return false;\n-\n-    hSocketRet = hSocket;\n-    return true;\n+    return ConnectThroughProxy(nameProxy, strDest, port, hSocketRet, nTimeout, outProxyConnectionFailed);\n }\n \n void CNetAddr::Init()\n@@ -1214,15 +1252,15 @@ CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n             std::string strNetmask = strSubnet.substr(slash + 1);\n             int32_t n;\n             // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-            int noffset = network.IsIPv4() ? (12 * 8) : 0;\n+            const int astartofs = network.IsIPv4() ? 12 : 0;\n             if (ParseInt32(strNetmask, &n)) // If valid number, assume /24 symtex\n             {\n-                if(n >= 0 && n <= (128 - noffset)) // Only valid if in range of bits of address\n+                if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n                 {\n-                    n += noffset;\n+                    n += astartofs*8;\n                     // Clear bits [n..127]\n                     for (; n < 128; ++n)\n-                        netmask[n>>3] &= ~(1<<(n&7));\n+                        netmask[n>>3] &= ~(1<<(7-(n&7)));\n                 }\n                 else\n                 {\n@@ -1233,12 +1271,10 @@ CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n             {\n                 if (LookupHost(strNetmask.c_str(), vIP, 1, false)) // Never allow lookup for netmask\n                 {\n-                    // Remember: GetByte returns bytes in reversed order\n                     // Copy only the *last* four bytes in case of IPv4, the rest of the mask should stay 1's as\n                     // we don't want pchIPv4 to be part of the mask.\n-                    int asize = network.IsIPv4() ? 4 : 16;\n-                    for(int x=0; x<asize; ++x)\n-                        netmask[15-x] = vIP[0].GetByte(x);\n+                    for(int x=astartofs; x<16; ++x)\n+                        netmask[x] = vIP[0].ip[x];\n                 }\n                 else\n                 {\n@@ -1251,14 +1287,18 @@ CSubNet::CSubNet(const std::string &strSubnet, bool fAllowLookup)\n     {\n         valid = false;\n     }\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n }\n \n bool CSubNet::Match(const CNetAddr &addr) const\n {\n     if (!valid || !addr.IsValid())\n         return false;\n     for(int x=0; x<16; ++x)\n-        if ((addr.GetByte(x) & netmask[15-x]) != network.GetByte(x))\n+        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n             return false;\n     return true;\n }"
      },
      {
        "sha": "1f2957116e3ed561cc420f879a2df1ab780357c0",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -100,6 +100,8 @@ class CNetAddr\n         inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n             READWRITE(FLATDATA(ip));\n         }\n+\n+        friend class CSubNet;\n };\n \n class CSubNet\n@@ -162,21 +164,31 @@ class CService : public CNetAddr\n         inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n             READWRITE(FLATDATA(ip));\n             unsigned short portN = htons(port);\n-            READWRITE(portN);\n+            READWRITE(FLATDATA(portN));\n             if (ser_action.ForRead())\n                  port = ntohs(portN);\n         }\n };\n \n-typedef CService proxyType;\n+class proxyType\n+{\n+public:\n+    proxyType(): randomize_credentials(false) {}\n+    proxyType(const CService &proxy, bool randomize_credentials=false): proxy(proxy), randomize_credentials(randomize_credentials) {}\n+\n+    bool IsValid() const { return proxy.IsValid(); }\n+\n+    CService proxy;\n+    bool randomize_credentials;\n+};\n \n enum Network ParseNetwork(std::string net);\n std::string GetNetworkName(enum Network net);\n void SplitHostPort(std::string in, int &portOut, std::string &hostOut);\n-bool SetProxy(enum Network net, CService addrProxy);\n+bool SetProxy(enum Network net, const proxyType &addrProxy);\n bool GetProxy(enum Network net, proxyType &proxyInfoOut);\n bool IsProxy(const CNetAddr &addr);\n-bool SetNameProxy(CService addrProxy);\n+bool SetNameProxy(const proxyType &addrProxy);\n bool HaveNameProxy();\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions = 0, bool fAllowLookup = true);\n bool Lookup(const char *pszName, CService& addr, int portDefault = 0, bool fAllowLookup = true);"
      },
      {
        "sha": "b1491cec018fc3e18ee591eb126b9280a37b8ee1",
        "filename": "src/policy/fees.cpp",
        "status": "added",
        "additions": 529,
        "deletions": 0,
        "changes": 529,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"policy/fees.h\"\n+\n+#include \"amount.h\"\n+#include \"primitives/transaction.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,\n+                                unsigned int maxConfirms, double _decay, std::string _dataTypeString)\n+{\n+    decay = _decay;\n+    dataTypeString = _dataTypeString;\n+    for (unsigned int i = 0; i < defaultBuckets.size(); i++) {\n+        buckets.push_back(defaultBuckets[i]);\n+        bucketMap[defaultBuckets[i]] = i;\n+    }\n+    confAvg.resize(maxConfirms);\n+    curBlockConf.resize(maxConfirms);\n+    unconfTxs.resize(maxConfirms);\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        confAvg[i].resize(buckets.size());\n+        curBlockConf[i].resize(buckets.size());\n+        unconfTxs[i].resize(buckets.size());\n+    }\n+\n+    oldUnconfTxs.resize(buckets.size());\n+    curBlockTxCt.resize(buckets.size());\n+    txCtAvg.resize(buckets.size());\n+    curBlockVal.resize(buckets.size());\n+    avg.resize(buckets.size());\n+}\n+\n+// Zero out the data for the current block\n+void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)\n+{\n+    for (unsigned int j = 0; j < buckets.size(); j++) {\n+        oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];\n+        unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;\n+        for (unsigned int i = 0; i < curBlockConf.size(); i++)\n+            curBlockConf[i][j] = 0;\n+        curBlockTxCt[j] = 0;\n+        curBlockVal[j] = 0;\n+    }\n+}\n+\n+\n+void TxConfirmStats::Record(int blocksToConfirm, double val)\n+{\n+    // blocksToConfirm is 1-based\n+    if (blocksToConfirm < 1)\n+        return;\n+    unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n+    for (size_t i = blocksToConfirm; i <= curBlockConf.size(); i++) {\n+        curBlockConf[i - 1][bucketindex]++;\n+    }\n+    curBlockTxCt[bucketindex]++;\n+    curBlockVal[bucketindex] += val;\n+}\n+\n+void TxConfirmStats::UpdateMovingAverages()\n+{\n+    for (unsigned int j = 0; j < buckets.size(); j++) {\n+        for (unsigned int i = 0; i < confAvg.size(); i++)\n+            confAvg[i][j] = confAvg[i][j] * decay + curBlockConf[i][j];\n+        avg[j] = avg[j] * decay + curBlockVal[j];\n+        txCtAvg[j] = txCtAvg[j] * decay + curBlockTxCt[j];\n+    }\n+}\n+\n+// returns -1 on error conditions\n+double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                                         double successBreakPoint, bool requireGreater,\n+                                         unsigned int nBlockHeight)\n+{\n+    // Counters for a bucket (or range of buckets)\n+    double nConf = 0; // Number of tx's confirmed within the confTarget\n+    double totalNum = 0; // Total number of tx's that were ever confirmed\n+    int extraNum = 0;  // Number of tx's still in mempool for confTarget or longer\n+\n+    int maxbucketindex = buckets.size() - 1;\n+\n+    // requireGreater means we are looking for the lowest fee/priority such that all higher\n+    // values pass, so we start at maxbucketindex (highest fee) and look at succesively\n+    // smaller buckets until we reach failure.  Otherwise, we are looking for the highest\n+    // fee/priority such that all lower values fail, and we go in the opposite direction.\n+    unsigned int startbucket = requireGreater ? maxbucketindex : 0;\n+    int step = requireGreater ? -1 : 1;\n+\n+    // We'll combine buckets until we have enough samples.\n+    // The near and far variables will define the range we've combined\n+    // The best variables are the last range we saw which still had a high\n+    // enough confirmation rate to count as success.\n+    // The cur variables are the current range we're counting.\n+    unsigned int curNearBucket = startbucket;\n+    unsigned int bestNearBucket = startbucket;\n+    unsigned int curFarBucket = startbucket;\n+    unsigned int bestFarBucket = startbucket;\n+\n+    bool foundAnswer = false;\n+    unsigned int bins = unconfTxs.size();\n+\n+    // Start counting from highest(default) or lowest fee/pri transactions\n+    for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {\n+        curFarBucket = bucket;\n+        nConf += confAvg[confTarget - 1][bucket];\n+        totalNum += txCtAvg[bucket];\n+        for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)\n+            extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];\n+        extraNum += oldUnconfTxs[bucket];\n+        // If we have enough transaction data points in this range of buckets,\n+        // we can test for success\n+        // (Only count the confirmed data points, so that each confirmation count\n+        // will be looking at the same amount of data and same bucket breaks)\n+        if (totalNum >= sufficientTxVal / (1 - decay)) {\n+            double curPct = nConf / (totalNum + extraNum);\n+\n+            // Check to see if we are no longer getting confirmed at the success rate\n+            if (requireGreater && curPct < successBreakPoint)\n+                break;\n+            if (!requireGreater && curPct > successBreakPoint)\n+                break;\n+\n+            // Otherwise update the cumulative stats, and the bucket variables\n+            // and reset the counters\n+            else {\n+                foundAnswer = true;\n+                nConf = 0;\n+                totalNum = 0;\n+                extraNum = 0;\n+                bestNearBucket = curNearBucket;\n+                bestFarBucket = curFarBucket;\n+                curNearBucket = bucket + step;\n+            }\n+        }\n+    }\n+\n+    double median = -1;\n+    double txSum = 0;\n+\n+    // Calculate the \"average\" fee of the best bucket range that met success conditions\n+    // Find the bucket with the median transaction and then report the average fee from that bucket\n+    // This is a compromise between finding the median which we can't since we don't save all tx's\n+    // and reporting the average which is less accurate\n+    unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;\n+    unsigned int maxBucket = bestNearBucket > bestFarBucket ? bestNearBucket : bestFarBucket;\n+    for (unsigned int j = minBucket; j <= maxBucket; j++) {\n+        txSum += txCtAvg[j];\n+    }\n+    if (foundAnswer && txSum != 0) {\n+        txSum = txSum / 2;\n+        for (unsigned int j = minBucket; j <= maxBucket; j++) {\n+            if (txCtAvg[j] < txSum)\n+                txSum -= txCtAvg[j];\n+            else { // we're in the right bucket\n+                median = avg[j] / txCtAvg[j];\n+                break;\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"estimatefee\", \"%3d: For conf success %s %4.2f need %s %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n+             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint, dataTypeString,\n+             requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n+             100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n+\n+    return median;\n+}\n+\n+void TxConfirmStats::Write(CAutoFile& fileout)\n+{\n+    fileout << decay;\n+    fileout << buckets;\n+    fileout << avg;\n+    fileout << txCtAvg;\n+    fileout << confAvg;\n+}\n+\n+void TxConfirmStats::Read(CAutoFile& filein)\n+{\n+    // Read data file into temporary variables and do some very basic sanity checking\n+    std::vector<double> fileBuckets;\n+    std::vector<double> fileAvg;\n+    std::vector<std::vector<double> > fileConfAvg;\n+    std::vector<double> fileTxCtAvg;\n+    double fileDecay;\n+    size_t maxConfirms;\n+    size_t numBuckets;\n+\n+    filein >> fileDecay;\n+    if (fileDecay <= 0 || fileDecay >= 1)\n+        throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+    filein >> fileBuckets;\n+    numBuckets = fileBuckets.size();\n+    if (numBuckets <= 1 || numBuckets > 1000)\n+        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 fee/pri buckets\");\n+    filein >> fileAvg;\n+    if (fileAvg.size() != numBuckets)\n+        throw std::runtime_error(\"Corrupt estimates file. Mismatch in fee/pri average bucket count\");\n+    filein >> fileTxCtAvg;\n+    if (fileTxCtAvg.size() != numBuckets)\n+        throw std::runtime_error(\"Corrupt estimates file. Mismatch in tx count bucket count\");\n+    filein >> fileConfAvg;\n+    maxConfirms = fileConfAvg.size();\n+    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) // one week\n+        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        if (fileConfAvg[i].size() != numBuckets)\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in fee/pri conf average bucket count\");\n+    }\n+    // Now that we've processed the entire fee estimate data file and not\n+    // thrown any errors, we can copy it to our data structures\n+    decay = fileDecay;\n+    buckets = fileBuckets;\n+    avg = fileAvg;\n+    confAvg = fileConfAvg;\n+    txCtAvg = fileTxCtAvg;\n+    bucketMap.clear();\n+\n+    // Resize the current block variables which aren't stored in the data file\n+    // to match the number of confirms and buckets\n+    curBlockConf.resize(maxConfirms);\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        curBlockConf[i].resize(buckets.size());\n+    }\n+    curBlockTxCt.resize(buckets.size());\n+    curBlockVal.resize(buckets.size());\n+\n+    unconfTxs.resize(maxConfirms);\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        unconfTxs[i].resize(buckets.size());\n+    }\n+    oldUnconfTxs.resize(buckets.size());\n+\n+    for (unsigned int i = 0; i < buckets.size(); i++)\n+        bucketMap[buckets[i]] = i;\n+\n+    LogPrint(\"estimatefee\", \"Reading estimates: %u %s buckets counting confirms up to %u blocks\\n\",\n+             numBuckets, dataTypeString, maxConfirms);\n+}\n+\n+unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n+{\n+    unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n+    unsigned int blockIndex = nBlockHeight % unconfTxs.size();\n+    unconfTxs[blockIndex][bucketindex]++;\n+    LogPrint(\"estimatefee\", \"adding to %s\\n\", dataTypeString);\n+    return bucketindex;\n+}\n+\n+void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex)\n+{\n+    //nBestSeenHeight is not updated yet for the new block\n+    int blocksAgo = nBestSeenHeight - entryHeight;\n+    if (nBestSeenHeight == 0)  // the BlockPolicyEstimator hasn't seen any blocks yet\n+        blocksAgo = 0;\n+    if (blocksAgo < 0) {\n+        LogPrint(\"estimatefee\", \"Blockpolicy error, blocks ago is negative for mempool tx\\n\");\n+        return;  //This can't happen becasue we call this with our best seen height, no entries can have higher\n+    }\n+\n+    if (blocksAgo >= (int)unconfTxs.size()) {\n+        if (oldUnconfTxs[bucketindex] > 0)\n+            oldUnconfTxs[bucketindex]--;\n+        else\n+            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n+                     bucketindex);\n+    }\n+    else {\n+        unsigned int blockIndex = entryHeight % unconfTxs.size();\n+        if (unconfTxs[blockIndex][bucketindex] > 0)\n+            unconfTxs[blockIndex][bucketindex]--;\n+        else\n+            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n+                     blockIndex, bucketindex);\n+    }\n+}\n+\n+void CBlockPolicyEstimator::removeTx(uint256 hash)\n+{\n+    std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n+    if (pos == mapMemPoolTxs.end()) {\n+        LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s not found for removeTx\\n\",\n+                 hash.ToString().c_str());\n+        return;\n+    }\n+    TxConfirmStats *stats = pos->second.stats;\n+    unsigned int entryHeight = pos->second.blockHeight;\n+    unsigned int bucketIndex = pos->second.bucketIndex;\n+\n+    if (stats != NULL)\n+        stats->removeTx(entryHeight, nBestSeenHeight, bucketIndex);\n+    mapMemPoolTxs.erase(hash);\n+}\n+\n+CBlockPolicyEstimator::CBlockPolicyEstimator(const CFeeRate& _minRelayFee)\n+    : nBestSeenHeight(0)\n+{\n+    minTrackedFee = _minRelayFee < CFeeRate(MIN_FEERATE) ? CFeeRate(MIN_FEERATE) : _minRelayFee;\n+    std::vector<double> vfeelist;\n+    for (double bucketBoundary = minTrackedFee.GetFeePerK(); bucketBoundary <= MAX_FEERATE; bucketBoundary *= FEE_SPACING) {\n+        vfeelist.push_back(bucketBoundary);\n+    }\n+    vfeelist.push_back(INF_FEERATE);\n+    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, \"FeeRate\");\n+\n+    minTrackedPriority = AllowFreeThreshold() < MIN_PRIORITY ? MIN_PRIORITY : AllowFreeThreshold();\n+    std::vector<double> vprilist;\n+    for (double bucketBoundary = minTrackedPriority; bucketBoundary <= MAX_PRIORITY; bucketBoundary *= PRI_SPACING) {\n+        vprilist.push_back(bucketBoundary);\n+    }\n+    vprilist.push_back(INF_PRIORITY);\n+    priStats.Initialize(vprilist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, \"Priority\");\n+\n+    feeUnlikely = CFeeRate(0);\n+    feeLikely = CFeeRate(INF_FEERATE);\n+    priUnlikely = 0;\n+    priLikely = INF_PRIORITY;\n+}\n+\n+bool CBlockPolicyEstimator::isFeeDataPoint(const CFeeRate &fee, double pri)\n+{\n+    if ((pri < minTrackedPriority && fee >= minTrackedFee) ||\n+        (pri < priUnlikely && fee > feeLikely)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CBlockPolicyEstimator::isPriDataPoint(const CFeeRate &fee, double pri)\n+{\n+    if ((fee < minTrackedFee && pri >= minTrackedPriority) ||\n+        (fee < feeUnlikely && pri > priLikely)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate)\n+{\n+    unsigned int txHeight = entry.GetHeight();\n+    uint256 hash = entry.GetTx().GetHash();\n+    if (mapMemPoolTxs[hash].stats != NULL) {\n+        LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s already being tracked\\n\",\n+                 hash.ToString().c_str());\n+\treturn;\n+    }\n+\n+    if (txHeight < nBestSeenHeight) {\n+        // Ignore side chains and re-orgs; assuming they are random they don't\n+        // affect the estimate.  We'll potentially double count transactions in 1-block reorgs.\n+        return;\n+    }\n+\n+    // Only want to be updating estimates when our blockchain is synced,\n+    // otherwise we'll miscalculate how many blocks its taking to get included.\n+    if (!fCurrentEstimate)\n+        return;\n+\n+    if (!entry.WasClearAtEntry()) {\n+        // This transaction depends on other transactions in the mempool to\n+        // be included in a block before it will be able to be included, so\n+        // we shouldn't include it in our calculations\n+        return;\n+    }\n+\n+    // Fees are stored and reported as BTC-per-kb:\n+    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n+\n+    // Want the priority of the tx at confirmation. However we don't know\n+    // what that will be and its too hard to continue updating it\n+    // so use starting priority as a proxy\n+    double curPri = entry.GetPriority(txHeight);\n+    mapMemPoolTxs[hash].blockHeight = txHeight;\n+\n+    LogPrint(\"estimatefee\", \"Blockpolicy mempool tx %s \", hash.ToString().substr(0,10));\n+    // Record this as a priority estimate\n+    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {\n+        mapMemPoolTxs[hash].stats = &priStats;\n+        mapMemPoolTxs[hash].bucketIndex =  priStats.NewTx(txHeight, curPri);\n+    }\n+    // Record this as a fee estimate\n+    else if (isFeeDataPoint(feeRate, curPri)) {\n+        mapMemPoolTxs[hash].stats = &feeStats;\n+        mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    }\n+    else {\n+        LogPrint(\"estimatefee\", \"not adding\\n\");\n+    }\n+}\n+\n+void CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry)\n+{\n+    if (!entry.WasClearAtEntry()) {\n+        // This transaction depended on other transactions in the mempool to\n+        // be included in a block before it was able to be included, so\n+        // we shouldn't include it in our calculations\n+        return;\n+    }\n+\n+    // How many blocks did it take for miners to include this transaction?\n+    // blocksToConfirm is 1-based, so a transaction included in the earliest\n+    // possible block has confirmation count of 1\n+    int blocksToConfirm = nBlockHeight - entry.GetHeight();\n+    if (blocksToConfirm <= 0) {\n+        // This can't happen because we don't process transactions from a block with a height\n+        // lower than our greatest seen height\n+        LogPrint(\"estimatefee\", \"Blockpolicy error Transaction had negative blocksToConfirm\\n\");\n+        return;\n+    }\n+\n+    // Fees are stored and reported as BTC-per-kb:\n+    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n+\n+    // Want the priority of the tx at confirmation.  The priority when it\n+    // entered the mempool could easily be very small and change quickly\n+    double curPri = entry.GetPriority(nBlockHeight);\n+\n+    // Record this as a priority estimate\n+    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {\n+        priStats.Record(blocksToConfirm, curPri);\n+    }\n+    // Record this as a fee estimate\n+    else if (isFeeDataPoint(feeRate, curPri)) {\n+        feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    }\n+}\n+\n+void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n+                                         std::vector<CTxMemPoolEntry>& entries, bool fCurrentEstimate)\n+{\n+    if (nBlockHeight <= nBestSeenHeight) {\n+        // Ignore side chains and re-orgs; assuming they are random\n+        // they don't affect the estimate.\n+        // And if an attacker can re-org the chain at will, then\n+        // you've got much bigger problems than \"attacker can influence\n+        // transaction fees.\"\n+        return;\n+    }\n+    nBestSeenHeight = nBlockHeight;\n+\n+    // Only want to be updating estimates when our blockchain is synced,\n+    // otherwise we'll miscalculate how many blocks its taking to get included.\n+    if (!fCurrentEstimate)\n+        return;\n+\n+    // Update the dynamic cutoffs\n+    // a fee/priority is \"likely\" the reason your tx was included in a block if >85% of such tx's\n+    // were confirmed in 2 blocks and is \"unlikely\" if <50% were confirmed in 10 blocks\n+    LogPrint(\"estimatefee\", \"Blockpolicy recalculating dynamic cutoffs:\\n\");\n+    priLikely = priStats.EstimateMedianVal(2, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBlockHeight);\n+    if (priLikely == -1)\n+        priLikely = INF_PRIORITY;\n+\n+    double feeLikelyEst = feeStats.EstimateMedianVal(2, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBlockHeight);\n+    if (feeLikelyEst == -1)\n+        feeLikely = CFeeRate(INF_FEERATE);\n+    else\n+        feeLikely = CFeeRate(feeLikelyEst);\n+\n+    priUnlikely = priStats.EstimateMedianVal(10, SUFFICIENT_PRITXS, UNLIKELY_PCT, false, nBlockHeight);\n+    if (priUnlikely == -1)\n+        priUnlikely = 0;\n+\n+    double feeUnlikelyEst = feeStats.EstimateMedianVal(10, SUFFICIENT_FEETXS, UNLIKELY_PCT, false, nBlockHeight);\n+    if (feeUnlikelyEst == -1)\n+        feeUnlikely = CFeeRate(0);\n+    else\n+        feeUnlikely = CFeeRate(feeUnlikelyEst);\n+\n+    // Clear the current block states\n+    feeStats.ClearCurrent(nBlockHeight);\n+    priStats.ClearCurrent(nBlockHeight);\n+\n+    // Repopulate the current block states\n+    for (unsigned int i = 0; i < entries.size(); i++)\n+        processBlockTx(nBlockHeight, entries[i]);\n+\n+    // Update all exponential averages with the current block states\n+    feeStats.UpdateMovingAverages();\n+    priStats.UpdateMovingAverages();\n+\n+    LogPrint(\"estimatefee\", \"Blockpolicy after updating estimates for %u confirmed entries, new mempool map size %u\\n\",\n+             entries.size(), mapMemPoolTxs.size());\n+}\n+\n+CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget)\n+{\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n+        return CFeeRate(0);\n+\n+    double median = feeStats.EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+\n+    if (median < 0)\n+        return CFeeRate(0);\n+\n+    return CFeeRate(median);\n+}\n+\n+double CBlockPolicyEstimator::estimatePriority(int confTarget)\n+{\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > priStats.GetMaxConfirms())\n+        return -1;\n+\n+    return priStats.EstimateMedianVal(confTarget, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+}\n+\n+void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n+{\n+    fileout << nBestSeenHeight;\n+    feeStats.Write(fileout);\n+    priStats.Write(fileout);\n+}\n+\n+void CBlockPolicyEstimator::Read(CAutoFile& filein)\n+{\n+    int nFileBestSeenHeight;\n+    filein >> nFileBestSeenHeight;\n+    feeStats.Read(filein);\n+    priStats.Read(filein);\n+    nBestSeenHeight = nFileBestSeenHeight;\n+}"
      },
      {
        "sha": "ce4d7825662d68d14c0f7a7772e3e3082b225da7",
        "filename": "src/policy/fees.h",
        "status": "added",
        "additions": 276,
        "deletions": 0,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -0,0 +1,276 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICYESTIMATOR_H\n+#define BITCOIN_POLICYESTIMATOR_H\n+\n+#include \"amount.h\"\n+#include \"uint256.h\"\n+\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+class CAutoFile;\n+class CFeeRate;\n+class CTxMemPoolEntry;\n+\n+/** \\class CBlockPolicyEstimator\n+ * The BlockPolicyEstimator is used for estimating the fee or priority needed\n+ * for a transaction to be included in a block within a certain number of\n+ * blocks.\n+ *\n+ * At a high level the algorithm works by grouping transactions into buckets\n+ * based on having similar priorities or fees and then tracking how long it\n+ * takes transactions in the various buckets to be mined.  It operates under\n+ * the assumption that in general transactions of higher fee/priority will be\n+ * included in blocks before transactions of lower fee/priority.   So for\n+ * example if you wanted to know what fee you should put on a transaction to\n+ * be included in a block within the next 5 blocks, you would start by looking\n+ * at the bucket with with the highest fee transactions and verifying that a\n+ * sufficiently high percentage of them were confirmed within 5 blocks and\n+ * then you would look at the next highest fee bucket, and so on, stopping at\n+ * the last bucket to pass the test.   The average fee of transactions in this\n+ * bucket will give you an indication of the lowest fee you can put on a\n+ * transaction and still have a sufficiently high chance of being confirmed\n+ * within your desired 5 blocks.\n+ *\n+ * When a transaction enters the mempool or is included within a block we\n+ * decide whether it can be used as a data point for fee estimation, priority\n+ * estimation or neither.  If the value of exactly one of those properties was\n+ * below the required minimum it can be used to estimate the other.  In\n+ * addition, if a priori our estimation code would indicate that the\n+ * transaction would be much more quickly included in a block because of one\n+ * of the properties compared to the other, we can also decide to use it as\n+ * an estimate for that property.\n+ *\n+ * Here is a brief description of the implementation for fee estimation.\n+ * When a transaction that counts for fee estimation enters the mempool, we\n+ * track the height of the block chain at entry.  Whenever a block comes in,\n+ * we count the number of transactions in each bucket and the total amount of fee\n+ * paid in each bucket. Then we calculate how many blocks Y it took each\n+ * transaction to be mined and we track an array of counters in each bucket\n+ * for how long it to took transactions to get confirmed from 1 to a max of 25\n+ * and we increment all the counters from Y up to 25. This is because for any\n+ * number Z>=Y the transaction was successfully mined within Z blocks.  We\n+ * want to save a history of this information, so at any time we have a\n+ * counter of the total number of transactions that happened in a given fee\n+ * bucket and the total number that were confirmed in each number 1-25 blocks\n+ * or less for any bucket.   We save this history by keeping an exponentially\n+ * decaying moving average of each one of these stats.  Furthermore we also\n+ * keep track of the number unmined (in mempool) transactions in each bucket\n+ * and for how many blocks they have been outstanding and use that to increase\n+ * the number of transactions we've seen in that fee bucket when calculating\n+ * an estimate for any number of confirmations below the number of blocks\n+ * they've been outstanding.\n+ */\n+\n+/**\n+ * We will instantiate two instances of this class, one to track transactions\n+ * that were included in a block due to fee, and one for tx's included due to\n+ * priority.  We will lump transactions into a bucket according to their approximate\n+ * fee or priority and then track how long it took for those txs to be included in a block\n+ *\n+ * The tracking of unconfirmed (mempool) transactions is completely independent of the\n+ * historical tracking of transactions that have been confirmed in a block.\n+ */\n+class TxConfirmStats\n+{\n+private:\n+    //Define the buckets we will group transactions into (both fee buckets and priority buckets)\n+    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    // For each bucket X:\n+    // Count the total # of txs in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> txCtAvg;\n+    // and calcuate the total for the current block to update the moving average\n+    std::vector<int> curBlockTxCt;\n+\n+    // Count the total # of txs confirmed within Y blocks in each bucket\n+    // Track the historical moving average of theses totals over blocks\n+    std::vector<std::vector<double> > confAvg; // confAvg[Y][X]\n+    // and calcuate the totals for the current block to update the moving averages\n+    std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]\n+\n+    // Sum the total priority/fee of all tx's in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> avg;\n+    // and calculate the total for the current block to update the moving average\n+    std::vector<double> curBlockVal;\n+\n+    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n+    // Combine the total value with the tx counts to calculate the avg fee/priority per bucket\n+\n+    std::string dataTypeString;\n+    double decay;\n+\n+    // Mempool counts of outstanding transactions\n+    // For each bucket X, track the number of transactions in the mempool\n+    // that are unconfirmed for each possible confirmation value Y\n+    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n+    // transactions still unconfirmed after MAX_CONFIRMS for each bucket\n+    std::vector<int> oldUnconfTxs;\n+\n+public:\n+    /**\n+     * Initialize the data structures.  This is called by BlockPolicyEstimator's\n+     * constructor with default values.\n+     * @param defaultBuckets contains the upper limits for the bucket boundries\n+     * @param maxConfirms max number of confirms to track\n+     * @param decay how much to decay the historical moving average per block\n+     * @param dataTypeString for logging purposes\n+     */\n+    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay, std::string dataTypeString);\n+\n+    /** Clear the state of the curBlock variables to start counting for the new block */\n+    void ClearCurrent(unsigned int nBlockHeight);\n+\n+    /**\n+     * Record a new transaction data point in the current block stats\n+     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n+     * @param val either the fee or the priority when entered of the transaction\n+     * @warning blocksToConfirm is 1-based and has to be >= 1\n+     */\n+    void Record(int blocksToConfirm, double val);\n+\n+    /** Record a new transaction entering the mempool*/\n+    unsigned int NewTx(unsigned int nBlockHeight, double val);\n+\n+    /** Remove a transaction from mempool tracking stats*/\n+    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n+                  unsigned int bucketIndex);\n+\n+    /** Update our estimates by decaying our historical moving average and updating\n+        with the data gathered from the current block */\n+    void UpdateMovingAverages();\n+\n+    /**\n+     * Calculate a fee or priority estimate.  Find the lowest value bucket (or range of buckets\n+     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n+     * of being confirmed within the target number of confirmations\n+     * @param confTarget target number of confirmations\n+     * @param sufficientTxVal required average number of transactions per block in a bucket range\n+     * @param minSuccess the success probability we require\n+     * @param requireGreater return the lowest fee/pri such that all higher values pass minSuccess OR\n+     *        return the highest fee/pri such that all lower values fail minSuccess\n+     * @param nBlockHeight the current block height\n+     */\n+    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                             double minSuccess, bool requireGreater, unsigned int nBlockHeight);\n+\n+    /** Return the max number of confirms we're tracking */\n+    unsigned int GetMaxConfirms() { return confAvg.size(); }\n+\n+    /** Write state of estimation data to a file*/\n+    void Write(CAutoFile& fileout);\n+\n+    /**\n+     * Read saved state of estimation data from a file and replace all internal data structures and\n+     * variables with this state.\n+     */\n+    void Read(CAutoFile& filein);\n+};\n+\n+\n+\n+/** Track confirm delays up to 25 blocks, can't estimate beyond that */\n+static const unsigned int MAX_BLOCK_CONFIRMS = 25;\n+\n+/** Decay of .998 is a half-life of 346 blocks or about 2.4 days */\n+static const double DEFAULT_DECAY = .998;\n+\n+/** Require greater than 85% of X fee transactions to be confirmed within Y blocks for X to be big enough */\n+static const double MIN_SUCCESS_PCT = .85;\n+static const double UNLIKELY_PCT = .5;\n+\n+/** Require an avg of 1 tx in the combined fee bucket per block to have stat significance */\n+static const double SUFFICIENT_FEETXS = 1;\n+\n+/** Require only an avg of 1 tx every 5 blocks in the combined pri bucket (way less pri txs) */\n+static const double SUFFICIENT_PRITXS = .2;\n+\n+// Minimum and Maximum values for tracking fees and priorities\n+static const double MIN_FEERATE = 10;\n+static const double MAX_FEERATE = 1e7;\n+static const double INF_FEERATE = MAX_MONEY;\n+static const double MIN_PRIORITY = 10;\n+static const double MAX_PRIORITY = 1e16;\n+static const double INF_PRIORITY = 1e9 * MAX_MONEY;\n+\n+// We have to lump transactions into buckets based on fee or priority, but we want to be able\n+// to give accurate estimates over a large range of potential fees and priorities\n+// Therefore it makes sense to exponentially space the buckets\n+/** Spacing of FeeRate buckets */\n+static const double FEE_SPACING = 1.1;\n+\n+/** Spacing of Priority buckets */\n+static const double PRI_SPACING = 2;\n+\n+/**\n+ *  We want to be able to estimate fees or priorities that are needed on tx's to be included in\n+ * a certain number of blocks.  Every time a block is added to the best chain, this class records\n+ * stats on the transactions included in that block\n+ */\n+class CBlockPolicyEstimator\n+{\n+public:\n+    /** Create new BlockPolicyEstimator and initialize stats tracking classes with default values */\n+    CBlockPolicyEstimator(const CFeeRate& minRelayFee);\n+\n+    /** Process all the transactions that have been included in a block */\n+    void processBlock(unsigned int nBlockHeight,\n+                      std::vector<CTxMemPoolEntry>& entries, bool fCurrentEstimate);\n+\n+    /** Process a transaction confirmed in a block*/\n+    void processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry);\n+\n+    /** Process a transaction accepted to the mempool*/\n+    void processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate);\n+\n+    /** Remove a transaction from the mempool tracking stats*/\n+    void removeTx(uint256 hash);\n+\n+    /** Is this transaction likely included in a block because of its fee?*/\n+    bool isFeeDataPoint(const CFeeRate &fee, double pri);\n+\n+    /** Is this transaction likely included in a block because of its priority?*/\n+    bool isPriDataPoint(const CFeeRate &fee, double pri);\n+\n+    /** Return a fee estimate */\n+    CFeeRate estimateFee(int confTarget);\n+\n+    /** Return a priority estimate */\n+    double estimatePriority(int confTarget);\n+\n+    /** Write estimation data to a file */\n+    void Write(CAutoFile& fileout);\n+\n+    /** Read estimation data from a file */\n+    void Read(CAutoFile& filein);\n+\n+private:\n+    CFeeRate minTrackedFee; //! Passed to constructor to avoid dependency on main\n+    double minTrackedPriority; //! Set to AllowFreeThreshold\n+    unsigned int nBestSeenHeight;\n+    struct TxStatsInfo\n+    {\n+        TxConfirmStats *stats;\n+        unsigned int blockHeight;\n+        unsigned int bucketIndex;\n+        TxStatsInfo() : stats(NULL), blockHeight(0), bucketIndex(0) {}\n+    };\n+\n+    // map of txids to information about that transaction\n+    std::map<uint256, TxStatsInfo> mapMemPoolTxs;\n+\n+    /** Classes to track historical data on transaction confirmations */\n+    TxConfirmStats feeStats, priStats;\n+\n+    /** Breakpoints to help determine whether a transaction was confirmed by priority or Fee */\n+    CFeeRate feeLikely, feeUnlikely;\n+    double priLikely, priUnlikely;\n+};\n+#endif /*BITCOIN_POLICYESTIMATOR_H */"
      },
      {
        "sha": "bb53ad204bc7b3b8ccf1c2b7c1215fa964a35833",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 27,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -7,34 +7,33 @@\n \n #include \"arith_uint256.h\"\n #include \"chain.h\"\n-#include \"chainparams.h\"\n #include \"primitives/block.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n \n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)\n {\n-    unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit().GetCompact();\n+    unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();\n \n     // Genesis block\n     if (pindexLast == NULL)\n         return nProofOfWorkLimit;\n \n-    // Only change once per interval\n-    if ((pindexLast->nHeight+1) % Params().Interval() != 0)\n+    // Only change once per difficulty adjustment interval\n+    if ((pindexLast->nHeight+1) % params.DifficultyAdjustmentInterval() != 0)\n     {\n-        if (Params().AllowMinDifficultyBlocks())\n+        if (params.fPowAllowMinDifficultyBlocks)\n         {\n             // Special difficulty rule for testnet:\n             // If the new block's timestamp is more than 2* 10 minutes\n             // then allow mining of a min-difficulty block.\n-            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + Params().TargetSpacing()*2)\n+            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + params.nPowTargetSpacing*2)\n                 return nProofOfWorkLimit;\n             else\n             {\n                 // Return the last non-special-min-difficulty-rules-block\n                 const CBlockIndex* pindex = pindexLast;\n-                while (pindex->pprev && pindex->nHeight % Params().Interval() != 0 && pindex->nBits == nProofOfWorkLimit)\n+                while (pindex->pprev && pindex->nHeight % params.DifficultyAdjustmentInterval() != 0 && pindex->nBits == nProofOfWorkLimit)\n                     pindex = pindex->pprev;\n                 return pindex->nBits;\n             }\n@@ -43,57 +42,60 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n     }\n \n     // Go back by what we want to be 14 days worth of blocks\n-    const CBlockIndex* pindexFirst = pindexLast;\n-    for (int i = 0; pindexFirst && i < Params().Interval()-1; i++)\n-        pindexFirst = pindexFirst->pprev;\n+    int nHeightFirst = pindexLast->nHeight - (params.DifficultyAdjustmentInterval()-1);\n+    assert(nHeightFirst >= 0);\n+    const CBlockIndex* pindexFirst = pindexLast->GetAncestor(nHeightFirst);\n     assert(pindexFirst);\n \n+    return CalculateNextWorkRequired(pindexLast, pindexFirst->GetBlockTime(), params);\n+}\n+\n+unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\n+{\n     // Limit adjustment step\n-    int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n+    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\n     LogPrintf(\"  nActualTimespan = %d  before bounds\\n\", nActualTimespan);\n-    if (nActualTimespan < Params().TargetTimespan()/4)\n-        nActualTimespan = Params().TargetTimespan()/4;\n-    if (nActualTimespan > Params().TargetTimespan()*4)\n-        nActualTimespan = Params().TargetTimespan()*4;\n+    if (nActualTimespan < params.nPowTargetTimespan/4)\n+        nActualTimespan = params.nPowTargetTimespan/4;\n+    if (nActualTimespan > params.nPowTargetTimespan*4)\n+        nActualTimespan = params.nPowTargetTimespan*4;\n \n     // Retarget\n+    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);\n     arith_uint256 bnNew;\n     arith_uint256 bnOld;\n     bnNew.SetCompact(pindexLast->nBits);\n     bnOld = bnNew;\n     bnNew *= nActualTimespan;\n-    bnNew /= Params().TargetTimespan();\n+    bnNew /= params.nPowTargetTimespan;\n \n-    if (bnNew > Params().ProofOfWorkLimit())\n-        bnNew = Params().ProofOfWorkLimit();\n+    if (bnNew > bnPowLimit)\n+        bnNew = bnPowLimit;\n \n     /// debug print\n     LogPrintf(\"GetNextWorkRequired RETARGET\\n\");\n-    LogPrintf(\"Params().TargetTimespan() = %d    nActualTimespan = %d\\n\", Params().TargetTimespan(), nActualTimespan);\n+    LogPrintf(\"params.nPowTargetTimespan = %d    nActualTimespan = %d\\n\", params.nPowTargetTimespan, nActualTimespan);\n     LogPrintf(\"Before: %08x  %s\\n\", pindexLast->nBits, bnOld.ToString());\n     LogPrintf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.ToString());\n \n     return bnNew.GetCompact();\n }\n \n-bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n+bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)\n {\n     bool fNegative;\n     bool fOverflow;\n     arith_uint256 bnTarget;\n \n-    if (Params().SkipProofOfWorkCheck())\n-       return true;\n-\n     bnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n \n     // Check range\n-    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > Params().ProofOfWorkLimit())\n-        return error(\"CheckProofOfWork() : nBits below minimum work\");\n+    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))\n+        return error(\"CheckProofOfWork(): nBits below minimum work\");\n \n     // Check proof of work matches claimed amount\n     if (UintToArith256(hash) > bnTarget)\n-        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n+        return error(\"CheckProofOfWork(): hash doesn't match nBits\");\n \n     return true;\n }\n@@ -112,3 +114,20 @@ arith_uint256 GetBlockProof(const CBlockIndex& block)\n     // or ~bnTarget / (nTarget+1) + 1.\n     return (~bnTarget / (bnTarget + 1)) + 1;\n }\n+\n+int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)\n+{\n+    arith_uint256 r;\n+    int sign = 1;\n+    if (to.nChainWork > from.nChainWork) {\n+        r = to.nChainWork - from.nChainWork;\n+    } else {\n+        r = from.nChainWork - to.nChainWork;\n+        sign = -1;\n+    }\n+    r = r * arith_uint256(params.nPowTargetSpacing) / GetBlockProof(tip);\n+    if (r.bits() > 63) {\n+        return sign * std::numeric_limits<int64_t>::max();\n+    }\n+    return sign * r.GetLow64();\n+}"
      },
      {
        "sha": "e864a474ccd69d8cbf51c721cc810798c1f95b5f",
        "filename": "src/pow.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,17 +6,23 @@\n #ifndef BITCOIN_POW_H\n #define BITCOIN_POW_H\n \n+#include \"consensus/params.h\"\n+\n #include <stdint.h>\n \n class CBlockHeader;\n class CBlockIndex;\n class uint256;\n class arith_uint256;\n \n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock);\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params&);\n+unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&);\n \n /** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n-bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n+bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&);\n arith_uint256 GetBlockProof(const CBlockIndex& block);\n \n+/** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n+int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\n+\n #endif // BITCOIN_POW_H"
      },
      {
        "sha": "5b9c13d87011bf192b70bb7fc2902801e1e16e2e",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,10 +8,11 @@\n #include \"hash.h\"\n #include \"tinyformat.h\"\n #include \"utilstrencodings.h\"\n+#include \"crypto/common.h\"\n \n uint256 CBlockHeader::GetHash() const\n {\n-    return Hash(BEGIN(nVersion), END(nNonce));\n+    return SerializeHash(*this);\n }\n \n uint256 CBlock::BuildMerkleTree(bool* fMutated) const"
      },
      {
        "sha": "59f46deb1c420d8aef28a85a0d144a06259d3a18",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -10,9 +10,6 @@\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n-\n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n  * requirements.  When they solve the proof-of-work, they broadcast the block\n@@ -24,7 +21,7 @@ class CBlockHeader\n {\n public:\n     // header\n-    static const int32_t CURRENT_VERSION=2;\n+    static const int32_t CURRENT_VERSION=3;\n     int32_t nVersion;\n     uint256 hashPrevBlock;\n     uint256 hashMerkleRoot;"
      },
      {
        "sha": "606dbea79857d2f4cc79b0136ad46486f3c187d9",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -94,7 +94,7 @@ CAmount CTransaction::GetValueOut() const\n     {\n         nValueOut += it->nValue;\n         if (!MoneyRange(it->nValue) || !MoneyRange(nValueOut))\n-            throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n+            throw std::runtime_error(\"CTransaction::GetValueOut(): value out of range\");\n     }\n     return nValueOut;\n }"
      },
      {
        "sha": "6cfd93a9a1891c6d19884b0096ffcb124d8c45ba",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -25,7 +25,8 @@ class COutPoint\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(FLATDATA(*this));\n+        READWRITE(hash);\n+        READWRITE(n);\n     }\n \n     void SetNull() { hash.SetNull(); n = (uint32_t) -1; }\n@@ -134,7 +135,7 @@ class CTxOut\n \n     uint256 GetHash() const;\n \n-    bool IsDust(CFeeRate minRelayTxFee) const\n+    CAmount GetDustThreshold(const CFeeRate &minRelayTxFee) const\n     {\n         // \"Dust\" is defined in terms of CTransaction::minRelayTxFee,\n         // which has units satoshis-per-kilobyte.\n@@ -145,7 +146,12 @@ class CTxOut\n         // so dust is a txout less than 546 satoshis \n         // with default minRelayTxFee.\n         size_t nSize = GetSerializeSize(SER_DISK,0)+148u;\n-        return (nValue < 3*minRelayTxFee.GetFee(nSize));\n+        return 3*minRelayTxFee.GetFee(nSize);\n+    }\n+\n+    bool IsDust(const CFeeRate &minRelayTxFee) const\n+    {\n+        return (nValue < GetDustThreshold(minRelayTxFee));\n     }\n \n     friend bool operator==(const CTxOut& a, const CTxOut& b)"
      },
      {
        "sha": "dd855aa33aa921fd5459bf76e1308d53eb3f7e55",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -5,7 +5,6 @@\n \n #include \"protocol.h\"\n \n-#include \"chainparams.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n@@ -21,17 +20,17 @@ static const char* ppszTypeName[] =\n     \"filtered block\"\n };\n \n-CMessageHeader::CMessageHeader()\n+CMessageHeader::CMessageHeader(const MessageStartChars& pchMessageStartIn)\n {\n-    memcpy(pchMessageStart, Params().MessageStart(), MESSAGE_START_SIZE);\n+    memcpy(pchMessageStart, pchMessageStartIn, MESSAGE_START_SIZE);\n     memset(pchCommand, 0, sizeof(pchCommand));\n     nMessageSize = -1;\n     nChecksum = 0;\n }\n \n-CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)\n+CMessageHeader::CMessageHeader(const MessageStartChars& pchMessageStartIn, const char* pszCommand, unsigned int nMessageSizeIn)\n {\n-    memcpy(pchMessageStart, Params().MessageStart(), MESSAGE_START_SIZE);\n+    memcpy(pchMessageStart, pchMessageStartIn, MESSAGE_START_SIZE);\n     memset(pchCommand, 0, sizeof(pchCommand));\n     strncpy(pchCommand, pszCommand, COMMAND_SIZE);\n     nMessageSize = nMessageSizeIn;\n@@ -43,10 +42,10 @@ std::string CMessageHeader::GetCommand() const\n     return std::string(pchCommand, pchCommand + strnlen(pchCommand, COMMAND_SIZE));\n }\n \n-bool CMessageHeader::IsValid() const\n+bool CMessageHeader::IsValid(const MessageStartChars& pchMessageStartIn) const\n {\n     // Check start string\n-    if (memcmp(pchMessageStart, Params().MessageStart(), MESSAGE_START_SIZE) != 0)\n+    if (memcmp(pchMessageStart, pchMessageStartIn, MESSAGE_START_SIZE) != 0)\n         return false;\n \n     // Check the command string for errors\n@@ -66,7 +65,7 @@ bool CMessageHeader::IsValid() const\n     // Message size\n     if (nMessageSize > MAX_SIZE)\n     {\n-        LogPrintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand(), nMessageSize);\n+        LogPrintf(\"CMessageHeader::IsValid(): (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand(), nMessageSize);\n         return false;\n     }\n \n@@ -90,7 +89,6 @@ void CAddress::Init()\n {\n     nServices = NODE_NETWORK;\n     nTime = 100000000;\n-    nLastTry = 0;\n }\n \n CInv::CInv()\n@@ -117,7 +115,7 @@ CInv::CInv(const std::string& strType, const uint256& hashIn)\n         }\n     }\n     if (i == ARRAYLEN(ppszTypeName))\n-        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType));\n+        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256): unknown type '%s'\", strType));\n     hash = hashIn;\n }\n \n@@ -134,7 +132,7 @@ bool CInv::IsKnownType() const\n const char* CInv::GetCommand() const\n {\n     if (!IsKnownType())\n-        throw std::out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n+        throw std::out_of_range(strprintf(\"CInv::GetCommand(): type=%d unknown type\", type));\n     return ppszTypeName[type];\n }\n "
      },
      {
        "sha": "b5e65032a21fd111dbd01a119ac09685b51378ad",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -29,11 +29,13 @@\n class CMessageHeader\n {\n public:\n-    CMessageHeader();\n-    CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn);\n+    typedef unsigned char MessageStartChars[MESSAGE_START_SIZE];\n+\n+    CMessageHeader(const MessageStartChars& pchMessageStartIn);\n+    CMessageHeader(const MessageStartChars& pchMessageStartIn, const char* pszCommand, unsigned int nMessageSizeIn);\n \n     std::string GetCommand() const;\n-    bool IsValid() const;\n+    bool IsValid(const MessageStartChars& messageStart) const;\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -65,7 +67,14 @@ class CMessageHeader\n \n /** nServices flags */\n enum {\n+    // NODE_NETWORK means that the node is capable of serving the block chain. It is currently\n+    // set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want\n+    // network services but don't provide them.\n     NODE_NETWORK = (1 << 0),\n+    // NODE_GETUTXO means the node is capable of responding to the getutxo protocol request.\n+    // Bitcoin Core does not support this but a patch set called Bitcoin XT does.\n+    // See BIP 64 for details on how this is implemented.\n+    NODE_GETUTXO = (1 << 1),\n \n     // Bits 24-31 are reserved for temporary experiments. Just pick a bit that\n     // isn't getting used, or one not being used much, and notify the\n@@ -107,9 +116,6 @@ class CAddress : public CService\n \n     // disk and network only\n     unsigned int nTime;\n-\n-    // memory only\n-    int64_t nLastTry;\n };\n \n /** inv message data */"
      },
      {
        "sha": "bdab1376000ecab38bf2305bfa3f88c0bc17e045",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 38,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,25 +6,16 @@\n \n #include \"eccryptoverify.h\"\n \n-#ifdef USE_SECP256K1\n-#include <secp256k1.h>\n-#else\n #include \"ecwrapper.h\"\n-#endif\n \n bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n     if (!IsValid())\n         return false;\n-#ifdef USE_SECP256K1\n-    if (secp256k1_ecdsa_verify((const unsigned char*)&hash, &vchSig[0], vchSig.size(), begin(), size()) != 1)\n-        return false;\n-#else\n     CECKey key;\n     if (!key.SetPubKey(begin(), size()))\n         return false;\n     if (!key.Verify(hash, vchSig))\n         return false;\n-#endif\n     return true;\n }\n \n@@ -33,73 +24,49 @@ bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned cha\n         return false;\n     int recid = (vchSig[0] - 27) & 3;\n     bool fComp = ((vchSig[0] - 27) & 4) != 0;\n-#ifdef USE_SECP256K1\n-    int pubkeylen = 65;\n-    if (!secp256k1_ecdsa_recover_compact((const unsigned char*)&hash, &vchSig[1], (unsigned char*)begin(), &pubkeylen, fComp, recid))\n-        return false;\n-    assert((int)size() == pubkeylen);\n-#else\n     CECKey key;\n     if (!key.Recover(hash, &vchSig[1], recid))\n         return false;\n     std::vector<unsigned char> pubkey;\n     key.GetPubKey(pubkey, fComp);\n     Set(pubkey.begin(), pubkey.end());\n-#endif\n     return true;\n }\n \n bool CPubKey::IsFullyValid() const {\n     if (!IsValid())\n         return false;\n-#ifdef USE_SECP256K1\n-    if (!secp256k1_ecdsa_pubkey_verify(begin(), size()))\n-        return false;\n-#else\n     CECKey key;\n     if (!key.SetPubKey(begin(), size()))\n         return false;\n-#endif\n     return true;\n }\n \n bool CPubKey::Decompress() {\n     if (!IsValid())\n         return false;\n-#ifdef USE_SECP256K1\n-    int clen = size();\n-    int ret = secp256k1_ecdsa_pubkey_decompress((unsigned char*)begin(), &clen);\n-    assert(ret);\n-    assert(clen == (int)size());\n-#else\n     CECKey key;\n     if (!key.SetPubKey(begin(), size()))\n         return false;\n     std::vector<unsigned char> pubkey;\n     key.GetPubKey(pubkey, false);\n     Set(pubkey.begin(), pubkey.end());\n-#endif\n     return true;\n }\n \n-bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n+bool CPubKey::Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const {\n     assert(IsValid());\n     assert((nChild >> 31) == 0);\n     assert(begin() + 33 == end());\n     unsigned char out[64];\n     BIP32Hash(cc, nChild, *begin(), begin()+1, out);\n-    memcpy(ccChild, out+32, 32);\n-#ifdef USE_SECP256K1\n-    pubkeyChild = *this;\n-    bool ret = secp256k1_ecdsa_pubkey_tweak_add((unsigned char*)pubkeyChild.begin(), pubkeyChild.size(), out);\n-#else\n+    memcpy(ccChild.begin(), out+32, 32);\n     CECKey key;\n     bool ret = key.SetPubKey(begin(), size());\n     ret &= key.TweakPublic(out);\n     std::vector<unsigned char> pubkey;\n     key.GetPubKey(pubkey, true);\n     pubkeyChild.Set(pubkey.begin(), pubkey.end());\n-#endif\n     return ret;\n }\n \n@@ -108,7 +75,7 @@ void CExtPubKey::Encode(unsigned char code[74]) const {\n     memcpy(code+1, vchFingerprint, 4);\n     code[5] = (nChild >> 24) & 0xFF; code[6] = (nChild >> 16) & 0xFF;\n     code[7] = (nChild >>  8) & 0xFF; code[8] = (nChild >>  0) & 0xFF;\n-    memcpy(code+9, vchChainCode, 32);\n+    memcpy(code+9, chaincode.begin(), 32);\n     assert(pubkey.size() == 33);\n     memcpy(code+41, pubkey.begin(), 33);\n }\n@@ -117,7 +84,7 @@ void CExtPubKey::Decode(const unsigned char code[74]) {\n     nDepth = code[0];\n     memcpy(vchFingerprint, code+1, 4);\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n-    memcpy(vchChainCode, code+9, 32);\n+    memcpy(chaincode.begin(), code+9, 32);\n     pubkey.Set(code+41, code+74);\n }\n \n@@ -126,5 +93,5 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int nChild) const {\n     CKeyID id = pubkey.GetID();\n     memcpy(&out.vchFingerprint[0], &id, 4);\n     out.nChild = nChild;\n-    return pubkey.Derive(out.pubkey, out.vchChainCode, nChild, vchChainCode);\n+    return pubkey.Derive(out.pubkey, out.chaincode, nChild, chaincode);\n }"
      },
      {
        "sha": "cce9c826e5de8c7c4f343b62261d6d67f718e656",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -31,6 +31,8 @@ class CKeyID : public uint160\n     CKeyID(const uint160& in) : uint160(in) {}\n };\n \n+typedef uint256 ChainCode;\n+\n /** An encapsulated public key. */\n class CPubKey\n {\n@@ -182,20 +184,20 @@ class CPubKey\n     bool Decompress();\n \n     //! Derive BIP32 child pubkey.\n-    bool Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n+    bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n struct CExtPubKey {\n     unsigned char nDepth;\n     unsigned char vchFingerprint[4];\n     unsigned int nChild;\n-    unsigned char vchChainCode[32];\n+    ChainCode chaincode;\n     CPubKey pubkey;\n \n-    friend bool operator==(const CExtPubKey& a, const CExtPubKey& b)\n+    friend bool operator==(const CExtPubKey &a, const CExtPubKey &b)\n     {\n         return a.nDepth == b.nDepth && memcmp(&a.vchFingerprint[0], &b.vchFingerprint[0], 4) == 0 && a.nChild == b.nChild &&\n-               memcmp(&a.vchChainCode[0], &b.vchChainCode[0], 32) == 0 && a.pubkey == b.pubkey;\n+               a.chaincode == b.chaincode && a.pubkey == b.pubkey;\n     }\n \n     void Encode(unsigned char code[74]) const;"
      },
      {
        "sha": "8e20836c65459ffe4eb46ff58eefdaaa83a844d5",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,7 +8,9 @@\n #include \"walletmodel.h\"\n \n #include \"base58.h\"\n-#include \"wallet.h\"\n+#include \"wallet/wallet.h\"\n+\n+#include <boost/foreach.hpp>\n \n #include <QFont>\n #include <QDebug>\n@@ -114,7 +116,7 @@ class AddressTablePriv\n         case CT_NEW:\n             if(inModel)\n             {\n-                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_NEW, but entry is already in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry: Warning: Got CT_NEW, but entry is already in model\";\n                 break;\n             }\n             parent->beginInsertRows(QModelIndex(), lowerIndex, lowerIndex);\n@@ -124,7 +126,7 @@ class AddressTablePriv\n         case CT_UPDATED:\n             if(!inModel)\n             {\n-                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_UPDATED, but entry is not in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry: Warning: Got CT_UPDATED, but entry is not in model\";\n                 break;\n             }\n             lower->type = newEntryType;\n@@ -134,7 +136,7 @@ class AddressTablePriv\n         case CT_DELETED:\n             if(!inModel)\n             {\n-                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_DELETED, but entry is not in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry: Warning: Got CT_DELETED, but entry is not in model\";\n                 break;\n             }\n             parent->beginRemoveRows(QModelIndex(), lowerIndex, upperIndex-1);"
      },
      {
        "sha": "441814ff07130f0b8f5840c5b6cac5c440bfadec",
        "filename": "src/qt/askpassphrasedialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/askpassphrasedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/askpassphrasedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/askpassphrasedialog.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,7 +8,7 @@\n #include \"guiconstants.h\"\n #include \"walletmodel.h\"\n \n-#include \"allocators.h\"\n+#include \"support/allocators/secure.h\"\n \n #include <QKeyEvent>\n #include <QMessageBox>\n@@ -62,7 +62,7 @@ AskPassphraseDialog::AskPassphraseDialog(Mode mode, QWidget *parent) :\n             break;\n         case ChangePass: // Ask old passphrase + new passphrase x2\n             setWindowTitle(tr(\"Change passphrase\"));\n-            ui->warningLabel->setText(tr(\"Enter the old and new passphrase to the wallet.\"));\n+            ui->warningLabel->setText(tr(\"Enter the old passphrase and new passphrase to the wallet.\"));\n             break;\n     }\n     textChanged();"
      },
      {
        "sha": "8740b98b70cb1a7625ab0e295e7d4e12b3bb7578",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -26,11 +26,12 @@\n #include \"init.h\"\n #include \"main.h\"\n #include \"rpcserver.h\"\n+#include \"scheduler.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n \n #ifdef ENABLE_WALLET\n-#include \"wallet.h\"\n+#include \"wallet/wallet.h\"\n #endif\n \n #include <stdint.h>\n@@ -107,7 +108,6 @@ static QString GetLangTerritory()\n /** Set up translations */\n static void initTranslations(QTranslator &qtTranslatorBase, QTranslator &qtTranslator, QTranslator &translatorBase, QTranslator &translator)\n {\n-\n     // Remove old translators\n     QApplication::removeTranslator(&qtTranslatorBase);\n     QApplication::removeTranslator(&qtTranslator);\n@@ -179,6 +179,7 @@ public slots:\n \n private:\n     boost::thread_group threadGroup;\n+    CScheduler scheduler;\n \n     /// Pass fatal exception message to UI thread\n     void handleRunawayException(const std::exception *e);\n@@ -259,7 +260,7 @@ void BitcoinCore::initialize()\n     try\n     {\n         qDebug() << __func__ << \": Running AppInit2 in thread\";\n-        int rv = AppInit2(threadGroup);\n+        int rv = AppInit2(threadGroup, scheduler);\n         if(rv)\n         {\n             /* Start a dummy RPC thread if no RPC thread is active yet\n@@ -533,7 +534,7 @@ int main(int argc, char *argv[])\n     // Now that QSettings are accessible, initialize translations\n     QTranslator qtTranslatorBase, qtTranslator, translatorBase, translator;\n     initTranslations(qtTranslatorBase, qtTranslator, translatorBase, translator);\n-    uiInterface.Translate.connect(Translate);\n+    translationInterface.Translate.connect(Translate);\n \n     // Show help message immediately after parsing command-line options (for \"-lang\") and setting locale,\n     // but before showing splash screen."
      },
      {
        "sha": "c899e95506afa29de1a5c40b30b9256d42afbd51",
        "filename": "src/qt/bitcoin.qrc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoin.qrc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoin.qrc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.qrc?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -45,6 +45,7 @@\n         <file alias=\"about\">res/icons/about.png</file>\n         <file alias=\"about_qt\">res/icons/about_qt.png</file>\n         <file alias=\"verify\">res/icons/verify.png</file>\n+        <file alias=\"warning\">res/icons/warning.png</file>\n     </qresource>\n     <qresource prefix=\"/movies\">\n         <file alias=\"spinner-000\">res/movies/spinner-000.png</file>"
      },
      {
        "sha": "d31a1e018b2898a5bea2338abd3ad84002040cdb",
        "filename": "src/qt/bitcoinamountfield.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoinamountfield.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoinamountfield.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -278,7 +278,6 @@ void BitcoinAmountField::setValue(const CAmount& value)\n void BitcoinAmountField::setReadOnly(bool fReadOnly)\n {\n     amount->setReadOnly(fReadOnly);\n-    unit->setEnabled(!fReadOnly);\n }\n \n void BitcoinAmountField::unitChanged(int idx)"
      },
      {
        "sha": "efba0f5e18ed6e6897ac9ae4e48ac9dd11320450",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 20,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -151,7 +151,7 @@ BitcoinGUI::BitcoinGUI(const NetworkStyle *networkStyle, QWidget *parent) :\n \n     // Create actions for the toolbar, menu bar and tray/dock icon\n     // Needs walletFrame to be initialized\n-    createActions(networkStyle);\n+    createActions();\n \n     // Create application menu bar\n     createMenuBar();\n@@ -165,6 +165,9 @@ BitcoinGUI::BitcoinGUI(const NetworkStyle *networkStyle, QWidget *parent) :\n     // Create status bar\n     statusBar();\n \n+    // Disable size grip because it looks ugly and nobody needs it\n+    statusBar()->setSizeGripEnabled(false);\n+\n     // Status bar notification icons\n     QFrame *frameBlocks = new QFrame();\n     frameBlocks->setContentsMargins(0,0,0,0);\n@@ -234,13 +237,13 @@ BitcoinGUI::~BitcoinGUI()\n         trayIcon->hide();\n #ifdef Q_OS_MAC\n     delete appMenuBar;\n-    MacDockIconHandler::instance()->setMainWindow(NULL);\n+    MacDockIconHandler::cleanup();\n #endif\n \n     delete rpcConsole;\n }\n \n-void BitcoinGUI::createActions(const NetworkStyle *networkStyle)\n+void BitcoinGUI::createActions()\n {\n     QActionGroup *tabGroup = new QActionGroup(this);\n \n@@ -337,6 +340,7 @@ void BitcoinGUI::createActions(const NetworkStyle *networkStyle)\n     openAction->setStatusTip(tr(\"Open a bitcoin: URI or payment request\"));\n \n     showHelpMessageAction = new QAction(TextColorIcon(\":/icons/info\"), tr(\"&Command-line options\"), this);\n+    showHelpMessageAction->setMenuRole(QAction::NoRole);\n     showHelpMessageAction->setStatusTip(tr(\"Show the Bitcoin Core help message to get a list with possible Bitcoin command-line options\"));\n \n     connect(quitAction, SIGNAL(triggered()), qApp, SLOT(quit()));\n@@ -410,6 +414,7 @@ void BitcoinGUI::createToolBars()\n     if(walletFrame)\n     {\n         QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n+        toolbar->setMovable(false);\n         toolbar->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\n         toolbar->addAction(overviewAction);\n         toolbar->addAction(sendCoinsAction);\n@@ -432,8 +437,8 @@ void BitcoinGUI::setClientModel(ClientModel *clientModel)\n         setNumConnections(clientModel->getNumConnections());\n         connect(clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n \n-        setNumBlocks(clientModel->getNumBlocks());\n-        connect(clientModel, SIGNAL(numBlocksChanged(int)), this, SLOT(setNumBlocks(int)));\n+        setNumBlocks(clientModel->getNumBlocks(), clientModel->getLastBlockDate());\n+        connect(clientModel, SIGNAL(numBlocksChanged(int,QDateTime)), this, SLOT(setNumBlocks(int,QDateTime)));\n \n         // Receive and report messages from client model\n         connect(clientModel, SIGNAL(message(QString,QString,unsigned int)), this, SLOT(message(QString,QString,unsigned int)));\n@@ -649,7 +654,7 @@ void BitcoinGUI::setNumConnections(int count)\n     labelConnectionsIcon->setToolTip(tr(\"%n active connection(s) to Bitcoin network\", \"\", count));\n }\n \n-void BitcoinGUI::setNumBlocks(int count)\n+void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate)\n {\n     if(!clientModel)\n         return;\n@@ -677,11 +682,10 @@ void BitcoinGUI::setNumBlocks(int count)\n \n     QString tooltip;\n \n-    QDateTime lastBlockDate = clientModel->getLastBlockDate();\n     QDateTime currentDate = QDateTime::currentDateTime();\n-    int secs = lastBlockDate.secsTo(currentDate);\n+    qint64 secs = blockDate.secsTo(currentDate);\n \n-    tooltip = tr(\"Processed %n blocks of transaction history.\", \"\", count);\n+    tooltip = tr(\"Processed %n block(s) of transaction history.\", \"\", count);\n \n     // Set icon state: spinning if catching up, tick otherwise\n     if(secs < 90*60)\n@@ -719,8 +723,8 @@ void BitcoinGUI::setNumBlocks(int count)\n         }\n         else\n         {\n-            int years = secs / YEAR_IN_SECONDS;\n-            int remainder = secs % YEAR_IN_SECONDS;\n+            qint64 years = secs / YEAR_IN_SECONDS;\n+            qint64 remainder = secs % YEAR_IN_SECONDS;\n             timeBehindText = tr(\"%1 and %2\").arg(tr(\"%n year(s)\", \"\", years)).arg(tr(\"%n week(s)\",\"\", remainder/WEEK_IN_SECONDS));\n         }\n \n@@ -856,18 +860,18 @@ void BitcoinGUI::closeEvent(QCloseEvent *event)\n }\n \n #ifdef ENABLE_WALLET\n-void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address)\n+void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label)\n {\n     // On new transaction, make an info balloon\n+    QString msg = tr(\"Date: %1\\n\").arg(date) +\n+                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true)) +\n+                  tr(\"Type: %1\\n\").arg(type);\n+    if (!label.isEmpty())\n+        msg += tr(\"Label: %1\\n\").arg(label);\n+    else if (!address.isEmpty())\n+        msg += tr(\"Address: %1\\n\").arg(address);\n     message((amount)<0 ? tr(\"Sent transaction\") : tr(\"Incoming transaction\"),\n-             tr(\"Date: %1\\n\"\n-                \"Amount: %2\\n\"\n-                \"Type: %3\\n\"\n-                \"Address: %4\\n\")\n-                  .arg(date)\n-                  .arg(BitcoinUnits::formatWithUnit(unit, amount, true))\n-                  .arg(type)\n-                  .arg(address), CClientUIInterface::MSG_INFORMATION);\n+             msg, CClientUIInterface::MSG_INFORMATION);\n }\n #endif // ENABLE_WALLET\n "
      },
      {
        "sha": "494541f0027d9514a14ae1923289718278796939",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -118,7 +118,7 @@ class BitcoinGUI : public QMainWindow\n     int spinnerFrame;\n \n     /** Create the main UI actions. */\n-    void createActions(const NetworkStyle *networkStyle);\n+    void createActions();\n     /** Create the menu bar and sub-menus. */\n     void createMenuBar();\n     /** Create the toolbars */\n@@ -143,8 +143,8 @@ class BitcoinGUI : public QMainWindow\n public slots:\n     /** Set number of connections shown in the UI */\n     void setNumConnections(int count);\n-    /** Set number of blocks shown in the UI */\n-    void setNumBlocks(int count);\n+    /** Set number of blocks and last block date shown in the UI */\n+    void setNumBlocks(int count, const QDateTime& blockDate);\n \n     /** Notify the user of an event from the core network or transaction handling code.\n        @param[in] title     the message box / notification title\n@@ -165,7 +165,7 @@ public slots:\n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);\n \n     /** Show incoming transaction notification for new transactions. */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n #endif // ENABLE_WALLET\n \n private slots:"
      },
      {
        "sha": "b259d038f239442c7f8e44b8e2cfd4ef8f1068b5",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 31,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -10,18 +10,6 @@\n #endif\n static const char UNUSED *bitcoin_strings[] = {\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"%s, you must set a rpcpassword in the configuration file:\\n\"\n-\"%s\\n\"\n-\"It is recommended you use the following random password:\\n\"\n-\"rpcuser=bitcoinrpc\\n\"\n-\"rpcpassword=%s\\n\"\n-\"(you do not need to remember this password)\\n\"\n-\"The username and password MUST NOT be the same.\\n\"\n-\"If the file does not exist, create it with owner-readable-only file \"\n-\"permissions.\\n\"\n-\"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n-\"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"(1 = keep tx meta data e.g. account owner and payment request information, 2 \"\n \"= drop tx meta data)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -46,14 +34,17 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Continuously rate-limit free transactions to <n>*1000 bytes per minute \"\n-\"(default:%u)\"),\n+\"(default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Create new files with system default permissions, instead of umask 077 (only \"\n \"effective with disabled wallet functionality)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Delete all wallet transactions and only recover those parts of the \"\n \"blockchain through -rescan on startup\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Discover own IP addresses (default: 1 when listening and no -externalip or -\"\n+\"proxy)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Distributed under the MIT software license, see the accompanying file \"\n \"COPYING or <http://www.opensource.org/licenses/mit-license.php>.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -62,13 +53,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: Listening for incoming connections failed (listen returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Error: The transaction was rejected! This might happen if some of the coins \"\n-\"in your wallet were already spent, such as if you used a copy of wallet.dat \"\n-\"and coins were spent in the copy but not marked as spent here.\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Error: This transaction requires a transaction fee of at least %s because of \"\n-\"its amount, complexity, or use of recently received funds!\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: Unsupported argument -socks found. Setting SOCKS version isn't \"\n \"possible anymore, only SOCKS5 proxies are supported.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -92,12 +76,15 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"How thorough the block verification of -checkblocks is (0-4, default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"If paytxfee is not set, include enough fee so transactions are confirmed on \"\n-\"average within n blocks (default: %u)\"),\n+\"If paytxfee is not set, include enough fee so transactions begin \"\n+\"confirmation on average within n blocks (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"In this mode -genproclimit controls how many blocks are generated \"\n \"immediately.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay \"\n+\"fee of %s to prevent stuck transactions)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Log transaction priority and fee per kB when mining blocks (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Maintain a full transaction index, used by the getrawtransaction rpc call \"\n@@ -106,13 +93,29 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Maximum size of data in data carrier transactions we relay and mine \"\n \"(default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Maximum total fees to use in a single wallet transaction; setting this too \"\n+\"low may abort large transactions (default: %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Output debugging information (default: %u, supplying <category> is optional)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Prune configured below the minimum of %d MB.  Please use a higher number.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 \"\n \"unless -connect)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Randomize credentials for every proxy connection. This enables Tor stream \"\n+\"isolation (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Reduce storage requirements by pruning (deleting) old blocks. This mode \"\n+\"disables wallet support and is incompatible with -txindex. Warning: \"\n+\"Reverting this setting requires re-downloading the entire blockchain. \"\n+\"(default: 0 = disable pruning blocks, >%u = target size in MiB to use for \"\n+\"block files)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Require high priority for relaying free or low-fee transactions (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set the number of script verification threads (%u to %d, 0 = auto, <0 = \"\n@@ -121,19 +124,37 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set the number of threads for coin generation if enabled (-1 = all cores, \"\n \"default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"The transaction amount is too small to send after the fee has been deducted\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"This is a pre-release test build - use at your own risk - do not use for \"\n \"mining or merchant applications\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"This product includes software developed by the OpenSSL Project for use in \"\n \"the OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software \"\n \"written by Eric Young and UPnP software written by Thomas Bernard.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"To use bitcoind, or the -server option to bitcoin-qt, you must set an \"\n+\"rpcpassword in the configuration file:\\n\"\n+\"%s\\n\"\n+\"It is recommended you use the following random password:\\n\"\n+\"rpcuser=bitcoinrpc\\n\"\n+\"rpcpassword=%s\\n\"\n+\"(you do not need to remember this password)\\n\"\n+\"The username and password MUST NOT be the same.\\n\"\n+\"If the file does not exist, create it with owner-readable-only file \"\n+\"permissions.\\n\"\n+\"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n+\"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Unable to bind to %s on this computer. Bitcoin Core is probably already \"\n \"running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: \"\n \"%s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Warning: -maxtxfee is set very high! Fees this large could be paid on a \"\n+\"single transaction.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Warning: -paytxfee is set very high! This is the transaction fee you will \"\n \"pay if you send a transaction.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -158,22 +179,31 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Whitelisted peers cannot be DoS banned and their transactions are always \"\n \"relayed, even if they are already in the mempool, useful e.g. for a gateway\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"You need to rebuild the database using -reindex to go back to unpruned \"\n+\"mode.  This will redownload the entire blockchain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: 1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"<category> can be:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept command line and JSON-RPC commands\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept connections from outside (default: 1 if no -proxy or -connect)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept public REST requests (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Acceptable ciphers (default: %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Activating best chain...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Add a node to connect to and attempt to keep the connection open\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Allow DNS lookups for -addnode, -seednode and -connect\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Allow self signed root certificates (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Always query for peer addresses via DNS lookup (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Attempt to recover private keys from a corrupt wallet.dat\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Block creation options:\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Can't run with a wallet in prune mode.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot downgrade wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot resolve -bind address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot resolve -externalip address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot resolve -whitebind address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot write default address\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Choose data directory on startup (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect only to the specified node(s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect through SOCKS5 proxy\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect to a node to retrieve peer addresses, and disconnect\"),\n@@ -183,7 +213,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Corrupted block database detected\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Could not parse -rpcbind value %s as network address\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Debugging/Testing options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Disable safemode, override a real safe mode event (default: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Discover own IP address (default: 1 when listening and no -externalip)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Do not load the wallet and disable wallet RPC calls\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Do you want to rebuild the block database now?\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Done loading\"),\n@@ -194,11 +223,11 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet.dat\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet.dat: Wallet corrupted\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet.dat: Wallet requires newer version of Bitcoin Core\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error opening block database\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error reading from database, shutting down.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: A fatal internal error occured, see debug.log for details\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Disk space is low!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Unsupported argument -tor found, use -onion.\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Wallet locked, unable to create transaction!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to listen on any port. Use -listen=0 if you want this.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Fee (in BTC/kB) to add to transactions you send (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Force safe mode (default: %u)\"),\n@@ -214,13 +243,12 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Initialization sanity check failed. Bitcoin C\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Insufficient funds\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -maxtxfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -minrelaytxfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -mintxfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -paytxfee=<amount>: '%s'\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid netmask specified in -whitelist: '%s'\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keep at most <n> unconnectable blocks in memory (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keep at most <n> unconnectable transactions in memory (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Limit size of signature cache to <n> entries (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"),\n@@ -229,6 +257,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading addresses...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading block index...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading wallet...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maintain at most <n> connections to peers (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Make the wallet broadcast transactions\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Need to specify a port with -whitebind: '%s'\"),\n@@ -239,13 +268,14 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Only connect to nodes in network <net> (ipv4,\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Password for JSON-RPC connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prepend debug output with timestamp (default: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Print block on startup, if found in block index\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Print block tree on startup (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prune cannot be configured with a negative value.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prune mode is incompatible with -txindex.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC server options:\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC support for HTTP persistent connections (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Randomly drop 1 of every <n> network messages\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Randomly fuzz 1 of every <n> network messages\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild block chain index from current blk000??.dat files\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild block chain index from current blk000??.dat files on startup\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay and mine data carrier transactions (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay non-P2SH multisig (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescan the block chain for missing wallet transactions\"),\n@@ -256,13 +286,16 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send trace/debug info to console instead of d\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send transactions as zero-fee transactions if possible (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Server certificate file (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Server private key (default: %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set SSL root certificates for payment request (default: -system-)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set database cache size in megabytes (%d to %d, default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set key pool size to <n> (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set language, for example \\\"de_DE\\\" (default: system locale)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set maximum block size in bytes (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set minimum block size in bytes (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set the number of threads to service RPC calls (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Sets the DB_PRIVATE flag in the wallet db environment (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Show all debugging options (usage: --help -help-debug)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Show splash screen on startup (default: 1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Signing transaction failed\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify configuration file (default: %s)\"),\n@@ -272,15 +305,18 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify pid file (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify wallet file (within data directory)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify your own public address\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Spend unconfirmed change when sending transactions (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Start minimized\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Stop running after importing blocks from disk (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"The transaction amount is too small to pay the fee\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This help message\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This is experimental software.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This is intended for regression testing tools and app development.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Threshold for disconnecting misbehaving peers (default: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"To use the %s option\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction amount too small\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction amounts must be positive\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction too large for fee policy\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction too large\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"UI Options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to bind to %s on this computer (bind returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown network specified in -onlynet: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Upgrade wallet to latest format\"),\n@@ -295,7 +331,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet %s resides outside data directory %s\")\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet needed to be rewritten: restart Bitcoin Core to complete\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Warning\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Warning: This version is obsolete, upgrade required!\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Warning: This version is obsolete; upgrade required!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Warning: Unsupported argument -benchmark ignored, use -debug=bench.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Warning: Unsupported argument -debugnet ignored, use -debug=net.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"You need to rebuild the database using -reindex to change -txindex\"),"
      },
      {
        "sha": "8e29cdeb06a6e56c62a395544f79cbdba2965264",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 17,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -18,7 +18,6 @@\n \n #include <stdint.h>\n \n-#include <QDateTime>\n #include <QDebug>\n #include <QTimer>\n \n@@ -29,8 +28,10 @@ ClientModel::ClientModel(OptionsModel *optionsModel, QObject *parent) :\n     optionsModel(optionsModel),\n     peerTableModel(0),\n     cachedNumBlocks(0),\n-    cachedReindexing(0), cachedImporting(0),\n-    numBlocksAtStartup(-1), pollTimer(0)\n+    cachedBlockDate(QDateTime()),\n+    cachedReindexing(0),\n+    cachedImporting(0),\n+    pollTimer(0)\n {\n     peerTableModel = new PeerTableModel(this);\n     pollTimer = new QTimer(this);\n@@ -65,12 +66,6 @@ int ClientModel::getNumBlocks() const\n     return chainActive.Height();\n }\n \n-int ClientModel::getNumBlocksAtStartup()\n-{\n-    if (numBlocksAtStartup == -1) numBlocksAtStartup = getNumBlocks();\n-    return numBlocksAtStartup;\n-}\n-\n quint64 ClientModel::getTotalBytesRecv() const\n {\n     return CNode::GetTotalBytesRecv();\n@@ -84,16 +79,17 @@ quint64 ClientModel::getTotalBytesSent() const\n QDateTime ClientModel::getLastBlockDate() const\n {\n     LOCK(cs_main);\n+\n     if (chainActive.Tip())\n         return QDateTime::fromTime_t(chainActive.Tip()->GetBlockTime());\n-    else\n-        return QDateTime::fromTime_t(Params().GenesisBlock().GetBlockTime()); // Genesis block's time of current network\n+\n+    return QDateTime::fromTime_t(Params().GenesisBlock().GetBlockTime()); // Genesis block's time of current network\n }\n \n double ClientModel::getVerificationProgress() const\n {\n     LOCK(cs_main);\n-    return Checkpoints::GuessVerificationProgress(chainActive.Tip());\n+    return Checkpoints::GuessVerificationProgress(Params().Checkpoints(), chainActive.Tip());\n }\n \n void ClientModel::updateTimer()\n@@ -102,21 +98,26 @@ void ClientModel::updateTimer()\n     // periodical polls if the core is holding the locks for a longer time -\n     // for example, during a wallet rescan.\n     TRY_LOCK(cs_main, lockMain);\n-    if(!lockMain)\n+    if (!lockMain)\n         return;\n+\n     // Some quantities (such as number of blocks) change so fast that we don't want to be notified for each change.\n     // Periodically check and update with a timer.\n     int newNumBlocks = getNumBlocks();\n+    QDateTime newBlockDate = getLastBlockDate();\n \n     // check for changed number of blocks we have, number of blocks peers claim to have, reindexing state and importing state\n     if (cachedNumBlocks != newNumBlocks ||\n-        cachedReindexing != fReindex || cachedImporting != fImporting)\n+        cachedBlockDate != newBlockDate ||\n+        cachedReindexing != fReindex ||\n+        cachedImporting != fImporting)\n     {\n         cachedNumBlocks = newNumBlocks;\n+        cachedBlockDate = newBlockDate;\n         cachedReindexing = fReindex;\n         cachedImporting = fImporting;\n \n-        emit numBlocksChanged(newNumBlocks);\n+        emit numBlocksChanged(newNumBlocks, newBlockDate);\n     }\n \n     emit bytesChanged(getTotalBytesRecv(), getTotalBytesSent());\n@@ -212,14 +213,14 @@ static void ShowProgress(ClientModel *clientmodel, const std::string &title, int\n \n static void NotifyNumConnectionsChanged(ClientModel *clientmodel, int newNumConnections)\n {\n-    // Too noisy: qDebug() << \"NotifyNumConnectionsChanged : \" + QString::number(newNumConnections);\n+    // Too noisy: qDebug() << \"NotifyNumConnectionsChanged: \" + QString::number(newNumConnections);\n     QMetaObject::invokeMethod(clientmodel, \"updateNumConnections\", Qt::QueuedConnection,\n                               Q_ARG(int, newNumConnections));\n }\n \n static void NotifyAlertChanged(ClientModel *clientmodel, const uint256 &hash, ChangeType status)\n {\n-    qDebug() << \"NotifyAlertChanged : \" + QString::fromStdString(hash.GetHex()) + \" status=\" + QString::number(status);\n+    qDebug() << \"NotifyAlertChanged: \" + QString::fromStdString(hash.GetHex()) + \" status=\" + QString::number(status);\n     QMetaObject::invokeMethod(clientmodel, \"updateAlert\", Qt::QueuedConnection,\n                               Q_ARG(QString, QString::fromStdString(hash.GetHex())),\n                               Q_ARG(int, status));"
      },
      {
        "sha": "214701810c0dff36dabcc3aa77fe17e989685e1f",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_QT_CLIENTMODEL_H\n \n #include <QObject>\n+#include <QDateTime>\n \n class AddressTableModel;\n class OptionsModel;\n@@ -15,7 +16,6 @@ class TransactionTableModel;\n class CWallet;\n \n QT_BEGIN_NAMESPACE\n-class QDateTime;\n class QTimer;\n QT_END_NAMESPACE\n \n@@ -48,7 +48,6 @@ class ClientModel : public QObject\n     //! Return number of connections, default is in- and outbound (total)\n     int getNumConnections(unsigned int flags = CONNECTIONS_ALL) const;\n     int getNumBlocks() const;\n-    int getNumBlocksAtStartup();\n \n     quint64 getTotalBytesRecv() const;\n     quint64 getTotalBytesSent() const;\n@@ -74,19 +73,18 @@ class ClientModel : public QObject\n     PeerTableModel *peerTableModel;\n \n     int cachedNumBlocks;\n+    QDateTime cachedBlockDate;\n     bool cachedReindexing;\n     bool cachedImporting;\n \n-    int numBlocksAtStartup;\n-\n     QTimer *pollTimer;\n \n     void subscribeToCoreSignals();\n     void unsubscribeFromCoreSignals();\n \n signals:\n     void numConnectionsChanged(int count);\n-    void numBlocksChanged(int count);\n+    void numBlocksChanged(int count, const QDateTime& blockDate);\n     void alertsChanged(const QString &warnings);\n     void bytesChanged(quint64 totalBytesIn, quint64 totalBytesOut);\n "
      },
      {
        "sha": "7531fbddcbef0aebaf612b316fe25ac8c0b089aa",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 17,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -8,14 +8,14 @@\n #include \"addresstablemodel.h\"\n #include \"bitcoinunits.h\"\n #include \"guiutil.h\"\n-#include \"init.h\"\n #include \"optionsmodel.h\"\n #include \"scicon.h\"\n #include \"walletmodel.h\"\n \n #include \"coincontrol.h\"\n+#include \"init.h\"\n #include \"main.h\"\n-#include \"wallet.h\"\n+#include \"wallet/wallet.h\"\n \n #include <boost/assign/list_of.hpp> // for 'map_list_of()'\n \n@@ -33,6 +33,7 @@\n using namespace std;\n QList<CAmount> CoinControlDialog::payAmounts;\n CCoinControl* CoinControlDialog::coinControl = new CCoinControl();\n+bool CoinControlDialog::fSubtractFeeFromAmount = false;\n \n CoinControlDialog::CoinControlDialog(QWidget *parent) :\n     QDialog(parent),\n@@ -117,18 +118,22 @@ CoinControlDialog::CoinControlDialog(QWidget *parent) :\n     // (un)select all\n     connect(ui->pushButtonSelectAll, SIGNAL(clicked()), this, SLOT(buttonSelectAllClicked()));\n \n+    // change coin control first column label due Qt4 bug. \n+    // see https://github.com/bitcoin/bitcoin/issues/5716\n+    ui->treeWidget->headerItem()->setText(COLUMN_CHECKBOX, QString());\n+\n     ui->treeWidget->setColumnWidth(COLUMN_CHECKBOX, 84);\n     ui->treeWidget->setColumnWidth(COLUMN_AMOUNT, 100);\n     ui->treeWidget->setColumnWidth(COLUMN_LABEL, 170);\n     ui->treeWidget->setColumnWidth(COLUMN_ADDRESS, 290);\n     ui->treeWidget->setColumnWidth(COLUMN_DATE, 110);\n     ui->treeWidget->setColumnWidth(COLUMN_CONFIRMATIONS, 100);\n     ui->treeWidget->setColumnWidth(COLUMN_PRIORITY, 100);\n-    ui->treeWidget->setColumnHidden(COLUMN_TXHASH, true);         // store transacton hash in this column, but dont show it\n-    ui->treeWidget->setColumnHidden(COLUMN_VOUT_INDEX, true);     // store vout index in this column, but dont show it\n-    ui->treeWidget->setColumnHidden(COLUMN_AMOUNT_INT64, true);   // store amount int64 in this column, but dont show it\n-    ui->treeWidget->setColumnHidden(COLUMN_PRIORITY_INT64, true); // store priority int64 in this column, but dont show it\n-    ui->treeWidget->setColumnHidden(COLUMN_DATE_INT64, true);     // store date int64 in this column, but dont show it\n+    ui->treeWidget->setColumnHidden(COLUMN_TXHASH, true);         // store transacton hash in this column, but don't show it\n+    ui->treeWidget->setColumnHidden(COLUMN_VOUT_INDEX, true);     // store vout index in this column, but don't show it\n+    ui->treeWidget->setColumnHidden(COLUMN_AMOUNT_INT64, true);   // store amount int64 in this column, but don't show it\n+    ui->treeWidget->setColumnHidden(COLUMN_PRIORITY_INT64, true); // store priority int64 in this column, but don't show it\n+    ui->treeWidget->setColumnHidden(COLUMN_DATE_INT64, true);     // store date int64 in this column, but don't show it\n \n     // default view is sorted by amount desc\n     sortView(COLUMN_AMOUNT_INT64, Qt::DescendingOrder);\n@@ -403,8 +408,8 @@ void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n     }\n \n     // todo: this is a temporary qt5 fix: when clicking a parent node in tree mode, the parent node\n-    //       including all childs are partially selected. But the parent node should be fully selected\n-    //       as well as the childs. Childs should never be partially selected in the first place.\n+    //       including all children are partially selected. But the parent node should be fully selected\n+    //       as well as the children. Children should never be partially selected in the first place.\n     //       Please remove this ugly fix, once the bug is solved upstream.\n #if QT_VERSION >= 0x050000\n     else if (column == COLUMN_CHECKBOX && item->childCount() > 0)\n@@ -537,6 +542,11 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         dPriority = dPriorityInputs / (nBytes - nBytesInputs + (nQuantityUncompressed * 29)); // 29 = 180 - 151 (uncompressed public keys are over the limit. max 151 bytes of the input are ignored for priority)\n         sPriorityLabel = CoinControlDialog::getPriorityLabel(dPriority, mempoolEstimatePriority);\n \n+        // in the subtract fee from amount case, we can tell if zero change already and subtract the bytes, so that fee calculation afterwards is accurate\n+        if (CoinControlDialog::fSubtractFeeFromAmount)\n+            if (nAmount - nPayAmount == 0)\n+                nBytes -= 34;\n+\n         // Fee\n         nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, mempool);\n \n@@ -552,20 +562,27 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n         if (nPayAmount > 0)\n         {\n-            nChange = nAmount - nPayFee - nPayAmount;\n+            nChange = nAmount - nPayAmount;\n+            if (!CoinControlDialog::fSubtractFeeFromAmount)\n+                nChange -= nPayFee;\n \n             // Never create dust outputs; if we would, just add the dust to the fee.\n             if (nChange > 0 && nChange < CENT)\n             {\n                 CTxOut txout(nChange, (CScript)vector<unsigned char>(24, 0));\n                 if (txout.IsDust(::minRelayTxFee))\n                 {\n-                    nPayFee += nChange;\n-                    nChange = 0;\n+                    if (CoinControlDialog::fSubtractFeeFromAmount) // dust-change will be raised until no dust\n+                        nChange = txout.GetDustThreshold(::minRelayTxFee);\n+                    else\n+                    {\n+                        nPayFee += nChange;\n+                        nChange = 0;\n+                    }\n                 }\n             }\n \n-            if (nChange == 0)\n+            if (nChange == 0 && !CoinControlDialog::fSubtractFeeFromAmount)\n                 nBytes -= 34;\n         }\n \n@@ -608,7 +625,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     {\n         l3->setText(ASYMP_UTF8 + l3->text());\n         l4->setText(ASYMP_UTF8 + l4->text());\n-        if (nChange > 0)\n+        if (nChange > 0 && !CoinControlDialog::fSubtractFeeFromAmount)\n             l8->setText(ASYMP_UTF8 + l8->text());\n     }\n \n@@ -618,15 +635,15 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     l7->setStyleSheet((fDust) ? \"color:red;\" : \"\");                                     // Dust = \"yes\"\n \n     // tool tips\n-    QString toolTip1 = tr(\"This label turns red, if the transaction size is greater than 1000 bytes.\") + \"<br /><br />\";\n+    QString toolTip1 = tr(\"This label turns red if the transaction size is greater than 1000 bytes.\") + \"<br /><br />\";\n     toolTip1 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CWallet::minTxFee.GetFeePerK())) + \"<br /><br />\";\n     toolTip1 += tr(\"Can vary +/- 1 byte per input.\");\n \n     QString toolTip2 = tr(\"Transactions with higher priority are more likely to get included into a block.\") + \"<br /><br />\";\n-    toolTip2 += tr(\"This label turns red, if the priority is smaller than \\\"medium\\\".\") + \"<br /><br />\";\n+    toolTip2 += tr(\"This label turns red if the priority is smaller than \\\"medium\\\".\") + \"<br /><br />\";\n     toolTip2 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CWallet::minTxFee.GetFeePerK()));\n \n-    QString toolTip3 = tr(\"This label turns red, if any recipient receives an amount smaller than %1.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, ::minRelayTxFee.GetFee(546)));\n+    QString toolTip3 = tr(\"This label turns red if any recipient receives an amount smaller than %1.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, ::minRelayTxFee.GetFee(546)));\n \n     // how many satoshis the estimated fee can vary per byte we guess wrong\n     double dFeeVary;"
      },
      {
        "sha": "5ec382838f9069442773ec09a9d5571adf495214",
        "filename": "src/qt/coincontroldialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/coincontroldialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/coincontroldialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -43,6 +43,7 @@ class CoinControlDialog : public QDialog\n \n     static QList<CAmount> payAmounts;\n     static CCoinControl *coinControl;\n+    static bool fSubtractFeeFromAmount;\n \n private:\n     Ui::CoinControlDialog *ui;"
      },
      {
        "sha": "dc7df9d6c888a3223c4839cf2f7ba639ee6dc748",
        "filename": "src/qt/forms/helpmessagedialog.ui",
        "status": "modified",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/helpmessagedialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/helpmessagedialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/helpmessagedialog.ui?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -14,6 +14,69 @@\n    <string notr=\"true\">Bitcoin Core - Command-line options</string>\n   </property>\n   <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2\">\n+   <property name=\"spacing\">\n+    <number>0</number>\n+   </property>\n+   <property name=\"leftMargin\">\n+    <number>12</number>\n+   </property>\n+   <property name=\"topMargin\">\n+    <number>12</number>\n+   </property>\n+   <property name=\"rightMargin\">\n+    <number>12</number>\n+   </property>\n+   <property name=\"bottomMargin\">\n+    <number>12</number>\n+   </property>\n+   <item>\n+    <layout class=\"QVBoxLayout\" name=\"verticalLayoutLogo\" stretch=\"0,0\">\n+     <property name=\"leftMargin\">\n+      <number>0</number>\n+     </property>\n+     <property name=\"topMargin\">\n+      <number>4</number>\n+     </property>\n+     <property name=\"rightMargin\">\n+      <number>0</number>\n+     </property>\n+     <item>\n+      <widget class=\"QLabel\" name=\"aboutLogo\">\n+       <property name=\"sizePolicy\">\n+        <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Ignored\">\n+         <horstretch>0</horstretch>\n+         <verstretch>0</verstretch>\n+        </sizepolicy>\n+       </property>\n+       <property name=\"maximumSize\">\n+        <size>\n+         <width>100</width>\n+         <height>100</height>\n+        </size>\n+       </property>\n+       <property name=\"pixmap\">\n+        <pixmap resource=\"../bitcoin.qrc\">:/icons/bitcoin</pixmap>\n+       </property>\n+       <property name=\"scaledContents\">\n+        <bool>true</bool>\n+       </property>\n+       <property name=\"alignment\">\n+        <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>\n+       </property>\n+      </widget>\n+     </item>\n+     <item>\n+      <widget class=\"QFrame\" name=\"frame\">\n+       <property name=\"frameShape\">\n+        <enum>QFrame::NoFrame</enum>\n+       </property>\n+       <property name=\"frameShadow\">\n+        <enum>QFrame::Raised</enum>\n+       </property>\n+      </widget>\n+     </item>\n+    </layout>\n+   </item>\n    <item>\n     <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n      <item>\n@@ -25,6 +88,9 @@\n      </item>\n      <item>\n       <widget class=\"QScrollArea\" name=\"scrollArea\">\n+       <property name=\"frameShape\">\n+        <enum>QFrame::NoFrame</enum>\n+       </property>\n        <property name=\"verticalScrollBarPolicy\">\n         <enum>Qt::ScrollBarAlwaysOn</enum>\n        </property>\n@@ -56,6 +122,22 @@\n        </widget>\n       </widget>\n      </item>\n+     <item>\n+      <spacer name=\"verticalSpacer\">\n+       <property name=\"orientation\">\n+        <enum>Qt::Vertical</enum>\n+       </property>\n+       <property name=\"sizeType\">\n+        <enum>QSizePolicy::Fixed</enum>\n+       </property>\n+       <property name=\"sizeHint\" stdset=\"0\">\n+        <size>\n+         <width>4</width>\n+         <height>4</height>\n+        </size>\n+       </property>\n+      </spacer>\n+     </item>\n      <item>\n       <widget class=\"QDialogButtonBox\" name=\"okButton\">\n        <property name=\"orientation\">"
      },
      {
        "sha": "6d792d1475fed02143d7860f61ca3ed437fc5521",
        "filename": "src/qt/forms/overviewpage.ui",
        "status": "modified",
        "additions": 46,
        "deletions": 18,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/overviewpage.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/overviewpage.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/overviewpage.ui?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -59,21 +59,35 @@\n              </widget>\n             </item>\n             <item>\n-             <widget class=\"QLabel\" name=\"labelWalletStatus\">\n-              <property name=\"cursor\">\n-               <cursorShape>WhatsThisCursor</cursorShape>\n+             <widget class=\"QPushButton\" name=\"labelWalletStatus\">\n+              <property name=\"enabled\">\n+               <bool>false</bool>\n+              </property>\n+              <property name=\"maximumSize\">\n+               <size>\n+                <width>30</width>\n+                <height>16777215</height>\n+               </size>\n               </property>\n               <property name=\"toolTip\">\n                <string>The displayed information may be out of date. Your wallet automatically synchronizes with the Bitcoin network after a connection is established, but this process has not completed yet.</string>\n               </property>\n-              <property name=\"styleSheet\">\n-               <string notr=\"true\">QLabel { color: red; }</string>\n-              </property>\n               <property name=\"text\">\n-               <string notr=\"true\">(out of sync)</string>\n+               <string/>\n               </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n+              <property name=\"icon\">\n+               <iconset resource=\"../bitcoin.qrc\">\n+                <normaloff>:/icons/warning</normaloff>\n+                <disabledoff>:/icons/warning</disabledoff>:/icons/warning</iconset>\n+              </property>\n+              <property name=\"iconSize\">\n+               <size>\n+                <width>24</width>\n+                <height>24</height>\n+               </size>\n+              </property>\n+              <property name=\"flat\">\n+               <bool>true</bool>\n               </property>\n              </widget>\n             </item>\n@@ -431,21 +445,35 @@\n              </widget>\n             </item>\n             <item>\n-             <widget class=\"QLabel\" name=\"labelTransactionsStatus\">\n-              <property name=\"cursor\">\n-               <cursorShape>WhatsThisCursor</cursorShape>\n+             <widget class=\"QPushButton\" name=\"labelTransactionsStatus\">\n+              <property name=\"enabled\">\n+               <bool>false</bool>\n+              </property>\n+              <property name=\"maximumSize\">\n+               <size>\n+                <width>30</width>\n+                <height>16777215</height>\n+               </size>\n               </property>\n               <property name=\"toolTip\">\n                <string>The displayed information may be out of date. Your wallet automatically synchronizes with the Bitcoin network after a connection is established, but this process has not completed yet.</string>\n               </property>\n-              <property name=\"styleSheet\">\n-               <string notr=\"true\">QLabel { color: red; }</string>\n-              </property>\n               <property name=\"text\">\n-               <string notr=\"true\">(out of sync)</string>\n+               <string/>\n               </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+              <property name=\"icon\">\n+               <iconset resource=\"../bitcoin.qrc\">\n+                <normaloff>:/icons/warning</normaloff>\n+                <disabledoff>:/icons/warning</disabledoff>:/icons/warning</iconset>\n+              </property>\n+              <property name=\"iconSize\">\n+               <size>\n+                <width>24</width>\n+                <height>24</height>\n+               </size>\n+              </property>\n+              <property name=\"flat\">\n+               <bool>true</bool>\n               </property>\n              </widget>\n             </item>"
      },
      {
        "sha": "8911b41cbf31ac1f28a54df28ddba15ceede42e8",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -771,16 +771,6 @@\n                 </property>\n                </widget>\n               </item>\n-              <item>\n-               <widget class=\"QPushButton\" name=\"buttonMinimizeFee\">\n-                <property name=\"toolTip\">\n-                 <string>collapse fee-settings</string>\n-                </property>\n-                <property name=\"text\">\n-                 <string>Minimize</string>\n-                </property>\n-               </widget>\n-              </item>\n              </layout>\n             </item>\n             <item>\n@@ -811,6 +801,16 @@\n             </property>\n            </spacer>\n           </item>\n+          <item>\n+           <widget class=\"QPushButton\" name=\"buttonMinimizeFee\">\n+            <property name=\"toolTip\">\n+             <string>collapse fee-settings</string>\n+            </property>\n+            <property name=\"text\">\n+             <string>Hide</string>\n+            </property>\n+           </widget>\n+          </item>\n          </layout>\n         </item>\n         <item>"
      },
      {
        "sha": "df06f36833f45ddf0a9bd719f38984118cc66d48",
        "filename": "src/qt/forms/sendcoinsentry.ui",
        "status": "modified",
        "additions": 39,
        "deletions": 18,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/sendcoinsentry.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/forms/sendcoinsentry.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsentry.ui?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -21,15 +21,21 @@\n     <string>This is a normal payment.</string>\n    </property>\n    <property name=\"frameShape\">\n-    <enum>QFrame::StyledPanel</enum>\n-   </property>\n-   <property name=\"frameShadow\">\n-    <enum>QFrame::Sunken</enum>\n+    <enum>QFrame::NoFrame</enum>\n    </property>\n    <layout class=\"QGridLayout\" name=\"gridLayout\">\n-    <property name=\"spacing\">\n+    <property name=\"topMargin\">\n+     <number>8</number>\n+    </property>\n+    <property name=\"bottomMargin\">\n+     <number>4</number>\n+    </property>\n+    <property name=\"horizontalSpacing\">\n      <number>12</number>\n     </property>\n+    <property name=\"verticalSpacing\">\n+     <number>8</number>\n+    </property>\n     <item row=\"0\" column=\"0\">\n      <widget class=\"QLabel\" name=\"payToLabel\">\n       <property name=\"text\">\n@@ -157,7 +163,21 @@\n      </widget>\n     </item>\n     <item row=\"2\" column=\"1\">\n-     <widget class=\"BitcoinAmountField\" name=\"payAmount\"/>\n+     <layout class=\"QHBoxLayout\" name=\"horizontalLayoutAmount\" stretch=\"0,1\">\n+      <item>\n+       <widget class=\"BitcoinAmountField\" name=\"payAmount\"/>\n+      </item>\n+      <item>\n+       <widget class=\"QCheckBox\" name=\"checkboxSubtractFeeFromAmount\">\n+        <property name=\"toolTip\">\n+         <string>The fee will be deducted from the amount being sent. The recipient will receive less bitcoins than you enter in the amount field. If multiple recipients are selected, the fee is split equally.</string>\n+        </property>\n+        <property name=\"text\">\n+         <string>S&amp;ubtract fee from amount</string>\n+        </property>\n+       </widget>\n+      </item>\n+     </layout>\n     </item>\n     <item row=\"3\" column=\"0\">\n      <widget class=\"QLabel\" name=\"messageLabel\">\n@@ -179,9 +199,16 @@\n       </property>\n      </widget>\n     </item>\n+    <item row=\"4\" column=\"0\" colspan=\"2\">\n+     <widget class=\"Line\" name=\"line\">\n+      <property name=\"orientation\">\n+       <enum>Qt::Horizontal</enum>\n+      </property>\n+     </widget>\n+    </item>\n    </layout>\n   </widget>\n-  <widget class=\"QFrame\" name=\"SendCoins_InsecurePaymentRequest\">\n+  <widget class=\"QFrame\" name=\"SendCoins_UnauthenticatedPaymentRequest\">\n    <property name=\"palette\">\n     <palette>\n      <active>\n@@ -598,16 +625,13 @@\n     </palette>\n    </property>\n    <property name=\"toolTip\">\n-    <string>This is an unverified payment request.</string>\n+    <string>This is an unauthenticated payment request.</string>\n    </property>\n    <property name=\"autoFillBackground\">\n     <bool>true</bool>\n    </property>\n    <property name=\"frameShape\">\n-    <enum>QFrame::StyledPanel</enum>\n-   </property>\n-   <property name=\"frameShadow\">\n-    <enum>QFrame::Sunken</enum>\n+    <enum>QFrame::NoFrame</enum>\n    </property>\n    <layout class=\"QGridLayout\" name=\"gridLayout_is\">\n     <property name=\"spacing\">\n@@ -686,7 +710,7 @@\n     </item>\n    </layout>\n   </widget>\n-  <widget class=\"QFrame\" name=\"SendCoins_SecurePaymentRequest\">\n+  <widget class=\"QFrame\" name=\"SendCoins_AuthenticatedPaymentRequest\">\n    <property name=\"palette\">\n     <palette>\n      <active>\n@@ -1130,16 +1154,13 @@\n     </palette>\n    </property>\n    <property name=\"toolTip\">\n-    <string>This is a verified payment request.</string>\n+    <string>This is an authenticated payment request.</string>\n    </property>\n    <property name=\"autoFillBackground\">\n     <bool>true</bool>\n    </property>\n    <property name=\"frameShape\">\n-    <enum>QFrame::StyledPanel</enum>\n-   </property>\n-   <property name=\"frameShadow\">\n-    <enum>QFrame::Sunken</enum>\n+    <enum>QFrame::NoFrame</enum>\n    </property>\n    <layout class=\"QGridLayout\" name=\"gridLayout_s\">\n     <property name=\"spacing\">"
      },
      {
        "sha": "4a1f728e184f206a6095e800ba7c390458d4b6f7",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 13,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -40,6 +40,7 @@\n #if BOOST_FILESYSTEM_VERSION >= 3\n #include <boost/filesystem/detail/utf8_codecvt_facet.hpp>\n #endif\n+#include <boost/scoped_array.hpp>\n \n #include <QAbstractItemView>\n #include <QApplication>\n@@ -567,12 +568,17 @@ TableViewLastColumnResizingFixer::TableViewLastColumnResizingFixer(QTableView* t\n #ifdef WIN32\n boost::filesystem::path static StartupShortcutPath()\n {\n+    if (GetBoolArg(\"-testnet\", false))\n+        return GetSpecialFolderPath(CSIDL_STARTUP) / \"Bitcoin (testnet).lnk\";\n+    else if (GetBoolArg(\"-regtest\", false))\n+        return GetSpecialFolderPath(CSIDL_STARTUP) / \"Bitcoin (regtest).lnk\";\n+\n     return GetSpecialFolderPath(CSIDL_STARTUP) / \"Bitcoin.lnk\";\n }\n \n bool GetStartOnSystemStartup()\n {\n-    // check for Bitcoin.lnk\n+    // check for Bitcoin*.lnk\n     return boost::filesystem::exists(StartupShortcutPath());\n }\n \n@@ -588,29 +594,43 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n         // Get a pointer to the IShellLink interface.\n         IShellLink* psl = NULL;\n         HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,\n-                                CLSCTX_INPROC_SERVER, IID_IShellLink,\n-                                reinterpret_cast<void**>(&psl));\n+            CLSCTX_INPROC_SERVER, IID_IShellLink,\n+            reinterpret_cast<void**>(&psl));\n \n         if (SUCCEEDED(hres))\n         {\n             // Get the current executable path\n             TCHAR pszExePath[MAX_PATH];\n             GetModuleFileName(NULL, pszExePath, sizeof(pszExePath));\n \n-            TCHAR pszArgs[5] = TEXT(\"-min\");\n+            // Start client minimized\n+            QString strArgs = \"-min\";\n+            // Set -testnet /-regtest options\n+            strArgs += QString::fromStdString(strprintf(\" -testnet=%d -regtest=%d\", GetBoolArg(\"-testnet\", false), GetBoolArg(\"-regtest\", false)));\n+\n+#ifdef UNICODE\n+            boost::scoped_array<TCHAR> args(new TCHAR[strArgs.length() + 1]);\n+            // Convert the QString to TCHAR*\n+            strArgs.toWCharArray(args.get());\n+            // Add missing '\\0'-termination to string\n+            args[strArgs.length()] = '\\0';\n+#endif\n \n             // Set the path to the shortcut target\n             psl->SetPath(pszExePath);\n             PathRemoveFileSpec(pszExePath);\n             psl->SetWorkingDirectory(pszExePath);\n             psl->SetShowCmd(SW_SHOWMINNOACTIVE);\n-            psl->SetArguments(pszArgs);\n+#ifndef UNICODE\n+            psl->SetArguments(strArgs.toStdString().c_str());\n+#else\n+            psl->SetArguments(args.get());\n+#endif\n \n             // Query IShellLink for the IPersistFile interface for\n             // saving the shortcut in persistent storage.\n             IPersistFile* ppf = NULL;\n-            hres = psl->QueryInterface(IID_IPersistFile,\n-                                       reinterpret_cast<void**>(&ppf));\n+            hres = psl->QueryInterface(IID_IPersistFile, reinterpret_cast<void**>(&ppf));\n             if (SUCCEEDED(hres))\n             {\n                 WCHAR pwsz[MAX_PATH];\n@@ -630,11 +650,10 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n     }\n     return true;\n }\n-\n #elif defined(Q_OS_LINUX)\n \n // Follow the Desktop Application Autostart Spec:\n-//  http://standards.freedesktop.org/autostart-spec/autostart-spec-latest.html\n+// http://standards.freedesktop.org/autostart-spec/autostart-spec-latest.html\n \n boost::filesystem::path static GetAutostartDir()\n {\n@@ -690,8 +709,13 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n         // Write a bitcoin.desktop file to the autostart directory:\n         optionFile << \"[Desktop Entry]\\n\";\n         optionFile << \"Type=Application\\n\";\n-        optionFile << \"Name=Bitcoin\\n\";\n-        optionFile << \"Exec=\" << pszExePath << \" -min\\n\";\n+        if (GetBoolArg(\"-testnet\", false))\n+            optionFile << \"Name=Bitcoin (testnet)\\n\";\n+        else if (GetBoolArg(\"-regtest\", false))\n+            optionFile << \"Name=Bitcoin (regtest)\\n\";\n+        else\n+            optionFile << \"Name=Bitcoin\\n\";\n+        optionFile << \"Exec=\" << pszExePath << strprintf(\" -min -testnet=%d -regtest=%d\\n\", GetBoolArg(\"-testnet\", false), GetBoolArg(\"-regtest\", false));\n         optionFile << \"Terminal=false\\n\";\n         optionFile << \"Hidden=false\\n\";\n         optionFile.close();\n@@ -715,7 +739,18 @@ LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef\n         LSSharedFileListItemRef item = (LSSharedFileListItemRef)CFArrayGetValueAtIndex(listSnapshot, i);\n         UInt32 resolutionFlags = kLSSharedFileListNoUserInteraction | kLSSharedFileListDoNotMountVolumes;\n         CFURLRef currentItemURL = NULL;\n+\n+#if defined(MAC_OS_X_VERSION_MAX_ALLOWED) && MAC_OS_X_VERSION_MAX_ALLOWED >= 10100\n+    if(&LSSharedFileListItemCopyResolvedURL)\n+        currentItemURL = LSSharedFileListItemCopyResolvedURL(item, resolutionFlags, NULL);\n+#if defined(MAC_OS_X_VERSION_MIN_REQUIRED) && MAC_OS_X_VERSION_MIN_REQUIRED < 10100\n+    else\n         LSSharedFileListItemResolve(item, resolutionFlags, &currentItemURL, NULL);\n+#endif\n+#else\n+    LSSharedFileListItemResolve(item, resolutionFlags, &currentItemURL, NULL);\n+#endif\n+\n         if(currentItemURL && CFEqual(currentItemURL, findUrl)) {\n             // found\n             CFRelease(currentItemURL);\n@@ -843,10 +878,13 @@ QString formatServicesStr(quint64 mask)\n             switch (check)\n             {\n             case NODE_NETWORK:\n-                strList.append(QObject::tr(\"NETWORK\"));\n+                strList.append(\"NETWORK\");\n+                break;\n+            case NODE_GETUTXO:\n+                strList.append(\"GETUTXO\");\n                 break;\n             default:\n-                strList.append(QString(\"%1[%2]\").arg(QObject::tr(\"UNKNOWN\")).arg(check));\n+                strList.append(QString(\"%1[%2]\").arg(\"UNKNOWN\").arg(check));\n             }\n         }\n     }"
      },
      {
        "sha": "835ddb8eaa753f6356d70d34a3aff07c0281535c",
        "filename": "src/qt/locale/bitcoin_ach.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ach.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ach.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ach.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,4 +1,4 @@\n-<TS language=\"ach\" version=\"2.0\">\n+<TS language=\"ach\" version=\"2.1\">\n <context>\n     <name>AddressBookPage</name>\n     </context>"
      },
      {
        "sha": "5ef7d3fd37d0de87907bfc7266cf8456b0d9abb3",
        "filename": "src/qt/locale/bitcoin_af_ZA.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 15,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_af_ZA.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_af_ZA.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_af_ZA.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667",
        "patch": "@@ -1,10 +1,6 @@\n-<TS language=\"af_ZA\" version=\"2.0\">\n+<TS language=\"af_ZA\" version=\"2.1\">\n <context>\n     <name>AddressBookPage</name>\n-    <message>\n-        <source>Double-click to edit address or label</source>\n-        <translation>Dubbel-klik om die adres of etiket te wysig</translation>\n-    </message>\n     <message>\n         <source>Create a new address</source>\n         <translation>Skep 'n nuwe adres</translation>\n@@ -71,10 +67,6 @@\n         <source>Change passphrase</source>\n         <translation>Verander wagwoord</translation>\n     </message>\n-    <message>\n-        <source>Enter the old and new passphrase to the wallet.</source>\n-        <translation>Tik asseblief die ou en nuwe wagwoord vir die beursie in.</translation>\n-    </message>\n     <message>\n         <source>Confirm wallet encryption</source>\n         <translation>Bevestig beursie enkripsie.</translation>\n@@ -489,8 +481,8 @@\n         <translation>Tipe</translation>\n     </message>\n     <message>\n-        <source>Address</source>\n-        <translation>Adres</translation>\n+        <source>Label</source>\n+        <translation>Etiket</translation>\n     </message>\n     <message>\n         <source>Received with</source>\n@@ -658,10 +650,6 @@\n         <source>Loading addresses...</source>\n         <translation>Laai adresse...</translation>\n     </message>\n-    <message>\n-        <source>Invalid amount</source>\n-        <translation>Ongeldige bedrag</translation>\n-    </message>\n     <message>\n         <source>Insufficient funds</source>\n         <translation>Onvoldoende fondse</translation>"
      },
      {
        "sha": "235b22cd1f4cdd01ea75a92dec466096a80df847",
        "filename": "src/qt/locale/bitcoin_ar.ts",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ar.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ar.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ar.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "b727b7556698691932e2cf67b804473844d95200",
        "filename": "src/qt/locale/bitcoin_be_BY.ts",
        "status": "modified",
        "additions": 602,
        "deletions": 48,
        "changes": 650,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_be_BY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_be_BY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_be_BY.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "c86fdd42ddc96a96a2609a89543d997b1d8a4169",
        "filename": "src/qt/locale/bitcoin_bg.ts",
        "status": "modified",
        "additions": 1150,
        "deletions": 174,
        "changes": 1324,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_bg.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_bg.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_bg.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "fc5e6d270e7621fb18c20a2e161657485fe24d1c",
        "filename": "src/qt/locale/bitcoin_bs.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_bs.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_bs.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_bs.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "f7d97eb0618022db2f9fea6dc0808a105a22bf51",
        "filename": "src/qt/locale/bitcoin_ca.ts",
        "status": "modified",
        "additions": 403,
        "deletions": 207,
        "changes": 610,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ca.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ca.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "c68cfb686a85ad02cfa30b5a0096e687cf95f91b",
        "filename": "src/qt/locale/bitcoin_ca@valencia.ts",
        "status": "modified",
        "additions": 39,
        "deletions": 218,
        "changes": 257,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ca@valencia.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ca@valencia.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca@valencia.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "cd6aa96d3403c4faf196499fba5e69e0ca071028",
        "filename": "src/qt/locale/bitcoin_ca_ES.ts",
        "status": "modified",
        "additions": 403,
        "deletions": 207,
        "changes": 610,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ca_ES.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ca_ES.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca_ES.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "3286f126982b2e1dcdda1a7c50bf7125ed5eb6bc",
        "filename": "src/qt/locale/bitcoin_cmn.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_cmn.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_cmn.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cmn.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "47464b7a53825ab590c010d29efa8a302cfc365f",
        "filename": "src/qt/locale/bitcoin_cs.ts",
        "status": "modified",
        "additions": 368,
        "deletions": 204,
        "changes": 572,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_cs.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_cs.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cs.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "9867375fb2b5a1b609feb81d3bc82932016f0a13",
        "filename": "src/qt/locale/bitcoin_cy.ts",
        "status": "modified",
        "additions": 5,
        "deletions": 13,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_cy.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_cy.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cy.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "1467791047905e2fbfe8a3b8f6786f2ec00df374",
        "filename": "src/qt/locale/bitcoin_da.ts",
        "status": "modified",
        "additions": 305,
        "deletions": 219,
        "changes": 524,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_da.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_da.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_da.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "ab0367dbabffa312733a8d7b8da766c673836ade",
        "filename": "src/qt/locale/bitcoin_de.ts",
        "status": "modified",
        "additions": 302,
        "deletions": 211,
        "changes": 513,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_de.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_de.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_de.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "a4c95857ba7122bf9c29d35fc8ba1f4b8784f3df",
        "filename": "src/qt/locale/bitcoin_el_GR.ts",
        "status": "modified",
        "additions": 252,
        "deletions": 240,
        "changes": 492,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_el_GR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_el_GR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_el_GR.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "90a13feacae77ceb37782cb36cfc5d63b359bc1f",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 568,
        "deletions": 469,
        "changes": 1037,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "007acbc49564be515633f28b757633f5c127fa93",
        "filename": "src/qt/locale/bitcoin_eo.ts",
        "status": "modified",
        "additions": 42,
        "deletions": 202,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_eo.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_eo.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_eo.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "17ec4dca5da97acff93ff8aaafb4a340372a25bf",
        "filename": "src/qt/locale/bitcoin_es.ts",
        "status": "modified",
        "additions": 229,
        "deletions": 231,
        "changes": 460,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "f50aa491100bc5d83bfa08ac014004739c92fce3",
        "filename": "src/qt/locale/bitcoin_es_CL.ts",
        "status": "modified",
        "additions": 106,
        "deletions": 99,
        "changes": 205,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_CL.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_CL.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_CL.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "d2cdf87a0e00638b8542b0f5981ce641601083cd",
        "filename": "src/qt/locale/bitcoin_es_DO.ts",
        "status": "modified",
        "additions": 40,
        "deletions": 176,
        "changes": 216,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_DO.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_DO.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_DO.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "42383301054586358ed2724a1d83647ea075da1c",
        "filename": "src/qt/locale/bitcoin_es_MX.ts",
        "status": "modified",
        "additions": 31,
        "deletions": 67,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_MX.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_MX.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_MX.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "48a6f35f92d32323beae23b148eac48d7ba62346",
        "filename": "src/qt/locale/bitcoin_es_UY.ts",
        "status": "modified",
        "additions": 5,
        "deletions": 17,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_UY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_es_UY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_UY.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "29a45960c9d86b7cc41707a836bb40b3300bc40d",
        "filename": "src/qt/locale/bitcoin_et.ts",
        "status": "modified",
        "additions": 328,
        "deletions": 169,
        "changes": 497,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_et.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_et.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_et.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "d68411d382891eb0347fab5394e70982a1e64c07",
        "filename": "src/qt/locale/bitcoin_eu_ES.ts",
        "status": "modified",
        "additions": 5,
        "deletions": 17,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_eu_ES.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_eu_ES.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_eu_ES.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "33f43f0c2ddeee581bb02adaf0293e5e14574be9",
        "filename": "src/qt/locale/bitcoin_fa.ts",
        "status": "modified",
        "additions": 96,
        "deletions": 124,
        "changes": 220,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fa.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fa.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "da95f10474813d68be2b35c35595e97c7be11cf8",
        "filename": "src/qt/locale/bitcoin_fa_IR.ts",
        "status": "modified",
        "additions": 10,
        "deletions": 51,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fa_IR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fa_IR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa_IR.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "db59ea1751e6a82ad549f1f841094294c7f0de57",
        "filename": "src/qt/locale/bitcoin_fi.ts",
        "status": "modified",
        "additions": 346,
        "deletions": 197,
        "changes": 543,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fi.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fi.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fi.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "67d920fd5ed9b702fcca71b1652186b2694ab482",
        "filename": "src/qt/locale/bitcoin_fr.ts",
        "status": "modified",
        "additions": 299,
        "deletions": 217,
        "changes": 516,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "186985d493e19f3f998917553104a658afee1794",
        "filename": "src/qt/locale/bitcoin_fr_CA.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fr_CA.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_fr_CA.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr_CA.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "2473260c845b1fe0200a82c553f5b45ba535696f",
        "filename": "src/qt/locale/bitcoin_gl.ts",
        "status": "modified",
        "additions": 23,
        "deletions": 187,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_gl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_gl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_gl.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "b7b091aa39c036194a55d816fffbe123b5c1c318",
        "filename": "src/qt/locale/bitcoin_gu_IN.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_gu_IN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_gu_IN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_gu_IN.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "66dd05fca7779103cff5d3275416eb9525345b37",
        "filename": "src/qt/locale/bitcoin_he.ts",
        "status": "modified",
        "additions": 33,
        "deletions": 228,
        "changes": 261,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_he.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_he.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_he.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "5fe8635dc04d18be9c9e9739c08a9640edb8e2c3",
        "filename": "src/qt/locale/bitcoin_hi_IN.ts",
        "status": "modified",
        "additions": 6,
        "deletions": 49,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_hi_IN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_hi_IN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hi_IN.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "62bfe6a11f93cafffbf189a37f11dfc923f03bcf",
        "filename": "src/qt/locale/bitcoin_hr.ts",
        "status": "modified",
        "additions": 12,
        "deletions": 84,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_hr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_hr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hr.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "c84d2c4e8721bf2e0f8b2eb5efaa1cd8cd945c8b",
        "filename": "src/qt/locale/bitcoin_hu.ts",
        "status": "modified",
        "additions": 106,
        "deletions": 170,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_hu.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_hu.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hu.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "dec30dafb348d933a12f9f8d49cf7d326ab896f5",
        "filename": "src/qt/locale/bitcoin_id_ID.ts",
        "status": "modified",
        "additions": 19,
        "deletions": 139,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_id_ID.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_id_ID.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_id_ID.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "c81f458e39086932aeb81ee33627e51beb7d8cb2",
        "filename": "src/qt/locale/bitcoin_it.ts",
        "status": "modified",
        "additions": 725,
        "deletions": 395,
        "changes": 1120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_it.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_it.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_it.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "376d36bed0063ec1d72f71e9443608f7a45b36ab",
        "filename": "src/qt/locale/bitcoin_ja.ts",
        "status": "modified",
        "additions": 1339,
        "deletions": 163,
        "changes": 1502,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ja.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ja.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ja.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "b9e118a620eb63896bd397421ef3ee924f585551",
        "filename": "src/qt/locale/bitcoin_ka.ts",
        "status": "modified",
        "additions": 22,
        "deletions": 182,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ka.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ka.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ka.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "4cc709fdb27688125ed12b8a4f0cecdd7115bb2f",
        "filename": "src/qt/locale/bitcoin_kk_KZ.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_kk_KZ.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_kk_KZ.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_kk_KZ.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "42eb9eedbbc3bcdfdf26da609fe054ebeeeaa67f",
        "filename": "src/qt/locale/bitcoin_ko_KR.ts",
        "status": "modified",
        "additions": 26,
        "deletions": 164,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ko_KR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ko_KR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ko_KR.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "8edee19c7037031dfb40bcae95454b814dc3effb",
        "filename": "src/qt/locale/bitcoin_ky.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 10,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ky.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ky.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ky.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "3e25cf95b66e66c1d01b80d62a49dcce0fde3bfb",
        "filename": "src/qt/locale/bitcoin_la.ts",
        "status": "modified",
        "additions": 20,
        "deletions": 184,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_la.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_la.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_la.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "01fa94bab36e5d5cabd3fd9bf0dc1cb32f0d13cc",
        "filename": "src/qt/locale/bitcoin_lt.ts",
        "status": "modified",
        "additions": 17,
        "deletions": 108,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_lt.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_lt.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_lt.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "25f92b66428e2fc6c5cb3c34c24a9bb791b84147",
        "filename": "src/qt/locale/bitcoin_lv_LV.ts",
        "status": "modified",
        "additions": 21,
        "deletions": 145,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_lv_LV.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_lv_LV.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_lv_LV.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "a1a07af8d5d23193afb155a2487af0526c3dde46",
        "filename": "src/qt/locale/bitcoin_mn.ts",
        "status": "modified",
        "additions": 7,
        "deletions": 62,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_mn.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_mn.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_mn.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "999961beb8f94f5a8ec481a0b5fae70e6e2778ac",
        "filename": "src/qt/locale/bitcoin_ms_MY.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ms_MY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ms_MY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ms_MY.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "6e2b4e9fcc61411224e94dc89a0d8af7eff0a648",
        "filename": "src/qt/locale/bitcoin_nb.ts",
        "status": "modified",
        "additions": 313,
        "deletions": 226,
        "changes": 539,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_nb.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_nb.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_nb.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "385972845aa6a1345cb1511897ab6fa08f658e92",
        "filename": "src/qt/locale/bitcoin_nl.ts",
        "status": "modified",
        "additions": 337,
        "deletions": 220,
        "changes": 557,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_nl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_nl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_nl.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "54c30dfb6f5566ec69040254cd53d3252002425c",
        "filename": "src/qt/locale/bitcoin_pam.ts",
        "status": "modified",
        "additions": 20,
        "deletions": 112,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pam.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pam.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pam.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "db49e20cf1e1933dc2b0219934fd54f34e1ce750",
        "filename": "src/qt/locale/bitcoin_pl.ts",
        "status": "modified",
        "additions": 643,
        "deletions": 274,
        "changes": 917,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pl.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "42a781de991490314c48b5b8929db19e08ccabc6",
        "filename": "src/qt/locale/bitcoin_pt_BR.ts",
        "status": "modified",
        "additions": 461,
        "deletions": 250,
        "changes": 711,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pt_BR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pt_BR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_BR.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "5012ff8d837b2e51d64e79b1529128d9e21ea206",
        "filename": "src/qt/locale/bitcoin_pt_PT.ts",
        "status": "modified",
        "additions": 472,
        "deletions": 181,
        "changes": 653,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pt_PT.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_pt_PT.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_PT.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "11a29e86c936290c9462f83cf8a2c60ab45d176f",
        "filename": "src/qt/locale/bitcoin_ro_RO.ts",
        "status": "modified",
        "additions": 1119,
        "deletions": 510,
        "changes": 1629,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ro_RO.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ro_RO.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ro_RO.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "c208b3e25eb51587b374740b7e50f7194e071e28",
        "filename": "src/qt/locale/bitcoin_ru.ts",
        "status": "modified",
        "additions": 95,
        "deletions": 283,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ru.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ru.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ru.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "6cc17f480afd4f24a7976203b31cca0d82128e66",
        "filename": "src/qt/locale/bitcoin_sah.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sah.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sah.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sah.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "8e7d38be008dd37ec8dc688c1b80d5a9c40b1db9",
        "filename": "src/qt/locale/bitcoin_sk.ts",
        "status": "modified",
        "additions": 291,
        "deletions": 222,
        "changes": 513,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sk.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sk.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sk.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "abbdba376004c1649c07bc85c15f9d68cb109fac",
        "filename": "src/qt/locale/bitcoin_sl_SI.ts",
        "status": "modified",
        "additions": 29,
        "deletions": 145,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sl_SI.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sl_SI.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sl_SI.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "2e345e85cbd52bcff7035dc6ab64a9046ec227f2",
        "filename": "src/qt/locale/bitcoin_sq.ts",
        "status": "modified",
        "additions": 185,
        "deletions": 13,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sq.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sq.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sq.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "83e6e2f29eb9548306a54a892f488c778552c2b1",
        "filename": "src/qt/locale/bitcoin_sr.ts",
        "status": "modified",
        "additions": 5,
        "deletions": 33,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sr.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "289074f13418696b10e65cc015f1b8443d4fa8e8",
        "filename": "src/qt/locale/bitcoin_sv.ts",
        "status": "modified",
        "additions": 300,
        "deletions": 218,
        "changes": 518,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sv.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_sv.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sv.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "7b5d1ae01c087c1f2cba34b0fc731d26ab03352e",
        "filename": "src/qt/locale/bitcoin_th_TH.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 11,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_th_TH.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_th_TH.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_th_TH.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "bf6f3f279196766976d2e6a530c5679941b815bc",
        "filename": "src/qt/locale/bitcoin_tr.ts",
        "status": "modified",
        "additions": 301,
        "deletions": 219,
        "changes": 520,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_tr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_tr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_tr.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "92e0cc75c46319f5b37b999b5a2983e386f71756",
        "filename": "src/qt/locale/bitcoin_uk.ts",
        "status": "modified",
        "additions": 81,
        "deletions": 241,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_uk.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_uk.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_uk.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "9148626f57bc527dbb29f734cfc854a329562ef8",
        "filename": "src/qt/locale/bitcoin_ur_PK.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 11,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ur_PK.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_ur_PK.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ur_PK.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "b8807afb13b8b73d216b55b7c59a2dda2343b0f5",
        "filename": "src/qt/locale/bitcoin_uz@Cyrl.ts",
        "status": "modified",
        "additions": 37,
        "deletions": 97,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_uz@Cyrl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_uz@Cyrl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_uz@Cyrl.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "38ebd77b71e7fc30a0c97b3f51dfeba0aad08340",
        "filename": "src/qt/locale/bitcoin_vi.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_vi.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_vi.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_vi.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "18d1a252e7e98b01b4f47a243adf98f191a756fe",
        "filename": "src/qt/locale/bitcoin_vi_VN.ts",
        "status": "modified",
        "additions": 625,
        "deletions": 5,
        "changes": 630,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_vi_VN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_vi_VN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_vi_VN.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "3bcce1faabcca643002f9204f7897aa7acef98ce",
        "filename": "src/qt/locale/bitcoin_zh_CN.ts",
        "status": "modified",
        "additions": 756,
        "deletions": 190,
        "changes": 946,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_zh_CN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_zh_CN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_CN.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "dfdbb7d1da0527d042e46004c1a4040237b7f22a",
        "filename": "src/qt/locale/bitcoin_zh_HK.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_zh_HK.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_zh_HK.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_HK.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "3792a7609591d8a7791234ce75b219362f904c1e",
        "filename": "src/qt/locale/bitcoin_zh_TW.ts",
        "status": "modified",
        "additions": 144,
        "deletions": 232,
        "changes": 376,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_zh_TW.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/locale/bitcoin_zh_TW.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_TW.ts?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "15a6583ca44c45c26acf66236b8cacbf285f1931",
        "filename": "src/qt/macdockiconhandler.h",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/macdockiconhandler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/macdockiconhandler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macdockiconhandler.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "58a0365d3dca8923b94203ab74912ea7e4544914",
        "filename": "src/qt/macdockiconhandler.mm",
        "status": "modified",
        "additions": 29,
        "deletions": 32,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/macdockiconhandler.mm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/macdockiconhandler.mm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macdockiconhandler.mm?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "efb2bf4158d9eefa96ac0843387c42b885456071",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "41d6acf3584fb2d09b801b85902db84dd889c69a",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "2e33b9adf8d8fae63a59f95c0b34c2d01c9a0587",
        "filename": "src/qt/overviewpage.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/overviewpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/overviewpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "7e9729eeb9c07862a7f0b2817cf3c31fae6aed74",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 22,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "99a7186b85903da5f6c4f625f25d975831942545",
        "filename": "src/qt/paymentrequestplus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/paymentrequestplus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/paymentrequestplus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.h?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      },
      {
        "sha": "09e9949b1035d4c7a21670599c9b00b9bb9a2581",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 36,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/423f91f73ce65daace5f612aa6d7b4ba6c18f667/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=423f91f73ce65daace5f612aa6d7b4ba6c18f667"
      }
    ]
  }
]