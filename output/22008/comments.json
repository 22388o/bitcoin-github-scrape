[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/845634461",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-845634461",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 845634461,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0NTYzNDQ2MQ==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-21T03:55:09Z",
    "updated_at": "2021-06-05T07:17:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #22155 (wallet test: Add test for subtract fee from recipient behavior by ryanofsky)\n* #22100 (refactor: Clean up new wallet spend, receive files added #21207 by ryanofsky)\n* #22009 (wallet: Decide which coin selection solution to use based on waste metric by achow101)\n* #21206 (refactor: Make CWalletTx sync state type-safe by ryanofsky)\n* #20205 (wallet: Properly support a wallet id by achow101)\n* #17526 (Use Single Random Draw In addition to knapsack as coin selection fallback by achow101)\n* #17211 (Allow fundrawtransaction and walletcreatefundedpsbt to take external inputs by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/845634461/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/847985686",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-847985686",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 847985686,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0Nzk4NTY4Ng==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-25T15:47:45Z",
    "updated_at": "2021-05-25T15:47:45Z",
    "author_association": "MEMBER",
    "body": "With #17331 now merged, this is ready for review.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/847985686/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/848012016",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-848012016",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 848012016,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0ODAxMjAxNg==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-25T16:13:18Z",
    "updated_at": "2021-05-25T16:13:18Z",
    "author_association": "MEMBER",
    "body": "re-utACK a2dd0dbc91da89a5672d2e578998252b1a3ceabc",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/848012016/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849007602",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-849007602",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 849007602,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0OTAwNzYwMg==",
    "user": {
      "login": "Xekyo",
      "id": 4060799,
      "node_id": "MDQ6VXNlcjQwNjA3OTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4060799?u=d924616c3b45bdda9c3b78d1697f1fe6a92b49c5&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Xekyo",
      "html_url": "https://github.com/Xekyo",
      "followers_url": "https://api.github.com/users/Xekyo/followers",
      "following_url": "https://api.github.com/users/Xekyo/following{/other_user}",
      "gists_url": "https://api.github.com/users/Xekyo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
      "organizations_url": "https://api.github.com/users/Xekyo/orgs",
      "repos_url": "https://api.github.com/users/Xekyo/repos",
      "events_url": "https://api.github.com/users/Xekyo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Xekyo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-26T18:10:33Z",
    "updated_at": "2021-05-26T18:10:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "tACK c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602\r\n\r\nThe rebase ate my most pressing comment. Thanks @instagibbs for https://github.com/bitcoin/bitcoin/pull/22042. :heart: ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849007602/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849017814",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-849017814",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 849017814,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0OTAxNzgxNA==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-26T18:26:32Z",
    "updated_at": "2021-05-26T18:28:09Z",
    "author_association": "MEMBER",
    "body": "The last rebase broke the fee estimation test on CI, though perhaps a coincidence; I can't reproduce:\r\n\r\n```\r\nself.run_test()\r\nFile \"/tmp/cirrus-build/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/test/functional/feature_fee_estimation.py\", line 256, in run_test\r\ncheck_estimates(self.nodes[1], self.fees_per_kb)\r\nFile \"/tmp/cirrus-build/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/test/functional/feature_fee_estimation.py\", line 140, in check_estimates\r\ncheck_smart_estimates(node, fees_seen)\r\nFile \"/tmp/cirrus-build/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/test/functional/feature_fee_estimation.py\", line 130, in check_smart_estimates\r\n% (feerate, last_feerate))\r\nAssertionError: Estimated fee (0.000565) larger than last fee (0.000479) for lower number of confirms\r\n```\r\n\r\nc2a5bd68ef60d9c64512b205ff6ea4ce7dca8602 looks like a correct rebase",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849017814/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849039623",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-849039623",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 849039623,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0OTAzOTYyMw==",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-05-26T18:59:50Z",
    "updated_at": "2021-05-26T18:59:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Code review ACK c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602. I like `inputs_sum` and `recipients_sum`",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849039623/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/854733594",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-854733594",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 854733594,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1NDczMzU5NA==",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-04T13:42:47Z",
    "updated_at": "2021-06-04T13:46:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "Maybe another cleanup for later, but the separate `fee_needed` and `nFeeRet` variables haven't been needed since the `CreateTransactionInternal` while loop was removed in 9d3bd74ab4430532d6e53eef8cf77ad999044b14. `fee_needed` was only introduced before that commit because if a change output was dropped in an early iteration of the loop, `fee_needed` would hold the cost of the transaction without the change output for the current loop iteration, while `nFeeRet` would reflect the cost of the transaction with change for future iterations. So `fee_needed` can be dropped now without changing behavior, which I think would clarify the code:\r\n\r\n```diff\r\ndiff --git a/src/wallet/spend.cpp b/src/wallet/spend.cpp\r\nindex c8ded4c51e2..45a02f59a18 100644\r\n--- a/src/wallet/spend.cpp\r\n+++ b/src/wallet/spend.cpp\r\n@@ -756,9 +756,8 @@ bool CWallet::CreateTransactionInternal(\r\n     nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\r\n \r\n     // Subtract fee from the change output if not subtracting it from recipient outputs\r\n-    CAmount fee_needed = nFeeRet;\r\n     if (!coin_selection_params.m_subtract_fee_outputs) {\r\n-        change_position->nValue -= fee_needed;\r\n+        change_position->nValue -= nFeeRet;\r\n     }\r\n \r\n     // We want to drop the change to fees if:\r\n@@ -774,17 +773,12 @@ bool CWallet::CreateTransactionInternal(\r\n         // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\r\n         tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\r\n         nBytes = tx_sizes.vsize;\r\n-        fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\r\n-    }\r\n-\r\n-    // Update nFeeRet in case fee_needed changed due to dropping the change output\r\n-    if (fee_needed <= change_and_fee - change_amount) {\r\n-        nFeeRet = change_and_fee - change_amount;\r\n+        nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\r\n     }\r\n \r\n     // Reduce output values for subtractFeeFromAmount\r\n     if (coin_selection_params.m_subtract_fee_outputs) {\r\n-        CAmount to_reduce = fee_needed + change_amount - change_and_fee;\r\n+        CAmount to_reduce = nFeeRet + change_amount - change_and_fee;\r\n         int i = 0;\r\n         bool fFirst = true;\r\n         for (const auto& recipient : vecSend)\r\n@@ -816,7 +810,15 @@ bool CWallet::CreateTransactionInternal(\r\n             }\r\n             ++i;\r\n         }\r\n-        nFeeRet = fee_needed;\r\n+    } else if (nFeeRet <= change_and_fee - change_amount) {\r\n+        // If dropping the change output covered the fee, update the returned\r\n+        // fee amount. Note that that in subtract-fee-from-recipients case\r\n+        // above, if the change output is dropped, the change dust value will\r\n+        // be paid to recipients, rather than to the miner (`to_reduce` above\r\n+        // will be negative). In that case, the dust amount sent is an\r\n+        // additional cost of the transaction, but it's not considered part of\r\n+        // the fee since it isn't paid to the miner, so nFeeRet doesn't change here.\r\n+        nFeeRet = change_and_fee - change_amount;\r\n     }\r\n \r\n     // Give up if change keypool ran out and change is required\r\n\r\n```\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/854733594/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/854880614",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-854880614",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 854880614,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1NDg4MDYxNA==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-04T17:07:49Z",
    "updated_at": "2021-06-04T17:07:49Z",
    "author_association": "MEMBER",
    "body": "@ryanofsky I agree that `fee_needed` can be dropped, but I don't think your diff is necessarily correct. Looking at it now, I don't think the current behavior is correct either (and your diff maintains this behavior). We shouldn't ever be paying more to the recipient than the sender expects. The excess, if it is dust, should be burned as fees. So your diff, and the current behavior, is incorrect in that if the dropped change output is more than fees, then recipients will receive more than requested by the sender.\r\n\r\nBy simply removing `fee_needed`, I think we can get the behavior that we want. In this case, after the change is dropped, we will update `nFeeRet` to be the dropped change amount. Then `to_reduce` ends up being 0 and the recipients don't pay any fees, but also don't get anything back, so the excess is paid as fees. I believe that this is the intended behavior, and is simpler to understand too.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/854880614/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/854912977",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-854912977",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 854912977,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1NDkxMjk3Nw==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-04T18:10:50Z",
    "updated_at": "2021-06-04T18:10:50Z",
    "author_association": "MEMBER",
    "body": "I've reverted back to 96c2c9520e80ee4fed92f0e1ab859d59fcbdb110\r\n\r\nI think we should discuss the intended behavior of subtract fee from recipients during the wallet meeting today.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/854912977/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/856026671",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-856026671",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 856026671,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1NjAyNjY3MQ==",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-07T15:20:17Z",
    "updated_at": "2021-06-07T15:20:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "re: https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-854733594\r\n\r\n> Maybe another cleanup for later, but the separate fee_needed and nFeeRet variables haven't been needed [...]\r\n\r\nfee_needed cleanup was discussed more in [IRC](https://www.erisian.com.au/bitcoin-core-dev/log-2021-06-04.html#l-221) and is addressed in #22155 for now adding by a unit test to exercise and check the relevant behavior, since there isn't other test coverage",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/856026671/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/856033716",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-856033716",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22008",
    "id": 856033716,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1NjAzMzcxNg==",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-07T15:25:20Z",
    "updated_at": "2021-06-07T15:25:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is probably close to ready to being merged\r\n\r\nUp to date ACKs\r\n\r\nglozow https://github.com/bitcoin/bitcoin/pull/22008#pullrequestreview-675439314\r\nryanofsky https://github.com/bitcoin/bitcoin/pull/22008#pullrequestreview-676223208\r\n\r\nPrevious ACKS\r\n\r\nSjors https://github.com/bitcoin/bitcoin/pull/22008#pullrequestreview-665540991\r\nSjors https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-848012016\r\nXekyo https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-849007602\r\nryanofsky https://github.com/bitcoin/bitcoin/pull/22008#issuecomment-849039623\r\nglozow https://github.com/bitcoin/bitcoin/pull/22008#pullrequestreview-671176599\r\nmeshcollider https://github.com/bitcoin/bitcoin/pull/22008#pullrequestreview-671810704",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/856033716/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/639880355",
    "pull_request_review_id": 669228402,
    "id": 639880355,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTg4MDM1NQ==",
    "diff_hunk": "@@ -2798,6 +2798,12 @@ bool CWallet::CreateTransactionInternal(\n {\n     LOCK(cs_wallet);\n \n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 8,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "d58f1fb0fdd43ed186073f9db477d9afd760c637",
    "user": {
      "login": "Xekyo",
      "id": 4060799,
      "node_id": "MDQ6VXNlcjQwNjA3OTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Xekyo",
      "html_url": "https://github.com/Xekyo",
      "followers_url": "https://api.github.com/users/Xekyo/followers",
      "following_url": "https://api.github.com/users/Xekyo/following{/other_user}",
      "gists_url": "https://api.github.com/users/Xekyo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
      "organizations_url": "https://api.github.com/users/Xekyo/orgs",
      "repos_url": "https://api.github.com/users/Xekyo/repos",
      "events_url": "https://api.github.com/users/Xekyo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Xekyo/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "commit d58f1fb0fdd43ed186073f9db477d9afd760c637 Move variable initializations to where they are used;\r\n\r\nNit: the commit message does not mention `m_avoid_partial_spends`, but `m_avoid_reuse`, was this a mix-up?",
    "created_at": "2021-05-26T16:09:22Z",
    "updated_at": "2021-05-26T17:56:35Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r639880355",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/639880355"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r639880355"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/639880355/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2804,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/640957988",
    "pull_request_review_id": 670629741,
    "id": 640957988,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDk1Nzk4OA==",
    "diff_hunk": "@@ -2798,6 +2798,12 @@ bool CWallet::CreateTransactionInternal(\n {\n     LOCK(cs_wallet);\n \n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 8,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "d58f1fb0fdd43ed186073f9db477d9afd760c637",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Oops, yes, that's a typo. Will fix if I have to push this again.",
    "created_at": "2021-05-27T20:52:28Z",
    "updated_at": "2021-05-27T20:52:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r640957988",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/640957988"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r640957988"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/640957988/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2804,
    "side": "RIGHT",
    "in_reply_to_id": 639880355
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641457718",
    "pull_request_review_id": 671176599,
    "id": 641457718,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTQ1NzcxOA==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 72,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In cb81bede9b Move cs_wallet lock in CreateTransactionInternal to top of function and Remove extraneous scope in CreateTransactionInternal\r\n\r\nSeems like curly braces were supposed to limit the scope of the lock (?) but I am unsure why it should be released in the middle of `CreateTransation()`. If the intention is to hold this lock for all of `CreateTransaction()` (I don't see why we'd want to release it in between calls to `CreateTransactionInternal()`), why not grab the lock in `CreateTransation()` and annotate that `CreateTransactionInternal()` requires `cs_wallet`?",
    "created_at": "2021-05-28T10:51:44Z",
    "updated_at": "2021-05-28T12:10:24Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641457718",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641457718"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641457718"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641457718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2798,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641492447",
    "pull_request_review_id": 671176599,
    "id": 641492447,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTQ5MjQ0Nw==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        if (recipients_sum < 0 || recipient.nAmount < 0) {\n             error = _(\"Transaction amounts must not be negative\");\n             return false;\n         }",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 93,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In 806c32f6ef Move empty recipients vector check to beginning in CreateTransaction\r\n\r\nI think this check for non-negative amounts should be moved to the beginning of `CreateTransaction()` as well, since it's a sanitization step similar to checking for empty vector. It doesn't need to be checked more than once (and doesn't need the lock).",
    "created_at": "2021-05-28T11:57:56Z",
    "updated_at": "2021-05-28T12:10:24Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641492447",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641492447"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641492447"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641492447/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 2811,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 2814,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641493935",
    "pull_request_review_id": 671176599,
    "id": 641493935,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTQ5MzkzNQ==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        if (recipients_sum < 0 || recipient.nAmount < 0) {\n             error = _(\"Transaction amounts must not be negative\");\n             return false;\n         }\n-        nValue += recipient.nAmount;\n+        recipients_sum += recipient.nAmount;\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n+        }\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n+    }\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n-    {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n+    {\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n+    //\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+    }\n+\n+    // Calculate the transaction fee\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    int nBytes = tx_sizes.vsize;\n+    if (nBytes < 0) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n+    nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n+    // Subtract fee from the change output if not subtrating it from recipient outputs",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 396,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In bc0035a417 Remove extraneous scope in CreateTransactionInternal\r\n\r\n```suggestion\r\n    // Subtract fee from the change output if not subtracting it from recipient outputs\r\n```",
    "created_at": "2021-05-28T12:00:35Z",
    "updated_at": "2021-05-28T12:13:50Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641493935",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641493935"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641493935"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641493935/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2979,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641497754",
    "pull_request_review_id": 671176599,
    "id": 641497754,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTQ5Nzc1NA==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        if (recipients_sum < 0 || recipient.nAmount < 0) {\n             error = _(\"Transaction amounts must not be negative\");\n             return false;\n         }",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 93,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It could also be\r\n\r\n```c++\r\nif (std::any_of(vecSend.cbegin(), vecSend.cend(), [](const auto& recipient){ return recipient.nAmount < 0; }))\r\n```",
    "created_at": "2021-05-28T12:07:35Z",
    "updated_at": "2021-05-28T12:10:24Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641497754",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641497754"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641497754"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641497754/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 2811,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 2814,
    "side": "RIGHT",
    "in_reply_to_id": 641492447
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703339",
    "pull_request_review_id": 671507724,
    "id": 641703339,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTcwMzMzOQ==",
    "diff_hunk": "@@ -2798,6 +2798,12 @@ bool CWallet::CreateTransactionInternal(\n {\n     LOCK(cs_wallet);\n \n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 8,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "d58f1fb0fdd43ed186073f9db477d9afd760c637",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed.",
    "created_at": "2021-05-28T17:22:27Z",
    "updated_at": "2021-05-28T17:22:27Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703339",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703339"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703339"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703339/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2804,
    "side": "RIGHT",
    "in_reply_to_id": 639880355
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703409",
    "pull_request_review_id": 671507826,
    "id": 641703409,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTcwMzQwOQ==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 72,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2021-05-28T17:22:34Z",
    "updated_at": "2021-05-28T17:22:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703409",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703409"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703409"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703409/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2798,
    "side": "RIGHT",
    "in_reply_to_id": 641457718
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703449",
    "pull_request_review_id": 671507872,
    "id": 641703449,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTcwMzQ0OQ==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        if (recipients_sum < 0 || recipient.nAmount < 0) {\n             error = _(\"Transaction amounts must not be negative\");\n             return false;\n         }",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 93,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2021-05-28T17:22:39Z",
    "updated_at": "2021-05-28T17:22:39Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703449",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703449"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703449"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703449/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 2811,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 2814,
    "side": "RIGHT",
    "in_reply_to_id": 641492447
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703512",
    "pull_request_review_id": 671507973,
    "id": 641703512,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTcwMzUxMg==",
    "diff_hunk": "@@ -2795,287 +2795,270 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    LOCK(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        if (recipients_sum < 0 || recipient.nAmount < 0) {\n             error = _(\"Transaction amounts must not be negative\");\n             return false;\n         }\n-        nValue += recipient.nAmount;\n+        recipients_sum += recipient.nAmount;\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n+        }\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n+    }\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n-    {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n+    {\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n+    //\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+    }\n+\n+    // Calculate the transaction fee\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    int nBytes = tx_sizes.vsize;\n+    if (nBytes < 0) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n+    nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n+    // Subtract fee from the change output if not subtrating it from recipient outputs",
    "path": "src/wallet/wallet.cpp",
    "position": null,
    "original_position": 396,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "c2a5bd68ef60d9c64512b205ff6ea4ce7dca8602",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2021-05-28T17:22:46Z",
    "updated_at": "2021-05-28T17:22:46Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703512",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703512"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r641703512"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/641703512/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2979,
    "side": "RIGHT",
    "in_reply_to_id": 641493935
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/644911809",
    "pull_request_review_id": 675439314,
    "id": 644911809,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NDkxMTgwOQ==",
    "diff_hunk": "@@ -578,287 +578,266 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    AssertLockHeld(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        recipients_sum += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n         }\n-        nValue += recipient.nAmount;\n+    }\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n+\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n     {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());",
    "path": "src/wallet/spend.cpp",
    "position": 338,
    "original_position": 338,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In b583f73354 Move vin filling to before final fee setting (but not super relevant to this PR)\r\n\r\nQuestion: is there a reason `setCoins` (and `setCoinsRet`, etc. in the coin selection solvers) needs to be a `std::set` instead of a `std::vector`? It doesn't seem like we get much benefit out of using a set, and we convert to vector here anyway?",
    "created_at": "2021-06-03T15:48:09Z",
    "updated_at": "2021-06-04T11:04:41Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r644911809",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/644911809"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r644911809"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/644911809/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 733,
    "original_line": 733,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645476752",
    "pull_request_review_id": 675439314,
    "id": 645476752,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NTQ3Njc1Mg==",
    "diff_hunk": "@@ -578,287 +578,266 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    AssertLockHeld(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        recipients_sum += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n         }\n-        nValue += recipient.nAmount;\n+    }\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n+\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n     {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n-\n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n+    //\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+    }\n \n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n+    // Calculate the transaction fee\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    int nBytes = tx_sizes.vsize;\n+    if (nBytes < 0) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n+    nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+    // Subtract fee from the change output if not subtracting it from recipient outputs\n+    CAmount fee_needed = nFeeRet;\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        change_position->nValue -= fee_needed;\n+    }\n \n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n+    // We want to drop the change to fees if:\n+    // 1. The change output would be dust\n+    // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+    CAmount change_amount = change_position->nValue;\n+    if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+    {\n+        nChangePosInOut = -1;\n+        change_amount = 0;\n+        txNew.vout.erase(change_position);\n+\n+        // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+        nBytes = tx_sizes.vsize;\n+        fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    }\n \n-            // Calculate the transaction fee\n-            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-            nBytes = tx_sizes.vsize;\n-            if (nBytes < 0) {\n-                error = _(\"Signing transaction failed\");\n-                return false;\n-            }\n-            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    // Update nFeeRet in case fee_needed changed due to dropping the change output\n+    if (fee_needed <= change_and_fee - change_amount) {\n+        nFeeRet = change_and_fee - change_amount;\n+    }\n \n-            // Subtract fee from the change output if not subtrating it from recipient outputs\n-            CAmount fee_needed = nFeeRet;\n-            if (nSubtractFeeFromAmount == 0) {\n-                change_position->nValue -= fee_needed;\n+    // Reduce output values for subtractFeeFromAmount\n+    if (coin_selection_params.m_subtract_fee_outputs) {\n+        CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+        int i = 0;\n+        bool fFirst = true;\n+        for (const auto& recipient : vecSend)\n+        {\n+            if (i == nChangePosInOut) {\n+                ++i;\n             }\n+            CTxOut& txout = txNew.vout[i];\n \n-            // We want to drop the change to fees if:\n-            // 1. The change output would be dust\n-            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-            CAmount change_amount = change_position->nValue;\n-            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+            if (recipient.fSubtractFeeFromAmount)\n             {\n-                nChangePosInOut = -1;\n-                change_amount = 0;\n-                txNew.vout.erase(change_position);\n-\n-                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                nBytes = tx_sizes.vsize;\n-                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-            }\n+                txout.nValue -= to_reduce / outputs_to_subtract_fee_from; // Subtract fee equally from each selected recipient\n \n-            // Update nFeeRet in case fee_needed changed due to dropping the change output\n-            if (fee_needed <= change_and_fee - change_amount) {\n-                nFeeRet = change_and_fee - change_amount;\n-            }\n-\n-            // Reduce output values for subtractFeeFromAmount\n-            if (nSubtractFeeFromAmount != 0) {\n-                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-                int i = 0;\n-                bool fFirst = true;\n-                for (const auto& recipient : vecSend)\n+                if (fFirst) // first receiver pays the remainder not divisible by output count\n                 {\n-                    if (i == nChangePosInOut) {\n-                        ++i;\n-                    }\n-                    CTxOut& txout = txNew.vout[i];\n-\n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                        }\n-\n-                        // Error if this output is reduced to be below dust\n-                        if (IsDust(txout, chain().relayDustFee())) {\n-                            if (txout.nValue < 0) {\n-                                error = _(\"The transaction amount is too small to pay the fee\");\n-                            } else {\n-                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                            }\n-                            return false;\n-                        }\n-                    }\n-                    ++i;\n+                    fFirst = false;\n+                    txout.nValue -= to_reduce % outputs_to_subtract_fee_from;\n                 }\n-                nFeeRet = fee_needed;\n-            }\n \n-            // Give up if change keypool ran out and change is required\n-            if (scriptChange.empty() && nChangePosInOut != -1) {\n-                return false;\n+                // Error if this output is reduced to be below dust\n+                if (IsDust(txout, chain().relayDustFee())) {\n+                    if (txout.nValue < 0) {\n+                        error = _(\"The transaction amount is too small to pay the fee\");\n+                    } else {\n+                        error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                    }\n+                    return false;\n+                }\n             }\n+            ++i;\n         }\n+        nFeeRet = fee_needed;\n+    }\n \n-        // Shuffle selected coins and fill in final vin\n-        txNew.vin.clear();\n-        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n-\n-        // Note how the sequence number is set to non-maxint so that\n-        // the nLockTime set above actually works.\n-        //\n-        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-        // we use the highest possible value in that range (maxint-2)\n-        // to avoid conflicting with other possible uses of nSequence,\n-        // and in the spirit of \"smallest possible change from prior\n-        // behavior.\"\n-        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-        for (const auto& coin : selected_coins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-        }\n+    // Give up if change keypool ran out and change is required\n+    if (scriptChange.empty() && nChangePosInOut != -1) {\n+        return false;\n+    }",
    "path": "src/wallet/spend.cpp",
    "position": 546,
    "original_position": 546,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Question: just wondering, why doesn't this have an error message?",
    "created_at": "2021-06-04T10:47:35Z",
    "updated_at": "2021-06-04T11:04:41Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645476752",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645476752"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645476752"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645476752/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 823,
    "original_start_line": 823,
    "start_side": "RIGHT",
    "line": 825,
    "original_line": 825,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645711411",
    "pull_request_review_id": 676483409,
    "id": 645711411,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NTcxMTQxMQ==",
    "diff_hunk": "@@ -578,287 +578,266 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    AssertLockHeld(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        recipients_sum += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n         }\n-        nValue += recipient.nAmount;\n+    }\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n+\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n     {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());",
    "path": "src/wallet/spend.cpp",
    "position": 338,
    "original_position": 338,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "No reason other than it's always been that way. `setCoinsRet` can be traced back to 0.1.0.",
    "created_at": "2021-06-04T16:42:04Z",
    "updated_at": "2021-06-04T16:42:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645711411",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645711411"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645711411"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645711411/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 733,
    "original_line": 733,
    "side": "RIGHT",
    "in_reply_to_id": 644911809
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645727221",
    "pull_request_review_id": 676504055,
    "id": 645727221,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NTcyNzIyMQ==",
    "diff_hunk": "@@ -578,287 +578,266 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    AssertLockHeld(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        recipients_sum += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n         }\n-        nValue += recipient.nAmount;\n+    }\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n+\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n     {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n-\n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n+    //\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+    }\n \n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n+    // Calculate the transaction fee\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    int nBytes = tx_sizes.vsize;\n+    if (nBytes < 0) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n+    nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+    // Subtract fee from the change output if not subtracting it from recipient outputs\n+    CAmount fee_needed = nFeeRet;\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        change_position->nValue -= fee_needed;\n+    }\n \n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n+    // We want to drop the change to fees if:\n+    // 1. The change output would be dust\n+    // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+    CAmount change_amount = change_position->nValue;\n+    if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+    {\n+        nChangePosInOut = -1;\n+        change_amount = 0;\n+        txNew.vout.erase(change_position);\n+\n+        // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+        nBytes = tx_sizes.vsize;\n+        fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    }\n \n-            // Calculate the transaction fee\n-            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-            nBytes = tx_sizes.vsize;\n-            if (nBytes < 0) {\n-                error = _(\"Signing transaction failed\");\n-                return false;\n-            }\n-            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    // Update nFeeRet in case fee_needed changed due to dropping the change output\n+    if (fee_needed <= change_and_fee - change_amount) {\n+        nFeeRet = change_and_fee - change_amount;\n+    }\n \n-            // Subtract fee from the change output if not subtrating it from recipient outputs\n-            CAmount fee_needed = nFeeRet;\n-            if (nSubtractFeeFromAmount == 0) {\n-                change_position->nValue -= fee_needed;\n+    // Reduce output values for subtractFeeFromAmount\n+    if (coin_selection_params.m_subtract_fee_outputs) {\n+        CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+        int i = 0;\n+        bool fFirst = true;\n+        for (const auto& recipient : vecSend)\n+        {\n+            if (i == nChangePosInOut) {\n+                ++i;\n             }\n+            CTxOut& txout = txNew.vout[i];\n \n-            // We want to drop the change to fees if:\n-            // 1. The change output would be dust\n-            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-            CAmount change_amount = change_position->nValue;\n-            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+            if (recipient.fSubtractFeeFromAmount)\n             {\n-                nChangePosInOut = -1;\n-                change_amount = 0;\n-                txNew.vout.erase(change_position);\n-\n-                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                nBytes = tx_sizes.vsize;\n-                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-            }\n+                txout.nValue -= to_reduce / outputs_to_subtract_fee_from; // Subtract fee equally from each selected recipient\n \n-            // Update nFeeRet in case fee_needed changed due to dropping the change output\n-            if (fee_needed <= change_and_fee - change_amount) {\n-                nFeeRet = change_and_fee - change_amount;\n-            }\n-\n-            // Reduce output values for subtractFeeFromAmount\n-            if (nSubtractFeeFromAmount != 0) {\n-                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-                int i = 0;\n-                bool fFirst = true;\n-                for (const auto& recipient : vecSend)\n+                if (fFirst) // first receiver pays the remainder not divisible by output count\n                 {\n-                    if (i == nChangePosInOut) {\n-                        ++i;\n-                    }\n-                    CTxOut& txout = txNew.vout[i];\n-\n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                        }\n-\n-                        // Error if this output is reduced to be below dust\n-                        if (IsDust(txout, chain().relayDustFee())) {\n-                            if (txout.nValue < 0) {\n-                                error = _(\"The transaction amount is too small to pay the fee\");\n-                            } else {\n-                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                            }\n-                            return false;\n-                        }\n-                    }\n-                    ++i;\n+                    fFirst = false;\n+                    txout.nValue -= to_reduce % outputs_to_subtract_fee_from;\n                 }\n-                nFeeRet = fee_needed;\n-            }\n \n-            // Give up if change keypool ran out and change is required\n-            if (scriptChange.empty() && nChangePosInOut != -1) {\n-                return false;\n+                // Error if this output is reduced to be below dust\n+                if (IsDust(txout, chain().relayDustFee())) {\n+                    if (txout.nValue < 0) {\n+                        error = _(\"The transaction amount is too small to pay the fee\");\n+                    } else {\n+                        error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                    }\n+                    return false;\n+                }\n             }\n+            ++i;\n         }\n+        nFeeRet = fee_needed;\n+    }\n \n-        // Shuffle selected coins and fill in final vin\n-        txNew.vin.clear();\n-        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n-\n-        // Note how the sequence number is set to non-maxint so that\n-        // the nLockTime set above actually works.\n-        //\n-        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-        // we use the highest possible value in that range (maxint-2)\n-        // to avoid conflicting with other possible uses of nSequence,\n-        // and in the spirit of \"smallest possible change from prior\n-        // behavior.\"\n-        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-        for (const auto& coin : selected_coins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-        }\n+    // Give up if change keypool ran out and change is required\n+    if (scriptChange.empty() && nChangePosInOut != -1) {\n+        return false;\n+    }",
    "path": "src/wallet/spend.cpp",
    "position": 546,
    "original_position": 546,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I guess the original author forgot to add one. I've added an error message in a separate commit.",
    "created_at": "2021-06-04T17:08:21Z",
    "updated_at": "2021-06-04T17:08:21Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645727221",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645727221"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645727221"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645727221/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 823,
    "original_start_line": 823,
    "start_side": "RIGHT",
    "line": 825,
    "original_line": 825,
    "side": "RIGHT",
    "in_reply_to_id": 645476752
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645733373",
    "pull_request_review_id": 676512123,
    "id": 645733373,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NTczMzM3Mw==",
    "diff_hunk": "@@ -578,287 +578,266 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n-    CAmount nValue = 0;\n+    AssertLockHeld(cs_wallet);\n+\n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n-    for (const auto& recipient : vecSend)\n-    {\n-        if (nValue < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n+    for (const auto& recipient : vecSend) {\n+        recipients_sum += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount) {\n+            outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n         }\n-        nValue += recipient.nAmount;\n+    }\n \n-        if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n     }\n \n-    CMutableTransaction txNew;\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+\n+    // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n+\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n     {\n-        std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+        // Include the fee cost for outputs.\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n+        }\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+        if (IsDust(txout, chain().relayDustFee()))\n+        {\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    std::set<CInputCoin> setCoins;\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-            // vouts to the payees\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n-            }\n-            for (const auto& recipient : vecSend)\n-            {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n-\n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n+    //\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+    }\n \n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n+    // Calculate the transaction fee\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    int nBytes = tx_sizes.vsize;\n+    if (nBytes < 0) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n+    nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+    // Subtract fee from the change output if not subtracting it from recipient outputs\n+    CAmount fee_needed = nFeeRet;\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        change_position->nValue -= fee_needed;\n+    }\n \n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n+    // We want to drop the change to fees if:\n+    // 1. The change output would be dust\n+    // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+    CAmount change_amount = change_position->nValue;\n+    if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+    {\n+        nChangePosInOut = -1;\n+        change_amount = 0;\n+        txNew.vout.erase(change_position);\n+\n+        // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+        nBytes = tx_sizes.vsize;\n+        fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    }\n \n-            // Calculate the transaction fee\n-            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-            nBytes = tx_sizes.vsize;\n-            if (nBytes < 0) {\n-                error = _(\"Signing transaction failed\");\n-                return false;\n-            }\n-            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    // Update nFeeRet in case fee_needed changed due to dropping the change output\n+    if (fee_needed <= change_and_fee - change_amount) {\n+        nFeeRet = change_and_fee - change_amount;\n+    }\n \n-            // Subtract fee from the change output if not subtrating it from recipient outputs\n-            CAmount fee_needed = nFeeRet;\n-            if (nSubtractFeeFromAmount == 0) {\n-                change_position->nValue -= fee_needed;\n+    // Reduce output values for subtractFeeFromAmount\n+    if (coin_selection_params.m_subtract_fee_outputs) {\n+        CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+        int i = 0;\n+        bool fFirst = true;\n+        for (const auto& recipient : vecSend)\n+        {\n+            if (i == nChangePosInOut) {\n+                ++i;\n             }\n+            CTxOut& txout = txNew.vout[i];\n \n-            // We want to drop the change to fees if:\n-            // 1. The change output would be dust\n-            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-            CAmount change_amount = change_position->nValue;\n-            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+            if (recipient.fSubtractFeeFromAmount)\n             {\n-                nChangePosInOut = -1;\n-                change_amount = 0;\n-                txNew.vout.erase(change_position);\n-\n-                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                nBytes = tx_sizes.vsize;\n-                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-            }\n+                txout.nValue -= to_reduce / outputs_to_subtract_fee_from; // Subtract fee equally from each selected recipient\n \n-            // Update nFeeRet in case fee_needed changed due to dropping the change output\n-            if (fee_needed <= change_and_fee - change_amount) {\n-                nFeeRet = change_and_fee - change_amount;\n-            }\n-\n-            // Reduce output values for subtractFeeFromAmount\n-            if (nSubtractFeeFromAmount != 0) {\n-                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-                int i = 0;\n-                bool fFirst = true;\n-                for (const auto& recipient : vecSend)\n+                if (fFirst) // first receiver pays the remainder not divisible by output count\n                 {\n-                    if (i == nChangePosInOut) {\n-                        ++i;\n-                    }\n-                    CTxOut& txout = txNew.vout[i];\n-\n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                        }\n-\n-                        // Error if this output is reduced to be below dust\n-                        if (IsDust(txout, chain().relayDustFee())) {\n-                            if (txout.nValue < 0) {\n-                                error = _(\"The transaction amount is too small to pay the fee\");\n-                            } else {\n-                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                            }\n-                            return false;\n-                        }\n-                    }\n-                    ++i;\n+                    fFirst = false;\n+                    txout.nValue -= to_reduce % outputs_to_subtract_fee_from;\n                 }\n-                nFeeRet = fee_needed;\n-            }\n \n-            // Give up if change keypool ran out and change is required\n-            if (scriptChange.empty() && nChangePosInOut != -1) {\n-                return false;\n+                // Error if this output is reduced to be below dust\n+                if (IsDust(txout, chain().relayDustFee())) {\n+                    if (txout.nValue < 0) {\n+                        error = _(\"The transaction amount is too small to pay the fee\");\n+                    } else {\n+                        error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                    }\n+                    return false;\n+                }\n             }\n+            ++i;\n         }\n+        nFeeRet = fee_needed;\n+    }\n \n-        // Shuffle selected coins and fill in final vin\n-        txNew.vin.clear();\n-        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n-\n-        // Note how the sequence number is set to non-maxint so that\n-        // the nLockTime set above actually works.\n-        //\n-        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-        // we use the highest possible value in that range (maxint-2)\n-        // to avoid conflicting with other possible uses of nSequence,\n-        // and in the spirit of \"smallest possible change from prior\n-        // behavior.\"\n-        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-        for (const auto& coin : selected_coins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-        }\n+    // Give up if change keypool ran out and change is required\n+    if (scriptChange.empty() && nChangePosInOut != -1) {\n+        return false;\n+    }",
    "path": "src/wallet/spend.cpp",
    "position": 546,
    "original_position": 546,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Oh, actually it does have an error message. It's set earlier in the function when a change address is fetched. When one is not available, the error message is set. If there is a different failure before we get to this particular condition, then that failure takes precedence and the error message is changed. But if we reach this failure condition, then the error message will have been set previously and does not need to be set here. So I dropped the commit I added.",
    "created_at": "2021-06-04T17:19:12Z",
    "updated_at": "2021-06-04T17:19:12Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645733373",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645733373"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645733373"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645733373/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 823,
    "original_start_line": 823,
    "start_side": "RIGHT",
    "line": 825,
    "original_line": 825,
    "side": "RIGHT",
    "in_reply_to_id": 645476752
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645746200",
    "pull_request_review_id": 676528963,
    "id": 645746200,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NTc0NjIwMA==",
    "diff_hunk": "@@ -774,17 +773,17 @@ bool CWallet::CreateTransactionInternal(\n         // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n         tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n         nBytes = tx_sizes.vsize;\n-        fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+        nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n     }\n \n-    // Update nFeeRet in case fee_needed changed due to dropping the change output\n-    if (fee_needed <= change_and_fee - change_amount) {\n+    // Update nFeeRet in case it changed due to dropping the change output",
    "path": "src/wallet/spend.cpp",
    "position": null,
    "original_position": 21,
    "commit_id": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "original_commit_id": "303a6645dc604e1d074a1aa6253f4dc8a1c3109e",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Remove unneeded fee_needed variable\" (303a6645dc604e1d074a1aa6253f4dc8a1c3109e)\r\n\r\nI think this comment is a big vague and maybe even misleading because this code isn't just updating the return value but also increasing the fee paid in the subtract-from-outputs case. I would maybe say something like \"// Increase nFeeRet to reflect extra fee paid by giving up the small change amount which is smaller than the cost of the change output.\"\r\n\r\n\r\n",
    "created_at": "2021-06-04T17:42:07Z",
    "updated_at": "2021-06-04T18:05:03Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645746200",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645746200"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22008#discussion_r645746200"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22008"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/645746200/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 779,
    "side": "RIGHT"
  }
]