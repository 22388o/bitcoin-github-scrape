[
  {
    "sha": "b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjk5NTk2M2I1ZDBiOWJjYTUwM2IwY2M2OWM3NDdmNGNlZGVjMWU0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-20T18:51:50Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T17:59:32Z"
      },
      "message": "Move cs_wallet lock in CreateTransactionInternal to top of function\n\nIt isn't necessary to not lock parts of this function. Just lock the\nwhole thing and get rid of an indent.",
      "tree": {
        "sha": "1f807a9f28cdc3fe58765ccd3b9f2a4b887b1f34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f807a9f28cdc3fe58765ccd3b9f2a4b887b1f34"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2995963b5d0b9bca503b0cc69c747f4cedec1e4/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "55a156fca08713b020aafef91f40df8ce4bc3cae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/55a156fca08713b020aafef91f40df8ce4bc3cae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/55a156fca08713b020aafef91f40df8ce4bc3cae"
      }
    ],
    "stats": {
      "total": 371,
      "additions": 186,
      "deletions": 185
    },
    "files": [
      {
        "sha": "00edc94403730f928e01d92019a7bb39d85100c1",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 185,
        "deletions": 184,
        "changes": 369,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2995963b5d0b9bca503b0cc69c747f4cedec1e4/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2995963b5d0b9bca503b0cc69c747f4cedec1e4/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
        "patch": "@@ -578,6 +578,8 @@ bool CWallet::CreateTransactionInternal(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n+    AssertLockHeld(cs_wallet);\n+\n     CAmount nValue = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n@@ -606,224 +608,221 @@ bool CWallet::CreateTransactionInternal(\n     int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n-        LOCK(cs_wallet);\n         txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        {\n-            std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-            coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-            // Create change script that will be used if we need change\n-            // TODO: pass in scriptChange instead of reservedest so\n-            // change transaction isn't always pay-to-bitcoin-address\n-            CScript scriptChange;\n-\n-            // coin control: send change to custom address\n-            if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-                scriptChange = GetScriptForDestination(coin_control.destChange);\n-            } else { // no coin control: send change to newly generated address\n-                // Note: We use a new key here to keep it from being obvious which side is the change.\n-                //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                //  backup is restored, if the backup doesn't have the new private key for the change.\n-                //  If we reused the old key, it would be possible to add code to look for and\n-                //  rediscover unknown transactions that were written with keys of ours to recover\n-                //  post-backup change.\n-\n-                // Reserve a new key pair from key pool. If it fails, provide a dummy\n-                // destination in case we don't need change.\n-                CTxDestination dest;\n-                if (!reservedest.GetReservedDestination(dest, true)) {\n-                    error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-                }\n-                scriptChange = GetScriptForDestination(dest);\n-                // A valid destination implies a change script (and\n-                // vice-versa). An empty change script will abort later, if the\n-                // change keypool ran out, but change is required.\n-                CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-            }\n-            CTxOut change_prototype_txout(0, scriptChange);\n-            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-            // Get size of spending the change output\n-            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-            // as lower-bound to allow BnB to do it's thing\n-            if (change_spend_size == -1) {\n-                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-            } else {\n-                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-            }\n+        std::vector<COutput> vAvailableCoins;\n+        AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+        CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+        coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+        // Create change script that will be used if we need change\n+        // TODO: pass in scriptChange instead of reservedest so\n+        // change transaction isn't always pay-to-bitcoin-address\n+        CScript scriptChange;\n+\n+        // coin control: send change to custom address\n+        if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+            scriptChange = GetScriptForDestination(coin_control.destChange);\n+        } else { // no coin control: send change to newly generated address\n+            // Note: We use a new key here to keep it from being obvious which side is the change.\n+            //  The drawback is that by not reusing a previous key, the change may be lost if a\n+            //  backup is restored, if the backup doesn't have the new private key for the change.\n+            //  If we reused the old key, it would be possible to add code to look for and\n+            //  rediscover unknown transactions that were written with keys of ours to recover\n+            //  post-backup change.\n+\n+            // Reserve a new key pair from key pool. If it fails, provide a dummy\n+            // destination in case we don't need change.\n+            CTxDestination dest;\n+            if (!reservedest.GetReservedDestination(dest, true)) {\n+                error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+            }\n+            scriptChange = GetScriptForDestination(dest);\n+            // A valid destination implies a change script (and\n+            // vice-versa). An empty change script will abort later, if the\n+            // change keypool ran out, but change is required.\n+            CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n+        }\n+        CTxOut change_prototype_txout(0, scriptChange);\n+        coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+        // Get size of spending the change output\n+        int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+        // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+        // as lower-bound to allow BnB to do it's thing\n+        if (change_spend_size == -1) {\n+            coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+        } else {\n+            coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+        }\n \n-            // Set discard feerate\n-            coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+        // Set discard feerate\n+        coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n \n-            // Get the fee rate to use effective values in coin selection\n-            coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-            // provided one\n-            if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-                error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-                return false;\n-            }\n-            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                // eventually allow a fallback fee\n-                error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-                return false;\n-            }\n+        // Get the fee rate to use effective values in coin selection\n+        coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+        // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+        // provided one\n+        if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+            error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+            return false;\n+        }\n+        if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+            // eventually allow a fallback fee\n+            error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            return false;\n+        }\n \n-            // Get long term estimate\n-            CCoinControl cc_temp;\n-            cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-            coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+        // Get long term estimate\n+        CCoinControl cc_temp;\n+        cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+        coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n \n-            // Calculate the cost of change\n-            // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-            // For creating the change output now, we use the effective feerate.\n-            // For spending the change output in the future, we use the discard feerate for now.\n-            // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-            coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-            coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+        // Calculate the cost of change\n+        // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+        // For creating the change output now, we use the effective feerate.\n+        // For spending the change output in the future, we use the discard feerate for now.\n+        // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+        coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+        coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-            coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+        coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n \n-            // vouts to the payees\n+        // vouts to the payees\n+        if (!coin_selection_params.m_subtract_fee_outputs) {\n+            coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+        }\n+        for (const auto& recipient : vecSend)\n+        {\n+            CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+\n+            // Include the fee cost for outputs.\n             if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+                coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n             }\n-            for (const auto& recipient : vecSend)\n+\n+            if (IsDust(txout, chain().relayDustFee()))\n             {\n-                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+                error = _(\"Transaction amount too small\");\n+                return false;\n+            }\n+            txNew.vout.push_back(txout);\n+        }\n \n-                // Include the fee cost for outputs.\n-                if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                }\n+        // Include the fees for things that aren't inputs, excluding the change output\n+        const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+        CAmount nValueToSelect = nValue + not_input_fees;\n \n-                if (IsDust(txout, chain().relayDustFee()))\n-                {\n-                    error = _(\"Transaction amount too small\");\n-                    return false;\n-                }\n-                txNew.vout.push_back(txout);\n-            }\n+        // Choose coins to use\n+        CAmount inputs_sum = 0;\n+        setCoins.clear();\n+        if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n+        {\n+            error = _(\"Insufficient funds\");\n+            return false;\n+        }\n \n-            // Include the fees for things that aren't inputs, excluding the change output\n-            const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-            CAmount nValueToSelect = nValue + not_input_fees;\n+        // Always make a change output\n+        // We will reduce the fee from this change output later, and remove the output if it is too small.\n+        const CAmount change_and_fee = inputs_sum - nValue;\n+        assert(change_and_fee >= 0);\n+        CTxOut newTxOut(change_and_fee, scriptChange);\n \n-            // Choose coins to use\n-            CAmount inputs_sum = 0;\n-            setCoins.clear();\n-            if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-            {\n-                error = _(\"Insufficient funds\");\n-                return false;\n-            }\n+        if (nChangePosInOut == -1)\n+        {\n+            // Insert change txn at random position:\n+            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+        }\n+        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+        {\n+            error = _(\"Change index out of range\");\n+            return false;\n+        }\n \n-            // Always make a change output\n-            // We will reduce the fee from this change output later, and remove the output if it is too small.\n-            const CAmount change_and_fee = inputs_sum - nValue;\n-            assert(change_and_fee >= 0);\n-            CTxOut newTxOut(change_and_fee, scriptChange);\n+        assert(nChangePosInOut != -1);\n+        auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-            if (nChangePosInOut == -1)\n-            {\n-                // Insert change txn at random position:\n-                nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-            }\n-            else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-            {\n-                error = _(\"Change index out of range\");\n-                return false;\n-            }\n+        // Dummy fill vin for maximum size estimation\n+        //\n+        for (const auto& coin : setCoins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+        }\n \n-            assert(nChangePosInOut != -1);\n-            auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+        // Calculate the transaction fee\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+        nBytes = tx_sizes.vsize;\n+        if (nBytes < 0) {\n+            error = _(\"Signing transaction failed\");\n+            return false;\n+        }\n+        nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-            // Dummy fill vin for maximum size estimation\n-            //\n-            for (const auto& coin : setCoins) {\n-                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-            }\n+        // Subtract fee from the change output if not subtrating it from recipient outputs\n+        CAmount fee_needed = nFeeRet;\n+        if (nSubtractFeeFromAmount == 0) {\n+            change_position->nValue -= fee_needed;\n+        }\n \n-            // Calculate the transaction fee\n+        // We want to drop the change to fees if:\n+        // 1. The change output would be dust\n+        // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+        CAmount change_amount = change_position->nValue;\n+        if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+        {\n+            nChangePosInOut = -1;\n+            change_amount = 0;\n+            txNew.vout.erase(change_position);\n+\n+            // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n             tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n             nBytes = tx_sizes.vsize;\n-            if (nBytes < 0) {\n-                error = _(\"Signing transaction failed\");\n-                return false;\n-            }\n-            nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+            fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+        }\n \n-            // Subtract fee from the change output if not subtrating it from recipient outputs\n-            CAmount fee_needed = nFeeRet;\n-            if (nSubtractFeeFromAmount == 0) {\n-                change_position->nValue -= fee_needed;\n-            }\n+        // Update nFeeRet in case fee_needed changed due to dropping the change output\n+        if (fee_needed <= change_and_fee - change_amount) {\n+            nFeeRet = change_and_fee - change_amount;\n+        }\n \n-            // We want to drop the change to fees if:\n-            // 1. The change output would be dust\n-            // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-            CAmount change_amount = change_position->nValue;\n-            if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+        // Reduce output values for subtractFeeFromAmount\n+        if (nSubtractFeeFromAmount != 0) {\n+            CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+            int i = 0;\n+            bool fFirst = true;\n+            for (const auto& recipient : vecSend)\n             {\n-                nChangePosInOut = -1;\n-                change_amount = 0;\n-                txNew.vout.erase(change_position);\n-\n-                // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-                tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                nBytes = tx_sizes.vsize;\n-                fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-            }\n-\n-            // Update nFeeRet in case fee_needed changed due to dropping the change output\n-            if (fee_needed <= change_and_fee - change_amount) {\n-                nFeeRet = change_and_fee - change_amount;\n-            }\n+                if (i == nChangePosInOut) {\n+                    ++i;\n+                }\n+                CTxOut& txout = txNew.vout[i];\n \n-            // Reduce output values for subtractFeeFromAmount\n-            if (nSubtractFeeFromAmount != 0) {\n-                CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-                int i = 0;\n-                bool fFirst = true;\n-                for (const auto& recipient : vecSend)\n+                if (recipient.fSubtractFeeFromAmount)\n                 {\n-                    if (i == nChangePosInOut) {\n-                        ++i;\n-                    }\n-                    CTxOut& txout = txNew.vout[i];\n+                    txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n \n-                    if (recipient.fSubtractFeeFromAmount)\n+                    if (fFirst) // first receiver pays the remainder not divisible by output count\n                     {\n-                        txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                        }\n+                        fFirst = false;\n+                        txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n+                    }\n \n-                        // Error if this output is reduced to be below dust\n-                        if (IsDust(txout, chain().relayDustFee())) {\n-                            if (txout.nValue < 0) {\n-                                error = _(\"The transaction amount is too small to pay the fee\");\n-                            } else {\n-                                error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                            }\n-                            return false;\n+                    // Error if this output is reduced to be below dust\n+                    if (IsDust(txout, chain().relayDustFee())) {\n+                        if (txout.nValue < 0) {\n+                            error = _(\"The transaction amount is too small to pay the fee\");\n+                        } else {\n+                            error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                         }\n+                        return false;\n                     }\n-                    ++i;\n                 }\n-                nFeeRet = fee_needed;\n+                ++i;\n             }\n+            nFeeRet = fee_needed;\n+        }\n \n-            // Give up if change keypool ran out and change is required\n-            if (scriptChange.empty() && nChangePosInOut != -1) {\n-                return false;\n-            }\n+        // Give up if change keypool ran out and change is required\n+        if (scriptChange.empty() && nChangePosInOut != -1) {\n+            return false;\n         }\n \n         // Shuffle selected coins and fill in final vin\n@@ -900,6 +899,8 @@ bool CWallet::CreateTransaction(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n+    LOCK(cs_wallet);\n+\n     int nChangePosIn = nChangePosInOut;\n     Assert(!tx); // tx is an out-param. TODO change the return type from bool to tx (or nullptr)\n     bool res = CreateTransactionInternal(vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);"
      },
      {
        "sha": "a58b418b6d47d687bbb473fe7c8878afc15b5fe8",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2995963b5d0b9bca503b0cc69c747f4cedec1e4/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2995963b5d0b9bca503b0cc69c747f4cedec1e4/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
        "patch": "@@ -326,7 +326,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     // ScriptPubKeyMan::GetID. In many cases it will be the hash of an internal structure\n     std::map<uint256, std::unique_ptr<ScriptPubKeyMan>> m_spk_managers;\n \n-    bool CreateTransactionInternal(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign);\n+    bool CreateTransactionInternal(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Catch wallet up to current chain, scanning new blocks, updating the best"
      }
    ]
  },
  {
    "sha": "d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMmFlZTNiYmM3NjVhMWYwMmU0Y2VhZGIyZmE1OTI4YWM1MjRmMWE3",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-20T18:53:36Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:01:29Z"
      },
      "message": "Remove extraneous scope in CreateTransactionInternal\n\nThese brackets were restricting a scope for no apparent reason. Remove\nthem and dedent.",
      "tree": {
        "sha": "e16bc2df68d6ae04945f7f9e52bae1f04a020e37",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e16bc2df68d6ae04945f7f9e52bae1f04a020e37"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2995963b5d0b9bca503b0cc69c747f4cedec1e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b2995963b5d0b9bca503b0cc69c747f4cedec1e4"
      }
    ],
    "stats": {
      "total": 426,
      "additions": 212,
      "deletions": 214
    },
    "files": [
      {
        "sha": "e8bbdc454b335350f688fd6d4bb51afadf285142",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 212,
        "deletions": 214,
        "changes": 426,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
        "patch": "@@ -606,258 +606,256 @@ bool CWallet::CreateTransactionInternal(\n     FeeCalculation feeCalc;\n     TxSize tx_sizes;\n     int nBytes;\n-    {\n-        std::set<CInputCoin> setCoins;\n-        txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-        std::vector<COutput> vAvailableCoins;\n-        AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-        CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-        coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n-        // Create change script that will be used if we need change\n-        // TODO: pass in scriptChange instead of reservedest so\n-        // change transaction isn't always pay-to-bitcoin-address\n-        CScript scriptChange;\n-\n-        // coin control: send change to custom address\n-        if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n-            scriptChange = GetScriptForDestination(coin_control.destChange);\n-        } else { // no coin control: send change to newly generated address\n-            // Note: We use a new key here to keep it from being obvious which side is the change.\n-            //  The drawback is that by not reusing a previous key, the change may be lost if a\n-            //  backup is restored, if the backup doesn't have the new private key for the change.\n-            //  If we reused the old key, it would be possible to add code to look for and\n-            //  rediscover unknown transactions that were written with keys of ours to recover\n-            //  post-backup change.\n-\n-            // Reserve a new key pair from key pool. If it fails, provide a dummy\n-            // destination in case we don't need change.\n-            CTxDestination dest;\n-            if (!reservedest.GetReservedDestination(dest, true)) {\n-                error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n-            }\n-            scriptChange = GetScriptForDestination(dest);\n-            // A valid destination implies a change script (and\n-            // vice-versa). An empty change script will abort later, if the\n-            // change keypool ran out, but change is required.\n-            CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n-        }\n-        CTxOut change_prototype_txout(0, scriptChange);\n-        coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n-\n-        // Get size of spending the change output\n-        int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-        // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-        // as lower-bound to allow BnB to do it's thing\n-        if (change_spend_size == -1) {\n-            coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-        } else {\n-            coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-        }\n+    std::set<CInputCoin> setCoins;\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n+    // Create change script that will be used if we need change\n+    // TODO: pass in scriptChange instead of reservedest so\n+    // change transaction isn't always pay-to-bitcoin-address\n+    CScript scriptChange;\n+\n+    // coin control: send change to custom address\n+    if (!std::get_if<CNoDestination>(&coin_control.destChange)) {\n+        scriptChange = GetScriptForDestination(coin_control.destChange);\n+    } else { // no coin control: send change to newly generated address\n+        // Note: We use a new key here to keep it from being obvious which side is the change.\n+        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+        //  backup is restored, if the backup doesn't have the new private key for the change.\n+        //  If we reused the old key, it would be possible to add code to look for and\n+        //  rediscover unknown transactions that were written with keys of ours to recover\n+        //  post-backup change.\n+\n+        // Reserve a new key pair from key pool. If it fails, provide a dummy\n+        // destination in case we don't need change.\n+        CTxDestination dest;\n+        if (!reservedest.GetReservedDestination(dest, true)) {\n+            error = _(\"Transaction needs a change address, but we can't generate it. Please call keypoolrefill first.\");\n+        }\n+        scriptChange = GetScriptForDestination(dest);\n+        // A valid destination implies a change script (and\n+        // vice-versa). An empty change script will abort later, if the\n+        // change keypool ran out, but change is required.\n+        CHECK_NONFATAL(IsValidDestination(dest) != scriptChange.empty());\n+    }\n+    CTxOut change_prototype_txout(0, scriptChange);\n+    coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n+\n+    // Get size of spending the change output\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+    // as lower-bound to allow BnB to do it's thing\n+    if (change_spend_size == -1) {\n+        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+    } else {\n+        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+    }\n \n-        // Set discard feerate\n-        coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+    // Set discard feerate\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n \n-        // Get the fee rate to use effective values in coin selection\n-        coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n-        // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n-        // provided one\n-        if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n-            error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n-            return false;\n-        }\n-        if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-            // eventually allow a fallback fee\n-            error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n-            return false;\n-        }\n+    // Get the fee rate to use effective values in coin selection\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+    // provided one\n+    if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n+        error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n+        return false;\n+    }\n+    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+        // eventually allow a fallback fee\n+        error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+        return false;\n+    }\n \n-        // Get long term estimate\n-        CCoinControl cc_temp;\n-        cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-        coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n+    // Get long term estimate\n+    CCoinControl cc_temp;\n+    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n+    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n \n-        // Calculate the cost of change\n-        // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n-        // For creating the change output now, we use the effective feerate.\n-        // For spending the change output in the future, we use the discard feerate for now.\n-        // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n-        coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n-        coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n+    // Calculate the cost of change\n+    // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n+    // For creating the change output now, we use the effective feerate.\n+    // For spending the change output in the future, we use the discard feerate for now.\n+    // So cost of change = (change output size * effective feerate) + (size of spending change output * discard feerate)\n+    coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n+    coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-        coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n \n-        // vouts to the payees\n+    // vouts to the payees\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n+        coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+    }\n+    for (const auto& recipient : vecSend)\n+    {\n+        CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+\n+        // Include the fee cost for outputs.\n         if (!coin_selection_params.m_subtract_fee_outputs) {\n-            coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+            coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n         }\n-        for (const auto& recipient : vecSend)\n+\n+        if (IsDust(txout, chain().relayDustFee()))\n         {\n-            CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+            error = _(\"Transaction amount too small\");\n+            return false;\n+        }\n+        txNew.vout.push_back(txout);\n+    }\n \n-            // Include the fee cost for outputs.\n-            if (!coin_selection_params.m_subtract_fee_outputs) {\n-                coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-            }\n+    // Include the fees for things that aren't inputs, excluding the change output\n+    const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n+    CAmount nValueToSelect = nValue + not_input_fees;\n \n-            if (IsDust(txout, chain().relayDustFee()))\n-            {\n-                error = _(\"Transaction amount too small\");\n-                return false;\n-            }\n-            txNew.vout.push_back(txout);\n-        }\n+    // Choose coins to use\n+    CAmount inputs_sum = 0;\n+    setCoins.clear();\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    {\n+        error = _(\"Insufficient funds\");\n+        return false;\n+    }\n \n-        // Include the fees for things that aren't inputs, excluding the change output\n-        const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-        CAmount nValueToSelect = nValue + not_input_fees;\n+    // Always make a change output\n+    // We will reduce the fee from this change output later, and remove the output if it is too small.\n+    const CAmount change_and_fee = inputs_sum - nValue;\n+    assert(change_and_fee >= 0);\n+    CTxOut newTxOut(change_and_fee, scriptChange);\n \n-        // Choose coins to use\n-        CAmount inputs_sum = 0;\n-        setCoins.clear();\n-        if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n-        {\n-            error = _(\"Insufficient funds\");\n-            return false;\n-        }\n+    if (nChangePosInOut == -1)\n+    {\n+        // Insert change txn at random position:\n+        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n+    }\n+    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n+    {\n+        error = _(\"Change index out of range\");\n+        return false;\n+    }\n \n-        // Always make a change output\n-        // We will reduce the fee from this change output later, and remove the output if it is too small.\n-        const CAmount change_and_fee = inputs_sum - nValue;\n-        assert(change_and_fee >= 0);\n-        CTxOut newTxOut(change_and_fee, scriptChange);\n+    assert(nChangePosInOut != -1);\n+    auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-        if (nChangePosInOut == -1)\n-        {\n-            // Insert change txn at random position:\n-            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-        }\n-        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-        {\n-            error = _(\"Change index out of range\");\n-            return false;\n-        }\n+    // Dummy fill vin for maximum size estimation\n+    //\n+    for (const auto& coin : setCoins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+    }\n \n-        assert(nChangePosInOut != -1);\n-        auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n+    // Calculate the transaction fee\n+    tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    nBytes = tx_sizes.vsize;\n+    if (nBytes < 0) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n+    nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n \n-        // Dummy fill vin for maximum size estimation\n-        //\n-        for (const auto& coin : setCoins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-        }\n+    // Subtract fee from the change output if not subtracting it from recipient outputs\n+    CAmount fee_needed = nFeeRet;\n+    if (nSubtractFeeFromAmount == 0) {\n+        change_position->nValue -= fee_needed;\n+    }\n \n-        // Calculate the transaction fee\n+    // We want to drop the change to fees if:\n+    // 1. The change output would be dust\n+    // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n+    CAmount change_amount = change_position->nValue;\n+    if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+    {\n+        nChangePosInOut = -1;\n+        change_amount = 0;\n+        txNew.vout.erase(change_position);\n+\n+        // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n         tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n         nBytes = tx_sizes.vsize;\n-        if (nBytes < 0) {\n-            error = _(\"Signing transaction failed\");\n-            return false;\n-        }\n-        nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+        fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n+    }\n \n-        // Subtract fee from the change output if not subtrating it from recipient outputs\n-        CAmount fee_needed = nFeeRet;\n-        if (nSubtractFeeFromAmount == 0) {\n-            change_position->nValue -= fee_needed;\n-        }\n+    // Update nFeeRet in case fee_needed changed due to dropping the change output\n+    if (fee_needed <= change_and_fee - change_amount) {\n+        nFeeRet = change_and_fee - change_amount;\n+    }\n \n-        // We want to drop the change to fees if:\n-        // 1. The change output would be dust\n-        // 2. The change is within the (almost) exact match window, i.e. it is less than or equal to the cost of the change output (cost_of_change)\n-        CAmount change_amount = change_position->nValue;\n-        if (IsDust(*change_position, coin_selection_params.m_discard_feerate) || change_amount <= coin_selection_params.m_cost_of_change)\n+    // Reduce output values for subtractFeeFromAmount\n+    if (nSubtractFeeFromAmount != 0) {\n+        CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n+        int i = 0;\n+        bool fFirst = true;\n+        for (const auto& recipient : vecSend)\n         {\n-            nChangePosInOut = -1;\n-            change_amount = 0;\n-            txNew.vout.erase(change_position);\n-\n-            // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-            tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-            nBytes = tx_sizes.vsize;\n-            fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n-        }\n-\n-        // Update nFeeRet in case fee_needed changed due to dropping the change output\n-        if (fee_needed <= change_and_fee - change_amount) {\n-            nFeeRet = change_and_fee - change_amount;\n-        }\n+            if (i == nChangePosInOut) {\n+                ++i;\n+            }\n+            CTxOut& txout = txNew.vout[i];\n \n-        // Reduce output values for subtractFeeFromAmount\n-        if (nSubtractFeeFromAmount != 0) {\n-            CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n-            int i = 0;\n-            bool fFirst = true;\n-            for (const auto& recipient : vecSend)\n+            if (recipient.fSubtractFeeFromAmount)\n             {\n-                if (i == nChangePosInOut) {\n-                    ++i;\n-                }\n-                CTxOut& txout = txNew.vout[i];\n+                txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n \n-                if (recipient.fSubtractFeeFromAmount)\n+                if (fFirst) // first receiver pays the remainder not divisible by output count\n                 {\n-                    txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                    if (fFirst) // first receiver pays the remainder not divisible by output count\n-                    {\n-                        fFirst = false;\n-                        txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n-                    }\n+                    fFirst = false;\n+                    txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n+                }\n \n-                    // Error if this output is reduced to be below dust\n-                    if (IsDust(txout, chain().relayDustFee())) {\n-                        if (txout.nValue < 0) {\n-                            error = _(\"The transaction amount is too small to pay the fee\");\n-                        } else {\n-                            error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                        }\n-                        return false;\n+                // Error if this output is reduced to be below dust\n+                if (IsDust(txout, chain().relayDustFee())) {\n+                    if (txout.nValue < 0) {\n+                        error = _(\"The transaction amount is too small to pay the fee\");\n+                    } else {\n+                        error = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                     }\n+                    return false;\n                 }\n-                ++i;\n             }\n-            nFeeRet = fee_needed;\n+            ++i;\n         }\n+        nFeeRet = fee_needed;\n+    }\n \n-        // Give up if change keypool ran out and change is required\n-        if (scriptChange.empty() && nChangePosInOut != -1) {\n-            return false;\n-        }\n+    // Give up if change keypool ran out and change is required\n+    if (scriptChange.empty() && nChangePosInOut != -1) {\n+        return false;\n+    }\n \n-        // Shuffle selected coins and fill in final vin\n-        txNew.vin.clear();\n-        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-        Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+    // Shuffle selected coins and fill in final vin\n+    txNew.vin.clear();\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n \n-        // Note how the sequence number is set to non-maxint so that\n-        // the nLockTime set above actually works.\n-        //\n-        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-        // we use the highest possible value in that range (maxint-2)\n-        // to avoid conflicting with other possible uses of nSequence,\n-        // and in the spirit of \"smallest possible change from prior\n-        // behavior.\"\n-        const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-        for (const auto& coin : selected_coins) {\n-            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-        }\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n+    //\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+    }\n \n-        if (sign && !SignTransaction(txNew)) {\n-            error = _(\"Signing transaction failed\");\n-            return false;\n-        }\n+    if (sign && !SignTransaction(txNew)) {\n+        error = _(\"Signing transaction failed\");\n+        return false;\n+    }\n \n-        // Return the constructed transaction data.\n-        tx = MakeTransactionRef(std::move(txNew));\n+    // Return the constructed transaction data.\n+    tx = MakeTransactionRef(std::move(txNew));\n \n-        // Limit size\n-        if ((sign && GetTransactionWeight(*tx) > MAX_STANDARD_TX_WEIGHT) ||\n-            (!sign && tx_sizes.weight > MAX_STANDARD_TX_WEIGHT))\n-        {\n-            error = _(\"Transaction too large\");\n-            return false;\n-        }\n+    // Limit size\n+    if ((sign && GetTransactionWeight(*tx) > MAX_STANDARD_TX_WEIGHT) ||\n+        (!sign && tx_sizes.weight > MAX_STANDARD_TX_WEIGHT))\n+    {\n+        error = _(\"Transaction too large\");\n+        return false;\n     }\n \n     if (nFeeRet > m_default_max_tx_fee) {"
      }
    ]
  },
  {
    "sha": "dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWMyMWM3OTNmOGZiYjRkNWRlYmM1NWFjOTdjNDA2YzdjOTNmZjQ4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-17T20:20:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:03:43Z"
      },
      "message": "Rename nValue and nValueToSelect\n\nnValue is the sum of the intended recipient amounts, so name it that for\nclarity.\n\nnValueToSelect is the coin selection target value, so name it\nselection_target for clarity.",
      "tree": {
        "sha": "ca8168963814dd688da88332f7add854a441acb7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ca8168963814dd688da88332f7add854a441acb7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac21c793f8fbb4d5debc55ac97c406c7c93ff48/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2aee3bbc765a1f02e4ceadb2fa5928ac524f1a7"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 6,
      "deletions": 6
    },
    "files": [
      {
        "sha": "3e69703788ab91bb4a2edd520d11113289d07995",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dac21c793f8fbb4d5debc55ac97c406c7c93ff48/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dac21c793f8fbb4d5debc55ac97c406c7c93ff48/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
        "patch": "@@ -580,18 +580,18 @@ bool CWallet::CreateTransactionInternal(\n {\n     AssertLockHeld(cs_wallet);\n \n-    CAmount nValue = 0;\n+    CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n     unsigned int nSubtractFeeFromAmount = 0;\n     for (const auto& recipient : vecSend)\n     {\n-        if (nValue < 0 || recipient.nAmount < 0)\n+        if (recipients_sum < 0 || recipient.nAmount < 0)\n         {\n             error = _(\"Transaction amounts must not be negative\");\n             return false;\n         }\n-        nValue += recipient.nAmount;\n+        recipients_sum += recipient.nAmount;\n \n         if (recipient.fSubtractFeeFromAmount)\n             nSubtractFeeFromAmount++;\n@@ -709,20 +709,20 @@ bool CWallet::CreateTransactionInternal(\n \n     // Include the fees for things that aren't inputs, excluding the change output\n     const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n-    CAmount nValueToSelect = nValue + not_input_fees;\n+    CAmount selection_target = recipients_sum + not_input_fees;\n \n     // Choose coins to use\n     CAmount inputs_sum = 0;\n     setCoins.clear();\n-    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ nValueToSelect, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n     {\n         error = _(\"Insufficient funds\");\n         return false;\n     }\n \n     // Always make a change output\n     // We will reduce the fee from this change output later, and remove the output if it is too small.\n-    const CAmount change_and_fee = inputs_sum - nValue;\n+    const CAmount change_and_fee = inputs_sum - recipients_sum;\n     assert(change_and_fee >= 0);\n     CTxOut newTxOut(change_and_fee, scriptChange);\n "
      }
    ]
  },
  {
    "sha": "cd1d6d3324a841087f6d5da723394e8d7df07ec7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDFkNmQzMzI0YTg0MTA4N2Y2ZDVkYTcyMzM5NGU4ZDdkZjA3ZWM3",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-17T20:22:30Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:05:15Z"
      },
      "message": "Rename nSubtractFeeFromAmount in CreateTransaction\n\nRenamed to outputs_to_subtract_fee_from for clarity.",
      "tree": {
        "sha": "a4cd0e3e35939f788c736ec1b4ae6885dd9cc573",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a4cd0e3e35939f788c736ec1b4ae6885dd9cc573"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd1d6d3324a841087f6d5da723394e8d7df07ec7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd1d6d3324a841087f6d5da723394e8d7df07ec7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd1d6d3324a841087f6d5da723394e8d7df07ec7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd1d6d3324a841087f6d5da723394e8d7df07ec7/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dac21c793f8fbb4d5debc55ac97c406c7c93ff48",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dac21c793f8fbb4d5debc55ac97c406c7c93ff48"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "70f29001d06ebf88e6b54213c6ec59ce0f43fa4e",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd1d6d3324a841087f6d5da723394e8d7df07ec7/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd1d6d3324a841087f6d5da723394e8d7df07ec7/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=cd1d6d3324a841087f6d5da723394e8d7df07ec7",
        "patch": "@@ -583,7 +583,7 @@ bool CWallet::CreateTransactionInternal(\n     CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n-    unsigned int nSubtractFeeFromAmount = 0;\n+    unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n     for (const auto& recipient : vecSend)\n     {\n         if (recipients_sum < 0 || recipient.nAmount < 0)\n@@ -594,7 +594,7 @@ bool CWallet::CreateTransactionInternal(\n         recipients_sum += recipient.nAmount;\n \n         if (recipient.fSubtractFeeFromAmount)\n-            nSubtractFeeFromAmount++;\n+            outputs_to_subtract_fee_from++;\n     }\n     if (vecSend.empty())\n     {\n@@ -684,7 +684,7 @@ bool CWallet::CreateTransactionInternal(\n     coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n     coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-    coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n+    coin_selection_params.m_subtract_fee_outputs = outputs_to_subtract_fee_from != 0; // If we are doing subtract fee from recipient, don't use effective values\n \n     // vouts to the payees\n     if (!coin_selection_params.m_subtract_fee_outputs) {\n@@ -757,7 +757,7 @@ bool CWallet::CreateTransactionInternal(\n \n     // Subtract fee from the change output if not subtracting it from recipient outputs\n     CAmount fee_needed = nFeeRet;\n-    if (nSubtractFeeFromAmount == 0) {\n+    if (outputs_to_subtract_fee_from == 0) {\n         change_position->nValue -= fee_needed;\n     }\n \n@@ -783,7 +783,7 @@ bool CWallet::CreateTransactionInternal(\n     }\n \n     // Reduce output values for subtractFeeFromAmount\n-    if (nSubtractFeeFromAmount != 0) {\n+    if (outputs_to_subtract_fee_from != 0) {\n         CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n         int i = 0;\n         bool fFirst = true;\n@@ -796,12 +796,12 @@ bool CWallet::CreateTransactionInternal(\n \n             if (recipient.fSubtractFeeFromAmount)\n             {\n-                txout.nValue -= to_reduce / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n+                txout.nValue -= to_reduce / outputs_to_subtract_fee_from; // Subtract fee equally from each selected recipient\n \n                 if (fFirst) // first receiver pays the remainder not divisible by output count\n                 {\n                     fFirst = false;\n-                    txout.nValue -= to_reduce % nSubtractFeeFromAmount;\n+                    txout.nValue -= to_reduce % outputs_to_subtract_fee_from;\n                 }\n \n                 // Error if this output is reduced to be below dust"
      }
    ]
  },
  {
    "sha": "32ab430651594ed3d10a6ed75f19de5197f0e9b0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMmFiNDMwNjUxNTk0ZWQzZDEwYTZlZDc1ZjE5ZGU1MTk3ZjBlOWIw",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-17T20:23:08Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:05:42Z"
      },
      "message": "Move recipients vector checks to beginning of CreateTransaction\n\nEnsuring that the recipients vector is not empty and that the amounts\nare non-negative can be done in CreateTransaction rather than\nCreateTransactionInternal. Additionally, these checks should happen as\nsoon as possible, so they are done at the beginning of\nCreateTransaction.",
      "tree": {
        "sha": "f658b8a102786669ff0021a944c4f7ebee99216f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f658b8a102786669ff0021a944c4f7ebee99216f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32ab430651594ed3d10a6ed75f19de5197f0e9b0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ab430651594ed3d10a6ed75f19de5197f0e9b0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32ab430651594ed3d10a6ed75f19de5197f0e9b0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ab430651594ed3d10a6ed75f19de5197f0e9b0/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd1d6d3324a841087f6d5da723394e8d7df07ec7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd1d6d3324a841087f6d5da723394e8d7df07ec7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd1d6d3324a841087f6d5da723394e8d7df07ec7"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 10,
      "deletions": 10
    },
    "files": [
      {
        "sha": "374d361976462f02798ae7c5e4ad090d656811a1",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32ab430651594ed3d10a6ed75f19de5197f0e9b0/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32ab430651594ed3d10a6ed75f19de5197f0e9b0/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=32ab430651594ed3d10a6ed75f19de5197f0e9b0",
        "patch": "@@ -586,21 +586,11 @@ bool CWallet::CreateTransactionInternal(\n     unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n     for (const auto& recipient : vecSend)\n     {\n-        if (recipients_sum < 0 || recipient.nAmount < 0)\n-        {\n-            error = _(\"Transaction amounts must not be negative\");\n-            return false;\n-        }\n         recipients_sum += recipient.nAmount;\n \n         if (recipient.fSubtractFeeFromAmount)\n             outputs_to_subtract_fee_from++;\n     }\n-    if (vecSend.empty())\n-    {\n-        error = _(\"Transaction must have at least one recipient\");\n-        return false;\n-    }\n \n     CMutableTransaction txNew;\n     FeeCalculation feeCalc;\n@@ -897,6 +887,16 @@ bool CWallet::CreateTransaction(\n         FeeCalculation& fee_calc_out,\n         bool sign)\n {\n+    if (vecSend.empty()) {\n+        error = _(\"Transaction must have at least one recipient\");\n+        return false;\n+    }\n+\n+    if (std::any_of(vecSend.cbegin(), vecSend.cend(), [](const auto& recipient){ return recipient.nAmount < 0; })) {\n+        error = _(\"Transaction amounts must not be negative\");\n+        return false;\n+    }\n+\n     LOCK(cs_wallet);\n \n     int nChangePosIn = nChangePosInOut;"
      }
    ]
  },
  {
    "sha": "364e0698a543a19e81ae407cc523970e6ed924e8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNjRlMDY5OGE1NDNhMTllODFhZTQwN2NjNTIzOTcwZTZlZDkyNGU4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-17T20:26:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:06:13Z"
      },
      "message": "Move variable initializations to where they are used\n\n- txNew nLockTime setting to txNew init\n- FeeCalc to the fee estimation fetching\n- setCoins to prior to SelectCoins\n- nBytes to CalculateMaximumSignedTxSize call\n- tx_sizes to CalculateMaximumSignedTxSize call\n- coin_selection_params.m_avoid_partial_spends to params init",
      "tree": {
        "sha": "a09efcbe22968510110756540c6ca52f92551b66",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a09efcbe22968510110756540c6ca52f92551b66"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/364e0698a543a19e81ae407cc523970e6ed924e8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/364e0698a543a19e81ae407cc523970e6ed924e8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/364e0698a543a19e81ae407cc523970e6ed924e8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/364e0698a543a19e81ae407cc523970e6ed924e8/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "32ab430651594ed3d10a6ed75f19de5197f0e9b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32ab430651594ed3d10a6ed75f19de5197f0e9b0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/32ab430651594ed3d10a6ed75f19de5197f0e9b0"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 14,
      "deletions": 14
    },
    "files": [
      {
        "sha": "af56ce06d2f7e209b116f483186623a1b0c0d8a3",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/364e0698a543a19e81ae407cc523970e6ed924e8/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/364e0698a543a19e81ae407cc523970e6ed924e8/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=364e0698a543a19e81ae407cc523970e6ed924e8",
        "patch": "@@ -580,6 +580,12 @@ bool CWallet::CreateTransactionInternal(\n {\n     AssertLockHeld(cs_wallet);\n \n+    CMutableTransaction txNew; // The resulting transaction that we make\n+    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+\n+    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n+    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n+\n     CAmount recipients_sum = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n@@ -592,17 +598,6 @@ bool CWallet::CreateTransactionInternal(\n             outputs_to_subtract_fee_from++;\n     }\n \n-    CMutableTransaction txNew;\n-    FeeCalculation feeCalc;\n-    TxSize tx_sizes;\n-    int nBytes;\n-    std::set<CInputCoin> setCoins;\n-    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n-    std::vector<COutput> vAvailableCoins;\n-    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n-    CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n-    coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n-\n     // Create change script that will be used if we need change\n     // TODO: pass in scriptChange instead of reservedest so\n     // change transaction isn't always pay-to-bitcoin-address\n@@ -648,6 +643,7 @@ bool CWallet::CreateTransactionInternal(\n     coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n \n     // Get the fee rate to use effective values in coin selection\n+    FeeCalculation feeCalc;\n     coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n     // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n     // provided one\n@@ -701,9 +697,13 @@ bool CWallet::CreateTransactionInternal(\n     const CAmount not_input_fees = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.tx_noinputs_size);\n     CAmount selection_target = recipients_sum + not_input_fees;\n \n+    // Get available coins\n+    std::vector<COutput> vAvailableCoins;\n+    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+\n     // Choose coins to use\n     CAmount inputs_sum = 0;\n-    setCoins.clear();\n+    std::set<CInputCoin> setCoins;\n     if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n     {\n         error = _(\"Insufficient funds\");\n@@ -737,8 +737,8 @@ bool CWallet::CreateTransactionInternal(\n     }\n \n     // Calculate the transaction fee\n-    tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-    nBytes = tx_sizes.vsize;\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    int nBytes = tx_sizes.vsize;\n     if (nBytes < 0) {\n         error = _(\"Signing transaction failed\");\n         return false;"
      }
    ]
  },
  {
    "sha": "d39cac0547c960df0a890e89f43b458147b4b07a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMzljYWMwNTQ3Yzk2MGRmMGE4OTBlODlmNDNiNDU4MTQ3YjRiMDdh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-17T20:29:31Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:06:40Z"
      },
      "message": "Set m_subtract_fee_outputs during recipients vector loop\n\nInstead of setting this afterwards based on the results from the loop,\njust do it inside of the loop itself.\n\nFixed some styling nearby",
      "tree": {
        "sha": "a66c10ff2b818bdf113d4d1cff42f8f9f713f6d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a66c10ff2b818bdf113d4d1cff42f8f9f713f6d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d39cac0547c960df0a890e89f43b458147b4b07a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d39cac0547c960df0a890e89f43b458147b4b07a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d39cac0547c960df0a890e89f43b458147b4b07a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d39cac0547c960df0a890e89f43b458147b4b07a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "364e0698a543a19e81ae407cc523970e6ed924e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/364e0698a543a19e81ae407cc523970e6ed924e8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/364e0698a543a19e81ae407cc523970e6ed924e8"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 6,
      "deletions": 7
    },
    "files": [
      {
        "sha": "dbe5d165c8618d261164e20debf3e012a663c26c",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d39cac0547c960df0a890e89f43b458147b4b07a/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d39cac0547c960df0a890e89f43b458147b4b07a/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=d39cac0547c960df0a890e89f43b458147b4b07a",
        "patch": "@@ -590,12 +590,13 @@ bool CWallet::CreateTransactionInternal(\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n     ReserveDestination reservedest(this, change_type);\n     unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n-    for (const auto& recipient : vecSend)\n-    {\n+    for (const auto& recipient : vecSend) {\n         recipients_sum += recipient.nAmount;\n \n-        if (recipient.fSubtractFeeFromAmount)\n+        if (recipient.fSubtractFeeFromAmount) {\n             outputs_to_subtract_fee_from++;\n+            coin_selection_params.m_subtract_fee_outputs = true;\n+        }\n     }\n \n     // Create change script that will be used if we need change\n@@ -670,8 +671,6 @@ bool CWallet::CreateTransactionInternal(\n     coin_selection_params.m_change_fee = coin_selection_params.m_effective_feerate.GetFee(coin_selection_params.change_output_size);\n     coin_selection_params.m_cost_of_change = coin_selection_params.m_discard_feerate.GetFee(coin_selection_params.change_spend_size) + coin_selection_params.m_change_fee;\n \n-    coin_selection_params.m_subtract_fee_outputs = outputs_to_subtract_fee_from != 0; // If we are doing subtract fee from recipient, don't use effective values\n-\n     // vouts to the payees\n     if (!coin_selection_params.m_subtract_fee_outputs) {\n         coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n@@ -747,7 +746,7 @@ bool CWallet::CreateTransactionInternal(\n \n     // Subtract fee from the change output if not subtracting it from recipient outputs\n     CAmount fee_needed = nFeeRet;\n-    if (outputs_to_subtract_fee_from == 0) {\n+    if (!coin_selection_params.m_subtract_fee_outputs) {\n         change_position->nValue -= fee_needed;\n     }\n \n@@ -773,7 +772,7 @@ bool CWallet::CreateTransactionInternal(\n     }\n \n     // Reduce output values for subtractFeeFromAmount\n-    if (outputs_to_subtract_fee_from != 0) {\n+    if (coin_selection_params.m_subtract_fee_outputs) {\n         CAmount to_reduce = fee_needed + change_amount - change_and_fee;\n         int i = 0;\n         bool fFirst = true;"
      }
    ]
  },
  {
    "sha": "b583f73354c617ede9145f9738f13cedf1c13e08",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNTgzZjczMzU0YzYxN2VkZTkxNDVmOTczOGYxM2NlZGYxYzEzZTA4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-17T20:31:06Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:07:49Z"
      },
      "message": "Move vin filling to before final fee setting\n\nIt's unnecessary to fill in the vin with dummy inputs, calculate the\nfee, then fill in the vin with the actual inputs. Just fill the vin with\nthe actual inputs the first time.",
      "tree": {
        "sha": "c5d699c9f7d57662c25abcf94afea0eac45624aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5d699c9f7d57662c25abcf94afea0eac45624aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b583f73354c617ede9145f9738f13cedf1c13e08",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b583f73354c617ede9145f9738f13cedf1c13e08",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b583f73354c617ede9145f9738f13cedf1c13e08",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b583f73354c617ede9145f9738f13cedf1c13e08/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d39cac0547c960df0a890e89f43b458147b4b07a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d39cac0547c960df0a890e89f43b458147b4b07a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d39cac0547c960df0a890e89f43b458147b4b07a"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 14,
      "deletions": 21
    },
    "files": [
      {
        "sha": "e3bea9bd33ada6a5ca2b4a9ed84ccf39873ab0c3",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 21,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b583f73354c617ede9145f9738f13cedf1c13e08/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b583f73354c617ede9145f9738f13cedf1c13e08/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=b583f73354c617ede9145f9738f13cedf1c13e08",
        "patch": "@@ -729,10 +729,21 @@ bool CWallet::CreateTransactionInternal(\n     assert(nChangePosInOut != -1);\n     auto change_position = txNew.vout.insert(txNew.vout.begin() + nChangePosInOut, newTxOut);\n \n-    // Dummy fill vin for maximum size estimation\n+    // Shuffle selected coins and fill in final vin\n+    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+\n+    // Note how the sequence number is set to non-maxint so that\n+    // the nLockTime set above actually works.\n     //\n-    for (const auto& coin : setCoins) {\n-        txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+    // we use the highest possible value in that range (maxint-2)\n+    // to avoid conflicting with other possible uses of nSequence,\n+    // and in the spirit of \"smallest possible change from prior\n+    // behavior.\"\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    for (const auto& coin : selected_coins) {\n+        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n     }\n \n     // Calculate the transaction fee\n@@ -813,24 +824,6 @@ bool CWallet::CreateTransactionInternal(\n         return false;\n     }\n \n-    // Shuffle selected coins and fill in final vin\n-    txNew.vin.clear();\n-    std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n-    Shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n-\n-    // Note how the sequence number is set to non-maxint so that\n-    // the nLockTime set above actually works.\n-    //\n-    // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-    // we use the highest possible value in that range (maxint-2)\n-    // to avoid conflicting with other possible uses of nSequence,\n-    // and in the spirit of \"smallest possible change from prior\n-    // behavior.\"\n-    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-    for (const auto& coin : selected_coins) {\n-        txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n-    }\n-\n     if (sign && !SignTransaction(txNew)) {\n         error = _(\"Signing transaction failed\");\n         return false;"
      }
    ]
  },
  {
    "sha": "96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NmMyYzk1MjBlODBlZTRmZWQ5MmYwZTFhYjg1OWQ1OWZjYmRiMTEw",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-20T19:21:15Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-05-30T18:10:10Z"
      },
      "message": "scripted-diff: Rename SelectCoinsMinConf to AttemptSelection\n\nSelectCoinsMinConf is a bit of a misnomer now since it really just does\nall of the coin selection given some parameters. So rename this to\nsomething less annoying to say and makes a bit more sense.\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/SelectCoinsMinConf/AttemptSelection/g' $(git grep -l SelectCoinsMinConf ./src)\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "45f98c0735d5b390d4223174b1ef6ec0901f84ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45f98c0735d5b390d4223174b1ef6ec0901f84ac"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b583f73354c617ede9145f9738f13cedf1c13e08",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b583f73354c617ede9145f9738f13cedf1c13e08",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b583f73354c617ede9145f9738f13cedf1c13e08"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 46,
      "deletions": 46
    },
    "files": [
      {
        "sha": "5beb833b48bf8b313065fb9227e33ebb58b11d2b",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
        "patch": "@@ -56,7 +56,7 @@ static void CoinSelection(benchmark::Bench& bench)\n     bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n+        bool success = wallet.AttemptSelection(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "c8ded4c51e2434887eb82af33a8980e1d6823efe",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
        "patch": "@@ -352,7 +352,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n     return groups_out;\n }\n \n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+bool CWallet::AttemptSelection(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n                                  std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const\n {\n     setCoinsRet.clear();\n@@ -456,40 +456,40 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n         // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n         // confirmations on outputs received from other wallets and only spend confirmed change.\n-        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-        if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (AttemptSelection(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (AttemptSelection(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n \n         // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n         // possible) if we cannot fund the transaction otherwise.\n         if (m_spend_zero_conf_change) {\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n+            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n+            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n             // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n             // in their entirety.\n-            if (SelectCoinsMinConf(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unsafe inputs if they are allowed. This may spend unconfirmed outputs\n             // received from other wallets.\n             if (coin_control.m_include_unsafe_inputs\n-                && SelectCoinsMinConf(value_to_select,\n+                && AttemptSelection(value_to_select,\n                     CoinEligibilityFilter(0 /* conf_mine */, 0 /* conf_theirs */, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n                     vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unlimited ancestors/descendants. The transaction will still need to meet\n             // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n             // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n-            if (!fRejectLongChains && SelectCoinsMinConf(value_to_select,\n+            if (!fRejectLongChains && AttemptSelection(value_to_select,\n                                       CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n                                       vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n@@ -499,7 +499,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n         return false;\n     }();\n \n-    // SelectCoinsMinConf clears setCoinsRet, so add the preset inputs from coin_control to the coinset\n+    // AttemptSelection clears setCoinsRet, so add the preset inputs from coin_control to the coinset\n     util::insert(setCoinsRet, setPresetCoins);\n \n     // add preset inputs to the total value selected"
      },
      {
        "sha": "c65ebad52f17a513ee101f889d743ea09ecd695f",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 34,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
        "patch": "@@ -270,7 +270,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         BOOST_CHECK(!SelectCoinsBnB(GroupCoins(utxo_pool), 1 * CENT, 2 * CENT, selection, value_ret));\n     }\n \n-    // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n+    // Make sure that effective value is working in AttemptSelection when BnB is used\n     CoinSelectionParams coin_selection_params_bnb(/* change_output_size= */ 0,\n                                                   /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(3000),\n                                                   /* long_term_feerate= */ CFeeRate(1000), /* discard_feerate= */ CFeeRate(1000),\n@@ -280,14 +280,14 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n+    BOOST_CHECK(!testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n \n     // Test fees subtracted from output:\n     empty_wallet();\n     add_coin(1 * CENT);\n     vCoins.at(0).nInputBytes = 40;\n     coin_selection_params_bnb.m_subtract_fee_outputs = true;\n-    BOOST_CHECK(testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n+    BOOST_CHECK(testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n     BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n     // Make sure that can use BnB when there are preset inputs\n@@ -322,24 +322,24 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         add_coin(1*CENT, 4);        // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         add_coin(2*CENT);           // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.AttemptSelection( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n         add_coin(5*CENT);           // add a mature 5 cent coin,\n@@ -349,33 +349,33 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n         // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.AttemptSelection(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.AttemptSelection(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -389,30 +389,30 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!testWallet.AttemptSelection(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -421,11 +421,11 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin( 2*COIN);\n         add_coin( 3*COIN);\n         add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -440,22 +440,22 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n         // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n \n         // but if we add a bigger coin, small change is avoided\n         add_coin(1111*MIN_CHANGE);\n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // if we add more small coins:\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n \n         // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // run the 'mtgox' test (see https://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -464,7 +464,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         for (int j = 0; j < 20; j++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n \n@@ -477,7 +477,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -487,7 +487,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 8 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK( testWallet.AttemptSelection(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n@@ -498,12 +498,12 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 100);\n \n         // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(testWallet.AttemptSelection(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(testWallet.AttemptSelection(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n         BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n       }\n@@ -517,7 +517,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n            // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.\n            for (int i = 0; i < RUN_TESTS; i++) {\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+             BOOST_CHECK(testWallet.AttemptSelection(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n \n              if (amt - 2000 < MIN_CHANGE) {\n                  // needs more than one input:\n@@ -602,7 +602,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n         add_coin(1000 * COIN);\n     add_coin(3 * COIN);\n \n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+    BOOST_CHECK(testWallet.AttemptSelection(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n     BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n     BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n "
      },
      {
        "sha": "caacd383bbe99bae28962b63a6708bf36b3b3128",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96c2c9520e80ee4fed92f0e1ab859d59fcbdb110/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=96c2c9520e80ee4fed92f0e1ab859d59fcbdb110",
        "patch": "@@ -445,7 +445,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n      * param@[out]  nValueRet       Used to return the total value of selected coins.\n      */\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+    bool AttemptSelection(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n         std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);"
      }
    ]
  }
]