[
  {
    "sha": "fa883ab35ad2d4328e35b1e855d0833740a6b910",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTg4M2FiMzVhZDJkNDMyOGUzNWIxZTg1NWQwODMzNzQwYTZiOTEw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-06-12T19:19:02Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-06-17T18:12:32Z"
      },
      "message": "net: Use mockable time for tx download",
      "tree": {
        "sha": "4efff508a9e43e652f14f1d0df4b703f50cb7743",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4efff508a9e43e652f14f1d0df4b703f50cb7743"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa883ab35ad2d4328e35b1e855d0833740a6b910",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiI1wwAgMo0JN3VCC5RPdS/E4pDvKcduLhIoxO9v8GeQS+aqkxFlKt5mqq7G8Ga\nNY9q3JZpF9qUk8gskPgdcIDwITXp8hJI99GhGhvEhQ79mSwYS+md0VsSTfuyES9C\neAEDm1OSCswIiLcNSlPGsaiGqrPmVnLSl0LUBUd/1GODA4nvHb4EPZXZHxFH/z35\ng7JQpsmxzx/N6SzCp70AHK9c5rxAd2p2lzjeH2twQiS2t+973IObzHT8A2eV14LY\nQP0Ht6vpZizJqXHpU6S1Ck5QYaWsSgyLzllOvAXw5yWCh8TRxNWP2UvrHAx3ltm7\nGkZeojATbW4RNlwazdj89ct6rp6PbvYmjzPXse9SEBINhIcbbY1DP0ncr7xGPtgB\n9jU8OOsydmXbGqYd9ac/jaQcn+2xkpn2OiYUj06tswFml3WCUR8WTHcrW/9iIq9c\n7JCQoYeZqAjOnKbTdtyAF1GarMHxRham+msbmlszRmMpD5DkXDtwQh3q1A9vFYmT\n611JlvTq\n=yd2I\n-----END PGP SIGNATURE-----",
        "payload": "tree 4efff508a9e43e652f14f1d0df4b703f50cb7743\nparent fce4123242c4ad76dabef1291306f5ba879cdc00\nauthor MarcoFalke <falke.marco@gmail.com> 1560367142 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1560795152 -0400\n\nnet: Use mockable time for tx download\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa883ab35ad2d4328e35b1e855d0833740a6b910",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa883ab35ad2d4328e35b1e855d0833740a6b910",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa883ab35ad2d4328e35b1e855d0833740a6b910/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fce4123242c4ad76dabef1291306f5ba879cdc00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fce4123242c4ad76dabef1291306f5ba879cdc00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fce4123242c4ad76dabef1291306f5ba879cdc00"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 42,
      "deletions": 32
    },
    "files": [
      {
        "sha": "7ed8c49c1187d0b5e4622bad814bcb1dbd60528b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 31,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa883ab35ad2d4328e35b1e855d0833740a6b910/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa883ab35ad2d4328e35b1e855d0833740a6b910/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa883ab35ad2d4328e35b1e855d0833740a6b910",
        "patch": "@@ -68,13 +68,13 @@ static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n /** Maximum number of announced transactions from a peer */\n static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n /** How many microseconds to delay requesting transactions from inbound peers */\n-static constexpr int64_t INBOUND_PEER_TX_DELAY = 2 * 1000000; // 2 seconds\n+static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};\n /** How long to wait (in microseconds) before downloading a transaction from an additional peer */\n-static constexpr int64_t GETDATA_TX_INTERVAL = 60 * 1000000; // 1 minute\n+static constexpr std::chrono::microseconds GETDATA_TX_INTERVAL{std::chrono::seconds{60}};\n /** Maximum delay (in microseconds) for transaction requests to avoid biasing some peers over others. */\n-static constexpr int64_t MAX_GETDATA_RANDOM_DELAY = 2 * 1000000; // 2 seconds\n+static constexpr std::chrono::microseconds MAX_GETDATA_RANDOM_DELAY{std::chrono::seconds{2}};\n /** How long to wait (in microseconds) before expiring an in-flight getdata request to a peer */\n-static constexpr int64_t TX_EXPIRY_INTERVAL = 10 * GETDATA_TX_INTERVAL;\n+static constexpr std::chrono::microseconds TX_EXPIRY_INTERVAL{GETDATA_TX_INTERVAL * 10};\n static_assert(INBOUND_PEER_TX_DELAY >= MAX_GETDATA_RANDOM_DELAY,\n \"To preserve security, MAX_GETDATA_RANDOM_DELAY should not exceed INBOUND_PEER_DELAY\");\n /** Limit to avoid sending big packets. Not used in processing incoming GETDATA for compatibility */\n@@ -340,16 +340,16 @@ struct CNodeState {\n         /* Track when to attempt download of announced transactions (process\n          * time in micros -> txid)\n          */\n-        std::multimap<int64_t, uint256> m_tx_process_time;\n+        std::multimap<std::chrono::microseconds, uint256> m_tx_process_time;\n \n         //! Store all the transactions a peer has recently announced\n         std::set<uint256> m_tx_announced;\n \n         //! Store transactions which were requested by us, with timestamp\n-        std::map<uint256, int64_t> m_tx_in_flight;\n+        std::map<uint256, std::chrono::microseconds> m_tx_in_flight;\n \n         //! Periodically check for stuck getdata requests\n-        int64_t m_check_expiry_timer{0};\n+        std::chrono::microseconds m_check_expiry_timer{0};\n     };\n \n     TxDownloadState m_tx_download;\n@@ -391,7 +391,7 @@ struct CNodeState {\n };\n \n // Keeps track of the time (in microseconds) when transactions were requested last time\n-limitedmap<uint256, int64_t> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n+limitedmap<uint256, std::chrono::microseconds> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n /** Map maintaining per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n@@ -688,16 +688,16 @@ void EraseTxRequest(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     g_already_asked_for.erase(txid);\n }\n \n-int64_t GetTxRequestTime(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+std::chrono::microseconds GetTxRequestTime(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     auto it = g_already_asked_for.find(txid);\n     if (it != g_already_asked_for.end()) {\n         return it->second;\n     }\n-    return 0;\n+    return {};\n }\n \n-void UpdateTxRequestTime(const uint256& txid, int64_t request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void UpdateTxRequestTime(const uint256& txid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     auto it = g_already_asked_for.find(txid);\n     if (it == g_already_asked_for.end()) {\n@@ -707,17 +707,17 @@ void UpdateTxRequestTime(const uint256& txid, int64_t request_time) EXCLUSIVE_LO\n     }\n }\n \n-int64_t CalculateTxGetDataTime(const uint256& txid, int64_t current_time, bool use_inbound_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+std::chrono::microseconds CalculateTxGetDataTime(const uint256& txid, std::chrono::microseconds current_time, bool use_inbound_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    int64_t process_time;\n-    int64_t last_request_time = GetTxRequestTime(txid);\n+    std::chrono::microseconds process_time;\n+    const auto last_request_time = GetTxRequestTime(txid);\n     // First time requesting this tx\n-    if (last_request_time == 0) {\n+    if (last_request_time.count() == 0) {\n         process_time = current_time;\n     } else {\n         // Randomize the delay to avoid biasing some peers over others (such as due to\n         // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRand(MAX_GETDATA_RANDOM_DELAY);\n+        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n     }\n \n     // We delay processing announcements from inbound peers\n@@ -726,7 +726,7 @@ int64_t CalculateTxGetDataTime(const uint256& txid, int64_t current_time, bool u\n     return process_time;\n }\n \n-void RequestTx(CNodeState* state, const uint256& txid, int64_t nNow) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(CNodeState* state, const uint256& txid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n     if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n@@ -740,7 +740,7 @@ void RequestTx(CNodeState* state, const uint256& txid, int64_t nNow) EXCLUSIVE_L\n \n     // Calculate the time to try requesting this transaction. Use\n     // fPreferredDownload as a proxy for outbound peers.\n-    int64_t process_time = CalculateTxGetDataTime(txid, nNow, !state->fPreferredDownload);\n+    const auto process_time = CalculateTxGetDataTime(txid, current_time, !state->fPreferredDownload);\n \n     peer_download_state.m_tx_process_time.emplace(process_time, txid);\n }\n@@ -2218,7 +2218,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n \n         uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-        int64_t nNow = GetTimeMicros();\n+        const auto current_time = GetTime<std::chrono::microseconds>();\n \n         for (CInv &inv : vInv)\n         {\n@@ -2250,7 +2250,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (fBlocksOnly) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !::ChainstateActive().IsInitialBlockDownload()) {\n-                    RequestTx(State(pfrom->GetId()), inv.hash, nNow);\n+                    RequestTx(State(pfrom->GetId()), inv.hash, current_time);\n                 }\n             }\n         }\n@@ -2524,12 +2524,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n             if (!fRejectedParents) {\n                 uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                int64_t nNow = GetTimeMicros();\n+                const auto current_time = GetTime<std::chrono::microseconds>();\n \n                 for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv)) RequestTx(State(pfrom->GetId()), _inv.hash, nNow);\n+                    if (!AlreadyHave(_inv)) RequestTx(State(pfrom->GetId()), _inv.hash, current_time);\n                 }\n                 AddOrphanTx(ptx, pfrom->GetId());\n \n@@ -3900,6 +3900,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n+        const auto current_time = GetTime<std::chrono::microseconds>();\n+        // nNow is the current system time (GetTimeMicros is not mockable) and\n+        // should be replaced by the mockable current_time eventually\n         nNow = GetTimeMicros();\n         if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n@@ -3992,9 +3995,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // were unresponsive in the past.\n         // Eventually we should consider disconnecting peers, but this is\n         // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= nNow) {\n+        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n             for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= nNow - TX_EXPIRY_INTERVAL) {\n+                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n                     LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n                     state.m_tx_download.m_tx_announced.erase(it->first);\n                     state.m_tx_download.m_tx_in_flight.erase(it++);\n@@ -4004,11 +4007,11 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             }\n             // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n             // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = nNow + TX_EXPIRY_INTERVAL/2 + GetRand(TX_EXPIRY_INTERVAL);\n+            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n         }\n \n         auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= nNow && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n+        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n             const uint256 txid = tx_process_time.begin()->second;\n             // Erase this entry from tx_process_time (it may be added back for\n             // processing at a later time, see below)\n@@ -4017,22 +4020,22 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             if (!AlreadyHave(inv)) {\n                 // If this transaction was last requested more than 1 minute ago,\n                 // then request.\n-                int64_t last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= nNow - GETDATA_TX_INTERVAL) {\n+                const auto last_request_time = GetTxRequestTime(inv.hash);\n+                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n                     LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n                     vGetData.push_back(inv);\n                     if (vGetData.size() >= MAX_GETDATA_SZ) {\n                         connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                         vGetData.clear();\n                     }\n-                    UpdateTxRequestTime(inv.hash, nNow);\n-                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, nNow);\n+                    UpdateTxRequestTime(inv.hash, current_time);\n+                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, current_time);\n                 } else {\n                     // This transaction is in flight from someone else; queue\n                     // up processing to happen after the download times out\n                     // (with a slight delay for inbound peers, to prefer\n                     // requests to outbound peers).\n-                    int64_t next_process_time = CalculateTxGetDataTime(txid, nNow, !state.fPreferredDownload);\n+                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload);\n                     tx_process_time.emplace(next_process_time, txid);\n                 }\n             } else {"
      },
      {
        "sha": "675b177af392e3b28fc690e825db0b4c9ff16ed6",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa883ab35ad2d4328e35b1e855d0833740a6b910/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa883ab35ad2d4328e35b1e855d0833740a6b910/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=fa883ab35ad2d4328e35b1e855d0833740a6b910",
        "patch": "@@ -667,6 +667,11 @@ uint64_t GetRand(uint64_t nMax) noexcept\n     return FastRandomContext(g_mock_deterministic_tests).randrange(nMax);\n }\n \n+std::chrono::microseconds GetRandMicros(std::chrono::microseconds duration_max) noexcept\n+{\n+    return std::chrono::microseconds{GetRand(duration_max.count())};\n+}\n+\n int GetRandInt(int nMax) noexcept\n {\n     return GetRand(nMax);"
      },
      {
        "sha": "22801ec1555c0bec9a0de40b83fbb76a7a8c9034",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa883ab35ad2d4328e35b1e855d0833740a6b910/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa883ab35ad2d4328e35b1e855d0833740a6b910/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=fa883ab35ad2d4328e35b1e855d0833740a6b910",
        "patch": "@@ -10,7 +10,8 @@\n #include <crypto/common.h>\n #include <uint256.h>\n \n-#include <stdint.h>\n+#include <chrono> // For std::chrono::microseconds\n+#include <cstdint>\n #include <limits>\n \n /**\n@@ -69,6 +70,7 @@\n  */\n void GetRandBytes(unsigned char* buf, int num) noexcept;\n uint64_t GetRand(uint64_t nMax) noexcept;\n+std::chrono::microseconds GetRandMicros(std::chrono::microseconds duration_max) noexcept;\n int GetRandInt(int nMax) noexcept;\n uint256 GetRandHash() noexcept;\n "
      }
    ]
  },
  {
    "sha": "fab365835639a3da03f8ad9a58a0db6c6c4c2314",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWIzNjU4MzU2MzlhM2RhMDNmOGFkOWE1OGEwZGI2YzZjNGMyMzE0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-05-28T21:52:55Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-06-19T16:50:14Z"
      },
      "message": "[qa] Test that getdata requests work as expected\n\nWe should eventually request a transaction from all peers that announce\nit (assuming we never receive it).\n\nWe should prefer requesting from outbound peers over inbound peers.\n\nEnforce the max tx requests in flight, and the eventual expiry of those\nrequests.\n\nTest author:    Suhas Daftuar <sdaftuar@gmail.com>\nAdjusted by:    MarcoFalke",
      "tree": {
        "sha": "2a1d642a58ab6ba697ba1b8b6fdac2f0a08442d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2a1d642a58ab6ba697ba1b8b6fdac2f0a08442d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fab365835639a3da03f8ad9a58a0db6c6c4c2314",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUikNgwAlrZSbAXyKnjWO7SKR6YVXBEnDw887C0lg1aOa8sAVju7ek18vaj9albC\nmT8/Gc/Ykufl93LgOM2WyezqBH+8iALGM2eihXCWDKV/eQyp0MMpGyqHTrRyq7qW\n2oHErJhYsyPabmxZxhbi2y9/uR2oWuzxVo7jlNZCM9dVrA2lLzpIDO6brvdSCyQG\nco26em3nMdDfqQLUBrjIS+aLDo/jOTLfg/sr+hWW9YASa+NshqlumyeALD705z8E\nPTN6ISf7hrBmankSHNmHw3gebxfDaenTwWqEFxna8AMX26JsY+bKORNrpIgsGeRs\nqMyN7RQPqYAdjd2mJ0G1NMahscTZ0tQbV8y3HBnnFue0xHGTwiEObeRSDeexbi4i\nnr1Eqz72MBwgyn7IIFhS4j114FKvoqkAcRGADUjT6baUT4MjzeMClNzXzwxmoWxk\nPEpBztT8F1F2PN2+yAKFcA9qVLzQMzHWO2S1VacGXharSJwrfeF1VVV+tlRkr+i2\nhTUNEFl5\n=GFZf\n-----END PGP SIGNATURE-----",
        "payload": "tree 2a1d642a58ab6ba697ba1b8b6fdac2f0a08442d4\nparent fa883ab35ad2d4328e35b1e855d0833740a6b910\nauthor Suhas Daftuar <sdaftuar@gmail.com> 1559080375 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1560963014 -0400\n\n[qa] Test that getdata requests work as expected\n\nWe should eventually request a transaction from all peers that announce\nit (assuming we never receive it).\n\nWe should prefer requesting from outbound peers over inbound peers.\n\nEnforce the max tx requests in flight, and the eventual expiry of those\nrequests.\n\nTest author:    Suhas Daftuar <sdaftuar@gmail.com>\nAdjusted by:    MarcoFalke\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab365835639a3da03f8ad9a58a0db6c6c4c2314",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fab365835639a3da03f8ad9a58a0db6c6c4c2314",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab365835639a3da03f8ad9a58a0db6c6c4c2314/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa883ab35ad2d4328e35b1e855d0833740a6b910",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa883ab35ad2d4328e35b1e855d0833740a6b910",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa883ab35ad2d4328e35b1e855d0833740a6b910"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 176,
      "deletions": 0
    },
    "files": [
      {
        "sha": "19d78ff3039c20f6fcc9c1cf72cb77ff8f3fe76e",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "added",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab365835639a3da03f8ad9a58a0db6c6c4c2314/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab365835639a3da03f8ad9a58a0db6c6c4c2314/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=fab365835639a3da03f8ad9a58a0db6c6c4c2314",
        "patch": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test transaction download behavior\n+\"\"\"\n+\n+from test_framework.messages import (\n+    CInv,\n+    CTransaction,\n+    FromHex,\n+    MSG_TX,\n+    MSG_TYPE_MASK,\n+    msg_inv,\n+    msg_notfound,\n+)\n+from test_framework.mininode import (\n+    P2PInterface,\n+    mininode_lock,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    wait_until,\n+)\n+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n+\n+import time\n+\n+\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.tx_getdata_count = 0\n+\n+    def on_getdata(self, message):\n+        for i in message.inv:\n+            if i.type & MSG_TYPE_MASK == MSG_TX:\n+                self.tx_getdata_count += 1\n+\n+\n+# Constants from net_processing\n+GETDATA_TX_INTERVAL = 60  # seconds\n+MAX_GETDATA_RANDOM_DELAY = 2  # seconds\n+INBOUND_PEER_TX_DELAY = 2  # seconds\n+MAX_GETDATA_IN_FLIGHT = 100\n+TX_EXPIRY_INTERVAL = GETDATA_TX_INTERVAL * 10\n+\n+# Python test constants\n+NUM_INBOUND = 10\n+MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY\n+\n+\n+class TxDownloadTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = False\n+        self.num_nodes = 2\n+\n+    def test_tx_requests(self):\n+        self.log.info(\"Test that we request transactions from all our peers, eventually\")\n+\n+        txid = 0xdeadbeef\n+\n+        self.log.info(\"Announce the txid from each incoming peer to node 0\")\n+        msg = msg_inv([CInv(t=1, h=txid)])\n+        for p in self.nodes[0].p2ps:\n+            p.send_message(msg)\n+            p.sync_with_ping()\n+\n+        outstanding_peer_index = [i for i in range(len(self.nodes[0].p2ps))]\n+\n+        def getdata_found(peer_index):\n+            p = self.nodes[0].p2ps[peer_index]\n+            with mininode_lock:\n+                return p.last_message.get(\"getdata\") and p.last_message[\"getdata\"].inv[-1].hash == txid\n+\n+        node_0_mocktime = int(time.time())\n+        while outstanding_peer_index:\n+            node_0_mocktime += MAX_GETDATA_INBOUND_WAIT\n+            self.nodes[0].setmocktime(node_0_mocktime)\n+            wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))\n+            for i in outstanding_peer_index:\n+                if getdata_found(i):\n+                    outstanding_peer_index.remove(i)\n+\n+        self.nodes[0].setmocktime(0)\n+        self.log.info(\"All outstanding peers received a getdata\")\n+\n+    def test_inv_block(self):\n+        self.log.info(\"Generate a transaction on node 0\")\n+        tx = self.nodes[0].createrawtransaction(\n+            inputs=[{  # coinbase\n+                \"txid\": self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0],\n+                \"vout\": 0\n+            }],\n+            outputs={ADDRESS_BCRT1_UNSPENDABLE: 50 - 0.00025},\n+        )\n+        tx = self.nodes[0].signrawtransactionwithkey(\n+            hexstring=tx,\n+            privkeys=[self.nodes[0].get_deterministic_priv_key().key],\n+        )['hex']\n+        ctx = FromHex(CTransaction(), tx)\n+        txid = int(ctx.rehash(), 16)\n+\n+        self.log.info(\n+            \"Announce the transaction to all nodes from all {} incoming peers, but never send it\".format(NUM_INBOUND))\n+        msg = msg_inv([CInv(t=1, h=txid)])\n+        for p in self.peers:\n+            p.send_message(msg)\n+            p.sync_with_ping()\n+\n+        self.log.info(\"Put the tx in node 0's mempool\")\n+        self.nodes[0].sendrawtransaction(tx)\n+\n+        # Since node 1 is connected outbound to an honest peer (node 0), it\n+        # should get the tx within a timeout. (Assuming that node 0\n+        # announced the tx within the timeout)\n+        # The timeout is the sum of\n+        # * the worst case until the tx is first requested from an inbound\n+        #   peer, plus\n+        # * the first time it is re-requested from the outbound peer, plus\n+        # * 2 seconds to avoid races\n+        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n+            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n+        self.sync_mempools(timeout=timeout)\n+\n+    def test_in_flight_max(self):\n+        self.log.info(\"Test that we don't request more than {} transactions from any peer, every {} minutes\".format(\n+            MAX_GETDATA_IN_FLIGHT, TX_EXPIRY_INTERVAL / 60))\n+        txids = [i for i in range(MAX_GETDATA_IN_FLIGHT + 2)]\n+\n+        p = self.nodes[0].p2ps[0]\n+\n+        with mininode_lock:\n+            p.tx_getdata_count = 0\n+\n+        p.send_message(msg_inv([CInv(t=1, h=i) for i in txids]))\n+        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT, lock=mininode_lock)\n+        with mininode_lock:\n+            assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)\n+\n+        self.log.info(\"Now check that if we send a NOTFOUND for a transaction, we'll get one more request\")\n+        p.send_message(msg_notfound(vec=[CInv(t=1, h=txids[0])]))\n+        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10, lock=mininode_lock)\n+        with mininode_lock:\n+            assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT + 1)\n+\n+        WAIT_TIME = TX_EXPIRY_INTERVAL // 2 + TX_EXPIRY_INTERVAL\n+        self.log.info(\"if we wait about {} minutes, we should eventually get more requests\".format(WAIT_TIME / 60))\n+        self.nodes[0].setmocktime(int(time.time() + WAIT_TIME))\n+        wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)\n+        self.nodes[0].setmocktime(0)\n+\n+    def run_test(self):\n+        # Setup the p2p connections\n+        self.peers = []\n+        for node in self.nodes:\n+            for i in range(NUM_INBOUND):\n+                self.peers.append(node.add_p2p_connection(TestP2PConn()))\n+\n+        self.log.info(\"Nodes are setup with {} incoming connections each\".format(NUM_INBOUND))\n+\n+        # Test the in-flight max first, because we want no transactions in\n+        # flight ahead of this test.\n+        self.test_in_flight_max()\n+\n+        self.test_inv_block()\n+\n+        self.test_tx_requests()\n+\n+\n+if __name__ == '__main__':\n+    TxDownloadTest().main()"
      },
      {
        "sha": "034ef743d6f652498711054bd248ecb8e06652f3",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab365835639a3da03f8ad9a58a0db6c6c4c2314/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab365835639a3da03f8ad9a58a0db6c6c4c2314/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=fab365835639a3da03f8ad9a58a0db6c6c4c2314",
        "patch": "@@ -91,6 +91,7 @@\n     'wallet_labels.py',\n     'p2p_segwit.py',\n     'p2p_timeouts.py',\n+    'p2p_tx_download.py',\n     'wallet_dump.py',\n     'wallet_listtransactions.py',\n     # vv Tests less than 60s vv"
      }
    ]
  }
]