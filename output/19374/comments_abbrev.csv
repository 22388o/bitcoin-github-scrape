hebasto,2020-06-24 17:08:10,cc @sipa,https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-648947855,648947855,
DrahtBot,2020-06-24 23:50:59,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19364 (net processing: Move orphan reprocessing to a global by jnewbery)\n* #18044 (Use wtxid for transaction relay by sd",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-649133220,649133220,
naumenkogs,2020-06-25 08:23:28,"So, am I correct that we have this redundant `g_orphan_list`, and we can use the map instead?\nBut then the issue is that taking a random element from a map is expensive (asymptotically)?\n\nIf that's the case, I don't have strong opinion here. The code seems correct, but the trade-offs I don't know.",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-649362328,649362328,
hebasto,2020-06-25 13:19:57,"Updated 1263a647921a32d8675fc4f18d9c7a4bef12c6c9 -> 4286e3907d79199bc44e4cf6f1c45635339614e2 ([pr19374.01](https://github.com/hebasto/bitcoin/commits/pr19374.01) -> [pr19374.02](https://github.com/hebasto/bitcoin/commits/pr19374.02), [diff](https://github.com/hebasto/bitcoin/compare/pr19374.01..pr19374.02)):\n\n- implemented @sipa's [idea](https://github.com/bitcoin/bitcoin/pull/14626#discussion",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-649536293,649536293,
hebasto,2020-06-27 12:57:04,"Updated 4286e3907d79199bc44e4cf6f1c45635339614e2 -> 538a57f2fbf573d7a2ab3e7fb1a05650fd64d29b ([pr19374.02](https://github.com/hebasto/bitcoin/commits/pr19374.02) -> [pr19374.03](https://github.com/hebasto/bitcoin/commits/pr19374.03), [diff](https://github.com/hebasto/bitcoin/compare/pr19374.02..pr19374.03)):\n\n- addressed @vasild's [comment](https://github.com/bitcoin/bitcoin/pull/19374#discuss",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-650557986,650557986,
hebasto,2020-06-29 08:28:00,"Updated 538a57f2fbf573d7a2ab3e7fb1a05650fd64d29b -> d02fcd0d45f428f73bd1de8a7a411fd34216d2fc ([pr19374.03](https://github.com/hebasto/bitcoin/commits/pr19374.03) -> [pr19374.04](https://github.com/hebasto/bitcoin/commits/pr19374.04), [diff](https://github.com/hebasto/bitcoin/compare/pr19374.03..pr19374.04)):\n\n- implemented uncontroversial and robust erase from `std::unordered_map`",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-651012944,651012944,
jnewbery,2020-06-29 20:08:03,"I don't think the new random eviction logic leads to uniform independent events. See comment https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447219623.\n\nAn alternative way to do this, which I think would be closer to uniform, independent events would be to go back to using an ordered map, but key by salted-txid. When the 101st transaction needs to be added to the map, then evict the ",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-651332142,651332142,
vasild,2020-07-02 07:46:15,"@jnewbery that is an interesting observation!\n\nBackground\n---\n\nQuickly I thought that in the vector (before this PR) we insert at the end and remove a random element, whereas with the hash table (unordered_map, this PR) we insert at a random position and remove from the front, so it shouldn't make a difference. However, there is a catch!\n\nWith the hash table we insert at a random pos",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-652844721,652844721,
vasild,2020-07-02 08:46:46,"> we most often evict the transaction that has just been added ... Why?\n\nHere is some explanation - the chance of a transaction surviving\n* one eviction is `99/100 = 0.99`\n* two evictions is `99/100 * 99/100 = (99/100)^2 = 0.98`\n* 50 evictions is `(99/100)^50 = 0.6`\n* 400 evictions is `(99/100)^400 = 0.018`",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-652876093,652876093,
jnewbery,2020-07-02 14:45:43,"Thanks for the very detailed investigation @vasild !\n\n> > we most often evict the transaction that has just been added ... Why?\n\n> Here is some explanation - the chance of a transaction surviving\n\nRight. In current master, eviction is a negative binomial distribution with r=1 and p=1/101. Each eviction is an independent Bernoulli trial, and as you point out, the chance of survival decr",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-653049374,653049374,
ajtowns,2020-07-03 01:55:06,What's the motivation for this change? It seems like an awful lot of work to save what seems to be a single pointer per orphan transaction...,https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-653291423,653291423,
hebasto,2020-07-03 05:11:30,"> What's the motivation for this change? It seems like an awful lot of work to save what seems to be a single pointer per orphan transaction...\n\nTo achieve uniformity of transaction selection for its eviction from the orphan pool #14626 added the `g_orphan_list` global with supported code. The motivation for this PR is to achieve the same uniformity without the added in #14626 stuff.\nThe ini",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-653352228,653352228,
vasild,2020-07-03 09:16:59,"Just out of curiosity, here is the eviction distribution without https://github.com/bitcoin/bitcoin/pull/14626\n\n![master_revert14626](https://user-images.githubusercontent.com/266751/86453613-5f137280-bd1e-11ea-85e4-98142caace3d.png)\n\n<details>\n<summary>revert #14626 on top of master @ 7d9008f43 and add sampling</summary>\n\n```diff\ncommit 944e7a8a0 (HEAD -> master)\nParent: 5d1e3b8",https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-653444554,653444554,
sipa,2020-06-24 18:14:02,That's O(n) in the number of orphan transactions. I don't think that's acceptable.,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445081491,445081491,src/net_processing.cpp
hebasto,2020-06-24 18:34:29,Even with given `DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100` ?,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445092684,445092684,src/net_processing.cpp
hebasto,2020-06-24 20:24:17,"Benchmarked on the [custom](https://github.com/hebasto/bitcoin/tree/200624-bench) branch:\n\n- master\n```\n$ ./src/bench/bench_bitcoin -filter=""OrphanTxPool""\n# Benchmark, evals, iterations, total, min, max, median\nOrphanTxPool, 5, 10000, 2.42326, 4.83155e-05, 4.87947e-05, 4.83993e-0\n```\n\n- this PR\n```\n$ ./src/bench/bench_bitcoin -filter=""OrphanTxPool""\n# Benchmark, evals, itera",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445150293,445150293,src/net_processing.cpp
sipa,2020-06-24 22:15:42,"Thanks for providing actual numbers. I agree it's not so much of a concern in light of those - though I'm also not convinced it's worth the code simplification, especially if we'd ever want/need to increase the maximum number of orphans.",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445201797,445201797,src/net_processing.cpp
hebasto,2020-06-25 13:20:54,[Updated](https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-649536293).,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445552411,445552411,src/net_processing.cpp
vasild,2020-06-25 15:21:50,nit: `Uint256Hash` to abide to the naming convention.,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445640819,445640819,src/util/uint256hash.h
vasild,2020-06-25 15:29:18,"`IteratorComparator` compares the addresses of the elements in the container! With `std::unordered_map`, I guess, if rehashing occurs, those could change in an unpredictable way, confusing the `std::set` container. Maybe at some point the `std::set` could end up having element `A` before element `B` (two iterators to the `std::unordered_map`) but they now compare `A > B` (after a rehash).",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445646256,445646256,src/net_processing.cpp
jnewbery,2020-06-25 15:36:47,We already have one of these. It's called `SaltedTxidHasher` in txmempool.cpp. Feel free to take this commit that moves it to validation: https://github.com/jnewbery/bitcoin/commit/0ccd20536350ce0cbe9e453d50873a5bb6ca4d03 (not sure if there's a better home for it).,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445651273,445651273,src/util/uint256hash.h
vasild,2020-06-25 15:40:28,"There is a subtle difference between deleting elements from `std::map` and `std::unordered_map` while iterating on the container - with `std::unordered_map` the order of the elements may change. This is fixed in C++14: https://en.cppreference.com/w/cpp/container/unordered_map/erase\n> The  order of the elements that are not erased is preserved. (This makes it  possible to erase individual element",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445653632,445653632,src/net_processing.cpp
hebasto,2020-06-25 16:31:35,@jnewbery Thanks!,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445687904,445687904,src/util/uint256hash.h
MarcoFalke,2020-06-25 16:47:09,Probably best to move it to a new module to avoid re-introducing the net_processing<->validation circular dependency?,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445697374,445697374,src/util/uint256hash.h
jnewbery,2020-06-25 17:55:17,Net processing already includes validation.h,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445736795,445736795,src/util/uint256hash.h
vasild,2020-06-26 11:14:55,"This can be overcome by changing the `std::set` to `std::unordered_set`, removing the bizarre ""order by address"" `IteratorComparator` and hashing by the tx id. I checked that nowhere in the code we rely on the order of the elements in the `std::set` (as expected, because they are ordered by their address, which is ""random"" or unpredictable to the application). Something like this:\n\n<details>\",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446121515,446121515,src/net_processing.cpp
vasild,2020-06-26 12:05:50,"Actually, there is a bigger problem which the above patch would not solve - all iterators to `mapOrphanTransactions` might be invalidated by an insertion to it:\n\nhttps://github.com/bitcoin/bitcoin/blob/4286e3907d79199bc44e4cf6f1c45635339614e2/src/net_processing.cpp#L924\n\nI.e. the above line might invalidate all iterators to `mapOrphanTransactions` that are stored in `mapOrphanTransactionsB",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446142983,446142983,src/net_processing.cpp
hebasto,2020-06-27 12:59:11,[Switched](https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-650557986) to `SaltedTxidHasher` as [suggested](https://github.com/bitcoin/bitcoin/pull/19374#discussion_r445651273) by @jnewbery.,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446524394,446524394,src/util/uint256hash.h
hebasto,2020-06-27 12:59:40,[Updated](https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-650557986).,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446524436,446524436,src/net_processing.cpp
hebasto,2020-06-27 13:00:07,[Updated](https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-650557986).,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446524482,446524482,src/util/uint256hash.h
hebasto,2020-06-27 13:09:06,"@vasild and me have discussed this concern on IRC. I think as _""Other iterators ... are not invalidated.""_ it does not matter whether the internal element order is changed while iterating over `std::unordered_map`.\n\nMaybe our C++ connoisseurs could add their opinions here?",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446525223,446525223,src/net_processing.cpp
ajtowns,2020-06-29 07:09:01,"If you have an valid iterator without order being preserved, I think you could have:\n\n1. implicit ordering = A, B, C, D, E ; iterator X points at A\n2. X++; X points at B\n3. X++; X points at C\n4. delete B\n5. new implicit ordering = E D C A ; iterator X still points at C\n6. X++; now points at A, which was already seen\n7. X++; now points at end() and we never saw E\n\nhttps://stacko",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446815337,446815337,src/net_processing.cpp
hebasto,2020-06-29 08:28:24,[Updated](https://github.com/bitcoin/bitcoin/pull/19374#issuecomment-651012944).,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r446857079,446857079,src/net_processing.cpp
jnewbery,2020-06-29 19:22:43,"It feels a little scary that we're adding references to a uint256 where the lifetime of that object is only as long as the transaction exists in the mapOrphanTransactions. The logic looks fine (and is the same as the existing logic where we're storing iterators which are only valid as long as the tx exists in mapOrphanTransactions), but it feels slightly dangerous.",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447199201,447199201,src/net_processing.cpp
jnewbery,2020-06-29 19:46:24,why not make this a vector of `uint256`s?,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447211795,447211795,src/net_processing.cpp
jnewbery,2020-06-29 19:55:22,"Since `SaltedTxidHasher` is no longer just used by the mempool, it should be moved out of txmempool.cpp. Maybe validation.cpp or primitives/transaction.cpp?",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447216637,447216637,src/net_processing.cpp
jnewbery,2020-06-29 20:01:01,"I think this will exhibit different qualities from the current eviction logic. Currently, each eviction is an independent event, where every element has a 1/101 chance of being evicted. The new logic has dependent events. If a tx hashes to a bucket towards the end of the unordered_map, then it's unlikely to be evicted in any of these events, or put another way, if it doesn't get evicted in one rou",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447219623,447219623,src/net_processing.cpp
vasild,2020-06-30 10:41:00,"> the lifetime of that object is only as long as the transaction exists in the mapOrphanTransactions\n\nI think that is incorrect. The `hash` reference that we insert into `mapOrphanTransactionsByPrev` is created here:\n\nhttps://github.com/bitcoin/bitcoin/blob/d02fcd0d45f428f73bd1de8a7a411fd34216d2fc/src/net_processing.cpp#L897\n\nand the `GetHash()` method returns a reference to its `CTran",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447587078,447587078,src/net_processing.cpp
vasild,2020-06-30 10:44:22,... and maybe renamed because it is hashing `uint256` which is broader than `Txid`?,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447588886,447588886,src/net_processing.cpp
hebasto,2020-06-30 16:09:44,Something like 2ba96b0438fe734b788e56ba881303c84a3f249d from (#16910) ?,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447803998,447803998,src/net_processing.cpp
jnewbery,2020-06-30 16:38:54,"> the reference is valid as long as the CTransaction object is valid\n\nRight, and I believe that for an orphan transaction, the only shared_ptr to the CTransaction is held in mapOrphanTransactions. As soon as it gets removed from that map, then the CTransaction will be destructed and the uint256& will be dangling.\n\n> Saving uint256 instead of uint256& looks more robust, also considering pos",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447825820,447825820,src/net_processing.cpp
jnewbery,2020-06-30 16:39:41,Indeed. Just like that!,https://github.com/bitcoin/bitcoin/pull/19374#discussion_r447826309,447826309,src/net_processing.cpp
hebasto,2020-07-02 16:18:09,"> As soon as it gets removed from that map, then the CTransaction will be destructed and the uint256& will be dangling.\n\nIn `EraseOrphanTx()` a transaction is erased from `mapOrphanTransactions` only after its inputs have been erased from `mapOrphanTransactionsByPrev()`.\n\nSo, no dangling `uint256&` are expected.",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r449129171,449129171,src/net_processing.cpp
hebasto,2020-07-02 16:49:08,"> why not make this a vector of `uint256`s?\n\n`std::vector<OrphanTxPool::iterator>`  is more effective (both time and memory), I think.",https://github.com/bitcoin/bitcoin/pull/19374#discussion_r449146878,449146878,src/net_processing.cpp
