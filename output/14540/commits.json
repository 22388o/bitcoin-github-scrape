[
  {
    "sha": "5e6d1724bb865b8c3519ab35628002dac75251fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTZkMTcyNGJiODY1YjhjMzUxOWFiMzU2MjgwMDJkYWM3NTI1MWZi",
    "commit": {
      "author": {
        "name": "John Bampton",
        "email": "jbampton@users.noreply.github.com",
        "date": "2018-10-21T22:31:32Z"
      },
      "committer": {
        "name": "John Bampton",
        "email": "jbampton@users.noreply.github.com",
        "date": "2018-10-21T22:31:32Z"
      },
      "message": "Enable flake8 rule E231.\n\nChecks for missing whitespace after \u2018,\u2019, \u2018;\u2019, or \u2018:\u2019",
      "tree": {
        "sha": "830b3371a3eac0dae882ebf57aa5d9c16cc08a9e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/830b3371a3eac0dae882ebf57aa5d9c16cc08a9e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e6d1724bb865b8c3519ab35628002dac75251fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e6d1724bb865b8c3519ab35628002dac75251fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e6d1724bb865b8c3519ab35628002dac75251fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e6d1724bb865b8c3519ab35628002dac75251fb/comments",
    "author": {
      "login": "jbampton",
      "id": 418747,
      "node_id": "MDQ6VXNlcjQxODc0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/418747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbampton",
      "html_url": "https://github.com/jbampton",
      "followers_url": "https://api.github.com/users/jbampton/followers",
      "following_url": "https://api.github.com/users/jbampton/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbampton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbampton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbampton/subscriptions",
      "organizations_url": "https://api.github.com/users/jbampton/orgs",
      "repos_url": "https://api.github.com/users/jbampton/repos",
      "events_url": "https://api.github.com/users/jbampton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbampton/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jbampton",
      "id": 418747,
      "node_id": "MDQ6VXNlcjQxODc0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/418747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbampton",
      "html_url": "https://github.com/jbampton",
      "followers_url": "https://api.github.com/users/jbampton/followers",
      "following_url": "https://api.github.com/users/jbampton/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbampton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbampton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbampton/subscriptions",
      "organizations_url": "https://api.github.com/users/jbampton/orgs",
      "repos_url": "https://api.github.com/users/jbampton/repos",
      "events_url": "https://api.github.com/users/jbampton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbampton/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5c25409d6851182c5e351720cee36812c229b77a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c25409d6851182c5e351720cee36812c229b77a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5c25409d6851182c5e351720cee36812c229b77a"
      }
    ],
    "stats": {
      "total": 443,
      "additions": 222,
      "deletions": 221
    },
    "files": [
      {
        "sha": "685e48b9d8218aeef4777b2d131452661d3bc922",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 60,
        "deletions": 60,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -14,23 +14,23 @@\n \n # In case of a clean merge that is accepted by the user, the local branch with\n # name $BRANCH is overwritten with the merged result, and optionally pushed.\n-from __future__ import division,print_function,unicode_literals\n+from __future__ import division, print_function, unicode_literals\n import os\n-from sys import stdin,stdout,stderr\n+from sys import stdin, stdout, stderr\n import argparse\n import hashlib\n import subprocess\n import sys\n import json\n import codecs\n try:\n-    from urllib.request import Request,urlopen\n+    from urllib.request import Request, urlopen\n except:\n-    from urllib2 import Request,urlopen\n+    from urllib2 import Request, urlopen\n \n # External tools (can be overridden using environment)\n-GIT = os.getenv('GIT','git')\n-BASH = os.getenv('BASH','bash')\n+GIT = os.getenv('GIT', 'git')\n+BASH = os.getenv('BASH', 'bash')\n \n # OS specific configuration for terminal attributes\n ATTR_RESET = ''\n@@ -46,11 +46,11 @@ def git_config_get(option, default=None):\n     Get named configuration option from git repository.\n     '''\n     try:\n-        return subprocess.check_output([GIT,'config','--get',option]).rstrip().decode('utf-8')\n+        return subprocess.check_output([GIT, 'config', '--get', option]).rstrip().decode('utf-8')\n     except subprocess.CalledProcessError:\n         return default\n \n-def retrieve_pr_info(repo,pull):\n+def retrieve_pr_info(repo, pull):\n     '''\n     Retrieve pull request information from github.\n     Return None if no title can be found, or an error happens.\n@@ -66,10 +66,10 @@ def retrieve_pr_info(repo,pull):\n         return None\n \n def ask_prompt(text):\n-    print(text,end=\" \",file=stderr)\n+    print(text, end=\" \", file=stderr)\n     stderr.flush()\n     reply = stdin.readline().rstrip()\n-    print(\"\",file=stderr)\n+    print(\"\", file=stderr)\n     return reply\n \n def get_symlink_files():\n@@ -130,8 +130,8 @@ def tree_sha512sum(commit='HEAD'):\n     return overall.hexdigest()\n \n def print_merge_details(pull, title, branch, base_branch, head_branch):\n-    print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n-    subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n+    print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR, pull, ATTR_RESET, title, ATTR_RESET+ATTR_PR, branch, ATTR_RESET))\n+    subprocess.check_call([GIT, 'log', '--graph', '--topo-order', '--pretty=format:'+COMMIT_FORMAT, base_branch+'..'+head_branch])\n \n def parse_arguments():\n     epilog = '''\n@@ -153,17 +153,17 @@ def parse_arguments():\n def main():\n     # Extract settings from git repo\n     repo = git_config_get('githubmerge.repository')\n-    host = git_config_get('githubmerge.host','git@github.com')\n-    opt_branch = git_config_get('githubmerge.branch',None)\n+    host = git_config_get('githubmerge.host', 'git@github.com')\n+    opt_branch = git_config_get('githubmerge.branch', None)\n     testcmd = git_config_get('githubmerge.testcmd')\n     signingkey = git_config_get('user.signingkey')\n     if repo is None:\n         print(\"ERROR: No repository configured. Use this command to set:\", file=stderr)\n         print(\"git config githubmerge.repository <owner>/<repo>\", file=stderr)\n         sys.exit(1)\n     if signingkey is None:\n-        print(\"ERROR: No GPG signing key set. Set one using:\",file=stderr)\n-        print(\"git config --global user.signingkey <key>\",file=stderr)\n+        print(\"ERROR: No GPG signing key set. Set one using:\", file=stderr)\n+        print(\"git config --global user.signingkey <key>\", file=stderr)\n         sys.exit(1)\n \n     host_repo = host+\":\"+repo # shortcut for push/pull target\n@@ -173,7 +173,7 @@ def main():\n     pull = str(args.pull[0])\n \n     # Receive pull information from github\n-    info = retrieve_pr_info(repo,pull)\n+    info = retrieve_pr_info(repo, pull)\n     if info is None:\n         sys.exit(1)\n     title = info['title'].strip()\n@@ -193,51 +193,51 @@ def main():\n \n     devnull = open(os.devnull, 'w', encoding=\"utf8\")\n     try:\n-        subprocess.check_call([GIT,'checkout','-q',branch])\n+        subprocess.check_call([GIT, 'checkout', '-q', branch])\n     except subprocess.CalledProcessError:\n         print(\"ERROR: Cannot check out branch %s.\" % (branch), file=stderr)\n         sys.exit(3)\n     try:\n-        subprocess.check_call([GIT,'fetch','-q',host_repo,'+refs/pull/'+pull+'/*:refs/heads/pull/'+pull+'/*',\n+        subprocess.check_call([GIT, 'fetch', '-q', host_repo, '+refs/pull/'+pull+'/*:refs/heads/pull/'+pull+'/*',\n                                                           '+refs/heads/'+branch+':refs/heads/'+base_branch])\n     except subprocess.CalledProcessError:\n-        print(\"ERROR: Cannot find pull request #%s or branch %s on %s.\" % (pull,branch,host_repo), file=stderr)\n+        print(\"ERROR: Cannot find pull request #%s or branch %s on %s.\" % (pull, branch, host_repo), file=stderr)\n         sys.exit(3)\n     try:\n-        subprocess.check_call([GIT,'log','-q','-1','refs/heads/'+head_branch], stdout=devnull, stderr=stdout)\n+        subprocess.check_call([GIT, 'log', '-q', '-1', 'refs/heads/'+head_branch], stdout=devnull, stderr=stdout)\n     except subprocess.CalledProcessError:\n-        print(\"ERROR: Cannot find head of pull request #%s on %s.\" % (pull,host_repo), file=stderr)\n+        print(\"ERROR: Cannot find head of pull request #%s on %s.\" % (pull, host_repo), file=stderr)\n         sys.exit(3)\n     try:\n-        subprocess.check_call([GIT,'log','-q','-1','refs/heads/'+merge_branch], stdout=devnull, stderr=stdout)\n+        subprocess.check_call([GIT, 'log', '-q', '-1', 'refs/heads/'+merge_branch], stdout=devnull, stderr=stdout)\n     except subprocess.CalledProcessError:\n-        print(\"ERROR: Cannot find merge of pull request #%s on %s.\" % (pull,host_repo), file=stderr)\n+        print(\"ERROR: Cannot find merge of pull request #%s on %s.\" % (pull, host_repo), file=stderr)\n         sys.exit(3)\n-    subprocess.check_call([GIT,'checkout','-q',base_branch])\n-    subprocess.call([GIT,'branch','-q','-D',local_merge_branch], stderr=devnull)\n-    subprocess.check_call([GIT,'checkout','-q','-b',local_merge_branch])\n+    subprocess.check_call([GIT, 'checkout', '-q', base_branch])\n+    subprocess.call([GIT, 'branch', '-q', '-D', local_merge_branch], stderr=devnull)\n+    subprocess.check_call([GIT, 'checkout', '-q', '-b', local_merge_branch])\n \n     try:\n         # Go up to the repository's root.\n-        toplevel = subprocess.check_output([GIT,'rev-parse','--show-toplevel']).strip()\n+        toplevel = subprocess.check_output([GIT, 'rev-parse', '--show-toplevel']).strip()\n         os.chdir(toplevel)\n         # Create unsigned merge commit.\n         if title:\n-            firstline = 'Merge #%s: %s' % (pull,title)\n+            firstline = 'Merge #%s: %s' % (pull, title)\n         else:\n             firstline = 'Merge #%s' % (pull,)\n         message = firstline + '\\n\\n'\n-        message += subprocess.check_output([GIT,'log','--no-merges','--topo-order','--pretty=format:%h %s (%an)',base_branch+'..'+head_branch]).decode('utf-8')\n+        message += subprocess.check_output([GIT, 'log', '--no-merges', '--topo-order', '--pretty=format:%h %s (%an)', base_branch+'..'+head_branch]).decode('utf-8')\n         message += '\\n\\nPull request description:\\n\\n  ' + body.replace('\\n', '\\n  ') + '\\n'\n         try:\n-            subprocess.check_call([GIT,'merge','-q','--commit','--no-edit','--no-ff','-m',message.encode('utf-8'),head_branch])\n+            subprocess.check_call([GIT, 'merge', '-q', '--commit', '--no-edit', '--no-ff', '-m', message.encode('utf-8'), head_branch])\n         except subprocess.CalledProcessError:\n-            print(\"ERROR: Cannot be merged cleanly.\",file=stderr)\n-            subprocess.check_call([GIT,'merge','--abort'])\n+            print(\"ERROR: Cannot be merged cleanly.\", file=stderr)\n+            subprocess.check_call([GIT, 'merge', '--abort'])\n             sys.exit(4)\n-        logmsg = subprocess.check_output([GIT,'log','--pretty=format:%s','-n','1']).decode('utf-8')\n+        logmsg = subprocess.check_output([GIT, 'log', '--pretty=format:%s', '-n', '1']).decode('utf-8')\n         if logmsg.rstrip() != firstline.rstrip():\n-            print(\"ERROR: Creating merge failed (already merged?).\",file=stderr)\n+            print(\"ERROR: Creating merge failed (already merged?).\", file=stderr)\n             sys.exit(4)\n \n         symlink_files = get_symlink_files()\n@@ -254,7 +254,7 @@ def main():\n             print(\"ERROR: Unable to compute tree hash\")\n             sys.exit(4)\n         try:\n-            subprocess.check_call([GIT,'commit','--amend','-m',message.encode('utf-8')])\n+            subprocess.check_call([GIT, 'commit', '--amend', '-m', message.encode('utf-8')])\n         except subprocess.CalledProcessError:\n             print(\"ERROR: Cannot update message.\", file=stderr)\n             sys.exit(4)\n@@ -264,32 +264,32 @@ def main():\n \n         # Run test command if configured.\n         if testcmd:\n-            if subprocess.call(testcmd,shell=True):\n-                print(\"ERROR: Running %s failed.\" % testcmd,file=stderr)\n+            if subprocess.call(testcmd, shell=True):\n+                print(\"ERROR: Running %s failed.\" % testcmd, file=stderr)\n                 sys.exit(5)\n \n             # Show the created merge.\n-            diff = subprocess.check_output([GIT,'diff',merge_branch+'..'+local_merge_branch])\n-            subprocess.check_call([GIT,'diff',base_branch+'..'+local_merge_branch])\n+            diff = subprocess.check_output([GIT, 'diff', merge_branch+'..'+local_merge_branch])\n+            subprocess.check_call([GIT, 'diff', base_branch+'..'+local_merge_branch])\n             if diff:\n-                print(\"WARNING: merge differs from github!\",file=stderr)\n+                print(\"WARNING: merge differs from github!\", file=stderr)\n                 reply = ask_prompt(\"Type 'ignore' to continue.\")\n                 if reply.lower() == 'ignore':\n-                    print(\"Difference with github ignored.\",file=stderr)\n+                    print(\"Difference with github ignored.\", file=stderr)\n                 else:\n                     sys.exit(6)\n         else:\n             # Verify the result manually.\n-            print(\"Dropping you on a shell so you can try building/testing the merged source.\",file=stderr)\n-            print(\"Run 'git diff HEAD~' to show the changes being merged.\",file=stderr)\n-            print(\"Type 'exit' when done.\",file=stderr)\n+            print(\"Dropping you on a shell so you can try building/testing the merged source.\", file=stderr)\n+            print(\"Run 'git diff HEAD~' to show the changes being merged.\", file=stderr)\n+            print(\"Type 'exit' when done.\", file=stderr)\n             if os.path.isfile('/etc/debian_version'): # Show pull number on Debian default prompt\n-                os.putenv('debian_chroot',pull)\n-            subprocess.call([BASH,'-i'])\n+                os.putenv('debian_chroot', pull)\n+            subprocess.call([BASH, '-i'])\n \n         second_sha512 = tree_sha512sum()\n         if first_sha512 != second_sha512:\n-            print(\"ERROR: Tree hash changed unexpectedly\",file=stderr)\n+            print(\"ERROR: Tree hash changed unexpectedly\", file=stderr)\n             sys.exit(8)\n \n         # Sign the merge commit.\n@@ -298,30 +298,30 @@ def main():\n             reply = ask_prompt(\"Type 's' to sign off on the above merge, or 'x' to reject and exit.\").lower()\n             if reply == 's':\n                 try:\n-                    subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n+                    subprocess.check_call([GIT, 'commit', '-q', '--gpg-sign', '--amend', '--no-edit'])\n                     break\n                 except subprocess.CalledProcessError:\n-                    print(\"Error while signing, asking again.\",file=stderr)\n+                    print(\"Error while signing, asking again.\", file=stderr)\n             elif reply == 'x':\n-                print(\"Not signing off on merge, exiting.\",file=stderr)\n+                print(\"Not signing off on merge, exiting.\", file=stderr)\n                 sys.exit(1)\n \n         # Put the result in branch.\n-        subprocess.check_call([GIT,'checkout','-q',branch])\n-        subprocess.check_call([GIT,'reset','-q','--hard',local_merge_branch])\n+        subprocess.check_call([GIT, 'checkout', '-q', branch])\n+        subprocess.check_call([GIT, 'reset', '-q', '--hard', local_merge_branch])\n     finally:\n         # Clean up temporary branches.\n-        subprocess.call([GIT,'checkout','-q',branch])\n-        subprocess.call([GIT,'branch','-q','-D',head_branch],stderr=devnull)\n-        subprocess.call([GIT,'branch','-q','-D',base_branch],stderr=devnull)\n-        subprocess.call([GIT,'branch','-q','-D',merge_branch],stderr=devnull)\n-        subprocess.call([GIT,'branch','-q','-D',local_merge_branch],stderr=devnull)\n+        subprocess.call([GIT, 'checkout', '-q', branch])\n+        subprocess.call([GIT, 'branch', '-q', '-D', head_branch], stderr=devnull)\n+        subprocess.call([GIT, 'branch', '-q', '-D', base_branch], stderr=devnull)\n+        subprocess.call([GIT, 'branch', '-q', '-D', merge_branch], stderr=devnull)\n+        subprocess.call([GIT, 'branch', '-q', '-D', local_merge_branch], stderr=devnull)\n \n     # Push the result.\n     while True:\n-        reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s, or 'x' to exit without pushing.\" % (host_repo,branch)).lower()\n+        reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s, or 'x' to exit without pushing.\" % (host_repo, branch)).lower()\n         if reply == 'push':\n-            subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+            subprocess.check_call([GIT, 'push', host_repo, 'refs/heads/'+branch])\n             break\n         elif reply == 'x':\n             sys.exit(1)"
      },
      {
        "sha": "e1f0edd75f0b85bb405885e7e09e0a76acb9c073",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -132,24 +132,24 @@ def get_PE_dll_characteristics(executable):\n         if len(tokens)>=2 and tokens[0] == 'architecture:':\n             arch = tokens[1].rstrip(',')\n         if len(tokens)>=2 and tokens[0] == 'DllCharacteristics':\n-            bits = int(tokens[1],16)\n-    return (arch,bits)\n+            bits = int(tokens[1], 16)\n+    return (arch, bits)\n \n IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA = 0x0020\n IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE    = 0x0040\n IMAGE_DLL_CHARACTERISTICS_NX_COMPAT       = 0x0100\n \n def check_PE_DYNAMIC_BASE(executable):\n     '''PIE: DllCharacteristics bit 0x40 signifies dynamicbase (ASLR)'''\n-    (arch,bits) = get_PE_dll_characteristics(executable)\n+    (arch, bits) = get_PE_dll_characteristics(executable)\n     reqbits = IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE\n     return (bits & reqbits) == reqbits\n \n # On 64 bit, must support high-entropy 64-bit address space layout randomization in addition to DYNAMIC_BASE\n # to have secure ASLR.\n def check_PE_HIGH_ENTROPY_VA(executable):\n     '''PIE: DllCharacteristics bit 0x20 signifies high-entropy ASLR'''\n-    (arch,bits) = get_PE_dll_characteristics(executable)\n+    (arch, bits) = get_PE_dll_characteristics(executable)\n     if arch == 'i386:x86-64':\n         reqbits = IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA\n     else: # Unnecessary on 32-bit\n@@ -159,7 +159,7 @@ def check_PE_HIGH_ENTROPY_VA(executable):\n \n def check_PE_NX(executable):\n     '''NX: DllCharacteristics bit 0x100 signifies nxcompat (DEP)'''\n-    (arch,bits) = get_PE_dll_characteristics(executable)\n+    (arch, bits) = get_PE_dll_characteristics(executable)\n     return (bits & IMAGE_DLL_CHARACTERISTICS_NX_COMPAT) == IMAGE_DLL_CHARACTERISTICS_NX_COMPAT\n \n CHECKS = {"
      },
      {
        "sha": "cbb33dc59c32e9397113bdcfe2e62c7aa3648db4",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -36,11 +36,11 @@\n #   (glibc)    GLIBC_2_11\n #\n MAX_VERSIONS = {\n-'GCC':       (4,4,0),\n-'CXXABI':    (1,3,3),\n-'GLIBCXX':   (3,4,13),\n-'GLIBC':     (2,11),\n-'LIBATOMIC': (1,0)\n+'GCC':       (4, 4, 0),\n+'CXXABI':    (1, 3, 3),\n+'GLIBCXX':   (3, 4, 13),\n+'GLIBC':     (2, 11),\n+'LIBATOMIC': (1, 0)\n }\n # See here for a description of _IO_stdin_used:\n # https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634261#109\n@@ -75,11 +75,11 @@\n 'libdl.so.2' # programming interface to dynamic linker\n }\n ARCH_MIN_GLIBC_VER = {\n-'80386':  (2,1),\n-'X86-64': (2,2,5),\n-'ARM':    (2,4),\n-'AArch64':(2,17),\n-'RISC-V': (2,27)\n+'80386':  (2, 1),\n+'X86-64': (2, 2, 5),\n+'ARM':    (2, 4),\n+'AArch64': (2, 17),\n+'RISC-V': (2, 27)\n }\n class CPPFilt(object):\n     '''\n@@ -155,13 +155,13 @@ def read_libraries(filename):\n     retval = 0\n     for filename in sys.argv[1:]:\n         # Check imported symbols\n-        for sym,version,arch in read_symbols(filename, True):\n+        for sym, version, arch in read_symbols(filename, True):\n             if version and not check_version(MAX_VERSIONS, version, arch):\n                 print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym), version))\n                 retval = 1\n         # Check exported symbols\n         if arch != 'RISC-V':\n-            for sym,version,arch in read_symbols(filename, False):\n+            for sym, version, arch in read_symbols(filename, False):\n                 if sym in IGNORE_EXPORTS:\n                     continue\n                 print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym)))"
      },
      {
        "sha": "ef75481db1ba6c9eb54e84e7eeca0218c40933ff",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -20,8 +20,8 @@ def write_testcode(filename):\n     ''')\n \n def call_security_check(cc, source, executable, options):\n-    subprocess.check_call([cc,source,'-o',executable] + options)\n-    p = subprocess.Popen(['./security-check.py',executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n+    subprocess.check_call([cc, source, '-o', executable] + options)\n+    p = subprocess.Popen(['./security-check.py', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     return (p.returncode, stdout.rstrip())\n \n@@ -32,15 +32,15 @@ def test_ELF(self):\n         cc = 'gcc'\n         write_testcode(source)\n \n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-zexecstack','-fno-stack-protector','-Wl,-znorelro','-no-pie','-fno-PIE']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-zexecstack', '-fno-stack-protector', '-Wl,-znorelro', '-no-pie', '-fno-PIE']),\n                 (1, executable+': failed PIE NX RELRO Canary'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fno-stack-protector','-Wl,-znorelro','-no-pie','-fno-PIE']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack', '-fno-stack-protector', '-Wl,-znorelro', '-no-pie', '-fno-PIE']),\n                 (1, executable+': failed PIE RELRO Canary'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-znorelro','-no-pie','-fno-PIE']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack', '-fstack-protector-all', '-Wl,-znorelro', '-no-pie', '-fno-PIE']),\n                 (1, executable+': failed PIE RELRO'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-znorelro','-pie','-fPIE']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack', '-fstack-protector-all', '-Wl,-znorelro', '-pie', '-fPIE']),\n                 (1, executable+': failed RELRO'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-zrelro','-Wl,-z,now','-pie','-fPIE']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack', '-fstack-protector-all', '-Wl,-zrelro', '-Wl,-z,now', '-pie', '-fPIE']),\n                 (0, ''))\n \n     def test_32bit_PE(self):\n@@ -49,22 +49,22 @@ def test_32bit_PE(self):\n         cc = 'i686-w64-mingw32-gcc'\n         write_testcode(source)\n \n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--no-nxcompat','-Wl,--no-dynamicbase']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--no-nxcompat', '-Wl,--no-dynamicbase']),\n                 (1, executable+': failed DYNAMIC_BASE NX'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--no-dynamicbase']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat', '-Wl,--no-dynamicbase']),\n                 (1, executable+': failed DYNAMIC_BASE'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase']),\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat', '-Wl,--dynamicbase']),\n                 (0, ''))\n     def test_64bit_PE(self):\n         source = 'test1.c'\n         executable = 'test1.exe'\n         cc = 'x86_64-w64-mingw32-gcc'\n         write_testcode(source)\n \n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--no-nxcompat','-Wl,--no-dynamicbase','-Wl,--no-high-entropy-va']), (1, executable+': failed DYNAMIC_BASE HIGH_ENTROPY_VA NX'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--no-dynamicbase','-Wl,--no-high-entropy-va']), (1, executable+': failed DYNAMIC_BASE HIGH_ENTROPY_VA'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase','-Wl,--no-high-entropy-va']), (1, executable+': failed HIGH_ENTROPY_VA'))\n-        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase','-Wl,--high-entropy-va']), (0, ''))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--no-nxcompat', '-Wl,--no-dynamicbase', '-Wl,--no-high-entropy-va']), (1, executable+': failed DYNAMIC_BASE HIGH_ENTROPY_VA NX'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat', '-Wl,--no-dynamicbase', '-Wl,--no-high-entropy-va']), (1, executable+': failed DYNAMIC_BASE HIGH_ENTROPY_VA'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat', '-Wl,--dynamicbase', '-Wl,--no-high-entropy-va']), (1, executable+': failed HIGH_ENTROPY_VA'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat', '-Wl,--dynamicbase', '-Wl,--high-entropy-va']), (0, ''))\n \n if __name__ == '__main__':\n     unittest.main()"
      },
      {
        "sha": "66e9df8b57365fcd73504105be609e79da039806",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -61,7 +61,7 @@ def split_format_specifiers(specifiers):\n     numeric = []\n     other = []\n     for s in specifiers:\n-        if s in {'1','2','3','4','5','6','7','8','9'}:\n+        if s in {'1', '2', '3', '4', '5', '6', '7', '8', '9'}:\n             numeric.append(s)\n         else:\n             other.append(s)\n@@ -75,11 +75,11 @@ def split_format_specifiers(specifiers):\n         other = []\n \n     # numeric (Qt) can be present in any order, others (strprintf) must be in specified order\n-    return set(numeric),other\n+    return set(numeric), other\n \n def sanitize_string(s):\n     '''Sanitize string for printing'''\n-    return s.replace('\\n',' ')\n+    return s.replace('\\n', ' ')\n \n def check_format_specifiers(source, translation, errors, numerus):\n     source_f = split_format_specifiers(find_format_specifiers(source))\n@@ -138,11 +138,11 @@ def postprocess_translations(reduce_diff_hacks=False):\n         _orig_escape_cdata = ET._escape_cdata\n         ET._escape_cdata = escape_cdata\n \n-    for (filename,filepath) in all_ts_files():\n+    for (filename, filepath) in all_ts_files():\n         os.rename(filepath, filepath+'.orig')\n \n     have_errors = False\n-    for (filename,filepath) in all_ts_files('.orig'):\n+    for (filename, filepath) in all_ts_files('.orig'):\n         # pre-fixups to cope with transifex output\n         parser = ET.XMLParser(encoding='utf-8') # need to override encoding because 'utf8' is not understood only 'utf-8'\n         with open(filepath + '.orig', 'rb') as f:"
      },
      {
        "sha": "f5d1795f3e732c1125997b8eed7888c7f835f888",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -89,7 +89,7 @@ def get_block_hashes(settings):\n # The block map shouldn't give or receive byte-reversed hashes.\n def mkblockmap(blkindex):\n     blkmap = {}\n-    for height,hash in enumerate(blkindex):\n+    for height, hash in enumerate(blkindex):\n         blkmap[hash] = height\n     return blkmap\n "
      },
      {
        "sha": "4914a40a246f07b9736e6e245c7042fed7f6a3a5",
        "filename": "contrib/linearize/linearize-hashes.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/linearize/linearize-hashes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/linearize/linearize-hashes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-hashes.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -83,7 +83,7 @@ def get_block_hashes(settings, max_blocks_per_call=10000):\n             print('Cannot continue. Program will halt.')\n             return None\n \n-        for x,resp_obj in enumerate(reply):\n+        for x, resp_obj in enumerate(reply):\n             if rpc.response_is_error(resp_obj):\n                 print('JSON-RPC: error at height', height+x, ': ', resp_obj['error'], file=sys.stderr)\n                 sys.exit(1)"
      },
      {
        "sha": "e01d61a1a58668ea19224192735fe295b0bbcbb3",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -282,7 +282,7 @@ def copyFramework(framework, path, verbose):\n \n     if not framework.isDylib(): # Copy resources for real frameworks\n \n-        linkfrom = os.path.join(path, \"Contents\",\"Frameworks\", framework.frameworkName, \"Versions\", \"Current\")\n+        linkfrom = os.path.join(path, \"Contents\", \"Frameworks\", framework.frameworkName, \"Versions\", \"Current\")\n         linkto = framework.version\n         if not os.path.exists(linkfrom):\n             os.symlink(linkto, linkfrom)"
      },
      {
        "sha": "2e07cea73f5197acd714da62c213802ea2c5672c",
        "filename": "contrib/seeds/generate-seeds.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/seeds/generate-seeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/seeds/generate-seeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/generate-seeds.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -41,7 +41,7 @@\n # ipv4 in ipv6 prefix\n pchIPv4 = bytearray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff])\n # tor-specific ipv6 prefix\n-pchOnionCat = bytearray([0xFD,0x87,0xD8,0x7E,0xEB,0x43])\n+pchOnionCat = bytearray([0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43])\n \n def name_to_ipv6(addr):\n     if len(addr)>6 and addr.endswith('.onion'):\n@@ -55,7 +55,7 @@ def name_to_ipv6(addr):\n         sub = [[], []] # prefix, suffix\n         x = 0\n         addr = addr.split(':')\n-        for i,comp in enumerate(addr):\n+        for i, comp in enumerate(addr):\n             if comp == '':\n                 if i == 0 or i == (len(addr)-1): # skip empty component at beginning or end\n                     continue\n@@ -82,7 +82,7 @@ def parse_spec(s, defaultport):\n         host = s\n         port = ''\n     else:\n-        (host,_,port) = s.partition(':')\n+        (host, _, port) = s.partition(':')\n \n     if not port:\n         port = defaultport\n@@ -91,7 +91,7 @@ def parse_spec(s, defaultport):\n \n     host = name_to_ipv6(host)\n \n-    return (host,port)\n+    return (host, port)\n \n def process_nodes(g, f, structname, defaultport):\n     g.write('static SeedSpec6 %s[] = {\\n' % structname)\n@@ -107,7 +107,7 @@ def process_nodes(g, f, structname, defaultport):\n             g.write(',\\n')\n         first = False\n \n-        (host,port) = parse_spec(line, defaultport)\n+        (host, port) = parse_spec(line, defaultport)\n         hoststr = ','.join(('0x%02x' % b) for b in host)\n         g.write('    {{%s}, %i}' % (hoststr, port))\n     g.write('\\n};\\n')\n@@ -127,10 +127,10 @@ def main():\n     g.write(' * Each line contains a 16-byte IPv6 address and a port.\\n')\n     g.write(' * IPv4 as well as onion addresses are wrapped inside an IPv6 address accordingly.\\n')\n     g.write(' */\\n')\n-    with open(os.path.join(indir,'nodes_main.txt'), 'r', encoding=\"utf8\") as f:\n+    with open(os.path.join(indir, 'nodes_main.txt'), 'r', encoding=\"utf8\") as f:\n         process_nodes(g, f, 'pnSeed6_main', 8333)\n     g.write('\\n')\n-    with open(os.path.join(indir,'nodes_test.txt'), 'r', encoding=\"utf8\") as f:\n+    with open(os.path.join(indir, 'nodes_test.txt'), 'r', encoding=\"utf8\") as f:\n         process_nodes(g, f, 'pnSeed6_test', 18333)\n     g.write('#endif // BITCOIN_CHAINPARAMSSEEDS_H\\n')\n "
      },
      {
        "sha": "d2e2f8773b70725f70d51d0162c8197551bf302c",
        "filename": "contrib/seeds/makeseeds.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/seeds/makeseeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/seeds/makeseeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/makeseeds.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -59,7 +59,7 @@ def parseline(line):\n     else:\n         # Do IPv4 sanity check\n         ip = 0\n-        for i in range(0,4):\n+        for i in range(0, 4):\n             if int(m.group(i+2)) < 0 or int(m.group(i+2)) > 255:\n                 return None\n             ip = ip + (int(m.group(i+2)) << (8*(3-i)))\n@@ -104,7 +104,7 @@ def filtermultiport(ips):\n     hist = collections.defaultdict(list)\n     for ip in ips:\n         hist[ip['sortkey']].append(ip)\n-    return [value[0] for (key,value) in list(hist.items()) if len(value)==1]\n+    return [value[0] for (key, value) in list(hist.items()) if len(value)==1]\n \n # Based on Greg Maxwell's seed_filter.py\n def filterbyasn(ips, max_per_asn, max_total):"
      },
      {
        "sha": "8fb3eb0a9121083720137ce17774e355d1d20ec2",
        "filename": "contrib/testgen/gen_key_io_test_vectors.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/testgen/gen_key_io_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/contrib/testgen/gen_key_io_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_key_io_test_vectors.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -140,7 +140,7 @@ def gen_valid_vectors():\n         for template, valid_vector_generator in [(t, g) for g, l in zip(glist, tlist) for t in l]:\n             rv, payload = valid_vector_generator(template)\n             assert is_valid(rv)\n-            metadata = {x: y for x, y in zip(metadata_keys,template[3]) if y is not None}\n+            metadata = {x: y for x, y in zip(metadata_keys, template[3]) if y is not None}\n             hexrepr = b2a_hex(payload)\n             if isinstance(hexrepr, bytes):\n                 hexrepr = hexrepr.decode('utf8')\n@@ -173,7 +173,7 @@ def gen_invalid_base58_vector(template):\n         suffix = bytearray(template[2])\n \n     val = b58encode_chk(prefix + payload + suffix)\n-    if random.randint(0,10)<1: # line corruption\n+    if random.randint(0, 10)<1: # line corruption\n         if randbool(): # add random character to end\n             val += random.choice(b58chars)\n         else: # replace random character in the middle\n@@ -233,7 +233,7 @@ def gen_invalid_vectors():\n if __name__ == '__main__':\n     import sys\n     import json\n-    iters = {'valid':gen_valid_vectors, 'invalid':gen_invalid_vectors}\n+    iters = {'valid': gen_valid_vectors, 'invalid': gen_invalid_vectors}\n     try:\n         uiter = iters[sys.argv[1]]\n     except IndexError:"
      },
      {
        "sha": "83929009e8701743ade95458fb12cd36cc3cfa7e",
        "filename": "share/qt/extract_strings_qt.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/share/qt/extract_strings_qt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/share/qt/extract_strings_qt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/extract_strings_qt.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -55,10 +55,10 @@ def parse_po(text):\n # xgettext -n --keyword=_ $FILES\n XGETTEXT=os.getenv('XGETTEXT', 'xgettext')\n if not XGETTEXT:\n-    print('Cannot extract strings: xgettext utility is not installed or not configured.',file=sys.stderr)\n-    print('Please install package \"gettext\" and re-run \\'./configure\\'.',file=sys.stderr)\n+    print('Cannot extract strings: xgettext utility is not installed or not configured.', file=sys.stderr)\n+    print('Please install package \"gettext\" and re-run \\'./configure\\'.', file=sys.stderr)\n     sys.exit(1)\n-child = Popen([XGETTEXT,'--output=-','-n','--keyword=_'] + files, stdout=PIPE)\n+child = Popen([XGETTEXT, '--output=-', '-n', '--keyword=_'] + files, stdout=PIPE)\n (out, err) = child.communicate()\n \n messages = parse_po(out.decode('utf-8'))"
      },
      {
        "sha": "71abe9f05d9fa3e31b96b0d555a1c35f16764f78",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -147,11 +147,11 @@ def test_sequence_lock_confirmed_inputs(self):\n                 sequence_value = 0xfffffffe # this disables sequence locks\n \n                 # 50% chance we enable sequence locks\n-                if random.randint(0,1):\n+                if random.randint(0, 1):\n                     using_sequence_locks = True\n \n                     # 10% of the time, make the input sequence value pass\n-                    input_will_pass = (random.randint(1,10) == 1)\n+                    input_will_pass = (random.randint(1, 10) == 1)\n                     sequence_value = utxos[j][\"confirmations\"]\n                     if not input_will_pass:\n                         sequence_value += 1\n@@ -170,7 +170,7 @@ def test_sequence_lock_confirmed_inputs(self):\n                         can_time_lock = False\n \n                     # if time-lockable, then 50% chance we make this a time lock\n-                    if random.randint(0,1) and can_time_lock:\n+                    if random.randint(0, 1) and can_time_lock:\n                         # Find first time-lock value that fails, or latest one that succeeds\n                         time_delta = sequence_value << SEQUENCE_LOCKTIME_GRANULARITY\n                         if input_will_pass and time_delta > cur_time - orig_time:"
      },
      {
        "sha": "310971b1de281b6c5864f1775c11d00ecc0a3b24",
        "filename": "test/functional/feature_proxy.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_proxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_proxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_proxy.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -79,13 +79,13 @@ def setup_nodes(self):\n         # Note: proxies are not used to connect to local nodes\n         # this is because the proxy to use is based on CService.GetNetwork(), which return NET_UNROUTABLE for localhost\n         args = [\n-            ['-listen', '-proxy=%s:%i' % (self.conf1.addr),'-proxyrandomize=1'],\n-            ['-listen', '-proxy=%s:%i' % (self.conf1.addr),'-onion=%s:%i' % (self.conf2.addr),'-proxyrandomize=0'],\n-            ['-listen', '-proxy=%s:%i' % (self.conf2.addr),'-proxyrandomize=1'],\n+            ['-listen', '-proxy=%s:%i' % (self.conf1.addr), '-proxyrandomize=1'],\n+            ['-listen', '-proxy=%s:%i' % (self.conf1.addr), '-onion=%s:%i' % (self.conf2.addr), '-proxyrandomize=0'],\n+            ['-listen', '-proxy=%s:%i' % (self.conf2.addr), '-proxyrandomize=1'],\n             []\n             ]\n         if self.have_ipv6:\n-            args[3] = ['-listen', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0', '-noonion']\n+            args[3] = ['-listen', '-proxy=[%s]:%i' % (self.conf3.addr), '-proxyrandomize=0', '-noonion']\n         self.add_nodes(self.num_nodes, extra_args=args)\n         self.start_nodes()\n \n@@ -155,7 +155,7 @@ def run_test(self):\n         # -proxy plus -onion, -proxyrandomize\n         rv = self.node_test(self.nodes[2], [self.serv2, self.serv2, self.serv2, self.serv2], True)\n         # Check that credentials as used for -proxyrandomize connections are unique\n-        credentials = set((x.username,x.password) for x in rv)\n+        credentials = set((x.username, x.password) for x in rv)\n         assert_equal(len(credentials), len(rv))\n \n         if self.have_ipv6:\n@@ -170,28 +170,28 @@ def networks_dict(d):\n \n         # test RPC getnetworkinfo\n         n0 = networks_dict(self.nodes[0].getnetworkinfo())\n-        for net in ['ipv4','ipv6','onion']:\n+        for net in ['ipv4', 'ipv6', 'onion']:\n             assert_equal(n0[net]['proxy'], '%s:%i' % (self.conf1.addr))\n             assert_equal(n0[net]['proxy_randomize_credentials'], True)\n         assert_equal(n0['onion']['reachable'], True)\n \n         n1 = networks_dict(self.nodes[1].getnetworkinfo())\n-        for net in ['ipv4','ipv6']:\n+        for net in ['ipv4', 'ipv6']:\n             assert_equal(n1[net]['proxy'], '%s:%i' % (self.conf1.addr))\n             assert_equal(n1[net]['proxy_randomize_credentials'], False)\n         assert_equal(n1['onion']['proxy'], '%s:%i' % (self.conf2.addr))\n         assert_equal(n1['onion']['proxy_randomize_credentials'], False)\n         assert_equal(n1['onion']['reachable'], True)\n \n         n2 = networks_dict(self.nodes[2].getnetworkinfo())\n-        for net in ['ipv4','ipv6','onion']:\n+        for net in ['ipv4', 'ipv6', 'onion']:\n             assert_equal(n2[net]['proxy'], '%s:%i' % (self.conf2.addr))\n             assert_equal(n2[net]['proxy_randomize_credentials'], True)\n         assert_equal(n2['onion']['reachable'], True)\n \n         if self.have_ipv6:\n             n3 = networks_dict(self.nodes[3].getnetworkinfo())\n-            for net in ['ipv4','ipv6']:\n+            for net in ['ipv4', 'ipv6']:\n                 assert_equal(n3[net]['proxy'], '[%s]:%i' % (self.conf3.addr))\n                 assert_equal(n3[net]['proxy_randomize_credentials'], False)\n             assert_equal(n3['onion']['reachable'], False)"
      },
      {
        "sha": "2bc2427d0bce89c17d22eddbee18ffcc7ad70dc1",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -131,14 +131,14 @@ def reorg_test(self):\n         # Reboot node 1 to clear its mempool (hopefully make the invalidate faster)\n         # Lower the block max size so we don't keep mining all our big mempool transactions (from disconnected blocks)\n         self.stop_node(1)\n-        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\",\"-blockmaxweight=20000\", \"-checkblocks=5\"])\n+        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\", \"-blockmaxweight=20000\", \"-checkblocks=5\"])\n \n         height = self.nodes[1].getblockcount()\n         self.log.info(\"Current block height: %d\" % height)\n \n         invalidheight = height-287\n         badhash = self.nodes[1].getblockhash(invalidheight)\n-        self.log.info(\"Invalidating block %s at height %d\" % (badhash,invalidheight))\n+        self.log.info(\"Invalidating block %s at height %d\" % (badhash, invalidheight))\n         self.nodes[1].invalidateblock(badhash)\n \n         # We've now switched to our previously mined-24 block fork on node 1, but that's not what we want\n@@ -154,7 +154,7 @@ def reorg_test(self):\n \n         # Reboot node1 to clear those giant tx's from mempool\n         self.stop_node(1)\n-        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\",\"-blockmaxweight=20000\", \"-checkblocks=5\"])\n+        self.start_node(1, extra_args=[\"-maxreceivebuffer=20000\", \"-blockmaxweight=20000\", \"-checkblocks=5\"])\n \n         self.log.info(\"Generating new longer chain of 300 more blocks\")\n         self.nodes[1].generate(300)\n@@ -184,7 +184,7 @@ def reorg_test(self):\n         if (usage > 550):\n             raise AssertionError(\"Pruning target not being met\")\n \n-        return invalidheight,badhash\n+        return invalidheight, badhash\n \n     def reorg_back(self):\n         # Verify that a block on the old main chain fork has been pruned away\n@@ -394,7 +394,7 @@ def run_test(self):\n         self.mainchainhash2 = self.nodes[2].getblockhash(self.mainchainheight)\n \n         self.log.info(\"Check that we can survive a 288 block reorg still\")\n-        (self.forkheight,self.forkhash) = self.reorg_test() #(1033, )\n+        (self.forkheight, self.forkhash) = self.reorg_test() #(1033, )\n         # Now create a 288 block reorg by mining a longer chain on N1\n         # First disconnect N1\n         # Then invalidate 1033 on main chain and 1032 on fork so height is 1032 on main chain"
      },
      {
        "sha": "a36cf0a82e0f90a3384ea21b679a44b851b85f48",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -103,7 +103,7 @@ def run_test(self):\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         assert(tmpl['sizelimit'] == 1000000)\n         assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n@@ -205,7 +205,7 @@ def run_test(self):\n \n         self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n         assert(tmpl['weightlimit'] == 4000000)\n         assert(tmpl['sigoplimit'] == 80000)\n@@ -532,7 +532,7 @@ def run_test(self):\n \n         # after importaddress it should pass addwitnessaddress\n         v = self.nodes[0].getaddressinfo(compressed_solvable_address[1])\n-        self.nodes[0].importaddress(v['hex'],\"\",False,True)\n+        self.nodes[0].importaddress(v['hex'], \"\", False, True)\n         for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n             witaddress = self.nodes[0].addwitnessaddress(i)\n             assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n@@ -542,8 +542,8 @@ def run_test(self):\n         self.mine_and_test_listunspent(unseen_anytime, 0)\n \n         # Check that createrawtransaction/decoderawtransaction with non-v0 Bech32 works\n-        v1_addr = program_to_witness(1, [3,5])\n-        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])],{v1_addr: 1})\n+        v1_addr = program_to_witness(1, [3, 5])\n+        v1_tx = self.nodes[0].createrawtransaction([getutxo(spendable_txid[0])], {v1_addr: 1})\n         v1_decoded = self.nodes[1].decoderawtransaction(v1_tx)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['addresses'][0], v1_addr)\n         assert_equal(v1_decoded['vout'][0]['scriptPubKey']['hex'], \"51020305\")\n@@ -586,7 +586,7 @@ def run_test(self):\n     def mine_and_test_listunspent(self, script_list, ismine):\n         utxo = find_spendable_utxo(self.nodes[0], 50)\n         tx = CTransaction()\n-        tx.vin.append(CTxIn(COutPoint(int('0x'+utxo['txid'],0), utxo['vout'])))\n+        tx.vin.append(CTxIn(COutPoint(int('0x'+utxo['txid'], 0), utxo['vout'])))\n         for i in script_list:\n             tx.vout.append(CTxOut(10000000, i))\n         tx.rehash()\n@@ -610,14 +610,14 @@ def mine_and_test_listunspent(self, script_list, ismine):\n             assert_equal(watchcount, 0)\n         return txid\n \n-    def p2sh_address_to_script(self,v):\n+    def p2sh_address_to_script(self, v):\n         bare = CScript(hex_str_to_bytes(v['hex']))\n         p2sh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n         p2wsh = CScript([OP_0, sha256(bare)])\n         p2sh_p2wsh = CScript([OP_HASH160, hash160(p2wsh), OP_EQUAL])\n         return([bare, p2sh, p2wsh, p2sh_p2wsh])\n \n-    def p2pkh_address_to_script(self,v):\n+    def p2pkh_address_to_script(self, v):\n         pubkey = hex_str_to_bytes(v['pubkey'])\n         p2wpkh = CScript([OP_0, hash160(pubkey)])\n         p2sh_p2wpkh = CScript([OP_HASH160, hash160(p2wpkh), OP_EQUAL])\n@@ -639,7 +639,7 @@ def create_and_mine_tx_from_txids(self, txids, success = True):\n             f = BytesIO(hex_str_to_bytes(txraw))\n             txtmp.deserialize(f)\n             for j in range(len(txtmp.vout)):\n-                tx.vin.append(CTxIn(COutPoint(int('0x'+i,0), j)))\n+                tx.vin.append(CTxIn(COutPoint(int('0x'+i, 0), j)))\n         tx.vout.append(CTxOut(0, CScript()))\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize_without_witness()))['hex']"
      },
      {
        "sha": "2389580e6af231860162f135e5237579923eb99b",
        "filename": "test/functional/interface_http.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/interface_http.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/interface_http.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_http.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -58,7 +58,7 @@ def run_test(self):\n         conn.close()\n \n         #now do the same with \"Connection: close\"\n-        headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpair), \"Connection\":\"close\"}\n+        headers = {\"Authorization\": \"Basic \" + str_to_b64str(authpair), \"Connection\": \"close\"}\n \n         conn = http.client.HTTPConnection(url.hostname, url.port)\n         conn.connect()"
      },
      {
        "sha": "9957bb16bebd69a3af74ecd5fa4f6cb87bec2e6b",
        "filename": "test/functional/mempool_spend_coinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/mempool_spend_coinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/mempool_spend_coinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spend_coinbase.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -39,7 +39,7 @@ def run_test(self):\n         spend_101_id = self.nodes[0].sendrawtransaction(spends_raw[0])\n \n         # coinbase at height 102 should be too immature to spend\n-        assert_raises_rpc_error(-26,\"bad-txns-premature-spend-of-coinbase\", self.nodes[0].sendrawtransaction, spends_raw[1])\n+        assert_raises_rpc_error(-26, \"bad-txns-premature-spend-of-coinbase\", self.nodes[0].sendrawtransaction, spends_raw[1])\n \n         # mempool should have just spend_101:\n         assert_equal(self.nodes[0].getrawmempool(), [ spend_101_id ])"
      },
      {
        "sha": "7926aa7d6b3bd6d659fed73a537b1c9f197e8e6d",
        "filename": "test/functional/mining_getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/mining_getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/mining_getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_getblocktemplate_longpoll.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -22,7 +22,7 @@ def __init__(self, node):\n         self.node = get_rpc_proxy(node.url, 1, timeout=600, coveragedir=node.coverage_dir)\n \n     def run(self):\n-        self.node.getblocktemplate({'longpollid':self.longpollid})\n+        self.node.getblocktemplate({'longpollid': self.longpollid})\n \n class GetBlockTemplateLPTest(BitcoinTestFramework):\n     def set_test_params(self):"
      },
      {
        "sha": "64e1b24fd12db9601a086e25ea5559060ec85021",
        "filename": "test/functional/rpc_bind.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_bind.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_bind.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_bind.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -72,7 +72,7 @@ def run_test(self):\n \n         self.log.info(\"Check for non-loopback interface\")\n         self.non_loopback_ip = None\n-        for name,ip in all_interfaces():\n+        for name, ip in all_interfaces():\n             if ip != '127.0.0.1':\n                 self.non_loopback_ip = ip\n                 break"
      },
      {
        "sha": "8caba80d9f5791939e05bfd6b1cacdd1ee610717",
        "filename": "test/functional/rpc_createmultisig.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_createmultisig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_createmultisig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_createmultisig.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -23,23 +23,23 @@ def get_keys(self):\n         self.final = node2.getnewaddress()\n \n     def run_test(self):\n-        node0,node1,node2 = self.nodes\n+        node0, node1, node2 = self.nodes\n \n         # 50 BTC each, rest will be 25 BTC each\n         node0.generate(149)\n         self.sync_all()\n \n         self.moved = 0\n-        for self.nkeys in [3,5]:\n-            for self.nsigs in [2,3]:\n+        for self.nkeys in [3, 5]:\n+            for self.nsigs in [2, 3]:\n                 for self.output_type in [\"bech32\", \"p2sh-segwit\", \"legacy\"]:\n                     self.get_keys()\n                     self.do_multisig()\n \n         self.checkbalances()\n \n     def checkbalances(self):\n-        node0,node1,node2 = self.nodes\n+        node0, node1, node2 = self.nodes\n         node0.generate(100)\n         self.sync_all()\n \n@@ -55,7 +55,7 @@ def checkbalances(self):\n         assert bal0+bal1+bal2 == total\n \n     def do_multisig(self):\n-        node0,node1,node2 = self.nodes\n+        node0, node1, node2 = self.nodes\n \n         msig = node2.createmultisig(self.nsigs, self.pub, self.output_type)\n         madd = msig[\"address\"]\n@@ -74,7 +74,7 @@ def do_multisig(self):\n         txid = node0.sendtoaddress(madd, 40)\n \n         tx = node0.getrawtransaction(txid, True)\n-        vout = [v[\"n\"] for v in tx[\"vout\"] if madd in v[\"scriptPubKey\"].get(\"addresses\",[])]\n+        vout = [v[\"n\"] for v in tx[\"vout\"] if madd in v[\"scriptPubKey\"].get(\"addresses\", [])]\n         assert len(vout) == 1\n         vout = vout[0]\n         scriptPubKey = tx[\"vout\"][vout][\"scriptPubKey\"][\"hex\"]"
      },
      {
        "sha": "13f0d249dccf40f69d5d649bc75d7e8b576df892",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -61,8 +61,8 @@ def run_test(self):\n         self.sync_all()\n \n         # ensure that setting changePosition in fundraw with an exact match is handled properly\n-        rawmatch = self.nodes[2].createrawtransaction([], {self.nodes[2].getnewaddress():50})\n-        rawmatch = self.nodes[2].fundrawtransaction(rawmatch, {\"changePosition\":1, \"subtractFeeFromOutputs\":[0]})\n+        rawmatch = self.nodes[2].createrawtransaction([], {self.nodes[2].getnewaddress(): 50})\n+        rawmatch = self.nodes[2].fundrawtransaction(rawmatch, {\"changePosition\": 1, \"subtractFeeFromOutputs\": [0]})\n         assert_equal(rawmatch[\"changepos\"], -1)\n \n         watchonly_address = self.nodes[0].getnewaddress()\n@@ -197,7 +197,7 @@ def run_test(self):\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n-        assert_raises_rpc_error(-3, \"Unexpected key foo\", self.nodes[2].fundrawtransaction, rawtx, {'foo':'bar'})\n+        assert_raises_rpc_error(-3, \"Unexpected key foo\", self.nodes[2].fundrawtransaction, rawtx, {'foo': 'bar'})\n \n         # reserveChangeKey was deprecated and is now removed\n         assert_raises_rpc_error(-3, \"Unexpected key reserveChangeKey\", lambda: self.nodes[2].fundrawtransaction(hexstring=rawtx, options={'reserveChangeKey': True}))\n@@ -213,7 +213,7 @@ def run_test(self):\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n-        assert_raises_rpc_error(-5, \"changeAddress must be a valid bitcoin address\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':'foobar'})\n+        assert_raises_rpc_error(-5, \"changeAddress must be a valid bitcoin address\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress': 'foobar'})\n \n         ############################################################\n         # test a fundrawtransaction with a provided change address #\n@@ -227,7 +227,7 @@ def run_test(self):\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n         change = self.nodes[2].getnewaddress()\n-        assert_raises_rpc_error(-8, \"changePosition out of bounds\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress':change, 'changePosition':2})\n+        assert_raises_rpc_error(-8, \"changePosition out of bounds\", self.nodes[2].fundrawtransaction, rawtx, {'changeAddress': change, 'changePosition': 2})\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx, {'changeAddress': change, 'changePosition': 0})\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n         out = dec_tx['vout'][0]\n@@ -288,7 +288,7 @@ def run_test(self):\n         utx = get_unspent(self.nodes[2].listunspent(), 1)\n         utx2 = get_unspent(self.nodes[2].listunspent(), 5)\n \n-        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']},{'txid' : utx2['txid'], 'vout' : utx2['vout']} ]\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']}, {'txid' : utx2['txid'], 'vout' : utx2['vout']} ]\n         outputs = { self.nodes[0].getnewaddress() : 6.0 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n@@ -321,7 +321,7 @@ def run_test(self):\n         utx = get_unspent(self.nodes[2].listunspent(), 1)\n         utx2 = get_unspent(self.nodes[2].listunspent(), 5)\n \n-        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']},{'txid' : utx2['txid'], 'vout' : utx2['vout']} ]\n+        inputs  = [ {'txid' : utx['txid'], 'vout' : utx['vout']}, {'txid' : utx2['txid'], 'vout' : utx2['vout']} ]\n         outputs = { self.nodes[0].getnewaddress() : 6.0, self.nodes[0].getnewaddress() : 1.0 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n@@ -353,7 +353,7 @@ def run_test(self):\n         ############################################################\n         #compare fee of a standard pubkeyhash transaction\n         inputs = []\n-        outputs = {self.nodes[1].getnewaddress():1.1}\n+        outputs = {self.nodes[1].getnewaddress(): 1.1}\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n \n@@ -369,7 +369,7 @@ def run_test(self):\n         ############################################################\n         #compare fee of a standard pubkeyhash transaction with multiple outputs\n         inputs = []\n-        outputs = {self.nodes[1].getnewaddress():1.1,self.nodes[1].getnewaddress():1.2,self.nodes[1].getnewaddress():0.1,self.nodes[1].getnewaddress():1.3,self.nodes[1].getnewaddress():0.2,self.nodes[1].getnewaddress():0.3}\n+        outputs = {self.nodes[1].getnewaddress(): 1.1, self.nodes[1].getnewaddress(): 1.2, self.nodes[1].getnewaddress(): 0.1, self.nodes[1].getnewaddress(): 1.3, self.nodes[1].getnewaddress(): 0.2, self.nodes[1].getnewaddress(): 0.3}\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n         #create same transaction over sendtoaddress\n@@ -395,7 +395,7 @@ def run_test(self):\n         mSigObj = self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n \n         inputs = []\n-        outputs = {mSigObj:1.1}\n+        outputs = {mSigObj: 1.1}\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n \n@@ -428,7 +428,7 @@ def run_test(self):\n         mSigObj = self.nodes[1].addmultisigaddress(4, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey'], addr4Obj['pubkey'], addr5Obj['pubkey']])['address']\n \n         inputs = []\n-        outputs = {mSigObj:1.1}\n+        outputs = {mSigObj: 1.1}\n         rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[0].fundrawtransaction(rawtx)\n \n@@ -463,7 +463,7 @@ def run_test(self):\n \n         oldBalance = self.nodes[1].getbalance()\n         inputs = []\n-        outputs = {self.nodes[1].getnewaddress():1.1}\n+        outputs = {self.nodes[1].getnewaddress(): 1.1}\n         rawtx = self.nodes[2].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[2].fundrawtransaction(rawtx)\n \n@@ -487,10 +487,10 @@ def run_test(self):\n         for node in self.nodes:\n             node.settxfee(min_relay_tx_fee)\n \n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n-        connect_nodes_bi(self.nodes,0,3)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+        connect_nodes_bi(self.nodes, 0, 3)\n         # Again lock the watchonly UTXO or nodes[0] may spend it, because\n         # lockunspent is memory-only and thus lost on restart\n         self.nodes[0].lockunspent(False, [{\"txid\": watchonly_txid, \"vout\": watchonly_vout}])\n@@ -500,7 +500,7 @@ def run_test(self):\n         self.nodes[1].getnewaddress()\n         self.nodes[1].getrawchangeaddress()\n         inputs = []\n-        outputs = {self.nodes[0].getnewaddress():1.1}\n+        outputs = {self.nodes[0].getnewaddress(): 1.1}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         # fund a transaction that requires a new key for the change output\n         # creating the key must be impossible because the wallet is locked\n@@ -516,7 +516,7 @@ def run_test(self):\n         oldBalance = self.nodes[0].getbalance()\n \n         inputs = []\n-        outputs = {self.nodes[0].getnewaddress():1.1}\n+        outputs = {self.nodes[0].getnewaddress(): 1.1}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n \n@@ -541,14 +541,14 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        for i in range(0,20):\n+        for i in range(0, 20):\n             self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01)\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n         #fund a tx with ~20 small inputs\n         inputs = []\n-        outputs = {self.nodes[0].getnewaddress():0.15,self.nodes[0].getnewaddress():0.04}\n+        outputs = {self.nodes[0].getnewaddress(): 0.15, self.nodes[0].getnewaddress(): 0.04}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n \n@@ -571,7 +571,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        for i in range(0,20):\n+        for i in range(0, 20):\n             self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01)\n         self.nodes[0].generate(1)\n         self.sync_all()\n@@ -580,7 +580,7 @@ def run_test(self):\n         oldBalance = self.nodes[0].getbalance()\n \n         inputs = []\n-        outputs = {self.nodes[0].getnewaddress():0.15,self.nodes[0].getnewaddress():0.04}\n+        outputs = {self.nodes[0].getnewaddress(): 0.15, self.nodes[0].getnewaddress(): 0.04}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n         fundedAndSignedTx = self.nodes[1].signrawtransactionwithwallet(fundedTx['hex'])"
      },
      {
        "sha": "77b928fbddc2599b5b82b39d130649af3a5b7d32",
        "filename": "test/functional/rpc_invalidateblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalidateblock.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -29,7 +29,7 @@ def run_test(self):\n         assert(self.nodes[1].getblockcount() == 6)\n \n         self.log.info(\"Connect nodes to force a reorg\")\n-        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes, 0, 1)\n         sync_blocks(self.nodes[0:2])\n         assert(self.nodes[0].getblockcount() == 6)\n         badhash = self.nodes[1].getblockhash(2)\n@@ -39,10 +39,10 @@ def run_test(self):\n         newheight = self.nodes[0].getblockcount()\n         newhash = self.nodes[0].getbestblockhash()\n         if (newheight != 4 or newhash != besthash):\n-            raise AssertionError(\"Wrong tip for node0, hash %s, height %d\"%(newhash,newheight))\n+            raise AssertionError(\"Wrong tip for node0, hash %s, height %d\"%(newhash, newheight))\n \n         self.log.info(\"Make sure we won't reorg to a lower work chain:\")\n-        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes, 1, 2)\n         self.log.info(\"Sync node 2 to node 1 so both have 6 blocks\")\n         sync_blocks(self.nodes[1:3])\n         assert(self.nodes[2].getblockcount() == 6)"
      },
      {
        "sha": "bde8b67f2cf9d2ef90dc2856d55ca61f92afc825",
        "filename": "test/functional/rpc_named_arguments.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_named_arguments.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_named_arguments.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_named_arguments.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -25,10 +25,10 @@ def run_test(self):\n         node.getblock(blockhash=h)\n \n         assert_equal(node.echo(), [])\n-        assert_equal(node.echo(arg0=0,arg9=9), [0] + [None]*8 + [9])\n+        assert_equal(node.echo(arg0=0, arg9=9), [0] + [None]*8 + [9])\n         assert_equal(node.echo(arg1=1), [None, 1])\n         assert_equal(node.echo(arg9=None), [None]*10)\n-        assert_equal(node.echo(arg0=0,arg3=3,arg9=9), [0] + [None]*2 + [3] + [None]*5 + [9])\n+        assert_equal(node.echo(arg0=0, arg3=3, arg9=9), [0] + [None]*2 + [3] + [None]*5 + [9])\n \n if __name__ == '__main__':\n     NamedArgumentTest().main()"
      },
      {
        "sha": "49973981bf6ef0ff2e9a1fcf1aa276017f38947e",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -26,7 +26,7 @@ class NetTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n-        self.extra_args = [[\"-minrelaytxfee=0.00001000\"],[\"-minrelaytxfee=0.00000500\"]]\n+        self.extra_args = [[\"-minrelaytxfee=0.00001000\"], [\"-minrelaytxfee=0.00000500\"]]\n \n     def run_test(self):\n         self._test_connection_count()"
      },
      {
        "sha": "169a765f0aaae174b0d9ba793f48d353b0359fbb",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -61,7 +61,7 @@ def run_test(self):\n         self.log.info(\"Connect nodes and check no reorg occurs\")\n         # Submit competing blocks via RPC so any reorg should occur before we proceed (no way to wait on inaction for p2p sync)\n         node_sync_via_rpc(self.nodes[0:2])\n-        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes, 0, 1)\n         assert_equal(self.nodes[0].getbestblockhash(), hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashG)\n         self.log.info(\"Make Node0 prefer block G\")\n@@ -98,8 +98,8 @@ def run_test(self):\n         hashL = self.nodes[2].getbestblockhash()\n         self.log.info(\"Connect nodes and check no reorg occurs\")\n         node_sync_via_rpc(self.nodes[1:3])\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         assert_equal(self.nodes[0].getbestblockhash(), hashH)\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         assert_equal(self.nodes[2].getbestblockhash(), hashL)"
      },
      {
        "sha": "4219715ab8339af4e73ff9cbb485d0d226c26204",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -25,7 +25,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         # Create and fund a raw tx for sending 10 BTC\n-        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress(): 10})['psbt']\n \n         # Node 1 should not be able to add anything to it but still return the psbtx same as before\n         psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n@@ -48,8 +48,8 @@ def run_test(self):\n         p2sh_p2wpkh = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n \n         # fund those addresses\n-        rawtx = self.nodes[0].createrawtransaction([], {p2sh:10, p2wsh:10, p2wpkh:10, p2sh_p2wsh:10, p2sh_p2wpkh:10, p2pkh:10})\n-        rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n+        rawtx = self.nodes[0].createrawtransaction([], {p2sh: 10, p2wsh: 10, p2wpkh: 10, p2sh_p2wsh: 10, p2sh_p2wpkh: 10, p2pkh: 10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\": 3})\n         signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n         txid = self.nodes[0].sendrawtransaction(signed_tx)\n         self.nodes[0].generate(6)\n@@ -78,13 +78,13 @@ def run_test(self):\n                 p2pkh_pos = out['n']\n \n         # spend single key from node 1\n-        rawtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        rawtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\": txid, \"vout\": p2wpkh_pos}, {\"txid\": txid, \"vout\": p2sh_p2wpkh_pos}, {\"txid\": txid, \"vout\": p2pkh_pos}], {self.nodes[1].getnewaddress(): 29.99})['psbt']\n         walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(rawtx)\n         assert_equal(walletprocesspsbt_out['complete'], True)\n         self.nodes[1].sendrawtransaction(self.nodes[1].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n \n         # partially sign multisig things with node 1\n-        psbtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos},{\"txid\":txid,\"vout\":p2sh_p2wsh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        psbtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\": txid, \"vout\": p2wsh_pos}, {\"txid\": txid, \"vout\": p2sh_pos}, {\"txid\": txid, \"vout\": p2sh_p2wsh_pos}], {self.nodes[1].getnewaddress(): 29.99})['psbt']\n         walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(psbtx)\n         psbtx = walletprocesspsbt_out['psbt']\n         assert_equal(walletprocesspsbt_out['complete'], False)\n@@ -95,11 +95,11 @@ def run_test(self):\n         self.nodes[2].sendrawtransaction(self.nodes[2].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n \n         # check that walletprocesspsbt fails to decode a non-psbt\n-        rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wpkh_pos}], {self.nodes[1].getnewaddress():9.99})\n+        rawtx = self.nodes[1].createrawtransaction([{\"txid\": txid, \"vout\": p2wpkh_pos}], {self.nodes[1].getnewaddress(): 9.99})\n         assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletprocesspsbt, rawtx)\n \n         # Convert a non-psbt to psbt and make sure we can decode it\n-        rawtx = self.nodes[0].createrawtransaction([], {self.nodes[1].getnewaddress():10})\n+        rawtx = self.nodes[0].createrawtransaction([], {self.nodes[1].getnewaddress(): 10})\n         rawtx = self.nodes[0].fundrawtransaction(rawtx)\n         new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n         self.nodes[0].decodepsbt(new_psbt)\n@@ -123,7 +123,7 @@ def run_test(self):\n         vout2 = find_output(self.nodes[2], txid2, 13)\n \n         # Create a psbt spending outputs from nodes 1 and 2\n-        psbt_orig = self.nodes[0].createpsbt([{\"txid\":txid1,  \"vout\":vout1}, {\"txid\":txid2, \"vout\":vout2}], {self.nodes[0].getnewaddress():25.999})\n+        psbt_orig = self.nodes[0].createpsbt([{\"txid\": txid1,  \"vout\": vout1}, {\"txid\": txid2, \"vout\": vout2}], {self.nodes[0].getnewaddress(): 25.999})\n \n         # Update psbts, should only have data for one input and not the other\n         psbt1 = self.nodes[1].walletprocesspsbt(psbt_orig)['psbt']\n@@ -146,23 +146,23 @@ def run_test(self):\n         # replaceable arg\n         block_height = self.nodes[0].getblockcount()\n         unspent = self.nodes[0].listunspent()[0]\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height+2, {\"replaceable\":True}, False)\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\": unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height+2, {\"replaceable\": True}, False)\n         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in, psbt_in in zip(decoded_psbt[\"tx\"][\"vin\"], decoded_psbt[\"inputs\"]):\n            assert_equal(tx_in[\"sequence\"], MAX_BIP125_RBF_SEQUENCE)\n            assert \"bip32_derivs\" not in psbt_in\n         assert_equal(decoded_psbt[\"tx\"][\"locktime\"], block_height+2)\n \n         # Same construction with only locktime set\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height, {}, True)\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\": unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height, {}, True)\n         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in, psbt_in in zip(decoded_psbt[\"tx\"][\"vin\"], decoded_psbt[\"inputs\"]):\n             assert tx_in[\"sequence\"] > MAX_BIP125_RBF_SEQUENCE\n             assert \"bip32_derivs\" in psbt_in\n         assert_equal(decoded_psbt[\"tx\"][\"locktime\"], block_height)\n \n         # Same construction without optional arguments\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\": unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in in decoded_psbt[\"tx\"][\"vin\"]:\n             assert tx_in[\"sequence\"] > MAX_BIP125_RBF_SEQUENCE"
      },
      {
        "sha": "eaa40fd3768d812b5de1035332f55eed2472d4aa",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -57,9 +57,9 @@ def run_test(self):\n         self.sync_all()\n         self.nodes[0].generate(101)\n         self.sync_all()\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.5)\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.0)\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0)\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.5)\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 5.0)\n         self.sync_all()\n         self.nodes[0].generate(5)\n         self.sync_all()"
      },
      {
        "sha": "4b8c1df85ac385e568526f834a86a56aee8c128e",
        "filename": "test/functional/test_framework/address.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/address.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/address.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/address.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -20,7 +20,7 @@ def byte_to_base58(b, version):\n     str = bytes_to_hex_str(chr(version).encode('latin-1')) + str\n     checksum = bytes_to_hex_str(hash256(hex_str_to_bytes(str)))\n     str += checksum[:8]\n-    value = int('0x'+str,0)\n+    value = int('0x'+str, 0)\n     while value > 0:\n         result = chars[value % 58] + result\n         value //= 58"
      },
      {
        "sha": "f2cf92952fef1c03f7ad8cde896be542f7046209",
        "filename": "test/functional/test_framework/key.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/key.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -173,8 +173,8 @@ def sign(self, hash, low_s = True):\n             while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n                 low_s_bytes = low_s_bytes[1:]\n             new_s_size = len(low_s_bytes)\n-            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n-            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n+            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1, byteorder='big')\n+            new_s_size_byte = (new_s_size).to_bytes(1, byteorder='big')\n             return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n \n     def verify(self, hash, sig):"
      },
      {
        "sha": "e7f9d045202ebcde3e663d40604dfd48240aa3b9",
        "filename": "test/functional/test_framework/netutil.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/netutil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/netutil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/netutil.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -42,23 +42,23 @@ def _remove_empty(array):\n     return [x for x in array if x !='']\n \n def _convert_ip_port(array):\n-    host,port = array.split(':')\n+    host, port = array.split(':')\n     # convert host from mangled-per-four-bytes form as used by kernel\n     host = unhexlify(host)\n     host_out = ''\n     for x in range(0, len(host) // 4):\n         (val,) = struct.unpack('=I', host[x*4:(x+1)*4])\n         host_out += '%08x' % val\n \n-    return host_out,int(port,16)\n+    return host_out, int(port, 16)\n \n def netstat(typ='tcp'):\n     '''\n     Function to return a list with status of tcp connections at linux systems\n     To get pid of all network process running on system, you must run this script\n     as superuser\n     '''\n-    with open('/proc/net/'+typ,'r',encoding='utf8') as f:\n+    with open('/proc/net/'+typ, 'r', encoding='utf8') as f:\n         content = f.readlines()\n         content.pop(0)\n     result = []\n@@ -124,7 +124,7 @@ def addr_to_hex(addr):\n         sub = [[], []] # prefix, suffix\n         x = 0\n         addr = addr.split(':')\n-        for i,comp in enumerate(addr):\n+        for i, comp in enumerate(addr):\n             if comp == '':\n                 if i == 0 or i == (len(addr)-1): # skip empty component at beginning or end\n                     continue"
      },
      {
        "sha": "9bcca5031d36886442e095861af16415abf85d7b",
        "filename": "test/functional/test_framework/socks5.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/socks5.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/test_framework/socks5.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/socks5.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -108,7 +108,7 @@ def handle(self):\n                 addr = recvall(self.conn, 16)\n             else:\n                 raise IOError('Unknown address type %i' % atyp)\n-            port_hi,port_lo = recvall(self.conn, 2)\n+            port_hi, port_lo = recvall(self.conn, 2)\n             port = (port_hi << 8) | port_lo\n \n             # Send dummy response"
      },
      {
        "sha": "4e3dc93f0c13b1082797869d6f931269e6693f1e",
        "filename": "test/functional/wallet_abandonconflict.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_abandonconflict.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -53,8 +53,8 @@ def run_test(self):\n \n         inputs =[]\n         # spend 10btc outputs from txA and txB\n-        inputs.append({\"txid\":txA, \"vout\":nA})\n-        inputs.append({\"txid\":txB, \"vout\":nB})\n+        inputs.append({\"txid\": txA, \"vout\": nA})\n+        inputs.append({\"txid\": txB, \"vout\": nB})\n         outputs = {}\n \n         outputs[self.nodes[0].getnewaddress()] = Decimal(\"14.99998\")\n@@ -67,16 +67,16 @@ def run_test(self):\n \n         #Create a child tx spending AB1 and C\n         inputs = []\n-        inputs.append({\"txid\":txAB1, \"vout\":nAB})\n-        inputs.append({\"txid\":txC, \"vout\":nC})\n+        inputs.append({\"txid\": txAB1, \"vout\": nAB})\n+        inputs.append({\"txid\": txC, \"vout\": nC})\n         outputs = {}\n         outputs[self.nodes[0].getnewaddress()] = Decimal(\"24.9996\")\n         signed2 = self.nodes[0].signrawtransactionwithwallet(self.nodes[0].createrawtransaction(inputs, outputs))\n         txABC2 = self.nodes[0].sendrawtransaction(signed2[\"hex\"])\n \n         # Create a child tx spending ABC2\n         signed3_change = Decimal(\"24.999\")\n-        inputs = [ {\"txid\":txABC2, \"vout\":0} ]\n+        inputs = [ {\"txid\": txABC2, \"vout\": 0} ]\n         outputs = { self.nodes[0].getnewaddress(): signed3_change }\n         signed3 = self.nodes[0].signrawtransactionwithwallet(self.nodes[0].createrawtransaction(inputs, outputs))\n         # note tx is never directly referenced, only abandoned as a child of the above\n@@ -146,7 +146,7 @@ def run_test(self):\n         # Create a double spend of AB1 by spending again from only A's 10 output\n         # Mine double spend from node 1\n         inputs =[]\n-        inputs.append({\"txid\":txA, \"vout\":nA})\n+        inputs.append({\"txid\": txA, \"vout\": nA})\n         outputs = {}\n         outputs[self.nodes[1].getnewaddress()] = Decimal(\"9.9999\")\n         tx = self.nodes[0].createrawtransaction(inputs, outputs)"
      },
      {
        "sha": "23b32ad7caf61500f9d0fbc4596ec5aaca2caffe",
        "filename": "test/functional/wallet_backup.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_backup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_backup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_backup.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -57,8 +57,8 @@ def setup_network(self, split=False):\n         self.sync_all()\n \n     def one_send(self, from_node, to_address):\n-        if (randint(1,2) == 1):\n-            amount = Decimal(randint(1,10)) / Decimal(10)\n+        if (randint(1, 2) == 1):\n+            amount = Decimal(randint(1, 10)) / Decimal(10)\n             self.nodes[from_node].sendtoaddress(to_address, amount)\n \n     def do_one_round(self):"
      },
      {
        "sha": "c9c4d560a6170b460b275dfd2136c2cfab50ae41",
        "filename": "test/functional/wallet_disableprivatekeys.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_disableprivatekeys.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_disableprivatekeys.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_disableprivatekeys.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -27,8 +27,8 @@ def run_test(self):\n         self.nodes[0].createwallet('w2')\n         w1 = node.get_wallet_rpc('w1')\n         w2 = node.get_wallet_rpc('w2')\n-        assert_raises_rpc_error(-4,\"Error: Private keys are disabled for this wallet\", w1.getnewaddress)\n-        assert_raises_rpc_error(-4,\"Error: Private keys are disabled for this wallet\", w1.getrawchangeaddress)\n+        assert_raises_rpc_error(-4, \"Error: Private keys are disabled for this wallet\", w1.getnewaddress)\n+        assert_raises_rpc_error(-4, \"Error: Private keys are disabled for this wallet\", w1.getrawchangeaddress)\n         w1.importpubkey(w2.getaddressinfo(w2.getnewaddress())['pubkey'])\n \n if __name__ == '__main__':"
      },
      {
        "sha": "af7f065ee2bd49bb2b74953612f310988e9d9357",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -107,7 +107,7 @@ def run_test(self):\n         # wallet, we will expect 21 addresses in the dump\n         test_addr_count = 20\n         addrs = []\n-        for i in range(0,test_addr_count):\n+        for i in range(0, test_addr_count):\n             addr = self.nodes[0].getnewaddress()\n             vaddr= self.nodes[0].getaddressinfo(addr) #required to get hd keypath\n             addrs.append(vaddr)"
      },
      {
        "sha": "35b5dc540749c3f79b672c2678a28b5755e7394e",
        "filename": "test/functional/wallet_groups.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_groups.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_groups.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_groups.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -76,7 +76,7 @@ def run_test(self):\n         # Fill node2's wallet with 10000 outputs corresponding to the same\n         # scriptPubKey\n         for i in range(5):\n-            raw_tx = self.nodes[0].createrawtransaction([{\"txid\":\"0\"*64, \"vout\":0}], [{addr2[0]: 0.05}])\n+            raw_tx = self.nodes[0].createrawtransaction([{\"txid\": \"0\"*64, \"vout\": 0}], [{addr2[0]: 0.05}])\n             tx = FromHex(CTransaction(), raw_tx)\n             tx.vin = []\n             tx.vout = [tx.vout[0]] * 2000"
      },
      {
        "sha": "6efc9d2b1a6ddb9e96292cce68cb60de3b34ca55",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -38,7 +38,7 @@ def run_test (self):\n         assert_equal(node0_address1['ismine'], True)\n \n         #Node 1 sync test\n-        assert_equal(self.nodes[1].getblockcount(),1)\n+        assert_equal(self.nodes[1].getblockcount(), 1)\n \n         #Address Test - before import\n         address_info = self.nodes[1].getaddressinfo(node0_address1['address'])\n@@ -258,7 +258,7 @@ def run_test (self):\n         assert_equal(address_assert['isscript'], True)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n \n@@ -285,7 +285,7 @@ def run_test (self):\n         address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n@@ -313,7 +313,7 @@ def run_test (self):\n         address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n "
      },
      {
        "sha": "43448d9a7e94914552f6be08b620b5ef396ad11f",
        "filename": "test/lint/lint-python.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/lint/lint-python.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/lint/lint-python.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-python.sh?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -19,6 +19,7 @@ export LC_ALL=C\n # E133 closing bracket is missing indentation\n # E223 tab before operator\n # E224 tab after operator\n+# E231 missing whitespace after \u2018,\u2019, \u2018;\u2019, or \u2018:\u2019\n # E242 tab after ','\n # E266 too many leading '#' for block comment\n # E271 multiple spaces after keyword\n@@ -87,4 +88,4 @@ elif PYTHONWARNINGS=\"ignore\" flake8 --version | grep -q \"Python 2\"; then\n     exit 0\n fi\n \n-PYTHONWARNINGS=\"ignore\" flake8 --ignore=B,C,E,F,I,N,W --select=E101,E112,E113,E115,E116,E125,E129,E131,E133,E223,E224,E242,E266,E271,E272,E273,E274,E275,E304,E306,E401,E402,E502,E701,E702,E703,E714,E721,E741,E742,E743,E901,E902,F401,F402,F403,F404,F405,F406,F407,F601,F602,F621,F622,F631,F701,F702,F703,F704,F705,F706,F707,F811,F812,F821,F822,F823,F831,F841,W191,W291,W292,W293,W504,W601,W602,W603,W604,W605,W606 \"${@:-.}\"\n+PYTHONWARNINGS=\"ignore\" flake8 --ignore=B,C,E,F,I,N,W --select=E101,E112,E113,E115,E116,E125,E129,E131,E133,E223,E224,E231,E242,E266,E271,E272,E273,E274,E275,E304,E306,E401,E402,E502,E701,E702,E703,E714,E721,E741,E742,E743,E901,E902,F401,F402,F403,F404,F405,F406,F407,F601,F602,F621,F622,F631,F701,F702,F703,F704,F705,F706,F707,F811,F812,F821,F822,F823,F831,F841,W191,W291,W292,W293,W504,W601,W602,W603,W604,W605,W606 \"${@:-.}\""
      },
      {
        "sha": "70021604a9fc90440cfae1ac0b66246e056053b5",
        "filename": "test/util/bitcoin-util-test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e6d1724bb865b8c3519ab35628002dac75251fb/test/util/bitcoin-util-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e6d1724bb865b8c3519ab35628002dac75251fb/test/util/bitcoin-util-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/bitcoin-util-test.py?ref=5e6d1724bb865b8c3519ab35628002dac75251fb",
        "patch": "@@ -9,7 +9,7 @@\n \n Can also be run manually.\"\"\"\n \n-from __future__ import division,print_function,unicode_literals\n+from __future__ import division, print_function, unicode_literals\n \n import argparse\n import binascii"
      }
    ]
  }
]