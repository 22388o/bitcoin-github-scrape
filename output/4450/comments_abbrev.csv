dgenr8,2014-07-02T08:27:07Z,"There's a tradeoff with applying the rate limit before full input validation.  It will save the cost of validation when the tx wouldn't have been relayed anyway due to the rate limit (which could affect all processing), but it allows saturation of the relay rate limit with unsigned spam (which only affects respend relays).\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-47749369,47749369,
BitcoinPullTester,2014-07-02T16:45:42Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4450_0da6b3fd187da3aa810aaa584d8bd197ad4fa2b9/ for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-te",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-47802439,47802439,
gavinandresen,2014-07-03T18:52:30Z,"ACK.  Code reviewed, and compiled and run on OSX\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-47970232,47970232,
gavinandresen,2014-07-03T18:59:45Z,"RE: saturating the relay rate limit:  maybe I'm missing something, but I don't see how an attacker can do that because the bloom filter check is done first (and any outpoint hitting the bloom filter does not count against the relay limit).\n\nIf an attacker had a huge number of unspent outpoints they might be able to flood the filter. But they would pay for that attack in transaction fees for the ",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-47971047,47971047,
dgenr8,2014-07-03T20:10:44Z,"Because sigs have not been checked at rate limit check, he can also submit an invalid second spend for every unconfirmed tx he has seen.  Still limited though.\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-47979009,47979009,
dgenr8,2014-07-03T20:16:23Z,I tested the true and false cases for RelayableRespend.  Bloom filter is initialized and functions correctly.  Also I tested that first spend was relayed and added to wallet.  I did not test bloom filter clear.\n,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-47979626,47979626,
laanwj,2014-07-04T03:50:26Z,ACK\n,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-48006835,48006835,
SergioDemianLerner,2014-07-15T04:24:28Z,"I think this it is a mistake to change the network invariant ""double-spends not relayed"" that has provided quite a lot of DoS protection since 2009. The current patch looks fine. But it could have unexpected interactions.\nI have not actually tested these vulns, but I think they are possible..\n1. For example, suppose an attacker has 4000 outputs that he controls. He creates 4000 txs Tx(i) (one fo",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-48989180,48989180,
SergioDemianLerner,2014-07-15T12:04:07Z,"Clarification: Only smallproofs are generated if the payee requires them, so the network overhead will initially be 0%, and will grow slowly as more merchants adopt the new 0-confirmation system. If all transactions required 0-conf, then the network overhead would be aprox. 50%.\n\nAlso this system is more politically correct: why the whole network should pay with less security if a bunch of merch",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49022146,49022146,
SergioDemianLerner,2014-07-15T12:18:33Z,"A core design decision of Bitcoin was to use fully-spendable outputs instead of partially-spendable accounts for the sole reason that using fully-spendable outputs prevents spamming. For every other possible metric, accounts would have been a better choice than outputs (every new alt 2.0 coin has changed this). But now we're tweaking this to let spam be forwarded again. So we end up with the worst",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49023323,49023323,
dgenr8,2014-07-15T14:04:13Z,"@SergioDemianLerner Thank you very much for your attention and thoughts on this.  Regarding the attacks 1. and 2. that you posit:\n1.  Relaying A will not overcome the bloom filter, because only one output is added to the bloom filter.  That is true whether A respends one output or 2000.  Another respend transaction is required to get another output added, so this is the same attack that @petertod",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49035771,49035771,
sipa,2014-07-15T14:19:48Z,"It gives more information at the cost of decreasing the advantage the first transaction had over the second.\n\nIf we don't believe this advantage should exist, and it is just about more information about the network, and double spends are perfectly acceptable, there is a much simpler solution to this problem, namely replace-by-fee.\n\nIf we believe this advantage should exist (and fow now I do, e",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49038073,49038073,
gavinandresen,2014-07-15T14:27:10Z,"RE: not helping the second transaction get his transactions to miners:\n\nThis is the fundamental disagreement; I wonder if we can somehow measure how difficult it is for a would-be double-spend-attacker to get a transaction to miners.\n\nIf it is easy with the current rules, then I argue this change is definitely positive: it should make transaction recipients more aware that they are being attac",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49039162,49039162,
SergioDemianLerner,2014-07-15T15:17:24Z,"@gavinandresen I look as the source code and I see that if every input is a first double-spend, then every input will be added to the bloom filter.\nMaybe the intention was do it as you say, but the code reads otherwise. The code should be:\n\nif (pool.mapNextTx.count(outpoint) && !tx.IsEquivalentTo(*pool.mapNextTx[outpoint].ptx))\n        {\n            relayableRespend = RelayableRespend(outpoin",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49047166,49047166,
SergioDemianLerner,2014-07-15T15:29:34Z,"Let's recap the method used by merchants to accept 0-conf tx.(as far as I know)\n1. They monitor the network in several places.\n2. They wait 10 seconds\n3. They detect double-spends.\n\nSuppose all miners are fully rational but unscrupulous. This may actually be the average case today, please forgive me if you're a miner and you're not. Then the attacker can just wait 11 seconds and rely a double",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49049090,49049090,
SergioDemianLerner,2014-07-15T15:35:25Z,"@gavinandresen Regarding your 2nd point about orphans: The point is that a huge amount of traffic can be triggered by a 100 byte message. So if I connect to 1000 nodes, and send each one 1000 double-spend orphans (slowly), then In 1 second I can make 1M messages travel around the network. Who knows how the network will react to such state! It can loop....\nAn attacker can prevent people for making",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49049987,49049987,
SergioDemianLerner,2014-07-15T15:57:15Z,"Please give me a single argument why double-spend SmallProof notifications are worse than double-spending TXs,  Forget for a moment about the code already written. There much more at stake.\n\nRegarding information: Smallproofs provide more information, because they actually allow users to measure how many transactions are accepted by 0-conf, which is very important to compute risk of block-rollba",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49053279,49053279,
SergioDemianLerner,2014-07-15T16:02:59Z,Thank you for pointing me to #4484. This solves the first attack I proposed.\n,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49054085,49054085,
petertodd,2014-07-15T16:20:59Z,"@SergioDemianLerner Just to clarify, by ""smallproofs"" you mean my proposal of relaying the scriptSig right? Do remember that proposal requires wallets to apply special-case behavior when sending an instant-confirmation payment; it doesn't work with wallets as-is.\n\nAlso ""computing the signature hash as Hash( prevout(i) || Hash(Tx-as-is-now))"" isn't a hard-fork if done sanely. (sane changes are al",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49056585,49056585,
SergioDemianLerner,2014-07-15T16:22:40Z,"IMHO patch #4484 is buggy. The is an old rule about bugs that states that where a bug is found, there is probably another. With this code we're probably over the fourth.. how many more we'll find?\nAlso I remember a brief talk with Linus Torvals I had 20 years ago, when I was developing kernel drivers for Linux and he told me the KISS principle. Don't you see this patch breaks the KISS principle?\",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49056817,49056817,
gavinandresen,2014-07-15T16:23:18Z,"@SergioDemianLerner : I think you meant to tag @dgenr8  RE: a possible orphan flood attack.\n\nI've been thinking for about a year or so that storing orphan transactions is a bad idea; we could simplify the code if we got rid of mapOrphans and related, and just rely on transaction senders/receivers to rebroadcast transactions that they want mined.  KISS\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49056895,49056895,
SergioDemianLerner,2014-07-15T16:28:29Z,"@petertodd I don't have your proposal at hand, can you send me the link? It seems that we're talking about the same. It requires the wallets to do something special, namely sign a small message along the transaction, and broadcast this message, before or after the transaction.\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49057514,49057514,
petertodd,2014-07-15T16:28:45Z,@gavinandresen Re-broadcasting transactions frequently fails when all your peers have a tx but for whatever reason miners don't; need replace-by-fee or similar in that case to ensure everyone re-propagates your tx. For instance https://github.com/bitcoin/bitcoin/pull/2340 needs to be neutered right now because we don't rebroadcast orphans when we get the block.\n,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49057551,49057551,
petertodd,2014-07-15T16:32:20Z,@SergioDemianLerner We're talking about different things I think; my scheme doesn't require signing messages of any kind. My proposal was written up here: https://github.com/bitcoin/bitcoin/pull/3883#issuecomment-45543370\n,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49058156,49058156,
jgarzik,2014-07-15T17:33:23Z,"@gavinandresen +1\n\n@petertodd The mempool janitor PR (#3753) and related issues (#3722, #3723) also handle that, to a certain extent.\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49065970,49065970,
SergioDemianLerner,2014-07-15T17:47:09Z,@petertodd Your method works by preventing the use of a private key twice. I like it. But it has problems if the user has a single Bitcoin address to receive payments.\n\nMy method does not require a hard fork and can be implemented in different ways. Here is one:\n\nFirst the wallet signs two messages with each private key: the tx and a smallproof msg.\nWe make 0-conf outputs require anything tha,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49067681,49067681,
SergioDemianLerner,2014-07-15T17:56:04Z,"I think the smallproof idea deserves a more formal presentation because this is not the appropriate place to do it, so I will describe it in more detail in the mailing-list.\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49068847,49068847,
petertodd,2014-07-15T17:56:36Z,"@SergioDemianLerner Your method requires a soft-fork to be secure. I could easily make a Bitcoin Core fork that treats those outputs as standard without the smallproof message; Eligius among others would happily accept them. My scriptSig relaying mechanism OTOH works regardless of what policy miners follow, and with scorched-earth, gives them incentives to ""defect"" and broadcast double-spend proof",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49068925,49068925,
dgenr8,2014-07-15T18:46:19Z,"This change has about the smallest footprint possible for what it achieves.  KISS.\n\nThe problem with an as-yet unimplemented Better Solution is that it is not implemented, or even really designed.  If it is implemented, it will be subject to the same level scrutiny, and it sounds like it has a MUCH larger footprint than this one.  There will be more bugs, not less.  There will be more risks.\n\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49075375,49075375,
dgenr8,2014-07-15T19:30:22Z,These special alert ideas require the cooperation of the creating wallet?  tx relay is so much better than that!\n\nHighlighting another advantage that we discovered as we vetted and completed this change -- it works seamlessly with no additional code when a miner decides to spring a double-spend on the world in a block.  Let's not be too steeped in technology to remember that we are really trying,https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49080939,49080939,
petertodd,2014-07-15T19:54:50Z,"@dgenr8 If it works. Proof-of-stake is much better than proof-of-work, aside from that small problem that it doesn't work...\n\nAnyway, modulo the known bugs, I don't see how tx relay is actively harmful given the throttling.\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49083787,49083787,
dgenr8,2014-07-15T23:20:12Z,"@sipa I agree that we should preserve what 0-conf reliability there is.  Relaying does no harm when nodes, including miners, behave in a core-like way.\n\nTrying to keep respends away from non-core-like nodes is a lost cause -- those miners take direct submissions.  This should not prevent an effort to alert tx1 recipient, and others watching double-spends.\n",https://github.com/bitcoin/bitcoin/pull/4450#issuecomment-49105749,49105749,
gavinandresen,2014-07-02T15:32:27Z,"Are you sure this Does the Right Thing?\n\n""default behavior of a signal that has a return type is to call all slots and then return a boost::optional containing the result returned by the last slot called.""\n\nI'm not deeply familiar with the semantics of boost::optional, but even assuming assigning it to a bool does the right thing (I'm not 100% sure of that-- does assigning an optional&lt;bool&",https://github.com/bitcoin/bitcoin/pull/4450#discussion_r14463812,14463812,src/main.cpp
dgenr8,2014-07-02T15:54:26Z,"In fact it does not, and my earlier tests failed to catch it.  I'm going to turn this into a regular function call until we need multiple slots; hope that's alright.\n",https://github.com/bitcoin/bitcoin/pull/4450#discussion_r14465340,14465340,src/main.cpp
