[
  {
    "sha": "7fabe0f359ae16ed36ce4ca2c33631d038c21448",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZmFiZTBmMzU5YWUxNmVkMzZjZTRjYTJjMzM2MzFkMDM4YzIxNDQ4",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-18T19:30:12Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-12-10T13:41:41Z"
      },
      "message": "net: don't relay to the address' originator\n\nFor each address to be relayed we \"randomly\" pick 2 nodes to send the\naddress to (in `RelayAddress()`). However we do not take into\nconsideration that it does not make sense to relay the address back to\nits originator (`CNode::PushAddress()` will do nothing in that case).\n\nThis means that if the originator is among the \"randomly\" picked nodes,\nthen we will relay to one node less than intended.\n\nFix this by skipping the originating node when choosing candidates to\nrelay to.",
      "tree": {
        "sha": "e5153f361dd446a1f156cb5c208335ec2516f5a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e5153f361dd446a1f156cb5c208335ec2516f5a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7fabe0f359ae16ed36ce4ca2c33631d038c21448",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl/SJZcACgkQVN8G9ktV\ny7+mch//b3YSdLh9tbRgIl+pKU570Yd0/mNgUyE+RcIQWa8EIJd5gxT9uGDJYARJ\n5MJWkg5zUGNN+fdzQ3GfCxBppzAHtEzzUtXkEYzFmXRjTwQ+pkFfoZTzdYR3Z1kX\n2qq7oA2o6Si6mLedPAsh65u+lc4d0e+WYI8sTFnaU8101E0CNOaVQu1p7kfH1FIl\nUkL6FjMFuwuDvrMHxWT2cstH2E36lYcaCX1vv0tfUtB7hEx/3aOOKWaCXU8CZRWX\noJasfEEpJUg2fdFpDt8FPxNu6Kv6eK+wNunpy8pNSzEkG160lBQ92ztFMb9+3928\nkQ7RzucrqGttvmxBnUzoBfF1I3AOSV11qSodzaZvs5lg0gJQnS/FZDrm4BzfKwNL\n0i55BXhVXihPzacx13PFxQme8d2L/xBfIM080J2N/+rVDEuRf61JqFwGt1k9Spvr\ndw+Tr50G/herHHkBwwk2adlenmQpt3wqkUNRISx4NboJUwbqF+5ZuA0koayirnfo\n/6RJF91XczshzOETE0co8KDuNt4VAMQLW7unTz4ETgXVszy8BAn2pDoC3EVHf0s2\nX/pj3VvKAsFiyR7FuoHZRIGbLbTzmUPvkYDGXXdYlrFyJk89Gc95UVNoPSvBS3bQ\nqO7JHxJp89OSrwbBF8+flbIgunkAz7lCtkwO3rjn0MhujDu03KNesyUrrTztQ/ly\nqbg1Fdz6hqhM8kP7tv60ZOn+OfCc0CZrI6qqqS0bz+MfhN4gPHOIUBWnFrFLgMGr\nEl8azuMawZqjQiFk1vH9kSMkgmYii7NUnTjmr47cCa3ofr/r3laUH9k7Jpo6ihgg\nkNqZoVOxBvg3k41SkAk7OE6XK+5GOKsyUs066womqBASitk9A2liebdqtI9wiDPb\n2SDhz1SEuMDQ2V4SEXFvlRxNalD/qlaM5VzXv9s290f5zHofdKAarXgQ42blSKSo\nzHq96yFlOXh4PGYY7ItbJSoPoX0lsSyjPSLdVRkNrodJ4vxO7EKgFLy6ugyBrZFu\n8DlylV/6HBjQkob75V9GQ6UnY6Lu3y70sbC0Z62an44hCkHAh53C27DCkKUSKMYC\nl28tsK8OPu7yvnWuxnMh6UMoyaoKvcDg3Wwrhmgoi3Yawn2SEMjHqBTxyIkJZQ5b\nh8KA0JHn2UxAbi9Hsl7a5fEO73qHiP8V8BI0KI29G/Kn5fsraauW7Yvv7UM+TEKO\n0HzQDibPSDED27Ev1h95zZehRQCFpt9nsPfqI7ATMZ3wwqjXd4LhghrQaC9gVh8O\nwuYJAEx7cdfV7L4IqIoH/D0DyNdJBHf5lSTj9svuNQJfOIacr2P4b+TV1+noS72v\n0z4RCXfgrmll/hxIktYChNsnrdps3Q==\n=3Qol\n-----END PGP SIGNATURE-----",
        "payload": "tree e5153f361dd446a1f156cb5c208335ec2516f5a5\nparent bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2\nauthor Vasil Dimov <vd@FreeBSD.org> 1597779012 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1607607701 +0100\n\nnet: don't relay to the address' originator\n\nFor each address to be relayed we \"randomly\" pick 2 nodes to send the\naddress to (in `RelayAddress()`). However we do not take into\nconsideration that it does not make sense to relay the address back to\nits originator (`CNode::PushAddress()` will do nothing in that case).\n\nThis means that if the originator is among the \"randomly\" picked nodes,\nthen we will relay to one node less than intended.\n\nFix this by skipping the originating node when choosing candidates to\nrelay to.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7fabe0f359ae16ed36ce4ca2c33631d038c21448",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7fabe0f359ae16ed36ce4ca2c33631d038c21448",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7fabe0f359ae16ed36ce4ca2c33631d038c21448/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd60a9a8edd4a3fe2f4f605b77cdae34969eaaf2"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 48,
      "deletions": 13
    },
    "files": [
      {
        "sha": "96cfbc7079bd0311c560c5d4987d4da410630201",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 4,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fabe0f359ae16ed36ce4ca2c33631d038c21448/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fabe0f359ae16ed36ce4ca2c33631d038c21448/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7fabe0f359ae16ed36ce4ca2c33631d038c21448",
        "patch": "@@ -1517,7 +1517,23 @@ void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman&\n     });\n }\n \n-static void RelayAddress(const CAddress& addr, bool fReachable, const CConnman& connman)\n+/**\n+ * Relay (gossip) an address to a few randomly chosen nodes.\n+ * We choose the same nodes within a given 24h window (if the list of connected\n+ * nodes does not change) and we don't relay to nodes that already know an\n+ * address. So within 24h we will likely relay a given address once. This is to\n+ * prevent a peer from unjustly giving their address better propagation by sending\n+ * it to us repeatedly.\n+ * @param[in] originator The peer that sent us the address. We don't want to relay it back.\n+ * @param[in] addr Address to relay.\n+ * @param[in] fReachable Whether the address' network is reachable. We relay unreachable\n+ * addresses less.\n+ * @param[in] connman Connection manager to choose nodes to relay to.\n+ */\n+static void RelayAddress(const CNode& originator,\n+                         const CAddress& addr,\n+                         bool fReachable,\n+                         const CConnman& connman)\n {\n     unsigned int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n \n@@ -1531,8 +1547,8 @@ static void RelayAddress(const CAddress& addr, bool fReachable, const CConnman&\n     std::array<std::pair<uint64_t, CNode*>,2> best{{{0, nullptr}, {0, nullptr}}};\n     assert(nRelayNodes <= best.size());\n \n-    auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n-        if (pnode->RelayAddrsWithConn()) {\n+    auto sortfunc = [&best, &hasher, nRelayNodes, &originator](CNode* pnode) {\n+        if (pnode->RelayAddrsWithConn() && pnode != &originator) {\n             uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n@@ -2637,7 +2653,7 @@ void PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty\n             if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n-                RelayAddress(addr, fReachable, m_connman);\n+                RelayAddress(pfrom, addr, fReachable, m_connman);\n             }\n             // Do not store addresses outside our network\n             if (fReachable)"
      },
      {
        "sha": "91fbd722cf665c9161ecab84cfa24347fe9f5606",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 28,
        "deletions": 9,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7fabe0f359ae16ed36ce4ca2c33631d038c21448/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7fabe0f359ae16ed36ce4ca2c33631d038c21448/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=7fabe0f359ae16ed36ce4ca2c33631d038c21448",
        "patch": "@@ -19,8 +19,11 @@\n )\n import time\n \n+# Keep this with length <= 10. Addresses from larger messages are not relayed.\n ADDRS = []\n-for i in range(10):\n+num_ipv4_addrs = 10\n+\n+for i in range(num_ipv4_addrs):\n     addr = CAddress()\n     addr.time = int(time.time()) + i\n     addr.nServices = NODE_NETWORK | NODE_WITNESS\n@@ -30,11 +33,15 @@\n \n \n class AddrReceiver(P2PInterface):\n+    num_ipv4_received = 0\n+\n     def on_addr(self, message):\n         for addr in message.addrs:\n             assert_equal(addr.nServices, 9)\n+            if not 8333 <= addr.port < 8343:\n+                raise AssertionError(\"Invalid addr.port of {} (8333-8342 expected)\".format(addr.port))\n             assert addr.ip.startswith('123.123.123.')\n-            assert (8333 <= addr.port < 8343)\n+            self.num_ipv4_received += 1\n \n \n class AddrTest(BitcoinTestFramework):\n@@ -48,21 +55,33 @@ def run_test(self):\n         msg = msg_addr()\n \n         self.log.info('Send too-large addr message')\n-        msg.addrs = ADDRS * 101\n+        msg.addrs = ADDRS * 101  # more than 1000 addresses in one message\n         with self.nodes[0].assert_debug_log(['addr message size = 1010']):\n             addr_source.send_and_ping(msg)\n \n         self.log.info('Check that addr message content is relayed and added to addrman')\n-        addr_receiver = self.nodes[0].add_p2p_connection(AddrReceiver())\n+        num_receivers = 7\n+        receivers = []\n+        for _ in range(num_receivers):\n+            receivers.append(self.nodes[0].add_p2p_connection(AddrReceiver()))\n         msg.addrs = ADDRS\n-        with self.nodes[0].assert_debug_log([\n-                'Added 10 addresses from 127.0.0.1: 0 tried',\n+        with self.nodes[0].assert_debug_log(\n+            [\n+                'Added {} addresses from 127.0.0.1: 0 tried'.format(num_ipv4_addrs),\n                 'received: addr (301 bytes) peer=0',\n-                'sending addr (301 bytes) peer=1',\n-        ]):\n+            ]\n+        ):\n             addr_source.send_and_ping(msg)\n             self.nodes[0].setmocktime(int(time.time()) + 30 * 60)\n-            addr_receiver.sync_with_ping()\n+            for receiver in receivers:\n+                receiver.sync_with_ping()\n+\n+        total_ipv4_received = sum(r.num_ipv4_received for r in receivers)\n+\n+        # Every IPv4 address must be relayed to two peers, other than the\n+        # originating node (addr_source).\n+        ipv4_branching_factor = 2\n+        assert_equal(total_ipv4_received, num_ipv4_addrs * ipv4_branching_factor)\n \n \n if __name__ == '__main__':"
      }
    ]
  }
]