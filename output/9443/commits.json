[
  {
    "sha": "5cd334727d127a27983a97c19a4b8135b2f0e48d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2QzMzQ3MjdkMTI3YTI3OTgzYTk3YzE5YTRiODEzNWIyZjBlNDhk",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2017-03-09T05:01:40Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2017-03-09T05:01:40Z"
      },
      "message": "Store invalid nVersion headers and valid header of invalid blocks",
      "tree": {
        "sha": "c5ae0cf6a0a37fcb64a08b929c8e3142eb630e54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5ae0cf6a0a37fcb64a08b929c8e3142eb630e54"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5cd334727d127a27983a97c19a4b8135b2f0e48d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd334727d127a27983a97c19a4b8135b2f0e48d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd334727d127a27983a97c19a4b8135b2f0e48d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd334727d127a27983a97c19a4b8135b2f0e48d/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6996e066b538f03b8aa1f617dbb959b57ff6e727",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6996e066b538f03b8aa1f617dbb959b57ff6e727",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6996e066b538f03b8aa1f617dbb959b57ff6e727"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 39,
      "deletions": 16
    },
    "files": [
      {
        "sha": "55cac98dc71c1edb434f1ddf5531d10d65c211b2",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cd334727d127a27983a97c19a4b8135b2f0e48d/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cd334727d127a27983a97c19a4b8135b2f0e48d/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=5cd334727d127a27983a97c19a4b8135b2f0e48d",
        "patch": "@@ -126,7 +126,8 @@ enum BlockStatus: uint32_t {\n     //! Unused.\n     BLOCK_VALID_UNKNOWN      =    0,\n \n-    //! Parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n+    //! Parsed, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n+    //! Version ok _if_ failed bits are not set\n     BLOCK_VALID_HEADER       =    1,\n \n     //! All parent headers found, difficulty matches, timestamp >= median previous, checkpoint. Implies all parents"
      },
      {
        "sha": "9b344f9edde88283c943fb827f1c47213f2f38e6",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 15,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cd334727d127a27983a97c19a4b8135b2f0e48d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cd334727d127a27983a97c19a4b8135b2f0e48d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5cd334727d127a27983a97c19a4b8135b2f0e48d",
        "patch": "@@ -1286,9 +1286,9 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n     CheckForkWarningConditions();\n }\n \n-void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n-    if (!state.CorruptionPossible()) {\n-        pindex->nStatus |= BLOCK_FAILED_VALID;\n+void static InvalidBlockFound(CBlockIndex *pindex, const bool& corruptionPossible, const unsigned int& nStatus) {\n+    if (!corruptionPossible) {\n+        pindex->nStatus |= nStatus;\n         setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n@@ -2243,7 +2243,7 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n         GetMainSignals().BlockChecked(blockConnecting, state);\n         if (!rv) {\n             if (state.IsInvalid())\n-                InvalidBlockFound(pindexNew, state);\n+                InvalidBlockFound(pindexNew, state.CorruptionPossible(), BLOCK_FAILED_VALID);\n             return error(\"ConnectTip(): ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n         }\n         nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;\n@@ -2628,7 +2628,7 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n     return true;\n }\n \n-CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n+CBlockIndex* AddToBlockIndex(const CBlockHeader& block, const unsigned int& nStatus = BLOCK_VALID_UNKNOWN)\n {\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n@@ -2655,10 +2655,15 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n     pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n-    if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n-        pindexBestHeader = pindexNew;\n-\n-    setDirtyBlockIndex.insert(pindexNew);\n+    if (nStatus & BLOCK_FAILED_MASK)\n+        InvalidBlockFound(pindexNew, false, nStatus);\n+    else {\n+        if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n+            pindexBestHeader = pindexNew;\n+        else\n+            CheckForkWarningConditionsOnNewFork(pindexNew);\n+        setDirtyBlockIndex.insert(pindexNew);\n+    }\n \n     return pindexNew;\n }\n@@ -3053,13 +3058,14 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Co\n     return true;\n }\n \n-static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, const bool& certainlyInvalid = false)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = NULL;\n+    unsigned int nStatus = certainlyInvalid ? BLOCK_FAILED_VALID : BLOCK_VALID_UNKNOWN;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n \n         if (miSelf != mapBlockIndex.end()) {\n@@ -3079,26 +3085,38 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n         CBlockIndex* pindexPrev = NULL;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"bad-prevblk\");\n+            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"bad-prevblk-missing\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            nStatus |= BLOCK_FAILED_CHILD;\n \n         assert(pindexPrev);\n         if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash))\n             return error(\"%s: CheckIndexAgainstCheckpoint(): %s\", __func__, state.GetRejectReason().c_str());\n \n-        if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))\n-            return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+        if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime())) {\n+            if (state.GetRejectCode() == REJECT_OBSOLETE)\n+                nStatus |= BLOCK_FAILED_VALID;\n+            else\n+                return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+        }\n+\n     }\n     if (pindex == NULL)\n-        pindex = AddToBlockIndex(block);\n+        pindex = AddToBlockIndex(block, nStatus);\n \n     if (ppindex)\n         *ppindex = pindex;\n \n     CheckBlockIndex(chainparams.GetConsensus());\n \n+    if (nStatus & BLOCK_FAILED_CHILD)\n+        return state.Invalid(false, REJECT_INVALID, strprintf(\"bad-prevblk-invalid\"),\n+                             strprintf(\"%s: prev block invalid for %s\", __func__, hash.ToString()));\n+\n+    if (state.GetRejectCode() == REJECT_OBSOLETE)\n+        return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+\n     return true;\n }\n \n@@ -3217,6 +3235,10 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n             // Store to disk\n             ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock);\n         }\n+        else {\n+            // Store only the header when CheckBlock() failed\n+            AcceptBlockHeader(*pblock, state, chainparams, &pindex, !state.CorruptionPossible());\n+        }\n         CheckBlockIndex(chainparams.GetConsensus());\n         if (!ret) {\n             GetMainSignals().BlockChecked(*pblock, state);"
      }
    ]
  },
  {
    "sha": "ff1a46d86eaba450857bafe1b4153c1a3b269faa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjFhNDZkODZlYWJhNDUwODU3YmFmZTFiNDE1M2MxYTNiMjY5ZmFh",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-12-29T18:55:13Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2017-03-09T05:01:40Z"
      },
      "message": "Update fork warning messages",
      "tree": {
        "sha": "51d1763c62fca6eaa9f4adcf4594844eb416a69c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/51d1763c62fca6eaa9f4adcf4594844eb416a69c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff1a46d86eaba450857bafe1b4153c1a3b269faa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff1a46d86eaba450857bafe1b4153c1a3b269faa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff1a46d86eaba450857bafe1b4153c1a3b269faa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff1a46d86eaba450857bafe1b4153c1a3b269faa/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5cd334727d127a27983a97c19a4b8135b2f0e48d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd334727d127a27983a97c19a4b8135b2f0e48d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd334727d127a27983a97c19a4b8135b2f0e48d"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 31,
      "deletions": 18
    },
    "files": [
      {
        "sha": "720345d11fff22a7681542187ead80762bc828e1",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 13,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff1a46d86eaba450857bafe1b4153c1a3b269faa/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff1a46d86eaba450857bafe1b4153c1a3b269faa/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ff1a46d86eaba450857bafe1b4153c1a3b269faa",
        "patch": "@@ -1208,32 +1208,45 @@ void CheckForkWarningConditions()\n     if (pindexBestForkTip && chainActive.Height() - pindexBestForkTip->nHeight >= 72)\n         pindexBestForkTip = NULL;\n \n-    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > chainActive.Tip()->nChainWork + (GetBlockProof(*chainActive.Tip()) * 6)))\n+    if (pindexBestForkTip && pindexBestForkBase)\n     {\n-        if (!GetfLargeWorkForkFound() && pindexBestForkBase)\n+        if (!GetfLargeWorkForkFound())\n         {\n             std::string warning = std::string(\"'Warning: Large-work fork detected, forking after block \") +\n-                pindexBestForkBase->phashBlock->ToString() + std::string(\"'\");\n+                pindexBestForkBase->phashBlock->ToString() + std::string(\". Payments confirmed after this block may be unreliable'\");\n             AlertNotify(warning);\n         }\n-        if (pindexBestForkTip && pindexBestForkBase)\n-        {\n-            LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,\n+        LogPrintf(\"%s: Warning: Large-work fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\n  Payments confirmed after the forking block may be unreliable.\\n  Our chain state database may be corrupted, or some miners may be experiencing issues.\\n\", __func__,\n                    pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),\n                    pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString());\n-            SetfLargeWorkForkFound(true);\n+        SetfLargeWorkForkFound(true);\n+    }\n+    else\n+        SetfLargeWorkForkFound(false);\n+\n+    if (pindexBestInvalid && pindexBestInvalid->nChainWork > chainActive.Tip()->nChainWork + (GetBlockProof(*chainActive.Tip()) * 6)) {\n+        CBlockIndex* plonger = pindexBestInvalid;\n+        CBlockIndex* pforkbase = chainActive.Tip();\n+        while (pforkbase && pforkbase != plonger)\n+        {\n+            while (plonger && plonger->nHeight > pforkbase->nHeight)\n+                plonger = plonger->pprev;\n+            if (pforkbase == plonger)\n+                break;\n+            pforkbase = pforkbase->pprev;\n         }\n-        else\n+        if (!GetfLargeWorkInvalidChainFound())\n         {\n-            LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__);\n-            SetfLargeWorkInvalidChainFound(true);\n+            std::string warning = std::string(\"'Warning: Large-work invalid chain detected, forking after block \") +\n+                    pforkbase->phashBlock->ToString() + std::string(\". Payments confirmed after this block may be unreliable'\");\n+            AlertNotify(warning);\n         }\n+        unsigned int nForkLength = ((pindexBestInvalid->nChainWork - chainActive.Tip()->nChainWork) / GetBlockProof(*chainActive.Tip())).getdouble();\n+        LogPrintf(\"%s: Warning: Found invalid chain at least ~%d blocks longer than our best chain.\\n Payments confirmed after the forking block at height %d (%s) may be unreliable.\\n Our chain state database may be corrupted, or different network rules may be accidentally or intentionally enforced by a majority of miners.\\n Be wary when being suggested to upgrade.\\n\", __func__, nForkLength, pforkbase->nHeight, pforkbase->phashBlock->ToString());\n+        SetfLargeWorkInvalidChainFound(true);\n     }\n     else\n-    {\n-        SetfLargeWorkForkFound(false);\n         SetfLargeWorkInvalidChainFound(false);\n-    }\n }\n \n void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)"
      },
      {
        "sha": "de8fd454c834e006fdecbc3f01e1a2cf8291e85f",
        "filename": "src/warnings.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff1a46d86eaba450857bafe1b4153c1a3b269faa/src/warnings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff1a46d86eaba450857bafe1b4153c1a3b269faa/src/warnings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/warnings.cpp?ref=ff1a46d86eaba450857bafe1b4153c1a3b269faa",
        "patch": "@@ -69,13 +69,13 @@ std::string GetWarnings(const std::string& strFor)\n \n     if (fLargeWorkForkFound)\n     {\n-        strStatusBar = strRPC = \"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.\";\n-        strGUI += (strGUI.empty() ? \"\" : uiAlertSeperator) + _(\"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.\");\n+        strStatusBar = strRPC = \"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues. Outgoing and incoming payment may not be reliable! See debug.log for details.\";\n+        strGUI += (strGUI.empty() ? \"\" : uiAlertSeperator) + _(\"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues. Outgoing and incoming payments may not be reliable! See debug.log for details.\");\n     }\n-    else if (fLargeWorkInvalidChainFound)\n+    if (fLargeWorkInvalidChainFound)\n     {\n-        strStatusBar = strRPC = \"Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.\";\n-        strGUI += (strGUI.empty() ? \"\" : uiAlertSeperator) + _(\"Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.\");\n+        strStatusBar = strRPC = \"Warning: Found invalid chain at least 6 blocks longer than our best chain! We do not appear to fully agree with our peers! Outgoing and incoming payment may not be reliable! See debug.log for details.\";\n+        strGUI += (strGUI.empty() ? \"\" : uiAlertSeperator) + _(\"Warning: Found invalid chain at least 6 blocks longer than our best chain! We do not appear to fully agree with our peers! Outgoing and incoming payments may not be reliable! Be wary when being suggested to upgrade! See debug.log for details.\");\n     }\n \n     if (strFor == \"gui\")"
      }
    ]
  },
  {
    "sha": "6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmNkNmEzNjMzYmM3ZTFmZjJiMjRiZmE3NjlkMzAzOGUzYzRiMTdk",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-12-28T14:14:26Z"
      },
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2017-03-09T05:01:40Z"
      },
      "message": "[qa] test fork warning system",
      "tree": {
        "sha": "01e38eff9088464857dc35d3f1e1a0819665ddef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/01e38eff9088464857dc35d3f1e1a0819665ddef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff1a46d86eaba450857bafe1b4153c1a3b269faa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff1a46d86eaba450857bafe1b4153c1a3b269faa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff1a46d86eaba450857bafe1b4153c1a3b269faa"
      }
    ],
    "stats": {
      "total": 302,
      "additions": 300,
      "deletions": 2
    },
    "files": [
      {
        "sha": "7b168e5d2c9b0c85cf1c5cd8921c42a13d6bd8df",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
        "patch": "@@ -41,6 +41,7 @@\n     'p2p-segwit.py',\n     'wallet-dump.py',\n     'listtransactions.py',\n+    'forkwarning.py',\n     # vv Tests less than 60s vv\n     'sendheaders.py',\n     'zapwallettxes.py',"
      },
      {
        "sha": "6338f6d5dfb2873cc62cafd6d84c6c4d8227fc96",
        "filename": "qa/rpc-tests/forkwarning.py",
        "status": "added",
        "additions": 297,
        "deletions": 0,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/qa/rpc-tests/forkwarning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/qa/rpc-tests/forkwarning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/forkwarning.py?ref=6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
        "patch": "@@ -0,0 +1,297 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.blocktools import create_block, create_coinbase\n+\n+'''\n+Test large work fork and large work invalid chain warning\n+'''\n+\n+BASIC_WARNING = \"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\"\n+INVALID_WARNING = \"Warning: Found invalid chain at least 6 blocks longer than our best chain! We do not appear to fully agree with our peers! Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+FORK_WARNING = \"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues. Outgoing and incoming payment may not be reliable! See debug.log for details.\"\n+\n+class BaseNode(SingleNodeConnCB):\n+    def __init__(self):\n+        SingleNodeConnCB.__init__(self)\n+        self.last_inv = None\n+        self.last_headers = None\n+        self.last_block = None\n+        self.last_getdata = None\n+        self.block_announced = False\n+        self.last_getheaders = None\n+        self.disconnected = False\n+        self.last_blockhash_announced = None\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def wait_for_getdata(self, hash_list, timeout=60):\n+        if hash_list == []:\n+            return\n+\n+        test_function = lambda: self.last_getdata != None and [x.hash for x in self.last_getdata.inv] == hash_list\n+        assert(wait_until(test_function, timeout=timeout))\n+        return\n+\n+    def send_header_for_blocks(self, new_blocks):\n+        headers_message = msg_headers()\n+        headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n+        self.send_message(headers_message)\n+\n+\n+# TestNode: This peer is the one we use for most of the testing.\n+class TestNode(BaseNode):\n+    def __init__(self):\n+        BaseNode.__init__(self)\n+\n+class ForkWarningTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n+        with open(self.alert_filename, 'w', encoding='utf8') as f:\n+            pass  # Just open then close to create zero-length file\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n+                                     [\"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]))\n+        self.is_network_split = False\n+\n+    # mine count blocks and return the new tip\n+    def mine_blocks(self, count, node = 0):\n+        # Clear out last block announcement from each p2p listener\n+        self.nodes[node].generate(count)\n+        return int(self.nodes[node].getbestblockhash(), 16)\n+\n+    def run_test(self):\n+        self.test_node = TestNode()\n+        connections = []\n+        connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=0))\n+        self.test_node.add_connection(connections[0])\n+        NetworkThread().start()\n+        self.test_node.wait_for_verack()\n+\n+        # Generate 10 blocks\n+        tip = self.mine_blocks(10)\n+        height = self.nodes[0].getblockcount()\n+        last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+        forkbase = [];\n+        forkbase.append(self.nodes[0].getblock(self.nodes[0].getbestblockhash())['hash'])\n+        block_time = last_time + 1\n+        height += 1\n+\n+        print(\"Test 1: Invalid chain warning\")\n+        # Generate 1 block with valid header but invalid nLockTime coinbase tx\n+        new_block = create_block(tip, create_coinbase(height), block_time)\n+        new_block.vtx[0].nLockTime = 100\n+        new_block.vtx[0].vin[0].nSequence = 0\n+        new_block.vtx[0].rehash()\n+        new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+        new_block.rehash()\n+        new_block.solve()\n+        tip_invalid = new_block.sha256\n+        self.submit_header_and_block(new_block)\n+        assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+\n+        # Build 10 blocks on top of the invalid block (Invalid block 21)\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 10)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 5):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                assert_equal(warning, INVALID_WARNING)\n+\n+        print(\"Test 2: Stop invalid chain warning\")\n+        # Build 20 valid blocks on top of the best valid block (Block 11-30)\n+        height = self.nodes[0].getblockcount()\n+        for j in range(20):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 4):\n+                assert_equal(warning, INVALID_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 15 is found\n+\n+        print(\"Test 3: Large-work fork warning (header only)\")\n+        # Build 10 valid blocks on top of the block 20 to create a valid fork (Block 21a-30a)\n+        height = 20\n+        forkbase.append(self.nodes[0].getblockhash(height))\n+        tip = int(forkbase[1], 16)\n+        new_blocks = []\n+        for j in range(10):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header(new_block)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j >= 7):\n+                assert_equal(warning, FORK_WARNING) # Warning starts when block 28 is found\n+            else:\n+                assert_equal(warning, BASIC_WARNING)\n+\n+        # Submit the blocks\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        print(\"Test 4: Large-work fork warning (orphaning the original chain)\")\n+        # Build 75 valid blocks on top of the block 30a to orphan the original chain (Block 31a-105a)\n+        for j in range(75): # To block 105\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j <= 70):\n+                assert_equal(warning, FORK_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING) # Warning stops when block 103a is found (72 blocks longer)\n+\n+        print(\"Test 5: Large-work fork warning (invalid block with header submitted only)\")\n+        # Build 90 invalid blocks on top of the block 95 to create an invalid fork (Invalid block 96-185)\n+        new_blocks = []\n+        forkbase.append(self.nodes[0].getblockhash(95))\n+        height = 95\n+        tip_invalid = int(forkbase[2], 16)\n+        for j in range(90):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.vtx[0].nLockTime = 96\n+            new_block.vtx[0].vin[0].nSequence = 0\n+            new_block.vtx[0].rehash()\n+            new_block.hashMerkleRoot = new_block.calc_merkle_root()\n+            new_block.rehash()\n+            new_block.solve()\n+            new_blocks.append(new_block)\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 7):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                # Warning starts when block 103 is found since it doesn't know the block is invalid\n+                assert_equal(warning, FORK_WARNING)\n+\n+        # Submit the blocks. Now it knows the first block is invalid, but it doesn't show invalid chain warning because\n+        # only the first block is marked BLOCK_FAILED_VALID\n+        for b in new_blocks:\n+            self.submit_block(b)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 105)\n+            assert_equal(warning, FORK_WARNING)\n+\n+        # Build to 185a to stop the warning\n+        height = self.nodes[0].getblockcount()\n+        for j in range(80):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.solve()\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 71):\n+                assert_equal(warning, FORK_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING)\n+\n+        tip = self.mine_blocks(1080) # build to 1265a to activate BIP66\n+        block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n+        print(\"Test 6: Invalid chain warning by negative version block\")\n+        # Build a version -1 block on 1255a which is now invalid\n+        height = 1255\n+        forkbase.append(self.nodes[0].getblockhash(height))\n+        tip_invalid = int(forkbase[3], 16)\n+        block_time += 1\n+        height += 1\n+        new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+        new_block.nVersion = -1\n+        new_block.solve()\n+        tip_invalid = new_block.sha256\n+        self.submit_header(new_block)\n+        assert_equal(self.nodes[0].getinfo()['blocks'], 1265)\n+\n+        # Build 20 blocks on the negative version block to start the invalid chain warning\n+        for j in range(20):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip_invalid, create_coinbase(height), block_time)\n+            new_block.nVersion = 4;\n+            new_block.solve()\n+            tip_invalid = new_block.sha256\n+            self.submit_header(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], 1265)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 15):\n+                assert_equal(warning, BASIC_WARNING)\n+            else:\n+                assert_equal(warning, INVALID_WARNING)\n+\n+        # Build a valid chain to stop the invalid chain warning\n+        height = self.nodes[0].getblockcount()\n+        for j in range(20):\n+            block_time += 1\n+            height += 1\n+            new_block = create_block(tip, create_coinbase(height), block_time)\n+            new_block.nVersion = 4\n+            new_block.solve()\n+            tip = new_block.sha256\n+            self.submit_header_and_block(new_block)\n+            assert_equal(self.nodes[0].getinfo()['blocks'], height)\n+            warning = self.nodes[0].getinfo()['errors']\n+            if (j < 4):\n+                assert_equal(warning, INVALID_WARNING)\n+            else:\n+                assert_equal(warning, BASIC_WARNING)\n+\n+        with open(self.alert_filename, 'r', encoding='utf8') as f:\n+            alert_text = f.readlines()\n+        assert_equal(len(alert_text), 4) # There should be totally 4 alerts\n+\n+\n+    def submit_header_and_block(self, block):\n+        self.submit_header(block)\n+        #self.test_node.wait_for_getdata([block.sha256], timeout=5)\n+        self.submit_block(block)\n+\n+    def submit_header(self, block):\n+        self.test_node.send_header_for_blocks([block])\n+        self.test_node.sync_with_ping()\n+\n+    def submit_block(self, block):\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+\n+if __name__ == '__main__':\n+    ForkWarningTest().main()"
      },
      {
        "sha": "90cab4fad75fadf08c569776f78bfc16b54b46ca",
        "filename": "qa/rpc-tests/p2p-fullblocktest.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/qa/rpc-tests/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d/qa/rpc-tests/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-fullblocktest.py?ref=6bcd6a3633bc7e1ff2b24bfa769d3038e3c4b17d",
        "patch": "@@ -398,7 +398,7 @@ def update_block(block_number, new_transactions):\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n         b27 = block(27, spend=out[7])\n-        yield rejected(RejectResult(0, b'bad-prevblk'))\n+        yield rejected(RejectResult(16, b'bad-prevblk-invalid'))\n \n         # Now try a too-large-coinbase script\n         tip(15)\n@@ -410,7 +410,7 @@ def update_block(block_number, new_transactions):\n \n         # Extend the b28 chain to make sure bitcoind isn't accepting b28\n         b29 = block(29, spend=out[7])\n-        yield rejected(RejectResult(0, b'bad-prevblk'))\n+        yield rejected(RejectResult(16, b'bad-prevblk-invalid'))\n \n         # b30 has a max-sized coinbase scriptSig.\n         tip(23)"
      }
    ]
  }
]