[
  {
    "sha": "db78f311bab9bd3e660ddd31e12bb2acf2694630",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjc4ZjMxMWJhYjliZDNlNjYwZGRkMzFlMTJiYjJhY2YyNjk0NjMw",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-09-12T18:38:01Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:14:06Z"
      },
      "message": "serialization: teach serializers variadics\n\nAlso add a variadic CDataStream ctor for ease-of-use.",
      "tree": {
        "sha": "15748dd27d3660778ae2201fa3cedaaa07e995a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15748dd27d3660778ae2201fa3cedaaa07e995a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db78f311bab9bd3e660ddd31e12bb2acf2694630",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db78f311bab9bd3e660ddd31e12bb2acf2694630",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db78f311bab9bd3e660ddd31e12bb2acf2694630",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db78f311bab9bd3e660ddd31e12bb2acf2694630/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fcf61b80fa2ce60ee1a806dbf4d4240aa682b879",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fcf61b80fa2ce60ee1a806dbf4d4240aa682b879",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fcf61b80fa2ce60ee1a806dbf4d4240aa682b879"
      }
    ],
    "stats": {
      "total": 127,
      "additions": 126,
      "deletions": 1
    },
    "files": [
      {
        "sha": "82870c45b3b0b5bd59ba93aafd7bbffc011cd009",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db78f311bab9bd3e660ddd31e12bb2acf2694630/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db78f311bab9bd3e660ddd31e12bb2acf2694630/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=db78f311bab9bd3e660ddd31e12bb2acf2694630",
        "patch": "@@ -160,6 +160,7 @@ enum\n };\n \n #define READWRITE(obj)      (::SerReadWrite(s, (obj), nType, nVersion, ser_action))\n+#define READWRITEMANY(...)      (::SerReadWriteMany(s, nType, nVersion, ser_action, __VA_ARGS__))\n \n /** \n  * Implement three methods for serializable objects. These are actually wrappers over\n@@ -960,4 +961,52 @@ class CSizeComputer\n     }\n };\n \n+template<typename Stream>\n+void SerializeMany(Stream& s, int nType, int nVersion)\n+{\n+}\n+\n+template<typename Stream, typename Arg>\n+void SerializeMany(Stream& s, int nType, int nVersion, Arg&& arg)\n+{\n+    ::Serialize(s, std::forward<Arg>(arg), nType, nVersion);\n+}\n+\n+template<typename Stream, typename Arg, typename... Args>\n+void SerializeMany(Stream& s, int nType, int nVersion, Arg&& arg, Args&&... args)\n+{\n+    ::Serialize(s, std::forward<Arg>(arg), nType, nVersion);\n+    ::SerializeMany(s, nType, nVersion, std::forward<Args>(args)...);\n+}\n+\n+template<typename Stream>\n+inline void UnserializeMany(Stream& s, int nType, int nVersion)\n+{\n+}\n+\n+template<typename Stream, typename Arg>\n+inline void UnserializeMany(Stream& s, int nType, int nVersion, Arg& arg)\n+{\n+    ::Unserialize(s, arg, nType, nVersion);\n+}\n+\n+template<typename Stream, typename Arg, typename... Args>\n+inline void UnserializeMany(Stream& s, int nType, int nVersion, Arg& arg, Args&... args)\n+{\n+    ::Unserialize(s, arg, nType, nVersion);\n+    ::UnserializeMany(s, nType, nVersion, args...);\n+}\n+\n+template<typename Stream, typename... Args>\n+inline void SerReadWriteMany(Stream& s, int nType, int nVersion, CSerActionSerialize ser_action, Args&&... args)\n+{\n+    ::SerializeMany(s, nType, nVersion, std::forward<Args>(args)...);\n+}\n+\n+template<typename Stream, typename... Args>\n+inline void SerReadWriteMany(Stream& s, int nType, int nVersion, CSerActionUnserialize ser_action, Args&... args)\n+{\n+    ::UnserializeMany(s, nType, nVersion, args...);\n+}\n+\n #endif // BITCOIN_SERIALIZE_H"
      },
      {
        "sha": "fa001c112accca4260635b097979c7e5e5e56787",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db78f311bab9bd3e660ddd31e12bb2acf2694630/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db78f311bab9bd3e660ddd31e12bb2acf2694630/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=db78f311bab9bd3e660ddd31e12bb2acf2694630",
        "patch": "@@ -112,6 +112,13 @@ class CDataStream\n         Init(nTypeIn, nVersionIn);\n     }\n \n+    template <typename... Args>\n+    CDataStream(int nTypeIn, int nVersionIn, Args&&... args)\n+    {\n+        Init(nTypeIn, nVersionIn);\n+        ::SerializeMany(*this, nType, nVersion, std::forward<Args>(args)...);\n+    }\n+\n     void Init(int nTypeIn, int nVersionIn)\n     {\n         nReadPos = 0;"
      },
      {
        "sha": "4c0fdc77f70beb25454739d01c394329607cd4a1",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 1,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db78f311bab9bd3e660ddd31e12bb2acf2694630/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db78f311bab9bd3e660ddd31e12bb2acf2694630/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=db78f311bab9bd3e660ddd31e12bb2acf2694630",
        "patch": "@@ -10,11 +10,54 @@\n #include <stdint.h>\n \n #include <boost/test/unit_test.hpp>\n-\n using namespace std;\n \n BOOST_FIXTURE_TEST_SUITE(serialize_tests, BasicTestingSetup)\n \n+class CSerializeMethodsTestSingle\n+{\n+protected:\n+    int intval;\n+    bool boolval;\n+    std::string stringval;\n+    const char* charstrval;\n+    CTransaction txval;\n+public:\n+    CSerializeMethodsTestSingle() = default;\n+    CSerializeMethodsTestSingle(int intvalin, bool boolvalin, std::string stringvalin, const char* charstrvalin, CTransaction txvalin) : intval(intvalin), boolval(boolvalin), stringval(std::move(stringvalin)), charstrval(charstrvalin), txval(txvalin){}\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(intval);\n+        READWRITE(boolval);\n+        READWRITE(stringval);\n+        READWRITE(FLATDATA(charstrval));\n+        READWRITE(txval);\n+    }\n+\n+    bool operator==(const CSerializeMethodsTestSingle& rhs)\n+    {\n+        return  intval == rhs.intval && \\\n+                boolval == rhs.boolval && \\\n+                stringval == rhs.stringval && \\\n+                strcmp(charstrval, rhs.charstrval) == 0 && \\\n+                txval == rhs.txval;\n+    }\n+};\n+\n+class CSerializeMethodsTestMany : public CSerializeMethodsTestSingle\n+{\n+public:\n+    using CSerializeMethodsTestSingle::CSerializeMethodsTestSingle;\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITEMANY(intval, boolval, stringval, FLATDATA(charstrval), txval);\n+    }\n+};\n+\n BOOST_AUTO_TEST_CASE(sizes)\n {\n     BOOST_CHECK_EQUAL(sizeof(char), GetSerializeSize(char(0), 0));\n@@ -297,4 +340,30 @@ BOOST_AUTO_TEST_CASE(insert_delete)\n     BOOST_CHECK_EQUAL(ss.size(), 0);\n }\n \n+BOOST_AUTO_TEST_CASE(class_methods)\n+{\n+    int intval(100);\n+    bool boolval(true);\n+    std::string stringval(\"testing\");\n+    const char* charstrval(\"testing charstr\");\n+    CMutableTransaction txval;\n+    CSerializeMethodsTestSingle methodtest1(intval, boolval, stringval, charstrval, txval);\n+    CSerializeMethodsTestMany methodtest2(intval, boolval, stringval, charstrval, txval);\n+    CSerializeMethodsTestSingle methodtest3;\n+    CSerializeMethodsTestMany methodtest4;\n+    CDataStream ss(SER_DISK, PROTOCOL_VERSION);\n+    BOOST_CHECK(methodtest1 == methodtest2);\n+    ss << methodtest1;\n+    ss >> methodtest4;\n+    ss << methodtest2;\n+    ss >> methodtest3;\n+    BOOST_CHECK(methodtest1 == methodtest2);\n+    BOOST_CHECK(methodtest2 == methodtest3);\n+    BOOST_CHECK(methodtest3 == methodtest4);\n+\n+    CDataStream ss2(SER_DISK, PROTOCOL_VERSION, intval, boolval, stringval, FLATDATA(charstrval), txval);\n+    ss2 >> methodtest3;\n+    BOOST_CHECK(methodtest3 == methodtest4);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "462965635e8bf9c2754c27946f8b05560b8ddd84",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NjI5NjU2MzVlOGJmOWMyNzU0YzI3OTQ2ZjhiMDU1NjBiOGRkZDg0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-09-13T00:00:33Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:56:54Z"
      },
      "message": "connman is in charge of pushing messages\n\nThe changes here are dense and subtle, but hopefully all is more explicit\nthan before.\n\n- CConnman is now in charge of sending data rather than the nodes themselves.\n  This is necessary because many decisions need to be made with all nodes in\n  mind, and a model that requires the nodes calling up to their manager quickly\n  turns to spaghetti.\n\n- The per-node-serializer (ssSend) has been replaced with a (quasi-)const\n  send-version. Since the send version for serialization can only change once\n  per connection, we now explicitly tag messages with INIT_PROTO_VERSION if\n  they are sent before the handshake. With this done, there's no need to lock\n  for access to nSendVersion.\n\n  Also, a new stream is used for each message, so there's no need to lock\n  during the serialization process.\n\n- This takes care of accounting for optimistic sends, so the\n  nOptimisticBytesWritten hack can be removed.\n\n- -dropmessagestest and -fuzzmessagestest have not been preserved, as I suspect\n  they haven't been used in years.",
      "tree": {
        "sha": "cbf97b52271e6fb92c101c0edc261d206a00fd0e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cbf97b52271e6fb92c101c0edc261d206a00fd0e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/462965635e8bf9c2754c27946f8b05560b8ddd84",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/462965635e8bf9c2754c27946f8b05560b8ddd84",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/462965635e8bf9c2754c27946f8b05560b8ddd84",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/462965635e8bf9c2754c27946f8b05560b8ddd84/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db78f311bab9bd3e660ddd31e12bb2acf2694630",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db78f311bab9bd3e660ddd31e12bb2acf2694630",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db78f311bab9bd3e660ddd31e12bb2acf2694630"
      }
    ],
    "stats": {
      "total": 167,
      "additions": 135,
      "deletions": 32
    },
    "files": [
      {
        "sha": "4f4c2f06b388ac186f592adc53b81a4ca985db2e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/462965635e8bf9c2754c27946f8b05560b8ddd84/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/462965635e8bf9c2754c27946f8b05560b8ddd84/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=462965635e8bf9c2754c27946f8b05560b8ddd84",
        "patch": "@@ -5036,7 +5036,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\"));\n+            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\"));\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -5056,7 +5056,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (pfrom->nServicesExpected & ~pfrom->nServices)\n         {\n             LogPrint(\"net\", \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, pfrom->nServices, pfrom->nServicesExpected);\n-            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n+            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -5066,7 +5066,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         {\n             // disconnect from peers older than this proto version\n             LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, pfrom->nVersion);\n-            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n+            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -5107,7 +5107,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // Be shy and don't send version until we hear\n         if (pfrom->fInbound)\n-            pfrom->PushVersion();\n+            connman.PushVersion(pfrom, GetAdjustedTime());\n \n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n@@ -5124,8 +5124,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         // Change version\n-        pfrom->PushMessage(NetMsgType::VERACK);\n-        pfrom->ssSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+        connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::VERACK);\n+        pfrom->SetSendVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n \n         if (!pfrom->fInbound)\n         {\n@@ -6375,7 +6375,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman)\n         }\n         catch (const std::ios_base::failure& e)\n         {\n-            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\"));\n+            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\"));\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv"
      },
      {
        "sha": "f271aed242b74701e61abdff91b8b14266a1da23",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 22,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/462965635e8bf9c2754c27946f8b05560b8ddd84/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/462965635e8bf9c2754c27946f8b05560b8ddd84/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=462965635e8bf9c2754c27946f8b05560b8ddd84",
        "patch": "@@ -394,6 +394,9 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n         CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n \n+\n+        PushVersion(pnode, GetTime());\n+\n         GetNodeSignals().InitializeNode(pnode->GetId(), pnode);\n         pnode->AddRef();\n \n@@ -415,6 +418,24 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     return NULL;\n }\n \n+void CConnman::PushVersion(CNode* pnode, int64_t nTime)\n+{\n+    ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n+    CAddress addrYou = (pnode->addr.IsRoutable() && !IsProxy(pnode->addr) ? pnode->addr : CAddress(CService(), pnode->addr.nServices));\n+    CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n+    uint64_t nonce = pnode->GetLocalNonce();\n+    int nNodeStartingHeight = pnode->nMyStartingHeight;\n+    NodeId id = pnode->GetId();\n+\n+    PushMessageWithVersion(pnode, INIT_PROTO_VERSION, NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+            nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes);\n+\n+    if (fLogIPs)\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), id);\n+    else\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), id);\n+}\n+\n void CConnman::DumpBanlist()\n {\n     SweepBanned(); // clean unused entries (if bantime has expired)\n@@ -450,23 +471,6 @@ void CNode::CloseSocketDisconnect()\n         vRecvMsg.clear();\n }\n \n-void CNode::PushVersion()\n-{\n-    int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n-    CAddress addrMe = CAddress(CService(), nLocalServices);\n-    if (fLogIPs)\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nMyStartingHeight, addrMe.ToString(), addrYou.ToString(), id);\n-    else\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nMyStartingHeight, addrMe.ToString(), id);\n-    PushMessage(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalServices, nTime, addrYou, addrMe,\n-                nLocalHostNonce, strSubVersion, nMyStartingHeight, ::fRelayTxes);\n-}\n-\n-\n-\n-\n-\n void CConnman::ClearBanned()\n {\n     {\n@@ -2530,7 +2534,8 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     filterInventoryKnown(50000, 0.000001),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),\n-    nMyStartingHeight(nMyStartingHeightIn)\n+    nMyStartingHeight(nMyStartingHeightIn),\n+    nSendVersion(0)\n {\n     nServices = NODE_NONE;\n     nServicesExpected = NODE_NONE;\n@@ -2587,10 +2592,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n         LogPrint(\"net\", \"Added connection to %s peer=%d\\n\", addrName, id);\n     else\n         LogPrint(\"net\", \"Added connection peer=%d\\n\", id);\n-\n-    // Be shy and don't send version until we hear\n-    if (hSocket != INVALID_SOCKET && !fInbound)\n-        PushVersion();\n }\n \n CNode::~CNode()\n@@ -2696,6 +2697,52 @@ void CNode::EndMessage(const char* pszCommand) UNLOCK_FUNCTION(cs_vSend)\n     LEAVE_CRITICAL_SECTION(cs_vSend);\n }\n \n+CDataStream CConnman::BeginMessage(CNode* pnode, int nVersion, int flags, const std::string& sCommand)\n+{\n+    return {SER_NETWORK, (nVersion ? nVersion : pnode->GetSendVersion()) | flags, CMessageHeader(Params().MessageStart(), sCommand.c_str(), 0) };\n+}\n+\n+void CConnman::EndMessage(CDataStream& strm)\n+{\n+    // Set the size\n+    assert(strm.size () >= CMessageHeader::HEADER_SIZE);\n+    unsigned int nSize = strm.size() - CMessageHeader::HEADER_SIZE;\n+    WriteLE32((uint8_t*)&strm[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n+    // Set the checksum\n+    uint256 hash = Hash(strm.begin() + CMessageHeader::HEADER_SIZE, strm.end());\n+    memcpy((char*)&strm[CMessageHeader::CHECKSUM_OFFSET], hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+\n+}\n+\n+void CConnman::PushMessage(CNode* pnode, CDataStream& strm, const std::string& sCommand)\n+{\n+    if(strm.empty())\n+        return;\n+\n+    unsigned int nSize = strm.size() - CMessageHeader::HEADER_SIZE;\n+    LogPrint(\"net\", \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(sCommand.c_str()), nSize, pnode->id);\n+\n+    size_t nBytesSent = 0;\n+    {\n+        LOCK(pnode->cs_vSend);\n+        if(pnode->hSocket == INVALID_SOCKET) {\n+            return;\n+        }\n+        bool optimisticSend(pnode->vSendMsg.empty());\n+        pnode->vSendMsg.emplace_back(strm.begin(), strm.end());\n+\n+        //log total amount of bytes per command\n+        pnode->mapSendBytesPerMsgCmd[sCommand] += strm.size();\n+        pnode->nSendSize += strm.size();\n+\n+        // If write queue empty, attempt \"optimistic write\"\n+        if (optimisticSend == true)\n+            nBytesSent = SocketSendData(pnode);\n+    }\n+    if (nBytesSent)\n+        RecordBytesSent(nBytesSent);\n+}\n+\n bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n {\n     CNode* found = nullptr;"
      },
      {
        "sha": "c33de9824b411598aacfb2745d0bac758eeaabcd",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 55,
        "deletions": 3,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/462965635e8bf9c2754c27946f8b05560b8ddd84/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/462965635e8bf9c2754c27946f8b05560b8ddd84/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=462965635e8bf9c2754c27946f8b05560b8ddd84",
        "patch": "@@ -136,6 +136,36 @@ class CConnman\n \n     bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n \n+    template <typename... Args>\n+    void PushMessageWithVersionAndFlag(CNode* pnode, int nVersion, int flag, const std::string& sCommand, Args&&... args)\n+    {\n+        auto msg(BeginMessage(pnode, nVersion, flag, sCommand));\n+        ::SerializeMany(msg, msg.nType, msg.nVersion, std::forward<Args>(args)...);\n+        EndMessage(msg);\n+        PushMessage(pnode, msg, sCommand);\n+    }\n+\n+    template <typename... Args>\n+    void PushMessageWithFlag(CNode* pnode, int flag, const std::string& sCommand, Args&&... args)\n+    {\n+        PushMessageWithVersionAndFlag(pnode, 0, flag, sCommand, std::forward<Args>(args)...);\n+    }\n+\n+    template <typename... Args>\n+    void PushMessageWithVersion(CNode* pnode, int nVersion, const std::string& sCommand, Args&&... args)\n+    {\n+        PushMessageWithVersionAndFlag(pnode, nVersion, 0, sCommand, std::forward<Args>(args)...);\n+    }\n+\n+    template <typename... Args>\n+    void PushMessage(CNode* pnode, const std::string& sCommand, Args&&... args)\n+    {\n+        PushMessageWithVersionAndFlag(pnode, 0, 0, sCommand, std::forward<Args>(args)...);\n+    }\n+\n+    void PushVersion(CNode* pnode, int64_t nTime);\n+\n+\n     template<typename Callable>\n     bool ForEachNodeContinueIf(Callable&& func)\n     {\n@@ -345,6 +375,10 @@ class CConnman\n \n     unsigned int GetReceiveFloodSize() const;\n \n+    CDataStream BeginMessage(CNode* node, int nVersion, int flags, const std::string& sCommand);\n+    void PushMessage(CNode* pnode, CDataStream& strm, const std::string& sCommand);\n+    void EndMessage(CDataStream& strm);\n+\n     // Network stats\n     void RecordBytesRecv(uint64_t bytes);\n     void RecordBytesSent(uint64_t bytes);\n@@ -553,6 +587,7 @@ class CNetMessage {\n /** Information about a peer */\n class CNode\n {\n+    friend class CConnman;\n public:\n     // socket\n     ServiceFlags nServices;\n@@ -681,6 +716,7 @@ class CNode\n     // Services offered to this peer\n     const ServiceFlags nLocalServices;\n     const int nMyStartingHeight;\n+    int nSendVersion;\n public:\n \n     NodeId GetId() const {\n@@ -716,6 +752,25 @@ class CNode\n         BOOST_FOREACH(CNetMessage &msg, vRecvMsg)\n             msg.SetVersion(nVersionIn);\n     }\n+    void SetSendVersion(int nVersionIn)\n+    {\n+        // Send version may only be changed in the version message, and\n+        // only one version message is allowed per session. We can therefore\n+        // treat this value as const and even atomic as long as it's only used\n+        // once the handshake is complete. Any attempt to set this twice is an\n+        // error.\n+        assert(nSendVersion == 0);\n+        nSendVersion = nVersionIn;\n+    }\n+\n+    int GetSendVersion() const\n+    {\n+        // The send version should always be explicitly set to\n+        // INIT_PROTO_VERSION rather than using this value until the handshake\n+        // is complete. See PushMessageWithVersion().\n+        assert(nSendVersion != 0);\n+        return nSendVersion;\n+    }\n \n     CNode* AddRef()\n     {\n@@ -787,9 +842,6 @@ class CNode\n     // TODO: Document the precondition of this function.  Is cs_vSend locked?\n     void EndMessage(const char* pszCommand) UNLOCK_FUNCTION(cs_vSend);\n \n-    void PushVersion();\n-\n-\n     void PushMessage(const char* pszCommand)\n     {\n         try"
      },
      {
        "sha": "47979a6f8674731fd7f45c994f64f8f6503de06c",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/462965635e8bf9c2754c27946f8b05560b8ddd84/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/462965635e8bf9c2754c27946f8b05560b8ddd84/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=462965635e8bf9c2754c27946f8b05560b8ddd84",
        "patch": "@@ -49,6 +49,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     connman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, \"\", true);\n+    dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(dummyNode1.GetId(), &dummyNode1);\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n@@ -58,6 +59,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, \"\", true);\n+    dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(dummyNode2.GetId(), &dummyNode2);\n     dummyNode2.nVersion = 1;\n     Misbehaving(dummyNode2.GetId(), 50);\n@@ -75,6 +77,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     mapArgs[\"-banscore\"] = \"111\"; // because 11 is my favorite number\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, \"\", true);\n+    dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(dummyNode1.GetId(), &dummyNode1);\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100);\n@@ -97,6 +100,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n \n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, \"\", true);\n+    dummyNode.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(dummyNode.GetId(), &dummyNode);\n     dummyNode.nVersion = 1;\n "
      }
    ]
  },
  {
    "sha": "a6eff7cf73b266b18659a5e1c5901775924e4674",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNmVmZjdjZjczYjI2NmIxODY1OWE1ZTFjNTkwMTc3NTkyNGU0Njc0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-09-13T00:07:44Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:56:54Z"
      },
      "message": "net: switch all callers to connman for pushing messages\n\nDrop all of the old stuff.",
      "tree": {
        "sha": "e84eda67cd88f8a8a925f13a8f9036f00fb899f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e84eda67cd88f8a8a925f13a8f9036f00fb899f2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6eff7cf73b266b18659a5e1c5901775924e4674",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6eff7cf73b266b18659a5e1c5901775924e4674",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a6eff7cf73b266b18659a5e1c5901775924e4674",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6eff7cf73b266b18659a5e1c5901775924e4674/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "462965635e8bf9c2754c27946f8b05560b8ddd84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/462965635e8bf9c2754c27946f8b05560b8ddd84",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/462965635e8bf9c2754c27946f8b05560b8ddd84"
      }
    ],
    "stats": {
      "total": 343,
      "additions": 49,
      "deletions": 294
    },
    "files": [
      {
        "sha": "aaa7f125f68be27983b6ba90334eda18c440bf27",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 49,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6eff7cf73b266b18659a5e1c5901775924e4674/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6eff7cf73b266b18659a5e1c5901775924e4674/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=a6eff7cf73b266b18659a5e1c5901775924e4674",
        "patch": "@@ -501,15 +501,15 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pf\n         if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n             // As per BIP152, we only get 3 of our peers to announce\n             // blocks using compact encodings.\n-            bool found = connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n-                pnodeStop->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+            bool found = connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n+                connman.PushMessage(pnodeStop, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n                 return true;\n             });\n             if(found)\n                 lNodesAnnouncingHeaderAndIDs.pop_front();\n         }\n         fAnnounceUsingCMPCTBLOCK = true;\n-        pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+        connman.PushMessage(pfrom, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n         lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n     }\n }\n@@ -4889,9 +4889,9 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n-                        pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                        connman.PushMessageWithFlag(pfrom, SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n                     else if (inv.type == MSG_WITNESS_BLOCK)\n-                        pfrom->PushMessage(NetMsgType::BLOCK, block);\n+                        connman.PushMessage(pfrom, NetMsgType::BLOCK, block);\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         bool sendMerkleBlock = false;\n@@ -4904,7 +4904,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             }\n                         }\n                         if (sendMerkleBlock) {\n-                            pfrom->PushMessage(NetMsgType::MERKLEBLOCK, merkleBlock);\n+                            connman.PushMessage(pfrom, NetMsgType::MERKLEBLOCK, merkleBlock);\n                             // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                             // This avoids hurting performance by pointlessly requiring a round-trip\n                             // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -4913,7 +4913,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n-                                pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, block.vtx[pair.first]);\n+                                connman.PushMessageWithFlag(pfrom, SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, block.vtx[pair.first]);\n                         }\n                         // else\n                             // no response\n@@ -4927,9 +4927,9 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n                         if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n                             CBlockHeaderAndShortTxIDs cmpctblock(block, fPeerWantsWitness);\n-                            pfrom->PushMessageWithFlag(fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                            connman.PushMessageWithFlag(pfrom, fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                         } else\n-                            pfrom->PushMessageWithFlag(fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                            connman.PushMessageWithFlag(pfrom, fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -4940,7 +4940,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // wait for other stuff first.\n                         vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n-                        pfrom->PushMessage(NetMsgType::INV, vInv);\n+                        connman.PushMessage(pfrom, NetMsgType::INV, vInv);\n                         pfrom->hashContinue.SetNull();\n                     }\n                 }\n@@ -4951,14 +4951,14 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 bool push = false;\n                 auto mi = mapRelay.find(inv.hash);\n                 if (mi != mapRelay.end()) {\n-                    pfrom->PushMessageWithFlag(inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *mi->second);\n+                    connman.PushMessageWithFlag(pfrom, inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *mi->second);\n                     push = true;\n                 } else if (pfrom->timeLastMempoolReq) {\n                     auto txinfo = mempool.info(inv.hash);\n                     // To protect privacy, do not answer getdata using the mempool when\n                     // that TX couldn't have been INVed in reply to a MEMPOOL request.\n                     if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        pfrom->PushMessageWithFlag(inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *txinfo.tx);\n+                        connman.PushMessageWithFlag(pfrom, inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *txinfo.tx);\n                         push = true;\n                     }\n                 }\n@@ -4985,7 +4985,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n         // do that because they want to know about (and store and rebroadcast and\n         // risk analyze) the dependencies of transactions relevant to them, without\n         // having to download the entire memory pool.\n-        pfrom->PushMessage(NetMsgType::NOTFOUND, vNotFound);\n+        connman.PushMessage(pfrom, NetMsgType::NOTFOUND, vNotFound);\n     }\n }\n \n@@ -5148,7 +5148,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // Get recent addresses\n             if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman.GetAddressCount() < 1000)\n             {\n-                pfrom->PushMessage(NetMsgType::GETADDR);\n+                connman.PushMessage(pfrom, NetMsgType::GETADDR);\n                 pfrom->fGetAddr = true;\n             }\n             connman.MarkAddressGood(pfrom->addr);\n@@ -5195,7 +5195,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            pfrom->PushMessage(NetMsgType::SENDHEADERS);\n+            connman.PushMessage(pfrom, NetMsgType::SENDHEADERS);\n         }\n         if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n@@ -5206,9 +5206,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n             if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+                connman.PushMessage(pfrom, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n             nCMPCTBLOCKVersion = 1;\n-            pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+            connman.PushMessage(pfrom, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n         }\n     }\n \n@@ -5336,7 +5336,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // time the block arrives, the header chain leading up to it is already validated. Not\n                     // doing this will result in the received block being rejected as an orphan in case it is\n                     // not a direct successor.\n-                    pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash);\n+                    connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash);\n                     CNodeState *nodestate = State(pfrom->GetId());\n                     if (CanDirectFetch(chainparams.GetConsensus()) &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER &&\n@@ -5372,7 +5372,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         if (!vToFetch.empty())\n-            pfrom->PushMessage(NetMsgType::GETDATA, vToFetch);\n+            connman.PushMessage(pfrom, NetMsgType::GETDATA, vToFetch);\n     }\n \n \n@@ -5472,7 +5472,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n             resp.txn[i] = block.vtx[req.indexes[i]];\n         }\n-        pfrom->PushMessageWithFlag(State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n+        connman.PushMessageWithFlag(pfrom, State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n     }\n \n \n@@ -5521,7 +5521,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n-        pfrom->PushMessage(NetMsgType::HEADERS, vHeaders);\n+        connman.PushMessage(pfrom, NetMsgType::HEADERS, vHeaders);\n     }\n \n \n@@ -5684,7 +5684,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 pfrom->id,\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n-                pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                connman.PushMessage(pfrom, NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n             if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n@@ -5704,7 +5704,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n-                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+                connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n             return true;\n         }\n \n@@ -5737,7 +5737,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                connman.PushMessage(pfrom, NetMsgType::GETDATA, vInv);\n             }\n             return true;\n         }\n@@ -5781,7 +5781,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    connman.PushMessage(pfrom, NetMsgType::GETDATA, vInv);\n                     return true;\n                 }\n \n@@ -5805,7 +5805,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman);\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                    connman.PushMessage(pfrom, NetMsgType::GETBLOCKTXN, req);\n                 }\n             }\n         } else {\n@@ -5814,7 +5814,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                connman.PushMessage(pfrom, NetMsgType::GETDATA, vInv);\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -5858,7 +5858,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n-                pfrom->PushMessage(NetMsgType::GETDATA, invs);\n+                connman.PushMessage(pfrom, NetMsgType::GETDATA, invs);\n             } else\n                 fBlockRead = true;\n         } // Don't hold cs_main when we call into ProcessNewBlock\n@@ -5868,7 +5868,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             int nDoS;\n             if (state.IsInvalid(nDoS)) {\n                 assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n-                pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                connman.PushMessage(pfrom, NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n                 if (nDoS > 0) {\n                     LOCK(cs_main);\n@@ -5916,7 +5916,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n             LogPrint(\"net\", \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -5963,7 +5963,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n-            pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256());\n+            connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256());\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -6016,7 +6016,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n-                    pfrom->PushMessage(NetMsgType::GETDATA, vGetData);\n+                    connman.PushMessage(pfrom, NetMsgType::GETDATA, vGetData);\n                 }\n             }\n         }\n@@ -6044,7 +6044,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n-            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+            connman.PushMessage(pfrom, NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n             if (nDoS > 0) {\n                 LOCK(cs_main);\n@@ -6121,7 +6121,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            pfrom->PushMessage(NetMsgType::PONG, nonce);\n+            connman.PushMessage(pfrom, NetMsgType::PONG, nonce);\n         }\n     }\n \n@@ -6464,11 +6464,11 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             pto->nPingUsecStart = GetTimeMicros();\n             if (pto->nVersion > BIP0031_VERSION) {\n                 pto->nPingNonceSent = nonce;\n-                pto->PushMessage(NetMsgType::PING, nonce);\n+                connman.PushMessage(pto, NetMsgType::PING, nonce);\n             } else {\n                 // Peer is too old to support ping command with nonce, pong will never arrive.\n                 pto->nPingNonceSent = 0;\n-                pto->PushMessage(NetMsgType::PING);\n+                connman.PushMessage(pto, NetMsgType::PING);\n             }\n         }\n \n@@ -6499,14 +6499,14 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     // receiver rejects addr messages larger than 1000\n                     if (vAddr.size() >= 1000)\n                     {\n-                        pto->PushMessage(NetMsgType::ADDR, vAddr);\n+                        connman.PushMessage(pto, NetMsgType::ADDR, vAddr);\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                pto->PushMessage(NetMsgType::ADDR, vAddr);\n+                connman.PushMessage(pto, NetMsgType::ADDR, vAddr);\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();\n@@ -6529,7 +6529,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         }\n \n         BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            pto->PushMessage(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n+            connman.PushMessage(pto, NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n         state.rejects.clear();\n \n         // Start block sync\n@@ -6552,7 +6552,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n-                pto->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256());\n+                connman.PushMessage(pto, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256());\n             }\n         }\n \n@@ -6641,7 +6641,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     CBlock block;\n                     assert(ReadBlockFromDisk(block, pBestIndex, consensusParams));\n                     CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                    pto->PushMessageWithFlag(state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                    connman.PushMessageWithFlag(pto, state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {\n@@ -6653,7 +6653,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                         LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n                                 vHeaders.front().GetHash().ToString(), pto->id);\n                     }\n-                    pto->PushMessage(NetMsgType::HEADERS, vHeaders);\n+                    connman.PushMessage(pto, NetMsgType::HEADERS, vHeaders);\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n@@ -6699,7 +6699,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             BOOST_FOREACH(const uint256& hash, pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n-                    pto->PushMessage(NetMsgType::INV, vInv);\n+                    connman.PushMessage(pto, NetMsgType::INV, vInv);\n                     vInv.clear();\n                 }\n             }\n@@ -6745,7 +6745,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     pto->filterInventoryKnown.insert(hash);\n                     vInv.push_back(inv);\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        pto->PushMessage(NetMsgType::INV, vInv);\n+                        connman.PushMessage(pto, NetMsgType::INV, vInv);\n                         vInv.clear();\n                     }\n                 }\n@@ -6811,15 +6811,15 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                         }\n                     }\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        pto->PushMessage(NetMsgType::INV, vInv);\n+                        connman.PushMessage(pto, NetMsgType::INV, vInv);\n                         vInv.clear();\n                     }\n                     pto->filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n         if (!vInv.empty())\n-            pto->PushMessage(NetMsgType::INV, vInv);\n+            connman.PushMessage(pto, NetMsgType::INV, vInv);\n \n         // Detect whether we're stalling\n         nNow = GetTimeMicros();\n@@ -6880,7 +6880,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {\n-                    pto->PushMessage(NetMsgType::GETDATA, vGetData);\n+                    connman.PushMessage(pto, NetMsgType::GETDATA, vGetData);\n                     vGetData.clear();\n                 }\n             } else {\n@@ -6890,7 +6890,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n         if (!vGetData.empty())\n-            pto->PushMessage(NetMsgType::GETDATA, vGetData);\n+            connman.PushMessage(pto, NetMsgType::GETDATA, vGetData);\n \n         //\n         // Message: feefilter\n@@ -6903,7 +6903,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             if (timeNow > pto->nextSendTimeFeeFilter) {\n                 CAmount filterToSend = filterRounder.round(currentFilter);\n                 if (filterToSend != pto->lastSentFeeFilter) {\n-                    pto->PushMessage(NetMsgType::FEEFILTER, filterToSend);\n+                    connman.PushMessage(pto, NetMsgType::FEEFILTER, filterToSend);\n                     pto->lastSentFeeFilter = filterToSend;\n                 }\n                 pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);"
      },
      {
        "sha": "2cc14a222391eeb1bccd43a481533cc99a9ed929",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 61,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6eff7cf73b266b18659a5e1c5901775924e4674/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6eff7cf73b266b18659a5e1c5901775924e4674/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a6eff7cf73b266b18659a5e1c5901775924e4674",
        "patch": "@@ -2636,67 +2636,6 @@ void CNode::AskFor(const CInv& inv)\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n-void CNode::BeginMessage(const char* pszCommand) EXCLUSIVE_LOCK_FUNCTION(cs_vSend)\n-{\n-    ENTER_CRITICAL_SECTION(cs_vSend);\n-    assert(ssSend.size() == 0);\n-    ssSend << CMessageHeader(Params().MessageStart(), pszCommand, 0);\n-    LogPrint(\"net\", \"sending: %s \", SanitizeString(pszCommand));\n-}\n-\n-void CNode::AbortMessage() UNLOCK_FUNCTION(cs_vSend)\n-{\n-    ssSend.clear();\n-\n-    LEAVE_CRITICAL_SECTION(cs_vSend);\n-\n-    LogPrint(\"net\", \"(aborted)\\n\");\n-}\n-\n-void CNode::EndMessage(const char* pszCommand) UNLOCK_FUNCTION(cs_vSend)\n-{\n-    // The -*messagestest options are intentionally not documented in the help message,\n-    // since they are only used during development to debug the networking code and are\n-    // not intended for end-users.\n-    if (mapArgs.count(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 2)) == 0)\n-    {\n-        LogPrint(\"net\", \"dropmessages DROPPING SEND MESSAGE\\n\");\n-        AbortMessage();\n-        return;\n-    }\n-    if (mapArgs.count(\"-fuzzmessagestest\"))\n-        Fuzz(GetArg(\"-fuzzmessagestest\", 10));\n-\n-    if (ssSend.size() == 0)\n-    {\n-        LEAVE_CRITICAL_SECTION(cs_vSend);\n-        return;\n-    }\n-    // Set the size\n-    unsigned int nSize = ssSend.size() - CMessageHeader::HEADER_SIZE;\n-    WriteLE32((uint8_t*)&ssSend[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n-\n-    //log total amount of bytes per command\n-    mapSendBytesPerMsgCmd[std::string(pszCommand)] += nSize + CMessageHeader::HEADER_SIZE;\n-\n-    // Set the checksum\n-    uint256 hash = Hash(ssSend.begin() + CMessageHeader::HEADER_SIZE, ssSend.end());\n-    assert(ssSend.size () >= CMessageHeader::CHECKSUM_OFFSET + CMessageHeader::CHECKSUM_SIZE);\n-    memcpy((char*)&ssSend[CMessageHeader::CHECKSUM_OFFSET], hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n-\n-    LogPrint(\"net\", \"(%d bytes) peer=%d\\n\", nSize, id);\n-\n-    std::deque<CSerializeData>::iterator it = vSendMsg.insert(vSendMsg.end(), CSerializeData());\n-    ssSend.GetAndClear(*it);\n-    nSendSize += (*it).size();\n-\n-    // If write queue empty, attempt \"optimistic write\"\n-    if (it == vSendMsg.begin())\n-        nOptimisticBytesWritten += SocketSendData(this);\n-\n-    LEAVE_CRITICAL_SECTION(cs_vSend);\n-}\n-\n CDataStream CConnman::BeginMessage(CNode* pnode, int nVersion, int flags, const std::string& sCommand)\n {\n     return {SER_NETWORK, (nVersion ? nVersion : pnode->GetSendVersion()) | flags, CMessageHeader(Params().MessageStart(), sCommand.c_str(), 0) };"
      },
      {
        "sha": "559c22bbd3f93d3d9387c3c16bab573cfd9a3e8e",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 184,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6eff7cf73b266b18659a5e1c5901775924e4674/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6eff7cf73b266b18659a5e1c5901775924e4674/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a6eff7cf73b266b18659a5e1c5901775924e4674",
        "patch": "@@ -833,190 +833,6 @@ class CNode\n \n     void AskFor(const CInv& inv);\n \n-    // TODO: Document the postcondition of this function.  Is cs_vSend locked?\n-    void BeginMessage(const char* pszCommand) EXCLUSIVE_LOCK_FUNCTION(cs_vSend);\n-\n-    // TODO: Document the precondition of this function.  Is cs_vSend locked?\n-    void AbortMessage() UNLOCK_FUNCTION(cs_vSend);\n-\n-    // TODO: Document the precondition of this function.  Is cs_vSend locked?\n-    void EndMessage(const char* pszCommand) UNLOCK_FUNCTION(cs_vSend);\n-\n-    void PushMessage(const char* pszCommand)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1>\n-    void PushMessage(const char* pszCommand, const T1& a1)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    /** Send a message containing a1, serialized with flag flag. */\n-    template<typename T1>\n-    void PushMessageWithFlag(int flag, const char* pszCommand, const T1& a1)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            WithOrVersion(&ssSend, flag) << a1;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3, typename T4>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3 << a4;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3, typename T4, typename T5>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3 << a4 << a5;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3 << a4 << a5 << a6;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3 << a4 << a5 << a6 << a7;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n-    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8, const T9& a9)\n-    {\n-        try\n-        {\n-            BeginMessage(pszCommand);\n-            ssSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8 << a9;\n-            EndMessage(pszCommand);\n-        }\n-        catch (...)\n-        {\n-            AbortMessage();\n-            throw;\n-        }\n-    }\n-\n     void CloseSocketDisconnect();\n \n     void copyStats(CNodeStats &stats);"
      }
    ]
  },
  {
    "sha": "7f10bc8a76ebfd95b3d86db945746a00818f25ae",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjEwYmM4YTc2ZWJmZDk1YjNkODZkYjk0NTc0NmEwMDgxOGYyNWFl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-09-13T00:09:24Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:56:54Z"
      },
      "message": "drop the optimistic write counter hack\n\nThis is now handled properly in realtime.",
      "tree": {
        "sha": "fe2861b25e6024f6b04f7ca4a42c6a3ab35a96b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe2861b25e6024f6b04f7ca4a42c6a3ab35a96b2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f10bc8a76ebfd95b3d86db945746a00818f25ae",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f10bc8a76ebfd95b3d86db945746a00818f25ae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f10bc8a76ebfd95b3d86db945746a00818f25ae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f10bc8a76ebfd95b3d86db945746a00818f25ae/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a6eff7cf73b266b18659a5e1c5901775924e4674",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6eff7cf73b266b18659a5e1c5901775924e4674",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a6eff7cf73b266b18659a5e1c5901775924e4674"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 0,
      "deletions": 6
    },
    "files": [
      {
        "sha": "2d6573f7f0731b79d984a06fe7adacb9d6cc16c8",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f10bc8a76ebfd95b3d86db945746a00818f25ae/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f10bc8a76ebfd95b3d86db945746a00818f25ae/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7f10bc8a76ebfd95b3d86db945746a00818f25ae",
        "patch": "@@ -1167,10 +1167,6 @@ void CConnman::ThreadSocketHandler()\n                 {\n                     TRY_LOCK(pnode->cs_vSend, lockSend);\n                     if (lockSend) {\n-                        if (pnode->nOptimisticBytesWritten) {\n-                            RecordBytesSent(pnode->nOptimisticBytesWritten);\n-                            pnode->nOptimisticBytesWritten = 0;\n-                        }\n                         if (!pnode->vSendMsg.empty()) {\n                             FD_SET(pnode->hSocket, &fdsetSend);\n                             continue;\n@@ -2582,7 +2578,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     minFeeFilter = 0;\n     lastSentFeeFilter = 0;\n     nextSendTimeFeeFilter = 0;\n-    nOptimisticBytesWritten = 0;\n \n     BOOST_FOREACH(const std::string &msg, getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;"
      },
      {
        "sha": "3f9efbbea3b5dbb4a2f9b7471835e81a46ccd678",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f10bc8a76ebfd95b3d86db945746a00818f25ae/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f10bc8a76ebfd95b3d86db945746a00818f25ae/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7f10bc8a76ebfd95b3d86db945746a00818f25ae",
        "patch": "@@ -596,7 +596,6 @@ class CNode\n     CDataStream ssSend;\n     size_t nSendSize; // total size of all vSendMsg entries\n     size_t nSendOffset; // offset inside the first vSendMsg already sent\n-    uint64_t nOptimisticBytesWritten;\n     uint64_t nSendBytes;\n     std::deque<CSerializeData> vSendMsg;\n     CCriticalSection cs_vSend;"
      }
    ]
  },
  {
    "sha": "22f2af6997016bbc626030dfd90d9ba57749ccaf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMmYyYWY2OTk3MDE2YmJjNjI2MDMwZGZkOTBkOWJhNTc3NDljY2Fm",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-09-30T19:03:57Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:56:54Z"
      },
      "message": "net: remove now-unused ssSend and Fuzz",
      "tree": {
        "sha": "10e81a06aafdc1f1322a2756574efa411be0fc24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10e81a06aafdc1f1322a2756574efa411be0fc24"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/22f2af6997016bbc626030dfd90d9ba57749ccaf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22f2af6997016bbc626030dfd90d9ba57749ccaf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/22f2af6997016bbc626030dfd90d9ba57749ccaf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22f2af6997016bbc626030dfd90d9ba57749ccaf/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7f10bc8a76ebfd95b3d86db945746a00818f25ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f10bc8a76ebfd95b3d86db945746a00818f25ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7f10bc8a76ebfd95b3d86db945746a00818f25ae"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 1,
      "deletions": 41
    },
    "files": [
      {
        "sha": "16d9527eeb2fa1adfb4cef5edcb710586c915cce",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 37,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/22f2af6997016bbc626030dfd90d9ba57749ccaf/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/22f2af6997016bbc626030dfd90d9ba57749ccaf/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=22f2af6997016bbc626030dfd90d9ba57749ccaf",
        "patch": "@@ -1063,7 +1063,7 @@ void CConnman::ThreadSocketHandler()\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n             {\n                 if (pnode->fDisconnect ||\n-                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->nSendSize == 0 && pnode->ssSend.empty()))\n+                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->nSendSize == 0))\n                 {\n                     // remove from vNodes\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n@@ -2482,46 +2482,10 @@ int CConnman::GetBestHeight() const\n     return nBestHeight.load(std::memory_order_acquire);\n }\n \n-void CNode::Fuzz(int nChance)\n-{\n-    if (!fSuccessfullyConnected) return; // Don't fuzz initial handshake\n-    if (GetRand(nChance) != 0) return; // Fuzz 1 of every nChance messages\n-\n-    switch (GetRand(3))\n-    {\n-    case 0:\n-        // xor a random byte with a random value:\n-        if (!ssSend.empty()) {\n-            CDataStream::size_type pos = GetRand(ssSend.size());\n-            ssSend[pos] ^= (unsigned char)(GetRand(256));\n-        }\n-        break;\n-    case 1:\n-        // delete a random byte:\n-        if (!ssSend.empty()) {\n-            CDataStream::size_type pos = GetRand(ssSend.size());\n-            ssSend.erase(ssSend.begin()+pos);\n-        }\n-        break;\n-    case 2:\n-        // insert a random byte at a random position\n-        {\n-            CDataStream::size_type pos = GetRand(ssSend.size());\n-            char ch = (char)GetRand(256);\n-            ssSend.insert(ssSend.begin()+pos, ch);\n-        }\n-        break;\n-    }\n-    // Chance of more than one change half the time:\n-    // (more changes exponentially less likely):\n-    Fuzz(2);\n-}\n-\n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n unsigned int CConnman::GetSendBufferSize() const{ return nSendBufferMaxSize; }\n \n CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const std::string& addrNameIn, bool fInboundIn) :\n-    ssSend(SER_NETWORK, INIT_PROTO_VERSION),\n     addr(addrIn),\n     fInbound(fInboundIn),\n     id(idIn),"
      },
      {
        "sha": "99ca5bc0db3e33b9d716d1ab3da2f7fa043ebf33",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/22f2af6997016bbc626030dfd90d9ba57749ccaf/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/22f2af6997016bbc626030dfd90d9ba57749ccaf/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=22f2af6997016bbc626030dfd90d9ba57749ccaf",
        "patch": "@@ -593,7 +593,6 @@ class CNode\n     ServiceFlags nServices;\n     ServiceFlags nServicesExpected;\n     SOCKET hSocket;\n-    CDataStream ssSend;\n     size_t nSendSize; // total size of all vSendMsg entries\n     size_t nSendOffset; // offset inside the first vSendMsg already sent\n     uint64_t nSendBytes;\n@@ -645,9 +644,6 @@ class CNode\n     mapMsgCmdSize mapSendBytesPerMsgCmd;\n     mapMsgCmdSize mapRecvBytesPerMsgCmd;\n \n-    // Basic fuzz-testing\n-    void Fuzz(int nChance); // modifies ssSend\n-\n public:\n     uint256 hashContinue;\n     int nStartingHeight;"
      }
    ]
  },
  {
    "sha": "6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmEyNjdjMTcwMmY4MDMwMmRiZmJjZGJiNmY0YzMxN2E1MWI1Njg0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-10-26T21:41:44Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:56:54Z"
      },
      "message": "net: construct CNodeStates in place",
      "tree": {
        "sha": "5ebf7cdce979b296ad027a87f6b3dc5e3b676d36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ebf7cdce979b296ad027a87f6b3dc5e3b676d36"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ba267c1702f80302dbfbcdbb6f4c317a51b5684/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "22f2af6997016bbc626030dfd90d9ba57749ccaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22f2af6997016bbc626030dfd90d9ba57749ccaf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/22f2af6997016bbc626030dfd90d9ba57749ccaf"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 6,
      "deletions": 6
    },
    "files": [
      {
        "sha": "1dc4c59a154567d9ba3ed91651903a951dd7d48e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6ba267c1702f80302dbfbcdbb6f4c317a51b5684/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6ba267c1702f80302dbfbcdbb6f4c317a51b5684/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
        "patch": "@@ -257,15 +257,15 @@ struct CBlockReject {\n  */\n struct CNodeState {\n     //! The peer's address\n-    CService address;\n+    const CService address;\n     //! Whether we have a fully established connection.\n     bool fCurrentlyConnected;\n     //! Accumulated misbehaviour score for this peer.\n     int nMisbehavior;\n     //! Whether this peer should be disconnected and banned (unless whitelisted).\n     bool fShouldBan;\n     //! String name of this peer (debugging/logging purposes).\n-    std::string name;\n+    const std::string name;\n     //! List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n@@ -309,7 +309,7 @@ struct CNodeState {\n      */\n     bool fSupportsDesiredCmpctVersion;\n \n-    CNodeState() {\n+    CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n         fShouldBan = false;\n@@ -355,10 +355,10 @@ void UpdatePreferredDownload(CNode* node, CNodeState* state)\n }\n \n void InitializeNode(NodeId nodeid, const CNode *pnode) {\n+    CAddress addr = pnode->addr;\n+    std::string addrName = pnode->addrName;\n     LOCK(cs_main);\n-    CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;\n-    state.name = pnode->addrName;\n-    state.address = pnode->addr;\n+    mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n }\n \n void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {"
      }
    ]
  },
  {
    "sha": "c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjN2I4ZWZmYjk2NzI2YmE1MzY3YTdiMWM5YzczNzRjNGQyY2MxMGUy",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-10-26T22:08:11Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-03T13:56:54Z"
      },
      "message": "net: handle version push in InitializeNode",
      "tree": {
        "sha": "9cc148f8361f54609ae909cdfe4fa4f7e86c98dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9cc148f8361f54609ae909cdfe4fa4f7e86c98dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6ba267c1702f80302dbfbcdbb6f4c317a51b5684",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6ba267c1702f80302dbfbcdbb6f4c317a51b5684"
      }
    ],
    "stats": {
      "total": 85,
      "additions": 44,
      "deletions": 41
    },
    "files": [
      {
        "sha": "7e5baefc176f2d845dfc70169bb3c386e9aeddee",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 4,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
        "patch": "@@ -18,6 +18,7 @@\n #include \"init.h\"\n #include \"merkleblock.h\"\n #include \"net.h\"\n+#include \"netbase.h\"\n #include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"pow.h\"\n@@ -354,11 +355,36 @@ void UpdatePreferredDownload(CNode* node, CNodeState* state)\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-void InitializeNode(NodeId nodeid, const CNode *pnode) {\n+void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n+{\n+    ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n+    uint64_t nonce = pnode->GetLocalNonce();\n+    int nNodeStartingHeight = pnode->GetMyStartingHeight();\n+    NodeId nodeid = pnode->GetId();\n+    CAddress addr = pnode->addr;\n+\n+    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n+    CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n+\n+    connman.PushMessageWithVersion(pnode, INIT_PROTO_VERSION, NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+            nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes);\n+\n+    if (fLogIPs)\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n+    else\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), nodeid);\n+}\n+\n+void InitializeNode(CNode *pnode, CConnman& connman) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->addrName;\n-    LOCK(cs_main);\n-    mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n+    NodeId nodeid = pnode->GetId();\n+    {\n+        LOCK(cs_main);\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n+    }\n+    if(!pnode->fInbound)\n+        PushNodeVersion(pnode, connman, GetTime());\n }\n \n void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n@@ -5107,7 +5133,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // Be shy and don't send version until we hear\n         if (pfrom->fInbound)\n-            connman.PushVersion(pfrom, GetAdjustedTime());\n+            PushNodeVersion(pfrom, connman, GetAdjustedTime());\n \n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n "
      },
      {
        "sha": "15cf7ce8b2ba8551d98b93a684992a38b39f1a39",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 29,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
        "patch": "@@ -393,21 +393,15 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         NodeId id = GetNewNodeId();\n         uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n         CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n-\n-\n-        PushVersion(pnode, GetTime());\n-\n-        GetNodeSignals().InitializeNode(pnode->GetId(), pnode);\n+        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n+        pnode->nTimeConnected = GetTime();\n         pnode->AddRef();\n-\n+        GetNodeSignals().InitializeNode(pnode, *this);\n         {\n             LOCK(cs_vNodes);\n             vNodes.push_back(pnode);\n         }\n \n-        pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n-        pnode->nTimeConnected = GetTime();\n-\n         return pnode;\n     } else if (!proxyConnectionFailed) {\n         // If connecting to the node failed, and failure is not caused by a problem connecting to\n@@ -418,24 +412,6 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     return NULL;\n }\n \n-void CConnman::PushVersion(CNode* pnode, int64_t nTime)\n-{\n-    ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n-    CAddress addrYou = (pnode->addr.IsRoutable() && !IsProxy(pnode->addr) ? pnode->addr : CAddress(CService(), pnode->addr.nServices));\n-    CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n-    uint64_t nonce = pnode->GetLocalNonce();\n-    int nNodeStartingHeight = pnode->nMyStartingHeight;\n-    NodeId id = pnode->GetId();\n-\n-    PushMessageWithVersion(pnode, INIT_PROTO_VERSION, NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n-            nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes);\n-\n-    if (fLogIPs)\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), id);\n-    else\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), id);\n-}\n-\n void CConnman::DumpBanlist()\n {\n     SweepBanned(); // clean unused entries (if bantime has expired)\n@@ -1036,9 +1012,9 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n \n     CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, \"\", true);\n-    GetNodeSignals().InitializeNode(pnode->GetId(), pnode);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n+    GetNodeSignals().InitializeNode(pnode, *this);\n \n     LogPrint(\"net\", \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -2130,7 +2106,7 @@ bool CConnman::Start(boost::thread_group& threadGroup, CScheduler& scheduler, st\n         uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n \n         pnodeLocalHost = new CNode(id, nLocalServices, GetBestHeight(), INVALID_SOCKET, CAddress(CService(local, 0), nLocalServices), 0, nonce);\n-        GetNodeSignals().InitializeNode(pnodeLocalHost->GetId(), pnodeLocalHost);\n+        GetNodeSignals().InitializeNode(pnodeLocalHost, *this);\n     }\n \n     //"
      },
      {
        "sha": "22b80fc504cc85127cc21644c385bd5893c4566e",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
        "patch": "@@ -163,9 +163,6 @@ class CConnman\n         PushMessageWithVersionAndFlag(pnode, 0, 0, sCommand, std::forward<Args>(args)...);\n     }\n \n-    void PushVersion(CNode* pnode, int64_t nTime);\n-\n-\n     template<typename Callable>\n     bool ForEachNodeContinueIf(Callable&& func)\n     {\n@@ -462,7 +459,7 @@ struct CNodeSignals\n {\n     boost::signals2::signal<bool (CNode*, CConnman&), CombinerAll> ProcessMessages;\n     boost::signals2::signal<bool (CNode*, CConnman&), CombinerAll> SendMessages;\n-    boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;\n+    boost::signals2::signal<void (CNode*, CConnman&)> InitializeNode;\n     boost::signals2::signal<void (NodeId, bool&)> FinalizeNode;\n };\n \n@@ -722,6 +719,10 @@ class CNode\n       return nLocalHostNonce;\n     }\n \n+    int GetMyStartingHeight() const {\n+      return nMyStartingHeight;\n+    }\n+\n     int GetRefCount()\n     {\n         assert(nRefCount >= 0);"
      },
      {
        "sha": "6eed63608084f971ea8b840bec0ea1db468d8d48",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=c7b8effb96726ba5367a7b1c9c7374c4d2cc10e2",
        "patch": "@@ -50,7 +50,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(dummyNode1.GetId(), &dummyNode1);\n+    GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n     SendMessages(&dummyNode1, *connman);\n@@ -60,7 +60,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(dummyNode2.GetId(), &dummyNode2);\n+    GetNodeSignals().InitializeNode(&dummyNode2, *connman);\n     dummyNode2.nVersion = 1;\n     Misbehaving(dummyNode2.GetId(), 50);\n     SendMessages(&dummyNode2, *connman);\n@@ -78,7 +78,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(dummyNode1.GetId(), &dummyNode1);\n+    GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100);\n     SendMessages(&dummyNode1, *connman);\n@@ -101,7 +101,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n-    GetNodeSignals().InitializeNode(dummyNode.GetId(), &dummyNode);\n+    GetNodeSignals().InitializeNode(&dummyNode, *connman);\n     dummyNode.nVersion = 1;\n \n     Misbehaving(dummyNode.GetId(), 100);"
      }
    ]
  }
]