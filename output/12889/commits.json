[
  {
    "sha": "924d4ae38d34738b6313992a2b10984c398b23d2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjRkNGFlMzhkMzQ3MzhiNjMxMzk5MmEyYjEwOTg0YzM5OGIyM2Qy",
    "commit": {
      "author": {
        "name": "buddilla",
        "email": "buddilla@users.noreply.github.com",
        "date": "2018-04-05T04:34:13Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2018-04-05T04:34:13Z"
      },
      "message": "doc: add qrencode to brew install instructions (#1)\n\n* [gitian] Re-order keys by owner first name alphabetic order\r\n\r\n* [gitian] Add kallewoof key for signing\r\n\r\n* Simplify Base32 and Base64 conversions\r\n\r\n* CheckMinimalPush comments are prescriptive\r\n\r\n* [rpc] createrawtransaction: Accept sorted outputs\r\n\r\n* qa: Cache only chain and wallet for regtest datadir\r\n\r\n* [wallet] Get rid of CWalletTx default constructor\r\n\r\nNo change in behavior in the normal case. But buggy mapWallet lookups with\r\ninvalid txids will now throw exceptions instead of inserting dummy entries into\r\nthe map, and potentially causing segfaults and other failures.\r\n\r\nThis also makes it a compiler error to use the mapWallet[hash] syntax which\r\ncould create dummy entries.\r\n\r\n* [wallet] Construct CWalletTx objects in CommitTransaction\r\n\r\nConstruct CWalletTx objects in CWallet::CommitTransaction, instead of having\r\ncallers do it. This ensures CWalletTx objects are constructed in a uniform way\r\nand all fields are set.\r\n\r\nThis also makes it possible to avoid confusing and wasteful CWalletTx copies in\r\nhttps://github.com/bitcoin/bitcoin/pull/9381\r\n\r\nThere is no change in behavior.\r\n\r\n* bitcoin-cli: Provide a better error message when bitcoind is not running\r\n\r\nBefore this patch:\r\n\r\n```\r\n$ bitcoin-cli -testnet echo 'hello world'\r\nerror: Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (/root/.bitcoin/bitcoin.conf)\r\n```\r\n\r\nAfter this patch:\r\n\r\n```\r\n$ bitcoin-cli -testnet echo 'hello world'\r\nerror: Could not connect to the server 127.0.0.1:18332\r\n\r\nMake sure the bitcoind server is running and that you are connecting to the correct RPC port.\r\n```\r\n\r\n* Format timestamps using ISO 8601 formatting (e.g. \"2018-02-28T12:34:56Z\")\r\n\r\n* Z is the zone designator for the zero UTC offset.\r\n* T is the delimiter used to separate date and time.\r\n\r\nThis makes it clear for the end-user that the date/time logged is\r\nspecified in UTC and not in the local time zone.\r\n\r\n* scripted-diff: Convert 11 enums into scoped enums (C++11)\r\n\r\n-BEGIN VERIFY SCRIPT-\r\n\r\nsed -i 's/enum DBErrors/enum class DBErrors/g' src/wallet/walletdb.h\r\ngit grep -l DB_ | xargs sed -i 's/DB_\\(LOAD_OK\\|CORRUPT\\|NONCRITICAL_ERROR\\|TOO_NEW\\|LOAD_FAIL\\|NEED_REWRITE\\)/DBErrors::\\1/g'\r\nsed -i 's/^    DBErrors::/    /g' src/wallet/walletdb.h\r\n\r\nsed -i 's/enum VerifyResult/enum class VerifyResult/g' src/wallet/db.h\r\nsed -i 's/\\(VERIFY_OK\\|RECOVER_OK\\|RECOVER_FAIL\\)/VerifyResult::\\1/g' src/wallet/db.cpp\r\n\r\nsed -i 's/enum ThresholdState/enum class ThresholdState/g' src/versionbits.h\r\ngit grep -l THRESHOLD_ | xargs sed -i 's/THRESHOLD_\\(DEFINED\\|STARTED\\|LOCKED_IN\\|ACTIVE\\|FAILED\\)/ThresholdState::\\1/g'\r\nsed -i 's/^    ThresholdState::/    /g' src/versionbits.h\r\n\r\nsed -i 's/enum SigVersion/enum class SigVersion/g' src/script/interpreter.h\r\ngit grep -l SIGVERSION_ | xargs sed -i 's/SIGVERSION_\\(BASE\\|WITNESS_V0\\)/SigVersion::\\1/g'\r\nsed -i 's/^    SigVersion::/    /g' src/script/interpreter.h\r\n\r\nsed -i 's/enum RetFormat {/enum class RetFormat {/g' src/rest.cpp\r\nsed -i 's/RF_\\(UNDEF\\|BINARY\\|HEX\\|JSON\\)/RetFormat::\\1/g' src/rest.cpp\r\nsed -i 's/^    RetFormat::/    /g' src/rest.cpp\r\n\r\nsed -i 's/enum HelpMessageMode {/enum class HelpMessageMode {/g' src/init.h\r\ngit grep -l HMM_ | xargs sed -i 's/HMM_BITCOIN/HelpMessageMode::BITCOIN/g'\r\nsed -i 's/^    HelpMessageMode::/    /g' src/init.h\r\n\r\nsed -i 's/enum FeeEstimateHorizon/enum class FeeEstimateHorizon/g' src/policy/fees.h\r\n\r\nsed -i 's/enum RBFTransactionState/enum class RBFTransactionState/g' src/policy/rbf.h\r\ngit grep -l RBF_ | xargs sed -i 's/RBF_TRANSACTIONSTATE_\\(UNKNOWN\\|REPLACEABLE_BIP125\\|FINAL\\)/RBFTransactionState::\\1/g'\r\nsed -i 's/^    RBFTransactionState::/    /g' src/policy/rbf.h\r\n\r\nsed -i 's/enum BlockSource {/enum class BlockSource {/g' src/qt/clientmodel.h\r\ngit grep -l BLOCK_SOURCE_ | xargs sed -i 's/BLOCK_SOURCE_\\(NONE\\|REINDEX\\|DISK\\|NETWORK\\)/BlockSource::\\1/g'\r\nsed -i 's/^    BlockSource::/    /g' src/qt/clientmodel.h\r\n\r\nsed -i 's/enum FlushStateMode {/enum class FlushStateMode {/g' src/validation.cpp\r\nsed -i 's/FLUSH_STATE_\\(NONE\\|IF_NEEDED\\|PERIODIC\\|ALWAYS\\)/FlushStateMode::\\1/g' src/validation.cpp\r\nsed -i 's/^    FlushStateMode::/    /g' src/validation.cpp\r\n\r\nsed -i 's/enum WitnessMode {/enum class WitnessMode {/g' src/test/script_tests.cpp\r\nsed -i 's/WITNESS_\\(NONE\\|PKH\\|SH\\)/WitnessMode::\\1/g' src/test/script_tests.cpp\r\nsed -i 's/^    WitnessMode::/    /g' src/test/script_tests.cpp\r\n\r\n-END VERIFY SCRIPT-\r\n\r\n* Split up and sanitize CWalletTx serialization\r\n\r\n* Calculate and store the number of bytes required to spend an input\r\n\r\n* Store effective value, fee, and long term fee in CInputCoin\r\n\r\nHave CInputCOin store effective value information. This includes the effective\r\nvalue itself, the fee, and the long term fee for the input\r\n\r\n* Log fatal LevelDB errors more verbosely\r\n\r\n* configure: UniValue 1.0.4 is required for pushKV(, bool)\r\n\r\n* Allow to optional specify the directory for the blocks storage\r\n\r\n* Ubuntu xenial first dependencies\r\n\r\nAdd update and upgrade commands to enable the installation of the first dependencies on ubuntu xenial. If those are not executed some packages can not be found.\r\n\r\n* Split up and sanitize CAccountingEntry serialization\r\n\r\n* rpc: Update createrawtransaction examples\r\n\r\n* qt: Avoid querying unnecessary model data when filtering transactions\r\n\r\n* [qa] util: Remove unused sync_chain\r\n\r\n* Implement Branch and Bound coin selection in a new file\r\n\r\nCreate a new file for coin selection logic and implement the BnB algorithm in it.\r\n\r\n* Add a GetMinimumFeeRate function which is wrapped by GetMinimumFee\r\n\r\n* Remove coinselection.h -> wallet.h circular dependency\r\n\r\nChanges CInputCoin to coinselection and to use CTransactionRef in\r\norder to avoid a circular dependency. Also moves other coin selection\r\nspecific variables out of wallet.h to coinselectoin.h\r\n\r\n* Move output eligibility to a separate function\r\n\r\n* Move current coin selection algorithm to coinselection.{cpp,h}\r\n\r\nMoves the current coin selection algorithm out of SelectCoinsMinConf\r\nand puts it in coinselection.{cpp,h}. The new function, KnapsackSolver,\r\ninstead of taking a vector of COutputs, will take a vector of CInputCoins\r\nthat is prepared by SelectCoinsMinConf.\r\n\r\n* Use a struct for output eligibility\r\n\r\nInstead of specifying 3 parameters, use a struct for those parameters\r\nin order to reduce the number of arguments to SelectCoinsMinConf.\r\n\r\n* Add tests for the Branch and Bound algorithm\r\n\r\n* Move original knapsack solver tests to coinselector_tests.cpp\r\n\r\n* Have SelectCoinsMinConf and SelectCoins use BnB or Knapsack and use it\r\n\r\nAllows SelectCoinsMinConf and SelectCoins be able to switch between\r\nusing BnB or Knapsack for choosing coins.\r\n\r\nHas SelectCoinsMinConf do the preprocessing necessary to support either\r\nBnB or Knapsack. This includes calculating the filtering the effective\r\nvalues for each input.\r\n\r\nUses BnB in CreateTransaction to find an exact match for the output.\r\nIf BnB fails, it will fallback to the Knapsack solver.\r\n\r\n* Benchmark BnB in the worst case where it exhausts\r\n\r\n* Add a test to make sure that negative effective values are filtered\r\n\r\n* travis: Clone depth 1 unless $CHECK_DOC\r\n\r\n* Fix ComputeTimeSmart test failure with -DDEBUG_LOCKORDER\r\n\r\nFailure looks like:\r\n\r\n    Entering test case \"ComputeTimeSmart\"\r\n    test_bitcoin: sync.cpp:100: void potential_deadlock_detected(const std::pair<void*, void*>&, const LockStack&, const LockStack&): Assertion `false' failed.\r\n    unknown location(0): fatal error in \"ComputeTimeSmart\": signal: SIGABRT (application abort requested)\r\n    wallet/test/wallet_tests.cpp(566): last checkpoint\r\n\r\nReproducible with:\r\n\r\n    ./configure --enable-debug\r\n    make -C src test/test_bitcoin && src/test/test_bitcoin --log_level=test_suite --run_test=wallet_tests/ComputeTimeSmart\r\n\r\nHappens due to \"92fabcd443 Add LookupBlockIndex function\" which acquires\r\ncs_main from inside CWallet::ComputeTimeSmart.\r\n\r\n* Merge READWRITEMANY into READWRITE\r\n\r\n* Support deserializing into temporaries\r\n\r\nCurrently, the READWRITE macro cannot be passed any non-const temporaries, as\r\nthe SerReadWrite function only accepts lvalue references.\r\n\r\nDeserializing into a temporary is very common, however. See for example\r\nthings like 's >> VARINT(n)'. The VARINT macro produces a temporary wrapper\r\nthat holds a reference to n.\r\n\r\nFix this by accepting non-const rvalue references instead of lvalue references.\r\nWe don't propagate the rvalue-ness down, as there are no useful optimizations\r\nthat only apply to temporaries.\r\n\r\nThen use this new functionality to get rid of many (but not all) uses of the\r\n'REF' macro (which casts away constness).\r\n\r\n* Apply hardening measurements in bitcoind systemd service file\r\n\r\nAdds typical systemd hardening measurements for network services.\r\n\r\n* Polish interfaces around PeerLogicValidation\r\n\r\n* Make PeerLogicValidation final to prevent deriving from it [1]\r\n* Prevent deletions of NetEventsInterface and CValidationInterface\r\n  objects via a base class pointer\r\n\r\n[1] silences the following compiler warning (from Clang 7.0.0):\r\n\r\n/usr/include/c++/v1/memory:2285:5: error: delete called on non-final 'PeerLogicValidation' that has\r\n      virtual functions but non-virtual destructor [-Werror,-Wdelete-non-virtual-dtor]\r\n    delete __ptr;\r\n    ^\r\n/usr/include/c++/v1/memory:2598:7: note: in instantiation of member function\r\n      'std::__1::default_delete<PeerLogicValidation>::operator()' requested here\r\n      __ptr_.second()(__tmp);\r\n      ^\r\ninit.cpp:201:15: note: in instantiation of member function 'std::__1::unique_ptr<PeerLogicValidation,\r\n      std::__1::default_delete<PeerLogicValidation> >::reset' requested here\r\n    peerLogic.reset();\r\n                  ^\r\n\r\n* Provide relevant error message if datadir is not writable.\r\n\r\n* Remove unused variable in SortForBlock\r\n\r\n* Actually disable BnB when there are preset inputs\r\n\r\nWe don't want to use BnB when there are preset inputs because there\r\nis some weirdness with making that work with using the KnapsackSolver\r\nas the fallback. Currently we say that we haven't used bnb when\r\nthere are preset inputs, but we don't actually disable BnB. This fixes\r\nthat.\r\n\r\n* Do not check for main() in libminiupnpc\r\n\r\nmain() { main(); } causes \"infinite recursion\" compilation warning\r\nwhich with -Werror fails the check.\r\n\r\n* ax_boost_{chrono,unit_test_framework}.m4: take changes from upstream\r\n\r\nApply changes to\r\nbuild-aux/m4/ax_boost_chrono.m4 and\r\nbuild-aux/m4/ax_boost_unit_test_framework.m4\r\nfrom upstream: https://github.com/peti/autoconf-archive\r\n\r\n* Remove redundant checks for MSG_* from configure.ac\r\n\r\nIt is redundant to check for the presence of MSG_NOSIGNAL macro in\r\nconfigure.ac, define HAVE_MSG_NOSIGNAL and then check whether the later\r\nis defined in the source code. Instead we can check directly whether\r\nMSG_NOSIGNAL is defined. Same for MSG_DONTWAIT.\r\n\r\nIn addition to that, the checks we had in configure.ac produce a\r\ncompiler warning about unused variable and thus could fail if\r\n-Werror is present and erroneously proclaim that the macros are\r\nnot available.\r\n\r\n* Test that BnB is not used when there are preset inputs\r\n\r\n* Document RPC method aliasing\r\n\r\nSuggested by Sjors Provoost <sjors@sprovoost.nl> in\r\nhttps://github.com/bitcoin/bitcoin/pull/11536#issuecomment-372820660\r\n\r\n* Add static_assert to prevent VARINT(<signed value>)\r\n\r\nUsing VARINT with signed types is dangerous because negative values will appear\r\nto serialize correctly, but then deserialize as positive values mod 128.\r\n\r\nThis commit changes the VARINT macro to trigger an error by default if called\r\nwith an signed value, and updates broken uses of VARINT to pass a special flag\r\nthat lets them keep working with no change in behavior.\r\n\r\n* test: Use wait_until in tests where time was used for polling\r\n\r\n* test: Use os.path.join consistently in feature_pruning tests\r\n\r\n* [Trivial] Simplify if-else blocks and more descriptive variable naming\r\n\r\n* Append scripts to new test_list array to fix bad assignment\r\n\r\n* wallet: Change output type globals to members\r\n\r\n* QA: Add -blocksdir test\r\n\r\n* [Tests] Move assert_start_raises_init_error method to TestNode\r\n\r\n* [Tests] Require exact match in assert_start_raises_init_eror()\r\n\r\n* Avoiding 'file' function name from python2 with more descriptive variable naming\r\n\r\n* Qt: remove \"new\" button during receive-mode in addressbook\r\n\r\n* [tests] Fix flake8 warnings in feature_block.py\r\n\r\n* [tests] Tidy up feature_block.py\r\n\r\n- move all helper methods to the end\r\n- remove block, create_tx and create_and_sign_tx shortcuts\r\n- remove --runbarelyexpensive option, since it defaults to True and it's\r\nunlikely that anyone ever runs the test with this option set to false.\r\n\r\n* [tests] Add logging to feature_block.py\r\n\r\n* Remove unreachable help conditions\r\n\r\n* Rename account to label where appropriate\r\n\r\nThis change only updates strings and adds RPC aliases, but should simplify the\r\nimplementation of address labels in\r\nhttps://github.com/bitcoin/bitcoin/pull/7729, by getting renaming out of the\r\nway and letting it focus on semantics.\r\n\r\nThe difference between accounts and labels is that labels apply only to\r\naddresses, while accounts apply to both addresses and transactions\r\n(transactions have \"from\" and \"to\" accounts). The code associating accounts\r\nwith transactions is clumsy and unreliable so we would like get rid of it.\r\n\r\n* Rename wallet_accounts.py test\r\n\r\nThis is a separate commit because changing the test at the same time as\r\nrenaming it breaks git (and github) rename detection.\r\n\r\n* qa: Use node.datadir instead of tmpdir in test framework\r\n\r\n* [tests] Change feature_block.py to use BitcoinTestFramework\r\n\r\n* [tests] Improve assert message when wait_until() fails\r\n\r\n* scripted-diff: rename TestNode to TestP2PConn in tests\r\n\r\nSeveral test scripts define a subclass of P2PInterface called TestNode.\r\nThis commit renames those to TestP2PConn since we already have a\r\nTestNode class in the test framework.\r\n\r\n-BEGIN VERIFY SCRIPT-\r\nsed -i s/TestNode/TestP2PConn/ test/functional/*py test/functional/test_framework/comptool.py\r\n_END VERIFY SCRIPT-\r\n\r\n* qa: Allow for partial_match when checking init error\r\n\r\nThis allows the tests to pass on different platforms\r\n\r\n* tests: Test connecting to a non-existing server\r\n\r\n* tests: Test connecting with non-existing RPC cookie file\r\n\r\n* -blocksdir: keep blockindex leveldb database in datadir\r\n\r\n* Remove unnecessary NONNEGATIVE_SIGNED\r\n\r\nSwitch to unsigned encoding, which is backwards compatible and avoids MSVC\r\nerror reported https://github.com/bitcoin/bitcoin/issues/12732\r\n\r\n* use base58 map instead of strchr()\r\n\r\n* Make FastRandomContext support standard C++11 RNG interface\r\n\r\nThis makes it possible to plug it into the various standard C++11 random\r\ndistribution algorithms and other functions like std::shuffle.\r\n\r\n* Fix typos\r\n\r\n* tests: Remove unused argument max_invalid from check_estimates(...)\r\n\r\n* Fix typos\r\n\r\n* Qt: Warn users about invalid-BIP21 URI bitcoin://\r\n\r\n* shuffle selected coins before transaction finalization\r\n\r\n* Replace boost::call_once with std::call_once\r\n\r\n* Add native support for serializing char arrays without FLATDATA\r\n\r\nSupport is added to serialize arrays of type char or unsigned char directly,\r\nwithout any wrappers. All invocations of the FLATDATA wrappers that are\r\nobsoleted by this are removed.\r\n\r\nThis includes a patch by Russell Yanofsky to make char casting type safe.\r\n\r\nThe serialization of CSubNet is changed to serialize a bool directly rather\r\nthan though FLATDATA. This makes the serialization independent of the size\r\nof the bool type (and will use 1 byte everywhere).\r\n\r\n* Move compressor utility functions out of class\r\n\r\n* [config] Remove blockmaxsize option\r\n\r\nThe blockmaxsize option was marked as deprecated in V0.15.1, and code\r\nwas added to convert provided blockmaxsize into blockmaxweight. However,\r\nthis code was incorrectly implemented, and blockmaxsize was silently\r\nignored.\r\n\r\nNo users have complained about blockmaxsize being ignored, so just\r\nremove it in V0.17.\r\n\r\n* Docs: Improve documentation on standard communication channels\r\n\r\nMore information about connection on IRC will hopefully help new\r\ncontributors.\r\n\r\n* shuffle sendmany recipients ordering to shuffle tx outputs\r\n\r\n* add release note for sendmany output shuffling\r\n\r\n* [CI]: bump travis timeout for make check to 50m\r\n\r\n* Inline CKeyStore::AddKey(const CKey &) in CBasicKeyStore\r\n\r\n* Move CKeyStore::cs_KeyStore to CBasicKeyStore\r\n\r\n* Make CTxMemPool::isSpent() const\r\n\r\n* [REST] Handle UTXO retrieval when ignoring the mempool\r\n\r\nCurrent REST API always returns empty UTXO when invoked without `/checkmempool/` URL part.\r\n\r\nAfter the fix:\r\n```\r\n$ curl -s http://localhost:8332/rest/getutxos/0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098-0.json | jq\r\n{\r\n  \"chainHeight\": 514109,\r\n  \"chaintipHash\": \"0000000000000000001fe76d1445e8a6432fd2de04261dc9c5915311dc7ad6de\",\r\n  \"bitmap\": \"1\",\r\n  \"utxos\": [\r\n    {\r\n      \"height\": 1,\r\n      \"value\": 50,\r\n      \"scriptPubKey\": {\r\n        \"asm\": \"0496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858ee OP_CHECKSIG\",\r\n        \"hex\": \"410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac\",\r\n        \"reqSigs\": 1,\r\n        \"type\": \"pubkey\",\r\n        \"addresses\": [\r\n          \"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nBefore the fix:\r\n```\r\n$ curl -s http://localhost:8332/rest/getutxos/0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098-0.json | jq\r\n{\r\n  \"chainHeight\": 514109,\r\n  \"chaintipHash\": \"0000000000000000001fe76d1445e8a6432fd2de04261dc9c5915311dc7ad6de\",\r\n  \"bitmap\": \"0\",\r\n  \"utxos\": []\r\n}\r\n```\r\n\r\n* Add username and ip logging for RPC method requests\r\n\r\n* Qt: Remove unused method setupAmountWidget(...)\r\n\r\n* Introduce interface for signing providers\r\n\r\nCKeyStore is a rich interface that provides many features, including knowledge\r\nof scripts and pubkeys for solving, private keys for signing, in addition to\r\nwatch-only keys and scripts, and distinguishing lack of keys from them just\r\nbeing encrypted.\r\n\r\nThe signing logic in script/sign does not actually need most of these features.\r\nHere we introduce a simpler interface (SigningProvider) which *only* provides\r\nkeys and scripts. This is actually sufficient for signing.\r\n\r\nIn addtion, we swap the dependency between keystore and script/sign\r\n(keystore now depends on script/script with CKeyStore deriving from\r\nSigningProvider, rather than CKeyStore being the interface that signing\r\nrelies on).\r\n\r\n* Reduce variable scopes\r\n\r\n* Qt: Add wallet selector to debug console\r\n\r\n* Qt: QComboBox::setVisible doesn't work in toolbars, so defer adding it at all until needed\r\n\r\n* Qt: Get wallet name from WalletModel rather than passing it around\r\n\r\n* Qt: When multiple wallets are used, include in notifications the name\r\n\r\n* GUI: RPCConsole: Log wallet changes\r\n\r\n* Qt: show wallet name in send confirmation dlg in case of multiwallet\r\n\r\n* Qt: show wallet name in request dlg in case of multiwallet\r\n\r\n* Qt: hide RPCConsole wallet selector when no wallets are present\r\n\r\n* rpc: Adjust ifdef to avoid unreachable code\r\n\r\n* [Tests] Use blockmaxweight where tests previously had blockmaxsize\r\n\r\n* [wallet] Move wallet init functions into WalletInit class.\r\n\r\n* [wallet] Create wallet init interface.\r\n\r\n* qt: Avoid resetting on resetguisettigs=0\r\n\r\n* do not truncate .dat extension for wallets in gui\r\n\r\n* Change all python files to use Python3\r\n\r\n* init: Fix help message for checkblockindex\r\n\r\n* doc: Refer to witness reserved value as spec. in the BIP\r\n\r\n* doc: Add note about our preference for scoped enumerations (\"enum class\")\r\n\r\n* [wallet] Use global g_wallet_init_interface to init/destroy the wallet.\r\n\r\nThis commit creates a global g_wallet_init_interface, which is created\r\nin bitcoind and bitcoin-qt. g_wallet_init_interface is used to init\r\nand destroy the wallet.\r\n\r\nThis removes the dependency from init.cpp on the wallet library.\r\n\r\n* [wallet] Add dummy wallet init class\r\n\r\n* Fix error in memory usage calculation (unintended integer division)\r\n\r\n* qa: Fix function names in feature_blocksdir\r\n\r\n* Add additional tests for GetBoolArg()\r\n\r\nThis is meant to be an intermediate commit to prove that the next does not\r\nintroduce any changes in the semantics of boolean option parsing.\r\n\r\n* Track negated arguments in the argument paser.\r\n\r\nThis commit adds tracking for negated arguments. This change will be used in a\r\nfuture commit that allows disabling the debug.log file using -nodebuglogfile.\r\n\r\n* test: Make summary row bold-red if any test failed\r\n\r\nMake the summary row of the test runner bold red if any test fails.\r\nThis helps visibility if something fails.\r\n\r\n* Make base58 python contrib code work with python3\r\n\r\n* test: List any failed tests at the end of test_runner output\r\n\r\nChange sorting output to put failed tests at the end of test_runner\r\noutput.\r\n\r\n* [Tests] fix a typo in TestNode.assert_start_raises_init_error()\r\n\r\nAlso, use specific exception for testing TestNode initialization failure.\r\n\r\n* contrib: Fix check-doc script regexes\r\n\r\n* contrib: Remove unused import string\r\n\r\n* init: Remove help text for non-existent -fuzzmessagestest arg\r\n\r\n* Revert \"test: Update trust git root\".\r\n\r\nThis reverts commit 7deba93bdc76616011a9f493cbc203d60084416f.\r\n\r\nThis is neither a \"test\" change, nor should the trusted-git-root\r\nhave been updated - there is a process for expired PGP keys.\r\n\r\n* Add Marco-expired-key-signed-commits to allow-revsig-commits\r\n\r\n* Improve formatting of developer notes\r\n\r\nSummary of changes:\r\n\r\n * Add a TOC to the page\r\n * Make tips and tricks section use h3 headings\r\n * Reformat and clarify some sections\r\n\r\n* Add --with-sanitizers option to configure\r\n\r\nThis enables the use of different compiler sanitizers, coresponding to\r\nthe -fsanitize option in GCC and Clang.\r\n\r\n* [tests] Fix intermittent rpc_net.py failure.\r\n\r\nrpc_net.py would intermittently fail on Travis, probably\r\ndue to assuming that two consecutive RPC calls were atomic.\r\nFix this by only testing that amounts are bounded above and\r\nbelow rather than equal.\r\n\r\n* [contrib] fixup security-check.py Python3 support\r\n\r\n* [contrib] fixup symbol-check.py Python3 support\r\n\r\n* Bugfix: RPC: savemempool: Don't save until LoadMempool() is finished\r\n\r\n* Increase LevelDB max_open_files unless on 32-bit Unix.\r\n\r\nThis change significantly increases IBD performance by increasing the\r\namount of the UTXO index that can remain in memory. To ensure this\r\ndoesn't cause problems in the future, a static_assert on the LevelDB\r\nversion has been added, which must be updated by anyone upgrading\r\nLevelDB.\r\n\r\n* [verify-commits] Add some additional useful documentation.\r\n\r\n* test: Remove travis checkout depth\r\n\r\nTests on branches of non-head commits are failing, because the depth of\r\n1 doesn't allow checking them out.\r\n\r\nRemove `depth` as was the case before fa44af5cd2152a21da9ef3e48c073a668bf2df27,\r\nso that Travis can determine the minimum depth to check out.\r\n\r\n* Fixes Missing QRCode Build\r\n\r\nBuild was missing qr code(qrencode libs) support and brew team no longer supports anything less than macOS 10.11\r\n\r\n* Fixed notes\r\n\r\nFixed notes to reflect that 10.8 is still supported via gitian\r\n\r\n* Rolled Back Tested on\r\n\r\nBelow is a suggestion for future release after EOL is done\r\n\r\n* Works with macOS 10.11 through 10.13 on 64-bit Intel processors only.\r\n\r\n* macOS 10.8 and higher is still supported on [gitian](/contrib) builds\r\n\r\n* Update build-osx.md\r\n\r\nBelow is a suggestion for future release after EOL is done\r\n\r\n* Works with macOS 10.11 through 10.13 on 64-bit Intel processors only.\r\n\r\n* macOS 10.8 and higher is still supported on [gitian](/contrib) builds",
      "tree": {
        "sha": "96cfbc7fe4181f99f163c02ac2cc4c92032dee05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96cfbc7fe4181f99f163c02ac2cc4c92032dee05"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/924d4ae38d34738b6313992a2b10984c398b23d2",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaxadFCRBK7hj4Ov3rIwAAdHIIAI3TPaDSdZtSA+VZhHEZ5jMQ\nERpUBY7fB2YF78hQyClVPUpInRw7XEdhPibigYbPw3REThWopoFm6BJeY5AcA0RN\njbH/YD+BEZdb2QqgkaaTxdDMbXQhtaUN4c9ALSPHoVggS7EwuP+JwmZOGJR5civF\nXXde1AuYvjvCWWrHNjZK2KEz4/rZKgbG2h5mvm4Q2hkq5npgCLtoW41VZvAO0M01\ncBNluWl6RhqjOzqdG236UpIX7Zr+MFbaCixGld8i6itAqEkdkLizPSZ3cuZL1ICb\nHleIa/IHts8blIZa6A9jOOGD+l1BTyFNFfFfHgVzzxsklWKPFgXfaz59Z5keVs4=\n=HlUU\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 96cfbc7fe4181f99f163c02ac2cc4c92032dee05\nparent 07090c5339436f856e79a8036d1c85deeb453803\nauthor buddilla <buddilla@users.noreply.github.com> 1522902853 -0700\ncommitter GitHub <noreply@github.com> 1522902853 -0700\n\ndoc: add qrencode to brew install instructions (#1)\n\n* [gitian] Re-order keys by owner first name alphabetic order\r\n\r\n* [gitian] Add kallewoof key for signing\r\n\r\n* Simplify Base32 and Base64 conversions\r\n\r\n* CheckMinimalPush comments are prescriptive\r\n\r\n* [rpc] createrawtransaction: Accept sorted outputs\r\n\r\n* qa: Cache only chain and wallet for regtest datadir\r\n\r\n* [wallet] Get rid of CWalletTx default constructor\r\n\r\nNo change in behavior in the normal case. But buggy mapWallet lookups with\r\ninvalid txids will now throw exceptions instead of inserting dummy entries into\r\nthe map, and potentially causing segfaults and other failures.\r\n\r\nThis also makes it a compiler error to use the mapWallet[hash] syntax which\r\ncould create dummy entries.\r\n\r\n* [wallet] Construct CWalletTx objects in CommitTransaction\r\n\r\nConstruct CWalletTx objects in CWallet::CommitTransaction, instead of having\r\ncallers do it. This ensures CWalletTx objects are constructed in a uniform way\r\nand all fields are set.\r\n\r\nThis also makes it possible to avoid confusing and wasteful CWalletTx copies in\r\nhttps://github.com/bitcoin/bitcoin/pull/9381\r\n\r\nThere is no change in behavior.\r\n\r\n* bitcoin-cli: Provide a better error message when bitcoind is not running\r\n\r\nBefore this patch:\r\n\r\n```\r\n$ bitcoin-cli -testnet echo 'hello world'\r\nerror: Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (/root/.bitcoin/bitcoin.conf)\r\n```\r\n\r\nAfter this patch:\r\n\r\n```\r\n$ bitcoin-cli -testnet echo 'hello world'\r\nerror: Could not connect to the server 127.0.0.1:18332\r\n\r\nMake sure the bitcoind server is running and that you are connecting to the correct RPC port.\r\n```\r\n\r\n* Format timestamps using ISO 8601 formatting (e.g. \"2018-02-28T12:34:56Z\")\r\n\r\n* Z is the zone designator for the zero UTC offset.\r\n* T is the delimiter used to separate date and time.\r\n\r\nThis makes it clear for the end-user that the date/time logged is\r\nspecified in UTC and not in the local time zone.\r\n\r\n* scripted-diff: Convert 11 enums into scoped enums (C++11)\r\n\r\n-BEGIN VERIFY SCRIPT-\r\n\r\nsed -i 's/enum DBErrors/enum class DBErrors/g' src/wallet/walletdb.h\r\ngit grep -l DB_ | xargs sed -i 's/DB_\\(LOAD_OK\\|CORRUPT\\|NONCRITICAL_ERROR\\|TOO_NEW\\|LOAD_FAIL\\|NEED_REWRITE\\)/DBErrors::\\1/g'\r\nsed -i 's/^    DBErrors::/    /g' src/wallet/walletdb.h\r\n\r\nsed -i 's/enum VerifyResult/enum class VerifyResult/g' src/wallet/db.h\r\nsed -i 's/\\(VERIFY_OK\\|RECOVER_OK\\|RECOVER_FAIL\\)/VerifyResult::\\1/g' src/wallet/db.cpp\r\n\r\nsed -i 's/enum ThresholdState/enum class ThresholdState/g' src/versionbits.h\r\ngit grep -l THRESHOLD_ | xargs sed -i 's/THRESHOLD_\\(DEFINED\\|STARTED\\|LOCKED_IN\\|ACTIVE\\|FAILED\\)/ThresholdState::\\1/g'\r\nsed -i 's/^    ThresholdState::/    /g' src/versionbits.h\r\n\r\nsed -i 's/enum SigVersion/enum class SigVersion/g' src/script/interpreter.h\r\ngit grep -l SIGVERSION_ | xargs sed -i 's/SIGVERSION_\\(BASE\\|WITNESS_V0\\)/SigVersion::\\1/g'\r\nsed -i 's/^    SigVersion::/    /g' src/script/interpreter.h\r\n\r\nsed -i 's/enum RetFormat {/enum class RetFormat {/g' src/rest.cpp\r\nsed -i 's/RF_\\(UNDEF\\|BINARY\\|HEX\\|JSON\\)/RetFormat::\\1/g' src/rest.cpp\r\nsed -i 's/^    RetFormat::/    /g' src/rest.cpp\r\n\r\nsed -i 's/enum HelpMessageMode {/enum class HelpMessageMode {/g' src/init.h\r\ngit grep -l HMM_ | xargs sed -i 's/HMM_BITCOIN/HelpMessageMode::BITCOIN/g'\r\nsed -i 's/^    HelpMessageMode::/    /g' src/init.h\r\n\r\nsed -i 's/enum FeeEstimateHorizon/enum class FeeEstimateHorizon/g' src/policy/fees.h\r\n\r\nsed -i 's/enum RBFTransactionState/enum class RBFTransactionState/g' src/policy/rbf.h\r\ngit grep -l RBF_ | xargs sed -i 's/RBF_TRANSACTIONSTATE_\\(UNKNOWN\\|REPLACEABLE_BIP125\\|FINAL\\)/RBFTransactionState::\\1/g'\r\nsed -i 's/^    RBFTransactionState::/    /g' src/policy/rbf.h\r\n\r\nsed -i 's/enum BlockSource {/enum class BlockSource {/g' src/qt/clientmodel.h\r\ngit grep -l BLOCK_SOURCE_ | xargs sed -i 's/BLOCK_SOURCE_\\(NONE\\|REINDEX\\|DISK\\|NETWORK\\)/BlockSource::\\1/g'\r\nsed -i 's/^    BlockSource::/    /g' src/qt/clientmodel.h\r\n\r\nsed -i 's/enum FlushStateMode {/enum class FlushStateMode {/g' src/validation.cpp\r\nsed -i 's/FLUSH_STATE_\\(NONE\\|IF_NEEDED\\|PERIODIC\\|ALWAYS\\)/FlushStateMode::\\1/g' src/validation.cpp\r\nsed -i 's/^    FlushStateMode::/    /g' src/validation.cpp\r\n\r\nsed -i 's/enum WitnessMode {/enum class WitnessMode {/g' src/test/script_tests.cpp\r\nsed -i 's/WITNESS_\\(NONE\\|PKH\\|SH\\)/WitnessMode::\\1/g' src/test/script_tests.cpp\r\nsed -i 's/^    WitnessMode::/    /g' src/test/script_tests.cpp\r\n\r\n-END VERIFY SCRIPT-\r\n\r\n* Split up and sanitize CWalletTx serialization\r\n\r\n* Calculate and store the number of bytes required to spend an input\r\n\r\n* Store effective value, fee, and long term fee in CInputCoin\r\n\r\nHave CInputCOin store effective value information. This includes the effective\r\nvalue itself, the fee, and the long term fee for the input\r\n\r\n* Log fatal LevelDB errors more verbosely\r\n\r\n* configure: UniValue 1.0.4 is required for pushKV(, bool)\r\n\r\n* Allow to optional specify the directory for the blocks storage\r\n\r\n* Ubuntu xenial first dependencies\r\n\r\nAdd update and upgrade commands to enable the installation of the first dependencies on ubuntu xenial. If those are not executed some packages can not be found.\r\n\r\n* Split up and sanitize CAccountingEntry serialization\r\n\r\n* rpc: Update createrawtransaction examples\r\n\r\n* qt: Avoid querying unnecessary model data when filtering transactions\r\n\r\n* [qa] util: Remove unused sync_chain\r\n\r\n* Implement Branch and Bound coin selection in a new file\r\n\r\nCreate a new file for coin selection logic and implement the BnB algorithm in it.\r\n\r\n* Add a GetMinimumFeeRate function which is wrapped by GetMinimumFee\r\n\r\n* Remove coinselection.h -> wallet.h circular dependency\r\n\r\nChanges CInputCoin to coinselection and to use CTransactionRef in\r\norder to avoid a circular dependency. Also moves other coin selection\r\nspecific variables out of wallet.h to coinselectoin.h\r\n\r\n* Move output eligibility to a separate function\r\n\r\n* Move current coin selection algorithm to coinselection.{cpp,h}\r\n\r\nMoves the current coin selection algorithm out of SelectCoinsMinConf\r\nand puts it in coinselection.{cpp,h}. The new function, KnapsackSolver,\r\ninstead of taking a vector of COutputs, will take a vector of CInputCoins\r\nthat is prepared by SelectCoinsMinConf.\r\n\r\n* Use a struct for output eligibility\r\n\r\nInstead of specifying 3 parameters, use a struct for those parameters\r\nin order to reduce the number of arguments to SelectCoinsMinConf.\r\n\r\n* Add tests for the Branch and Bound algorithm\r\n\r\n* Move original knapsack solver tests to coinselector_tests.cpp\r\n\r\n* Have SelectCoinsMinConf and SelectCoins use BnB or Knapsack and use it\r\n\r\nAllows SelectCoinsMinConf and SelectCoins be able to switch between\r\nusing BnB or Knapsack for choosing coins.\r\n\r\nHas SelectCoinsMinConf do the preprocessing necessary to support either\r\nBnB or Knapsack. This includes calculating the filtering the effective\r\nvalues for each input.\r\n\r\nUses BnB in CreateTransaction to find an exact match for the output.\r\nIf BnB fails, it will fallback to the Knapsack solver.\r\n\r\n* Benchmark BnB in the worst case where it exhausts\r\n\r\n* Add a test to make sure that negative effective values are filtered\r\n\r\n* travis: Clone depth 1 unless $CHECK_DOC\r\n\r\n* Fix ComputeTimeSmart test failure with -DDEBUG_LOCKORDER\r\n\r\nFailure looks like:\r\n\r\n    Entering test case \"ComputeTimeSmart\"\r\n    test_bitcoin: sync.cpp:100: void potential_deadlock_detected(const std::pair<void*, void*>&, const LockStack&, const LockStack&): Assertion `false' failed.\r\n    unknown location(0): fatal error in \"ComputeTimeSmart\": signal: SIGABRT (application abort requested)\r\n    wallet/test/wallet_tests.cpp(566): last checkpoint\r\n\r\nReproducible with:\r\n\r\n    ./configure --enable-debug\r\n    make -C src test/test_bitcoin && src/test/test_bitcoin --log_level=test_suite --run_test=wallet_tests/ComputeTimeSmart\r\n\r\nHappens due to \"92fabcd443 Add LookupBlockIndex function\" which acquires\r\ncs_main from inside CWallet::ComputeTimeSmart.\r\n\r\n* Merge READWRITEMANY into READWRITE\r\n\r\n* Support deserializing into temporaries\r\n\r\nCurrently, the READWRITE macro cannot be passed any non-const temporaries, as\r\nthe SerReadWrite function only accepts lvalue references.\r\n\r\nDeserializing into a temporary is very common, however. See for example\r\nthings like 's >> VARINT(n)'. The VARINT macro produces a temporary wrapper\r\nthat holds a reference to n.\r\n\r\nFix this by accepting non-const rvalue references instead of lvalue references.\r\nWe don't propagate the rvalue-ness down, as there are no useful optimizations\r\nthat only apply to temporaries.\r\n\r\nThen use this new functionality to get rid of many (but not all) uses of the\r\n'REF' macro (which casts away constness).\r\n\r\n* Apply hardening measurements in bitcoind systemd service file\r\n\r\nAdds typical systemd hardening measurements for network services.\r\n\r\n* Polish interfaces around PeerLogicValidation\r\n\r\n* Make PeerLogicValidation final to prevent deriving from it [1]\r\n* Prevent deletions of NetEventsInterface and CValidationInterface\r\n  objects via a base class pointer\r\n\r\n[1] silences the following compiler warning (from Clang 7.0.0):\r\n\r\n/usr/include/c++/v1/memory:2285:5: error: delete called on non-final 'PeerLogicValidation' that has\r\n      virtual functions but non-virtual destructor [-Werror,-Wdelete-non-virtual-dtor]\r\n    delete __ptr;\r\n    ^\r\n/usr/include/c++/v1/memory:2598:7: note: in instantiation of member function\r\n      'std::__1::default_delete<PeerLogicValidation>::operator()' requested here\r\n      __ptr_.second()(__tmp);\r\n      ^\r\ninit.cpp:201:15: note: in instantiation of member function 'std::__1::unique_ptr<PeerLogicValidation,\r\n      std::__1::default_delete<PeerLogicValidation> >::reset' requested here\r\n    peerLogic.reset();\r\n                  ^\r\n\r\n* Provide relevant error message if datadir is not writable.\r\n\r\n* Remove unused variable in SortForBlock\r\n\r\n* Actually disable BnB when there are preset inputs\r\n\r\nWe don't want to use BnB when there are preset inputs because there\r\nis some weirdness with making that work with using the KnapsackSolver\r\nas the fallback. Currently we say that we haven't used bnb when\r\nthere are preset inputs, but we don't actually disable BnB. This fixes\r\nthat.\r\n\r\n* Do not check for main() in libminiupnpc\r\n\r\nmain() { main(); } causes \"infinite recursion\" compilation warning\r\nwhich with -Werror fails the check.\r\n\r\n* ax_boost_{chrono,unit_test_framework}.m4: take changes from upstream\r\n\r\nApply changes to\r\nbuild-aux/m4/ax_boost_chrono.m4 and\r\nbuild-aux/m4/ax_boost_unit_test_framework.m4\r\nfrom upstream: https://github.com/peti/autoconf-archive\r\n\r\n* Remove redundant checks for MSG_* from configure.ac\r\n\r\nIt is redundant to check for the presence of MSG_NOSIGNAL macro in\r\nconfigure.ac, define HAVE_MSG_NOSIGNAL and then check whether the later\r\nis defined in the source code. Instead we can check directly whether\r\nMSG_NOSIGNAL is defined. Same for MSG_DONTWAIT.\r\n\r\nIn addition to that, the checks we had in configure.ac produce a\r\ncompiler warning about unused variable and thus could fail if\r\n-Werror is present and erroneously proclaim that the macros are\r\nnot available.\r\n\r\n* Test that BnB is not used when there are preset inputs\r\n\r\n* Document RPC method aliasing\r\n\r\nSuggested by Sjors Provoost <sjors@sprovoost.nl> in\r\nhttps://github.com/bitcoin/bitcoin/pull/11536#issuecomment-372820660\r\n\r\n* Add static_assert to prevent VARINT(<signed value>)\r\n\r\nUsing VARINT with signed types is dangerous because negative values will appear\r\nto serialize correctly, but then deserialize as positive values mod 128.\r\n\r\nThis commit changes the VARINT macro to trigger an error by default if called\r\nwith an signed value, and updates broken uses of VARINT to pass a special flag\r\nthat lets them keep working with no change in behavior.\r\n\r\n* test: Use wait_until in tests where time was used for polling\r\n\r\n* test: Use os.path.join consistently in feature_pruning tests\r\n\r\n* [Trivial] Simplify if-else blocks and more descriptive variable naming\r\n\r\n* Append scripts to new test_list array to fix bad assignment\r\n\r\n* wallet: Change output type globals to members\r\n\r\n* QA: Add -blocksdir test\r\n\r\n* [Tests] Move assert_start_raises_init_error method to TestNode\r\n\r\n* [Tests] Require exact match in assert_start_raises_init_eror()\r\n\r\n* Avoiding 'file' function name from python2 with more descriptive variable naming\r\n\r\n* Qt: remove \"new\" button during receive-mode in addressbook\r\n\r\n* [tests] Fix flake8 warnings in feature_block.py\r\n\r\n* [tests] Tidy up feature_block.py\r\n\r\n- move all helper methods to the end\r\n- remove block, create_tx and create_and_sign_tx shortcuts\r\n- remove --runbarelyexpensive option, since it defaults to True and it's\r\nunlikely that anyone ever runs the test with this option set to false.\r\n\r\n* [tests] Add logging to feature_block.py\r\n\r\n* Remove unreachable help conditions\r\n\r\n* Rename account to label where appropriate\r\n\r\nThis change only updates strings and adds RPC aliases, but should simplify the\r\nimplementation of address labels in\r\nhttps://github.com/bitcoin/bitcoin/pull/7729, by getting renaming out of the\r\nway and letting it focus on semantics.\r\n\r\nThe difference between accounts and labels is that labels apply only to\r\naddresses, while accounts apply to both addresses and transactions\r\n(transactions have \"from\" and \"to\" accounts). The code associating accounts\r\nwith transactions is clumsy and unreliable so we would like get rid of it.\r\n\r\n* Rename wallet_accounts.py test\r\n\r\nThis is a separate commit because changing the test at the same time as\r\nrenaming it breaks git (and github) rename detection.\r\n\r\n* qa: Use node.datadir instead of tmpdir in test framework\r\n\r\n* [tests] Change feature_block.py to use BitcoinTestFramework\r\n\r\n* [tests] Improve assert message when wait_until() fails\r\n\r\n* scripted-diff: rename TestNode to TestP2PConn in tests\r\n\r\nSeveral test scripts define a subclass of P2PInterface called TestNode.\r\nThis commit renames those to TestP2PConn since we already have a\r\nTestNode class in the test framework.\r\n\r\n-BEGIN VERIFY SCRIPT-\r\nsed -i s/TestNode/TestP2PConn/ test/functional/*py test/functional/test_framework/comptool.py\r\n_END VERIFY SCRIPT-\r\n\r\n* qa: Allow for partial_match when checking init error\r\n\r\nThis allows the tests to pass on different platforms\r\n\r\n* tests: Test connecting to a non-existing server\r\n\r\n* tests: Test connecting with non-existing RPC cookie file\r\n\r\n* -blocksdir: keep blockindex leveldb database in datadir\r\n\r\n* Remove unnecessary NONNEGATIVE_SIGNED\r\n\r\nSwitch to unsigned encoding, which is backwards compatible and avoids MSVC\r\nerror reported https://github.com/bitcoin/bitcoin/issues/12732\r\n\r\n* use base58 map instead of strchr()\r\n\r\n* Make FastRandomContext support standard C++11 RNG interface\r\n\r\nThis makes it possible to plug it into the various standard C++11 random\r\ndistribution algorithms and other functions like std::shuffle.\r\n\r\n* Fix typos\r\n\r\n* tests: Remove unused argument max_invalid from check_estimates(...)\r\n\r\n* Fix typos\r\n\r\n* Qt: Warn users about invalid-BIP21 URI bitcoin://\r\n\r\n* shuffle selected coins before transaction finalization\r\n\r\n* Replace boost::call_once with std::call_once\r\n\r\n* Add native support for serializing char arrays without FLATDATA\r\n\r\nSupport is added to serialize arrays of type char or unsigned char directly,\r\nwithout any wrappers. All invocations of the FLATDATA wrappers that are\r\nobsoleted by this are removed.\r\n\r\nThis includes a patch by Russell Yanofsky to make char casting type safe.\r\n\r\nThe serialization of CSubNet is changed to serialize a bool directly rather\r\nthan though FLATDATA. This makes the serialization independent of the size\r\nof the bool type (and will use 1 byte everywhere).\r\n\r\n* Move compressor utility functions out of class\r\n\r\n* [config] Remove blockmaxsize option\r\n\r\nThe blockmaxsize option was marked as deprecated in V0.15.1, and code\r\nwas added to convert provided blockmaxsize into blockmaxweight. However,\r\nthis code was incorrectly implemented, and blockmaxsize was silently\r\nignored.\r\n\r\nNo users have complained about blockmaxsize being ignored, so just\r\nremove it in V0.17.\r\n\r\n* Docs: Improve documentation on standard communication channels\r\n\r\nMore information about connection on IRC will hopefully help new\r\ncontributors.\r\n\r\n* shuffle sendmany recipients ordering to shuffle tx outputs\r\n\r\n* add release note for sendmany output shuffling\r\n\r\n* [CI]: bump travis timeout for make check to 50m\r\n\r\n* Inline CKeyStore::AddKey(const CKey &) in CBasicKeyStore\r\n\r\n* Move CKeyStore::cs_KeyStore to CBasicKeyStore\r\n\r\n* Make CTxMemPool::isSpent() const\r\n\r\n* [REST] Handle UTXO retrieval when ignoring the mempool\r\n\r\nCurrent REST API always returns empty UTXO when invoked without `/checkmempool/` URL part.\r\n\r\nAfter the fix:\r\n```\r\n$ curl -s http://localhost:8332/rest/getutxos/0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098-0.json | jq\r\n{\r\n  \"chainHeight\": 514109,\r\n  \"chaintipHash\": \"0000000000000000001fe76d1445e8a6432fd2de04261dc9c5915311dc7ad6de\",\r\n  \"bitmap\": \"1\",\r\n  \"utxos\": [\r\n    {\r\n      \"height\": 1,\r\n      \"value\": 50,\r\n      \"scriptPubKey\": {\r\n        \"asm\": \"0496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858ee OP_CHECKSIG\",\r\n        \"hex\": \"410496b538e853519c726a2c91e61ec11600ae1390813a627c66fb8be7947be63c52da7589379515d4e0a604f8141781e62294721166bf621e73a82cbf2342c858eeac\",\r\n        \"reqSigs\": 1,\r\n        \"type\": \"pubkey\",\r\n        \"addresses\": [\r\n          \"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nBefore the fix:\r\n```\r\n$ curl -s http://localhost:8332/rest/getutxos/0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098-0.json | jq\r\n{\r\n  \"chainHeight\": 514109,\r\n  \"chaintipHash\": \"0000000000000000001fe76d1445e8a6432fd2de04261dc9c5915311dc7ad6de\",\r\n  \"bitmap\": \"0\",\r\n  \"utxos\": []\r\n}\r\n```\r\n\r\n* Add username and ip logging for RPC method requests\r\n\r\n* Qt: Remove unused method setupAmountWidget(...)\r\n\r\n* Introduce interface for signing providers\r\n\r\nCKeyStore is a rich interface that provides many features, including knowledge\r\nof scripts and pubkeys for solving, private keys for signing, in addition to\r\nwatch-only keys and scripts, and distinguishing lack of keys from them just\r\nbeing encrypted.\r\n\r\nThe signing logic in script/sign does not actually need most of these features.\r\nHere we introduce a simpler interface (SigningProvider) which *only* provides\r\nkeys and scripts. This is actually sufficient for signing.\r\n\r\nIn addtion, we swap the dependency between keystore and script/sign\r\n(keystore now depends on script/script with CKeyStore deriving from\r\nSigningProvider, rather than CKeyStore being the interface that signing\r\nrelies on).\r\n\r\n* Reduce variable scopes\r\n\r\n* Qt: Add wallet selector to debug console\r\n\r\n* Qt: QComboBox::setVisible doesn't work in toolbars, so defer adding it at all until needed\r\n\r\n* Qt: Get wallet name from WalletModel rather than passing it around\r\n\r\n* Qt: When multiple wallets are used, include in notifications the name\r\n\r\n* GUI: RPCConsole: Log wallet changes\r\n\r\n* Qt: show wallet name in send confirmation dlg in case of multiwallet\r\n\r\n* Qt: show wallet name in request dlg in case of multiwallet\r\n\r\n* Qt: hide RPCConsole wallet selector when no wallets are present\r\n\r\n* rpc: Adjust ifdef to avoid unreachable code\r\n\r\n* [Tests] Use blockmaxweight where tests previously had blockmaxsize\r\n\r\n* [wallet] Move wallet init functions into WalletInit class.\r\n\r\n* [wallet] Create wallet init interface.\r\n\r\n* qt: Avoid resetting on resetguisettigs=0\r\n\r\n* do not truncate .dat extension for wallets in gui\r\n\r\n* Change all python files to use Python3\r\n\r\n* init: Fix help message for checkblockindex\r\n\r\n* doc: Refer to witness reserved value as spec. in the BIP\r\n\r\n* doc: Add note about our preference for scoped enumerations (\"enum class\")\r\n\r\n* [wallet] Use global g_wallet_init_interface to init/destroy the wallet.\r\n\r\nThis commit creates a global g_wallet_init_interface, which is created\r\nin bitcoind and bitcoin-qt. g_wallet_init_interface is used to init\r\nand destroy the wallet.\r\n\r\nThis removes the dependency from init.cpp on the wallet library.\r\n\r\n* [wallet] Add dummy wallet init class\r\n\r\n* Fix error in memory usage calculation (unintended integer division)\r\n\r\n* qa: Fix function names in feature_blocksdir\r\n\r\n* Add additional tests for GetBoolArg()\r\n\r\nThis is meant to be an intermediate commit to prove that the next does not\r\nintroduce any changes in the semantics of boolean option parsing.\r\n\r\n* Track negated arguments in the argument paser.\r\n\r\nThis commit adds tracking for negated arguments. This change will be used in a\r\nfuture commit that allows disabling the debug.log file using -nodebuglogfile.\r\n\r\n* test: Make summary row bold-red if any test failed\r\n\r\nMake the summary row of the test runner bold red if any test fails.\r\nThis helps visibility if something fails.\r\n\r\n* Make base58 python contrib code work with python3\r\n\r\n* test: List any failed tests at the end of test_runner output\r\n\r\nChange sorting output to put failed tests at the end of test_runner\r\noutput.\r\n\r\n* [Tests] fix a typo in TestNode.assert_start_raises_init_error()\r\n\r\nAlso, use specific exception for testing TestNode initialization failure.\r\n\r\n* contrib: Fix check-doc script regexes\r\n\r\n* contrib: Remove unused import string\r\n\r\n* init: Remove help text for non-existent -fuzzmessagestest arg\r\n\r\n* Revert \"test: Update trust git root\".\r\n\r\nThis reverts commit 7deba93bdc76616011a9f493cbc203d60084416f.\r\n\r\nThis is neither a \"test\" change, nor should the trusted-git-root\r\nhave been updated - there is a process for expired PGP keys.\r\n\r\n* Add Marco-expired-key-signed-commits to allow-revsig-commits\r\n\r\n* Improve formatting of developer notes\r\n\r\nSummary of changes:\r\n\r\n * Add a TOC to the page\r\n * Make tips and tricks section use h3 headings\r\n * Reformat and clarify some sections\r\n\r\n* Add --with-sanitizers option to configure\r\n\r\nThis enables the use of different compiler sanitizers, coresponding to\r\nthe -fsanitize option in GCC and Clang.\r\n\r\n* [tests] Fix intermittent rpc_net.py failure.\r\n\r\nrpc_net.py would intermittently fail on Travis, probably\r\ndue to assuming that two consecutive RPC calls were atomic.\r\nFix this by only testing that amounts are bounded above and\r\nbelow rather than equal.\r\n\r\n* [contrib] fixup security-check.py Python3 support\r\n\r\n* [contrib] fixup symbol-check.py Python3 support\r\n\r\n* Bugfix: RPC: savemempool: Don't save until LoadMempool() is finished\r\n\r\n* Increase LevelDB max_open_files unless on 32-bit Unix.\r\n\r\nThis change significantly increases IBD performance by increasing the\r\namount of the UTXO index that can remain in memory. To ensure this\r\ndoesn't cause problems in the future, a static_assert on the LevelDB\r\nversion has been added, which must be updated by anyone upgrading\r\nLevelDB.\r\n\r\n* [verify-commits] Add some additional useful documentation.\r\n\r\n* test: Remove travis checkout depth\r\n\r\nTests on branches of non-head commits are failing, because the depth of\r\n1 doesn't allow checking them out.\r\n\r\nRemove `depth` as was the case before fa44af5cd2152a21da9ef3e48c073a668bf2df27,\r\nso that Travis can determine the minimum depth to check out.\r\n\r\n* Fixes Missing QRCode Build\r\n\r\nBuild was missing qr code(qrencode libs) support and brew team no longer supports anything less than macOS 10.11\r\n\r\n* Fixed notes\r\n\r\nFixed notes to reflect that 10.8 is still supported via gitian\r\n\r\n* Rolled Back Tested on\r\n\r\nBelow is a suggestion for future release after EOL is done\r\n\r\n* Works with macOS 10.11 through 10.13 on 64-bit Intel processors only.\r\n\r\n* macOS 10.8 and higher is still supported on [gitian](/contrib) builds\r\n\r\n* Update build-osx.md\r\n\r\nBelow is a suggestion for future release after EOL is done\r\n\r\n* Works with macOS 10.11 through 10.13 on 64-bit Intel processors only.\r\n\r\n* macOS 10.8 and higher is still supported on [gitian](/contrib) builds\r\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/924d4ae38d34738b6313992a2b10984c398b23d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/924d4ae38d34738b6313992a2b10984c398b23d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/924d4ae38d34738b6313992a2b10984c398b23d2/comments",
    "author": null,
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "07090c5339436f856e79a8036d1c85deeb453803",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07090c5339436f856e79a8036d1c85deeb453803",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/07090c5339436f856e79a8036d1c85deeb453803"
      }
    ],
    "stats": {
      "total": 13690,
      "additions": 8652,
      "deletions": 5038
    },
    "files": [
      {
        "sha": "69397c26bfa192e51dcc3ec8ab97d3d9b8d82607",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -3,6 +3,7 @@ dist: trusty\n os: linux\n language: minimal\n cache:\n+  ccache: true\n   directories:\n   - depends/built\n   - depends/sdk-sources\n@@ -45,6 +46,7 @@ install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then travis_retry pip3 install flake8 --user; fi\n before_script:\n+    - if [ \"$CHECK_DOC\" = 1 ]; then git fetch --unshallow; fi\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/git-subtree-check.sh src/crypto/ctaes; fi\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/git-subtree-check.sh src/secp256k1; fi\n@@ -62,13 +64,12 @@ before_script:\n     - if [ \"$NEED_XVFB\" = 1 ]; then export DISPLAY=:99.0; /sbin/start-stop-daemon --start --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -ac; fi\n script:\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys; fi\n-    - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then git fetch --unshallow; fi\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then contrib/verify-commits/verify-commits.sh; fi\n     - export TRAVIS_COMMIT_LOG=`git log --format=fuller -1`\n     - if [ -n \"$USE_SHELL\" ]; then export CONFIG_SHELL=\"$USE_SHELL\"; fi\n     - OUTDIR=$BASE_OUTDIR/$TRAVIS_PULL_REQUEST/$TRAVIS_JOB_NUMBER-$HOST\n     - BITCOIN_CONFIG_ALL=\"--disable-dependency-tracking --prefix=$TRAVIS_BUILD_DIR/depends/$HOST --bindir=$OUTDIR/bin --libdir=$OUTDIR/lib\"\n-    - if [ -z \"$NO_DEPENDS\" ]; then depends/$HOST/native/bin/ccache --max-size=$CCACHE_SIZE; fi\n+    - if [ -z \"$NO_DEPENDS\" ]; then ccache --max-size=$CCACHE_SIZE; fi\n     - test -n \"$USE_SHELL\" && eval '\"$USE_SHELL\" -c \"./autogen.sh\"' || ./autogen.sh\n     - mkdir build && cd build\n     - ../configure --cache-file=config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n@@ -77,7 +78,7 @@ script:\n     - ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 30 make $MAKEJOBS check VERBOSE=1; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 50 make $MAKEJOBS check VERBOSE=1; fi\n     - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude feature_pruning,feature_dbcrash\"; fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --combinedlogslen=4000 --coverage --quiet ${extended}; fi\n after_script:"
      },
      {
        "sha": "ea475f8cfb76635a18bb62a986d2fef69c79e673",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -15,6 +15,24 @@ merging pull requests as well as a \"lead maintainer\" who is responsible for the\n release cycle, overall merging, moderation and appointment of maintainers.\n \n \n+Communication Channels\n+----------------------\n+\n+Most communication about Bitcoin Core development happens on IRC, in the\n+#bitcoin-core-dev channel on Freenode. The easiest way to participate on IRC is\n+with the web client, [webchat.freenode.net](https://webchat.freenode.net/). Chat\n+history logs can be found\n+on [botbot.me](https://botbot.me/freenode/bitcoin-core-dev/).\n+\n+Discussion about code base improvements happens in GitHub issues and on pull\n+requests.\n+\n+The developer\n+[mailing list](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev)\n+should be used to discuss complicated or controversial changes before working on\n+a patch set.\n+\n+\n Contributor Workflow\n --------------------\n "
      },
      {
        "sha": "acdbe461049b614013fe653211ae57fab26db128",
        "filename": "README.md",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -33,12 +33,6 @@ regularly to indicate new official, stable release versions of Bitcoin Core.\n \n The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md).\n \n-The developer [mailing list](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev)\n-should be used to discuss complicated or controversial changes before working\n-on a patch set.\n-\n-Developer IRC can be found on Freenode at #bitcoin-core-dev.\n-\n Testing\n -------\n "
      },
      {
        "sha": "e9b0f2061cd038d09691892421c27eeaea375aa9",
        "filename": "build-aux/m4/ax_boost_chrono.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/build-aux/m4/ax_boost_chrono.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/build-aux/m4/ax_boost_chrono.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_boost_chrono.m4?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,5 +1,5 @@\n # ===========================================================================\n-#      http://www.gnu.org/software/autoconf-archive/ax_boost_chrono.html\n+#     https://www.gnu.org/software/autoconf-archive/ax_boost_chrono.html\n # ===========================================================================\n #\n # SYNOPSIS\n@@ -8,7 +8,7 @@\n #\n # DESCRIPTION\n #\n-#   Test for System library from the Boost C++ libraries. The macro requires\n+#   Test for Chrono library from the Boost C++ libraries. The macro requires\n #   a preceding call to AX_BOOST_BASE. Further documentation is available at\n #   <http://randspringer.de/boost/index.html>.\n #\n@@ -29,7 +29,7 @@\n #   and this notice are preserved. This file is offered as-is, without any\n #   warranty.\n \n-#serial 1\n+#serial 4\n \n AC_DEFUN([AX_BOOST_CHRONO],\n [\n@@ -68,7 +68,7 @@ AC_DEFUN([AX_BOOST_CHRONO],\n \t\t\t CXXFLAGS_SAVE=$CXXFLAGS\n \n \t\t\t AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <boost/chrono.hpp>]],\n-                                   [[boost::chrono::system_clock::time_point time;]])],\n+                                   [[boost::chrono::system_clock::time_point* time = new boost::chrono::system_clock::time_point; delete time;]])],\n                    ax_cv_boost_chrono=yes, ax_cv_boost_chrono=no)\n \t\t\t CXXFLAGS=$CXXFLAGS_SAVE\n              AC_LANG_POP([C++])"
      },
      {
        "sha": "0cdbe752cfb78ab887b35968745347a367a8ace5",
        "filename": "build-aux/m4/ax_boost_unit_test_framework.m4",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/build-aux/m4/ax_boost_unit_test_framework.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/build-aux/m4/ax_boost_unit_test_framework.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_boost_unit_test_framework.m4?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,6 +1,6 @@\n-# ================================================================================\n-#  http://www.gnu.org/software/autoconf-archive/ax_boost_unit_test_framework.html\n-# ================================================================================\n+# =================================================================================\n+#  https://www.gnu.org/software/autoconf-archive/ax_boost_unit_test_framework.html\n+# =================================================================================\n #\n # SYNOPSIS\n #\n@@ -29,7 +29,7 @@\n #   and this notice are preserved. This file is offered as-is, without any\n #   warranty.\n \n-#serial 19\n+#serial 21\n \n AC_DEFUN([AX_BOOST_UNIT_TEST_FRAMEWORK],\n [\n@@ -66,7 +66,7 @@ AC_DEFUN([AX_BOOST_UNIT_TEST_FRAMEWORK],\n         [AC_LANG_PUSH([C++])\n \t\t\t AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <boost/test/unit_test.hpp>]],\n                                     [[using boost::unit_test::test_suite;\n-\t\t\t\t\t\t\t test_suite* test= BOOST_TEST_SUITE( \"Unit test example 1\" ); return 0;]])],\n+\t\t\t\t\t\t\t test_suite* test= BOOST_TEST_SUITE( \"Unit test example 1\" ); if (test == NULL) { return 1; } else { return 0; }]])],\n                    ax_cv_boost_unit_test_framework=yes, ax_cv_boost_unit_test_framework=no)\n          AC_LANG_POP([C++])\n \t\t])"
      },
      {
        "sha": "c422914a26e567811d3598ef681b718eca87fd76",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 60,
        "deletions": 20,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -148,9 +148,9 @@ AC_ARG_WITH([qrencode],\n \n AC_ARG_ENABLE([hardening],\n   [AS_HELP_STRING([--disable-hardening],\n-  [do not attempt to harden the resulting executables (default is to harden)])],\n+  [do not attempt to harden the resulting executables (default is to harden when possible)])],\n   [use_hardening=$enableval],\n-  [use_hardening=yes])\n+  [use_hardening=auto])\n \n AC_ARG_ENABLE([reduce-exports],\n   [AS_HELP_STRING([--enable-reduce-exports],\n@@ -219,6 +219,19 @@ AC_ARG_ENABLE([debug],\n     [enable_debug=$enableval],\n     [enable_debug=no])\n \n+# Enable different -fsanitize options\n+AC_ARG_WITH([sanitizers],\n+    [AS_HELP_STRING([--with-sanitizers],\n+                    [comma separated list of extra sanitizers to build with (default is none enabled)])],\n+    [use_sanitizers=$withval])\n+\n+# Enable gprof profiling\n+AC_ARG_ENABLE([gprof],\n+    [AS_HELP_STRING([--enable-gprof],\n+                    [use gprof profiling compiler flags (default is no)])],\n+    [enable_gprof=$enableval],\n+    [enable_gprof=no])\n+\n # Turn warnings into errors\n AC_ARG_ENABLE([werror],\n     [AS_HELP_STRING([--enable-werror],\n@@ -240,6 +253,26 @@ if test \"x$enable_debug\" = xyes; then\n     fi\n fi\n \n+if test x$use_sanitizers != x; then\n+  # First check if the compiler accepts flags. If an incompatible pair like\n+  # -fsanitize=address,thread is used here, this check will fail. This will also\n+  # fail if a bad argument is passed, e.g. -fsanitize=undfeined\n+  AX_CHECK_COMPILE_FLAG(\n+    [[-fsanitize=$use_sanitizers]],\n+    [[SANITIZER_CXXFLAGS=-fsanitize=$use_sanitizers]],\n+    [AC_MSG_ERROR([compiler did not accept requested flags])])\n+\n+  # Some compilers (e.g. GCC) require additional libraries like libasan,\n+  # libtsan, libubsan, etc. Make sure linking still works with the sanitize\n+  # flag. This is a separate check so we can give a better error message when\n+  # the sanitize flags are supported by the compiler but the actual sanitizer\n+  # libs are missing.\n+  AX_CHECK_LINK_FLAG(\n+    [[-fsanitize=$use_sanitizers]],\n+    [[SANITIZER_LDFLAGS=-fsanitize=$use_sanitizers]],\n+    [AC_MSG_ERROR([linker did not accept requested flags, you are missing required libraries])])\n+fi\n+\n ERROR_CXXFLAGS=\n if test \"x$enable_werror\" = \"xyes\"; then\n   if test \"x$CXXFLAG_WERROR\" = \"x\"; then\n@@ -558,12 +591,30 @@ else\n   AC_SEARCH_LIBS([clock_gettime],[rt])\n fi\n \n+if test \"x$enable_gprof\" = xyes; then\n+    dnl -pg is incompatible with -pie. Since hardening and profiling together doesn't make sense,\n+    dnl we simply make them mutually exclusive here. Additionally, hardened toolchains may force\n+    dnl -pie by default, in which case it needs to be turned off with -no-pie.\n+\n+    if test x$use_hardening = xyes; then\n+        AC_MSG_ERROR(gprof profiling is not compatible with hardening. Reconfigure with --disable-hardening or --disable-gprof)\n+    fi\n+    use_hardening=no\n+    AX_CHECK_COMPILE_FLAG([-pg],[GPROF_CXXFLAGS=\"-pg\"],\n+        [AC_MSG_ERROR(gprof profiling requested but not available)], [[$CXXFLAG_WERROR]])\n+\n+    AX_CHECK_LINK_FLAG([[-no-pie]], [GPROF_LDFLAGS=\"-no-pie\"])\n+    AX_CHECK_LINK_FLAG([[-pg]],[GPROF_LDFLAGS=\"$GPROF_LDFLAGS -pg\"],\n+        [AC_MSG_ERROR(gprof profiling requested but not available)], [[$GPROF_LDFLAGS]])\n+fi\n+\n if test x$TARGET_OS != xwindows; then\n   # All windows code is PIC, forcing it on just adds useless compile warnings\n   AX_CHECK_COMPILE_FLAG([-fPIC],[PIC_FLAGS=\"-fPIC\"])\n fi\n \n if test x$use_hardening != xno; then\n+  use_hardening=yes\n   AX_CHECK_COMPILE_FLAG([-Wstack-protector],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -Wstack-protector\"])\n   AX_CHECK_COMPILE_FLAG([-fstack-protector-all],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fstack-protector-all\"])\n \n@@ -618,22 +669,6 @@ AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,\n \n AC_CHECK_DECLS([__builtin_clz, __builtin_clzl, __builtin_clzll])\n \n-dnl Check for MSG_NOSIGNAL\n-AC_MSG_CHECKING(for MSG_NOSIGNAL)\n-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n- [[ int f = MSG_NOSIGNAL; ]])],\n- [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_MSG_NOSIGNAL, 1,[Define this symbol if you have MSG_NOSIGNAL]) ],\n- [ AC_MSG_RESULT(no)]\n-)\n-\n-dnl Check for MSG_DONTWAIT\n-AC_MSG_CHECKING(for MSG_DONTWAIT)\n-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n- [[ int f = MSG_DONTWAIT; ]])],\n- [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_MSG_DONTWAIT, 1,[Define this symbol if you have MSG_DONTWAIT]) ],\n- [ AC_MSG_RESULT(no)]\n-)\n-\n dnl Check for malloc_info (for memory statistics information in getmemoryinfo)\n AC_MSG_CHECKING(for getmemoryinfo)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <malloc.h>]],\n@@ -746,7 +781,7 @@ dnl Check for libminiupnpc (optional)\n if test x$use_upnp != xno; then\n   AC_CHECK_HEADERS(\n     [miniupnpc/miniwget.h miniupnpc/miniupnpc.h miniupnpc/upnpcommands.h miniupnpc/upnperrors.h],\n-    [AC_CHECK_LIB([miniupnpc], [main],[MINIUPNPC_LIBS=-lminiupnpc], [have_miniupnpc=no])],\n+    [AC_CHECK_LIB([miniupnpc], [upnpDiscover], [MINIUPNPC_LIBS=-lminiupnpc], [have_miniupnpc=no])],\n     [have_miniupnpc=no]\n   )\n fi\n@@ -1030,7 +1065,7 @@ if test x$system_univalue != xno ; then\n     m4_ifdef(\n       [PKG_CHECK_MODULES],\n       [\n-        PKG_CHECK_MODULES([UNIVALUE],[libunivalue],[found_univalue=yes],[true])\n+        PKG_CHECK_MODULES([UNIVALUE],[libunivalue >= 1.0.4],[found_univalue=yes],[true])\n       ]\n     )\n   else\n@@ -1242,11 +1277,15 @@ AC_SUBST(BITCOIN_TX_NAME)\n \n AC_SUBST(RELDFLAGS)\n AC_SUBST(ERROR_CXXFLAGS)\n+AC_SUBST(GPROF_CXXFLAGS)\n+AC_SUBST(GPROF_LDFLAGS)\n AC_SUBST(HARDENED_CXXFLAGS)\n AC_SUBST(HARDENED_CPPFLAGS)\n AC_SUBST(HARDENED_LDFLAGS)\n AC_SUBST(PIC_FLAGS)\n AC_SUBST(PIE_FLAGS)\n+AC_SUBST(SANITIZER_CXXFLAGS)\n+AC_SUBST(SANITIZER_LDFLAGS)\n AC_SUBST(SSE42_CXXFLAGS)\n AC_SUBST(LIBTOOL_APP_LDFLAGS)\n AC_SUBST(USE_UPNP)\n@@ -1335,6 +1374,7 @@ echo \"  with bench    = $use_bench\"\n echo \"  with upnp     = $use_upnp\"\n echo \"  use asm       = $use_asm\"\n echo \"  debug enabled = $enable_debug\"\n+echo \"  gprof enabled = $enable_gprof\"\n echo \"  werror        = $enable_werror\"\n echo\n echo \"  target os     = $TARGET_OS\""
      },
      {
        "sha": "0c2e1a24be07a2e59a8acb2b3121059c95eb05ed",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 24,
        "deletions": 22,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -16,31 +16,33 @@\n \n FOLDER_GREP = 'src'\n FOLDER_TEST = 'src/test/'\n-CMD_ROOT_DIR = '`git rev-parse --show-toplevel`/%s' % FOLDER_GREP\n-CMD_GREP_ARGS = r\"egrep -r -I '(map(Multi)?Args(\\.count\\(|\\[)|Get(Bool)?Arg\\()\\\"\\-[^\\\"]+?\\\"' %s | grep -v '%s'\" % (CMD_ROOT_DIR, FOLDER_TEST)\n-CMD_GREP_DOCS = r\"egrep -r -I 'HelpMessageOpt\\(\\\"\\-[^\\\"=]+?(=|\\\")' %s\" % (CMD_ROOT_DIR)\n-REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n-REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n+REGEX_ARG = '(?:ForceSet|SoftSet|Get|Is)(?:Bool)?Args?(?:Set)?\\(\"(-[^\"]+)\"'\n+REGEX_DOC = 'HelpMessageOpt\\(\"(-[^\"=]+?)(?:=|\")'\n+CMD_ROOT_DIR = '`git rev-parse --show-toplevel`/{}'.format(FOLDER_GREP)\n+CMD_GREP_ARGS = r\"git grep --perl-regexp '{}' -- {} ':(exclude){}'\".format(REGEX_ARG, CMD_ROOT_DIR, FOLDER_TEST)\n+CMD_GREP_DOCS = r\"git grep --perl-regexp '{}' {}\".format(REGEX_DOC, CMD_ROOT_DIR)\n # list unsupported, deprecated and duplicate args as they need no documentation\n SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio', '-forcecompactdb', '-usehd'])\n \n+\n def main():\n-  used = check_output(CMD_GREP_ARGS, shell=True)\n-  docd = check_output(CMD_GREP_DOCS, shell=True)\n-\n-  args_used = set(re.findall(REGEX_ARG,used))\n-  args_docd = set(re.findall(REGEX_DOC,docd)).union(SET_DOC_OPTIONAL)\n-  args_need_doc = args_used.difference(args_docd)\n-  args_unknown = args_docd.difference(args_used)\n-\n-  print \"Args used        : %s\" % len(args_used)\n-  print \"Args documented  : %s\" % len(args_docd)\n-  print \"Args undocumented: %s\" % len(args_need_doc)\n-  print args_need_doc\n-  print \"Args unknown     : %s\" % len(args_unknown)\n-  print args_unknown\n-\n-  sys.exit(len(args_need_doc))\n+    used = check_output(CMD_GREP_ARGS, shell=True, universal_newlines=True)\n+    docd = check_output(CMD_GREP_DOCS, shell=True, universal_newlines=True)\n+\n+    args_used = set(re.findall(re.compile(REGEX_ARG), used))\n+    args_docd = set(re.findall(re.compile(REGEX_DOC), docd)).union(SET_DOC_OPTIONAL)\n+    args_need_doc = args_used.difference(args_docd)\n+    args_unknown = args_docd.difference(args_used)\n+\n+    print(\"Args used        : {}\".format(len(args_used)))\n+    print(\"Args documented  : {}\".format(len(args_docd)))\n+    print(\"Args undocumented: {}\".format(len(args_need_doc)))\n+    print(args_need_doc)\n+    print(\"Args unknown     : {}\".format(len(args_unknown)))\n+    print(args_unknown)\n+\n+    sys.exit(len(args_need_doc))\n+\n \n if __name__ == \"__main__\":\n     main()"
      },
      {
        "sha": "5402870fbab15be89b38cf8deeffe425a51c27d0",
        "filename": "contrib/devtools/clang-format-diff.py",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/clang-format-diff.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/clang-format-diff.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/clang-format-diff.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n #\n #===- clang-format-diff.py - ClangFormat Diff Reformatter ----*- python -*--===#\n #\n@@ -69,10 +69,9 @@\n \n import argparse\n import difflib\n+import io\n import re\n-import string\n import subprocess\n-import StringIO\n import sys\n \n \n@@ -133,30 +132,33 @@ def main():\n           ['-lines', str(start_line) + ':' + str(end_line)])\n \n   # Reformat files containing changes in place.\n-  for filename, lines in lines_by_file.iteritems():\n+  for filename, lines in lines_by_file.items():\n     if args.i and args.verbose:\n-      print 'Formatting', filename\n+      print('Formatting {}'.format(filename))\n     command = [binary, filename]\n     if args.i:\n       command.append('-i')\n     if args.sort_includes:\n       command.append('-sort-includes')\n     command.extend(lines)\n     command.extend(['-style=file', '-fallback-style=none'])\n-    p = subprocess.Popen(command, stdout=subprocess.PIPE,\n-                         stderr=None, stdin=subprocess.PIPE)\n+    p = subprocess.Popen(command,\n+                         stdout=subprocess.PIPE,\n+                         stderr=None,\n+                         stdin=subprocess.PIPE,\n+                         universal_newlines=True)\n     stdout, stderr = p.communicate()\n     if p.returncode != 0:\n       sys.exit(p.returncode)\n \n     if not args.i:\n       with open(filename) as f:\n         code = f.readlines()\n-      formatted_code = StringIO.StringIO(stdout).readlines()\n+      formatted_code = io.StringIO(stdout).readlines()\n       diff = difflib.unified_diff(code, formatted_code,\n                                   filename, filename,\n                                   '(before formatting)', '(after formatting)')\n-      diff_string = string.join(diff, '')\n+      diff_string = ''.join(diff)\n       if len(diff_string) > 0:\n         sys.stdout.write(diff_string)\n "
      },
      {
        "sha": "c5d43043d5d24b11ef7c6e5a55d7ee2afeabe93c",
        "filename": "contrib/devtools/lint-whitespace.sh",
        "status": "modified",
        "additions": 33,
        "deletions": 9,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/lint-whitespace.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/lint-whitespace.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-whitespace.sh?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -7,12 +7,26 @@\n # Check for new lines in diff that introduce trailing whitespace.\n \n # We can't run this check unless we know the commit range for the PR.\n+\n+while getopts \"?\" opt; do\n+  case $opt in\n+    ?)\n+      echo \"Usage: .lint-whitespace.sh [N]\"\n+      echo \"       TRAVIS_COMMIT_RANGE='<commit range>' .lint-whitespace.sh\"\n+      echo \"       .lint-whitespace.sh -?\"\n+      echo \"Checks unstaged changes, the previous N commits, or a commit range.\"\n+      echo \"TRAVIS_COMMIT_RANGE='47ba2c3...ee50c9e' .lint-whitespace.sh\"\n+      exit 0\n+    ;;\n+  esac\n+done\n+\n if [ -z \"${TRAVIS_COMMIT_RANGE}\" ]; then\n-  echo \"Cannot run lint-whitespace.sh without commit range. To run locally, use:\"\n-  echo \"TRAVIS_COMMIT_RANGE='<commit range>' .lint-whitespace.sh\"\n-  echo \"For example:\"\n-  echo \"TRAVIS_COMMIT_RANGE='47ba2c3...ee50c9e' .lint-whitespace.sh\"\n-  exit 1\n+  if [ \"$1\" ]; then\n+    TRAVIS_COMMIT_RANGE=\"HEAD~$1...HEAD\"\n+  else\n+    TRAVIS_COMMIT_RANGE=\"HEAD\"\n+  fi\n fi\n \n showdiff() {\n@@ -37,51 +51,61 @@ if showdiff | grep -E -q '^\\+.*\\s+$'; then\n   echo \"The following changes were suspected:\"\n   FILENAME=\"\"\n   SEEN=0\n+  SEENLN=0\n   while read -r line; do\n     if [[ \"$line\" =~ ^diff ]]; then\n       FILENAME=\"$line\"\n       SEEN=0\n     elif [[ \"$line\" =~ ^@@ ]]; then\n       LINENUMBER=\"$line\"\n+      SEENLN=0\n     else\n       if [ \"$SEEN\" -eq 0 ]; then\n         # The first time a file is seen with trailing whitespace, we print the\n         # filename (preceded by a newline).\n         echo\n         echo \"$FILENAME\"\n-        echo \"$LINENUMBER\"\n         SEEN=1\n       fi\n+      if [ \"$SEENLN\" -eq 0 ]; then\n+        echo \"$LINENUMBER\"\n+        SEENLN=1\n+      fi\n       echo \"$line\"\n     fi\n   done < <(showdiff | grep -E '^(diff --git |@@|\\+.*\\s+$)')\n   RET=1\n fi\n \n # Check if tab characters were found in the diff.\n-if showcodediff | grep -P -q '^\\+.*\\t'; then\n+if showcodediff | perl -nle '$MATCH++ if m{^\\+.*\\t}; END{exit 1 unless $MATCH>0}' > /dev/null; then\n   echo \"This diff appears to have added new lines with tab characters instead of spaces.\"\n   echo \"The following changes were suspected:\"\n   FILENAME=\"\"\n   SEEN=0\n+  SEENLN=0\n   while read -r line; do\n     if [[ \"$line\" =~ ^diff ]]; then\n       FILENAME=\"$line\"\n       SEEN=0\n     elif [[ \"$line\" =~ ^@@ ]]; then\n       LINENUMBER=\"$line\"\n+      SEENLN=0\n     else\n       if [ \"$SEEN\" -eq 0 ]; then\n         # The first time a file is seen with a tab character, we print the\n         # filename (preceded by a newline).\n         echo\n         echo \"$FILENAME\"\n-        echo \"$LINENUMBER\"\n         SEEN=1\n       fi\n+      if [ \"$SEENLN\" -eq 0 ]; then\n+        echo \"$LINENUMBER\"\n+        SEENLN=1\n+      fi\n       echo \"$line\"\n     fi\n-  done < <(showcodediff | grep -P '^(diff --git |@@|\\+.*\\t)')\n+  done < <(showcodediff | perl -nle 'print if m{^(diff --git |@@|\\+.*\\t)}')\n   RET=1\n fi\n "
      },
      {
        "sha": "565b199125105c3e39fdba4d232826811dce55a1",
        "filename": "contrib/devtools/optimize-pngs.py",
        "status": "modified",
        "additions": 14,
        "deletions": 16,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/optimize-pngs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/optimize-pngs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/optimize-pngs.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -10,7 +10,7 @@\n import sys\n import subprocess\n import hashlib\n-from PIL import Image\n+from PIL import Image  # pip3 install Pillow\n \n def file_hash(filename):\n     '''Return hash of raw file contents'''\n@@ -27,7 +27,7 @@ def content_hash(filename):\n pngcrush = 'pngcrush'\n git = 'git'\n folders = [\"src/qt/res/movies\", \"src/qt/res/icons\", \"share/pixmaps\"]\n-basePath = subprocess.check_output([git, 'rev-parse', '--show-toplevel']).rstrip('\\n')\n+basePath = subprocess.check_output([git, 'rev-parse', '--show-toplevel'], universal_newlines=True).rstrip('\\n')\n totalSaveBytes = 0\n noHashChange = True\n \n@@ -37,42 +37,40 @@ def content_hash(filename):\n     for file in os.listdir(absFolder):\n         extension = os.path.splitext(file)[1]\n         if extension.lower() == '.png':\n-            print(\"optimizing \"+file+\"...\"),\n+            print(\"optimizing {}...\".format(file), end =' ')\n             file_path = os.path.join(absFolder, file)\n             fileMetaMap = {'file' : file, 'osize': os.path.getsize(file_path), 'sha256Old' : file_hash(file_path)}\n             fileMetaMap['contentHashPre'] = content_hash(file_path)\n         \n-            pngCrushOutput = \"\"\n             try:\n-                pngCrushOutput = subprocess.check_output(\n-                        [pngcrush, \"-brute\", \"-ow\", \"-rem\", \"gAMA\", \"-rem\", \"cHRM\", \"-rem\", \"iCCP\", \"-rem\", \"sRGB\", \"-rem\", \"alla\", \"-rem\", \"text\", file_path],\n-                        stderr=subprocess.STDOUT).rstrip('\\n')\n+                subprocess.call([pngcrush, \"-brute\", \"-ow\", \"-rem\", \"gAMA\", \"-rem\", \"cHRM\", \"-rem\", \"iCCP\", \"-rem\", \"sRGB\", \"-rem\", \"alla\", \"-rem\", \"text\", file_path],\n+                                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n             except:\n-                print \"pngcrush is not installed, aborting...\"\n+                print(\"pngcrush is not installed, aborting...\")\n                 sys.exit(0)\n         \n             #verify\n-            if \"Not a PNG file\" in subprocess.check_output([pngcrush, \"-n\", \"-v\", file_path], stderr=subprocess.STDOUT):\n-                print \"PNG file \"+file+\" is corrupted after crushing, check out pngcursh version\"\n+            if \"Not a PNG file\" in subprocess.check_output([pngcrush, \"-n\", \"-v\", file_path], stderr=subprocess.STDOUT, universal_newlines=True):\n+                print(\"PNG file \"+file+\" is corrupted after crushing, check out pngcursh version\")\n                 sys.exit(1)\n             \n             fileMetaMap['sha256New'] = file_hash(file_path)\n             fileMetaMap['contentHashPost'] = content_hash(file_path)\n \n             if fileMetaMap['contentHashPre'] != fileMetaMap['contentHashPost']:\n-                print \"Image contents of PNG file \"+file+\" before and after crushing don't match\"\n+                print(\"Image contents of PNG file {} before and after crushing don't match\".format(file))\n                 sys.exit(1)\n \n             fileMetaMap['psize'] = os.path.getsize(file_path)\n             outputArray.append(fileMetaMap)\n-            print(\"done\\n\"),\n+            print(\"done\")\n \n-print \"summary:\\n+++++++++++++++++\"\n+print(\"summary:\\n+++++++++++++++++\")\n for fileDict in outputArray:\n     oldHash = fileDict['sha256Old']\n     newHash = fileDict['sha256New']\n     totalSaveBytes += fileDict['osize'] - fileDict['psize']\n     noHashChange = noHashChange and (oldHash == newHash)\n-    print fileDict['file']+\"\\n  size diff from: \"+str(fileDict['osize'])+\" to: \"+str(fileDict['psize'])+\"\\n  old sha256: \"+oldHash+\"\\n  new sha256: \"+newHash+\"\\n\"\n+    print(fileDict['file']+\"\\n  size diff from: \"+str(fileDict['osize'])+\" to: \"+str(fileDict['psize'])+\"\\n  old sha256: \"+oldHash+\"\\n  new sha256: \"+newHash+\"\\n\")\n     \n-print \"completed. Checksum stable: \"+str(noHashChange)+\". Total reduction: \"+str(totalSaveBytes)+\" bytes\"\n+print(\"completed. Checksum stable: \"+str(noHashChange)+\". Total reduction: \"+str(totalSaveBytes)+\" bytes\")"
      },
      {
        "sha": "0f2099953f8ad47cb95eb8c066ae4d169ed82bd6",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 23,
        "deletions": 24,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -8,7 +8,6 @@\n Otherwise the exit status will be 1 and it will log which executables failed which checks.\n Needs `readelf` (for ELF) and `objdump` (for PE).\n '''\n-from __future__ import division,print_function,unicode_literals\n import subprocess\n import sys\n import os\n@@ -21,38 +20,38 @@ def check_ELF_PIE(executable):\n     '''\n     Check for position independent executable (PIE), allowing for address space randomization.\n     '''\n-    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n \n     ok = False\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         line = line.split()\n-        if len(line)>=2 and line[0] == b'Type:' and line[1] == b'DYN':\n+        if len(line)>=2 and line[0] == 'Type:' and line[1] == 'DYN':\n             ok = True\n     return ok\n \n def get_ELF_program_headers(executable):\n     '''Return type and flags for ELF program headers'''\n-    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     in_headers = False\n     count = 0\n     headers = []\n-    for line in stdout.split(b'\\n'):\n-        if line.startswith(b'Program Headers:'):\n+    for line in stdout.splitlines():\n+        if line.startswith('Program Headers:'):\n             in_headers = True\n-        if line == b'':\n+        if line == '':\n             in_headers = False\n         if in_headers:\n             if count == 1: # header line\n-                ofs_typ = line.find(b'Type')\n-                ofs_offset = line.find(b'Offset')\n-                ofs_flags = line.find(b'Flg')\n-                ofs_align = line.find(b'Align')\n+                ofs_typ = line.find('Type')\n+                ofs_offset = line.find('Offset')\n+                ofs_flags = line.find('Flg')\n+                ofs_align = line.find('Align')\n                 if ofs_typ == -1 or ofs_offset == -1 or ofs_flags == -1 or ofs_align  == -1:\n                     raise ValueError('Cannot parse elfread -lW output')\n             elif count > 1:\n@@ -69,9 +68,9 @@ def check_ELF_NX(executable):\n     have_wx = False\n     have_gnu_stack = False\n     for (typ, flags) in get_ELF_program_headers(executable):\n-        if typ == b'GNU_STACK':\n+        if typ == 'GNU_STACK':\n             have_gnu_stack = True\n-        if b'W' in flags and b'E' in flags: # section is both writable and executable\n+        if 'W' in flags and 'E' in flags: # section is both writable and executable\n             have_wx = True\n     return have_gnu_stack and not have_wx\n \n@@ -88,31 +87,31 @@ def check_ELF_RELRO(executable):\n         # However, the dynamic linker need to write to this area so these are RW.\n         # Glibc itself takes care of mprotecting this area R after relocations are finished.\n         # See also http://permalink.gmane.org/gmane.comp.gnu.binutils/71347\n-        if typ == b'GNU_RELRO':\n+        if typ == 'GNU_RELRO':\n             have_gnu_relro = True\n \n     have_bindnow = False\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n-        if len(tokens)>1 and tokens[1] == b'(BIND_NOW)' or (len(tokens)>2 and tokens[1] == b'(FLAGS)' and b'BIND_NOW' in tokens[2]):\n+        if len(tokens)>1 and tokens[1] == '(BIND_NOW)' or (len(tokens)>2 and tokens[1] == '(FLAGS)' and 'BIND_NOW' in tokens[2]):\n             have_bindnow = True\n     return have_gnu_relro and have_bindnow\n \n def check_ELF_Canary(executable):\n     '''\n     Check for use of stack canary\n     '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     ok = False\n-    for line in stdout.split(b'\\n'):\n-        if b'__stack_chk_fail' in line:\n+    for line in stdout.splitlines():\n+        if '__stack_chk_fail' in line:\n             ok = True\n     return ok\n \n@@ -122,13 +121,13 @@ def get_PE_dll_characteristics(executable):\n     Returns a tuple (arch,bits) where arch is 'i386:x86-64' or 'i386'\n     and bits is the DllCharacteristics value.\n     '''\n-    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     arch = ''\n     bits = 0\n-    for line in stdout.split('\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n         if len(tokens)>=2 and tokens[0] == 'architecture:':\n             arch = tokens[1].rstrip(',')"
      },
      {
        "sha": "3a67319eaa81783ad3afdd65650e899b39a5781c",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 34,
        "deletions": 35,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -11,7 +11,6 @@\n \n     find ../gitian-builder/build -type f -executable | xargs python contrib/devtools/symbol-check.py\n '''\n-from __future__ import division, print_function, unicode_literals\n import subprocess\n import re\n import sys\n@@ -47,28 +46,28 @@\n \n # Ignore symbols that are exported as part of every executable\n IGNORE_EXPORTS = {\n-b'_edata', b'_end', b'_init', b'__bss_start', b'_fini', b'_IO_stdin_used'\n+'_edata', '_end', '_init', '__bss_start', '_fini', '_IO_stdin_used'\n }\n READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n CPPFILT_CMD = os.getenv('CPPFILT', '/usr/bin/c++filt')\n # Allowed NEEDED libraries\n ALLOWED_LIBRARIES = {\n # bitcoind and bitcoin-qt\n-b'libgcc_s.so.1', # GCC base support\n-b'libc.so.6', # C library\n-b'libpthread.so.0', # threading\n-b'libanl.so.1', # DNS resolve\n-b'libm.so.6', # math library\n-b'librt.so.1', # real-time (clock)\n-b'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n-b'ld-linux.so.2', # 32-bit dynamic linker\n+'libgcc_s.so.1', # GCC base support\n+'libc.so.6', # C library\n+'libpthread.so.0', # threading\n+'libanl.so.1', # DNS resolve\n+'libm.so.6', # math library\n+'librt.so.1', # real-time (clock)\n+'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n+'ld-linux.so.2', # 32-bit dynamic linker\n # bitcoin-qt only\n-b'libX11-xcb.so.1', # part of X11\n-b'libX11.so.6', # part of X11\n-b'libxcb.so.1', # part of X11\n-b'libfontconfig.so.1', # font support\n-b'libfreetype.so.6', # font parsing\n-b'libdl.so.2' # programming interface to dynamic linker\n+'libX11-xcb.so.1', # part of X11\n+'libX11.so.6', # part of X11\n+'libxcb.so.1', # part of X11\n+'libfontconfig.so.1', # font support\n+'libfreetype.so.6', # font parsing\n+'libdl.so.2' # programming interface to dynamic linker\n }\n \n class CPPFilt(object):\n@@ -78,10 +77,10 @@ class CPPFilt(object):\n     Use a pipe to the 'c++filt' command.\n     '''\n     def __init__(self):\n-        self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n+        self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE, universal_newlines=True)\n \n     def __call__(self, mangled):\n-        self.proc.stdin.write(mangled + b'\\n')\n+        self.proc.stdin.write(mangled + '\\n')\n         self.proc.stdin.flush()\n         return self.proc.stdout.readline().rstrip()\n \n@@ -95,43 +94,43 @@ def read_symbols(executable, imports=True):\n     Parse an ELF executable and return a list of (symbol,version) tuples\n     for dynamic, imported symbols.\n     '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Could not read symbols for %s: %s' % (executable, stderr.strip()))\n     syms = []\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         line = line.split()\n-        if len(line)>7 and re.match(b'[0-9]+:$', line[0]):\n-            (sym, _, version) = line[7].partition(b'@')\n-            is_import = line[6] == b'UND'\n-            if version.startswith(b'@'):\n+        if len(line)>7 and re.match('[0-9]+:$', line[0]):\n+            (sym, _, version) = line[7].partition('@')\n+            is_import = line[6] == 'UND'\n+            if version.startswith('@'):\n                 version = version[1:]\n             if is_import == imports:\n                 syms.append((sym, version))\n     return syms\n \n def check_version(max_versions, version):\n-    if b'_' in version:\n-        (lib, _, ver) = version.rpartition(b'_')\n+    if '_' in version:\n+        (lib, _, ver) = version.rpartition('_')\n     else:\n         lib = version\n         ver = '0'\n-    ver = tuple([int(x) for x in ver.split(b'.')])\n+    ver = tuple([int(x) for x in ver.split('.')])\n     if not lib in max_versions:\n         return False\n     return ver <= max_versions[lib]\n \n def read_libraries(filename):\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     libraries = []\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n-        if len(tokens)>2 and tokens[1] == b'(NEEDED)':\n-            match = re.match(b'^Shared library: \\[(.*)\\]$', b' '.join(tokens[2:]))\n+        if len(tokens)>2 and tokens[1] == '(NEEDED)':\n+            match = re.match('^Shared library: \\[(.*)\\]$', ' '.join(tokens[2:]))\n             if match:\n                 libraries.append(match.group(1))\n             else:\n@@ -145,18 +144,18 @@ def read_libraries(filename):\n         # Check imported symbols\n         for sym,version in read_symbols(filename, True):\n             if version and not check_version(MAX_VERSIONS, version):\n-                print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym).decode('utf-8'), version.decode('utf-8')))\n+                print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym), version))\n                 retval = 1\n         # Check exported symbols\n         for sym,version in read_symbols(filename, False):\n             if sym in IGNORE_EXPORTS:\n                 continue\n-            print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym).decode('utf-8')))\n+            print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym)))\n             retval = 1\n         # Check dependency libraries\n         for library_name in read_libraries(filename):\n             if library_name not in ALLOWED_LIBRARIES:\n-                print('%s: NEEDED library %s is not allowed' % (filename, library_name.decode('utf-8')))\n+                print('%s: NEEDED library %s is not allowed' % (filename, library_name))\n                 retval = 1\n \n     sys.exit(retval)"
      },
      {
        "sha": "b36e6968bf0f64d424992ff1589f9e44fb3ce671",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -15,7 +15,6 @@\n TODO:\n - auto-add new translations to the build system according to the translation process\n '''\n-from __future__ import division, print_function\n import subprocess\n import re\n import sys"
      },
      {
        "sha": "94d6a89c7b22bff126edb1c0ca8e3c92be9cac02",
        "filename": "contrib/gitian-build.sh",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/gitian-build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/gitian-build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-build.sh?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -77,7 +77,7 @@ while :; do\n         -S|--signer)\n \t    if [ -n \"$2\" ]\n \t    then\n-\t\tSIGNER=$2\n+\t\tSIGNER=\"$2\"\n \t\tshift\n \t    else\n \t\techo 'Error: \"--signer\" requires a non-empty argument.'\n@@ -190,7 +190,7 @@ fi\n # Get signer\n if [[ -n \"$1\" ]]\n then\n-    SIGNER=$1\n+    SIGNER=\"$1\"\n     shift\n fi\n \n@@ -203,7 +203,7 @@ then\n fi\n \n # Check that a signer is specified\n-if [[ $SIGNER == \"\" ]]\n+if [[ \"$SIGNER\" == \"\" ]]\n then\n     echo \"$scriptName: Missing signer.\"\n     echo \"Try $scriptName --help for more information\"\n@@ -272,7 +272,7 @@ then\n \t    echo \"Compiling ${VERSION} Linux\"\n \t    echo \"\"\n \t    ./bin/gbuild -j ${proc} -m ${mem} --commit bitcoin=${COMMIT} --url bitcoin=${url} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n-\t    ./bin/gsign -p $signProg --signer $SIGNER --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n+\t    ./bin/gsign -p \"$signProg\" --signer \"$SIGNER\" --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n \t    mv build/out/bitcoin-*.tar.gz build/out/src/bitcoin-*.tar.gz ../bitcoin-binaries/${VERSION}\n \tfi\n \t# Windows\n@@ -282,7 +282,7 @@ then\n \t    echo \"Compiling ${VERSION} Windows\"\n \t    echo \"\"\n \t    ./bin/gbuild -j ${proc} -m ${mem} --commit bitcoin=${COMMIT} --url bitcoin=${url} ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n-\t    ./bin/gsign -p $signProg --signer $SIGNER --release ${VERSION}-win-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n+\t    ./bin/gsign -p \"$signProg\" --signer \"$SIGNER\" --release ${VERSION}-win-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n \t    mv build/out/bitcoin-*-win-unsigned.tar.gz inputs/bitcoin-win-unsigned.tar.gz\n \t    mv build/out/bitcoin-*.zip build/out/bitcoin-*.exe ../bitcoin-binaries/${VERSION}\n \tfi\n@@ -293,7 +293,7 @@ then\n \t    echo \"Compiling ${VERSION} Mac OSX\"\n \t    echo \"\"\n \t    ./bin/gbuild -j ${proc} -m ${mem} --commit bitcoin=${COMMIT} --url bitcoin=${url} ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n-\t    ./bin/gsign -p $signProg --signer $SIGNER --release ${VERSION}-osx-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n+\t    ./bin/gsign -p \"$signProg\" --signer \"$SIGNER\" --release ${VERSION}-osx-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n \t    mv build/out/bitcoin-*-osx-unsigned.tar.gz inputs/bitcoin-osx-unsigned.tar.gz\n \t    mv build/out/bitcoin-*.tar.gz build/out/bitcoin-*.dmg ../bitcoin-binaries/${VERSION}\n \tfi\n@@ -306,9 +306,9 @@ then\n             echo \"Committing ${VERSION} Unsigned Sigs\"\n             echo \"\"\n             pushd gitian.sigs\n-            git add ${VERSION}-linux/${SIGNER}\n-            git add ${VERSION}-win-unsigned/${SIGNER}\n-            git add ${VERSION}-osx-unsigned/${SIGNER}\n+            git add ${VERSION}-linux/\"${SIGNER}\"\n+            git add ${VERSION}-win-unsigned/\"${SIGNER}\"\n+            git add ${VERSION}-osx-unsigned/\"${SIGNER}\"\n             git commit -a -m \"Add ${VERSION} unsigned sigs for ${SIGNER}\"\n             popd\n         fi\n@@ -358,7 +358,7 @@ then\n \t    echo \"Signing ${VERSION} Windows\"\n \t    echo \"\"\n \t    ./bin/gbuild -i --commit signature=${COMMIT} ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n-\t    ./bin/gsign -p $signProg --signer $SIGNER --release ${VERSION}-win-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n+\t    ./bin/gsign -p \"$signProg\" --signer \"$SIGNER\" --release ${VERSION}-win-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n \t    mv build/out/bitcoin-*win64-setup.exe ../bitcoin-binaries/${VERSION}\n \t    mv build/out/bitcoin-*win32-setup.exe ../bitcoin-binaries/${VERSION}\n \tfi\n@@ -369,7 +369,7 @@ then\n \t    echo \"Signing ${VERSION} Mac OSX\"\n \t    echo \"\"\n \t    ./bin/gbuild -i --commit signature=${COMMIT} ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n-\t    ./bin/gsign -p $signProg --signer $SIGNER --release ${VERSION}-osx-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n+\t    ./bin/gsign -p \"$signProg\" --signer \"$SIGNER\" --release ${VERSION}-osx-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n \t    mv build/out/bitcoin-osx-signed.dmg ../bitcoin-binaries/${VERSION}/bitcoin-${VERSION}-osx.dmg\n \tfi\n \tpopd\n@@ -381,8 +381,8 @@ then\n             echo \"\"\n             echo \"Committing ${VERSION} Signed Sigs\"\n             echo \"\"\n-            git add ${VERSION}-win-signed/${SIGNER}\n-            git add ${VERSION}-osx-signed/${SIGNER}\n+            git add ${VERSION}-win-signed/\"${SIGNER}\"\n+            git add ${VERSION}-osx-signed/\"${SIGNER}\"\n             git commit -a -m \"Add ${VERSION} signed binary sigs for ${SIGNER}\"\n             popd\n         fi"
      },
      {
        "sha": "593fba1d0915fb8ad7e3c246e14f5dcbf4e5b1de",
        "filename": "contrib/gitian-keys/keys.txt",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/gitian-keys/keys.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/gitian-keys/keys.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-keys/keys.txt?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,29 +1,30 @@\n 617C90010B3BD370B0AC7D424BB42E31C79111B8 Akira Takizawa\n-152812300785C96444D3334D17565732E08E5E41 Andrew Chow\n E944AE667CF960B1004BC32FCA662BE18B877A60 Andreas Schildbach\n-07DF3E57A548CCFB7530709189BBB8663E2E65CE Matt Corallo (BlueMatt)\n+152812300785C96444D3334D17565732E08E5E41 Andrew Chow\n 912FD3228387123DC97E0E57D5566241A0295FA9 BtcDrak\n C519EBCF3B926298946783EFF6430754120EC2F4 Christian Decker (cdecker)\n F20F56EF6A067F70E8A5C99FFF95FAA971697405 centaur\n C060A6635913D98A3587D7DB1C2491FFEB0EF770 Cory Fields\n BF6273FAEF7CC0BA1F562E50989F6B3048A116B5 Dev Random\n 9A1689B60D1B3CCE9262307A2F40A9BF167FBA47 Erik Mossberg (erkmos)\n D35176BE9264832E4ACA8986BF0792FBE95DC863 fivepiece\n-E777299FC265DD04793070EB944D35F9AC3DB76A Michael Ford\n 01CDF4627A3B88AAE4A571C87588242FBE38D3A8 Gavin Andresen\n D3CC177286005BB8FF673294C5242A1AB3936517 jl2012\n 32EE5C4C3FA15CCADB46ABE529D4BCB6416F53EC Jonas Schnelli\n 4B4E840451149DD7FB0D633477DFAB5C3108B9A8 Jorge Timon\n-71A3B16735405025D447E8F274810B012346C9A6 Wladimir J. van der Laan\n+C42AFF7C61B3E44A1454CD3557AF762DB3353322 Karl-Johan Alm (kallewoof)\n E463A93F5F3117EEDE6C7316BD02942421F4889F Luke Dashjr\n B8B3F1C0E58C15DB6A81D30C3648A882F4316B9B Marco Falke\n+07DF3E57A548CCFB7530709189BBB8663E2E65CE Matt Corallo (BlueMatt)\n CA03882CB1FC067B5D3ACFE4D300116E1C875A3D MeshCollider\n+E777299FC265DD04793070EB944D35F9AC3DB76A Michael Ford\n 9692B91BBF0E8D34DFD33B1882C5C009628ECF0C Michagogo\n-37EC7D7B0A217CDB4B4E007E7FAB114267E4FA04 Peter Todd\n+77E72E69DA7EE0A148C06B21B34821D4944DE5F7 Nils Schneider\n D62A803E27E7F43486035ADBBCD04D8E9CCCAC2A Paul Rabahy\n+37EC7D7B0A217CDB4B4E007E7FAB114267E4FA04 Peter Todd\n D762373D24904A3E42F33B08B9A408E71DAAC974 Pieter Wuille (Location: Leuven, Belgium)\n 133EAC179436F14A5CF1B794860FEB804E669320 Pieter Wuille\n ED9BDF7AD6A55E232E84524257FF9BDBCC301009 Sjors Provoost\n-77E72E69DA7EE0A148C06B21B34821D4944DE5F7 Nils Schneider\n-79D00BAC68B56D422F945A8F8E3A8F3247DBCBBF Willy Ko\n AEC1884398647C47413C1C3FB1179EB7347DC10D Warren Togami\n+79D00BAC68B56D422F945A8F8E3A8F3247DBCBBF Willy Ko\n+71A3B16735405025D447E8F274810B012346C9A6 Wladimir J. van der Laan"
      },
      {
        "sha": "877abafd19260e1707e6b1e370cde8b2e088a599",
        "filename": "contrib/init/bitcoind.service",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/init/bitcoind.service",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/init/bitcoind.service",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.service?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -19,7 +19,26 @@ User=bitcoin\n Type=forking\n PIDFile=/run/bitcoind/bitcoind.pid\n Restart=on-failure\n+\n+# Hardening measures\n+####################\n+\n+# Provide a private /tmp and /var/tmp.\n PrivateTmp=true\n \n+# Mount /usr, /boot/ and /etc read-only for the process.\n+ProtectSystem=full\n+\n+# Disallow the process and all of its children to gain\n+# new privileges through execve().\n+NoNewPrivileges=true\n+\n+# Use a new /dev namespace only populated with API pseudo devices\n+# such as /dev/null, /dev/zero and /dev/random.\n+PrivateDevices=true\n+\n+# Deny the creation of writable and executable memory mappings.\n+MemoryDenyWriteExecute=true\n+\n [Install]\n WantedBy=multi-user.target"
      },
      {
        "sha": "b29fc71765653b816e9fcef0437c302c0dd55a86",
        "filename": "contrib/macdeploy/custom_dsstore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/macdeploy/custom_dsstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/macdeploy/custom_dsstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/custom_dsstore.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,8 +1,7 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2013-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-from __future__ import division,print_function,unicode_literals\n import biplist\n from ds_store import DSStore\n from mac_alias import Alias"
      },
      {
        "sha": "17ce6c44f93b0d1f5746f22153210a243979836b",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 5,
        "deletions": 22,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,5 +1,4 @@\n-#!/usr/bin/env python\n-from __future__ import division, print_function, unicode_literals\n+#!/usr/bin/env python3\n #\n # Copyright (C) 2011  Patrick \"p2k\" Schneider <me@p2k-network.org>\n #\n@@ -203,15 +202,15 @@ def getFrameworks(binaryPath, verbose):\n     if verbose >= 3:\n         print(\"Inspecting with otool: \" + binaryPath)\n     otoolbin=os.getenv(\"OTOOL\", \"otool\")\n-    otool = subprocess.Popen([otoolbin, \"-L\", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    otool = subprocess.Popen([otoolbin, \"-L\", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n     o_stdout, o_stderr = otool.communicate()\n     if otool.returncode != 0:\n         if verbose >= 1:\n             sys.stderr.write(o_stderr)\n             sys.stderr.flush()\n             raise RuntimeError(\"otool failed with return code %d\" % otool.returncode)\n \n-    otoolLines = o_stdout.decode().split(\"\\n\")\n+    otoolLines = o_stdout.split(\"\\n\")\n     otoolLines.pop(0) # First line is the inspected binary\n     if \".framework\" in binaryPath or binaryPath.endswith(\".dylib\"):\n         otoolLines.pop(0) # Frameworks and dylibs list themselves as a dependency.\n@@ -714,22 +713,6 @@ elif config.sign:\n \n if config.dmg is not None:\n \n-    #Patch in check_output for Python 2.6\n-    if \"check_output\" not in dir( subprocess ):\n-        def f(*popenargs, **kwargs):\n-            if 'stdout' in kwargs:\n-                raise ValueError('stdout argument not allowed, it will be overridden.')\n-            process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)\n-            output, unused_err = process.communicate()\n-            retcode = process.poll()\n-            if retcode:\n-                cmd = kwargs.get(\"args\")\n-                if cmd is None:\n-                    cmd = popenargs[0]\n-                raise CalledProcessError(retcode, cmd)\n-            return output\n-        subprocess.check_output = f\n-\n     def runHDIUtil(verb, image_basename, **kwargs):\n         hdiutil_args = [\"hdiutil\", verb, image_basename + \".dmg\"]\n         if \"capture_stdout\" in kwargs:\n@@ -747,7 +730,7 @@ if config.dmg is not None:\n             if not value is True:\n                 hdiutil_args.append(str(value))\n         \n-        return run(hdiutil_args)\n+        return run(hdiutil_args, universal_newlines=True)\n     \n     if verbose >= 2:\n         if fancy is None:\n@@ -789,7 +772,7 @@ if config.dmg is not None:\n         except subprocess.CalledProcessError as e:\n             sys.exit(e.returncode)\n         \n-        m = re.search(\"/Volumes/(.+$)\", output.decode())\n+        m = re.search(\"/Volumes/(.+$)\", output)\n         disk_root = m.group(0)\n         disk_name = m.group(1)\n         "
      },
      {
        "sha": "0dbb79a70712d788bee76c87f538341e657f57bc",
        "filename": "contrib/testgen/base58.py",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/testgen/base58.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/testgen/base58.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/base58.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -28,7 +28,9 @@ def b58encode(v):\n     \"\"\"\n     long_value = 0\n     for (i, c) in enumerate(v[::-1]):\n-        long_value += (256**i) * ord(c)\n+        if isinstance(c, str):\n+            c = ord(c)\n+        long_value += (256**i) * c\n \n     result = ''\n     while long_value >= __b58base:\n@@ -41,7 +43,7 @@ def b58encode(v):\n     # leading 0-bytes in the input become leading-1s\n     nPad = 0\n     for c in v:\n-        if c == '\\0': nPad += 1\n+        if c == 0: nPad += 1\n         else: break\n \n     return (__b58chars[0]*nPad) + result\n@@ -50,8 +52,10 @@ def b58decode(v, length = None):\n     \"\"\" decode v into a string of len bytes\n     \"\"\"\n     long_value = 0\n-    for (i, c) in enumerate(v[::-1]):\n-        long_value += __b58chars.find(c) * (__b58base**i)\n+    for i, c in enumerate(v[::-1]):\n+        pos = __b58chars.find(c)\n+        assert pos != -1\n+        long_value += pos * (__b58base**i)\n \n     result = bytes()\n     while long_value >= 256:\n@@ -62,10 +66,12 @@ def b58decode(v, length = None):\n \n     nPad = 0\n     for c in v:\n-        if c == __b58chars[0]: nPad += 1\n-        else: break\n+        if c == __b58chars[0]:\n+            nPad += 1\n+            continue\n+        break\n \n-    result = chr(0)*nPad + result\n+    result = bytes(nPad) + result\n     if length is not None and len(result) != length:\n         return None\n "
      },
      {
        "sha": "43516057866df9746e65890a5416540cfa01aab8",
        "filename": "contrib/testgen/gen_base58_test_vectors.py",
        "status": "modified",
        "additions": 14,
        "deletions": 11,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/testgen/gen_base58_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/testgen/gen_base58_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_base58_test_vectors.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,11 +1,11 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2012-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n Generate valid and invalid base58 address and private key test vectors.\n \n-Usage: \n+Usage:\n     gen_base58_test_vectors.py valid 50 > ../../src/test/data/base58_keys_valid.json\n     gen_base58_test_vectors.py invalid 50 > ../../src/test/data/base58_keys_invalid.json\n '''\n@@ -46,8 +46,8 @@ def is_valid(v):\n     if result is None:\n         return False\n     for template in templates:\n-        prefix = str(bytearray(template[0]))\n-        suffix = str(bytearray(template[2]))\n+        prefix = bytearray(template[0])\n+        suffix = bytearray(template[2])\n         if result.startswith(prefix) and result.endswith(suffix):\n             if (len(result) - len(prefix) - len(suffix)) == template[1]:\n                 return True\n@@ -57,20 +57,23 @@ def gen_valid_vectors():\n     '''Generate valid test vectors'''\n     while True:\n         for template in templates:\n-            prefix = str(bytearray(template[0]))\n-            payload = os.urandom(template[1]) \n-            suffix = str(bytearray(template[2]))\n+            prefix = bytearray(template[0])\n+            payload = bytearray(os.urandom(template[1]))\n+            suffix = bytearray(template[2])\n             rv = b58encode_chk(prefix + payload + suffix)\n             assert is_valid(rv)\n-            metadata = dict([(x,y) for (x,y) in zip(metadata_keys,template[3]) if y is not None])\n-            yield (rv, b2a_hex(payload), metadata)\n+            metadata = {x: y for x, y in zip(metadata_keys,template[3]) if y is not None}\n+            hexrepr = b2a_hex(payload)\n+            if isinstance(hexrepr, bytes):\n+                hexrepr = hexrepr.decode('utf8')\n+            yield (rv, hexrepr, metadata)\n \n def gen_invalid_vector(template, corrupt_prefix, randomize_payload_size, corrupt_suffix):\n     '''Generate possibly invalid vector'''\n     if corrupt_prefix:\n         prefix = os.urandom(1)\n     else:\n-        prefix = str(bytearray(template[0]))\n+        prefix = bytearray(template[0])\n     \n     if randomize_payload_size:\n         payload = os.urandom(max(int(random.expovariate(0.5)), 50))\n@@ -80,7 +83,7 @@ def gen_invalid_vector(template, corrupt_prefix, randomize_payload_size, corrupt\n     if corrupt_suffix:\n         suffix = os.urandom(len(template[2]))\n     else:\n-        suffix = str(bytearray(template[2]))\n+        suffix = bytearray(template[2])\n \n     return b58encode_chk(prefix + payload + suffix)\n "
      },
      {
        "sha": "fa492fdd2750639aca86c787da7a797e7a22479e",
        "filename": "contrib/verify-commits/README.md",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/verify-commits/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/verify-commits/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/README.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -24,3 +24,24 @@ keys:\n Note that the above isn't a good UI/UX yet, and needs significant improvements\n to make it more convenient and reduce the chance of errors; pull-reqs\n improving this process would be much appreciated.\n+\n+Configuration files\n+-------------------\n+\n+* `trusted-git-root`: This file should contain a single git commit hash which is the first unsigned git commit (hence it is the \"root of trust\").\n+* `trusted-sha512-root-commit`: This file should contain a single git commit hash which is the first commit without a SHA512 root commitment.\n+* `trusted-keys`: This file should contain a \\n-delimited list of all PGP fingerprints of authorized commit signers (primary, not subkeys).\n+* `allow-revsig-commits`: This file should contain a \\n-delimited list of git commit hashes. See next section for more info.\n+\n+Key expiry/revocation\n+---------------------\n+\n+When a key (or subkey) which has signed old commits expires or is revoked,\n+verify-commits will start failing to verify all commits which were signed by\n+said key. In order to avoid bumping the root-of-trust `trusted-git-root`\n+file, individual commits which were signed by such a key can be added to the\n+`allow-revsig-commits` file. That way, the PGP signatures are still verified\n+but no new commits can be signed by any expired/revoked key. To easily build a\n+list of commits which need to be added, verify-commits.sh can be edited to test\n+each commit with BITCOIN_VERIFY_COMMITS_ALLOW_REVSIG set to both 1 and 0, and\n+those which need it set to 1 printed."
      },
      {
        "sha": "3abf82e529cbbbc766d0b7f7c4028d7721eb6755",
        "filename": "contrib/verify-commits/allow-revsig-commits",
        "status": "modified",
        "additions": 400,
        "deletions": 0,
        "changes": 400,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/verify-commits/allow-revsig-commits",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/verify-commits/allow-revsig-commits",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/allow-revsig-commits?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -102,3 +102,403 @@ bafd075c5e6a1088ef0f1aa0b0b224e026a3d3e0\n c8d2473e6cb042e7275a10c49d3f6a4a91bf0166\n 386f4385ab04b0b2c3d47bddc0dc0f2de7354964\n 9f33dba05c01ecc5c56eb1284ab7d64d42f55171\n+7466a26cab5d66665991433947964a638f5b957e\n+b43aba89e356ff95b706e80d4802f60fc46a569a\n+02b7e8319aef2a870264ad4fa2e3bb18664dcc36\n+f686002a8eba820a40ac2f34a6e8f57b2b5cc54c\n+2b1c50b9352ab1dc40b0f877db23c1fa4048fae3\n+2405ce1df043f778b8efb9205009500cbc17313a\n+4ad3b3c72c73d61e0a0cab541dca20acf651320d\n+4ba3d4f4393d81148422d24d222fe7ed00130194\n+8ee5c7b747171e335793c74cd9d2f7491da58164\n+872c921c0a208b04bd0713758e52fcab5b7c1684\n+00d1680498c5550e7db1f359202d3433a092fafd\n+585db41e9ab7a6fb262c8bad7f427cdbdc497188\n+18462960c0f13bd07d8f52b61e7d7bc17e991eea\n+0630974647dacaf25e7fcb7f9cbb785bb078ede6\n+0f58d7f3d62f012f2584f5e781fc73de4763dd9e\n+3d16f581538b0974853e820508e8b3093269d2fd\n+66e91420ab233cf1dac64504e0dc129019bf8c0d\n+d8d9162f5bad39b2720dd2b2da237c6159e4755f\n+29fad97c320c892ab6a480c81e2078ec22ab354b\n+791c3ea61b4e49fd46a1a71b84ca99ddf69d2ff7\n+a312e201ba56742499a5480b5f2115f01505c217\n+ce56fdd2e8cdf94fd0ab76d71adbfa755e23ce7d\n+480f42630cbd598c04fa59ee0e406f56904ecffb\n+6012f1caf744ac9b53383d7d10a8f1b70ca2c0e1\n+ded6a2afa549f693dcabb430ce0862f8631360c8\n+07090c5339436f856e79a8036d1c85deeb453803\n+0e265916d1c6a63e4a3821dab9db597b5ec64b46\n+e4ffcacc2187d3419c8ea12b82fb06d82d8751d2\n+e117cfe45eee9169409e74a44ef4a866be25bc35\n+dcfe218626b05204e9fbc95ba5d95ca0eb72ec9b\n+23481fa50301201ef5a60675ef899aa6ce94ca03\n+27c59dc502f29cf1d76290556c21e366145e3b2e\n+4a62ddd01873d18dbca96c81d756be1020249b45\n+a233fb4f1d037e68ff70eef3a9f5b7bf1d631918\n+b2089c51cc4af2f7e1c0ec75be9449ee222b1d69\n+c997f8808256521397f1c003bb1e9896fee6eaa0\n+5dc00f68c49c46a380a98d06233f90528b8e2557\n+fe53d5f3636aed064823bc220d828c7ff08d1d52\n+935eb8de039dec65669a96a1c3b86f4b03a1b86c\n+0277173b1defb63216d40a8d8805ae6d5d563c26\n+2a30e67d20f76bbcd9a7d445f616f005316e0a1a\n+d32528e733f2711b34dbc41fbb2bb0f153bf7e9a\n+4cad91663df381d0dff8526f3b4aa74569dfb626\n+1b06ed136f17b526360617a70026aed5ded5746c\n+895fbd768f0c89cea3f78acac58b233d4e3a145e\n+f0295becbf3ef1fb78095306408789253fe0c114\n+8d573198638e52e2dbd9abc609861430f9d2bcc3\n+9d9c4185fadaf243bb97c226e2fef16b65299699\n+eebe4580bc8d6484d79ecb24dd87412221cf2ea7\n+9cf6393a4f82b9c81d3b4b468a17a89db10531a2\n+598a9c4e4dcd03c6d80fba005de729a6a3aeba7e\n+6970b30c6f1d2be7947295fe18f2390649b17a4b\n+f359afcc410432ed5d30001acda0c66741ee8935\n+126000ba9e7ff16271be2f4eef3df99ade8d624f\n+b5e4b9b5100ec15217d43edb5f4149439f4b20a5\n+b987ca4ee495a7fff82f0ac14ef0753bfb7586e2\n+b03013396cb2f4bf25746388b3982a2c3616e16b\n+9a97f39afaa890caa7987c6bc001b9a66e3e74e8\n+cad504bf4c302f7a72e0a0e191f3fdbafda7340f\n+45cf8a03cb57b8639a8d47323bde46ba22d9eeaf\n+b7450cdbd89a1c862f4d4d8bf093f8a0b5448f9c\n+0910cbe4ef31eb95fd76c7c2f820419fe64a3150\n+92a810d04b906722c9efe60e3997243c71ff3d4c\n+45173fa6fca9537abb0a0554f731d14b9f89c456\n+fd4ca17360e6fc0c9bb76bf6b5b07c9102c12728\n+ddff3447f29b62d79a33f728791f42fa9436216e\n+36a5a4404836da323c755523fbd27563a8e84f94\n+c991b304dee368f506cfee27ddaa333f1f82c518\n+d38d1a3e75aa97ffa8755ddd431754a6d0942964\n+a332a7d5a15214015f9553fdb2bcf80a1a4b8dc0\n+604e08c83cf58ca7e7cda2ab284c1ace7bb12977\n+18a1bbad98bd4321f15e7921d9aec91661499d90\n+8049241e226c16bd07b029c0cb4b62ac40f0c923\n+797441ee995aac59f55d59a93ecb55e8ecbe7dbc\n+62fdf9b07087b80d2142799bdd2324f61483359d\n+f60b4ad57912b78a96af08046a503f7905610a8c\n+13e31dd6548d64a5992f439e74bb424bf88aca04\n+fbce66a982679b5409a295be5c99a2eef429cabf\n+9f2c2dba21855b8cb9b193b1819be73fa4a23a99\n+a89221873a3ee2451c73b41bbe2d99d36f439d31\n+3d6ad407770e13958e157bf026cae0bfb9254899\n+901ba3e3819405306414628306746552b0aa1d28\n+7a43fbb959c38e025e558e472ad57de357539894\n+0d89fa0877930c6c8a539a656c1009ad8ab6755b\n+54aedc013744c86b11157423fa3cffc9a51eef02\n+f0c1f8abb0182da557d07372b938f3a0a4bb906f\n+4ed818060ecf4a38a02c8cb48f6cbc78d2ee7708\n+3bdf242fc68a8d767932c6214455d4d413effbc9\n+5e468994fbb349e8eefc996954a31a67a34aaa15\n+41aa9c4a801a01eca1fad22a7095372d23dace60\n+2adbddb03840ad71e843c6c4a207a13e871cd1d4\n+13e352dc53dec0127c5f94a60055d0ca829420dc\n+95e14dc81dd30ee0d396ad08dca9a6980d16eee1\n+61fb80660f73e5aa5b69302ecc7ac33da206ba5a\n+05a761932edd05cf94ffe938908baf058f38632a\n+ee92243e66f2df03b3a759a8ffb75dc06f0cea0d\n+22cdf93c062eeaa0f8f9d6220f01b67240073dfb\n+76b33491596736ca804e3a29bd8398d7a1516ab7\n+6e4e98ee8ce2da3cca2e2fd210e9e8dbc9b1c936\n+c838283ecdfb9490425bb071b7c22e542de46c7c\n+5e3f5e4f25b65b583d3bfefac9e1148035781089\n+f7388e93d3dd91a90239aedac4ec58404f103a2e\n+0a2f46b0158b6fc7244a585913b0925c0acf707f\n+dd561667cb7ccbbfed3134b05a565971ef6f5873\n+6f01dcf63873a5e42798635ab4026c9a5f9fa213\n+70fec9e36bcd1a3d93df019be084aaf89cecd7d7\n+f9b74ef3fc74fd7d2aa94560820341f03cda8e12\n+998c3046fab2b52bc9f141cfb588a18c05506a86\n+89cc4f905e30b913ca20e4192d538cc5cbe2c38d\n+87d90efd69b64f769116956a5db89e536e9e3714\n+5aeaa9ccd1568a77e075dbe2bd2435bd60c87c91\n+bfb270acfa30713dc8c968bb9ee40cf5a2360359\n+1b8c88451b0554502435d3883c528ad0aad1b09b\n+57ee73990f1ce29916adfd99f93eae1ccea1a43b\n+808c84f89d0edcef9ddaab0b849a382719f6ec9e\n+14b860bf64020451ced823b859da8cb912278ab9\n+c63364610f4a041df1c1bd81d01b1f6856160749\n+92eadc395071876d77f3babddc056b4325bdbabc\n+e93fff1463ae906fc986bf98c3b118c82f171546\n+9ccafb1d7bdd172a9b963444072a844da379c4f7\n+b4a509a3f817121c3df98ddfd96b2769e18a3e5a\n+dbc4ae03963014ab4b7957d62ba59dbd8f938c33\n+8ddf60db7ad636b6a31b590251c671ded635fa1d\n+f199b8a33d9443a258a1f49a1a29674cd9ee9a20\n+e542728cde676f218c552d841d0af29b92f9800b\n+763231051596b8e3455b839911ad6a3a1f1c3c74\n+ff4cd6075b12fb32b9a906deea3ed033e3f9560a\n+9c3c9cdae3e20b5bdea91a0631edac5116bbc89f\n+93d20a734d2ee873832bed8ca5c05cf8e539c53c\n+ef8340d25f7c5dd5682bdecea97ce84cfce1493c\n+69c7ecef405d168f658a9cc7996da84c17f61e66\n+4ce2f3d0d33346e9f0e96851689ee6550b2a72e3\n+44e1fd926cfb0df0fbd8c41de8cd65ed8d5d6e18\n+d6d2c8503c4039b682196d83a67dc28359c10c5c\n+ae233c4ec3d14a97c6195059f52873cdba2b4755\n+0f399a9ff227896265cafab9b2e9fab6cdb9b5b9\n+f4ed44ab4a8f9a87ba678d5fd1449fbf636103dc\n+7fcd61b2613c211bb042a82a889655178be6a212\n+42973f834445d7735738bdba8847812ba3c34d95\n+8df48b36ed3201d938b9974ecbee455d7dc2fb84\n+96ac26e56627f0c24213fcd3a1cce9fc95f1f661\n+cce94c518a46b7b0006f984bbe4d69e8749182d2\n+801dd40666d1e6009920ad3ff755c7bb993b2a62\n+ce829855cfca103dde55661fa1524e66b139d063\n+b148803b181e30213e8a7f3bd89c8239e9dcb866\n+c377feaad87f8109f85da6caf62602b30c20effc\n+b37cab65c63e051ebc5b491da9bd687581df94df\n+16e41844e7d6c5876d2caaeef6010656950c6ec5\n+ee50c9e48786dea0d9df2e45805c25565c100fe3\n+11dacc6154c42bc6fe3ba94c1823f8a46e4fe81a\n+791a0e6ddade27d1b69f4861a6640de60b9553cf\n+638e6c59da4fad987c437592174b188510193b2e\n+52f8877525d5238f3440e73710507be889d14127\n+2a56baf395bf11835d784c4f8634f4525deed6a1\n+bc561b4b7d6a3f71649d37d5eb9047c29efa2b13\n+31809d6f8514c4a8d5677e947e3f1ebb0db210b9\n+a31e9ad4f027955d43c04a05517244647e250161\n+777519bd96f68c18150a0f5942f8f97a91937f5e\n+4eb1f39d421024d9666cec61deaf96715ffae4c6\n+50fae68d416b4b8ec4ca192923dfd5ae9ea42773\n+ce665863b137ac4a7470cf006a92aa7694faca71\n+81f8c0378b2ab5ea0d7b65635cb529bd3c69127c\n+108222b9c323a05cc9339368f10ddd0859f62b43\n+28f788e47e58f2b462351d6989348a4e1a241b2b\n+d81dccf191a48a6b59c3747d7b4ccbe3535dde40\n+a90e6d2bffc422ddcdb771c53aac0bceb970a2c4\n+91e49c51f1aecc9e1d75457f4920d52a4b0a133c\n+60dd9cc470584960431de425e2a9ffbed0e8034a\n+ede386c2193fc31351e193b3a8cf30030d6be62c\n+a084767b40c0d3ba8fa8f8d60f1e8d99a9dc3457\n+3f726c99f819f97f2ab21b94d34c6b3129cd883a\n+77fc469fc78cdd87c29f398d46ac58dbb9ef62c0\n+4ae6d0fbef60ccbecf8f23bb482e201b3678f7a3\n+8858b6ddd3bce9daa08da6e05de3ca863a399c15\n+22e301a3d56dc9e6878380ee92c7d19ca43119d2\n+c484ec6c9b85ca4e331e395c564ae232fd0681dd\n+a46a671e253528e450bd57645c400bf761da07ab\n+655970d9c60ae6850daf452457e14e21047c0e1b\n+b6a48914c50631914192aa11b19205436a9c664d\n+7db65c363a0cc6ca7cdb04de9a973ab70013baad\n+6366941275344dac7e2130b0c972e90117d37ed0\n+4fb2586661471a1572c2df2a5a091011d45eb7c4\n+d7be7b39fa1021ec4518186afe145ee948e12a94\n+85aec87b11ec41295558175c63f1f5a849460fdf\n+aeb31756276034dd506fdf97c8aaade0e7e584f5\n+ac016e17d20253129a0287cee7e1d06b7ef15966\n+bf74d377fb8e20140da6eac1407414928384bcea\n+2c811e08db651a4aed6ea0f7c1972d60de6de8ab\n+e5d26e47c7a482c072a7fe47bb84c56854734184\n+96a63a3e0cefe920819bd42add0041837b1214a1\n+e526ca6284b9e13be1b912b80dd73a34e739b539\n+ecd21357f16106e541e9c2854ead2a906659b938\n+4b5a7ce0c301ad971f383eb60f61bf9b4026efda\n+929fd7276c0f0c30b9416f61a6f5f35d763d81e4\n+fa8a0639f7b0ce04030b72b4d5be4f0aa36fc5cb\n+f1f1605c22a6283bbfd757055fcf2b584a857709\n+0c173a15ca1bf20999f74987988985508c9de463\n+df0793f324e33066cc746c0cb1d053d35733d626\n+2b0179d8a9b75397937126b36114df0dddeab40c\n+bf0a08be281dc42241e7f264c2a20515eb4781bb\n+3895e25a77363ae8b49358fb793f50fa8b271e2d\n+1fc783fc08bc078239537535f174ab8a489772c0\n+1d4805ce04645f3203b0cfd3d66ea710e7433eb4\n+d3b58704d1d325875fc605580c1c02b825c1bbcc\n+ed88e3194c4bc43aeafef929da7b419d03dea1ad\n+dd07f47b79628668e29cc0143b21e790100ee445\n+65cc7aacfbfc7b747926375280a1d839e88d576b\n+080ec5209172ac9605f1434559dbb3c1e012b10a\n+416af3edf5b5ab265acf95568f2bc9eabd3d96de\n+e0a7801223fd573863939e76cb633f1dcc2d22c4\n+4bc853b50fd9127687eb9e4f3b679dd261a4fa96\n+c68a9a69278aa194fed96bd9733d32af3690a11e\n+c38f540298f0e188df5ed68fd56c623b9ac8331b\n+643fa0b22d70e459d7f7ec3d728ae4811dc5158f\n+e053e05c130549f43953f1d70e724dc9ce3e1b85\n+75e898c094eea533d1dfaf141c6afccc3072c49f\n+2805d606bc46bf5589093a1b92d3542c13ce50c2\n+32751807c9c06011eb689cba56b401a6302699c0\n+30853e16d332816752dafcfca92147c7ffef5b54\n+bea5b00cfe95cd37832305c0f93c339a22a7d79d\n+c871f323b418fac27bf834843ca26985010df53f\n+329fc1dce7a1c372c8b10c2f2f8732b2c60daff0\n+1aefc94dd78d6e0c9209cb09fc16f53dedf42108\n+8e5725666b519b61fcdc3141da5c6a57c1959909\n+a4ca0b042365061020627a8c045cddacea3312ec\n+8bd16ee12fc8ef6723e0572c29b979c15b92b4f4\n+87abe20fc118721cc5efdbd94a8462468cd1da2b\n+4b766fcdd4ca16399075d1e081a321b3b05ce516\n+f6241b3e420e19f3f0507cbbc872fe9218916a02\n+7ee523604851af62c0a47c07ee023a8710ef32f7\n+776ba233e939fe41a74c6b2632b93a0679a32c71\n+6a796b2b53fe542e0f340f250f4f20d69efed8d0\n+23d78c4dd01bc74ba35db3e3df95280f6f1b2e22\n+f4b15e2de97c4f8cdbb40bef4c9d0ab2807974d9\n+fff72de5bf8ac7b70208e655f237b80e70e18851\n+170bc2c381f86a523de2fc8b71d62ade66303c0d\n+314ebdfcb38d4b4c977579f787d5e1a20d068c94\n+e9274839bf316b1972d80d28e45759f898edbf86\n+75171f099e82e3527d7c3469b15891bd92227ec2\n+3c5e6c94caf40395e031fbde44a0cca46fdd76ec\n+dc8fc0c73bebbc1c48ac5540026030c9cc00ec23\n+492d22f92919d8d9d59568318c26c1e2ac4890cc\n+80c3a734298e824f9321c4efdd446086a3baad89\n+47535d7c3ec79c5978cdcc03a5351ddbbb22538d\n+1b25b6df0f08f7474228c5b6ed13b58682e1e440\n+c530c15180631cea95e9c292cf7fabde9dca9db3\n+2723bcdce3248417e98e6c43207bef74d34076c1\n+ed22eb4a62bd8d5369aaec87d4cbdc03c9f16368\n+9111df9673beb6d6616d491a5478f09b5f14d040\n+d86bb075bf6d1e78c1e4f3dd38b0ea828ef5ecfe\n+50a1cc0f0aef1514b917a5a3f4476967170b429d\n+6ce733747e160ca699711f2c47e686284ca9aa07\n+b44adf92342ad4f9c343ba29c081a91687932936\n+88799ea1b1c08f4bc1a487c9e3c2effd5e1650ae\n+080d7c700fc3291560d79fc590e05b8e2bad984f\n+12af74b289f8cdc6caf850dc6c802f9936b1e8b3\n+8e4f7e72410df3ba430082c7cf385f26fd75b033\n+8ac80412867118172dc4172494304e19969e9489\n+f2734c2828f69d9cfd535e5eab0592a7674b2b61\n+0b9fb682890b8fe10cec54072b809a5efe57d33d\n+5b029aaedb5fcf7cadd249607dd28eb3f233ab8c\n+79af9fbd8c3c0e54702a9c92b171f134bd4466c8\n+c412fd805ddf3282dc2e1f28e30f51ffcb1f1da2\n+111849345bb5140f86b48e730ceab4bff45fa2e9\n+a0b1e57b20a17177ed5a9a54e4a8aab597a546b4\n+ca209230c8e73745cf8cfc79f500c9c46e103306\n+a230b0588788dbe1ac84622aea169c577b381241\n+dfef6b6af08097f0676a2323085558fbbd3c48c6\n+3192e5278abca7c1f3b4a2a7f77a0ce941c73985\n+7c7ddd9ead99a8b5033a1a5d4698032c9e2b3a92\n+10b930dde8f14e9cb661810e97a33bbf144fc55c\n+9225de2cf652fe2bf6e50636824cdb641546f57d\n+598ef9c44b3ea2cc142c175f077b493f39f5ba22\n+c49355c7170a64bdd7864cc3ba9a64916b67fe7c\n+857d1e171e051b254a617f27b39f6a551054cee2\n+21833f9456f6ad5bc06321ad6d9590f42ce0195c\n+8910b4717e5bb946ee6988f7fe9fd461f53a5935\n+5703dff0939f05c7457cebd6fc61d88ab13afe41\n+8bfa13b15b84cb372950fb7b25a1080173060b6a\n+ac23a7c1f19b3d8c326ffe75c8e13edf285f90fe\n+19be26afe3d04783a92d032b55bf3fb1e2ae63cc\n+f7ec7cfd38b543ba81ac7bed5b77f9a19739460b\n+36afd4db4442c45d4078b1a7ad16a1872b5bee0d\n+88c2ae3ed2bb5d367dd408c9255cd8f1e7a36c7d\n+a13a417cdcfdfd1f1b3bf997bb6ffe6e69b096b9\n+d6064a89ac97dc0d2ce9da3982e1a4e25afaeda8\n+7146d96de3e15a80cafbab2af48ff6f65d8e41bb\n+5628c70f2a44567695e5331fe2293c5b7f35b629\n+7ff4a538a8682cdf02a4bcd6f15499c841001b73\n+aa5fa642b0e7ce2ea55e2298886f212f11a8894e\n+8efd1c820b9a782d8608d54d924658536178295c\n+50a226563cd8d7c0a5e8448e87fede0eb72a8354\n+b860915f8b0dae98e57a254d11575ea41f5c5a79\n+d304fef3746039183f51b3ac8f4774dcf3a64f59\n+53ab12d9318d5d195ccc77028b0e3ae66dc6e1fd\n+668de70be039a4f1ffcf20aeae2a22ee71fc55a8\n+0fea960ca917b73aff853fe88476174c8a313863\n+f89502306dcf6393a2c7b0efbb0fa728fc582137\n+ff58b1c3bdff5e5f687f10f9e40ce495ca49674e\n+0b96abc35f1a9d46a27eeddd7df418d107c29c57\n+b0b57a17306a7e963a4fe463f84e2b150a00a859\n+4105cb6fd964ad13099ca83b1fdf3d35f3961f74\n+23281a4dc3afc42a001346caec4dbb8193f0bb53\n+8daf103fa138f9a184448ebf1c2e03b9dbd96f21\n+02e5308c1b9f3771bbe49bc5036215fa2bd66aa9\n+a65ced1a66575c652baf5084644b8647f531be8c\n+2456a835f0bc7796d9ff71f64837fa6790e2b7cc\n+9ec1330b455c1ab2eb6b89f8a2ab885677d4ae8a\n+0b738075bd43fbd4410e30a51e0498cbfd2b7513\n+98c80e374b84e5a9c2d5c36889a0b1ebed5b814b\n+25720fc394e27a951bcad26095fb5a711bfacb8f\n+4cfd57d2e38207d78722ce8c9274ba8dd700d1cc\n+0fc1c31a878e93d938c67db3f958e82e3c39659f\n+df1ab5b4d67b46b5e9e840b1fbe0ff02520831f9\n+5bc3b6cede8dabdf3f4f27ddb03723cbb7cde51a\n+c2ea1e6561caba3abffce361abc800822b9e0efe\n+caa2f106d704ec3ade63498031dd58d34510bc76\n+dce853ef76ef90c46d84294225088d595467d08c\n+dbc8a8c86ae50059fddb2d6834fa5f0c9bbf9b71\n+0f921e6a0492c4e9f037a9ed91f474885032d68c\n+041331e1da23e4136fd046ed870cdcc177464176\n+e6ba5068f107ac234576e77cedbd748b665369c2\n+76fcd9d5034143a5b041766552670d19f926097d\n+72bf1b3d0962304850a3ef5fe375db4bff1d0a39\n+919db037f1f5cc73cdcaef92dd9cb0e7f5c8dec3\n+c36229b0b2e9d4554053f5c9fc451ac29a493b1f\n+9e4bb312e6958d2baa309ba670e5eed1523c6f47\n+d7ba4a233bd5a6f8fadee681c68a995e23fe36d7\n+98514988a3d3e8b7dbf0463884a5c38f5ed5562d\n+5412c08c3cf13577566064edd04da021c37b7cbe\n+31bcc667863f368157efa1143a78623a5db8f0d1\n+7bd1aa566fb4a4fe194f209085649f2c722b0cff\n+c4522e71c7e1d8ecfd70112e9375b9d00d6733a8\n+e22f409f18881b63a8e747036584a71217f40e6e\n+97ec6e5c9098a1240655cfcab05b6cd5eedb6cd1\n+bc121b0eb19713ec72002b5be03ba5ac35903a17\n+c98f6b3d93a2cc1b49a6db425ea2b661089d0f9e\n+0de7fd36de57a68e543b4c1f184fba192c398c73\n+e662d281b837c25b2b70525aa8fe8af894339823\n+44adf683ad232db8ce0cb89b3e236a1f5944cfb0\n+cb2ed300a89ebf9f0654da869ced665ed8b2abe7\n+0a6d48d9ed60b0b02177059ab116f8f46d2cbed3\n+b42291334651fff46dbfe5947a726f65cb9d7dfe\n+e5364991daecb73aca3bb5ac37f2619d7a89211b\n+4a2b170c075ce703cbdc82519a48016a9ee3f99c\n+924de0bd75a7f75df65d7d15f9d1587a2e794abf\n+1253f8692fc3a11be9430685cd405236a68df6c3\n+2b799ae9e1e0a540f9a5971ddf27d83254668279\n+c9bdf9a75f9fde8cd011e4aa94be4ed4347078a3\n+3d69ecb4edeb80003a1a41442e320898a30dbd9c\n+f08222e882b18c1f279308636e03beceece2dbf1\n+23e03f8d26d7bd03273a5dcbdcfe3905dfb49ffb\n+03dd707dc027fbf6f24120213f8eb66571600374\n+d0754799698de2c032abcb8198ee5d5401063213\n+072116fceb2294b97d1c40f79305f2e3ff71812b\n+e66cc1d58e16bf1650dd6479fed64ecaca8c6098\n+f137753a2dcd8229f89d1d1ac28039364e5850b4\n+61d191fbf953700ba8aeadc9c8cf4c195efbd10c\n+76f3c02fb01a6df98fbd8c16ac21d159d4649d37\n+6013c73b3312e11b447ed387426749014716f820\n+6faffb8a83db3f209a303a4464dbdd597faad5a4\n+cc9e8aca5f950c78dcfeff63c441ba993c1fe12f\n+8ca69a2a88a77eb06149fa049ab1a7e6de38b321\n+2f71490d21796594ca6f55e375558944de9db5a0\n+08cc5fd666456cb476467473ed1880c90c92dedb\n+e31a43c725ebe641d7c219c3886eee18eebf0bb8\n+52b5a8785de760a204b2b0aab19dfaf79c2c3ff0\n+483e8e4f4875a1a621ec9e9df2880d3037d95ed7\n+1e5799c52535a3fc20e885916f1e7ed33ecc7f46\n+a82e5d8220bbc8b5d786bed99b0876f530b9b7cc\n+7fe6c5c993706e8395cdaf7977bee793c06f48f3\n+2a0836f6d5e7c1d7e97bedb0e0ea33dcaf981f77\n+ddc308068d69c6c9aa629ee3c4ce75e1d1cf08b5\n+ec139a5621a9c9f03e1988391a3c7c6c5d849776\n+c01a6c48b982d625fd9f4f69005878781d3d56fa\n+95a983d56dbda457e3bf8766d59bac74c7aa5699\n+760741a00833876976389ed7a6b73f36ee5b4c13\n+6e5e5abba6f8bbbe61c22795df440dfafcfdc378\n+cf2cecb18779ce83de9adebf382dff1c19b12840\n+af9b7a9f2f73b1a2f9728106774dd13e8d1cdd8d\n+115735d547fdeade822f547eb3e8c8f9961a9b07\n+c2c69edf37b5c02aafa01d0407dadbf5ef8751b5\n+a072d1a83787e786d074a4b5871b0b961781f7c6\n+ed2cd59e258f756b2eaed7909a60956ade6ef7ee\n+ae5575ba41c8a782805afb1c08730343cfc22397\n+6ff2c8d29f6b5a5c2ce63f0a16f3bb0dbd049451\n+a80de15113166354cdf208e3d8b6e25f4511a591\n+06bd4f637f15e769f088d9051a5af94bbb0217a3\n+6700cc993cc07fb0f5b8b577ff8c4afcf0b18274\n+37f9a1f627c0995d89b62923e75cd092600894f9\n+8844ef15ded02d5ed86fb95aaf251235fcef2396\n+1b87e5b5b184a0a6c683eda23b36393822b57f03\n+e2bf830bb6c1bfa038c943dd6f5d92a406bd723f\n+423ca302a3ee87000530da3c105f269b8fabece7\n+4e14afe42fdd468d5de11df8cc13defdcb8e83f8\n+3e90fe6534206412ea22beaa445cf20d28fbe718\n+88b77c7da0a672c89e24df37ea6e9085b4e2a05c\n+0ad104190465d8d65c2344bbe10dcf3df025d86c\n+5c7df7022bcd360e6af00b9458b1a3fd54e1cc9a\n+59ad56851a342d2c62f6b38bf15002b23ab439e1"
      },
      {
        "sha": "60768dc59a962934d85092c8b67b282ee0db1d6b",
        "filename": "contrib/zmq/zmq_sub.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/zmq/zmq_sub.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/zmq/zmq_sub.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -38,7 +38,7 @@\n \n class ZMQHandler():\n     def __init__(self):\n-        self.loop = zmq.asyncio.install()\n+        self.loop = asyncio.get_event_loop()\n         self.zmqContext = zmq.asyncio.Context()\n \n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)"
      },
      {
        "sha": "0df843c9a3f46c6ae146bc0d9975e79da0370537",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -42,7 +42,7 @@\n \n class ZMQHandler():\n     def __init__(self):\n-        self.loop = zmq.asyncio.install()\n+        self.loop = asyncio.get_event_loop()\n         self.zmqContext = zmq.asyncio.Context()\n \n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)"
      },
      {
        "sha": "8444dc26f27b26dd1cd489f276be2b31e4c1886e",
        "filename": "depends/config.site.in",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/config.site.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/config.site.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.site.in?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -64,7 +64,6 @@ LDFLAGS=\"-L$depends_prefix/lib $LDFLAGS\"\n CC=\"@CC@\"\n CXX=\"@CXX@\"\n OBJC=\"${CC}\"\n-CCACHE=$depends_prefix/native/bin/ccache\n PYTHONPATH=$depends_prefix/native/lib/python/dist-packages:$PYTHONPATH\n \n if test -n \"@AR@\"; then"
      },
      {
        "sha": "5ad2b580d2ea9706e8ebcc72d2bc59d6197056ed",
        "filename": "depends/packages/miniupnpc.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/miniupnpc.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/miniupnpc.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/miniupnpc.mk?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -6,10 +6,9 @@ $(package)_sha256_hash=90dda8c7563ca6cd4a83e23b3c66dbbea89603a1675bfdb852897c2c9\n \n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\"\n-$(package)_build_opts_darwin=OS=Darwin LIBTOOL=\"$($(package)_libtool)\"\n+$(package)_build_opts_darwin=LIBTOOL=\"$($(package)_libtool)\"\n $(package)_build_opts_mingw32=-f Makefile.mingw\n $(package)_build_env+=CFLAGS=\"$($(package)_cflags) $($(package)_cppflags)\" AR=\"$($(package)_ar)\"\n-$(package)_build_env+=CFLAGS=-D_DARWIN_C_SOURCE\n endef\n \n define $(package)_preprocess_cmds"
      },
      {
        "sha": "5f247e9bf34877ed5b37ee526e2737654b2b5ef7",
        "filename": "depends/packages/native_biplist.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/native_biplist.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/native_biplist.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_biplist.mk?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,14 +1,9 @@\n package=native_biplist\n-$(package)_version=0.9\n-$(package)_download_path=https://pypi.python.org/packages/source/b/biplist\n+$(package)_version=1.0.3\n+$(package)_download_path=https://bitbucket.org/wooster/biplist/downloads\n $(package)_file_name=biplist-$($(package)_version).tar.gz\n-$(package)_sha256_hash=b57cadfd26e4754efdf89e9e37de87885f9b5c847b2615688ca04adfaf6ca604\n+$(package)_sha256_hash=4c0549764c5fe50b28042ec21aa2e14fe1a2224e239a1dae77d9e7f3932aa4c6\n $(package)_install_libdir=$(build_prefix)/lib/python/dist-packages\n-$(package)_patches=sorted_list.patch\n-\n-define $(package)_preprocess_cmds\n-  patch -p1 < $($(package)_patch_dir)/sorted_list.patch\n-endef\n \n define $(package)_build_cmds\n     python setup.py build"
      },
      {
        "sha": "8f4eb225387d01aa7dabd73e1922f6d0ebf3960d",
        "filename": "depends/packages/native_ccache.mk",
        "status": "removed",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07090c5339436f856e79a8036d1c85deeb453803/depends/packages/native_ccache.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07090c5339436f856e79a8036d1c85deeb453803/depends/packages/native_ccache.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_ccache.mk?ref=07090c5339436f856e79a8036d1c85deeb453803",
        "patch": "@@ -1,25 +0,0 @@\n-package=native_ccache\n-$(package)_version=3.4.1\n-$(package)_download_path=https://samba.org/ftp/ccache\n-$(package)_file_name=ccache-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=ca5a01fb4868cdb5176c77b8b4a390be7929a6064be80741217e0686f03f8389\n-\n-define $(package)_set_vars\n-$(package)_config_opts=\n-endef\n-\n-define $(package)_config_cmds\n-  $($(package)_autoconf)\n-endef\n-\n-define $(package)_build_cmds\n-  $(MAKE)\n-endef\n-\n-define $(package)_stage_cmds\n-  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n-endef\n-\n-define $(package)_postprocess_cmds\n-  rm -rf lib include\n-endef"
      },
      {
        "sha": "551c9fa70b6668f526067925ee1eee7de0e382d5",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,5 +1,4 @@\n packages:=boost openssl libevent zeromq\n-native_packages := native_ccache\n \n qt_native_packages = native_protobuf\n qt_packages = qrencode protobuf zlib"
      },
      {
        "sha": "849192755281382b5477deca982e94a2ed204394",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,7 +8,7 @@ $(package)_dependencies=openssl zlib\n $(package)_linux_dependencies=freetype fontconfig libxcb libX11 xproto libXext\n $(package)_build_subdir=qtbase\n $(package)_qt_libs=corelib network widgets gui plugins testlib\n-$(package)_patches=mac-qmake.conf mingw-uuidof.patch pidlist_absolute.patch fix-xcb-include-order.patch fix_qt_pkgconfig.patch\n+$(package)_patches=mac-qmake.conf mingw-uuidof.patch pidlist_absolute.patch fix-xcb-include-order.patch fix_qt_pkgconfig.patch fix-cocoahelpers-macos.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n $(package)_qttranslations_sha256_hash=3a15aebd523c6d89fb97b2d3df866c94149653a26d27a00aac9b6d3020bc5a1d\n@@ -140,6 +140,7 @@ define $(package)_preprocess_cmds\n   patch -p1 < $($(package)_patch_dir)/pidlist_absolute.patch && \\\n   patch -p1 < $($(package)_patch_dir)/fix-xcb-include-order.patch && \\\n   patch -p1 < $($(package)_patch_dir)/fix_qt_pkgconfig.patch && \\\n+  patch -p1 < $($(package)_patch_dir)/fix-cocoahelpers-macos.patch && \\\n   echo \"!host_build: QMAKE_CFLAGS     += $($(package)_cflags) $($(package)_cppflags)\" >> qtbase/mkspecs/common/gcc-base.conf && \\\n   echo \"!host_build: QMAKE_CXXFLAGS   += $($(package)_cxxflags) $($(package)_cppflags)\" >> qtbase/mkspecs/common/gcc-base.conf && \\\n   echo \"!host_build: QMAKE_LFLAGS     += $($(package)_ldflags)\" >> qtbase/mkspecs/common/gcc-base.conf && \\"
      },
      {
        "sha": "cde523370f0e4ca32e91b327e8d6b12f5b96dfd5",
        "filename": "depends/packages/zeromq.mk",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/zeromq.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/packages/zeromq.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/zeromq.mk?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,9 +1,9 @@\n package=zeromq\n-$(package)_version=4.2.2\n+$(package)_version=4.2.3\n $(package)_download_path=https://github.com/zeromq/libzmq/releases/download/v$($(package)_version)/\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=5b23f4ca9ef545d5bd3af55d305765e3ee06b986263b31967435d285a3e6df6b\n-$(package)_patches=0001-fix-build-with-older-mingw64.patch\n+$(package)_sha256_hash=8f1e2b2aade4dbfde98d82366d61baef2f62e812530160d2e6d0a5bb24e40bc0\n+$(package)_patches=0001-fix-build-with-older-mingw64.patch 0002-disable-pthread_set_name_np.patch\n \n define $(package)_set_vars\n   $(package)_config_opts=--without-docs --disable-shared --without-libsodium --disable-curve --disable-curve-keygen --disable-perf\n@@ -13,7 +13,7 @@ endef\n \n define $(package)_preprocess_cmds\n    patch -p1 < $($(package)_patch_dir)/0001-fix-build-with-older-mingw64.patch && \\\n-  ./autogen.sh\n+   patch -p1 < $($(package)_patch_dir)/0002-disable-pthread_set_name_np.patch\n endef\n \n define $(package)_config_cmds"
      },
      {
        "sha": "89abdb1b71ff81ffdcab8b138ae86d53b4a07442",
        "filename": "depends/patches/native_biplist/sorted_list.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 29,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07090c5339436f856e79a8036d1c85deeb453803/depends/patches/native_biplist/sorted_list.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07090c5339436f856e79a8036d1c85deeb453803/depends/patches/native_biplist/sorted_list.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/native_biplist/sorted_list.patch?ref=07090c5339436f856e79a8036d1c85deeb453803",
        "patch": "@@ -1,29 +0,0 @@\n---- a/biplist/__init__.py\t2014-10-26 19:03:11.000000000 +0000\n-+++ b/biplist/__init__.py\t2016-07-19 19:30:17.663521999 +0000\n-@@ -541,7 +541,7 @@\n-             return HashableWrapper(n)\n-         elif isinstance(root, dict):\n-             n = {}\n--            for key, value in iteritems(root):\n-+            for key, value in sorted(iteritems(root)):\n-                 n[self.wrapRoot(key)] = self.wrapRoot(value)\n-             return HashableWrapper(n)\n-         elif isinstance(root, list):\n-@@ -616,7 +616,7 @@\n-             elif isinstance(obj, dict):\n-                 size = proc_size(len(obj))\n-                 self.incrementByteCount('dictBytes', incr=1+size)\n--                for key, value in iteritems(obj):\n-+                for key, value in sorted(iteritems(obj)):\n-                     check_key(key)\n-                     self.computeOffsets(key, asReference=True)\n-                     self.computeOffsets(value, asReference=True)\n-@@ -714,7 +714,7 @@\n-                 keys = []\n-                 values = []\n-                 objectsToWrite = []\n--                for key, value in iteritems(obj):\n-+                for key, value in sorted(iteritems(obj)):\n-                     keys.append(key)\n-                     values.append(value)\n-                 for key in keys:"
      },
      {
        "sha": "1b43a9eff8fe924961b3962ee0d892ae5553c75c",
        "filename": "depends/patches/qt/fix-cocoahelpers-macos.patch",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/patches/qt/fix-cocoahelpers-macos.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/patches/qt/fix-cocoahelpers-macos.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix-cocoahelpers-macos.patch?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,70 @@\n+From 0707260a4f8e64dfadf1df5f935e74cabb7c7d27 Mon Sep 17 00:00:00 2001\n+From: Jake Petroules <jake.petroules@qt.io>\n+Date: Sun, 1 Oct 2017 21:48:17 -0700\n+Subject: [PATCH] Fix build error with macOS 10.13 SDK\n+MIME-Version: 1.0\n+Content-Type: text/plain; charset=utf8\n+Content-Transfer-Encoding: 8bit\n+\n+Several of these variables/macros are no longer defined. We didn't\n+validate the preconditions on iOS, tvOS, or watchOS, so no\n+need to bother validating them on macOS either. Nor did we check the\n+OSStatus result on any platform anyways.\n+\n+Task-number: QTBUG-63401\n+Change-Id: Ife64dff767cf6d3f4b839fc53ec486181c176bf3\n+(cherry-picked from 861544583511d4e6f7745d2339b26ff1cd44132b)\n+Reviewed-by: Timur Pocheptsov <timur.pocheptsov@qt.io>\n+Reviewed-by: Tor Arne Vestb\u00c3\u00b8 <tor.arne.vestbo@qt.io>\n+---\n+ src/plugins/platforms/cocoa/qcocoahelpers.h  |  2 +-\n+ src/plugins/platforms/cocoa/qcocoahelpers.mm | 13 +------------\n+ 2 files changed, 2 insertions(+), 13 deletions(-)\n+\n+diff --git old/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.h new/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.h\n+index bbb3793..74371d5 100644\n+--- old/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.h\n++++ new/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.h\n+@@ -80,7 +80,7 @@ QColor qt_mac_toQColor(CGColorRef color);\n+ // Creates a mutable shape, it's the caller's responsibility to release.\n+ HIMutableShapeRef qt_mac_QRegionToHIMutableShape(const QRegion &region);\n+ \n+-OSStatus qt_mac_drawCGImage(CGContextRef inContext, const CGRect *inBounds, CGImageRef inImage);\n++void qt_mac_drawCGImage(CGContextRef inContext, const CGRect *inBounds, CGImageRef inImage);\n+ \n+ NSDragOperation qt_mac_mapDropAction(Qt::DropAction action);\n+ NSDragOperation qt_mac_mapDropActions(Qt::DropActions actions);\n+diff --git old/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.mm new/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.mm\n+index cd73148..3f8429e 100644\n+--- old/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.mm\n++++ new/qtbase/src/plugins/platforms/cocoa/qcocoahelpers.mm\n+@@ -544,15 +544,8 @@ NSRect qt_mac_flipRect(const QRect &rect)\n+     return NSMakeRect(rect.x(), flippedY, rect.width(), rect.height());\n+ }\n+ \n+-OSStatus qt_mac_drawCGImage(CGContextRef inContext, const CGRect *inBounds, CGImageRef inImage)\n++void qt_mac_drawCGImage(CGContextRef inContext, const CGRect *inBounds, CGImageRef inImage)\n+ {\n+-    // Verbatim copy if HIViewDrawCGImage (as shown on Carbon-Dev)\n+-    OSStatus err = noErr;\n+-\n+-    require_action(inContext != NULL, InvalidContext, err = paramErr);\n+-    require_action(inBounds != NULL, InvalidBounds, err = paramErr);\n+-    require_action(inImage != NULL, InvalidImage, err = paramErr);\n+-\n+     CGContextSaveGState( inContext );\n+     CGContextTranslateCTM (inContext, 0, inBounds->origin.y + CGRectGetMaxY(*inBounds));\n+     CGContextScaleCTM(inContext, 1, -1);\n+@@ -560,10 +553,6 @@ OSStatus qt_mac_drawCGImage(CGContextRef inContext, const CGRect *inBounds, CGIm\n+     CGContextDrawImage(inContext, *inBounds, inImage);\n+ \n+     CGContextRestoreGState(inContext);\n+-InvalidImage:\n+-InvalidBounds:\n+-InvalidContext:\n+-        return err;\n+ }\n+ \n+ Qt::MouseButton cocoaButton2QtButton(NSInteger buttonNum)\n+-- \n+2.7.4"
      },
      {
        "sha": "d220b54f3ecdbae3605be72dbcd0c6b2c5ee85f7",
        "filename": "depends/patches/zeromq/0002-disable-pthread_set_name_np.patch",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/depends/patches/zeromq/0002-disable-pthread_set_name_np.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/depends/patches/zeromq/0002-disable-pthread_set_name_np.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/zeromq/0002-disable-pthread_set_name_np.patch?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,35 @@\n+From 6e6b47d5ab381c3df3b30bb0b0a6cf210dfb1eba Mon Sep 17 00:00:00 2001\n+From: Cory Fields <cory-nospam-@coryfields.com>\n+Date: Mon, 5 Mar 2018 14:22:05 -0500\n+Subject: [PATCH] disable pthread_set_name_np\n+\n+pthread_set_name_np adds a Glibc requirement on >= 2.12.\n+---\n+ src/thread.cpp | 4 +++-\n+ 1 file changed, 3 insertions(+), 1 deletion(-)\n+\n+diff --git a/src/thread.cpp b/src/thread.cpp\n+index 4fc59c3e..c3fdfd46 100644\n+--- a/src/thread.cpp\n++++ b/src/thread.cpp\n+@@ -220,7 +220,7 @@ void zmq::thread_t::setThreadName(const char *name_)\n+  */\n+     if (!name_)\n+         return;\n+-\n++#if 0\n+ #if defined(ZMQ_HAVE_PTHREAD_SETNAME_1)\n+     int rc = pthread_setname_np(name_);\n+     if(rc) return;\n+@@ -233,6 +233,8 @@ void zmq::thread_t::setThreadName(const char *name_)\n+ #elif defined(ZMQ_HAVE_PTHREAD_SET_NAME)\n+     pthread_set_name_np(descriptor, name_);\n+ #endif\n++#endif\n++    return;\n+ }\n+ \n+ #endif\n+-- \n+2.11.1\n+"
      },
      {
        "sha": "975be4be9ed63d2c203b79ccf5a02ce82ceb8ad0",
        "filename": "doc/README_osx.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/README_osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/README_osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_osx.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-Deterministic OS X Dmg Notes.\n+Deterministic OS X DMG Notes.\n \n Working OS X DMGs are created in Linux by combining a recent clang,\n the Apple binutils (ld, ar, etc) and DMG authoring tools."
      },
      {
        "sha": "7010edfcd38f2fa1eff002c0f952e6702515195d",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -45,7 +45,7 @@ Only supports JSON as output format.\n * verificationprogress : (numeric) estimate of verification progress [0..1]\n * chainwork : (string) total amount of work in active chain, in hexadecimal\n * pruned : (boolean) if the blocks are subject to pruning\n-* pruneheight : (numeric) heighest block available\n+* pruneheight : (numeric) highest block available\n * softforks : (array) status of softforks in progress\n * bip9_softforks : (object) status of BIP9 softforks in progress\n "
      },
      {
        "sha": "e52a770cedb68df51523681742dfaed8108d12fe",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -16,7 +16,7 @@ Then install [Homebrew](https://brew.sh).\n Dependencies\n ----------------------\n \n-    brew install automake berkeley-db4 libtool boost miniupnpc openssl pkg-config protobuf python3 qt libevent\n+    brew install automake berkeley-db4 libtool boost miniupnpc openssl pkg-config protobuf python qt libevent qrencode\n \n See [dependencies.md](dependencies.md) for a complete overview.\n "
      },
      {
        "sha": "2d10484a6516c69b7e74a8a174c65453ae8b48af",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -326,6 +326,7 @@ For the wallet (optional):\n Then build using:\n \n     ./autogen.sh\n+    ./configure --disable-wallet # OR\n     ./configure BDB_CFLAGS=\"-I${BDB_PREFIX}/include\" BDB_LIBS=\"-L${BDB_PREFIX}/lib -ldb_cxx\"\n     gmake\n "
      },
      {
        "sha": "0a4136173b8e7bc45120ab920a38a31d8f57dafd",
        "filename": "doc/build-windows.md",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/build-windows.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/build-windows.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-windows.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -35,7 +35,7 @@ To install WSL on Windows 10 with Fall Creators Update installed (version >= 162\n \n 1. Enable the Windows Subsystem for Linux feature\n   * Open the Windows Features dialog (`OptionalFeatures.exe`)\n-  * Enable 'Windows Susbsystem for Linux'\n+  * Enable 'Windows Subsystem for Linux'\n   * Click 'OK' and restart if necessary\n 2. Install Ubuntu\n   * Open Microsoft Store and search for Ubuntu or use [this link](https://www.microsoft.com/store/productId/9NBLGGH4MSV6)\n@@ -62,6 +62,8 @@ installing the toolchain will be different.\n \n First, install the general dependencies:\n \n+    sudo apt update\n+    sudo apt upgrade\n     sudo apt install build-essential libtool autotools-dev automake pkg-config bsdmainutils curl git\n \n A host toolchain (`build-essential`) is necessary because some dependency"
      },
      {
        "sha": "7aa96c4c9b0715a87922893274659c8cc938c6cb",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -7,7 +7,6 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | --- | --- | --- | --- | --- | --- |\n | Berkeley DB | [4.8.30](http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html) | 4.8.x | No |  |  |\n | Boost | [1.64.0](http://www.boost.org/users/download/) | [1.47.0](https://github.com/bitcoin/bitcoin/pull/8920) | No |  |  |\n-| ccache | [3.3.6](https://ccache.samba.org/download.html) |  | No |  |  |\n | Clang |  | [3.3+](http://llvm.org/releases/download.html) (C++11 support) |  |  |  |\n | D-Bus | [1.10.18](https://cgit.freedesktop.org/dbus/dbus/tree/NEWS?h=dbus-1.10) |  | No | Yes |  |\n | Expat | [2.2.5](https://libexpat.github.io/) |  | No | Yes |  |\n@@ -27,5 +26,5 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | Qt | [5.7.1](https://download.qt.io/official_releases/qt/) | 4.7+ | No |  |  |\n | XCB |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L94) (Linux only) |\n | xkbcommon |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk#L93) (Linux only) |\n-| ZeroMQ | [4.2.2](https://github.com/zeromq/libzmq/releases) |  | No |  |  |\n+| ZeroMQ | [4.2.3](https://github.com/zeromq/libzmq/releases) |  | No |  |  |\n | zlib | [1.2.11](http://zlib.net/) |  |  |  | No |"
      },
      {
        "sha": "0de18922009e2dd9e415e697fa96fab6311c0b4e",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 196,
        "deletions": 34,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,6 +1,43 @@\n Developer Notes\n ===============\n \n+<!-- markdown-toc start -->\n+**Table of Contents**\n+\n+- [Developer Notes](#developer-notes)\n+    - [Coding Style](#coding-style)\n+    - [Doxygen comments](#doxygen-comments)\n+    - [Development tips and tricks](#development-tips-and-tricks)\n+        - [Compiling for debugging](#compiling-for-debugging)\n+        - [Compiling for gprof profiling](#compiling-for-gprof-profiling)\n+        - [debug.log](#debuglog)\n+        - [Testnet and Regtest modes](#testnet-and-regtest-modes)\n+        - [DEBUG_LOCKORDER](#debug_lockorder)\n+        - [Valgrind suppressions file](#valgrind-suppressions-file)\n+        - [Compiling for test coverage](#compiling-for-test-coverage)\n+    - [Locking/mutex usage notes](#lockingmutex-usage-notes)\n+    - [Threads](#threads)\n+    - [Ignoring IDE/editor files](#ignoring-ideeditor-files)\n+- [Development guidelines](#development-guidelines)\n+    - [General Bitcoin Core](#general-bitcoin-core)\n+    - [Wallet](#wallet)\n+    - [General C++](#general-c)\n+    - [C++ data structures](#c-data-structures)\n+    - [Strings and formatting](#strings-and-formatting)\n+    - [Variable names](#variable-names)\n+    - [Threads and synchronization](#threads-and-synchronization)\n+    - [Source code organization](#source-code-organization)\n+    - [GUI](#gui)\n+    - [Subtrees](#subtrees)\n+    - [Git and GitHub tips](#git-and-github-tips)\n+    - [Scripted diffs](#scripted-diffs)\n+    - [RPC interface guidelines](#rpc-interface-guidelines)\n+\n+<!-- markdown-toc end -->\n+\n+Coding Style\n+---------------\n+\n Various coding styles have been used during the history of the codebase,\n and the result is not very consistent. However, we're now trying to converge to\n a single style, which is specified below. When writing patches, favor the new\n@@ -39,6 +76,7 @@ code.\n   - `++i` is preferred over `i++`.\n   - `nullptr` is preferred over `NULL` or `(void*)0`.\n   - `static_assert` is preferred over `assert` where possible. Generally; compile-time checking is preferred over run-time checking.\n+  - `enum class` is preferred over `enum` where possible. Scoped enumerations avoid two potential pitfalls/problems with traditional C++ enumerations: implicit conversions to int, and name clashes due to enumerators being exported to the surrounding scope.\n \n Block style example:\n ```c++\n@@ -137,39 +175,44 @@ Documentation can be generated with `make docs` and cleaned up with `make clean-\n Development tips and tricks\n ---------------------------\n \n-**compiling for debugging**\n+### Compiling for debugging\n+\n+Run configure with `--enable-debug` to add additional compiler flags that\n+produce better debugging builds.\n+\n+### Compiling for gprof profiling\n \n-Run configure with the --enable-debug option, then make. Or run configure with\n-CXXFLAGS=\"-g -ggdb -O0\" or whatever debug flags you need.\n+Run configure with the `--enable-gprof` option, then make.\n \n-**debug.log**\n+### debug.log\n \n If the code is behaving strangely, take a look in the debug.log file in the data directory;\n error and debugging messages are written there.\n \n-The -debug=... command-line option controls debugging; running with just -debug or -debug=1 will turn\n+The `-debug=...` command-line option controls debugging; running with just `-debug` or `-debug=1` will turn\n on all categories (and give you a very large debug.log file).\n \n-The Qt code routes qDebug() output to debug.log under category \"qt\": run with -debug=qt\n+The Qt code routes `qDebug()` output to debug.log under category \"qt\": run with `-debug=qt`\n to see it.\n \n-**testnet and regtest modes**\n+### Testnet and Regtest modes\n \n-Run with the -testnet option to run with \"play bitcoins\" on the test network, if you\n+Run with the `-testnet` option to run with \"play bitcoins\" on the test network, if you\n are testing multi-machine code that needs to operate across the internet.\n \n-If you are testing something that can run on one machine, run with the -regtest option.\n-In regression test mode, blocks can be created on-demand; see test/functional/ for tests\n-that run in -regtest mode.\n+If you are testing something that can run on one machine, run with the `-regtest` option.\n+In regression test mode, blocks can be created on-demand; see [test/functional/](/test/functional) for tests\n+that run in `-regtest` mode.\n \n-**DEBUG_LOCKORDER**\n+### DEBUG_LOCKORDER\n \n-Bitcoin Core is a multithreaded application, and deadlocks or other multithreading bugs\n-can be very difficult to track down. Compiling with -DDEBUG_LOCKORDER (configure\n-CXXFLAGS=\"-DDEBUG_LOCKORDER -g\") inserts run-time checks to keep track of which locks\n-are held, and adds warnings to the debug.log file if inconsistencies are detected.\n+Bitcoin Core is a multi-threaded application, and deadlocks or other\n+multi-threading bugs can be very difficult to track down. The `--enable-debug`\n+configure option adds `-DDEBUG_LOCKORDER` to the compiler flags. This inserts\n+run-time checks to keep track of which locks are held, and adds warnings to the\n+debug.log file if inconsistencies are detected.\n \n-**Valgrind suppressions file**\n+### Valgrind suppressions file\n \n Valgrind is a programming tool for memory debugging, memory leak detection, and\n profiling. The repo contains a Valgrind suppressions file\n@@ -184,7 +227,7 @@ $ valgrind --suppressions=contrib/valgrind.supp --leak-check=full \\\n $ valgrind -v --leak-check=full src/bitcoind -printtoconsole\n ```\n \n-**compiling for test coverage**\n+### Compiling for test coverage\n \n LCOV can be used to generate a test coverage report based upon `make check`\n execution. LCOV must be installed on your system (e.g. the `lcov` package\n@@ -200,22 +243,73 @@ make cov\n # A coverage report will now be accessible at `./test_bitcoin.coverage/index.html`.\n ```\n \n+**Sanitizers**\n+\n+Bitcoin can be compiled with various \"sanitizers\" enabled, which add\n+instrumentation for issues regarding things like memory safety, thread race\n+conditions, or undefined behavior. This is controlled with the\n+`--with-sanitizers` configure flag, which should be a comma separated list of\n+sanitizers to enable. The sanitizer list should correspond to supported\n+`-fsanitize=` options in your compiler. These sanitizers have runtime overhead,\n+so they are most useful when testing changes or producing debugging builds.\n+\n+Some examples:\n+\n+```bash\n+# Enable both the address sanitizer and the undefined behavior sanitizer\n+./configure --with-sanitizers=address,undefined\n+\n+# Enable the thread sanitizer\n+./configure --with-sanitizers=thread\n+```\n+\n+If you are compiling with GCC you will typically need to install corresponding\n+\"san\" libraries to actually compile with these flags, e.g. libasan for the\n+address sanitizer, libtsan for the thread sanitizer, and libubsan for the\n+undefined sanitizer. If you are missing required libraries, the configure script\n+will fail with a linker error when testing the sanitizer flags.\n+\n+The test suite should pass cleanly with the `thread` and `undefined` sanitizers,\n+but there are a number of known problems when using the `address` sanitizer. The\n+address sanitizer is known to fail in\n+[sha256_sse4::Transform](/src/crypto/sha256_sse4.cpp) which makes it unusable\n+unless you also use `--disable-asm` when running configure. We would like to fix\n+sanitizer issues, so please send pull requests if you can fix any errors found\n+by the address sanitizer (or any other sanitizer).\n+\n+Not all sanitizer options can be enabled at the same time, e.g. trying to build\n+with `--with-sanitizers=address,thread` will fail in the configure script as\n+these sanitizers are mutually incompatible. Refer to your compiler manual to\n+learn more about these options and which sanitizers are supported by your\n+compiler.\n+\n+Additional resources:\n+\n+ * [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)\n+ * [LeakSanitizer](https://clang.llvm.org/docs/LeakSanitizer.html)\n+ * [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html)\n+ * [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)\n+ * [UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)\n+ * [GCC Instrumentation Options](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)\n+ * [Google Sanitizers Wiki](https://github.com/google/sanitizers/wiki)\n+ * [Issue #12691: Enable -fsanitize flags in Travis](https://github.com/bitcoin/bitcoin/issues/12691)\n+\n Locking/mutex usage notes\n -------------------------\n \n The code is multi-threaded, and uses mutexes and the\n-LOCK/TRY_LOCK macros to protect data structures.\n+`LOCK` and `TRY_LOCK` macros to protect data structures.\n \n-Deadlocks due to inconsistent lock ordering (thread 1 locks cs_main\n-and then cs_wallet, while thread 2 locks them in the opposite order:\n-result, deadlock as each waits for the other to release its lock) are\n-a problem. Compile with -DDEBUG_LOCKORDER to get lock order\n-inconsistencies reported in the debug.log file.\n+Deadlocks due to inconsistent lock ordering (thread 1 locks `cs_main` and then\n+`cs_wallet`, while thread 2 locks them in the opposite order: result, deadlock\n+as each waits for the other to release its lock) are a problem. Compile with\n+`-DDEBUG_LOCKORDER` (or use `--enable-debug`) to get lock order inconsistencies\n+reported in the debug.log file.\n \n Re-architecting the core code so there are better-defined interfaces\n between the various components is a goal, with any necessary locking\n-done by the components (e.g. see the self-contained CKeyStore class\n-and its cs_KeyStore lock for example).\n+done by the components (e.g. see the self-contained `CBasicKeyStore` class\n+and its `cs_KeyStore` lock for example).\n \n Threads\n -------\n@@ -240,12 +334,8 @@ Threads\n \n - DumpAddresses : Dumps IP addresses of nodes to peers.dat.\n \n-- ThreadFlushWalletDB : Close the wallet.dat file if it hasn't been used in 500ms.\n-\n - ThreadRPCServer : Remote procedure call handler, listens on port 8332 for connections and services them.\n \n-- BitcoinMiner : Generates bitcoins (if wallet is enabled).\n-\n - Shutdown : Does an orderly shutdown of everything.\n \n Ignoring IDE/editor files\n@@ -382,6 +472,18 @@ C++ data structures\n   - *Rationale*: Easier to understand what is happening, thus easier to spot mistakes, even for those\n   that are not language lawyers\n \n+- Initialize all non-static class members where they are defined\n+\n+  - *Rationale*: Initializing the members in the declaration makes it easy to spot uninitialized ones,\n+  and avoids accidentally reading uninitialized memory\n+\n+```cpp\n+class A\n+{\n+    uint32_t m_count{0};\n+}\n+```\n+\n Strings and formatting\n ------------------------\n \n@@ -417,11 +519,11 @@ member name:\n ```c++\n class AddressBookPage\n {\n-    Mode mode;\n+    Mode m_mode;\n }\n \n AddressBookPage::AddressBookPage(Mode _mode) :\n-      mode(_mode)\n+      m_mode(_mode)\n ...\n ```\n \n@@ -530,7 +632,10 @@ its upstream repository.\n Current subtrees include:\n \n - src/leveldb\n-  - Upstream at https://github.com/google/leveldb ; Maintained by Google, but open important PRs to Core to avoid delay\n+  - Upstream at https://github.com/google/leveldb ; Maintained by Google, but\n+    open important PRs to Core to avoid delay.\n+  - **Note**: Follow the instructions in [Upgrading LevelDB](#upgrading-leveldb) when\n+    merging upstream changes to the leveldb subtree.\n \n - src/libsecp256k1\n   - Upstream at https://github.com/bitcoin-core/secp256k1/ ; actively maintaned by Core contributors.\n@@ -541,6 +646,52 @@ Current subtrees include:\n - src/univalue\n   - Upstream at https://github.com/jgarzik/univalue ; report important PRs to Core to avoid delay.\n \n+Upgrading LevelDB\n+---------------------\n+\n+Extra care must be taken when upgrading LevelDB. This section explains issues\n+you must be aware of.\n+\n+### File Descriptor Counts\n+\n+In most configurations we use the default LevelDB value for `max_open_files`,\n+which is 1000 at the time of this writing. If LevelDB actually uses this many\n+file descriptors it will cause problems with Bitcoin's `select()` loop, because\n+it may cause new sockets to be created where the fd value is >= 1024. For this\n+reason, on 64-bit Unix systems we rely on an internal LevelDB optimization that\n+uses `mmap()` + `close()` to open table files without actually retaining\n+references to the table file descriptors. If you are upgrading LevelDB, you must\n+sanity check the changes to make sure that this assumption remains valid.\n+\n+In addition to reviewing the upstream changes in `env_posix.cc`, you can use `lsof` to\n+check this. For example, on Linux this command will show open `.ldb` file counts:\n+\n+```bash\n+$ lsof -p $(pidof bitcoind) |\\\n+    awk 'BEGIN { fd=0; mem=0; } /ldb$/ { if ($4 == \"mem\") mem++; else fd++ } END { printf \"mem = %s, fd = %s\\n\", mem, fd}'\n+mem = 119, fd = 0\n+```\n+\n+The `mem` value shows how many files are mmap'ed, and the `fd` value shows you\n+many file descriptors these files are using. You should check that `fd` is a\n+small number (usually 0 on 64-bit hosts).\n+\n+See the notes in the `SetMaxOpenFiles()` function in `dbwrapper.cc` for more\n+details.\n+\n+### Consensus Compatibility\n+\n+It is possible for LevelDB changes to inadvertently change consensus\n+compatibility between nodes. This happened in Bitcoin 0.8 (when LevelDB was\n+first introduced). When upgrading LevelDB you should review the upstream changes\n+to check for issues affecting consensus compatibility.\n+\n+For example, if LevelDB had a bug that accidentally prevented a key from being\n+returned in an edge case, and that bug was fixed upstream, the bug \"fix\" would\n+be an incompatible consensus change. In this situation the correct behavior\n+would be to revert the upstream fix before applying the updates to Bitcoin's\n+copy of LevelDB. In general you should be wary of any upstream changes affecting\n+what data is returned from LevelDB queries.\n \n Git and GitHub tips\n ---------------------\n@@ -608,7 +759,7 @@ To create a scripted-diff:\n \n The scripted-diff is verified by the tool `contrib/devtools/commit-script-check.sh`\n \n-Commit `bb81e173` is an example of a scripted-diff.\n+Commit [`bb81e173`](https://github.com/bitcoin/bitcoin/commit/bb81e173) is an example of a scripted-diff.\n \n RPC interface guidelines\n --------------------------\n@@ -698,3 +849,14 @@ A few guidelines for introducing and reviewing new RPC interfaces:\n     client may be aware of prior to entering a wallet RPC call, we must block\n     until the wallet is caught up to the chainstate as of the RPC call's entry.\n     This also makes the API much easier for RPC clients to reason about.\n+\n+- Be aware of RPC method aliases and generally avoid registering the same\n+  callback function pointer for different RPCs.\n+\n+  - *Rationale*: RPC methods registered with the same function pointer will be\n+    considered aliases and only the first method name will show up in the\n+    `help` rpc command list.\n+\n+  - *Exception*: Using RPC method aliases may be appropriate in cases where a\n+    new RPC is replacing a deprecated RPC, to avoid both RPCs confusingly\n+    showing up in the command list."
      },
      {
        "sha": "ffd13ae1f9e93d017b234a718fb31b66b39b8b06",
        "filename": "doc/init.md",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/init.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/init.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/init.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -84,6 +84,8 @@ Installing this .service file consists of just copying it to\n To test, run `systemctl start bitcoind` and to enable for system startup run\n `systemctl enable bitcoind`\n \n+NOTE: When installing for systemd in Debian/Ubuntu the .service file needs to be copied to the /lib/systemd/system directory instead.\n+\n ### OpenRC\n \n Rename bitcoind.openrc to bitcoind and drop it in /etc/init.d.  Double\n@@ -93,6 +95,8 @@ check ownership and permissions and make it executable.  Test it with\n \n ### Upstart (for Debian/Ubuntu based distributions)\n \n+Upstart is the default init system for Debian/Ubuntu versions older than 15.04. If you are using version 15.04 or newer and haven't manually configured upstart you should follow the systemd instructions instead.\n+\n Drop bitcoind.conf in /etc/init.  Test by running `service bitcoind start`\n it will automatically start on reboot.\n "
      },
      {
        "sha": "48ee364c187c89211347629ef5caa93c1925a94b",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 61,
        "deletions": 2,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -48,7 +48,7 @@ Compatibility\n ==============\n \n Bitcoin Core is extensively tested on multiple operating systems using\n-the Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n+the Linux kernel, macOS 10.8+, and Windows 7 and newer (Windows XP is not supported).\n \n Bitcoin Core should also work on most other Unix-like systems but is not\n frequently tested on them.\n@@ -61,7 +61,66 @@ RPC changes\n \n ### Low-level changes\n \n-- The `fundrawtransaction` rpc will reject the previously deprecated `reserveChangeKey` option.\n+- The `createrawtransaction` RPC will now accept an array or dictionary (kept for compatibility) for the `outputs` parameter. This means the order of transaction outputs can be specified by the client.\n+- The `fundrawtransaction` RPC will reject the previously deprecated `reserveChangeKey` option.\n+- Wallet `getnewaddress` and `addmultisigaddress` RPC `account` named\n+  parameters have been renamed to `label` with no change in behavior.\n+- Wallet `getlabeladdress`, `getreceivedbylabel`, `listreceivedbylabel`, and\n+  `setlabel` RPCs have been added to replace `getaccountaddress`,\n+  `getreceivedbyaccount`, `listreceivedbyaccount`, and `setaccount` RPCs,\n+  which are now deprecated. There is no change in behavior between the\n+  new RPCs and deprecated RPCs.\n+- Wallet `listreceivedbylabel`, `listreceivedbyaccount` and `listunspent` RPCs\n+  add `label` fields to returned JSON objects that previously only had\n+  `account` fields.\n+- `sendmany` now shuffles outputs to improve privacy, so any previously expected behavior with regards to output ordering can no longer be relied upon.\n+\n+External wallet files\n+---------------------\n+\n+The `-wallet=<path>` option now accepts full paths instead of requiring wallets\n+to be located in the -walletdir directory.\n+\n+Newly created wallet format\n+---------------------------\n+\n+If `-wallet=<path>` is specified with a path that does not exist, it will now\n+create a wallet directory at the specified location (containing a wallet.dat\n+data file, a db.log file, and database/log.?????????? files) instead of just\n+creating a data file at the path and storing log files in the parent\n+directory. This should make backing up wallets more straightforward than\n+before because the specified wallet path can just be directly archived without\n+having to look in the parent directory for transaction log files.\n+\n+For backwards compatibility, wallet paths that are names of existing data files\n+in the `-walletdir` directory will continue to be accepted and interpreted the\n+same as before.\n+\n+Low-level RPC changes\n+---------------------\n+\n+- When bitcoin is not started with any `-wallet=<path>` options, the name of\n+  the default wallet returned by `getwalletinfo` and `listwallets` RPCs is\n+  now the empty string `\"\"` instead of `\"wallet.dat\"`. If bitcoin is started\n+  with any `-wallet=<path>` options, there is no change in behavior, and the\n+  name of any wallet is just its `<path>` string.\n+\n+### Logging\n+\n+- The log timestamp format is now ISO 8601 (e.g. \"2018-02-28T12:34:56Z\").\n+\n+Miner block size removed\n+------------------------\n+\n+The `-blockmaxsize` option for miners to limit their blocks' sizes was\n+deprecated in V0.15.1, and has now been removed. Miners should use the\n+`-blockmaxweight` option if they want to limit the weight of their blocks'\n+weights.\n+\n+Python Support\n+--------------\n+\n+Support for Python 2 has been discontinued for all test files and tools.\n \n Credits\n ======="
      },
      {
        "sha": "8f158b3481cfa033cf05400581cb0319fb8e3c45",
        "filename": "doc/release-notes/release-notes-0.16.0.md",
        "status": "added",
        "additions": 720,
        "deletions": 0,
        "changes": 720,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/release-notes/release-notes-0.16.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/release-notes/release-notes-0.16.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.16.0.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,720 @@\n+Bitcoin Core version 0.16.0 is now available from:\n+\n+  <https://bitcoincore.org/bin/bitcoin-core-0.16.0/>\n+\n+This is a new major version release, including new features, various bugfixes\n+and performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at GitHub:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+How to Upgrade\n+==============\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\n+or `bitcoind`/`bitcoin-qt` (on Linux).\n+\n+The first time you run version 0.15.0 or newer, your chainstate database will be converted to a\n+new format, which will take anywhere from a few minutes to half an hour,\n+depending on the speed of your machine.\n+\n+Note that the block database format also changed in version 0.8.0 and there is no\n+automatic upgrade code from before version 0.8 to version 0.15.0 or higher. Upgrading\n+directly from 0.7.x and earlier without re-downloading the blockchain is not supported.\n+However, as usual, old wallet versions are still supported.\n+\n+Downgrading warning\n+-------------------\n+\n+Wallets created in 0.16 and later are not compatible with versions prior to 0.16\n+and will not work if you try to use newly created wallets in older versions. Existing\n+wallets that were created with older versions are not affected by this.\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+Wallet changes\n+---------------\n+\n+### Segwit Wallet\n+\n+Bitcoin Core 0.16.0 introduces full support for segwit in the wallet and user interfaces. A new `-addresstype` argument has been added, which supports `legacy`, `p2sh-segwit` (default), and `bech32` addresses. It controls what kind of addresses are produced by `getnewaddress`, `getaccountaddress`, and `createmultisigaddress`. A `-changetype` argument has also been added, with the same options, and by default equal to `-addresstype`, to control which kind of change is used.\n+\n+A new `address_type` parameter has been added to the `getnewaddress` and `addmultisigaddress` RPCs to specify which type of address to generate.\n+A `change_type` argument has been added to the `fundrawtransaction` RPC to override the `-changetype` argument for specific transactions.\n+\n+- All segwit addresses created through `getnewaddress` or `*multisig` RPCs explicitly get their redeemscripts added to the wallet file. This means that downgrading after creating a segwit address will work, as long as the wallet file is up to date.\n+- All segwit keys in the wallet get an implicit redeemscript added, without it being written to the file. This means recovery of an old backup will work, as long as you use new software.\n+- All keypool keys that are seen used in transactions explicitly get their redeemscripts added to the wallet files. This means that downgrading after recovering from a backup that includes a segwit address will work\n+\n+Note that some RPCs do not yet support segwit addresses. Notably, `signmessage`/`verifymessage` doesn't support segwit addresses, nor does `importmulti` at this time. Support for segwit in those RPCs will continue to be added in future versions.\n+\n+P2WPKH change outputs are now used by default if any destination in the transaction is a P2WPKH or P2WSH output. This is done to ensure the change output is as indistinguishable from the other outputs as possible in either case.\n+\n+### BIP173 (Bech32) Address support (\"bc1...\" addresses)\n+\n+Full support for native segwit addresses (BIP173 / Bech32) has now been added.\n+This includes the ability to send to BIP173 addresses (including non-v0 ones), and generating these\n+addresses (including as default new addresses, see above).\n+\n+A checkbox has been added to the GUI to select whether a Bech32 address or P2SH-wrapped address should be generated when using segwit addresses. When launched with `-addresstype=bech32` it is checked by default. When launched with `-addresstype=legacy` it is unchecked and disabled.\n+\n+### HD-wallets by default\n+\n+Due to a backward-incompatible change in the wallet database, wallets created\n+with version 0.16.0 will be rejected by previous versions. Also, version 0.16.0\n+will only create hierarchical deterministic (HD) wallets. Note that this only applies\n+to new wallets; wallets made with previous versions will not be upgraded to be HD.\n+\n+### Replace-By-Fee by default in GUI\n+\n+The send screen now uses BIP125 RBF by default, regardless of `-walletrbf`.\n+There is a checkbox to mark the transaction as final.\n+\n+The RPC default remains unchanged: to use RBF, launch with `-walletrbf=1` or\n+use the `replaceable` argument for individual transactions.\n+\n+### Wallets directory configuration (`-walletdir`)\n+\n+Bitcoin Core now has more flexibility in where the wallets directory can be\n+located. Previously wallet database files were stored at the top level of the\n+bitcoin data directory. The behavior is now:\n+\n+- For new installations (where the data directory doesn't already exist),\n+  wallets will now be stored in a new `wallets/` subdirectory inside the data\n+  directory by default.\n+- For existing nodes (where the data directory already exists), wallets will be\n+  stored in the data directory root by default. If a `wallets/` subdirectory\n+  already exists in the data directory root, then wallets will be stored in the\n+  `wallets/` subdirectory by default.\n+- The location of the wallets directory can be overridden by specifying a\n+  `-walletdir=<path>` option where `<path>` can be an absolute path to a\n+  directory or directory symlink.\n+\n+Care should be taken when choosing the wallets directory location, as if it\n+becomes unavailable during operation, funds may be lost.\n+\n+Build: Minimum GCC bumped to 4.8.x\n+------------------------------------\n+The minimum version of the GCC compiler required to compile Bitcoin Core is now 4.8. No effort will be\n+made to support older versions of GCC. See discussion in issue #11732 for more information.\n+The minimum version for the Clang compiler is still 3.3. Other minimum dependency versions can be found in `doc/dependencies.md` in the repository.\n+\n+Support for signalling pruned nodes (BIP159)\n+---------------------------------------------\n+Pruned nodes can now signal BIP159's NODE_NETWORK_LIMITED using service bits, in preparation for\n+full BIP159 support in later versions. This would allow pruned nodes to serve the most recent blocks. However, the current change does not yet include support for connecting to these pruned peers.\n+\n+Performance: SHA256 assembly enabled by default\n+-------------------------------------------------\n+The SHA256 hashing optimizations for architectures supporting SSE4, which lead to ~50% speedups in SHA256 on supported hardware (~5% faster synchronization and block validation), have now been enabled by default. In previous versions they were enabled using the `--enable-experimental-asm` flag when building, but are now the default and no longer deemed experimental.\n+\n+GUI changes\n+-----------\n+- Uses of \"\u00b5BTC\" in the GUI now also show the more colloquial term \"bits\", specified in BIP176.\n+- The option to reuse a previous address has now been removed. This was justified by the need to \"resend\" an invoice, but now that we have the request history, that need should be gone.\n+- Support for searching by TXID has been added, rather than just address and label.\n+- A \"Use available balance\" option has been added to the send coins dialog, to add the remaining available wallet balance to a transaction output.\n+- A toggle for unblinding the password fields on the password dialog has been added.\n+\n+RPC changes\n+------------\n+\n+### New `rescanblockchain` RPC\n+\n+A new RPC `rescanblockchain` has been added to manually invoke a blockchain rescan.\n+The RPC supports start and end-height arguments for the rescan, and can be used in a\n+multiwallet environment to rescan the blockchain at runtime.\n+\n+### New `savemempool` RPC\n+A new `savemempool` RPC has been added which allows the current mempool to be saved to\n+disk at any time to avoid it being lost due to crashes / power loss.\n+\n+### Safe mode disabled by default\n+\n+Safe mode is now disabled by default and must be manually enabled (with `-disablesafemode=0`) if you wish to use it. Safe mode is a feature that disables a subset of RPC calls - mostly related to the wallet and sending - automatically in case certain problem conditions with the network are detected. However, developers have come to regard these checks as not reliable enough to act on automatically. Even with safe mode disabled, they will still cause warnings in the `warnings` field of the `getneworkinfo` RPC and launch the `-alertnotify` command.\n+\n+### Renamed script for creating JSON-RPC credentials\n+\n+The `share/rpcuser/rpcuser.py` script was renamed to `share/rpcauth/rpcauth.py`. This script can be\n+used to create `rpcauth` credentials for a JSON-RPC user.\n+\n+### Validateaddress improvements\n+\n+The `validateaddress` RPC output has been extended with a few new fields, and support for segwit addresses (both P2SH and Bech32). Specifically:\n+* A new field `iswitness` is True for P2WPKH and P2WSH addresses (\"bc1...\" addresses), but not for P2SH-wrapped segwit addresses (see below).\n+* The existing field `isscript` will now also report True for P2WSH addresses.\n+* A new field `embedded` is present for all script addresses where the script is known and matches something that can be interpreted as a known address. This is particularly true for P2SH-P2WPKH and P2SH-P2WSH addresses. The value for `embedded` includes much of the information `validateaddress` would report if invoked directly on the embedded address.\n+* For multisig scripts a new `pubkeys` field was added that reports the full public keys involved in the script (if known). This is a replacement for the existing `addresses` field (which reports the same information but encoded as P2PKH addresses), represented in a more useful and less confusing way. The `addresses` field remains present for non-segwit addresses for backward compatibility.\n+* For all single-key addresses with known key (even when wrapped in P2SH or P2WSH), the `pubkey` field will be present. In particular, this means that invoking `validateaddress` on the output of `getnewaddress` will always report the `pubkey`, even when the address type is P2SH-P2WPKH.\n+\n+### Low-level changes\n+\n+- The deprecated RPC `getinfo` was removed. It is recommended that the more specific RPCs are used:\n+  * `getblockchaininfo`\n+  * `getnetworkinfo`\n+  * `getwalletinfo`\n+  * `getmininginfo`\n+- The wallet RPC `getreceivedbyaddress` will return an error if called with an address not in the wallet.\n+- The wallet RPC `addwitnessaddress` was deprecated and will be removed in version 0.17,\n+  set the `address_type` argument of `getnewaddress`, or option `-addresstype=[bech32|p2sh-segwit]` instead.\n+- `dumpwallet` now includes hex-encoded scripts from the wallet in the dumpfile, and\n+  `importwallet` now imports these scripts, but corresponding addresses may not be added\n+  correctly or a manual rescan may be required to find relevant transactions.\n+- The RPC `getblockchaininfo` now includes an `errors` field.\n+- A new `blockhash` parameter has been added to the `getrawtransaction` RPC which allows for a raw transaction to be fetched from a specific block if known, even without `-txindex` enabled.\n+- The `decoderawtransaction` and `fundrawtransaction` RPCs now have optional `iswitness` parameters to override the\n+  heuristic witness checks if necessary.\n+- The `walletpassphrase` timeout is now clamped to 2^30 seconds.\n+- Using addresses with the `createmultisig` RPC is now deprecated, and will be removed in a later version. Public keys should be used instead.\n+- Blockchain rescans now no longer lock the wallet for the entire rescan process, so other RPCs can now be used at the same time (although results of balances / transactions may be incorrect or incomplete until the rescan is complete).\n+- The `logging` RPC has now been made public rather than hidden.\n+- An `initialblockdownload` boolean has been added to the `getblockchaininfo` RPC to indicate whether the node is currently in IBD or not.\n+- `minrelaytxfee` is now included in the output of `getmempoolinfo`\n+\n+Other changed command-line options\n+----------------------------------\n+- `-debuglogfile=<file>` can be used to specify an alternative debug logging file.\n+- bitcoin-cli now has an `-stdinrpcpass` option to allow the RPC password to be read from standard input.\n+- The `-usehd` option has been removed.\n+- bitcoin-cli now supports a new `-getinfo` flag which returns an output like that of the now-removed `getinfo` RPC.\n+\n+Testing changes\n+----------------\n+- The default regtest JSON-RPC port has been changed to 18443 to avoid conflict with testnet's default of 18332.\n+- Segwit is now always active in regtest mode by default. Thus, if you upgrade a regtest node you will need to either -reindex or use the old rules by adding `vbparams=segwit:0:999999999999` to your regtest bitcoin.conf. Failure to do this will result in a CheckBlockIndex() assertion failure that will look like: Assertion `(pindexFirstNeverProcessed != nullptr) == (pindex->nChainTx == 0)' failed.\n+\n+0.16.0 change log\n+------------------\n+\n+### Block and transaction handling\n+- #10953 `aeed345` Combine scriptPubKey and amount as CTxOut in CScriptCheck (jl2012)\n+- #11309 `93d20a7` Minor cleanups for AcceptToMemoryPool (morcos)\n+- #11418 `38c201f` Add error string for CLEANSTACK script violation (maaku)\n+- #11411 `339da9c` Change SignatureHash input index check to an assert (jimpo)\n+- #11406 `e12522d` Add state message print to AcceptBlock failure message (TheBlueMatt)\n+- #11062 `26fee4f` Mark mempool import fails that were found in mempool as 'already there' (kallewoof)\n+- #11269 `61fb806` CTxMemPoolEntry::UpdateAncestorState: modifySiagOps param type (donaloconnor)\n+- #11747 `e970396` Fix: Open files read only if requested (Elbandi)\n+- #11737 `46d1ebf` Document partial validation in ConnectBlock() (sdaftuar)\n+- #10699 `c090262` Make all script validation flags backward compatible (sipa)\n+- #10279 `214046f` Add a CChainState class to validation.cpp to take another step towards clarifying internal interfaces (TheBlueMatt)\n+- #11824 `d9fdac1` Block ActivateBestChain to empty validationinterface queue (TheBlueMatt)\n+- #12127 `9501dc2` Remove unused mempool index (sdaftuar)\n+- #12118 `44080a9` Sort mempool by min(feerate, ancestor_feerate) (sdaftuar)\n+- #8498 `0e3a411` Minimize the number of times it is checked that no money... (jtimon)\n+- #12368 `3f5012b` Hold mempool.cs for the duration of ATMP (TheBlueMatt)\n+- #12401 `d44cd7e` Reset pblocktree before deleting LevelDB file (Sjors)\n+- #12415 `f893824` Interrupt loading thread after shutdown request (promag)\n+\n+### P2P protocol and network code\n+- #10596 `6866b49` Add vConnect to CConnman::Options (benma)\n+- #10663 `9d31ed2` Split resolve out of connect (theuni)\n+- #11113 `fef65c4` Ignore getheaders requests for very old side blocks (jimpo)\n+- #11585 `5aeaa9c` addrman: Add missing lock in Clear() (CAddrMan) (practicalswift)\n+- #11524 `5ef3b69` De-duplicate connection eviction logic (tjps)\n+- #11580 `1f4375f` Do not send (potentially) invalid headers in response to getheaders (TheBlueMatt)\n+- #11655 `aca77a4` Assert state.m_chain_sync.m_work_header in ConsiderEviction (practicalswift)\n+- #11744 `3ff6ff5` Add missing locks in net.{cpp,h} (practicalswift)\n+- #11740 `59d3dc8` Implement BIP159 NODE_NETWORK_LIMITED (pruned peers) *signaling only* (jonasschnelli)\n+- #11583 `37ffa16` Do not make it trivial for inbound peers to generate log entries (TheBlueMatt)\n+- #11363 `ba2f195` Split socket create/connect (theuni)\n+- #11917 `bc66765` Add testnet DNS seed:  seed.testnet.bitcoin.sprovoost.nl (Sjors)\n+- #11512 `6e89de5` Use GetDesireableServiceFlags in seeds, dnsseeds, fixing static seed adding (TheBlueMatt)\n+- #12262 `16bac24` Hardcoded seed update (laanwj)\n+- #12270 `9cf6393` Update chainTxData for 0.16 (laanwj)\n+- #12392 `0f61651` Fix ignoring tx data requests when fPauseSend is set on a peer (TheBlueMatt)\n+\n+### Wallet\n+- #11039 `fc51565` Avoid second mapWallet lookup (promag)\n+- #10952 `2621673` Remove vchDefaultKey and have better first run detection (achow101)\n+- #11007 `fc5c237` Fix potential memory leak when loading a corrupted wallet file (practicalswift)\n+- #10976 `07c92b9` Move some static functions out of wallet.h/cpp (ryanofsky)\n+- #11117 `961901f` Prepare for non-Base58 addresses (sipa)\n+- #10916 `e6ab88a` add missing lock to crypter GetKeys() (benma)\n+- #10767 `791a0e6` Clarify wallet initialization / destruction interface (jnewbery)\n+- #11250 `c22a53c` Bump wallet version to 159900 and remove the `usehd` option (achow101)\n+- #11307 `4f7e37e` Display non-HD error on first run (MarcoFalke)\n+- #11408 `69c7ece` Fix parameter name typo in ErasePurpose walletdb method (PierreRochard)\n+- #11167 `aa624b6` Full BIP173 (Bech32) support (sipa)\n+- #11594 `0ecc630` Improve -disablewallet parameter interaction (promag)\n+- #10368 `77ba4bf` Remove helper conversion operator from wallet (kallewoof)\n+- #11074 `99ec126` Assert that CWallet::SyncMetaData finds oldest transaction (BitonicEelis)\n+- #11272 `e6e3fc3` CKeystore/CCrypter: move relevant implementation out of the header (jonasschnelli)\n+- #10286 `927a1d7` Call wallet notify callbacks in scheduler thread (without cs_main) (TheBlueMatt)\n+- #10600 `4ed8180` Make feebumper class stateless (ryanofsky)\n+- #11466 `d080a7d` Specify custom wallet directory with -walletdir param (MeshCollider)\n+- #11839 `8ab6c0b` Don't attempt mempool entry for wallet transactions on startup (instagibbs)\n+- #11854 `2214954` Split up key and script metadata for better type safety (ryanofsky)\n+- #11870 `ef8ba7d` Remove unnecessary mempool lock in ReacceptWalletTransactions (promag)\n+- #11864 `2ae58d5` Make CWallet::FundTransaction atomic (promag)\n+- #11886 `df71819` Clarify getbalance meaning a tiny bit in response to questions (TheBlueMatt)\n+- #11923 `81c89e9` Remove unused fNoncriticalErrors variable from CWalletDB::FindWalletTx (PierreRochard)\n+- #11726 `604e08c` Cleanups + nit fixes for walletdir PR (MeshCollider)\n+- #11403 `d889c03` Segwit wallet support (sipa)\n+- #11970 `b7450cd` Add test coverage for bitcoin-cli multiwallet calls (ryanofsky)\n+- #11904 `66e3af7` Add a lock to the wallet directory (MeshCollider)\n+- #12101 `c7978be` Clamp walletpassphrase timeout to 2^30 seconds and check its bounds (achow101)\n+- #12210 `17180fa` Deprecate addwitnessaddress (laanwj)\n+- #12220 `f4c942e` Error if relative -walletdir is specified (ryanofsky)\n+- #11281 `8470e64` Avoid permanent cs_main/cs_wallet lock during RescanFromTime (jonasschnelli)\n+- #12119 `9594139` Use P2WPKH change output if any destination is P2WPKH or P2WSH (Sjors)\n+- #12213 `eadb2da` Add address type option to addmultisigaddress (promag)\n+- #12276 `7936446` Remove duplicate mapWallet lookups (promag)\n+\n+### RPC and other APIs\n+- #11008 `3841aaf` Enable disablesafemode by default (gmaxwell)\n+- #11050 `7ed57d3` Avoid treating null RPC arguments different from missing arguments (ryanofsky)\n+- #10997 `affe927` Add option -stdinrpcpass to bitcoin-cli to allow RPC password to be read from standard input (jharvell)\n+- #11179 `e0e3cbb` Push down safe mode checks (laanwj)\n+- #11203 `d745b4c` add wtxid to mempool entry output (sdaftuar)\n+- #11099 `bc561b4` Add savemempool RPC (greenaddress)\n+- #10838 `66a5b41` (finally) remove getinfo (TheBlueMatt)\n+- #10753 `7fcd61b` test: Check RPC argument mapping (laanwj)\n+- #11288 `0f8e095` More user-friendly error message when partially signing (MeshCollider)\n+- #11031 `ef8340d` deprecate estimatefee (jnewbery)\n+- #10858 `9a8e916` Add \"errors\" field to getblockchaininfo and unify \"errors\" field in get*info RPCs (achow101)\n+- #11021 `90926db` Fix getchaintxstats() (AkioNak)\n+- #11367 `3a93270` getblockchaininfo: Add disk_size, prune_target_size (esotericnonsense)\n+- #11006 `a1d78b5` Improve shutdown process (promag)\n+- #11529 `ff92fbf` Avoid slow transaction search with txindex enabled (promag)\n+- #11618 `87d90ef` Lock cs_main in blockToJSON/blockheaderToJSON (practicalswift)\n+- #11626 `998c304` Make `logging` RPC public (laanwj)\n+- #11258 `033c786` Add initialblockdownload to getblockchaininfo (jnewbery)\n+- #11087 `99bc0b4` Diagnose unsuitable outputs in lockunspent() (BitonicEelis)\n+- #11710 `9388639` cli: Reject arguments to -getinfo (laanwj)\n+- #11738 `d4267a3` Fix sendrawtransaction hang when sending a tx already in mempool (TheBlueMatt)\n+- #11753 `32c9b57` clarify abortrescan rpc use (instagibbs)\n+- #11191 `ef14f2e` Improve help text and behavior of RPC-logging (AkioNak)\n+- #10874 `9e38d35` getblockchaininfo: Loop through the bip9 soft fork deployments instead of hard coding (achow101)\n+- #10275 `497d0e0` Allow fetching tx directly from specified block in getrawtransaction (kallewoof)\n+- #11178 `fee0370` Add iswitness parameter to decode- and fundrawtransaction RPCs (MeshCollider)\n+- #11667 `711d16c` Add scripts to dumpwallet RPC (MeshCollider)\n+- #11475 `9bad8d6` mempoolinfo should take ::minRelayTxFee into account (mess110)\n+- #12001 `a9a49e6` Adding ::minRelayTxFee amount to getmempoolinfo and updating help (jeffrade)\n+- #12198 `adce1de` Add deprecation error for `getinfo` (laanwj)\n+- #11415 `69ec021` Disallow using addresses in createmultisig (achow101)\n+- #12278 `288deac` Add special error for genesis coinbase to getrawtransaction (MeshCollider)\n+- #11362 `c6223b3` Remove nBlockMaxSize from miner opt struct as it is no longer used (gmaxwell)\n+- #10825 `28485c7` Set regtest JSON-RPC port to 18443 to avoid conflict with testnet 18332 (fametrano)\n+- #11303 `e542728` Fix estimatesmartfee rounding display issue (TheBlueMatt)\n+- #7061 `8c2de82` Add RPC call \"rescanblockchain <startheight> <stopheight>\" (jonasschnelli)\n+- #11055 `95e14dc` RPC getreceivedbyaddress should return error if called with address not owned by the wallet (jnewbery)\n+- #12366 `93de37a` http: Join worker threads before deleting work queue (laanwj)\n+- #12315 `758a41e` Bech32 addresses in dumpwallet (fivepiece)\n+- #12427 `3762ac1` Make signrawtransaction accept P2SH-P2WSH redeemscripts (sipa)\n+\n+### GUI\n+- #10964 `64e66bb` Pass SendCoinsRecipient (208 bytes) by reference (practicalswift)\n+- #11169 `5b8af7b` Make tabs toolbar no longer have a context menu (achow101)\n+- #10911 `9c8f365` Fix typo and access key in optionsdialog.ui (keystrike)\n+- #10770 `ea729d5` Drop upgrade-cancel callback registration for a generic \"cancelable\" (TheBlueMatt)\n+- #11156 `a3624dd` Fix memory leaks in qt/guiutil.cpp (danra)\n+- #11268 `31e72b2` [macOS] remove Growl support, remove unused code (jonasschnelli)\n+- #11193 `c5c77bd` Terminate string *pszExePath after readlink and without using memset (practicalswift)\n+- #11508 `ffa5159` Fix crash via division by zero assertion (jonasschnelli)\n+- #11499 `6157e8c` Add upload and download info to the peerlist (debug menu) (aarongolliver)\n+- #11480 `ffc0b11` Add toggle for unblinding password fields (tjps)\n+- #11316 `22cdf93` Add use available balance in send coins dialog (CryptAxe, promag)\n+- #3716 `13e352d` Receive: Remove option to reuse a previous address (luke-jr)\n+- #11690 `f0c1f8a` Fix the StartupWMClass for bitoin-qt, so gnome-shell can recognize it (eklitzke)\n+- #10920 `f6f8d54` Fix potential memory leak in newPossibleKey(ChangeCWallet *wallet) (practicalswift)\n+- #11698 `7293d06` RPC-Console nested commands documentation  (lmlsna)\n+- #11395 `38d31f9` Enable searching by transaction id (luke-jr)\n+- #11556 `91eeaa0` Improved copy for RBF checkbox and tooltip (Sjors)\n+- #11809 `80f9dad` Fix proxy setting options dialog crash (laanwj)\n+- #11616 `8585bb8` Update ban-state in case of dirty-state during periodic sweep (jonasschnelli)\n+- #11605 `f19ca12` Enable RBF by default in QT (Sjors)\n+- #12074 `a1136f0` Optimizes boolean expression model && model->haveWatchOnly() (251Labs)\n+- #12035 `eeb6d52` Change \u00b5BTC to bits (jb55)\n+- #12092 `fd4ca17` Replaces numbered place marker %2 with %1 (251Labs)\n+- #12173 `bbc91b7` Use flexible font size for QRCode image address (jonasschnelli)\n+- #12211 `10d10d7` Avoid potential null dereference in ReceiveCoinsDialog constructor (ryanofsky)\n+- #12261 `f359afc` Bump BLOCK_CHAIN_SIZE to 200GB (laanwj)\n+- #11991 `062c8b6` Receive: checkbox for bech32 address (Sjors)\n+- #11644 `045a809` Fix qt build broken by 5a5e4e9 (TheBlueMatt)\n+- #11448 `d473e6d` reset addrProxy/addrSeparateProxyTor if colon char missing (mess110)\n+- #12377 `604f289` qt: Poll ShutdownTimer after init is done (MarcoFalke)\n+- #12374 `daaae36` qt: Make sure splash screen is freed on AppInitMain fail (laanwj)\n+- #12349 `ad10b90` shutdown: fix crash on shutdown with reindex-chainstate (theuni)\n+\n+### Build system\n+- #10923 `2c9f5ec` travis: Build with --enable-werror under OS X (practicalswift)\n+- #11176 `df8c722` build: Rename --enable-experimental-asm to --enable-asm and enable by default (laanwj)\n+- #11286 `11dacc6` [depends] Don't build libevent sample code (fanquake)\n+- #7142 `801dd40` Travis: Test build against system libs (& Qt4) (luke-jr)\n+- #11380 `390771b` Remove outdated share/certs/ directory (MeshCollider)\n+- #11391 `7632310` Remove lxcbr0 lines from gitian-build.sh (MeshCollider)\n+- #11435 `167cef8` build: Make \"make clean\" remove all files created when running \"make check\" (practicalswift)\n+- #11460 `e022463` [depends] mac_alias 2.0.6, ds_store 1.1.2 (fanquake)\n+- #11541 `bb9ab0f` Build: Fix Automake warnings when running autogen.sh (fanquake)\n+- #11611 `0e70791` [build] Don't fail when passed --disable-lcov and lcov isn't available (fanquake)\n+- #11651 `3c098a8` refactor: Make all #includes relative to project root (laanwj, MeshCollider, ryanofsky)\n+- #11621 `1f7695b` [build] Add temp_bitcoin_locale_qrc to CLEAN_QT to fix make distcheck (fanquake)\n+- #11755 `84fa645` [Docs] Bump minimum required version of GCC to 4.8 (fanquake)\n+- #9254 `6d3dc52` [depends] ZeroMQ 4.2.2 (fanquake)\n+- #11842 `3c8f0a3` [build] Add missing stuff to clean-local (kallewoof)\n+- #11936 `483bb67` [build] Warn that only libconsensus can be built without Boost (fanquake)\n+- #11945 `7a11ba7` Improve BSD compatibility of contrib/install_db4.sh (laanwj)\n+- #11981 `180a255` Fix gitian build after libzmq bump (theuni)\n+- #11903 `8f68fd2` [trivial] Add required package dependencies for depends cross compilation (jonasschnelli)\n+- #12168 `45cf8a0`  #include sys/fcntl.h to just fcntl.h (without sys/) (jsarenik)\n+- #12095 `3fa1ab4` Use BDB_LIBS/CFLAGS and pass --disable-replication (fanquake)\n+- #11711 `6378e5c` bitcoin_qt.m4: Minor fixes and clean-ups (fanquake)\n+- #11989 `90d4104` .gitignore: add QT Creator artifacts (Sjors)\n+- #11577 `c0ae864` Fix warnings (-Wsign-compare) when building with DEBUG_ADDRMAN (practicalswift)\n+\n+### Tests and QA\n+- #11024 `3e55f13` Remove OldSetKeyFromPassphrase/OldEncrypt/OldDecrypt (practicalswift)\n+- #10679 `31b2612` Document the non-DER-conformance of one test in tx_valid.json (schildbach)\n+- #11160 `ede386c` Improve versionbits_computeblockversion test code consistency (danra)\n+- #10303 `f088a1b` Include ms/blk stats in Connect* benchmarks (kallewoof)\n+- #10777 `d81dccf` Avoid redundant assignments. Remove unused variables (practicalswift)\n+- #11260 `52f8877` travis: Assert default datadir isn't created, Run scripted diff only once (MarcoFalke)\n+- #11271 `638e6c5` travis: filter out pyenv (theuni)\n+- #11285 `3255d63` Add -usehd to excluded args in check-doc.py (MeshCollider)\n+- #11297 `16e4184` Make sure ~/.bitcoin doesn't exist before build (MeshCollider)\n+- #11311 `cce94c5` travis: Revert default datadir check (MarcoFalke)\n+- #11300 `f4ed44a` Add a lint check for trailing whitespace (MeshCollider)\n+- #11323 `4ce2f3d` mininode: add an optimistic write and disable nagle (theuni)\n+- #11370 `2d85899` Add getblockchaininfo functional test (promag)\n+- #11365 `f199b8a` Add Qt GUI tests to Overview and ReceiveCoin Page (anditto)\n+- #11293 `dbc4ae0` Deduplicate CMerkleBlock construction code, add test coverage (jamesob)\n+- #10440 `9e8ef9d` Add libFuzzer support (practicalswift)\n+- #10941 `364da2c` Add blocknotify and walletnotify functional tests (promag)\n+- #11420 `8928093` Bump univalue subtree and fix json formatting in tests (MarcoFalke)\n+- #10099 `424be03` Slightly Improve Unit Tests for Checkqueue (JeremyRubin)\n+- #11513 `14b860b` A few Python3 tidy ups (jnewbery)\n+- #11486 `2ca518d` Add uacomment tests (mess110)\n+- #11452 `02ac8c8` Improve ZMQ functional test (promag)\n+- #10409 `b5545d8` Add fuzz testing for BlockTransactions and BlockTransactionsRequest (practicalswift)\n+- #11389 `dd56166` Support having segwit always active in regtest (sipa, ajtowns, jnewbery)\n+- #11562 `5776582` bench: use std::chrono rather than gettimeofday (theuni)\n+- #11182 `f7388e9` Add P2P interface to TestNode (jnewbery)\n+- #11552 `b5f9f02` Improve wallet-accounts test (ryanofsky)\n+- #11638 `5e3f5e4` Dead mininode code (jnewbery)\n+- #11646 `fe503e1` Require a steady clock for bench with at least micro precision (TheBlueMatt)\n+- #11468 `76b3349` Make comp test framework more debuggable (jnewbery)\n+- #11623 `ee92243` Add missing locks to tests (practicalswift)\n+- #11035 `927e528` [contrib] Add Valgrind suppressions file (practicalswift)\n+- #11641 `7adeea3` Only allow disconnecting all NodeConns (MarcoFalke)\n+- #11677 `3bdf242` Remove unused NodeConn members (MarcoFalke)\n+- #11699 `66d46c7` [travis-ci] Only run linters on Pull Requests (jnewbery)\n+- #11654 `084f52f` Initialize recently introduced non-static class member lastCycles to zero in constructor (practicalswift)\n+- #11648 `ccc70a2` Add messages.py (jnewbery)\n+- #11713 `49667a7` Fix for mismatched extern definition in wallet tests (sipsorcery)\n+- #11707 `0d89fa0` Fix sendheaders (jnewbery)\n+- #11718 `9cdd2bc` Move pwalletMain to wallet test fixture (laanwj)\n+- #11714 `901ba3e` Test that mempool rejects coinbase transactions (jamesob)\n+- #11743 `3d6ad40` Add multiwallet prefix test (MarcoFalke)\n+- #11683 `a892218` Remove unused mininode functions {ser,deser}_int_vector(...). Remove unused imports (practicalswift)\n+- #11712 `9f2c2db` Split NodeConn from NodeConnCB (jnewbery)\n+- #11791 `13e31dd` Rename NodeConn and NodeConnCB (jnewbery)\n+- #11835 `f60b4ad` Add Travis check for unused Python imports (practicalswift)\n+- #11849 `ad1820c` Assert that only one NetworkThread exists (jnewbery)\n+- #11877 `d4991c0` Improve createrawtransaction functional tests (promag)\n+- #11220 `2971fd0` Check specific validation error in miner tests (Sjors)\n+- #11947 `797441e` Fix rawtransactions test (laanwj)\n+- #11946 `8049241` Remove unused variable (firstAddrnServices) (practicalswift)\n+- #11867 `18a1bba` Improve node network test (jnewbery)\n+- #11883 `cfd99dd` Add configuration file/argument testing (MeshCollider)\n+- #11879 `d4e404a` Remove redundant univalue_tests.cpp (jnewbery)\n+- #11748 `20166f8` Adding unit tests for GetDifficulty in blockchain.cpp (merehap)\n+- #11517 `5180a86` Improve benchmark precision (martinus)\n+- #11291 `a332a7d` Fix string concatenation to os.path.join and add exception case (dongsam)\n+- #11965 `d38d1a3` Note on test order in test_runner (MarcoFalke)\n+- #11997 `ddff344` util_tests.cpp: actually check ignored args (ajtowns)\n+- #12079 `45173fa` Improve prioritisetransaction test coverage (promag)\n+- #12150 `92a810d` Fix ListCoins test failure due to unset g_address_type, g_change_type (ryanofsky)\n+- #12133 `1d2eaba` Fix rare failure in p2p-segwit.py (sdaftuar)\n+- #12082 `0910cbe` Adding test case for SINGLE|ANYONECANPAY hash type in tx_valid.json (Christewart)\n+- #11796 `4db16ec` Functional test naming convention (ajtowns)\n+- #12227 `b987ca4` test_runner: Readable output if create_cache.py fails (ryanofsky)\n+- #12089 `126000b` Make TestNodeCLI command optional in send_cli (MarcoFalke)\n+- #11774 `6970b30` Rename functional tests (ajtowns)\n+- #12264 `598a9c4` Fix versionbits warning test (jnewbery)\n+- #12217 `1213be6` Add missing syncwithvalidationinterfacequeue to tests (MarcoFalke)\n+- #12292 `eebe458` Fix names of excluded extended tests for travis (ajtowns)\n+- #11789 `60d739e` [travis-ci] Combine logs on failure (jnewbery)\n+- #11838 `3e50024` Add getrawtransaction in_active_chain=False test (MarcoFalke)\n+- #12206 `898f560` Sync with validationinterface queue in sync_mempools (MarcoFalke)\n+- #12424 `ff44101` Fix rescan test failure due to unset g_address_type, g_change_type (ryanofsky)\n+- #12388 `e2431d1` travis: Full clone for git subtree check (MarcoFalke)\n+\n+### Documentation\n+- #10680 `6366941` Fix inconsistencies and grammar in various files (MeshCollider)\n+- #11011 `7db65c3` Add a comment on the use of prevector in script (gmaxwell)\n+- #10878 `c58128f` Fix Markdown formatting issues in init.md (dongcarl)\n+- #11066 `9e00a62` Document the preference of nullptr over NULL or (void*)0 (practicalswift)\n+- #11094 `271e40a` Hash in ZMQ hash is raw bytes, not hex (runn1ng)\n+- #11026 `ea3ac59` Bugfix: Use testnet RequireStandard for -acceptnonstdtxn default (luke-jr)\n+- #11058 `4b65fa5` Comments: More comments on functions/globals in standard.h (jimpo)\n+- #11112 `3f726c9` [developer-notes] By default, declare single-argument constructors \"explicit\" (practicalswift)\n+- #11155 `a084767` Trivial: Documentation fixes for CVectorWriter ctors (danra)\n+- #11136 `108222b` Docs: Add python3 to list of dependencies on some platforms (danra)\n+- #11216 `81f8c03` Update hmac_sha256.h (utsavgupta)\n+- #11236 `ba05971` Add note on translations to CONTRIBUTING.md (MeshCollider)\n+- #11173 `4eb1f39` RPC: Fix currency unit string in the help text (AkioNak)\n+- #11135 `21e2f2f` Update developer notes with RPC response guidelines (promag)\n+- #11219 `bcc8a62` explain how to recompile a modified unit test (Sjors)\n+- #10779 `f656147` Create dependencies.md (flack)\n+- #10682 `2a56baf` Move the AreInputsStandard documentation next to its implementation (esneider)\n+- #11276 `ee50c9e` Update CONTRIBUTING.md to reduce unnecessary review workload (jonasschnelli)\n+- #11264 `b148803` Fix broken Markdown table in dependencies.md (practicalswift)\n+- #10691 `ce82985` Properly comment about shutdown process in init.cpp file (wraith7)\n+- #11330 `ae233c4` Fix comments for DEFAULT_WHITELIST[FORCE]RELAY (danra)\n+- #11340 `d6d2c85` Fix validation comments (danra)\n+- #11305 `2847480` Update release notes and manpages for 0.16 (MarcoFalke)\n+- #11132 `551d7bf` Document assumptions that are being made to avoid NULL pointer dereferences (practicalswift)\n+- #11390 `12ed800` Document scripted-diff (jnewbery)\n+- #11392 `a3b4c59` Fix stale link in gitian-building.md (shooterman)\n+- #11401 `4202273` Move gitian building to external repo (MarcoFalke)\n+- #11414 `bbc901d` Remove partial gitian build instructions from descriptors dir (fanquake)\n+- #11571 `c95832d` Fixed a couple small grammatical errors (BitsInMyBlood)\n+- #11624 `f9b74ef` Change formatting for sequence of steps (vivganes)\n+- #11597 `6f01dcf` Fix error messages in CFeeBumper (kallewoof)\n+- #11438 `7fbf3c6` Updated Windows build doc for WSL/Xenial workaround (sipsorcery)\n+- #11663 `41aa9c4` Add getreceivedbyaddress release notes (MarcoFalke)\n+- #11533 `cbb54e7` Update WSL installation notes for Fall Creators update (Thoragh)\n+- #11680 `4db82b7` Add instructions for lcov report generation (jamesob)\n+- #11686 `54aedc0` Make ISSUE_TEMPLATE a bit shorter, mention hardware tests (TheBlueMatt)\n+- #11704 `ea68190` Windows build doc update (sipsorcery)\n+- #11706 `5197100` Make default issue text all comments to make issues more readable (TheBlueMatt)\n+- #11140 `1429132` Improve #endif comments (danra)\n+- #11729 `7a43fbb` links to code style guides (Sjors)\n+- #11793 `8879d50` Bump OS X version to 10.13 (Varunram)\n+- #11783 `16fff80` Fix shutdown in case of errors during initialization (laanwj)\n+- #11804 `00d25e9` Fixed outdated link with archive.is (TimothyShimmin)\n+- #11960 `4307062` Fix link to installation script (laudaa)\n+- #12027 `63a4dc1` Remove boost --c++ flag from osx build instructions (fernandezpablo85)\n+- #12062 `5961b23` Increment MIT Licence copyright header year on files modified in 2017 (akx20000a)\n+- #12063 `36a5a44` Update license year range to 2018 (akx20000a)\n+- #12093 `5691028` Fix incorrect Markdown link (practicalswift)\n+- #12143 `b0d626d` Fix link for BIP159 pull request (azuchi)\n+- #12112 `3c62868` Remove the ending slashes from RPC URI format (jackycjh)\n+- #12166 `e839d65` Clarify -walletdir usage (jnewbery)\n+- #12241 `b030133` Fix incorrect link in /test/ README.md (fanquake)\n+- #12187 `b5e4b9b` Updating benchmarkmarking.md with an updated sample output (jeffrade)\n+- #12294 `7cf1aea` Create NetBSD build instructions and fix compilation (fanquake)\n+- #12251 `cc5870a` initwallet: Do not translate highly technical addresstype help (MarcoFalke)\n+- #11984 `efae366` Update OpenBSD build instructions for 6.2 (cont'd) (laanwj)\n+- #12293 `9d9c418` Mention that HD is enabled if hdmasterkeyid is present in getwalletinfo RPC help (fanquake)\n+- #12077 `c04cb48` Correct `sendmany` curl example (251Labs)\n+- #10677 `b3ecb7b` Document that addmultisigaddress is intended for non-watchonly addresses (instagibbs)\n+- #12177 `cad504b` Fix address_type help text of getnewaddress and getrawchangeaddress (mruddy)\n+\n+### Refactoring\n+- #9964 `b6a4891` Add const to methods that do not modify the object for which it is called (practicalswift)\n+- #10965 `655970d` Replace deprecated throw() with noexcept specifier (C++11) (practicalswift)\n+- #10645 `c484ec6` Use nullptr (C++11) instead of zero (0) as the null pointer constant (practicalswift)\n+- #10901 `22e301a` Fix constness of ArgsManager methods (promag)\n+- #10969 `4afb5aa` Declare single-argument (non-converting) constructors \"explicit\" (practicalswift)\n+- #11071 `dbf6bd6` Use static_assert(\u2026, \u2026) (C++11) instead of assert(\u2026) where appropriate (practicalswift)\n+- #10809 `c559884` optim: mark a few classes final (theuni)\n+- #10843 `2ab7c63` Add attribute [[noreturn]] (C++11) to functions that will not return (practicalswift)\n+- #11151 `7fd49d0` Fix header guards using reserved identifiers (danra)\n+- #11138 `2982511` Compat: Simplify bswap_16 implementation (danra)\n+- #11161 `745bbdc` Remove redundant explicitly defined copy ctors (danra)\n+- #11144 `cee4fe1` Move local include to before system includes (danra)\n+- #10781 `60dd9cc` Python cleanups (practicalswift)\n+- #10701 `50fae68` Remove the virtual specifier for functions with the override specifier (practicalswift)\n+- #11164 `38a54a5` Fix boost headers included as user instead of system headers (danra)\n+- #11143 `3aa60b7` Fix include path for bitcoin-config.h (danra)\n+- #8330 `59e1789` Structure Packing Optimizations in C{,Mutable}Transaction (JeremyRubin)\n+- #10845 `39ae413` Remove unreachable code (practicalswift)\n+- #11238 `6acdb1f` Add assertions before potential null deferences (MeshCollider)\n+- #11259 `089b742` Remove duplicate destination decoding (promag)\n+- #11232 `2f0d3e6` Ensure that data types are consistent (jjz)\n+- #10793 `efb4383` Changing &var[0] to var.data() (MeshCollider)\n+- #11196 `e278f86` Switch memory_cleanse implementation to BoringSSL's to ensure memory clearing even with -lto (maaku)\n+- #10888 `9821274` range-based loops and const qualifications in net.cpp (benma)\n+- #11351 `6c4fecf` Refactor: Modernize disallowed copy constructors/assignment (danra)\n+- #11385 `94c9015` Remove some unused functions and methods (sipa)\n+- #11301 `8776787` add m_added_nodes to connman options (benma)\n+- #11432 `058c0f9` Remove unused fTry from push_lock (promag)\n+- #11107 `e93fff1` Fix races in AppInitMain and others with lock and atomic bools (MeshCollider)\n+- #9572 `17f2ace` Skip witness sighash cache for non-segwit transactions (jl2012)\n+- #10961 `da0478e` Improve readability of DecodeBase58Check(...) (practicalswift)\n+- #11133 `a865b38` Document assumptions that are being made to avoid division by zero (practicalswift)\n+- #11073 `3bb77eb` Remove dead store in ecdsa_signature_parse_der_lax (BitonicEelis)\n+- #10898 `470c730` Fix invalid checks (NULL checks after dereference, redundant checks, etc.) (practicalswift)\n+- #11495 `50d72b3` [trivial] Make namespace explicit for is_regular_file (jnewbery)\n+- #11511 `db2f83e` [Init] Remove redundant exit(EXIT_FAILURE) instances and replace with return false (donaloconnor)\n+- #10866 `ef8a634` Fix -Wthread-safety-analysis warnings. Compile with -Wthread-safety-analysis if available (practicalswift)\n+- #11221 `0dec4cc` Refactor: simpler read (gnuser)\n+- #10696 `ef3758d` Remove redundant nullptr checks before deallocation (practicalswift)\n+- #11043 `5e9be16` Use std::unique_ptr (C++11) where possible (practicalswift)\n+- #11353 `05a7619` Small refactor of CCoinsViewCache::BatchWrite() (danra)\n+- #10749 `2adbddb` Use compile-time constants instead of unnamed enumerations (remove \"enum hack\") (practicalswift)\n+- #11603 `a933cb1` Move RPC registration out of AppInitParameterInteraction (ryanofsky)\n+- #11722 `26efc22` Switched sync.{cpp,h} to std threading primitives (tjps)\n+- #10493 `fbce66a` Use range-based for loops (C++11) when looping over map elements (practicalswift)\n+- #11337 `0d7e0a3` Fix code constness in CBlockIndex::GetAncestor() overloads (danra)\n+- #11516 `0e722e8` crypto: Add test cases covering the relevant HMAC-SHA{256,512} key length boundaries (practicalswift)\n+- #10574 `5d132e8` Remove includes in .cpp files for things the corresponding .h file already included (practicalswift)\n+- #11884 `66479c0` Remove unused include in hash.cpp (kallewoof)\n+- #10839 `c66adb2` Don't use pass by reference to const for cheaply-copied types (bool, char, etc.) (practicalswift)\n+- #10657 `79399c8` Utils: Improvements to ECDSA key-handling code (str4d)\n+- #12250 `e37ca2b` Make CKey::Load references const (ryanofsky)\n+- #12108 `9220426` Remove unused fQuit var from checkqueue.h (donaloconnor)\n+- #12159 `f3c7062` Use the character based overload for std::string::find (kekimusmaximus)\n+- #12266 `3448907` Move scheduler/threadGroup into common-init instead of per-app (TheBlueMatt)\n+\n+### Miscellaneous\n+- #11246 `777519b` github-merge: Coalesce git fetches (laanwj)\n+- #10871 `c9a4aa8` Handle getinfo in bitcoin-cli w/ -getinfo (revival of #8843) (achow101)\n+- #11419 `093074b` Utils: Fix launchctl not being able to stop bitcoind (OmeGak)\n+- #11394 `6e4e98e` Perform a weaker subtree check in Travis (sipa)\n+- #11702 `4122112` [build] Add a script for installing db4 (jamesob)\n+- #11794 `dd49862` Prefix leveldb debug logging (laanwj)\n+- #11781 `24df9af` Add `-debuglogfile` option (laanwj)\n+- #10773 `c17f11f` Shell script cleanups (practicalswift)\n+- #11829 `7630a1f` Test datadir specified in conf file exists (MeshCollider)\n+- #11836 `d44535d` Rename rpcuser.py to rpcauth.py (hkjn)\n+- #11831 `d48ab83` Always return true if AppInitMain got to the end (TheBlueMatt)\n+- #11943 `1808660` contrib: fix typo in install_db4.sh help message (laanwj)\n+- #12075 `c991b30` [scripts] Add missing univalue file to copyright_header.py (fanquake)\n+- #12197 `000ac4f` Log debug build status and warn when running benchmarks (laanwj)\n+- #10672 `6ab0e4c` Avoid division by zero in the case of a corrupt estimates file (practicalswift)\n+- #11273 `cdd6bbf` Ignore old format estimation file (Xekyo)\n+- #11951 `1fb34e0` Remove dead feeest-file read code for old versions (TheBlueMatt)\n+- #11421 `9ccafb1` Merge current secp256k1 subtree (MarcoFalke)\n+- #11573 `2631d55` [Util] Update tinyformat.h (fanquake)\n+- #10529 `331352f` Improve bitcoind systemd service file (Flowdalic)\n+- #11620 `70fec9e` [build] .gitignore: add background.tiff (Sjors)\n+- #11558 `68e021e` Minimal code changes to allow msvc compilation (sipsorcery)\n+- #11284 `10bee0d` Fix invalid memory access in CScript::operator+= (guidovranken, ajtowns)\n+- #10939 `a1f7f18` [init] Check non-emptiness of -blocknotify command prior to executing (practicalswift)\n+- #11467 `937613d` Fix typos. Use nullptr instead of NULL (practicalswift)\n+- #11834 `5bea05b` [verify-commits] Fix gpg.sh's echoing for commits with '\\n' (TheBlueMatt)\n+- #11830 `a13e443` rpcuser.py: Use 'python' not 'python2' (hkjn)\n+- #12194 `7abb0f0` Add change type option to fundrawtransaction (promag)\n+- #12269 `2ae7cf8` Update defaultAssumeValid to block 506067 (gmaxwell)\n+- #11952 `9ab9963` univalue: Bump subtree (MarcoFalke)\n+- #12367 `09fc859` Fix two fast-shutdown bugs (TheBlueMatt)\n+- #12422 `4d54e7a` util: Make LockDirectory thread-safe, consistent, and fix OpenBSD 6.2 build (laanwj)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- 251\n+- Aaron Clauson\n+- Aaron Golliver\n+- aaron-hanson\n+- Adam Langley\n+- Akio Nakamura\n+- Akira Takizawa\n+- Alejandro Avil\u00e9s\n+- Alex Morcos\n+- Alin Rus\n+- Anditto Heristyo\n+- Andras Elso\n+- Andreas Schildbach\n+- Andrew Chow\n+- Anthony Towns\n+- azuchi\n+- Carl Dong\n+- Chris Moore\n+- Chris Stewart\n+- Christian Gentry\n+- Cory Fields\n+- Cristian Mircea Messel\n+- CryptAxe\n+- Dan Raviv\n+- Daniel Edgecumbe\n+- danra\n+- david60\n+- Donal O'Connor\n+- dongsamb\n+- Dusty Williams\n+- Eelis\n+- esneider\n+- Evan Klitzke\n+- fanquake\n+- Ferdinando M. Ametrano\n+- fivepiece\n+- flack\n+- Florian Schmaus\n+- gnuser\n+- Gregory Maxwell\n+- Gregory Sanders\n+- Henrik Jonsson\n+- Jack Grigg\n+- Jacky C\n+- James Evans\n+- James O'Beirne\n+- Jan Sarenik\n+- Jeff Rade\n+- Jeremiah Buddenhagen\n+- Jeremy Rubin\n+- Jim Posen\n+- jjz\n+- Joe Harvell\n+- Johannes Kanig\n+- John Newbery\n+- Johnson Lau\n+- Jonas Nick\n+- Jonas Schnelli\n+- Jo\u00e3o Barbosa\n+- Jorge Tim\u00f3n\n+- Karel B\u00edlek\n+- Karl-Johan Alm\n+- klemens\n+- Kyuntae Ethan Kim\n+- laudaa\n+- Lawrence Nahum\n+- Lucas Betschart\n+- Luke Dashjr\n+- Luke Mlsna\n+- MarcoFalke\n+- Mark Friedenbach\n+- Marko Bencun\n+- Martin Ankerl\n+- Matt Corallo\n+- mruddy\n+- Murch\n+- NicolasDorier\n+- Pablo Fernandez\n+- Paul Berg\n+- Pedro Branco\n+- Pierre Rochard\n+- Pieter Wuille\n+- practicalswift\n+- Randolf Richardson\n+- Russell Yanofsky\n+- Samuel Dobson\n+- Sean Erle Johnson\n+- Shooter\n+- Sjors Provoost\n+- Suhas Daftuar\n+- Thomas Snider\n+- Thoragh\n+- Tim Shimmin\n+- Tomas van der Wansem\n+- Utsav Gupta\n+- Varunram Ganesh\n+- Vivek Ganesan\n+- Werner Lemberg\n+- William Casarin\n+- Willy Ko\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/)."
      },
      {
        "sha": "a988c74ba545e516f2c9cfba1a8321a90111ce05",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -63,7 +63,7 @@ If you're using the automated script (found in [contrib/gitian-build.sh](/contri\n Setup Gitian descriptors:\n \n     pushd ./bitcoin\n-    export SIGNER=(your Gitian key, ie bluematt, sipa, etc)\n+    export SIGNER=\"(your Gitian key, ie bluematt, sipa, etc)\"\n     export VERSION=(new version, e.g. 0.8.0)\n     git fetch\n     git checkout v${VERSION}\n@@ -93,7 +93,9 @@ Create the OS X SDK tarball, see the [OS X readme](README_osx.md) for details, a\n \n ### Optional: Seed the Gitian sources cache and offline git repositories\n \n-By default, Gitian will fetch source files as needed. To cache them ahead of time:\n+NOTE: Gitian is sometimes unable to download files. If you have errors, try the step below.\n+\n+By default, Gitian will fetch source files as needed. To cache them ahead of time, make sure you have checked out the tag you want to build in bitcoin, then:\n \n     pushd ./gitian-builder\n     make -C ../bitcoin/depends download SOURCES_PATH=`pwd`/cache/common\n@@ -113,16 +115,16 @@ The gbuild invocations below <b>DO NOT DO THIS</b> by default.\n \n     pushd ./gitian-builder\n     ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n-    ./bin/gsign --signer $SIGNER --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n+    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n     mv build/out/bitcoin-*.tar.gz build/out/src/bitcoin-*.tar.gz ../\n \n     ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n-    ./bin/gsign --signer $SIGNER --release ${VERSION}-win-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n+    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-win-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n     mv build/out/bitcoin-*-win-unsigned.tar.gz inputs/bitcoin-win-unsigned.tar.gz\n     mv build/out/bitcoin-*.zip build/out/bitcoin-*.exe ../\n \n     ./bin/gbuild --num-make 2 --memory 3000 --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n-    ./bin/gsign --signer $SIGNER --release ${VERSION}-osx-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n+    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-osx-unsigned --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n     mv build/out/bitcoin-*-osx-unsigned.tar.gz inputs/bitcoin-osx-unsigned.tar.gz\n     mv build/out/bitcoin-*.tar.gz build/out/bitcoin-*.dmg ../\n     popd\n@@ -152,9 +154,9 @@ Verify the signatures\n Commit your signature to gitian.sigs:\n \n     pushd gitian.sigs\n-    git add ${VERSION}-linux/${SIGNER}\n-    git add ${VERSION}-win-unsigned/${SIGNER}\n-    git add ${VERSION}-osx-unsigned/${SIGNER}\n+    git add ${VERSION}-linux/\"${SIGNER}\"\n+    git add ${VERSION}-win-unsigned/\"${SIGNER}\"\n+    git add ${VERSION}-osx-unsigned/\"${SIGNER}\"\n     git commit -a\n     git push  # Assuming you can push to the gitian.sigs tree\n     popd\n@@ -199,7 +201,7 @@ Create (and optionally verify) the signed OS X binary:\n \n     pushd ./gitian-builder\n     ./bin/gbuild -i --commit signature=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n-    ./bin/gsign --signer $SIGNER --release ${VERSION}-osx-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n+    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-osx-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n     ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-osx-signed ../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml\n     mv build/out/bitcoin-osx-signed.dmg ../bitcoin-${VERSION}-osx.dmg\n     popd\n@@ -208,7 +210,7 @@ Create (and optionally verify) the signed Windows binaries:\n \n     pushd ./gitian-builder\n     ./bin/gbuild -i --commit signature=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n-    ./bin/gsign --signer $SIGNER --release ${VERSION}-win-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n+    ./bin/gsign --signer \"$SIGNER\" --release ${VERSION}-win-signed --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n     ./bin/gverify -v -d ../gitian.sigs/ -r ${VERSION}-win-signed ../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml\n     mv build/out/bitcoin-*win64-setup.exe ../bitcoin-${VERSION}-win64-setup.exe\n     mv build/out/bitcoin-*win32-setup.exe ../bitcoin-${VERSION}-win32-setup.exe\n@@ -217,8 +219,8 @@ Create (and optionally verify) the signed Windows binaries:\n Commit your signature for the signed OS X/Windows binaries:\n \n     pushd gitian.sigs\n-    git add ${VERSION}-osx-signed/${SIGNER}\n-    git add ${VERSION}-win-signed/${SIGNER}\n+    git add ${VERSION}-osx-signed/\"${SIGNER}\"\n+    git add ${VERSION}-win-signed/\"${SIGNER}\"\n     git commit -a\n     git push  # Assuming you can push to the gitian.sigs tree\n     popd"
      },
      {
        "sha": "5a9c59914e3fb302121a81d382477b8ed82ba4e2",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -52,7 +52,7 @@ The client it used to fetch updated translations. If you are having problems, or\n \n `pip install transifex-client`\n \n-Setup your transifex client config as follows. Please *ignore the token field*.\n+Setup your Transifex client config as follows. Please *ignore the token field*.\n \n ```ini\n nano ~/.transifexrc"
      },
      {
        "sha": "5d67df9d22117513c21580f7559d00517b3dcc82",
        "filename": "doc/zmq.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/doc/zmq.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/doc/zmq.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/zmq.md?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -101,6 +101,6 @@ and just the tip will be notified. It is up to the subscriber to\n retrieve the chain from the last known block to the new tip.\n \n There are several possibilities that ZMQ notification can get lost\n-during transmission depending on the communication type your are\n+during transmission depending on the communication type you are\n using. Bitcoind appends an up-counting sequence number to each\n notification which allows listeners to detect lost notifications."
      },
      {
        "sha": "e8f0820ca878b16551748d16020bb54022941ded",
        "filename": "share/qt/extract_strings_qt.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/share/qt/extract_strings_qt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/share/qt/extract_strings_qt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/extract_strings_qt.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,12 +1,11 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2012-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n Extract _(\"...\") strings for translation and convert to Qt stringdefs so that\n they can be picked up by Qt linguist.\n '''\n-from __future__ import division,print_function,unicode_literals\n from subprocess import Popen, PIPE\n import operator\n import os"
      },
      {
        "sha": "d6580281d40e38ee9e99cfcba76d29cf53a9df83",
        "filename": "share/rpcauth/rpcauth.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/share/rpcauth/rpcauth.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/share/rpcauth/rpcauth.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/rpcauth/rpcauth.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying \n # file COPYING or http://www.opensource.org/licenses/mit-license.php."
      },
      {
        "sha": "72e5cdb95db3f45d5b57f5b84795768a9a199be4",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,8 +4,8 @@\n \n DIST_SUBDIRS = secp256k1 univalue\n \n-AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS)\n-AM_CXXFLAGS = $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS)\n+AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS) $(GPROF_LDFLAGS) $(SANITIZER_LDFLAGS)\n+AM_CXXFLAGS = $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS) $(GPROF_CXXFLAGS) $(SANITIZER_CXXFLAGS)\n AM_CPPFLAGS = $(HARDENED_CPPFLAGS)\n EXTRA_LIBRARIES =\n \n@@ -105,6 +105,7 @@ BITCOIN_CORE_H = \\\n   indirectmap.h \\\n   init.h \\\n   key.h \\\n+  key_io.h \\\n   keystore.h \\\n   dbwrapper.h \\\n   limitedmap.h \\\n@@ -161,6 +162,7 @@ BITCOIN_CORE_H = \\\n   validation.h \\\n   validationinterface.h \\\n   versionbits.h \\\n+  walletinitinterface.h \\\n   wallet/coincontrol.h \\\n   wallet/crypter.h \\\n   wallet/db.h \\\n@@ -171,6 +173,7 @@ BITCOIN_CORE_H = \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n   wallet/walletutil.h \\\n+  wallet/coinselection.h \\\n   warnings.h \\\n   zmq/zmqabstractnotifier.h \\\n   zmq/zmqconfig.h\\\n@@ -252,6 +255,7 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/wallet.cpp \\\n   wallet/walletdb.cpp \\\n   wallet/walletutil.cpp \\\n+  wallet/coinselection.cpp \\\n   $(BITCOIN_CORE_H)\n \n # crypto primitives library\n@@ -327,6 +331,7 @@ libbitcoin_common_a_SOURCES = \\\n   core_read.cpp \\\n   core_write.cpp \\\n   key.cpp \\\n+  key_io.cpp \\\n   keystore.cpp \\\n   netaddress.cpp \\\n   netbase.cpp \\"
      },
      {
        "sha": "748c5b7887db6e903da020047c2db6e6a0256c9e",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -27,7 +27,7 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/lockedpool.cpp \\\n   bench/perf.cpp \\\n   bench/perf.h \\\n-  bench/prevector_destructor.cpp\n+  bench/prevector.cpp\n \n nodist_bench_bench_bitcoin_SOURCES = $(GENERATED_BENCH_FILES)\n "
      },
      {
        "sha": "4d0819ab796acf02527c17759d87f14d4467455f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,13 +9,13 @@ TEST_SRCDIR = test\n TEST_BINARY=test/test_bitcoin$(EXEEXT)\n \n JSON_TEST_FILES = \\\n-  test/data/script_tests.json \\\n-  test/data/base58_keys_valid.json \\\n   test/data/base58_encode_decode.json \\\n-  test/data/base58_keys_invalid.json \\\n+  test/data/key_io_valid.json \\\n+  test/data/key_io_invalid.json \\\n+  test/data/script_tests.json \\\n+  test/data/sighash.json \\\n   test/data/tx_invalid.json \\\n-  test/data/tx_valid.json \\\n-  test/data/sighash.json\n+  test/data/tx_valid.json\n \n RAW_TEST_FILES =\n \n@@ -45,6 +45,7 @@ BITCOIN_TESTS =\\\n   test/DoS_tests.cpp \\\n   test/getarg_tests.cpp \\\n   test/hash_tests.cpp \\\n+  test/key_io_tests.cpp \\\n   test/key_tests.cpp \\\n   test/limitedmap_tests.cpp \\\n   test/dbwrapper_tests.cpp \\\n@@ -93,7 +94,8 @@ BITCOIN_TESTS += \\\n   wallet/test/wallet_test_fixture.h \\\n   wallet/test/accounting_tests.cpp \\\n   wallet/test/wallet_tests.cpp \\\n-  wallet/test/crypto_tests.cpp\n+  wallet/test/crypto_tests.cpp \\\n+  wallet/test/coinselector_tests.cpp\n endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)"
      },
      {
        "sha": "e4620e63c6d4cf20cca21873b9ee956215ca1dc2",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -22,8 +22,8 @@ bool SerializeDB(Stream& stream, const Data& data)\n     // Write and commit header, data\n     try {\n         CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n-        stream << FLATDATA(Params().MessageStart()) << data;\n-        hasher << FLATDATA(Params().MessageStart()) << data;\n+        stream << Params().MessageStart() << data;\n+        hasher << Params().MessageStart() << data;\n         stream << hasher.GetHash();\n     } catch (const std::exception& e) {\n         return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n@@ -66,7 +66,7 @@ bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n         CHashVerifier<Stream> verifier(&stream);\n         // de-serialize file header (network specific magic number) and ..\n         unsigned char pchMsgTmp[4];\n-        verifier >> FLATDATA(pchMsgTmp);\n+        verifier >> pchMsgTmp;\n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n             return error(\"%s: Invalid network magic number\", __func__);"
      },
      {
        "sha": "e811dd4bea51e40211e430ff3ecd162803c40082",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 4,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -187,7 +187,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, int64_t nTime)\n+void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n {\n     int nId;\n \n@@ -233,10 +233,22 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     if (nUBucket == -1)\n         return;\n \n-    LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n+    // which tried bucket to move the entry to\n+    int tried_bucket = info.GetTriedBucket(nKey);\n+    int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);\n+\n+    // Will moving this address into tried evict another entry?\n+    if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {\n+        LogPrint(BCLog::ADDRMAN, \"Collision inserting element into tried table, moving %s to m_tried_collisions=%d\\n\", addr.ToString(), m_tried_collisions.size());\n+        if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {\n+            m_tried_collisions.insert(nId);\n+        }\n+    } else {\n+        LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n \n-    // move nId to the tried tables\n-    MakeTried(info, nId);\n+        // move nId to the tried tables\n+        MakeTried(info, nId);\n+    }\n }\n \n bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n@@ -521,3 +533,82 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n int CAddrMan::RandomInt(int nMax){\n     return GetRandInt(nMax);\n }\n+\n+void CAddrMan::ResolveCollisions_()\n+{\n+    for (std::set<int>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {\n+        int id_new = *it;\n+\n+        bool erase_collision = false;\n+\n+        // If id_new not found in mapInfo remove it from m_tried_collisions\n+        if (mapInfo.count(id_new) != 1) {\n+            erase_collision = true;\n+        } else {\n+            CAddrInfo& info_new = mapInfo[id_new];\n+\n+            // Which tried bucket to move the entry to.\n+            int tried_bucket = info_new.GetTriedBucket(nKey);\n+            int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);\n+            if (!info_new.IsValid()) { // id_new may no longer map to a valid address\n+                erase_collision = true;\n+            } else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty\n+\n+                // Get the to-be-evicted address that is being tested\n+                int id_old = vvTried[tried_bucket][tried_bucket_pos];\n+                CAddrInfo& info_old = mapInfo[id_old];\n+\n+                // Has successfully connected in last X hours\n+                if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n+                    erase_collision = true;\n+                } else if (GetAdjustedTime() - info_old.nLastTry < ADDRMAN_REPLACEMENT_HOURS*(60*60)) { // attempted to connect and failed in last X hours\n+\n+                    // Give address at least 60 seconds to successfully connect\n+                    if (GetAdjustedTime() - info_old.nLastTry > 60) {\n+                        LogPrint(BCLog::ADDRMAN, \"Swapping %s for %s in tried table\\n\", info_new.ToString(), info_old.ToString());\n+\n+                        // Replaces an existing address already in the tried table with the new address\n+                        Good_(info_new, false, GetAdjustedTime());\n+                        erase_collision = true;\n+                    }\n+                }\n+            } else { // Collision is not actually a collision anymore\n+                Good_(info_new, false, GetAdjustedTime());\n+                erase_collision = true;\n+            }\n+        }\n+\n+        if (erase_collision) {\n+            m_tried_collisions.erase(it++);\n+        } else {\n+            it++;\n+        }\n+    }\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision_()\n+{\n+    if (m_tried_collisions.size() == 0) return CAddrInfo();\n+\n+    std::set<int>::iterator it = m_tried_collisions.begin();\n+\n+    // Selects a random element from m_tried_collisions\n+    std::advance(it, GetRandInt(m_tried_collisions.size()));\n+    int id_new = *it;\n+\n+    // If id_new not found in mapInfo remove it from m_tried_collisions\n+    if (mapInfo.count(id_new) != 1) {\n+        m_tried_collisions.erase(it);\n+        return CAddrInfo();\n+    }\n+\n+    CAddrInfo& newInfo = mapInfo[id_new];\n+\n+    // which tried bucket to move the entry to\n+    int tried_bucket = newInfo.GetTriedBucket(nKey);\n+    int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n+\n+    int id_old = vvTried[tried_bucket][tried_bucket_pos];\n+\n+    return mapInfo[id_old];\n+}"
      },
      {
        "sha": "6dec3fe416bb97c9e6785a9a214e9e9398e77548",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 40,
        "deletions": 3,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -165,6 +165,9 @@ class CAddrInfo : public CAddress\n //! ... in at least this many days\n #define ADDRMAN_MIN_FAIL_DAYS 7\n \n+//! how recent a successful connection should be before we allow an address to be evicted from tried\n+#define ADDRMAN_REPLACEMENT_HOURS 4\n+\n //! the maximum percentage of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX_PCT 23\n \n@@ -176,6 +179,9 @@ class CAddrInfo : public CAddress\n #define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n #define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n \n+//! the maximum number of tried addr collisions to store\n+#define ADDRMAN_SET_TRIED_COLLISION_SIZE 10\n+\n /** \n  * Stochastical (IP) address manager \n  */\n@@ -212,6 +218,9 @@ class CAddrMan\n     //! last time Good was called (memory only)\n     int64_t nLastGood;\n \n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n protected:\n     //! secret key to randomize bucket select with\n     uint256 nKey;\n@@ -239,7 +248,7 @@ class CAddrMan\n     void ClearNew(int nUBucket, int nUBucketPos);\n \n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, int64_t nTime);\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time);\n \n     //! Add an entry to the \"new\" table.\n     bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty);\n@@ -250,6 +259,12 @@ class CAddrMan\n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     CAddrInfo Select_(bool newOnly);\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_();\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_();\n+\n     //! Wraps GetRandInt to allow tests to override RandomInt and make it determinismistic.\n     virtual int RandomInt(int nMax);\n \n@@ -537,11 +552,11 @@ class CAddrMan\n     }\n \n     //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n+    void Good(const CService &addr, bool test_before_evict = true, int64_t nTime = GetAdjustedTime())\n     {\n         LOCK(cs);\n         Check();\n-        Good_(addr, nTime);\n+        Good_(addr, test_before_evict, nTime);\n         Check();\n     }\n \n@@ -554,6 +569,28 @@ class CAddrMan\n         Check();\n     }\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions()\n+    {\n+        LOCK(cs);\n+        Check();\n+        ResolveCollisions_();\n+        Check();\n+    }\n+\n+    //! Randomly select an address in tried that another address is attempting to evict.\n+    CAddrInfo SelectTriedCollision()\n+    {\n+        CAddrInfo ret;\n+        {\n+            LOCK(cs);\n+            Check();\n+            ret = SelectTriedCollision_();\n+            Check();\n+        }\n+        return ret;\n+    }\n+\n     /**\n      * Choose an address to connect to.\n      */"
      },
      {
        "sha": "3f4cc8c2bf77ea1de8ffa2ce8756ac4a14e624a5",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -85,7 +85,7 @@ class base_uint\n         base_uint ret;\n         for (int i = 0; i < WIDTH; i++)\n             ret.pn[i] = ~pn[i];\n-        ret++;\n+        ++ret;\n         return ret;\n     }\n "
      },
      {
        "sha": "feec2d4e052d3098c76026495388bc0dd57ff48c",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 236,
        "changes": 257,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,22 +4,32 @@\n \n #include <base58.h>\n \n-#include <bech32.h>\n #include <hash.h>\n-#include <script/script.h>\n #include <uint256.h>\n-#include <utilstrencodings.h>\n \n-#include <boost/variant/apply_visitor.hpp>\n-#include <boost/variant/static_visitor.hpp>\n-\n-#include <algorithm>\n #include <assert.h>\n #include <string.h>\n \n-\n /** All alphanumeric characters except for \"0\", \"I\", \"O\", and \"l\" */\n static const char* pszBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n+static const int8_t mapBase58[256] = {\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1, 0, 1, 2, 3, 4, 5, 6,  7, 8,-1,-1,-1,-1,-1,-1,\n+    -1, 9,10,11,12,13,14,15, 16,-1,17,18,19,20,21,-1,\n+    22,23,24,25,26,27,28,29, 30,31,32,-1,-1,-1,-1,-1,\n+    -1,33,34,35,36,37,38,39, 40,41,42,43,-1,44,45,46,\n+    47,48,49,50,51,52,53,54, 55,56,57,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+    -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n+};\n \n bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n {\n@@ -37,13 +47,12 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n     int size = strlen(psz) * 733 /1000 + 1; // log(58) / log(256), rounded up.\n     std::vector<unsigned char> b256(size);\n     // Process the characters.\n+    static_assert(sizeof(mapBase58)/sizeof(mapBase58[0]) == 256, \"mapBase58.size() should be 256\"); // guarantee not out of range\n     while (*psz && !isspace(*psz)) {\n         // Decode base58 character\n-        const char* ch = strchr(pszBase58, *psz);\n-        if (ch == nullptr)\n+        int carry = mapBase58[(uint8_t)*psz];\n+        if (carry == -1)  // Invalid b58 character\n             return false;\n-        // Apply \"b256 = b256 * 58 + ch\".\n-        int carry = ch - pszBase58;\n         int i = 0;\n         for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); (carry != 0 || i < length) && (it != b256.rend()); ++it, ++i) {\n             carry += 58 * (*it);\n@@ -151,227 +160,3 @@ bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRe\n {\n     return DecodeBase58Check(str.c_str(), vchRet);\n }\n-\n-CBase58Data::CBase58Data()\n-{\n-    vchVersion.clear();\n-    vchData.clear();\n-}\n-\n-void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const void* pdata, size_t nSize)\n-{\n-    vchVersion = vchVersionIn;\n-    vchData.resize(nSize);\n-    if (!vchData.empty())\n-        memcpy(vchData.data(), pdata, nSize);\n-}\n-\n-void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const unsigned char* pbegin, const unsigned char* pend)\n-{\n-    SetData(vchVersionIn, (void*)pbegin, pend - pbegin);\n-}\n-\n-bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)\n-{\n-    std::vector<unsigned char> vchTemp;\n-    bool rc58 = DecodeBase58Check(psz, vchTemp);\n-    if ((!rc58) || (vchTemp.size() < nVersionBytes)) {\n-        vchData.clear();\n-        vchVersion.clear();\n-        return false;\n-    }\n-    vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);\n-    vchData.resize(vchTemp.size() - nVersionBytes);\n-    if (!vchData.empty())\n-        memcpy(vchData.data(), vchTemp.data() + nVersionBytes, vchData.size());\n-    memory_cleanse(vchTemp.data(), vchTemp.size());\n-    return true;\n-}\n-\n-bool CBase58Data::SetString(const std::string& str)\n-{\n-    return SetString(str.c_str());\n-}\n-\n-std::string CBase58Data::ToString() const\n-{\n-    std::vector<unsigned char> vch = vchVersion;\n-    vch.insert(vch.end(), vchData.begin(), vchData.end());\n-    return EncodeBase58Check(vch);\n-}\n-\n-int CBase58Data::CompareTo(const CBase58Data& b58) const\n-{\n-    if (vchVersion < b58.vchVersion)\n-        return -1;\n-    if (vchVersion > b58.vchVersion)\n-        return 1;\n-    if (vchData < b58.vchData)\n-        return -1;\n-    if (vchData > b58.vchData)\n-        return 1;\n-    return 0;\n-}\n-\n-namespace\n-{\n-class DestinationEncoder : public boost::static_visitor<std::string>\n-{\n-private:\n-    const CChainParams& m_params;\n-\n-public:\n-    DestinationEncoder(const CChainParams& params) : m_params(params) {}\n-\n-    std::string operator()(const CKeyID& id) const\n-    {\n-        std::vector<unsigned char> data = m_params.Base58Prefix(CChainParams::PUBKEY_ADDRESS);\n-        data.insert(data.end(), id.begin(), id.end());\n-        return EncodeBase58Check(data);\n-    }\n-\n-    std::string operator()(const CScriptID& id) const\n-    {\n-        std::vector<unsigned char> data = m_params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n-        data.insert(data.end(), id.begin(), id.end());\n-        return EncodeBase58Check(data);\n-    }\n-\n-    std::string operator()(const WitnessV0KeyHash& id) const\n-    {\n-        std::vector<unsigned char> data = {0};\n-        ConvertBits<8, 5, true>(data, id.begin(), id.end());\n-        return bech32::Encode(m_params.Bech32HRP(), data);\n-    }\n-\n-    std::string operator()(const WitnessV0ScriptHash& id) const\n-    {\n-        std::vector<unsigned char> data = {0};\n-        ConvertBits<8, 5, true>(data, id.begin(), id.end());\n-        return bech32::Encode(m_params.Bech32HRP(), data);\n-    }\n-\n-    std::string operator()(const WitnessUnknown& id) const\n-    {\n-        if (id.version < 1 || id.version > 16 || id.length < 2 || id.length > 40) {\n-            return {};\n-        }\n-        std::vector<unsigned char> data = {(unsigned char)id.version};\n-        ConvertBits<8, 5, true>(data, id.program, id.program + id.length);\n-        return bech32::Encode(m_params.Bech32HRP(), data);\n-    }\n-\n-    std::string operator()(const CNoDestination& no) const { return {}; }\n-};\n-\n-CTxDestination DecodeDestination(const std::string& str, const CChainParams& params)\n-{\n-    std::vector<unsigned char> data;\n-    uint160 hash;\n-    if (DecodeBase58Check(str, data)) {\n-        // base58-encoded Bitcoin addresses.\n-        // Public-key-hash-addresses have version 0 (or 111 testnet).\n-        // The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key.\n-        const std::vector<unsigned char>& pubkey_prefix = params.Base58Prefix(CChainParams::PUBKEY_ADDRESS);\n-        if (data.size() == hash.size() + pubkey_prefix.size() && std::equal(pubkey_prefix.begin(), pubkey_prefix.end(), data.begin())) {\n-            std::copy(data.begin() + pubkey_prefix.size(), data.end(), hash.begin());\n-            return CKeyID(hash);\n-        }\n-        // Script-hash-addresses have version 5 (or 196 testnet).\n-        // The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.\n-        const std::vector<unsigned char>& script_prefix = params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n-        if (data.size() == hash.size() + script_prefix.size() && std::equal(script_prefix.begin(), script_prefix.end(), data.begin())) {\n-            std::copy(data.begin() + script_prefix.size(), data.end(), hash.begin());\n-            return CScriptID(hash);\n-        }\n-    }\n-    data.clear();\n-    auto bech = bech32::Decode(str);\n-    if (bech.second.size() > 0 && bech.first == params.Bech32HRP()) {\n-        // Bech32 decoding\n-        int version = bech.second[0]; // The first 5 bit symbol is the witness version (0-16)\n-        // The rest of the symbols are converted witness program bytes.\n-        if (ConvertBits<5, 8, false>(data, bech.second.begin() + 1, bech.second.end())) {\n-            if (version == 0) {\n-                {\n-                    WitnessV0KeyHash keyid;\n-                    if (data.size() == keyid.size()) {\n-                        std::copy(data.begin(), data.end(), keyid.begin());\n-                        return keyid;\n-                    }\n-                }\n-                {\n-                    WitnessV0ScriptHash scriptid;\n-                    if (data.size() == scriptid.size()) {\n-                        std::copy(data.begin(), data.end(), scriptid.begin());\n-                        return scriptid;\n-                    }\n-                }\n-                return CNoDestination();\n-            }\n-            if (version > 16 || data.size() < 2 || data.size() > 40) {\n-                return CNoDestination();\n-            }\n-            WitnessUnknown unk;\n-            unk.version = version;\n-            std::copy(data.begin(), data.end(), unk.program);\n-            unk.length = data.size();\n-            return unk;\n-        }\n-    }\n-    return CNoDestination();\n-}\n-} // namespace\n-\n-void CBitcoinSecret::SetKey(const CKey& vchSecret)\n-{\n-    assert(vchSecret.IsValid());\n-    SetData(Params().Base58Prefix(CChainParams::SECRET_KEY), vchSecret.begin(), vchSecret.size());\n-    if (vchSecret.IsCompressed())\n-        vchData.push_back(1);\n-}\n-\n-CKey CBitcoinSecret::GetKey()\n-{\n-    CKey ret;\n-    assert(vchData.size() >= 32);\n-    ret.Set(vchData.begin(), vchData.begin() + 32, vchData.size() > 32 && vchData[32] == 1);\n-    return ret;\n-}\n-\n-bool CBitcoinSecret::IsValid() const\n-{\n-    bool fExpectedFormat = vchData.size() == 32 || (vchData.size() == 33 && vchData[32] == 1);\n-    bool fCorrectVersion = vchVersion == Params().Base58Prefix(CChainParams::SECRET_KEY);\n-    return fExpectedFormat && fCorrectVersion;\n-}\n-\n-bool CBitcoinSecret::SetString(const char* pszSecret)\n-{\n-    return CBase58Data::SetString(pszSecret) && IsValid();\n-}\n-\n-bool CBitcoinSecret::SetString(const std::string& strSecret)\n-{\n-    return SetString(strSecret.c_str());\n-}\n-\n-std::string EncodeDestination(const CTxDestination& dest)\n-{\n-    return boost::apply_visitor(DestinationEncoder(Params()), dest);\n-}\n-\n-CTxDestination DecodeDestination(const std::string& str)\n-{\n-    return DecodeDestination(str, Params());\n-}\n-\n-bool IsValidDestinationString(const std::string& str, const CChainParams& params)\n-{\n-    return IsValidDestination(DecodeDestination(str, params));\n-}\n-\n-bool IsValidDestinationString(const std::string& str)\n-{\n-    return IsValidDestinationString(str, Params());\n-}"
      },
      {
        "sha": "8f2833bec9a944d2fe44b88c3a7b43dd59ab8169",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 2,
        "deletions": 91,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -14,12 +14,6 @@\n #ifndef BITCOIN_BASE58_H\n #define BITCOIN_BASE58_H\n \n-#include <chainparams.h>\n-#include <key.h>\n-#include <pubkey.h>\n-#include <script/standard.h>\n-#include <support/allocators/zeroafterfree.h>\n-\n #include <string>\n #include <vector>\n \n@@ -56,95 +50,12 @@ std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn);\n  * Decode a base58-encoded string (psz) that includes a checksum into a byte\n  * vector (vchRet), return true if decoding is successful\n  */\n-inline bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet);\n+bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet);\n \n /**\n  * Decode a base58-encoded string (str) that includes a checksum into a byte\n  * vector (vchRet), return true if decoding is successful\n  */\n-inline bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet);\n-\n-/**\n- * Base class for all base58-encoded data\n- */\n-class CBase58Data\n-{\n-protected:\n-    //! the version byte(s)\n-    std::vector<unsigned char> vchVersion;\n-\n-    //! the actually encoded data\n-    typedef std::vector<unsigned char, zero_after_free_allocator<unsigned char> > vector_uchar;\n-    vector_uchar vchData;\n-\n-    CBase58Data();\n-    void SetData(const std::vector<unsigned char> &vchVersionIn, const void* pdata, size_t nSize);\n-    void SetData(const std::vector<unsigned char> &vchVersionIn, const unsigned char *pbegin, const unsigned char *pend);\n-\n-public:\n-    bool SetString(const char* psz, unsigned int nVersionBytes = 1);\n-    bool SetString(const std::string& str);\n-    std::string ToString() const;\n-    int CompareTo(const CBase58Data& b58) const;\n-\n-    bool operator==(const CBase58Data& b58) const { return CompareTo(b58) == 0; }\n-    bool operator<=(const CBase58Data& b58) const { return CompareTo(b58) <= 0; }\n-    bool operator>=(const CBase58Data& b58) const { return CompareTo(b58) >= 0; }\n-    bool operator< (const CBase58Data& b58) const { return CompareTo(b58) <  0; }\n-    bool operator> (const CBase58Data& b58) const { return CompareTo(b58) >  0; }\n-};\n-\n-/**\n- * A base58-encoded secret key\n- */\n-class CBitcoinSecret : public CBase58Data\n-{\n-public:\n-    void SetKey(const CKey& vchSecret);\n-    CKey GetKey();\n-    bool IsValid() const;\n-    bool SetString(const char* pszSecret);\n-    bool SetString(const std::string& strSecret);\n-\n-    CBitcoinSecret(const CKey& vchSecret) { SetKey(vchSecret); }\n-    CBitcoinSecret() {}\n-};\n-\n-template<typename K, int Size, CChainParams::Base58Type Type> class CBitcoinExtKeyBase : public CBase58Data\n-{\n-public:\n-    void SetKey(const K &key) {\n-        unsigned char vch[Size];\n-        key.Encode(vch);\n-        SetData(Params().Base58Prefix(Type), vch, vch+Size);\n-    }\n-\n-    K GetKey() {\n-        K ret;\n-        if (vchData.size() == Size) {\n-            // If base58 encoded data does not hold an ext key, return a !IsValid() key\n-            ret.Decode(vchData.data());\n-        }\n-        return ret;\n-    }\n-\n-    CBitcoinExtKeyBase(const K &key) {\n-        SetKey(key);\n-    }\n-\n-    CBitcoinExtKeyBase(const std::string& strBase58c) {\n-        SetString(strBase58c.c_str(), Params().Base58Prefix(Type).size());\n-    }\n-\n-    CBitcoinExtKeyBase() {}\n-};\n-\n-typedef CBitcoinExtKeyBase<CExtKey, BIP32_EXTKEY_SIZE, CChainParams::EXT_SECRET_KEY> CBitcoinExtKey;\n-typedef CBitcoinExtKeyBase<CExtPubKey, BIP32_EXTKEY_SIZE, CChainParams::EXT_PUBLIC_KEY> CBitcoinExtPubKey;\n-\n-std::string EncodeDestination(const CTxDestination& dest);\n-CTxDestination DecodeDestination(const std::string& str);\n-bool IsValidDestinationString(const std::string& str);\n-bool IsValidDestinationString(const std::string& str, const CChainParams& params);\n+bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet);\n \n #endif // BITCOIN_BASE58_H"
      },
      {
        "sha": "4b2a0e72fe8b06acce3b9931a4493a91b411d902",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 2,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <bench/bench.h>\n #include <wallet/wallet.h>\n+#include <wallet/coinselection.h>\n \n #include <set>\n \n@@ -32,7 +33,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<CO\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n static void CoinSelection(benchmark::State& state)\n {\n-    const CWallet wallet;\n+    const CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n     std::vector<COutput> vCoins;\n     LOCK(wallet.cs_wallet);\n \n@@ -44,7 +45,11 @@ static void CoinSelection(benchmark::State& state)\n \n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, 0, vCoins, setCoinsRet, nValueRet);\n+        bool bnb_used;\n+        CoinEligibilityFilter filter_standard(1, 6, 0);\n+        CoinSelectionParams coin_selection_params(false, 34, 148, CFeeRate(0), 0);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)\n+                       || wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n@@ -57,4 +62,47 @@ static void CoinSelection(benchmark::State& state)\n     }\n }\n \n+typedef std::set<CInputCoin> CoinSet;\n+\n+// Copied from src/wallet/test/coinselector_tests.cpp\n+static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n+{\n+    CMutableTransaction tx;\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    set.emplace_back(MakeTransactionRef(tx), nInput);\n+}\n+// Copied from src/wallet/test/coinselector_tests.cpp\n+static CAmount make_hard_case(int utxos, std::vector<CInputCoin>& utxo_pool)\n+{\n+    utxo_pool.clear();\n+    CAmount target = 0;\n+    for (int i = 0; i < utxos; ++i) {\n+        target += (CAmount)1 << (utxos+i);\n+        add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n+        add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n+    }\n+    return target;\n+}\n+\n+static void BnBExhaustion(benchmark::State& state)\n+{\n+    // Setup\n+    std::vector<CInputCoin> utxo_pool;\n+    CoinSet selection;\n+    CAmount value_ret = 0;\n+    CAmount not_input_fees = 0;\n+\n+    while (state.KeepRunning()) {\n+        // Benchmark\n+        CAmount target = make_hard_case(17, utxo_pool);\n+        SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees); // Should exhaust\n+\n+        // Cleanup\n+        utxo_pool.clear();\n+        selection.clear();\n+    }\n+}\n+\n BENCHMARK(CoinSelection, 650);\n+BENCHMARK(BnBExhaustion, 650);"
      },
      {
        "sha": "55a00318c1bc59e7cb92c76776d0a70797f056ff",
        "filename": "src/bench/lockedpool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -43,4 +43,4 @@ static void BenchLockedPool(benchmark::State& state)\n     addr.clear();\n }\n \n-BENCHMARK(BenchLockedPool, 530);\n+BENCHMARK(BenchLockedPool, 1300);"
      },
      {
        "sha": "d0f28d1a3e4fb96361e5f50db6315c05fafacf5e",
        "filename": "src/bench/prevector.cpp",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,77 @@\n+// Copyright (c) 2015-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compat.h>\n+#include <prevector.h>\n+\n+#include <bench/bench.h>\n+\n+struct nontrivial_t {\n+    int x;\n+    nontrivial_t() :x(-1) {}\n+};\n+static_assert(!IS_TRIVIALLY_CONSTRUCTIBLE<nontrivial_t>::value,\n+              \"expected nontrivial_t to not be trivially constructible\");\n+\n+typedef unsigned char trivial_t;\n+static_assert(IS_TRIVIALLY_CONSTRUCTIBLE<trivial_t>::value,\n+              \"expected trivial_t to be trivially constructible\");\n+\n+template <typename T>\n+static void PrevectorDestructor(benchmark::State& state)\n+{\n+    while (state.KeepRunning()) {\n+        for (auto x = 0; x < 1000; ++x) {\n+            prevector<28, T> t0;\n+            prevector<28, T> t1;\n+            t0.resize(28);\n+            t1.resize(29);\n+        }\n+    }\n+}\n+\n+template <typename T>\n+static void PrevectorClear(benchmark::State& state)\n+{\n+\n+    while (state.KeepRunning()) {\n+        for (auto x = 0; x < 1000; ++x) {\n+            prevector<28, T> t0;\n+            prevector<28, T> t1;\n+            t0.resize(28);\n+            t0.clear();\n+            t1.resize(29);\n+            t0.clear();\n+        }\n+    }\n+}\n+\n+template <typename T>\n+void PrevectorResize(benchmark::State& state)\n+{\n+    while (state.KeepRunning()) {\n+        prevector<28, T> t0;\n+        prevector<28, T> t1;\n+        for (auto x = 0; x < 1000; ++x) {\n+            t0.resize(28);\n+            t0.resize(0);\n+            t1.resize(29);\n+            t1.resize(0);\n+        }\n+    }\n+}\n+\n+#define PREVECTOR_TEST(name, nontrivops, trivops)                       \\\n+    static void Prevector ## name ## Nontrivial(benchmark::State& state) { \\\n+        PrevectorResize<nontrivial_t>(state);                           \\\n+    }                                                                   \\\n+    BENCHMARK(Prevector ## name ## Nontrivial, nontrivops);             \\\n+    static void Prevector ## name ## Trivial(benchmark::State& state) { \\\n+        PrevectorResize<trivial_t>(state);                              \\\n+    }                                                                   \\\n+    BENCHMARK(Prevector ## name ## Trivial, trivops);\n+\n+PREVECTOR_TEST(Clear, 28300, 88600)\n+PREVECTOR_TEST(Destructor, 28800, 88900)\n+PREVECTOR_TEST(Resize, 28900, 90300)"
      },
      {
        "sha": "39d0ee5eb194a214aeda584bd4a150156a78bce6",
        "filename": "src/bench/prevector_destructor.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 36,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07090c5339436f856e79a8036d1c85deeb453803/src/bench/prevector_destructor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07090c5339436f856e79a8036d1c85deeb453803/src/bench/prevector_destructor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector_destructor.cpp?ref=07090c5339436f856e79a8036d1c85deeb453803",
        "patch": "@@ -1,36 +0,0 @@\n-// Copyright (c) 2015-2017 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <bench/bench.h>\n-#include <prevector.h>\n-\n-static void PrevectorDestructor(benchmark::State& state)\n-{\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n-            prevector<28, unsigned char> t0;\n-            prevector<28, unsigned char> t1;\n-            t0.resize(28);\n-            t1.resize(29);\n-        }\n-    }\n-}\n-\n-static void PrevectorClear(benchmark::State& state)\n-{\n-\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n-            prevector<28, unsigned char> t0;\n-            prevector<28, unsigned char> t1;\n-            t0.resize(28);\n-            t0.clear();\n-            t1.resize(29);\n-            t0.clear();\n-        }\n-    }\n-}\n-\n-BENCHMARK(PrevectorDestructor, 5700);\n-BENCHMARK(PrevectorClear, 5600);"
      },
      {
        "sha": "705fa368a5072721f32a57d4aa3f21492bdc99dc",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -75,7 +75,7 @@ static void VerifyScriptBench(benchmark::State& state)\n     CMutableTransaction txSpend = BuildSpendingTransaction(scriptSig, txCredit);\n     CScriptWitness& witness = txSpend.vin[0].scriptWitness;\n     witness.stack.emplace_back();\n-    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SIGVERSION_WITNESS_V0), witness.stack.back(), 0);\n+    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SigVersion::WITNESS_V0), witness.stack.back(), 0);\n     witness.stack.back().push_back(static_cast<unsigned char>(SIGHASH_ALL));\n     witness.stack.push_back(ToByteVector(pubkey));\n "
      },
      {
        "sha": "8bdc2109976888285e6edf1b8caf4b0219e42ebe",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -46,7 +46,7 @@ std::string HelpMessageCli()\n     strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n-    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (argument is wallet filename in bitcoind directory, required if bitcoind/-Qt runs with multiple wallets)\"));\n+    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind)\"));\n     strUsage += HelpMessageOpt(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases).  When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\"));\n     strUsage += HelpMessageOpt(\"-stdinrpcpass\", strprintf(_(\"Read RPC password from standard input as a single line.  When combined with -stdin, the first line from standard input is used for the RPC password.\")));\n \n@@ -313,13 +313,11 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n \n     // Get credentials\n     std::string strRPCUserColonPass;\n+    bool failedToGetAuthCookie = false;\n     if (gArgs.GetArg(\"-rpcpassword\", \"\") == \"\") {\n         // Try fall back to cookie-based authentication if no password is provided\n         if (!GetAuthCookie(&strRPCUserColonPass)) {\n-            throw std::runtime_error(strprintf(\n-                _(\"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)\"),\n-                    GetConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string().c_str()));\n-\n+            failedToGetAuthCookie = true;\n         }\n     } else {\n         strRPCUserColonPass = gArgs.GetArg(\"-rpcuser\", \"\") + \":\" + gArgs.GetArg(\"-rpcpassword\", \"\");\n@@ -339,8 +337,8 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n \n     // check if we should use a special wallet endpoint\n     std::string endpoint = \"/\";\n-    std::string walletName = gArgs.GetArg(\"-rpcwallet\", \"\");\n-    if (!walletName.empty()) {\n+    if (!gArgs.GetArgs(\"-rpcwallet\").empty()) {\n+        std::string walletName = gArgs.GetArg(\"-rpcwallet\", \"\");\n         char *encodedURI = evhttp_uriencode(walletName.c_str(), walletName.size(), false);\n         if (encodedURI) {\n             endpoint = \"/wallet/\"+ std::string(encodedURI);\n@@ -358,11 +356,21 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n \n     event_base_dispatch(base.get());\n \n-    if (response.status == 0)\n-        throw CConnectionFailed(strprintf(\"couldn't connect to server: %s (code %d)\\n(make sure server is running and you are connecting to the correct RPC port)\", http_errorstring(response.error), response.error));\n-    else if (response.status == HTTP_UNAUTHORIZED)\n-        throw std::runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n-    else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n+    if (response.status == 0) {\n+        std::string responseErrorMessage;\n+        if (response.error != -1) {\n+            responseErrorMessage = strprintf(\" (error code %d - \\\"%s\\\")\", response.error, http_errorstring(response.error));\n+        }\n+        throw CConnectionFailed(strprintf(\"Could not connect to the server %s:%d%s\\n\\nMake sure the bitcoind server is running and that you are connecting to the correct RPC port.\", host, port, responseErrorMessage));\n+    } else if (response.status == HTTP_UNAUTHORIZED) {\n+        if (failedToGetAuthCookie) {\n+            throw std::runtime_error(strprintf(\n+                _(\"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)\"),\n+                GetConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string().c_str()));\n+        } else {\n+            throw std::runtime_error(\"Authorization failed: Incorrect rpcuser or rpcpassword\");\n+        }\n+    } else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n         throw std::runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\n     else if (response.body.empty())\n         throw std::runtime_error(\"no response from server\");"
      },
      {
        "sha": "8218e883a6f1da98c99badad2e450e55b7f4c9a8",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 16,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -6,11 +6,11 @@\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <base58.h>\n #include <clientversion.h>\n #include <coins.h>\n #include <consensus/consensus.h>\n #include <core_io.h>\n+#include <key_io.h>\n #include <keystore.h>\n #include <policy/policy.h>\n #include <policy/rbf.h>\n@@ -551,7 +551,6 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     // mergedTx will end up with all the signatures; it\n     // starts as a clone of the raw tx:\n     CMutableTransaction mergedTx(txVariants[0]);\n-    bool fComplete = true;\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n \n@@ -563,12 +562,10 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     for (unsigned int kidx = 0; kidx < keysObj.size(); kidx++) {\n         if (!keysObj[kidx].isStr())\n             throw std::runtime_error(\"privatekey not a std::string\");\n-        CBitcoinSecret vchSecret;\n-        bool fGood = vchSecret.SetString(keysObj[kidx].getValStr());\n-        if (!fGood)\n+        CKey key = DecodeSecret(keysObj[kidx].getValStr());\n+        if (!key.IsValid()) {\n             throw std::runtime_error(\"privatekey not valid\");\n-\n-        CKey key = vchSecret.GetKey();\n+        }\n         tempKeystore.AddKey(key);\n     }\n \n@@ -639,7 +636,6 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n         CTxIn& txin = mergedTx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n         if (coin.IsSpent()) {\n-            fComplete = false;\n             continue;\n         }\n         const CScript& prevPubKey = coin.out.scriptPubKey;\n@@ -654,14 +650,6 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n         for (const CTransaction& txv : txVariants)\n             sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n         UpdateTransaction(mergedTx, i, sigdata);\n-\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i, amount)))\n-            fComplete = false;\n-    }\n-\n-    if (fComplete) {\n-        // do nothing... for now\n-        // perhaps store this for later optional JSON output\n     }\n \n     tx = mergedTx;"
      },
      {
        "sha": "df7fad89c2607c2140819b26aa73654d3fcdc1f5",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -18,6 +18,10 @@\n #include <httpserver.h>\n #include <httprpc.h>\n #include <utilstrencodings.h>\n+#if ENABLE_WALLET\n+#include <wallet/init.h>\n+#endif\n+#include <walletinitinterface.h>\n \n #include <boost/thread.hpp>\n \n@@ -59,6 +63,12 @@ bool AppInit(int argc, char* argv[])\n {\n     bool fRet = false;\n \n+#if ENABLE_WALLET\n+    g_wallet_init_interface.reset(new WalletInit);\n+#else\n+    g_wallet_init_interface.reset(new DummyWalletInit);\n+#endif\n+\n     //\n     // Parameters\n     //\n@@ -79,7 +89,7 @@ bool AppInit(int argc, char* argv[])\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n                   \"  bitcoind [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n+            strUsage += \"\\n\" + HelpMessage(HelpMessageMode::BITCOIND);\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());"
      },
      {
        "sha": "f80821aa65be1772c70f3e9cd5801b5aea0ac056",
        "filename": "src/blockencodings.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -90,11 +90,11 @@ class BlockTransactions {\n             while (txn.size() < txn_size) {\n                 txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n                 for (; i < txn.size(); i++)\n-                    READWRITE(REF(TransactionCompressor(txn[i])));\n+                    READWRITE(TransactionCompressor(txn[i]));\n             }\n         } else {\n             for (size_t i = 0; i < txn.size(); i++)\n-                READWRITE(REF(TransactionCompressor(txn[i])));\n+                READWRITE(TransactionCompressor(txn[i]));\n         }\n     }\n };\n@@ -115,7 +115,7 @@ struct PrefilledTransaction {\n         if (idx > std::numeric_limits<uint16_t>::max())\n             throw std::ios_base::failure(\"index overflowed 16-bits\");\n         index = idx;\n-        READWRITE(REF(TransactionCompressor(tx)));\n+        READWRITE(TransactionCompressor(tx));\n     }\n };\n "
      },
      {
        "sha": "757840bb236a0acdfedc7180b844a3a8d137a553",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -91,7 +91,7 @@ struct CDiskBlockPos\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(VARINT(nFile));\n+        READWRITE(VARINT(nFile, VarIntMode::NONNEGATIVE_SIGNED));\n         READWRITE(VARINT(nPos));\n     }\n \n@@ -386,13 +386,13 @@ class CDiskBlockIndex : public CBlockIndex\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         int _nVersion = s.GetVersion();\n         if (!(s.GetType() & SER_GETHASH))\n-            READWRITE(VARINT(_nVersion));\n+            READWRITE(VARINT(_nVersion, VarIntMode::NONNEGATIVE_SIGNED));\n \n-        READWRITE(VARINT(nHeight));\n+        READWRITE(VARINT(nHeight, VarIntMode::NONNEGATIVE_SIGNED));\n         READWRITE(VARINT(nStatus));\n         READWRITE(VARINT(nTx));\n         if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n-            READWRITE(VARINT(nFile));\n+            READWRITE(VARINT(nFile, VarIntMode::NONNEGATIVE_SIGNED));\n         if (nStatus & BLOCK_HAVE_DATA)\n             READWRITE(VARINT(nDataPos));\n         if (nStatus & BLOCK_HAVE_UNDO)"
      },
      {
        "sha": "6067503b0b93c134d4459a92a31e4d318611cf60",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -135,6 +135,7 @@ class CMainParams : public CChainParams {\n         vSeeds.emplace_back(\"seed.bitcoinstats.com\"); // Christian Decker, supports x1 - xf\n         vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\"); // Jonas Schnelli, only supports x1, x5, x9, and xd\n         vSeeds.emplace_back(\"seed.btc.petertodd.org\"); // Peter Todd, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.bitcoin.sprovoost.nl\"); // Sjors Provoost\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n@@ -175,6 +176,9 @@ class CMainParams : public CChainParams {\n                         //   (the tx=... number in the SetBestChain debug.log lines)\n             3.5         // * estimated number of transactions per second after that timestamp\n         };\n+\n+        /* disable fallback fee on mainnet */\n+        m_fallback_fee_enabled = false;\n     }\n };\n \n@@ -266,6 +270,8 @@ class CTestNetParams : public CChainParams {\n             0.09\n         };\n \n+        /* enable fallback fee on testnet */\n+        m_fallback_fee_enabled = true;\n     }\n };\n \n@@ -343,6 +349,9 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n \n         bech32_hrp = \"bcrt\";\n+\n+        /* enable fallback fee on regtest */\n+        m_fallback_fee_enabled = true;\n     }\n };\n "
      },
      {
        "sha": "6b1f813afb47267ba10abf1ece3d5b2cd98246cf",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -65,6 +65,8 @@ class CChainParams\n     bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n     /** Return the BIP70 network string (main, test or regtest) */\n     std::string NetworkIDString() const { return strNetworkID; }\n+    /** Return true if the fallback fee is by default enabled for this network */\n+    bool IsFallbackFeeEnabled() const { return m_fallback_fee_enabled; }\n     /** Return the list of hostnames to look up for DNS seeds */\n     const std::vector<std::string>& DNSSeeds() const { return vSeeds; }\n     const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n@@ -91,6 +93,7 @@ class CChainParams\n     bool fMineBlocksOnDemand;\n     CCheckpointData checkpointData;\n     ChainTxData chainTxData;\n+    bool m_fallback_fee_enabled;\n };\n \n /**"
      },
      {
        "sha": "816d854db34467bd9289cbdbeb8378e1c193f18c",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -21,9 +21,10 @@ namespace Checkpoints {\n         for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n         {\n             const uint256& hash = i.second;\n-            BlockMap::const_iterator t = mapBlockIndex.find(hash);\n-            if (t != mapBlockIndex.end())\n-                return t->second;\n+            CBlockIndex* pindex = LookupBlockIndex(hash);\n+            if (pindex) {\n+                return pindex;\n+            }\n         }\n         return nullptr;\n     }"
      },
      {
        "sha": "564b48639318b2fd59dc9d9de04234a141946cb1",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -19,7 +19,7 @@ struct CCheckpointData;\n namespace Checkpoints\n {\n \n-//! Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n+//! Returns last CBlockIndex* that is a checkpoint\n CBlockIndex* GetLastCheckpoint(const CCheckpointData& data);\n \n } //namespace Checkpoints"
      },
      {
        "sha": "a73f016a3112727723ff3650fb9ef5c458d24ce3",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -69,7 +69,7 @@ class Coin\n         ::Unserialize(s, VARINT(code));\n         nHeight = code >> 1;\n         fCoinBase = code & 1;\n-        ::Unserialize(s, REF(CTxOutCompressor(out)));\n+        ::Unserialize(s, CTxOutCompressor(out));\n     }\n \n     bool IsSpent() const {"
      },
      {
        "sha": "8a0f901304e528aeb957574961a7ef0dde7a86f5",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,6 +10,16 @@\n #include <config/bitcoin-config.h>\n #endif\n \n+#include <type_traits>\n+\n+// GCC 4.8 is missing some C++11 type_traits,\n+// https://www.gnu.org/software/gcc/gcc-5/changes.html\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#define IS_TRIVIALLY_CONSTRUCTIBLE std::is_trivial\n+#else\n+#define IS_TRIVIALLY_CONSTRUCTIBLE std::is_trivially_constructible\n+#endif\n+\n #ifdef WIN32\n #ifdef _WIN32_WINNT\n #undef _WIN32_WINNT"
      },
      {
        "sha": "da639a01af40d840a51557a05d0846d6a6c16e02",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 11,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,7 +9,15 @@\n #include <pubkey.h>\n #include <script/standard.h>\n \n-bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n+/*\n+ * These check for scripts for which a special case with a shorter encoding is defined.\n+ * They are implemented separately from the CScript test, as these test for exact byte\n+ * sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n+ * whether the public key is valid (as invalid ones cannot be represented in compressed\n+ * form).\n+ */\n+\n+static bool IsToKeyID(const CScript& script, CKeyID &hash)\n {\n     if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n                             && script[2] == 20 && script[23] == OP_EQUALVERIFY\n@@ -20,7 +28,7 @@ bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n     return false;\n }\n \n-bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n+static bool IsToScriptID(const CScript& script, CScriptID &hash)\n {\n     if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n                             && script[22] == OP_EQUAL) {\n@@ -30,7 +38,7 @@ bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n     return false;\n }\n \n-bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n+static bool IsToPubKey(const CScript& script, CPubKey &pubkey)\n {\n     if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n                             && (script[1] == 0x02 || script[1] == 0x03)) {\n@@ -45,24 +53,24 @@ bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n     return false;\n }\n \n-bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n+bool CompressScript(const CScript& script, std::vector<unsigned char> &out)\n {\n     CKeyID keyID;\n-    if (IsToKeyID(keyID)) {\n+    if (IsToKeyID(script, keyID)) {\n         out.resize(21);\n         out[0] = 0x00;\n         memcpy(&out[1], &keyID, 20);\n         return true;\n     }\n     CScriptID scriptID;\n-    if (IsToScriptID(scriptID)) {\n+    if (IsToScriptID(script, scriptID)) {\n         out.resize(21);\n         out[0] = 0x01;\n         memcpy(&out[1], &scriptID, 20);\n         return true;\n     }\n     CPubKey pubkey;\n-    if (IsToPubKey(pubkey)) {\n+    if (IsToPubKey(script, pubkey)) {\n         out.resize(33);\n         memcpy(&out[1], &pubkey[1], 32);\n         if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n@@ -76,7 +84,7 @@ bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n     return false;\n }\n \n-unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n+unsigned int GetSpecialScriptSize(unsigned int nSize)\n {\n     if (nSize == 0 || nSize == 1)\n         return 20;\n@@ -85,7 +93,7 @@ unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n     return 0;\n }\n \n-bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n+bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &in)\n {\n     switch(nSize) {\n     case 0x00:\n@@ -139,7 +147,7 @@ bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigne\n // * if e==9, we only know the resulting number is not zero, so output 1 + 10*(n - 1) + 9\n // (this is decodable, as d is in [1-9] and e is in [0-9])\n \n-uint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n+uint64_t CompressAmount(uint64_t n)\n {\n     if (n == 0)\n         return 0;\n@@ -158,7 +166,7 @@ uint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n     }\n }\n \n-uint64_t CTxOutCompressor::DecompressAmount(uint64_t x)\n+uint64_t DecompressAmount(uint64_t x)\n {\n     // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n     if (x == 0)"
      },
      {
        "sha": "561c8e66d0d3740dcb458df0b7e0de4033a2ee6e",
        "filename": "src/compressor.h",
        "status": "modified",
        "additions": 12,
        "deletions": 23,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -14,6 +14,13 @@ class CKeyID;\n class CPubKey;\n class CScriptID;\n \n+bool CompressScript(const CScript& script, std::vector<unsigned char> &out);\n+unsigned int GetSpecialScriptSize(unsigned int nSize);\n+bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &out);\n+\n+uint64_t CompressAmount(uint64_t nAmount);\n+uint64_t DecompressAmount(uint64_t nAmount);\n+\n /** Compact serializer for scripts.\n  *\n  *  It detects common cases and encodes them much more efficiently.\n@@ -37,28 +44,13 @@ class CScriptCompressor\n     static const unsigned int nSpecialScripts = 6;\n \n     CScript &script;\n-protected:\n-    /**\n-     * These check for scripts for which a special case with a shorter encoding is defined.\n-     * They are implemented separately from the CScript test, as these test for exact byte\n-     * sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n-     * whether the public key is valid (as invalid ones cannot be represented in compressed\n-     * form).\n-     */\n-    bool IsToKeyID(CKeyID &hash) const;\n-    bool IsToScriptID(CScriptID &hash) const;\n-    bool IsToPubKey(CPubKey &pubkey) const;\n-\n-    bool Compress(std::vector<unsigned char> &out) const;\n-    unsigned int GetSpecialSize(unsigned int nSize) const;\n-    bool Decompress(unsigned int nSize, const std::vector<unsigned char> &out);\n public:\n     explicit CScriptCompressor(CScript &scriptIn) : script(scriptIn) { }\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n         std::vector<unsigned char> compr;\n-        if (Compress(compr)) {\n+        if (CompressScript(script, compr)) {\n             s << CFlatData(compr);\n             return;\n         }\n@@ -72,9 +64,9 @@ class CScriptCompressor\n         unsigned int nSize = 0;\n         s >> VARINT(nSize);\n         if (nSize < nSpecialScripts) {\n-            std::vector<unsigned char> vch(GetSpecialSize(nSize), 0x00);\n-            s >> REF(CFlatData(vch));\n-            Decompress(nSize, vch);\n+            std::vector<unsigned char> vch(GetSpecialScriptSize(nSize), 0x00);\n+            s >> CFlatData(vch);\n+            DecompressScript(script, nSize, vch);\n             return;\n         }\n         nSize -= nSpecialScripts;\n@@ -84,7 +76,7 @@ class CScriptCompressor\n             s.ignore(nSize);\n         } else {\n             script.resize(nSize);\n-            s >> REF(CFlatData(script));\n+            s >> CFlatData(script);\n         }\n     }\n };\n@@ -96,9 +88,6 @@ class CTxOutCompressor\n     CTxOut &txout;\n \n public:\n-    static uint64_t CompressAmount(uint64_t nAmount);\n-    static uint64_t DecompressAmount(uint64_t nAmount);\n-\n     explicit CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) { }\n \n     ADD_SERIALIZE_METHODS;"
      },
      {
        "sha": "28d3c4a1194286f7804d15d0e84e367dcfc5e86d",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -101,5 +101,10 @@ static inline int64_t GetBlockWeight(const CBlock& block)\n {\n     return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n }\n+static inline int64_t GetTransactionInputWeight(const CTxIn& txin)\n+{\n+    // scriptWitness size is added here because witnesses and txins are split up in segwit serialization.\n+    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);\n+}\n \n #endif // BITCOIN_CONSENSUS_VALIDATION_H"
      },
      {
        "sha": "54b18a49310fc7c3f4be155c2cfc1f1720e2d687",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,9 +4,9 @@\n \n #include <core_io.h>\n \n-#include <base58.h>\n #include <consensus/consensus.h>\n #include <consensus/validation.h>\n+#include <key_io.h>\n #include <script/script.h>\n #include <script/standard.h>\n #include <serialize.h>\n@@ -209,6 +209,6 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry,\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n \n     if (include_hex) {\n-        entry.pushKV(\"hex\", EncodeHexTx(tx, serialize_flags)); // the hex-encoded transaction. used the name \"hex\" to be consistent with the verbose output of \"getrawtransaction\".\n+        entry.pushKV(\"hex\", EncodeHexTx(tx, serialize_flags)); // The hex-encoded transaction. Used the name \"hex\" to be consistent with the verbose output of \"getrawtransaction\".\n     }\n }"
      },
      {
        "sha": "6e9d6dc82aa76d35b2c8d7cd7be3cecb902ba4d9",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -82,12 +82,12 @@ void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n /** Return the smallest number n such that (x >> n) == 0 (or 64 if the highest bit in x is set. */\n uint64_t static inline CountBits(uint64_t x)\n {\n-#ifdef HAVE_DECL___BUILTIN_CLZL\n+#if HAVE_DECL___BUILTIN_CLZL\n     if (sizeof(unsigned long) >= sizeof(uint64_t)) {\n         return x ? 8 * sizeof(unsigned long) - __builtin_clzl(x) : 0;\n     }\n #endif\n-#ifdef HAVE_DECL___BUILTIN_CLZLL\n+#if HAVE_DECL___BUILTIN_CLZLL\n     if (sizeof(unsigned long long) >= sizeof(uint64_t)) {\n         return x ? 8 * sizeof(unsigned long long) - __builtin_clzll(x) : 0;\n     }"
      },
      {
        "sha": "d1de712024ab9158c7dde281a3e1106edd792367",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -224,7 +224,7 @@ class cache\n      *\n      * Instead we treat the 32-bit random number as a Q32 fixed-point number in the range\n      *  [0,1) and simply multiply it by the size.  Then we just shift the result down by\n-     *  32-bits to get our bucket number.  The results has non-uniformity the same as a\n+     *  32-bits to get our bucket number.  The result has non-uniformity the same as a\n      *  mod, but it is much faster to compute. More about this technique can be found at\n      *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n      *"
      },
      {
        "sha": "752f985bc09d755e8d94502b141ffaa463617dfb",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 9,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -71,24 +71,50 @@ class CBitcoinLevelDBLogger : public leveldb::Logger {\n     }\n };\n \n+static void SetMaxOpenFiles(leveldb::Options *options) {\n+    // On most platforms the default setting of max_open_files (which is 1000)\n+    // is optimal. On Windows using a large file count is OK because the handles\n+    // do not interfere with select() loops. On 64-bit Unix hosts this value is\n+    // also OK, because up to that amount LevelDB will use an mmap\n+    // implementation that does not use extra file descriptors (the fds are\n+    // closed after being mmaped).\n+    //\n+    // Increasing the value beyond the default is dangerous because LevelDB will\n+    // fall back to a non-mmap implementation when the file count is too large.\n+    // On 32-bit Unix host we should decrease the value because the handles use\n+    // up real fds, and we want to avoid fd exhaustion issues.\n+    //\n+    // See PR #12495 for further discussion.\n+\n+    int default_open_files = options->max_open_files;\n+#ifndef WIN32\n+    if (sizeof(void*) < 8) {\n+        options->max_open_files = 64;\n+    }\n+#endif\n+    LogPrint(BCLog::LEVELDB, \"LevelDB using max_open_files=%d (default=%d)\\n\",\n+             options->max_open_files, default_open_files);\n+}\n+\n static leveldb::Options GetOptions(size_t nCacheSize)\n {\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n     options.compression = leveldb::kNoCompression;\n-    options.max_open_files = 64;\n     options.info_log = new CBitcoinLevelDBLogger();\n     if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n         // on corruption in later versions.\n         options.paranoid_checks = true;\n     }\n+    SetMaxOpenFiles(&options);\n     return options;\n }\n \n CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n+    : m_name(fs::basename(path))\n {\n     penv = nullptr;\n     readoptions.verify_checksums = true;\n@@ -155,11 +181,30 @@ CDBWrapper::~CDBWrapper()\n \n bool CDBWrapper::WriteBatch(CDBBatch& batch, bool fSync)\n {\n+    const bool log_memory = LogAcceptCategory(BCLog::LEVELDB);\n+    double mem_before = 0;\n+    if (log_memory) {\n+        mem_before = DynamicMemoryUsage() / 1024.0 / 1024;\n+    }\n     leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n     dbwrapper_private::HandleError(status);\n+    if (log_memory) {\n+        double mem_after = DynamicMemoryUsage() / 1024.0 / 1024;\n+        LogPrint(BCLog::LEVELDB, \"WriteBatch memory usage: db=%s, before=%.1fMiB, after=%.1fMiB\\n\",\n+                 m_name, mem_before, mem_after);\n+    }\n     return true;\n }\n \n+size_t CDBWrapper::DynamicMemoryUsage() const {\n+    std::string memory;\n+    if (!pdb->GetProperty(\"leveldb.approximate-memory-usage\", &memory)) {\n+        LogPrint(BCLog::LEVELDB, \"Failed to get approximate-memory-usage property\\n\");\n+        return 0;\n+    }\n+    return stoul(memory);\n+}\n+\n // Prefixed with null character to avoid collisions with other keys\n //\n // We must use a string constructor which specifies length so that we copy\n@@ -198,14 +243,10 @@ void HandleError(const leveldb::Status& status)\n {\n     if (status.ok())\n         return;\n-    LogPrintf(\"%s\\n\", status.ToString());\n-    if (status.IsCorruption())\n-        throw dbwrapper_error(\"Database corrupted\");\n-    if (status.IsIOError())\n-        throw dbwrapper_error(\"Database I/O error\");\n-    if (status.IsNotFound())\n-        throw dbwrapper_error(\"Database entry missing\");\n-    throw dbwrapper_error(\"Unknown database error\");\n+    const std::string errmsg = \"Fatal LevelDB error: \" + status.ToString();\n+    LogPrintf(\"%s\\n\", errmsg);\n+    LogPrintf(\"You can use -debug=leveldb to get more complete diagnostic messages\\n\");\n+    throw dbwrapper_error(errmsg);\n }\n \n const std::vector<unsigned char>& GetObfuscateKey(const CDBWrapper &w)"
      },
      {
        "sha": "6f80eedc7a4b235d127c6bf8dedb9461f4d7aa96",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -198,6 +198,9 @@ class CDBWrapper\n     //! the database itself\n     leveldb::DB* pdb;\n \n+    //! the name of this database\n+    std::string m_name;\n+\n     //! a key used for optional XOR-obfuscation of the database\n     std::vector<unsigned char> obfuscate_key;\n \n@@ -284,6 +287,9 @@ class CDBWrapper\n \n     bool WriteBatch(CDBBatch& batch, bool fSync = false);\n \n+    // Get an estimate of LevelDB memory usage (in bytes).\n+    size_t DynamicMemoryUsage() const;\n+\n     // not available for LevelDB; provide for compatibility with BDB\n     bool Flush()\n     {"
      },
      {
        "sha": "75353e0c0f265d30459c8c823f2757c00a541fde",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -173,7 +173,7 @@ class CHashVerifier : public CHashWriter\n     }\n \n     template<typename T>\n-    CHashVerifier<Source>& operator>>(T& obj)\n+    CHashVerifier<Source>& operator>>(T&& obj)\n     {\n         // Unserialize from this stream\n         ::Unserialize(*this, obj);"
      },
      {
        "sha": "0a70619ba6a7e2f4b1565b9c76c5262f754b7a81",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,9 +4,9 @@\n \n #include <httprpc.h>\n \n-#include <base58.h>\n #include <chainparams.h>\n #include <httpserver.h>\n+#include <key_io.h>\n #include <rpc/protocol.h>\n #include <rpc/server.h>\n #include <random.h>\n@@ -158,8 +158,9 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n     }\n \n     JSONRPCRequest jreq;\n+    jreq.peerAddr = req->GetPeer().ToString();\n     if (!RPCAuthorized(authHeader.second, jreq.authUser)) {\n-        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", req->GetPeer().ToString());\n+        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", jreq.peerAddr);\n \n         /* Deter brute-forcing\n            If this results in a DoS the user really\n@@ -252,6 +253,9 @@ void StopHTTPRPC()\n {\n     LogPrint(BCLog::RPC, \"Stopping HTTP RPC server\\n\");\n     UnregisterHTTPHandler(\"/\", true);\n+#ifdef ENABLE_WALLET\n+    UnregisterHTTPHandler(\"/wallet/\", false);\n+#endif\n     if (httpRPCTimerInterface) {\n         RPCUnsetTimerInterface(httpRPCTimerInterface.get());\n         httpRPCTimerInterface.reset();"
      },
      {
        "sha": "f6f522da66b6d2cc6329f266eb064513553e3fed",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 70,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -43,10 +43,8 @@\n #include <util.h>\n #include <utilmoneystr.h>\n #include <validationinterface.h>\n-#ifdef ENABLE_WALLET\n-#include <wallet/init.h>\n-#endif\n #include <warnings.h>\n+#include <walletinitinterface.h>\n #include <stdint.h>\n #include <stdio.h>\n #include <memory>\n@@ -74,6 +72,7 @@ static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;\n \n std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<PeerLogicValidation> peerLogic;\n+std::unique_ptr<WalletInitInterface> g_wallet_init_interface;\n \n #if ENABLE_ZMQ\n static CZMQNotificationInterface* pzmqNotificationInterface = nullptr;\n@@ -116,7 +115,6 @@ static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n //\n \n std::atomic<bool> fRequestShutdown(false);\n-std::atomic<bool> fDumpMempoolLater(false);\n \n void StartShutdown()\n {\n@@ -189,9 +187,7 @@ void Shutdown()\n     StopREST();\n     StopRPC();\n     StopHTTPServer();\n-#ifdef ENABLE_WALLET\n-    FlushWallets();\n-#endif\n+    g_wallet_init_interface->Flush();\n     StopMapPort();\n \n     // Because these depend on each-other, we make sure that neither can be\n@@ -208,7 +204,7 @@ void Shutdown()\n     threadGroup.interrupt_all();\n     threadGroup.join_all();\n \n-    if (fDumpMempoolLater && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+    if (g_is_mempool_loaded && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n     }\n \n@@ -249,9 +245,7 @@ void Shutdown()\n         pcoinsdbview.reset();\n         pblocktree.reset();\n     }\n-#ifdef ENABLE_WALLET\n-    StopWallets();\n-#endif\n+    g_wallet_init_interface->Stop();\n \n #if ENABLE_ZMQ\n     if (pzmqNotificationInterface) {\n@@ -271,9 +265,8 @@ void Shutdown()\n     UnregisterAllValidationInterfaces();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n     GetMainSignals().UnregisterWithMempoolSignals(mempool);\n-#ifdef ENABLE_WALLET\n-    CloseWallets();\n-#endif\n+    g_wallet_init_interface->Close();\n+    g_wallet_init_interface.reset();\n     globalVerifyHandle.reset();\n     ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n@@ -333,12 +326,13 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-version\", _(\"Print version and exit\"));\n     strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"));\n     strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n+    strUsage += HelpMessageOpt(\"-blocksdir=<dir>\", _(\"Specify blocks directory (default: <datadir>/blocks)\"));\n     strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME));\n-    if (mode == HMM_BITCOIND)\n+    if (mode == HelpMessageMode::BITCOIND)\n     {\n #if HAVE_DECL_DAEMON\n         strUsage += HelpMessageOpt(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"));\n@@ -415,9 +409,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-whitelist=<IP address or network>\", _(\"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\") +\n         \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n \n-#ifdef ENABLE_WALLET\n-    strUsage += GetWalletHelpString(showDebug);\n-#endif\n+    strUsage += g_wallet_init_interface->GetHelpString(showDebug);\n \n #if ENABLE_ZMQ\n     strUsage += HelpMessageGroup(_(\"ZeroMQ notification options:\"));\n@@ -428,18 +420,16 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n \n     strUsage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n-    if (showDebug)\n-    {\n+    if (showDebug) {\n         strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n         strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL));\n-        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n         strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n         strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED));\n         strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\"Disable safemode, override a real safe mode event (default: %u)\", DEFAULT_DISABLE_SAFEMODE));\n         strUsage += HelpMessageOpt(\"-deprecatedrpc=<method>\", \"Allows deprecated RPC method(s) to be used\");\n         strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n         strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n-        strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT));\n         strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT));\n \n@@ -448,6 +438,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\");\n+        strUsage += HelpMessageOpt(\"-addrmantest\", \"Allows to test address relay on localhost\");\n     }\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n         _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\");\n@@ -490,8 +481,6 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", \"Set maximum BIP141 block weight to this * 4. Deprecated, use blockmaxweight\");\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n     strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n     if (showDebug)\n@@ -595,7 +584,7 @@ void CleanupBlockRevFiles()\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    fs::path blocksdir = GetDataDir() / \"blocks\";\n+    fs::path blocksdir = GetBlocksDir();\n     for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n         if (fs::is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n@@ -692,8 +681,8 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n     } // End scope of CImportingNow\n     if (gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         LoadMempool();\n-        fDumpMempoolLater = !fRequestShutdown;\n     }\n+    g_is_mempool_loaded = !fRequestShutdown;\n }\n \n /** Sanity checks\n@@ -797,15 +786,6 @@ void InitParameterInteraction()\n         if (gArgs.SoftSetBoolArg(\"-whitelistrelay\", true))\n             LogPrintf(\"%s: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1\\n\", __func__);\n     }\n-\n-    if (gArgs.IsArgSet(\"-blockmaxsize\")) {\n-        unsigned int max_size = gArgs.GetArg(\"-blockmaxsize\", 0);\n-        if (gArgs.SoftSetArg(\"blockmaxweight\", strprintf(\"%d\", max_size * WITNESS_SCALE_FACTOR))) {\n-            LogPrintf(\"%s: parameter interaction: -blockmaxsize=%d -> setting -blockmaxweight=%d (-blockmaxsize is deprecated!)\\n\", __func__, max_size, max_size * WITNESS_SCALE_FACTOR);\n-        } else {\n-            LogPrintf(\"%s: Ignoring blockmaxsize setting which is overridden by blockmaxweight\", __func__);\n-        }\n-    }\n }\n \n static std::string ResolveErrMsg(const char * const optname, const std::string& strBind)\n@@ -907,6 +887,10 @@ bool AppInitParameterInteraction()\n \n     // also see: InitParameterInteraction()\n \n+    if (!fs::is_directory(GetBlocksDir(false))) {\n+        return InitError(strprintf(_(\"Specified blocks directory \\\"%s\\\" does not exist.\\n\"), gArgs.GetArg(\"-blocksdir\", \"\").c_str()));\n+    }\n+\n     // if using block pruning, then disallow txindex\n     if (gArgs.GetArg(\"-prune\", 0)) {\n         if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX))\n@@ -925,7 +909,7 @@ bool AppInitParameterInteraction()\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n     // Trim requested connection counts, to fit into system limitations\n-    nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS)), 0);\n+    nMaxConnections = std::max(std::min(nMaxConnections, FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS - MAX_ADDNODE_CONNECTIONS), 0);\n     nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS + MAX_ADDNODE_CONNECTIONS);\n     if (nFD < MIN_CORE_FILEDESCRIPTORS)\n         return InitError(_(\"Not enough file descriptors available.\"));\n@@ -1082,7 +1066,7 @@ bool AppInitParameterInteraction()\n     if (gArgs.IsArgSet(\"-dustrelayfee\"))\n     {\n         CAmount n = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-dustrelayfee\", \"\"), n) || 0 == n)\n+        if (!ParseMoney(gArgs.GetArg(\"-dustrelayfee\", \"\"), n))\n             return InitError(AmountErrMsg(\"dustrelayfee\", gArgs.GetArg(\"-dustrelayfee\", \"\")));\n         dustRelayFee = CFeeRate(n);\n     }\n@@ -1092,10 +1076,7 @@ bool AppInitParameterInteraction()\n         return InitError(strprintf(\"acceptnonstdtxn is not currently supported for %s chain\", chainparams.NetworkIDString()));\n     nBytesPerSigOp = gArgs.GetArg(\"-bytespersigop\", nBytesPerSigOp);\n \n-#ifdef ENABLE_WALLET\n-    if (!WalletParameterInteraction())\n-        return false;\n-#endif\n+    if (!g_wallet_init_interface->ParameterInteraction()) return false;\n \n     fIsBareMultisigStd = gArgs.GetBoolArg(\"-permitbaremultisig\", DEFAULT_PERMIT_BAREMULTISIG);\n     fAcceptDatacarrier = gArgs.GetBoolArg(\"-datacarrier\", DEFAULT_ACCEPT_DATACARRIER);\n@@ -1164,6 +1145,9 @@ static bool LockDataDirectory(bool probeOnly)\n {\n     // Make sure only a single Bitcoin process is using the data directory.\n     fs::path datadir = GetDataDir();\n+    if (!DirIsWritable(datadir)) {\n+        return InitError(strprintf(_(\"Cannot write to data directory '%s'; check permissions.\"), datadir.string()));\n+    }\n     if (!LockDirectory(datadir, \".lock\", probeOnly)) {\n         return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. %s is probably already running.\"), datadir.string(), _(PACKAGE_NAME)));\n     }\n@@ -1223,7 +1207,7 @@ bool AppInitMain()\n     }\n \n     if (!fLogTimestamps)\n-        LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()));\n+        LogPrintf(\"Startup time: %s\\n\", FormatISO8601DateTime(GetTime()));\n     LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n     LogPrintf(\"Using data directory %s\\n\", GetDataDir().string());\n     LogPrintf(\"Using config file %s\\n\", GetConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string());\n@@ -1258,9 +1242,7 @@ bool AppInitMain()\n      * available in the GUI RPC console even if external calls are disabled.\n      */\n     RegisterAllCoreRPCCommands(tableRPC);\n-#ifdef ENABLE_WALLET\n-    RegisterWalletRPC(tableRPC);\n-#endif\n+    g_wallet_init_interface->RegisterRPC(tableRPC);\n \n     /* Start the RPC server already.  It will be started in \"warmup\" mode\n      * and not really process calls already (but it will signify connections\n@@ -1277,10 +1259,8 @@ bool AppInitMain()\n     int64_t nStart;\n \n     // ********************************************************* Step 5: verify wallet database integrity\n-#ifdef ENABLE_WALLET\n-    if (!VerifyWallets())\n-        return false;\n-#endif\n+    if (!g_wallet_init_interface->Verify()) return false;\n+\n     // ********************************************************* Step 6: network initialization\n     // Note that we absolutely cannot open any actual connections\n     // until the very end (\"start node\") as the UTXO/block state\n@@ -1423,6 +1403,8 @@ bool AppInitMain()\n \n         uiInterface.InitMessage(_(\"Loading block index...\"));\n \n+        LOCK(cs_main);\n+\n         nStart = GetTimeMillis();\n         do {\n             try {\n@@ -1456,8 +1438,9 @@ bool AppInitMain()\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && mapBlockIndex.count(chainparams.GetConsensus().hashGenesisBlock) == 0)\n+                if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n+                }\n \n                 // Check for changed -txindex state\n                 if (fTxIndex != gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n@@ -1531,16 +1514,13 @@ bool AppInitMain()\n                             MIN_BLOCKS_TO_KEEP);\n                     }\n \n-                    {\n-                        LOCK(cs_main);\n-                        CBlockIndex* tip = chainActive.Tip();\n-                        RPCNotifyBlockChange(true, tip);\n-                        if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n-                            strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n-                                    \"This may be due to your computer's date and time being set incorrectly. \"\n-                                    \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n-                            break;\n-                        }\n+                    CBlockIndex* tip = chainActive.Tip();\n+                    RPCNotifyBlockChange(true, tip);\n+                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n+                        strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n+                                \"This may be due to your computer's date and time being set incorrectly. \"\n+                                \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n+                        break;\n                     }\n \n                     if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n@@ -1598,12 +1578,7 @@ bool AppInitMain()\n     fFeeEstimatesInitialized = true;\n \n     // ********************************************************* Step 8: load wallet\n-#ifdef ENABLE_WALLET\n-    if (!OpenWallets())\n-        return false;\n-#else\n-    LogPrintf(\"No wallet support compiled in!\\n\");\n-#endif\n+    if (!g_wallet_init_interface->Open()) return false;\n \n     // ********************************************************* Step 9: data directory maintenance\n \n@@ -1629,7 +1604,7 @@ bool AppInitMain()\n \n     // ********************************************************* Step 10: import blocks\n \n-    if (!CheckDiskSpace())\n+    if (!CheckDiskSpace() && !CheckDiskSpace(0, true))\n         return false;\n \n     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.\n@@ -1749,9 +1724,7 @@ bool AppInitMain()\n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n-#ifdef ENABLE_WALLET\n-    StartWallets(scheduler);\n-#endif\n+    g_wallet_init_interface->Start(scheduler);\n \n     return true;\n }"
      },
      {
        "sha": "c93a2101546b3a0e0e8c1d59c79a63ca26a8edf5",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -6,11 +6,15 @@\n #ifndef BITCOIN_INIT_H\n #define BITCOIN_INIT_H\n \n+#include <memory>\n #include <string>\n \n class CScheduler;\n class CWallet;\n \n+class WalletInitInterface;\n+extern std::unique_ptr<WalletInitInterface> g_wallet_init_interface;\n+\n namespace boost\n {\n class thread_group;\n@@ -57,9 +61,9 @@ bool AppInitLockDataDirectory();\n bool AppInitMain();\n \n /** The help message mode determines what help message to show */\n-enum HelpMessageMode {\n-    HMM_BITCOIND,\n-    HMM_BITCOIN_QT\n+enum class HelpMessageMode {\n+    BITCOIND,\n+    BITCOIN_QT\n };\n \n /** Help for options shared between UI and daemon (for -help) */"
      },
      {
        "sha": "042e687772412aea4347b813ef98e333efa93661",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -170,7 +170,7 @@ CPrivKey CKey::GetPrivKey() const {\n     size_t privkeylen;\n     privkey.resize(PRIVATE_KEY_SIZE);\n     privkeylen = PRIVATE_KEY_SIZE;\n-    ret = ec_privkey_export_der(secp256k1_context_sign, (unsigned char*) privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n+    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n     assert(ret);\n     privkey.resize(privkeylen);\n     return privkey;\n@@ -199,7 +199,7 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_\n     secp256k1_ecdsa_signature sig;\n     int ret = secp256k1_ecdsa_sign(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : nullptr);\n     assert(ret);\n-    secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, (unsigned char*)vchSig.data(), &nSigLen, &sig);\n+    secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, vchSig.data(), &nSigLen, &sig);\n     vchSig.resize(nSigLen);\n     return true;\n }\n@@ -226,7 +226,7 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n     secp256k1_ecdsa_recoverable_signature sig;\n     int ret = secp256k1_ecdsa_sign_recoverable(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, nullptr);\n     assert(ret);\n-    secp256k1_ecdsa_recoverable_signature_serialize_compact(secp256k1_context_sign, (unsigned char*)&vchSig[1], &rec, &sig);\n+    secp256k1_ecdsa_recoverable_signature_serialize_compact(secp256k1_context_sign, &vchSig[1], &rec, &sig);\n     assert(ret);\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);"
      },
      {
        "sha": "c2dc511989e6e29b07c5dbcd2a18be97af5bb861",
        "filename": "src/key_io.cpp",
        "status": "added",
        "additions": 227,
        "deletions": 0,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/key_io.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/key_io.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key_io.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,227 @@\n+// Copyright (c) 2014-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <key_io.h>\n+\n+#include <base58.h>\n+#include <bech32.h>\n+#include <script/script.h>\n+#include <utilstrencodings.h>\n+\n+#include <boost/variant/apply_visitor.hpp>\n+#include <boost/variant/static_visitor.hpp>\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <algorithm>\n+\n+namespace\n+{\n+class DestinationEncoder : public boost::static_visitor<std::string>\n+{\n+private:\n+    const CChainParams& m_params;\n+\n+public:\n+    DestinationEncoder(const CChainParams& params) : m_params(params) {}\n+\n+    std::string operator()(const CKeyID& id) const\n+    {\n+        std::vector<unsigned char> data = m_params.Base58Prefix(CChainParams::PUBKEY_ADDRESS);\n+        data.insert(data.end(), id.begin(), id.end());\n+        return EncodeBase58Check(data);\n+    }\n+\n+    std::string operator()(const CScriptID& id) const\n+    {\n+        std::vector<unsigned char> data = m_params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n+        data.insert(data.end(), id.begin(), id.end());\n+        return EncodeBase58Check(data);\n+    }\n+\n+    std::string operator()(const WitnessV0KeyHash& id) const\n+    {\n+        std::vector<unsigned char> data = {0};\n+        data.reserve(33);\n+        ConvertBits<8, 5, true>([&](unsigned char c) { data.push_back(c); }, id.begin(), id.end());\n+        return bech32::Encode(m_params.Bech32HRP(), data);\n+    }\n+\n+    std::string operator()(const WitnessV0ScriptHash& id) const\n+    {\n+        std::vector<unsigned char> data = {0};\n+        data.reserve(53);\n+        ConvertBits<8, 5, true>([&](unsigned char c) { data.push_back(c); }, id.begin(), id.end());\n+        return bech32::Encode(m_params.Bech32HRP(), data);\n+    }\n+\n+    std::string operator()(const WitnessUnknown& id) const\n+    {\n+        if (id.version < 1 || id.version > 16 || id.length < 2 || id.length > 40) {\n+            return {};\n+        }\n+        std::vector<unsigned char> data = {(unsigned char)id.version};\n+        data.reserve(1 + (id.length * 8 + 4) / 5);\n+        ConvertBits<8, 5, true>([&](unsigned char c) { data.push_back(c); }, id.program, id.program + id.length);\n+        return bech32::Encode(m_params.Bech32HRP(), data);\n+    }\n+\n+    std::string operator()(const CNoDestination& no) const { return {}; }\n+};\n+\n+CTxDestination DecodeDestination(const std::string& str, const CChainParams& params)\n+{\n+    std::vector<unsigned char> data;\n+    uint160 hash;\n+    if (DecodeBase58Check(str, data)) {\n+        // base58-encoded Bitcoin addresses.\n+        // Public-key-hash-addresses have version 0 (or 111 testnet).\n+        // The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key.\n+        const std::vector<unsigned char>& pubkey_prefix = params.Base58Prefix(CChainParams::PUBKEY_ADDRESS);\n+        if (data.size() == hash.size() + pubkey_prefix.size() && std::equal(pubkey_prefix.begin(), pubkey_prefix.end(), data.begin())) {\n+            std::copy(data.begin() + pubkey_prefix.size(), data.end(), hash.begin());\n+            return CKeyID(hash);\n+        }\n+        // Script-hash-addresses have version 5 (or 196 testnet).\n+        // The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script.\n+        const std::vector<unsigned char>& script_prefix = params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);\n+        if (data.size() == hash.size() + script_prefix.size() && std::equal(script_prefix.begin(), script_prefix.end(), data.begin())) {\n+            std::copy(data.begin() + script_prefix.size(), data.end(), hash.begin());\n+            return CScriptID(hash);\n+        }\n+    }\n+    data.clear();\n+    auto bech = bech32::Decode(str);\n+    if (bech.second.size() > 0 && bech.first == params.Bech32HRP()) {\n+        // Bech32 decoding\n+        int version = bech.second[0]; // The first 5 bit symbol is the witness version (0-16)\n+        // The rest of the symbols are converted witness program bytes.\n+        data.reserve(((bech.second.size() - 1) * 5) / 8);\n+        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, bech.second.begin() + 1, bech.second.end())) {\n+            if (version == 0) {\n+                {\n+                    WitnessV0KeyHash keyid;\n+                    if (data.size() == keyid.size()) {\n+                        std::copy(data.begin(), data.end(), keyid.begin());\n+                        return keyid;\n+                    }\n+                }\n+                {\n+                    WitnessV0ScriptHash scriptid;\n+                    if (data.size() == scriptid.size()) {\n+                        std::copy(data.begin(), data.end(), scriptid.begin());\n+                        return scriptid;\n+                    }\n+                }\n+                return CNoDestination();\n+            }\n+            if (version > 16 || data.size() < 2 || data.size() > 40) {\n+                return CNoDestination();\n+            }\n+            WitnessUnknown unk;\n+            unk.version = version;\n+            std::copy(data.begin(), data.end(), unk.program);\n+            unk.length = data.size();\n+            return unk;\n+        }\n+    }\n+    return CNoDestination();\n+}\n+} // namespace\n+\n+CKey DecodeSecret(const std::string& str)\n+{\n+    CKey key;\n+    std::vector<unsigned char> data;\n+    if (DecodeBase58Check(str, data)) {\n+        const std::vector<unsigned char>& privkey_prefix = Params().Base58Prefix(CChainParams::SECRET_KEY);\n+        if ((data.size() == 32 + privkey_prefix.size() || (data.size() == 33 + privkey_prefix.size() && data.back() == 1)) &&\n+            std::equal(privkey_prefix.begin(), privkey_prefix.end(), data.begin())) {\n+            bool compressed = data.size() == 33 + privkey_prefix.size();\n+            key.Set(data.begin() + privkey_prefix.size(), data.begin() + privkey_prefix.size() + 32, compressed);\n+        }\n+    }\n+    memory_cleanse(data.data(), data.size());\n+    return key;\n+}\n+\n+std::string EncodeSecret(const CKey& key)\n+{\n+    assert(key.IsValid());\n+    std::vector<unsigned char> data = Params().Base58Prefix(CChainParams::SECRET_KEY);\n+    data.insert(data.end(), key.begin(), key.end());\n+    if (key.IsCompressed()) {\n+        data.push_back(1);\n+    }\n+    std::string ret = EncodeBase58Check(data);\n+    memory_cleanse(data.data(), data.size());\n+    return ret;\n+}\n+\n+CExtPubKey DecodeExtPubKey(const std::string& str)\n+{\n+    CExtPubKey key;\n+    std::vector<unsigned char> data;\n+    if (DecodeBase58Check(str, data)) {\n+        const std::vector<unsigned char>& prefix = Params().Base58Prefix(CChainParams::EXT_PUBLIC_KEY);\n+        if (data.size() == BIP32_EXTKEY_SIZE + prefix.size() && std::equal(prefix.begin(), prefix.end(), data.begin())) {\n+            key.Decode(data.data() + prefix.size());\n+        }\n+    }\n+    return key;\n+}\n+\n+std::string EncodeExtPubKey(const CExtPubKey& key)\n+{\n+    std::vector<unsigned char> data = Params().Base58Prefix(CChainParams::EXT_PUBLIC_KEY);\n+    size_t size = data.size();\n+    data.resize(size + BIP32_EXTKEY_SIZE);\n+    key.Encode(data.data() + size);\n+    std::string ret = EncodeBase58Check(data);\n+    return ret;\n+}\n+\n+CExtKey DecodeExtKey(const std::string& str)\n+{\n+    CExtKey key;\n+    std::vector<unsigned char> data;\n+    if (DecodeBase58Check(str, data)) {\n+        const std::vector<unsigned char>& prefix = Params().Base58Prefix(CChainParams::EXT_SECRET_KEY);\n+        if (data.size() == BIP32_EXTKEY_SIZE + prefix.size() && std::equal(prefix.begin(), prefix.end(), data.begin())) {\n+            key.Decode(data.data() + prefix.size());\n+        }\n+    }\n+    return key;\n+}\n+\n+std::string EncodeExtKey(const CExtKey& key)\n+{\n+    std::vector<unsigned char> data = Params().Base58Prefix(CChainParams::EXT_SECRET_KEY);\n+    size_t size = data.size();\n+    data.resize(size + BIP32_EXTKEY_SIZE);\n+    key.Encode(data.data() + size);\n+    std::string ret = EncodeBase58Check(data);\n+    memory_cleanse(data.data(), data.size());\n+    return ret;\n+}\n+\n+std::string EncodeDestination(const CTxDestination& dest)\n+{\n+    return boost::apply_visitor(DestinationEncoder(Params()), dest);\n+}\n+\n+CTxDestination DecodeDestination(const std::string& str)\n+{\n+    return DecodeDestination(str, Params());\n+}\n+\n+bool IsValidDestinationString(const std::string& str, const CChainParams& params)\n+{\n+    return IsValidDestination(DecodeDestination(str, params));\n+}\n+\n+bool IsValidDestinationString(const std::string& str)\n+{\n+    return IsValidDestinationString(str, Params());\n+}"
      },
      {
        "sha": "6fc9a8059a543b725283544e79cb1d406faf0351",
        "filename": "src/key_io.h",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/key_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/key_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key_io.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KEYIO_H\n+#define BITCOIN_KEYIO_H\n+\n+#include <chainparams.h>\n+#include <key.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+\n+#include <string>\n+\n+CKey DecodeSecret(const std::string& str);\n+std::string EncodeSecret(const CKey& key);\n+\n+CExtKey DecodeExtKey(const std::string& str);\n+std::string EncodeExtKey(const CExtKey& extkey);\n+CExtPubKey DecodeExtPubKey(const std::string& str);\n+std::string EncodeExtPubKey(const CExtPubKey& extpubkey);\n+\n+std::string EncodeDestination(const CTxDestination& dest);\n+CTxDestination DecodeDestination(const std::string& str);\n+bool IsValidDestinationString(const std::string& str);\n+bool IsValidDestinationString(const std::string& str, const CChainParams& params);\n+\n+#endif // BITCOIN_KEYIO_H"
      },
      {
        "sha": "dfdfa5ea9f11ed27918fad13587f3bc2ebd14152",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -7,10 +7,6 @@\n \n #include <util.h>\n \n-bool CKeyStore::AddKey(const CKey &key) {\n-    return AddKeyPubKey(key, key.GetPubKey());\n-}\n-\n void CBasicKeyStore::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey)\n {\n     AssertLockHeld(cs_KeyStore);"
      },
      {
        "sha": "fa912cb195106a3241006a52be5a5b15d1c30a86",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,35 +9,27 @@\n #include <key.h>\n #include <pubkey.h>\n #include <script/script.h>\n+#include <script/sign.h>\n #include <script/standard.h>\n #include <sync.h>\n \n #include <boost/signals2/signal.hpp>\n \n /** A virtual base class for key stores */\n-class CKeyStore\n+class CKeyStore : public SigningProvider\n {\n-protected:\n-    mutable CCriticalSection cs_KeyStore;\n-\n public:\n-    virtual ~CKeyStore() {}\n-\n     //! Add a key to the store.\n     virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) =0;\n-    virtual bool AddKey(const CKey &key);\n \n     //! Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CKeyID &address) const =0;\n-    virtual bool GetKey(const CKeyID &address, CKey& keyOut) const =0;\n     virtual std::set<CKeyID> GetKeys() const =0;\n-    virtual bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const =0;\n \n     //! Support for BIP 0013 : see https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki\n     virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const CScriptID &hash) const =0;\n     virtual std::set<CScriptID> GetCScripts() const =0;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n \n     //! Support for Watch-only addresses\n     virtual bool AddWatchOnly(const CScript &dest) =0;\n@@ -55,6 +47,8 @@ typedef std::set<CScript> WatchOnlySet;\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n+    mutable CCriticalSection cs_KeyStore;\n+\n     KeyMap mapKeys;\n     WatchKeyMap mapWatchKeys;\n     ScriptMap mapScripts;\n@@ -64,6 +58,7 @@ class CBasicKeyStore : public CKeyStore\n \n public:\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool AddKey(const CKey &key) { return AddKeyPubKey(key, key.GetPubKey()); }\n     bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n     bool HaveKey(const CKeyID &address) const override;\n     std::set<CKeyID> GetKeys() const override;"
      },
      {
        "sha": "0660df928c28b35bf78593cd5f6a467495e122ed",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 11,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -30,12 +30,6 @@\n #include <queue>\n #include <utility>\n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// BitcoinMiner\n-//\n-\n-//\n // Unconfirmed transactions in the memory pool often depend on other\n // transactions in the memory pool. When we select transactions from the\n // pool, we select by highest fee rate of a transaction combined with all\n@@ -74,9 +68,7 @@ BlockAssembler::BlockAssembler(const CChainParams& params, const Options& option\n static BlockAssembler::Options DefaultOptions(const CChainParams& params)\n {\n     // Block resource limits\n-    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*\n-    // If only one is given, only restrict the specified resource.\n-    // If both are given, restrict both.\n+    // If -blockmaxweight is not given, limit to DEFAULT_BLOCK_MAX_WEIGHT\n     BlockAssembler::Options options;\n     options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n     if (gArgs.IsArgSet(\"-blockmintxfee\")) {\n@@ -288,7 +280,7 @@ bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_tran\n     return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\n }\n \n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)\n+void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n {\n     // Sort package by ancestor count\n     // If a transaction A depends on transaction B, then A's ancestor count\n@@ -424,7 +416,7 @@ void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpda\n \n         // Package can be added. Sort the entries in a valid order.\n         std::vector<CTxMemPool::txiter> sortedEntries;\n-        SortForBlock(ancestors, iter, sortedEntries);\n+        SortForBlock(ancestors, sortedEntries);\n \n         for (size_t i=0; i<sortedEntries.size(); ++i) {\n             AddToBlock(sortedEntries[i]);"
      },
      {
        "sha": "33a22ba75fca760c33d756c8e44c0d7119d543a8",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -185,7 +185,7 @@ class BlockAssembler\n       * or if the transaction's cached data in mapTx is incorrect. */\n     bool SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx);\n     /** Sort the package in an order that is valid to appear in a block */\n-    void SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries);\n+    void SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries);\n     /** Add descendants of given transactions to mapModifiedTx with ancestor\n       * state updated assuming given transactions are inBlock. Returns number\n       * of updated descendants. */"
      },
      {
        "sha": "342dfbaeb9c2f5b8896adc2a593c22d92d0ac0d0",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 7,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -42,12 +42,13 @@\n // We add a random period time (0 to 1 seconds) to feeler connections to prevent synchronization.\n #define FEELER_SLEEP_WINDOW 1\n \n-#if !defined(HAVE_MSG_NOSIGNAL)\n+// MSG_NOSIGNAL is not available on some platforms, if it doesn't exist define it as 0\n+#if !defined(MSG_NOSIGNAL)\n #define MSG_NOSIGNAL 0\n #endif\n \n // MSG_DONTWAIT is not available on some platforms, if it doesn't exist define it as 0\n-#if !defined(HAVE_MSG_DONTWAIT)\n+#if !defined(MSG_DONTWAIT)\n #define MSG_DONTWAIT 0\n #endif\n \n@@ -181,6 +182,10 @@ void AdvertiseLocal(CNode *pnode)\n     if (fListen && pnode->fSuccessfullyConnected)\n     {\n         CAddress addrLocal = GetLocalAddress(&pnode->addr, pnode->GetLocalServices());\n+        if (gArgs.GetBoolArg(\"-addrmantest\", false)) {\n+            // use IPv4 loopback during addrmantest\n+            addrLocal = CAddress(CService(LookupNumeric(\"127.0.0.1\", GetListenPort())), pnode->GetLocalServices());\n+        }\n         // If discovery is enabled, sometimes give our peer the address it\n         // tells us that it sees us as in case it has a better idea of our\n         // address than we do.\n@@ -189,7 +194,7 @@ void AdvertiseLocal(CNode *pnode)\n         {\n             addrLocal.SetIP(pnode->GetAddrLocal());\n         }\n-        if (addrLocal.IsRoutable())\n+        if (addrLocal.IsRoutable() || gArgs.GetBoolArg(\"-addrmantest\", false))\n         {\n             LogPrint(BCLog::NET, \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n             FastRandomContext insecure_rand;\n@@ -1627,7 +1632,8 @@ void CConnman::ThreadDNSAddressSeed()\n             if (!resolveSource.SetInternal(host)) {\n                 continue;\n             }\n-            if (LookupHost(host.c_str(), vIPs, 0, true))\n+            unsigned int nMaxIPs = 256; // Limits number of IPs learned from a DNS seed\n+            if (LookupHost(host.c_str(), vIPs, nMaxIPs, true))\n             {\n                 for (const CNetAddr& ip : vIPs)\n                 {\n@@ -1824,11 +1830,18 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n         }\n \n+        addrman.ResolveCollisions();\n+\n         int64_t nANow = GetAdjustedTime();\n         int nTries = 0;\n         while (!interruptNet)\n         {\n-            CAddrInfo addr = addrman.Select(fFeeler);\n+            CAddrInfo addr = addrman.SelectTriedCollision();\n+\n+            // SelectTriedCollision returns an invalid address if it is empty.\n+            if (!fFeeler || !addr.IsValid()) {\n+                addr = addrman.Select(fFeeler);\n+            }\n \n             // if we selected an invalid address, restart\n             if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n@@ -1942,7 +1955,7 @@ void CConnman::ThreadOpenAddedConnections()\n         for (const AddedNodeInfo& info : vInfo) {\n             if (!info.fConnected) {\n                 if (!grant.TryAcquire()) {\n-                    // If we've used up our semaphore and need a new one, lets not wait here since while we are waiting\n+                    // If we've used up our semaphore and need a new one, let's not wait here since while we are waiting\n                     // the addednodeinfo state might change.\n                     break;\n                 }\n@@ -2718,6 +2731,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fOneShot = false;\n     m_manual_connection = false;\n     fClient = false; // set by version message\n+    m_limited_node = false; // set by version message\n     fFeeler = false;\n     fSuccessfullyConnected = false;\n     fDisconnect = false;\n@@ -2782,7 +2796,7 @@ void CNode::AskFor(const CInv& inv)\n         nRequestTime = it->second;\n     else\n         nRequestTime = 0;\n-    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n+    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, FormatISO8601Time(nRequestTime/1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n     int64_t nNow = GetTimeMicros() - 1000000;"
      },
      {
        "sha": "7839b75a86ae78986f8af4503ef43e75baafbf27",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -469,6 +469,13 @@ class NetEventsInterface\n     virtual bool SendMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n     virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n+\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n enum\n@@ -641,6 +648,7 @@ class CNode\n     bool fOneShot;\n     bool m_manual_connection;\n     bool fClient;\n+    bool m_limited_node; //after BIP159\n     const bool fInbound;\n     std::atomic_bool fSuccessfullyConnected;\n     std::atomic_bool fDisconnect;"
      },
      {
        "sha": "61e6ae74482ced9c04984703d31afc9894db3ed6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 81,
        "deletions": 49,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -339,7 +339,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n-    // Short-circuit most stuff in case its from the same node\n+    // Short-circuit most stuff in case it is from the same node\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n         if (pit) {\n@@ -374,10 +374,11 @@ void ProcessBlockAvailability(NodeId nodeid) {\n     assert(state != nullptr);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n-        BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n-        if (itOld != mapBlockIndex.end() && itOld->second->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || itOld->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n-                state->pindexBestKnownBlock = itOld->second;\n+        const CBlockIndex* pindex = LookupBlockIndex(state->hashLastUnknownBlock);\n+        if (pindex && pindex->nChainWork > 0) {\n+            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+                state->pindexBestKnownBlock = pindex;\n+            }\n             state->hashLastUnknownBlock.SetNull();\n         }\n     }\n@@ -390,17 +391,24 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n \n     ProcessBlockAvailability(nodeid);\n \n-    BlockMap::iterator it = mapBlockIndex.find(hash);\n-    if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {\n+    const CBlockIndex* pindex = LookupBlockIndex(hash);\n+    if (pindex && pindex->nChainWork > 0) {\n         // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == nullptr || it->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n-            state->pindexBestKnownBlock = it->second;\n+        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n+            state->pindexBestKnownBlock = pindex;\n+        }\n     } else {\n         // An unknown block was announced; just assume that the latest one is the best one.\n         state->hashLastUnknownBlock = hash;\n     }\n }\n \n+/**\n+ * When a peer sends us a valid block, instruct it to announce blocks to us\n+ * using CMPCTBLOCK if possible by adding its nodeid to the end of\n+ * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n+ * removing the first element if necessary.\n+ */\n void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n@@ -510,7 +518,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n         }\n \n         // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n-        // are not yet downloaded and not in flight to vBlocks. In the mean time, update\n+        // are not yet downloaded and not in flight to vBlocks. In the meantime, update\n         // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n         // already part of our chain (and therefore don't need it even if pruned).\n         for (const CBlockIndex* pindex : vToFetch) {\n@@ -749,7 +757,11 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     return nEvicted;\n }\n \n-// Requires cs_main.\n+/**\n+ * Mark a misbehaving peer to be banned depending upon the value of `-banscore`.\n+ *\n+ * Requires cs_main.\n+ */\n void Misbehaving(NodeId pnode, int howmuch, const std::string& message)\n {\n     if (howmuch == 0)\n@@ -808,6 +820,10 @@ PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &schedu\n     scheduler.scheduleEvery(std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams), EXTRA_PEER_CHECK_INTERVAL * 1000);\n }\n \n+/**\n+ * Evict orphan txn pool entries (EraseOrphanTx) based on a newly connected\n+ * block. Also save the time of the last tip update.\n+ */\n void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n     LOCK(g_cs_orphans);\n \n@@ -828,7 +844,7 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         }\n     }\n \n-    // Erase orphan transactions include or precluded by this block\n+    // Erase orphan transactions included or precluded by this block\n     if (vOrphanErase.size()) {\n         int nErased = 0;\n         for (uint256 &orphanHash : vOrphanErase) {\n@@ -847,6 +863,10 @@ static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_bloc\n static uint256 most_recent_block_hash;\n static bool fWitnessesPresentInMostRecentCompactBlock;\n \n+/**\n+ * Maintain state about the best-seen block and fast-announce a compact block \n+ * to compatible peers.\n+ */\n void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);\n     const CNetMsgMaker msgMaker(PROTOCOL_VERSION);\n@@ -888,10 +908,15 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n     });\n }\n \n+/**\n+ * Update our best height and announce any block hashes which weren't previously \n+ * in chainActive to our peers.\n+ */\n void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {\n     const int nNewHeight = pindexNew->nHeight;\n     connman->SetBestHeight(nNewHeight);\n \n+    SetServiceFlagsIBDCache(!fInitialDownload);\n     if (!fInitialDownload) {\n         // Find the hashes of all blocks that weren't previously in the best chain.\n         std::vector<uint256> vHashes;\n@@ -919,6 +944,10 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n     nTimeBestReceived = GetTime();\n }\n \n+/**\n+ * Handle invalid block rejection and consequent peer banning, maintain which \n+ * peers announce compact blocks.\n+ */\n void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n     LOCK(cs_main);\n \n@@ -988,7 +1017,7 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n-        return mapBlockIndex.count(inv.hash);\n+        return LookupBlockIndex(inv.hash) != nullptr;\n     }\n     // Don't know what it is, just say we already got one\n     return true;\n@@ -1055,11 +1084,10 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     bool need_activate_chain = false;\n     {\n         LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n-        if (mi != mapBlockIndex.end())\n-        {\n-            if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n-                    mi->second->IsValid(BLOCK_VALID_TREE)) {\n+        const CBlockIndex* pindex = LookupBlockIndex(inv.hash);\n+        if (pindex) {\n+            if (pindex->nChainTx && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                    pindex->IsValid(BLOCK_VALID_TREE)) {\n                 // If we have the block and all of its parents, but have not yet validated it,\n                 // we might be in the middle of connecting it (ie in the unlock of cs_main\n                 // before ActivateBestChain but after AcceptBlock).\n@@ -1075,17 +1103,17 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     }\n \n     LOCK(cs_main);\n-    BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n-    if (mi != mapBlockIndex.end()) {\n-        send = BlockRequestAllowed(mi->second, consensusParams);\n+    const CBlockIndex* pindex = LookupBlockIndex(inv.hash);\n+    if (pindex) {\n+        send = BlockRequestAllowed(pindex, consensusParams);\n         if (!send) {\n             LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n         }\n     }\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     // never disconnect whitelisted nodes\n-    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n     {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1095,7 +1123,7 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n     if (send && !pfrom->fWhitelisted && (\n-            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - mi->second->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n         LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n \n@@ -1105,15 +1133,15 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     }\n     // Pruned nodes may have deleted the block, so check whether\n     // it's available before trying to send.\n-    if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+    if (send && (pindex->nStatus & BLOCK_HAVE_DATA))\n     {\n         std::shared_ptr<const CBlock> pblock;\n-        if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+        if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {\n             pblock = a_recent_block;\n         } else {\n             // Send block from disk\n             std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n-            if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+            if (!ReadBlockFromDisk(*pblockRead, pindex, consensusParams))\n                 assert(!\"cannot load block from disk\");\n             pblock = pblockRead;\n         }\n@@ -1155,8 +1183,8 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n             // instead we respond with the full, non-compact block.\n             bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n             int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-            if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+            if (CanDirectFetch(consensusParams) && pindex->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n                     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                 } else {\n                     CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n@@ -1296,7 +1324,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         //   don't connect before giving DoS points\n         // - Once a headers message is received that is valid and does connect,\n         //   nUnconnectingHeaders gets reset back to 0.\n-        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+        if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n             connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n@@ -1326,7 +1354,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n \n         // If we don't have the last header, then they'll have given us\n         // something new (if these headers are valid).\n-        if (mapBlockIndex.find(hashLastBlock) == mapBlockIndex.end()) {\n+        if (!LookupBlockIndex(hashLastBlock)) {\n             received_new_header = true;\n         }\n     }\n@@ -1342,7 +1370,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             } else {\n                 LogPrint(BCLog::NET, \"peer=%d: invalid header received\\n\", pfrom->GetId());\n             }\n-            if (punish_duplicate_invalid && mapBlockIndex.find(first_invalid_header.GetHash()) != mapBlockIndex.end()) {\n+            if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {\n                 // Goal: don't allow outbound peers to use up our outbound\n                 // connection slots if they are on incompatible chains.\n                 //\n@@ -1642,7 +1670,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->cleanSubVer = cleanSubVer;\n         }\n         pfrom->nStartingHeight = nStartingHeight;\n-        pfrom->fClient = !(nServices & NODE_NETWORK);\n+\n+        // set nodes not relaying blocks and tx and not serving (parts) of the historical blockchain as \"clients\"\n+        pfrom->fClient = (!(nServices & NODE_NETWORK) && !(nServices & NODE_NETWORK_LIMITED));\n+\n+        // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n+        pfrom->m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n+\n         {\n             LOCK(pfrom->cs_filter);\n             pfrom->fRelayTxes = fRelay; // set to true after we get the first filter* message\n@@ -1801,7 +1835,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // We only bother storing full nodes, though this may include\n             // things which we would not make an outbound connection to, in\n             // part because we may make feeler connections to them.\n-            if (!MayHaveUsefulAddressDB(addr.nServices))\n+            if (!MayHaveUsefulAddressDB(addr.nServices) && !HasAllDesirableServiceFlags(addr.nServices))\n                 continue;\n \n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n@@ -2017,13 +2051,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n \n-        BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n-        if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n+        const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);\n+        if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n             LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n-        if (it->second->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {\n+        if (pindex->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {\n             // If an older block is requested (should never happen in practice,\n             // but can happen in tests) send a block response instead of a\n             // blocktxn response. Sending a full block response instead of a\n@@ -2041,7 +2075,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         CBlock block;\n-        bool ret = ReadBlockFromDisk(block, it->second, chainparams.GetConsensus());\n+        bool ret = ReadBlockFromDisk(block, pindex, chainparams.GetConsensus());\n         assert(ret);\n \n         SendBlockTransactions(block, req, pfrom, connman);\n@@ -2065,10 +2099,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (locator.IsNull())\n         {\n             // If locator is null, return the hashStop block\n-            BlockMap::iterator mi = mapBlockIndex.find(hashStop);\n-            if (mi == mapBlockIndex.end())\n+            pindex = LookupBlockIndex(hashStop);\n+            if (!pindex) {\n                 return true;\n-            pindex = (*mi).second;\n+            }\n \n             if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {\n                 LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());\n@@ -2307,14 +2341,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n         LOCK(cs_main);\n \n-        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+        if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n \n-        if (mapBlockIndex.find(cmpctblock.header.GetHash()) == mapBlockIndex.end()) {\n+        if (!LookupBlockIndex(cmpctblock.header.GetHash())) {\n             received_new_header = true;\n         }\n         }\n@@ -3296,9 +3330,8 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 // then send all headers past that one.  If we come across any\n                 // headers that aren't on chainActive, give up.\n                 for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n-                    BlockMap::iterator mi = mapBlockIndex.find(hash);\n-                    assert(mi != mapBlockIndex.end());\n-                    const CBlockIndex *pindex = mi->second;\n+                    const CBlockIndex* pindex = LookupBlockIndex(hash);\n+                    assert(pindex);\n                     if (chainActive[pindex->nHeight] != pindex) {\n                         // Bail out if we reorged away from this block\n                         fRevertToInv = true;\n@@ -3389,9 +3422,8 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n                 // in the past.\n                 if (!pto->vBlockHashesToAnnounce.empty()) {\n                     const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();\n-                    BlockMap::iterator mi = mapBlockIndex.find(hashToAnnounce);\n-                    assert(mi != mapBlockIndex.end());\n-                    const CBlockIndex *pindex = mi->second;\n+                    const CBlockIndex* pindex = LookupBlockIndex(hashToAnnounce);\n+                    assert(pindex);\n \n                     // Warn if we're announcing a block that is not on the main chain.\n                     // This should be very rare and could be optimized out.\n@@ -3611,7 +3643,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n         // Message: getdata (blocks)\n         //\n         std::vector<CInv> vGetData;\n-        if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);"
      },
      {
        "sha": "11543129cf94923dcd17ef51751c9fbebc1971c4",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -35,20 +35,33 @@ static constexpr int64_t EXTRA_PEER_CHECK_INTERVAL = 45;\n /** Minimum time an outbound-peer-eviction candidate must be connected for, in order to evict, in seconds */\n static constexpr int64_t MINIMUM_CONNECT_TIME = 30;\n \n-class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n+class PeerLogicValidation final : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* const connman;\n \n public:\n     explicit PeerLogicValidation(CConnman* connman, CScheduler &scheduler);\n \n+    /**\n+     * Overridden from CValidationInterface.\n+     */\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n+    /**\n+     * Overridden from CValidationInterface.\n+     */\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    /**\n+     * Overridden from CValidationInterface.\n+     */\n     void BlockChecked(const CBlock& block, const CValidationState& state) override;\n+    /**\n+     * Overridden from CValidationInterface.\n+     */\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n \n-\n+    /** Initialize a peer by adding it to mapNodeState and pushing a message requesting its version */\n     void InitializeNode(CNode* pnode) override;\n+    /** Handle removal of a peer by updating various state and removing it from mapNodeState */\n     void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) override;\n     /** Process protocol messages received from a given node */\n     bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n@@ -61,8 +74,11 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     */\n     bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n \n+    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n     void ConsiderEviction(CNode *pto, int64_t time_in_seconds);\n+    /** Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound */\n     void CheckForStaleTipAndEvictPeers(const Consensus::Params &consensusParams);\n+    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n     void EvictExtraOutboundPeers(int64_t time_in_seconds);\n \n private:"
      },
      {
        "sha": "ad6b55eb5894ac82247813187b47f7b45843b2d9",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -93,7 +93,7 @@ class CNetAddr\n \n         template <typename Stream, typename Operation>\n         inline void SerializationOp(Stream& s, Operation ser_action) {\n-            READWRITE(FLATDATA(ip));\n+            READWRITE(ip);\n         }\n \n         friend class CSubNet;\n@@ -131,8 +131,8 @@ class CSubNet\n         template <typename Stream, typename Operation>\n         inline void SerializationOp(Stream& s, Operation ser_action) {\n             READWRITE(network);\n-            READWRITE(FLATDATA(netmask));\n-            READWRITE(FLATDATA(valid));\n+            READWRITE(netmask);\n+            READWRITE(valid);\n         }\n };\n \n@@ -166,7 +166,7 @@ class CService : public CNetAddr\n \n         template <typename Stream, typename Operation>\n         inline void SerializationOp(Stream& s, Operation ser_action) {\n-            READWRITE(FLATDATA(ip));\n+            READWRITE(ip);\n             unsigned short portN = htons(port);\n             READWRITE(FLATDATA(portN));\n             if (ser_action.ForRead())"
      },
      {
        "sha": "92ac1c4c85c66f64e5bf7eb7d0a3f347a5122f7f",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -21,7 +21,7 @@\n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <boost/algorithm/string/predicate.hpp> // for startswith() and endswith()\n \n-#if !defined(HAVE_MSG_NOSIGNAL)\n+#if !defined(MSG_NOSIGNAL)\n #define MSG_NOSIGNAL 0\n #endif\n \n@@ -139,7 +139,7 @@ bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault,\n     if (pszName[0] == 0)\n         return false;\n     int port = portDefault;\n-    std::string hostname = \"\";\n+    std::string hostname;\n     SplitHostPort(std::string(pszName), port, hostname);\n \n     std::vector<CNetAddr> vIP;"
      },
      {
        "sha": "7f80fc92c2e22415088a1d06ea9279057c3bf19d",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -68,7 +68,7 @@ class TxConfirmStats;\n \n /* Identifier for each of the 3 different TxConfirmStats which will track\n  * history over different time horizons. */\n-enum FeeEstimateHorizon {\n+enum class FeeEstimateHorizon {\n     SHORT_HALFLIFE = 0,\n     MED_HALFLIFE = 1,\n     LONG_HALFLIFE = 2"
      },
      {
        "sha": "c3f65fb2ab9c7f769e528c75a62106bfd4d3cce4",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -179,7 +179,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         {\n             std::vector<std::vector<unsigned char> > stack;\n             // convert the scriptSig into a stack, so we can inspect the redeemScript\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;\n@@ -215,7 +215,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n             // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n             // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.\n             // If the check fails at this stage, we know that this txid must be a bad one.\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;\n@@ -258,3 +258,8 @@ int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost)\n {\n     return GetVirtualTransactionSize(GetTransactionWeight(tx), nSigOpCost);\n }\n+\n+int64_t GetVirtualTransactionInputSize(const CTxIn& txin, int64_t nSigOpCost)\n+{\n+    return GetVirtualTransactionSize(GetTransactionInputWeight(txin), nSigOpCost);\n+}"
      },
      {
        "sha": "e4eda4b6354081f3e097d0003ba224d9d5e58df4",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -102,5 +102,6 @@ extern unsigned int nBytesPerSigOp;\n /** Compute the virtual transaction size (weight reinterpreted as bytes). */\n int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost);\n int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost = 0);\n+int64_t GetVirtualTransactionInputSize(const CTxIn& tx, int64_t nSigOpCost = 0);\n \n #endif // BITCOIN_POLICY_POLICY_H"
      },
      {
        "sha": "81b2a7fadc5a8ad944a8a9bdeb52dcd6119cefc0",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -22,13 +22,13 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     // First check the transaction itself.\n     if (SignalsOptInRBF(tx)) {\n-        return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+        return RBFTransactionState::REPLACEABLE_BIP125;\n     }\n \n     // If this transaction is not in our mempool, then we can't be sure\n     // we will know about all its inputs.\n     if (!pool.exists(tx.GetHash())) {\n-        return RBF_TRANSACTIONSTATE_UNKNOWN;\n+        return RBFTransactionState::UNKNOWN;\n     }\n \n     // If all the inputs have nSequence >= maxint-1, it still might be\n@@ -40,8 +40,8 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n-            return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+            return RBFTransactionState::REPLACEABLE_BIP125;\n         }\n     }\n-    return RBF_TRANSACTIONSTATE_FINAL;\n+    return RBFTransactionState::FINAL;\n }"
      },
      {
        "sha": "b10532addf3ed2c0ac96d5c0f6b446bb3c29baaa",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,10 +9,10 @@\n \n static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n \n-enum RBFTransactionState {\n-    RBF_TRANSACTIONSTATE_UNKNOWN,\n-    RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125,\n-    RBF_TRANSACTIONSTATE_FINAL\n+enum class RBFTransactionState {\n+    UNKNOWN,\n+    REPLACEABLE_BIP125,\n+    FINAL\n };\n \n // Check whether the sequence numbers on this transaction are signaling"
      },
      {
        "sha": "103ead82ccb34fbe24622c05e67ab6d399710567",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 63,
        "deletions": 51,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,9 +10,12 @@\n #include <stdint.h>\n #include <string.h>\n \n+#include <cstddef>\n #include <iterator>\n #include <type_traits>\n \n+#include <compat.h>\n+\n #pragma pack(push, 1)\n /** Implements a drop-in replacement for std::vector<T> which stores up to N\n  *  elements directly (without heap allocation). The types Size and Diff are\n@@ -194,16 +197,42 @@ class prevector {\n     T* item_ptr(difference_type pos) { return is_direct() ? direct_ptr(pos) : indirect_ptr(pos); }\n     const T* item_ptr(difference_type pos) const { return is_direct() ? direct_ptr(pos) : indirect_ptr(pos); }\n \n+    void fill(T* dst, ptrdiff_t count) {\n+        if (IS_TRIVIALLY_CONSTRUCTIBLE<T>::value) {\n+            // The most common use of prevector is where T=unsigned char. For\n+            // trivially constructible types, we can use memset() to avoid\n+            // looping.\n+            ::memset(dst, 0, count * sizeof(T));\n+        } else {\n+            for (auto i = 0; i < count; ++i) {\n+                new(static_cast<void*>(dst + i)) T();\n+            }\n+        }\n+    }\n+\n+    void fill(T* dst, ptrdiff_t count, const T& value) {\n+        for (auto i = 0; i < count; ++i) {\n+            new(static_cast<void*>(dst + i)) T(value);\n+        }\n+    }\n+\n+    template<typename InputIterator>\n+    void fill(T* dst, InputIterator first, InputIterator last) {\n+        while (first != last) {\n+            new(static_cast<void*>(dst)) T(*first);\n+            ++dst;\n+            ++first;\n+        }\n+    }\n+\n public:\n     void assign(size_type n, const T& val) {\n         clear();\n         if (capacity() < n) {\n             change_capacity(n);\n         }\n-        while (size() < n) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T(val);\n-        }\n+        _size += n;\n+        fill(item_ptr(0), n, val);\n     }\n \n     template<typename InputIterator>\n@@ -213,11 +242,8 @@ class prevector {\n         if (capacity() < n) {\n             change_capacity(n);\n         }\n-        while (first != last) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T(*first);\n-            ++first;\n-        }\n+        _size += n;\n+        fill(item_ptr(0), first, last);\n     }\n \n     prevector() : _size(0), _union{{}} {}\n@@ -228,31 +254,23 @@ class prevector {\n \n     explicit prevector(size_type n, const T& val = T()) : _size(0) {\n         change_capacity(n);\n-        while (size() < n) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T(val);\n-        }\n+        _size += n;\n+        fill(item_ptr(0), n, val);\n     }\n \n     template<typename InputIterator>\n     prevector(InputIterator first, InputIterator last) : _size(0) {\n         size_type n = last - first;\n         change_capacity(n);\n-        while (first != last) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T(*first);\n-            ++first;\n-        }\n+        _size += n;\n+        fill(item_ptr(0), first, last);\n     }\n \n     prevector(const prevector<N, T, Size, Diff>& other) : _size(0) {\n-        change_capacity(other.size());\n-        const_iterator it = other.begin();\n-        while (it != other.end()) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T(*it);\n-            ++it;\n-        }\n+        size_type n = other.size();\n+        change_capacity(n);\n+        _size += n;\n+        fill(item_ptr(0), other.begin(),  other.end());\n     }\n \n     prevector(prevector<N, T, Size, Diff>&& other) : _size(0) {\n@@ -263,14 +281,7 @@ class prevector {\n         if (&other == this) {\n             return *this;\n         }\n-        resize(0);\n-        change_capacity(other.size());\n-        const_iterator it = other.begin();\n-        while (it != other.end()) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T(*it);\n-            ++it;\n-        }\n+        assign(other.begin(), other.end());\n         return *this;\n     }\n \n@@ -314,16 +325,20 @@ class prevector {\n     }\n \n     void resize(size_type new_size) {\n-        if (size() > new_size) {\n+        size_type cur_size = size();\n+        if (cur_size == new_size) {\n+            return;\n+        }\n+        if (cur_size > new_size) {\n             erase(item_ptr(new_size), end());\n+            return;\n         }\n         if (new_size > capacity()) {\n             change_capacity(new_size);\n         }\n-        while (size() < new_size) {\n-            _size++;\n-            new(static_cast<void*>(item_ptr(size() - 1))) T();\n-        }\n+        ptrdiff_t increase = new_size - cur_size;\n+        fill(item_ptr(cur_size), increase);\n+        _size += increase;\n     }\n \n     void reserve(size_type new_capacity) {\n@@ -346,10 +361,11 @@ class prevector {\n         if (capacity() < new_size) {\n             change_capacity(new_size + (new_size >> 1));\n         }\n-        memmove(item_ptr(p + 1), item_ptr(p), (size() - p) * sizeof(T));\n+        T* ptr = item_ptr(p);\n+        memmove(ptr + 1, ptr, (size() - p) * sizeof(T));\n         _size++;\n-        new(static_cast<void*>(item_ptr(p))) T(value);\n-        return iterator(item_ptr(p));\n+        new(static_cast<void*>(ptr)) T(value);\n+        return iterator(ptr);\n     }\n \n     void insert(iterator pos, size_type count, const T& value) {\n@@ -358,11 +374,10 @@ class prevector {\n         if (capacity() < new_size) {\n             change_capacity(new_size + (new_size >> 1));\n         }\n-        memmove(item_ptr(p + count), item_ptr(p), (size() - p) * sizeof(T));\n+        T* ptr = item_ptr(p);\n+        memmove(ptr + count, ptr, (size() - p) * sizeof(T));\n         _size += count;\n-        for (size_type i = 0; i < count; i++) {\n-            new(static_cast<void*>(item_ptr(p + i))) T(value);\n-        }\n+        fill(item_ptr(p), count, value);\n     }\n \n     template<typename InputIterator>\n@@ -373,13 +388,10 @@ class prevector {\n         if (capacity() < new_size) {\n             change_capacity(new_size + (new_size >> 1));\n         }\n-        memmove(item_ptr(p + count), item_ptr(p), (size() - p) * sizeof(T));\n+        T* ptr = item_ptr(p);\n+        memmove(ptr + count, ptr, (size() - p) * sizeof(T));\n         _size += count;\n-        while (first != last) {\n-            new(static_cast<void*>(item_ptr(p))) T(*first);\n-            ++p;\n-            ++first;\n-        }\n+        fill(ptr, first, last);\n     }\n \n     iterator erase(iterator pos) {"
      },
      {
        "sha": "2ec26fbd3e5fb5c7a63a7b36029c1df31218c2b0",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -12,6 +12,8 @@\n # include <arpa/inet.h>\n #endif\n \n+static std::atomic<bool> g_initial_block_download_completed(false);\n+\n namespace NetMsgType {\n const char *VERSION=\"version\";\n const char *VERACK=\"verack\";\n@@ -127,6 +129,17 @@ bool CMessageHeader::IsValid(const MessageStartChars& pchMessageStartIn) const\n }\n \n \n+ServiceFlags GetDesirableServiceFlags(ServiceFlags services) {\n+    if ((services & NODE_NETWORK_LIMITED) && g_initial_block_download_completed) {\n+        return ServiceFlags(NODE_NETWORK_LIMITED | NODE_WITNESS);\n+    }\n+    return ServiceFlags(NODE_NETWORK | NODE_WITNESS);\n+}\n+\n+void SetServiceFlagsIBDCache(bool state) {\n+    g_initial_block_download_completed = state;\n+}\n+\n \n CAddress::CAddress() : CService()\n {"
      },
      {
        "sha": "a07c5ea8624e8822d9d3d780f8ef98b6c2299690",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -15,6 +15,7 @@\n #include <uint256.h>\n #include <version.h>\n \n+#include <atomic>\n #include <stdint.h>\n #include <string>\n \n@@ -47,10 +48,10 @@ class CMessageHeader\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action)\n     {\n-        READWRITE(FLATDATA(pchMessageStart));\n-        READWRITE(FLATDATA(pchCommand));\n+        READWRITE(pchMessageStart);\n+        READWRITE(pchCommand);\n         READWRITE(nMessageSize);\n-        READWRITE(FLATDATA(pchChecksum));\n+        READWRITE(pchChecksum);\n     }\n \n     char pchMessageStart[MESSAGE_START_SIZE];\n@@ -301,9 +302,10 @@ enum ServiceFlags : uint64_t {\n  * If the NODE_NONE return value is changed, contrib/seeds/makeseeds.py\n  * should be updated appropriately to filter for the same nodes.\n  */\n-static ServiceFlags GetDesirableServiceFlags(ServiceFlags services) {\n-    return ServiceFlags(NODE_NETWORK | NODE_WITNESS);\n-}\n+ServiceFlags GetDesirableServiceFlags(ServiceFlags services);\n+\n+/** Set the current IBD status in order to figure out the desirable service flags */\n+void SetServiceFlagsIBDCache(bool status);\n \n /**\n  * A shortcut for (services & GetDesirableServiceFlags(services))\n@@ -316,10 +318,10 @@ static inline bool HasAllDesirableServiceFlags(ServiceFlags services) {\n \n /**\n  * Checks if a peer with the given service flags may be capable of having a\n- * robust address-storage DB. Currently an alias for checking NODE_NETWORK.\n+ * robust address-storage DB.\n  */\n static inline bool MayHaveUsefulAddressDB(ServiceFlags services) {\n-    return services & NODE_NETWORK;\n+    return (services & NODE_NETWORK) || (services & NODE_NETWORK_LIMITED);\n }\n \n /** A CService with information about it as peer */"
      },
      {
        "sha": "f2ddbf259bb9eca50123f2b21b075ee4bba9bd48",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 21,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -21,6 +21,41 @@\n #include <QMessageBox>\n #include <QSortFilterProxyModel>\n \n+class AddressBookSortFilterProxyModel final : public QSortFilterProxyModel\n+{\n+    const QString m_type;\n+\n+public:\n+    AddressBookSortFilterProxyModel(const QString& type, QObject* parent)\n+        : QSortFilterProxyModel(parent)\n+        , m_type(type)\n+    {\n+        setDynamicSortFilter(true);\n+        setFilterCaseSensitivity(Qt::CaseInsensitive);\n+        setSortCaseSensitivity(Qt::CaseInsensitive);\n+    }\n+\n+protected:\n+    bool filterAcceptsRow(int row, const QModelIndex& parent) const\n+    {\n+        auto model = sourceModel();\n+        auto label = model->index(row, AddressTableModel::Label, parent);\n+\n+        if (model->data(label, AddressTableModel::TypeRole).toString() != m_type) {\n+            return false;\n+        }\n+\n+        auto address = model->index(row, AddressTableModel::Address, parent);\n+\n+        if (filterRegExp().indexIn(model->data(address).toString()) < 0 &&\n+            filterRegExp().indexIn(model->data(label).toString()) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+};\n+\n AddressBookPage::AddressBookPage(const PlatformStyle *platformStyle, Mode _mode, Tabs _tab, QWidget *parent) :\n     QDialog(parent),\n     ui(new Ui::AddressBookPage),\n@@ -69,10 +104,12 @@ AddressBookPage::AddressBookPage(const PlatformStyle *platformStyle, Mode _mode,\n     case SendingTab:\n         ui->labelExplanation->setText(tr(\"These are your Bitcoin addresses for sending payments. Always check the amount and the receiving address before sending coins.\"));\n         ui->deleteAddress->setVisible(true);\n+        ui->newAddress->setVisible(true);\n         break;\n     case ReceivingTab:\n         ui->labelExplanation->setText(tr(\"These are your Bitcoin addresses for receiving payments. It is recommended to use a new receiving address for each transaction.\"));\n         ui->deleteAddress->setVisible(false);\n+        ui->newAddress->setVisible(false);\n         break;\n     }\n \n@@ -113,24 +150,12 @@ void AddressBookPage::setModel(AddressTableModel *_model)\n     if(!_model)\n         return;\n \n-    proxyModel = new QSortFilterProxyModel(this);\n+    auto type = tab == ReceivingTab ? AddressTableModel::Receive : AddressTableModel::Send;\n+    proxyModel = new AddressBookSortFilterProxyModel(type, this);\n     proxyModel->setSourceModel(_model);\n-    proxyModel->setDynamicSortFilter(true);\n-    proxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);\n-    proxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);\n-    switch(tab)\n-    {\n-    case ReceivingTab:\n-        // Receive filter\n-        proxyModel->setFilterRole(AddressTableModel::TypeRole);\n-        proxyModel->setFilterFixedString(AddressTableModel::Receive);\n-        break;\n-    case SendingTab:\n-        // Send filter\n-        proxyModel->setFilterRole(AddressTableModel::TypeRole);\n-        proxyModel->setFilterFixedString(AddressTableModel::Send);\n-        break;\n-    }\n+\n+    connect(ui->searchLineEdit, SIGNAL(textChanged(QString)), proxyModel, SLOT(setFilterWildcard(QString)));\n+\n     ui->tableView->setModel(proxyModel);\n     ui->tableView->sortByColumn(0, Qt::AscendingOrder);\n \n@@ -188,10 +213,11 @@ void AddressBookPage::on_newAddress_clicked()\n     if(!model)\n         return;\n \n-    EditAddressDialog dlg(\n-        tab == SendingTab ?\n-        EditAddressDialog::NewSendingAddress :\n-        EditAddressDialog::NewReceivingAddress, this);\n+    if (tab == ReceivingTab) {\n+        return;\n+    }\n+\n+    EditAddressDialog dlg(EditAddressDialog::NewSendingAddress, this);\n     dlg.setModel(model);\n     if(dlg.exec())\n     {"
      },
      {
        "sha": "8877d07330add1f600e4728ac9674340e6ffe55f",
        "filename": "src/qt/addressbookpage.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addressbookpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addressbookpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <QDialog>\n \n+class AddressBookSortFilterProxyModel;\n class AddressTableModel;\n class PlatformStyle;\n \n@@ -18,7 +19,6 @@ QT_BEGIN_NAMESPACE\n class QItemSelection;\n class QMenu;\n class QModelIndex;\n-class QSortFilterProxyModel;\n QT_END_NAMESPACE\n \n /** Widget that shows a list of sending or receiving addresses.\n@@ -53,7 +53,7 @@ public Q_SLOTS:\n     Mode mode;\n     Tabs tab;\n     QString returnValue;\n-    QSortFilterProxyModel *proxyModel;\n+    AddressBookSortFilterProxyModel *proxyModel;\n     QMenu *contextMenu;\n     QAction *deleteAction; // to be able to explicitly disable it\n     QString newAddressToSelect;"
      },
      {
        "sha": "801334483a2a2a118a51b335382ca1b1266241c7",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -7,10 +7,9 @@\n #include <qt/guiutil.h>\n #include <qt/walletmodel.h>\n \n-#include <base58.h>\n+#include <key_io.h>\n #include <wallet/wallet.h>\n \n-\n #include <QFont>\n #include <QDebug>\n \n@@ -442,6 +441,8 @@ int AddressTableModel::lookupAddress(const QString &address) const\n     }\n }\n \n+OutputType AddressTableModel::GetDefaultAddressType() const { return wallet->m_default_address_type; };\n+\n void AddressTableModel::emitDataChanged(int idx)\n {\n     Q_EMIT dataChanged(index(idx, 0, QModelIndex()), index(idx, columns.length()-1, QModelIndex()));"
      },
      {
        "sha": "ed7a4e6f4368f84cdfdc5c826a76d366a118e4fc",
        "filename": "src/qt/addresstablemodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addresstablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/addresstablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,7 +8,7 @@\n #include <QAbstractTableModel>\n #include <QStringList>\n \n-enum OutputType : int;\n+enum class OutputType;\n \n class AddressTablePriv;\n class WalletModel;\n@@ -76,6 +76,8 @@ class AddressTableModel : public QAbstractTableModel\n \n     EditStatus getEditStatus() const { return editStatus; }\n \n+    OutputType GetDefaultAddressType() const;\n+\n private:\n     WalletModel *walletModel;\n     CWallet *wallet;"
      },
      {
        "sha": "f853c0461723deddb1683f085dad83559dcbae67",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 12,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -29,12 +29,15 @@\n #include <init.h>\n #include <rpc/server.h>\n #include <ui_interface.h>\n+#include <uint256.h>\n #include <util.h>\n #include <warnings.h>\n \n #ifdef ENABLE_WALLET\n+#include <wallet/init.h>\n #include <wallet/wallet.h>\n #endif\n+#include <walletinitinterface.h>\n \n #include <stdint.h>\n \n@@ -80,6 +83,7 @@ Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin);\n // Declare meta types used for QMetaObject::invokeMethod\n Q_DECLARE_METATYPE(bool*)\n Q_DECLARE_METATYPE(CAmount)\n+Q_DECLARE_METATYPE(uint256)\n \n static void InitMessage(const std::string &message)\n {\n@@ -249,7 +253,7 @@ public Q_SLOTS:\n     QTimer *pollShutdownTimer;\n #ifdef ENABLE_WALLET\n     PaymentServer* paymentServer;\n-    WalletModel *walletModel;\n+    std::vector<WalletModel*> m_wallet_models;\n #endif\n     int returnValue;\n     const PlatformStyle *platformStyle;\n@@ -331,7 +335,7 @@ BitcoinApplication::BitcoinApplication(int &argc, char **argv):\n     pollShutdownTimer(0),\n #ifdef ENABLE_WALLET\n     paymentServer(0),\n-    walletModel(0),\n+    m_wallet_models(),\n #endif\n     returnValue(0)\n {\n@@ -449,8 +453,10 @@ void BitcoinApplication::requestShutdown()\n \n #ifdef ENABLE_WALLET\n     window->removeAllWallets();\n-    delete walletModel;\n-    walletModel = 0;\n+    for (WalletModel *walletModel : m_wallet_models) {\n+        delete walletModel;\n+    }\n+    m_wallet_models.clear();\n #endif\n     delete clientModel;\n     clientModel = 0;\n@@ -479,16 +485,20 @@ void BitcoinApplication::initializeResult(bool success)\n         window->setClientModel(clientModel);\n \n #ifdef ENABLE_WALLET\n-        // TODO: Expose secondary wallets\n-        if (!vpwallets.empty())\n-        {\n-            walletModel = new WalletModel(platformStyle, vpwallets[0], optionsModel);\n+        bool fFirstWallet = true;\n+        for (CWalletRef pwallet : vpwallets) {\n+            WalletModel * const walletModel = new WalletModel(platformStyle, pwallet, optionsModel);\n \n-            window->addWallet(BitcoinGUI::DEFAULT_WALLET, walletModel);\n-            window->setCurrentWallet(BitcoinGUI::DEFAULT_WALLET);\n+            window->addWallet(walletModel);\n+            if (fFirstWallet) {\n+                window->setCurrentWallet(walletModel->getWalletName());\n+                fFirstWallet = false;\n+            }\n \n             connect(walletModel, SIGNAL(coinsSent(CWallet*,SendCoinsRecipient,QByteArray)),\n                              paymentServer, SLOT(fetchPaymentACK(CWallet*,const SendCoinsRecipient&,QByteArray)));\n+\n+            m_wallet_models.push_back(walletModel);\n         }\n #endif\n \n@@ -615,7 +625,7 @@ int main(int argc, char *argv[])\n     if (!Intro::pickDataDirectory())\n         return EXIT_SUCCESS;\n \n-    /// 6. Determine availability of data directory and parse bitcoin.conf\n+    /// 6. Determine availability of data and blocks directory and parse bitcoin.conf\n     /// - Do not call GetDataDir(true) before this step finishes\n     if (!fs::is_directory(GetDataDir(false)))\n     {\n@@ -669,6 +679,11 @@ int main(int argc, char *argv[])\n     // Start up the payment server early, too, so impatient users that click on\n     // bitcoin: links repeatedly have their payment requests routed to this process:\n     app.createPaymentServer();\n+\n+    // Hook up the wallet init interface\n+    g_wallet_init_interface.reset(new WalletInit);\n+#else\n+    g_wallet_init_interface.reset(new DummyWalletInit);\n #endif\n \n     /// 9. Main GUI initialization\n@@ -688,7 +703,7 @@ int main(int argc, char *argv[])\n     // Allow parameter interaction before we create the options model\n     app.parameterSetup();\n     // Load GUI settings from QSettings\n-    app.createOptionsModel(gArgs.IsArgSet(\"-resetguisettings\"));\n+    app.createOptionsModel(gArgs.GetBoolArg(\"-resetguisettings\", false));\n \n     // Subscribe to global signals from core\n     uiInterface.InitMessage.connect(InitMessage);"
      },
      {
        "sha": "6a76358a7834561c2c81d0df633c6d1ba967a3eb",
        "filename": "src/qt/bitcoinaddressvalidator.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoinaddressvalidator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoinaddressvalidator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinaddressvalidator.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <qt/bitcoinaddressvalidator.h>\n \n-#include <base58.h>\n+#include <key_io.h>\n \n /* Base58 characters are:\n      \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\""
      },
      {
        "sha": "e4207fce99b8fe0e13d535f24559a59ca52dd43b",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 13,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -21,6 +21,7 @@\n #ifdef ENABLE_WALLET\n #include <qt/walletframe.h>\n #include <qt/walletmodel.h>\n+#include <qt/walletview.h>\n #endif // ENABLE_WALLET\n \n #ifdef Q_OS_MAC\n@@ -36,6 +37,7 @@\n \n #include <QAction>\n #include <QApplication>\n+#include <QComboBox>\n #include <QDateTime>\n #include <QDesktopWidget>\n #include <QDragEnterEvent>\n@@ -70,10 +72,6 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n #endif\n         ;\n \n-/** Display name for default wallet name. Uses tilde to avoid name\n- * collisions in the future with additional wallets */\n-const QString BitcoinGUI::DEFAULT_WALLET = \"~Default\";\n-\n BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     enableWallet(false),\n@@ -88,6 +86,7 @@ BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *\n     progressBar(0),\n     progressDialog(0),\n     appMenuBar(0),\n+    appToolBar(0),\n     overviewAction(0),\n     historyAction(0),\n     quitAction(0),\n@@ -455,6 +454,7 @@ void BitcoinGUI::createToolBars()\n     if(walletFrame)\n     {\n         QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n+        appToolBar = toolbar;\n         toolbar->setContextMenuPolicy(Qt::PreventContextMenu);\n         toolbar->setMovable(false);\n         toolbar->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\n@@ -463,6 +463,15 @@ void BitcoinGUI::createToolBars()\n         toolbar->addAction(receiveCoinsAction);\n         toolbar->addAction(historyAction);\n         overviewAction->setChecked(true);\n+\n+#ifdef ENABLE_WALLET\n+        QWidget *spacer = new QWidget();\n+        spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n+        toolbar->addWidget(spacer);\n+\n+        m_wallet_selector = new QComboBox();\n+        connect(m_wallet_selector, SIGNAL(currentIndexChanged(const QString&)), this, SLOT(setCurrentWallet(const QString&)));\n+#endif\n     }\n }\n \n@@ -529,12 +538,22 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n }\n \n #ifdef ENABLE_WALLET\n-bool BitcoinGUI::addWallet(const QString& name, WalletModel *walletModel)\n+bool BitcoinGUI::addWallet(WalletModel *walletModel)\n {\n     if(!walletFrame)\n         return false;\n+    const QString name = walletModel->getWalletName();\n     setWalletActionsEnabled(true);\n-    return walletFrame->addWallet(name, walletModel);\n+    m_wallet_selector->addItem(name);\n+    if (m_wallet_selector->count() == 2) {\n+        m_wallet_selector_label = new QLabel();\n+        m_wallet_selector_label->setText(tr(\"Wallet:\") + \" \");\n+        m_wallet_selector_label->setBuddy(m_wallet_selector);\n+        appToolBar->addWidget(m_wallet_selector_label);\n+        appToolBar->addWidget(m_wallet_selector);\n+    }\n+    rpcConsole->addWallet(walletModel);\n+    return walletFrame->addWallet(walletModel);\n }\n \n bool BitcoinGUI::setCurrentWallet(const QString& name)\n@@ -780,25 +799,25 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer\n     // Acquire current block source\n     enum BlockSource blockSource = clientModel->getBlockSource();\n     switch (blockSource) {\n-        case BLOCK_SOURCE_NETWORK:\n+        case BlockSource::NETWORK:\n             if (header) {\n                 updateHeadersSyncProgressLabel();\n                 return;\n             }\n             progressBarLabel->setText(tr(\"Synchronizing with network...\"));\n             updateHeadersSyncProgressLabel();\n             break;\n-        case BLOCK_SOURCE_DISK:\n+        case BlockSource::DISK:\n             if (header) {\n                 progressBarLabel->setText(tr(\"Indexing blocks on disk...\"));\n             } else {\n                 progressBarLabel->setText(tr(\"Processing blocks on disk...\"));\n             }\n             break;\n-        case BLOCK_SOURCE_REINDEX:\n+        case BlockSource::REINDEX:\n             progressBarLabel->setText(tr(\"Reindexing blocks on disk...\"));\n             break;\n-        case BLOCK_SOURCE_NONE:\n+        case BlockSource::NONE:\n             if (header) {\n                 return;\n             }\n@@ -923,6 +942,7 @@ void BitcoinGUI::message(const QString &title, const QString &message, unsigned\n \n         showNormalIfMinimized();\n         QMessageBox mBox(static_cast<QMessageBox::Icon>(nMBoxIcon), strTitle, message, buttons, this);\n+        mBox.setTextFormat(Qt::PlainText);\n         int r = mBox.exec();\n         if (ret != nullptr)\n             *ret = r == QMessageBox::Ok;\n@@ -982,12 +1002,15 @@ void BitcoinGUI::showEvent(QShowEvent *event)\n }\n \n #ifdef ENABLE_WALLET\n-void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label)\n+void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName)\n {\n     // On new transaction, make an info balloon\n     QString msg = tr(\"Date: %1\\n\").arg(date) +\n-                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true)) +\n-                  tr(\"Type: %1\\n\").arg(type);\n+                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true));\n+    if (WalletModel::isMultiwallet() && !walletName.isEmpty()) {\n+        msg += tr(\"Wallet: %1\\n\").arg(walletName);\n+    }\n+    msg += tr(\"Type: %1\\n\").arg(type);\n     if (!label.isEmpty())\n         msg += tr(\"Label: %1\\n\").arg(label);\n     else if (!address.isEmpty())\n@@ -1078,6 +1101,20 @@ void BitcoinGUI::setEncryptionStatus(int status)\n         break;\n     }\n }\n+\n+void BitcoinGUI::updateWalletStatus()\n+{\n+    if (!walletFrame) {\n+        return;\n+    }\n+    WalletView * const walletView = walletFrame->currentWalletView();\n+    if (!walletView) {\n+        return;\n+    }\n+    WalletModel * const walletModel = walletView->getWalletModel();\n+    setEncryptionStatus(walletModel->getEncryptionStatus());\n+    setHDStatus(walletModel->hdEnabled());\n+}\n #endif // ENABLE_WALLET\n \n void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)"
      },
      {
        "sha": "b9e92f2d5bafbfeaf21e9c303de5347f3796005c",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -33,6 +33,7 @@ class ModalOverlay;\n \n QT_BEGIN_NAMESPACE\n class QAction;\n+class QComboBox;\n class QProgressBar;\n class QProgressDialog;\n QT_END_NAMESPACE\n@@ -46,7 +47,6 @@ class BitcoinGUI : public QMainWindow\n     Q_OBJECT\n \n public:\n-    static const QString DEFAULT_WALLET;\n     static const std::string DEFAULT_UIPLATFORM;\n \n     explicit BitcoinGUI(const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent = 0);\n@@ -62,8 +62,7 @@ class BitcoinGUI : public QMainWindow\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n         functionality.\n     */\n-    bool addWallet(const QString& name, WalletModel *walletModel);\n-    bool setCurrentWallet(const QString& name);\n+    bool addWallet(WalletModel *walletModel);\n     void removeAllWallets();\n #endif // ENABLE_WALLET\n     bool enableWallet;\n@@ -90,6 +89,7 @@ class BitcoinGUI : public QMainWindow\n     QProgressDialog *progressDialog;\n \n     QMenuBar *appMenuBar;\n+    QToolBar *appToolBar;\n     QAction *overviewAction;\n     QAction *historyAction;\n     QAction *quitAction;\n@@ -112,6 +112,9 @@ class BitcoinGUI : public QMainWindow\n     QAction *openAction;\n     QAction *showHelpMessageAction;\n \n+    QLabel *m_wallet_selector_label;\n+    QComboBox *m_wallet_selector;\n+\n     QSystemTrayIcon *trayIcon;\n     QMenu *trayIconMenu;\n     Notificator *notificator;\n@@ -171,6 +174,12 @@ public Q_SLOTS:\n     void message(const QString &title, const QString &message, unsigned int style, bool *ret = nullptr);\n \n #ifdef ENABLE_WALLET\n+    bool setCurrentWallet(const QString& name);\n+    /** Set the UI status indicators based on the currently selected wallet.\n+    */\n+    void updateWalletStatus();\n+\n+private:\n     /** Set the encryption status as shown in the UI.\n        @param[in] status            current encryption status\n        @see WalletModel::EncryptionStatus\n@@ -183,10 +192,11 @@ public Q_SLOTS:\n      */\n     void setHDStatus(int hdEnabled);\n \n+public Q_SLOTS:\n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);\n \n     /** Show incoming transaction notification for new transactions. */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n #endif // ENABLE_WALLET\n \n private Q_SLOTS:"
      },
      {
        "sha": "40661d9ec313f1b07c5e1761681281968c86fbcb",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -138,9 +138,9 @@ size_t ClientModel::getMempoolDynamicUsage() const\n double ClientModel::getVerificationProgress(const CBlockIndex *tipIn) const\n {\n     CBlockIndex *tip = const_cast<CBlockIndex *>(tipIn);\n+    LOCK(cs_main);\n     if (!tip)\n     {\n-        LOCK(cs_main);\n         tip = chainActive.Tip();\n     }\n     return GuessVerificationProgress(Params().TxData(), tip);\n@@ -177,13 +177,13 @@ bool ClientModel::inInitialBlockDownload() const\n enum BlockSource ClientModel::getBlockSource() const\n {\n     if (fReindex)\n-        return BLOCK_SOURCE_REINDEX;\n+        return BlockSource::REINDEX;\n     else if (fImporting)\n-        return BLOCK_SOURCE_DISK;\n+        return BlockSource::DISK;\n     else if (getNumConnections() > 0)\n-        return BLOCK_SOURCE_NETWORK;\n+        return BlockSource::NETWORK;\n \n-    return BLOCK_SOURCE_NONE;\n+    return BlockSource::NONE;\n }\n \n void ClientModel::setNetworkActive(bool active)"
      },
      {
        "sha": "1118bc31b347d2b4f5ed89f754bfce26542424d3",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -20,11 +20,11 @@ QT_BEGIN_NAMESPACE\n class QTimer;\n QT_END_NAMESPACE\n \n-enum BlockSource {\n-    BLOCK_SOURCE_NONE,\n-    BLOCK_SOURCE_REINDEX,\n-    BLOCK_SOURCE_DISK,\n-    BLOCK_SOURCE_NETWORK\n+enum class BlockSource {\n+    NONE,\n+    REINDEX,\n+    DISK,\n+    NETWORK\n };\n \n enum NumConnections {"
      },
      {
        "sha": "a45e9f85c18c3eb8b7c01f4585f3297a541e5515",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -15,6 +15,7 @@\n \n #include <wallet/coincontrol.h>\n #include <init.h>\n+#include <key_io.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <validation.h> // For mempool\n@@ -205,7 +206,7 @@ void CoinControlDialog::showMenu(const QPoint &point)\n         contextMenuItem = item;\n \n         // disable some items (like Copy Transaction ID, lock, unlock) for tree roots in context menu\n-        if (item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means its a child node, so its not a parent node in tree mode)\n+        if (item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n         {\n             copyTransactionHashAction->setEnabled(true);\n             if (model->isLockedCoin(uint256S(item->text(COLUMN_TXHASH).toStdString()), item->text(COLUMN_VOUT_INDEX).toUInt()))\n@@ -373,7 +374,7 @@ void CoinControlDialog::radioListMode(bool checked)\n // checkbox clicked by user\n void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n {\n-    if (column == COLUMN_CHECKBOX && item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means its a child node, so its not a parent node in tree mode)\n+    if (column == COLUMN_CHECKBOX && item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n     {\n         COutPoint outpt(uint256S(item->text(COLUMN_TXHASH).toStdString()), item->text(COLUMN_VOUT_INDEX).toUInt());\n "
      },
      {
        "sha": "38411c499f26631f801bbfdca748e09b78c81c1b",
        "filename": "src/qt/editaddressdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/editaddressdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/editaddressdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/editaddressdialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -11,7 +11,6 @@\n #include <QDataWidgetMapper>\n #include <QMessageBox>\n \n-extern OutputType g_address_type;\n \n EditAddressDialog::EditAddressDialog(Mode _mode, QWidget *parent) :\n     QDialog(parent),\n@@ -26,10 +25,6 @@ EditAddressDialog::EditAddressDialog(Mode _mode, QWidget *parent) :\n \n     switch(mode)\n     {\n-    case NewReceivingAddress:\n-        setWindowTitle(tr(\"New receiving address\"));\n-        ui->addressEdit->setEnabled(false);\n-        break;\n     case NewSendingAddress:\n         setWindowTitle(tr(\"New sending address\"));\n         break;\n@@ -74,13 +69,12 @@ bool EditAddressDialog::saveCurrentRow()\n \n     switch(mode)\n     {\n-    case NewReceivingAddress:\n     case NewSendingAddress:\n         address = model->addRow(\n-                mode == NewSendingAddress ? AddressTableModel::Send : AddressTableModel::Receive,\n+                AddressTableModel::Send,\n                 ui->labelEdit->text(),\n                 ui->addressEdit->text(),\n-                g_address_type);\n+                model->GetDefaultAddressType());\n         break;\n     case EditReceivingAddress:\n     case EditSendingAddress:"
      },
      {
        "sha": "41c5d1708a84035de77fd30e498899aa24381ea9",
        "filename": "src/qt/editaddressdialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/editaddressdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/editaddressdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/editaddressdialog.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -25,7 +25,6 @@ class EditAddressDialog : public QDialog\n \n public:\n     enum Mode {\n-        NewReceivingAddress,\n         NewSendingAddress,\n         EditReceivingAddress,\n         EditSendingAddress"
      },
      {
        "sha": "7ac216286c8d6b36d4f799c30040f74714e32951",
        "filename": "src/qt/forms/addressbookpage.ui",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/addressbookpage.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/addressbookpage.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/addressbookpage.ui?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -21,6 +21,13 @@\n      </property>\n     </widget>\n    </item>\n+   <item>\n+    <widget class=\"QLineEdit\" name=\"searchLineEdit\">\n+     <property name=\"placeholderText\">\n+      <string>Enter address or label to search</string>\n+     </property>\n+    </widget>\n+   </item>\n    <item>\n     <widget class=\"QTableView\" name=\"tableView\">\n      <property name=\"contextMenuPolicy\">"
      },
      {
        "sha": "695ed61228a4007283da4f7d3be95b21be0c02e0",
        "filename": "src/qt/forms/debugwindow.ui",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/debugwindow.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/debugwindow.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/debugwindow.ui?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -412,6 +412,22 @@\n          <property name=\"spacing\">\n           <number>4</number>\n          </property>\n+         <item>\n+          <widget class=\"QLabel\" name=\"WalletSelectorLabel\">\n+           <property name=\"text\">\n+            <string>Wallet: </string>\n+           </property>\n+          </widget>\n+         </item>\n+         <item>\n+          <widget class=\"QComboBox\" name=\"WalletSelector\">\n+           <item>\n+            <property name=\"text\">\n+             <string>(none)</string>\n+            </property>\n+           </item>\n+          </widget>\n+         </item>\n          <item>\n           <spacer name=\"horizontalSpacer\">\n            <property name=\"orientation\">"
      },
      {
        "sha": "b5a69c578d0682073727b399ecc24c58ddd2df31",
        "filename": "src/qt/forms/modaloverlay.ui",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/modaloverlay.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/modaloverlay.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/modaloverlay.ui?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -351,6 +351,12 @@ QLabel { color: rgb(40,40,40);  }</string>\n              <property name=\"text\">\n               <string>Hide</string>\n              </property>\n+             <property name=\"focusPolicy\">\n+              <enum>Qt::StrongFocus</enum>\n+             </property>\n+             <property name=\"default\">\n+              <bool>true</bool>\n+             </property>\n             </widget>\n            </item>\n           </layout>"
      },
      {
        "sha": "6b31ddea9094e98497d66abe55cf408607306789",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -848,7 +848,9 @@\n                  <item>\n                   <widget class=\"QLabel\" name=\"labelCustomPerKilobyte\">\n                    <property name=\"toolTip\">\n-                    <string>If the custom fee is set to 1000 satoshis and the transaction is only 250 bytes, then &quot;per kilobyte&quot; only pays 250 satoshis in fee, while &quot;total at least&quot; pays 1000 satoshis. For transactions bigger than a kilobyte both pay by kilobyte.</string>\n+                    <string>Specify a custom fee per kB (1,000 bytes) of the transaction's virtual size.\n+\n+Note:  Since the fee is calculated on a per-byte basis, a fee of \"100 satoshis per kB\" for a transaction size of 500 bytes (half of 1 kB) would ultimately yield a fee of only 50 satoshis.</string>\n                    </property>\n                    <property name=\"text\">\n                     <string>per kilobyte</string>"
      },
      {
        "sha": "7b653a99da49fe5681003b4a0a4cef365ca589a9",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 17,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,7 +9,10 @@\n #include <qt/qvalidatedlineedit.h>\n #include <qt/walletmodel.h>\n \n+#include <base58.h>\n+#include <chainparams.h>\n #include <primitives/transaction.h>\n+#include <key_io.h>\n #include <init.h>\n #include <policy/policy.h>\n #include <protocol.h>\n@@ -134,15 +137,6 @@ void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent)\n     widget->setCheckValidator(new BitcoinAddressCheckValidator(parent));\n }\n \n-void setupAmountWidget(QLineEdit *widget, QWidget *parent)\n-{\n-    QDoubleValidator *amountValidator = new QDoubleValidator(parent);\n-    amountValidator->setDecimals(8);\n-    amountValidator->setBottom(0.0);\n-    widget->setValidator(amountValidator);\n-    widget->setAlignment(Qt::AlignRight|Qt::AlignVCenter);\n-}\n-\n bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n {\n     // return if URI is not valid or is no bitcoin: URI\n@@ -206,14 +200,6 @@ bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n \n bool parseBitcoinURI(QString uri, SendCoinsRecipient *out)\n {\n-    // Convert bitcoin:// to bitcoin:\n-    //\n-    //    Cannot handle this later, because bitcoin:// will cause Qt to see the part after // as host,\n-    //    which will lower-case it (and thus invalidate the address).\n-    if(uri.startsWith(\"bitcoin://\", Qt::CaseInsensitive))\n-    {\n-        uri.replace(0, 10, \"bitcoin:\");\n-    }\n     QUrl uriInstance(uri);\n     return parseBitcoinURI(uriInstance, out);\n }"
      },
      {
        "sha": "bbbeaf2c43d184621cd0b7c059e88aeffe9bc13d",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -40,9 +40,8 @@ namespace GUIUtil\n     // Return a monospace font\n     QFont fixedPitchFont();\n \n-    // Set up widgets for address and amounts\n+    // Set up widget for address\n     void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent);\n-    void setupAmountWidget(QLineEdit *widget, QWidget *parent);\n \n     // Parse \"bitcoin:\" URI into recipient object, return true on successful parsing\n     bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out);\n@@ -141,7 +140,7 @@ namespace GUIUtil\n      * Makes a QTableView last column feel as if it was being resized from its left border.\n      * Also makes sure the column widths are never larger than the table's viewport.\n      * In Qt, all columns are resizable from the right, but it's not intuitive resizing the last column from the right.\n-     * Usually our second to last columns behave as if stretched, and when on strech mode, columns aren't resizable\n+     * Usually our second to last columns behave as if stretched, and when on stretch mode, columns aren't resizable\n      * interactively or programmatically.\n      *\n      * This helper object takes care of this issue."
      },
      {
        "sha": "249418213f67777343ad416d543979c572946703",
        "filename": "src/qt/modaloverlay.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/modaloverlay.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/modaloverlay.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -81,7 +81,7 @@ void ModalOverlay::tipUpdate(int count, const QDateTime& blockDate, double nVeri\n     // keep a vector of samples of verification progress at height\n     blockProcessTime.push_front(qMakePair(currentDate.toMSecsSinceEpoch(), nVerificationProgress));\n \n-    // show progress speed if we have more then one sample\n+    // show progress speed if we have more than one sample\n     if (blockProcessTime.size() >= 2) {\n         double progressDelta = 0;\n         double progressPerHour = 0;"
      },
      {
        "sha": "357e98a53c6c5b632195a7ca9f22f248688c4fee",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <qt/paymentrequestplus.h>\n \n+#include <script/script.h>\n #include <util.h>\n \n #include <stdexcept>"
      },
      {
        "sha": "b1b60cf582dbd970d80a583dabf1f4ace73b6404",
        "filename": "src/qt/paymentrequestplus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/paymentrequestplus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/paymentrequestplus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,7 +10,8 @@\n #include <qt/paymentrequest.pb.h>\n #pragma GCC diagnostic pop\n \n-#include <base58.h>\n+#include <amount.h>\n+#include <script/script.h>\n \n #include <openssl/x509.h>\n "
      },
      {
        "sha": "65ef250440b1b46362e67eecd541b2241f7bc2ad",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,9 +8,9 @@\n #include <qt/guiutil.h>\n #include <qt/optionsmodel.h>\n \n-#include <base58.h>\n #include <chainparams.h>\n #include <policy/policy.h>\n+#include <key_io.h>\n #include <ui_interface.h>\n #include <util.h>\n #include <wallet/wallet.h>\n@@ -404,7 +404,12 @@ void PaymentServer::handleURIOrFile(const QString& s)\n         return;\n     }\n \n-    if (s.startsWith(BITCOIN_IPC_PREFIX, Qt::CaseInsensitive)) // bitcoin: URI\n+    if (s.startsWith(\"bitcoin://\", Qt::CaseInsensitive))\n+    {\n+        Q_EMIT message(tr(\"URI handling\"), tr(\"'bitcoin://' is not a valid URI. Use 'bitcoin:' instead.\"),\n+            CClientUIInterface::MSG_ERROR);\n+    }\n+    else if (s.startsWith(BITCOIN_IPC_PREFIX, Qt::CaseInsensitive)) // bitcoin: URI\n     {\n #if QT_VERSION < 0x050000\n         QUrl uri(s);\n@@ -634,19 +639,18 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, const SendCoinsRecipient& r\n     payment.add_transactions(transaction.data(), transaction.size());\n \n     // Create a new refund address, or re-use:\n-    QString account = tr(\"Refund from %1\").arg(recipient.authenticatedMerchant);\n-    std::string strAccount = account.toStdString();\n     CPubKey newKey;\n     if (wallet->GetKeyFromPool(newKey)) {\n         // BIP70 requests encode the scriptPubKey directly, so we are not restricted to address\n         // types supported by the receiver. As a result, we choose the address format we also\n         // use for change. Despite an actual payment and not change, this is a close match:\n         // it's the output type we use subject to privacy issues, but not restricted by what\n         // other software supports.\n-        const OutputType change_type = g_change_type != OUTPUT_TYPE_NONE ? g_change_type : g_address_type;\n+        const OutputType change_type = wallet->m_default_change_type != OutputType::NONE ? wallet->m_default_change_type : wallet->m_default_address_type;\n         wallet->LearnRelatedScripts(newKey, change_type);\n         CTxDestination dest = GetDestinationForKey(newKey, change_type);\n-        wallet->SetAddressBook(dest, strAccount, \"refund\");\n+        std::string label = tr(\"Refund from %1\").arg(recipient.authenticatedMerchant).toStdString();\n+        wallet->SetAddressBook(dest, label, \"refund\");\n \n         CScript s = GetScriptForDestination(dest);\n         payments::Output* refund_to = payment.add_refund_to();\n@@ -770,7 +774,7 @@ bool PaymentServer::verifyExpired(const payments::PaymentDetails& requestDetails\n {\n     bool fVerified = (requestDetails.has_expires() && (int64_t)requestDetails.expires() < GetTime());\n     if (fVerified) {\n-        const QString requestExpires = QString::fromStdString(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", (int64_t)requestDetails.expires()));\n+        const QString requestExpires = QString::fromStdString(FormatISO8601DateTime((int64_t)requestDetails.expires()));\n         qWarning() << QString(\"PaymentServer::%1: Payment request expired \\\"%2\\\".\")\n             .arg(__func__)\n             .arg(requestExpires);"
      },
      {
        "sha": "c8b6366db054aa190a220fcfead4d8ab1bfe6ef6",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -95,13 +95,13 @@ void ReceiveCoinsDialog::setModel(WalletModel *_model)\n         columnResizingFixer = new GUIUtil::TableViewLastColumnResizingFixer(tableView, AMOUNT_MINIMUM_COLUMN_WIDTH, DATE_COLUMN_WIDTH, this);\n \n         // configure bech32 checkbox, disable if launched with legacy as default:\n-        if (model->getDefaultAddressType() == OUTPUT_TYPE_BECH32) {\n+        if (model->getDefaultAddressType() == OutputType::BECH32) {\n             ui->useBech32->setCheckState(Qt::Checked);\n         } else {\n             ui->useBech32->setCheckState(Qt::Unchecked);\n         }\n \n-        ui->useBech32->setVisible(model->getDefaultAddressType() != OUTPUT_TYPE_LEGACY);\n+        ui->useBech32->setVisible(model->getDefaultAddressType() != OutputType::LEGACY);\n     }\n }\n \n@@ -145,15 +145,15 @@ void ReceiveCoinsDialog::on_receiveButton_clicked()\n     QString label = ui->reqLabel->text();\n     /* Generate new receiving address */\n     OutputType address_type = model->getDefaultAddressType();\n-    if (address_type != OUTPUT_TYPE_LEGACY) {\n-        address_type = ui->useBech32->isChecked() ? OUTPUT_TYPE_BECH32 : OUTPUT_TYPE_P2SH_SEGWIT;\n+    if (address_type != OutputType::LEGACY) {\n+        address_type = ui->useBech32->isChecked() ? OutputType::BECH32 : OutputType::P2SH_SEGWIT;\n     }\n     address = model->getAddressTableModel()->addRow(AddressTableModel::Receive, label, \"\", address_type);\n     SendCoinsRecipient info(address, label,\n         ui->reqAmount->value(), ui->reqMessage->text());\n     ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);\n     dialog->setAttribute(Qt::WA_DeleteOnClose);\n-    dialog->setModel(model->getOptionsModel());\n+    dialog->setModel(model);\n     dialog->setInfo(info);\n     dialog->show();\n     clear();\n@@ -166,7 +166,7 @@ void ReceiveCoinsDialog::on_recentRequestsView_doubleClicked(const QModelIndex &\n {\n     const RecentRequestsTableModel *submodel = model->getRecentRequestsTableModel();\n     ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);\n-    dialog->setModel(model->getOptionsModel());\n+    dialog->setModel(model);\n     dialog->setInfo(submodel->entry(index.row()).recipient);\n     dialog->setAttribute(Qt::WA_DeleteOnClose);\n     dialog->show();"
      },
      {
        "sha": "75146e22141b911508cbdb46de19e826f5b484a7",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -108,12 +108,12 @@ ReceiveRequestDialog::~ReceiveRequestDialog()\n     delete ui;\n }\n \n-void ReceiveRequestDialog::setModel(OptionsModel *_model)\n+void ReceiveRequestDialog::setModel(WalletModel *_model)\n {\n     this->model = _model;\n \n     if (_model)\n-        connect(_model, SIGNAL(displayUnitChanged(int)), this, SLOT(update()));\n+        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(update()));\n \n     // update the display unit if necessary\n     update();\n@@ -143,11 +143,14 @@ void ReceiveRequestDialog::update()\n     html += \"<a href=\\\"\"+uri+\"\\\">\" + GUIUtil::HtmlEscape(uri) + \"</a><br>\";\n     html += \"<b>\"+tr(\"Address\")+\"</b>: \" + GUIUtil::HtmlEscape(info.address) + \"<br>\";\n     if(info.amount)\n-        html += \"<b>\"+tr(\"Amount\")+\"</b>: \" + BitcoinUnits::formatHtmlWithUnit(model->getDisplayUnit(), info.amount) + \"<br>\";\n+        html += \"<b>\"+tr(\"Amount\")+\"</b>: \" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), info.amount) + \"<br>\";\n     if(!info.label.isEmpty())\n         html += \"<b>\"+tr(\"Label\")+\"</b>: \" + GUIUtil::HtmlEscape(info.label) + \"<br>\";\n     if(!info.message.isEmpty())\n         html += \"<b>\"+tr(\"Message\")+\"</b>: \" + GUIUtil::HtmlEscape(info.message) + \"<br>\";\n+    if(model->isMultiwallet()) {\n+        html += \"<b>\"+tr(\"Wallet\")+\"</b>: \" + GUIUtil::HtmlEscape(model->getWalletName()) + \"<br>\";\n+    }\n     ui->outUri->setText(html);\n \n #ifdef USE_QRCODE"
      },
      {
        "sha": "23c5529535c1938bdc211530fb8127fceda08722",
        "filename": "src/qt/receiverequestdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/receiverequestdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/receiverequestdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -12,8 +12,6 @@\n #include <QLabel>\n #include <QPainter>\n \n-class OptionsModel;\n-\n namespace Ui {\n     class ReceiveRequestDialog;\n }\n@@ -53,7 +51,7 @@ class ReceiveRequestDialog : public QDialog\n     explicit ReceiveRequestDialog(QWidget *parent = 0);\n     ~ReceiveRequestDialog();\n \n-    void setModel(OptionsModel *model);\n+    void setModel(WalletModel *model);\n     void setInfo(const SendCoinsRecipient &info);\n \n private Q_SLOTS:\n@@ -64,7 +62,7 @@ private Q_SLOTS:\n \n private:\n     Ui::ReceiveRequestDialog *ui;\n-    OptionsModel *model;\n+    WalletModel *model;\n     SendCoinsRecipient info;\n };\n "
      },
      {
        "sha": "f045053c3b91b12dac6442096f532ece9a7d53bd",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -139,10 +139,9 @@ bool RecentRequestsTableModel::removeRows(int row, int count, const QModelIndex\n \n     if(count > 0 && row >= 0 && (row+count) <= list.size())\n     {\n-        const RecentRequestEntry *rec;\n         for (int i = 0; i < count; ++i)\n         {\n-            rec = &list[row+i];\n+            const RecentRequestEntry* rec = &list[row+i];\n             if (!walletModel->saveReceiveRequest(rec->recipient.address.toStdString(), rec->id, \"\"))\n                 return false;\n         }"
      },
      {
        "sha": "c41e19f6f5dd275b7cc7c6fb91ddaa6fee9d28c4",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 10,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -12,6 +12,7 @@\n #include <qt/bantablemodel.h>\n #include <qt/clientmodel.h>\n #include <qt/platformstyle.h>\n+#include <qt/walletmodel.h>\n #include <chainparams.h>\n #include <netbase.h>\n #include <rpc/server.h>\n@@ -84,7 +85,7 @@ class RPCExecutor : public QObject\n     Q_OBJECT\n \n public Q_SLOTS:\n-    void request(const QString &command);\n+    void request(const QString &command, const QString &walletID);\n \n Q_SIGNALS:\n     void reply(int category, const QString &command);\n@@ -145,7 +146,7 @@ class QtRPCTimerInterface: public RPCTimerInterface\n  * @param[out]   pstrFilteredOut  Command line, filtered to remove any sensitive data\n  */\n \n-bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &strCommand, const bool fExecute, std::string * const pstrFilteredOut)\n+bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &strCommand, const bool fExecute, std::string * const pstrFilteredOut, const std::string *walletID)\n {\n     std::vector< std::vector<std::string> > stack;\n     stack.push_back(std::vector<std::string>());\n@@ -303,10 +304,8 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n                             req.params = RPCConvertValues(stack.back()[0], std::vector<std::string>(stack.back().begin() + 1, stack.back().end()));\n                             req.strMethod = stack.back()[0];\n #ifdef ENABLE_WALLET\n-                            // TODO: Move this logic to WalletModel\n-                            if (!vpwallets.empty()) {\n-                                // in Qt, use always the wallet with index 0 when running with multiple wallets\n-                                QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(vpwallets[0]->GetName()));\n+                            if (walletID && !walletID->empty()) {\n+                                QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(*walletID));\n                                 req.URI = \"/wallet/\"+std::string(encodedName.constData(), encodedName.length());\n                             }\n #endif\n@@ -385,7 +384,7 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n     }\n }\n \n-void RPCExecutor::request(const QString &command)\n+void RPCExecutor::request(const QString &command, const QString &walletID)\n {\n     try\n     {\n@@ -416,7 +415,8 @@ void RPCExecutor::request(const QString &command)\n                 \"   example:    getblock(getblockhash(0),true)[tx][0]\\n\\n\")));\n             return;\n         }\n-        if(!RPCConsole::RPCExecuteCommandLine(result, executableCommand))\n+        std::string wallet_id = walletID.toStdString();\n+        if(!RPCConsole::RPCExecuteCommandLine(result, executableCommand, nullptr, &wallet_id))\n         {\n             Q_EMIT reply(RPCConsole::CMD_ERROR, QString(\"Parse error: unbalanced ' or \\\"\"));\n             return;\n@@ -478,6 +478,10 @@ RPCConsole::RPCConsole(const PlatformStyle *_platformStyle, QWidget *parent) :\n     connect(ui->fontSmallerButton, SIGNAL(clicked()), this, SLOT(fontSmaller()));\n     connect(ui->btnClearTrafficGraph, SIGNAL(clicked()), ui->trafficGraph, SLOT(clear()));\n \n+    // disable the wallet selector by default\n+    ui->WalletSelector->setVisible(false);\n+    ui->WalletSelectorLabel->setVisible(false);\n+\n     // set library version labels\n #ifdef ENABLE_WALLET\n     ui->berkeleyDBVersion->setText(DbEnv::version(0, 0, 0));\n@@ -687,6 +691,23 @@ void RPCConsole::setClientModel(ClientModel *model)\n     }\n }\n \n+#ifdef ENABLE_WALLET\n+void RPCConsole::addWallet(WalletModel * const walletModel)\n+{\n+    const QString name = walletModel->getWalletName();\n+    // use name for text and internal data object (to allow to move to a wallet id later)\n+    ui->WalletSelector->addItem(name, name);\n+    if (ui->WalletSelector->count() == 2 && !isVisible()) {\n+        // First wallet added, set to default so long as the window isn't presently visible (and potentially in use)\n+        ui->WalletSelector->setCurrentIndex(1);\n+    }\n+    if (ui->WalletSelector->count() > 2) {\n+        ui->WalletSelector->setVisible(true);\n+        ui->WalletSelectorLabel->setVisible(true);\n+    }\n+}\n+#endif\n+\n static QString categoryClass(int category)\n {\n     switch(category)\n@@ -874,8 +895,25 @@ void RPCConsole::on_lineEdit_returnPressed()\n \n         cmdBeforeBrowsing = QString();\n \n+        QString walletID;\n+#ifdef ENABLE_WALLET\n+        const int wallet_index = ui->WalletSelector->currentIndex();\n+        if (wallet_index > 0) {\n+            walletID = (QString)ui->WalletSelector->itemData(wallet_index).value<QString>();\n+        }\n+\n+        if (m_last_wallet_id != walletID) {\n+            if (walletID.isEmpty()) {\n+                message(CMD_REQUEST, tr(\"Executing command without any wallet\"));\n+            } else {\n+                message(CMD_REQUEST, tr(\"Executing command using \\\"%1\\\" wallet\").arg(walletID));\n+            }\n+            m_last_wallet_id = walletID;\n+        }\n+#endif\n+\n         message(CMD_REQUEST, QString::fromStdString(strFilteredCmd));\n-        Q_EMIT cmdRequest(cmd);\n+        Q_EMIT cmdRequest(cmd, walletID);\n \n         cmd = QString::fromStdString(strFilteredCmd);\n \n@@ -923,7 +961,7 @@ void RPCConsole::startExecutor()\n     // Replies from executor object must go to this object\n     connect(executor, SIGNAL(reply(int,QString)), this, SLOT(message(int,QString)));\n     // Requests from this object must go to executor\n-    connect(this, SIGNAL(cmdRequest(QString)), executor, SLOT(request(QString)));\n+    connect(this, SIGNAL(cmdRequest(QString, QString)), executor, SLOT(request(QString, QString)));\n \n     // On stopExecutor signal\n     // - quit the Qt event loop in the execution thread"
      },
      {
        "sha": "c97260b2c36f879cebf83c33ee66157e9f577107",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -17,6 +17,7 @@\n class ClientModel;\n class PlatformStyle;\n class RPCTimerInterface;\n+class WalletModel;\n \n namespace Ui {\n     class RPCConsole;\n@@ -36,12 +37,13 @@ class RPCConsole: public QWidget\n     explicit RPCConsole(const PlatformStyle *platformStyle, QWidget *parent);\n     ~RPCConsole();\n \n-    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr);\n-    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr) {\n-        return RPCParseCommandLine(strResult, strCommand, true, pstrFilteredOut);\n+    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr, const std::string *walletID = nullptr);\n+    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr, const std::string *walletID = nullptr) {\n+        return RPCParseCommandLine(strResult, strCommand, true, pstrFilteredOut, walletID);\n     }\n \n     void setClientModel(ClientModel *model);\n+    void addWallet(WalletModel * const walletModel);\n \n     enum MessageClass {\n         MC_ERROR,\n@@ -120,7 +122,7 @@ public Q_SLOTS:\n Q_SIGNALS:\n     // For RPC command executor\n     void stopExecutor();\n-    void cmdRequest(const QString &command);\n+    void cmdRequest(const QString &command, const QString &walletID);\n \n private:\n     void startExecutor();\n@@ -151,6 +153,7 @@ public Q_SLOTS:\n     int consoleFontSize;\n     QCompleter *autoCompleter;\n     QThread thread;\n+    QString m_last_wallet_id;\n \n     /** Update UI with latest network info from model. */\n     void updateNetworkState();"
      },
      {
        "sha": "8a52aadbb0d99579304c91e8f8fed31139122510",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -14,8 +14,8 @@\n #include <qt/platformstyle.h>\n #include <qt/sendcoinsentry.h>\n \n-#include <base58.h>\n #include <chainparams.h>\n+#include <key_io.h>\n #include <wallet/coincontrol.h>\n #include <validation.h> // mempool and minRelayTxFee\n #include <ui_interface.h>\n@@ -277,8 +277,11 @@ void SendCoinsDialog::on_sendButton_clicked()\n     QStringList formatted;\n     for (const SendCoinsRecipient &rcp : currentTransaction.getRecipients())\n     {\n-        // generate bold amount string\n+        // generate bold amount string with wallet name in case of multiwallet\n         QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n+        if (model->isMultiwallet()) {\n+            amount.append(\" <u>\"+tr(\"from wallet %1\").arg(GUIUtil::HtmlEscape(model->getWalletName()))+\"</u> \");\n+        }\n         amount.append(\"</b>\");\n         // generate monospace address string\n         QString address = \"<span style='font-family: monospace;'>\" + rcp.address;\n@@ -369,12 +372,19 @@ void SendCoinsDialog::on_sendButton_clicked()\n         accept();\n         CoinControlDialog::coinControl()->UnSelectAll();\n         coinControlUpdateLabels();\n+        Q_EMIT coinsSent(currentTransaction.getTransaction()->GetHash());\n     }\n     fNewRecipientAllowed = true;\n }\n \n void SendCoinsDialog::clear()\n {\n+    // Clear coin control settings\n+    CoinControlDialog::coinControl()->UnSelectAll();\n+    ui->checkBoxCoinControlChange->setChecked(false);\n+    ui->lineEditCoinControlChange->clear();\n+    coinControlUpdateLabels();\n+\n     // Remove entries until only one left\n     while(ui->entries->count())\n     {"
      },
      {
        "sha": "48885bbcad77f1418a759241ce90e8d1d3d40dfe",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -54,6 +54,9 @@ public Q_SLOTS:\n     void setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n                     const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n \n+Q_SIGNALS:\n+    void coinsSent(const uint256& txid);\n+\n private:\n     Ui::SendCoinsDialog *ui;\n     ClientModel *clientModel;"
      },
      {
        "sha": "8dade8df7984eb97c921389e0e81392727fd5ced",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,8 +10,8 @@\n #include <qt/platformstyle.h>\n #include <qt/walletmodel.h>\n \n-#include <base58.h>\n #include <init.h>\n+#include <key_io.h>\n #include <validation.h> // For strMessageMagic\n #include <wallet/wallet.h>\n "
      },
      {
        "sha": "66e9dd0465b50e6afc959b08872a3ee3e93e1b8e",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -91,7 +91,7 @@ SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle)\n \n     pixPaint.setFont(QFont(font, 15*fontFactor));\n \n-    // if the version string is to long, reduce size\n+    // if the version string is too long, reduce size\n     fm = pixPaint.fontMetrics();\n     int versionTextWidth  = fm.width(versionText);\n     if(versionTextWidth > titleTextWidth+paddingRight-10) {"
      },
      {
        "sha": "29ef4b4c9e7ec029fe71c4e7c25113d4d20aea1c",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,6 +8,7 @@\n #include <qt/test/paymentrequestdata.h>\n \n #include <amount.h>\n+#include <chainparams.h>\n #include <random.h>\n #include <script/script.h>\n #include <script/standard.h>"
      },
      {
        "sha": "59938f704a5ed43539ceca219a95114617a83bab",
        "filename": "src/qt/test/uritests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/test/uritests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/test/uritests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/uritests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -51,7 +51,7 @@ void URITests::uriTests()\n     QVERIFY(rv.address == QString(\"175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\"));\n     QVERIFY(rv.label == QString());\n \n-    QVERIFY(GUIUtil::parseBitcoinURI(\"bitcoin://175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?message=Wikipedia Example Address\", &rv));\n+    QVERIFY(GUIUtil::parseBitcoinURI(\"bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?message=Wikipedia Example Address\", &rv));\n     QVERIFY(rv.address == QString(\"175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\"));\n     QVERIFY(rv.label == QString());\n "
      },
      {
        "sha": "c9898e52ca3ab738ea680826bc86ea4266f6d898",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 10,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,6 +10,7 @@\n #include <qt/transactiontablemodel.h>\n #include <qt/transactionview.h>\n #include <qt/walletmodel.h>\n+#include <key_io.h>\n #include <test/test_bitcoin.h>\n #include <validation.h>\n #include <wallet/wallet.h>\n@@ -149,22 +150,17 @@ void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, st\n //     src/qt/test/test_bitcoin-qt -platform cocoa    # macOS\n void TestGUI()\n {\n-    g_address_type = OUTPUT_TYPE_P2SH_SEGWIT;\n-    g_change_type = OUTPUT_TYPE_P2SH_SEGWIT;\n-\n     // Set up wallet and chain with 105 blocks (5 mature blocks for spending).\n     TestChain100Setup test;\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    bitdb.MakeMock();\n-    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"));\n-    CWallet wallet(std::move(dbw));\n+    CWallet wallet(\"mock\", CWalletDBWrapper::CreateMock());\n     bool firstRun;\n     wallet.LoadWallet(firstRun);\n     {\n         LOCK(wallet.cs_wallet);\n-        wallet.SetAddressBook(GetDestinationForKey(test.coinbaseKey.GetPubKey(), g_address_type), \"\", \"receive\");\n+        wallet.SetAddressBook(GetDestinationForKey(test.coinbaseKey.GetPubKey(), wallet.m_default_address_type), \"\", \"receive\");\n         wallet.AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());\n     }\n     {\n@@ -260,9 +256,6 @@ void TestGUI()\n     QPushButton* removeRequestButton = receiveCoinsDialog.findChild<QPushButton*>(\"removeRequestButton\");\n     removeRequestButton->click();\n     QCOMPARE(requestTableModel->rowCount({}), currentRowCount-1);\n-\n-    bitdb.Flush(true);\n-    bitdb.Reset();\n }\n \n }"
      },
      {
        "sha": "ec5a66bc9f46baa0355b1885426690bf3453619c",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -9,14 +9,15 @@\n #include <qt/paymentserver.h>\n #include <qt/transactionrecord.h>\n \n-#include <base58.h>\n #include <consensus/consensus.h>\n+#include <key_io.h>\n #include <validation.h>\n #include <script/script.h>\n #include <timedata.h>\n #include <util.h>\n #include <wallet/db.h>\n #include <wallet/wallet.h>\n+#include <policy/policy.h>\n \n #include <stdint.h>\n #include <string>\n@@ -239,8 +240,9 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     if (wtx.mapValue.count(\"comment\") && !wtx.mapValue[\"comment\"].empty())\n         strHTML += \"<br><b>\" + tr(\"Comment\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"comment\"], true) + \"<br>\";\n \n-    strHTML += \"<b>\" + tr(\"Transaction ID\") + \":</b> \" + rec->getTxID() + \"<br>\";\n+    strHTML += \"<b>\" + tr(\"Transaction ID\") + \":</b> \" + rec->getTxHash() + \"<br>\";\n     strHTML += \"<b>\" + tr(\"Transaction total size\") + \":</b> \" + QString::number(wtx.tx->GetTotalSize()) + \" bytes<br>\";\n+    strHTML += \"<b>\" + tr(\"Transaction virtual size\") + \":</b> \" + QString::number(GetVirtualTransactionSize(*wtx.tx)) + \" bytes<br>\";\n     strHTML += \"<b>\" + tr(\"Output index\") + \":</b> \" + QString::number(rec->getOutputIndex()) + \"<br>\";\n \n     // Message from normal bitcoin:URI (bitcoin:123...?message=example)"
      },
      {
        "sha": "7bf4d3351c6c0a3df597df6dc3b3f01bdc47d9cd",
        "filename": "src/qt/transactiondescdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiondescdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiondescdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondescdialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -14,7 +14,7 @@ TransactionDescDialog::TransactionDescDialog(const QModelIndex &idx, QWidget *pa\n     ui(new Ui::TransactionDescDialog)\n {\n     ui->setupUi(this);\n-    setWindowTitle(tr(\"Details for %1\").arg(idx.data(TransactionTableModel::TxIDRole).toString()));\n+    setWindowTitle(tr(\"Details for %1\").arg(idx.data(TransactionTableModel::TxHashRole).toString()));\n     QString desc = idx.data(TransactionTableModel::LongDescriptionRole).toString();\n     ui->detailText->setHtml(desc);\n }"
      },
      {
        "sha": "6301af7553cbc6841237aa100d1443b0101720a5",
        "filename": "src/qt/transactionfilterproxy.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionfilterproxy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionfilterproxy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionfilterproxy.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -31,31 +31,35 @@ bool TransactionFilterProxy::filterAcceptsRow(int sourceRow, const QModelIndex &\n {\n     QModelIndex index = sourceModel()->index(sourceRow, 0, sourceParent);\n \n-    int type = index.data(TransactionTableModel::TypeRole).toInt();\n-    QDateTime datetime = index.data(TransactionTableModel::DateRole).toDateTime();\n-    bool involvesWatchAddress = index.data(TransactionTableModel::WatchonlyRole).toBool();\n-    QString address = index.data(TransactionTableModel::AddressRole).toString();\n-    QString label = index.data(TransactionTableModel::LabelRole).toString();\n-    QString txid = index.data(TransactionTableModel::TxIDRole).toString();\n-    qint64 amount = llabs(index.data(TransactionTableModel::AmountRole).toLongLong());\n     int status = index.data(TransactionTableModel::StatusRole).toInt();\n-\n-    if(!showInactive && status == TransactionStatus::Conflicted)\n+    if (!showInactive && status == TransactionStatus::Conflicted)\n         return false;\n-    if(!(TYPE(type) & typeFilter))\n+\n+    int type = index.data(TransactionTableModel::TypeRole).toInt();\n+    if (!(TYPE(type) & typeFilter))\n         return false;\n+\n+    bool involvesWatchAddress = index.data(TransactionTableModel::WatchonlyRole).toBool();\n     if (involvesWatchAddress && watchOnlyFilter == WatchOnlyFilter_No)\n         return false;\n     if (!involvesWatchAddress && watchOnlyFilter == WatchOnlyFilter_Yes)\n         return false;\n-    if(datetime < dateFrom || datetime > dateTo)\n+\n+    QDateTime datetime = index.data(TransactionTableModel::DateRole).toDateTime();\n+    if (datetime < dateFrom || datetime > dateTo)\n         return false;\n+\n+    QString address = index.data(TransactionTableModel::AddressRole).toString();\n+    QString label = index.data(TransactionTableModel::LabelRole).toString();\n+    QString txid = index.data(TransactionTableModel::TxHashRole).toString();\n     if (!address.contains(m_search_string, Qt::CaseInsensitive) &&\n         !  label.contains(m_search_string, Qt::CaseInsensitive) &&\n         !   txid.contains(m_search_string, Qt::CaseInsensitive)) {\n         return false;\n     }\n-    if(amount < minAmount)\n+\n+    qint64 amount = llabs(index.data(TransactionTableModel::AmountRole).toLongLong());\n+    if (amount < minAmount)\n         return false;\n \n     return true;"
      },
      {
        "sha": "cc30cf747d972e68841cb976a09f3580716a564e",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,8 +4,8 @@\n \n #include <qt/transactionrecord.h>\n \n-#include <base58.h>\n #include <consensus/consensus.h>\n+#include <key_io.h>\n #include <validation.h>\n #include <timedata.h>\n #include <wallet/wallet.h>\n@@ -167,10 +167,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     // Determine transaction status\n \n     // Find the block the tx is in\n-    CBlockIndex* pindex = nullptr;\n-    BlockMap::iterator mi = mapBlockIndex.find(wtx.hashBlock);\n-    if (mi != mapBlockIndex.end())\n-        pindex = (*mi).second;\n+    const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n \n     // Sort order, unrecorded transactions sort to the top\n     status.sortKey = strprintf(\"%010d-%01d-%010u-%03d\",\n@@ -254,7 +251,7 @@ bool TransactionRecord::statusUpdateNeeded() const\n     return status.cur_num_blocks != chainActive.Height() || status.needsUpdate;\n }\n \n-QString TransactionRecord::getTxID() const\n+QString TransactionRecord::getTxHash() const\n {\n     return QString::fromStdString(hash.ToString());\n }"
      },
      {
        "sha": "5321d05d157d0597158cd0280137f1364e37a2d2",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -129,7 +129,7 @@ class TransactionRecord\n     bool involvesWatchAddress;\n \n     /** Return the unique identifier for this transaction (part) */\n-    QString getTxID() const;\n+    QString getTxHash() const;\n \n     /** Return the output index of the subtransaction  */\n     int getOutputIndex() const;"
      },
      {
        "sha": "84800125fe3cbce76300667fa7a65a01dc11e0dc",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -615,10 +615,8 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n         return walletModel->getAddressTableModel()->labelForAddress(QString::fromStdString(rec->address));\n     case AmountRole:\n         return qint64(rec->credit + rec->debit);\n-    case TxIDRole:\n-        return rec->getTxID();\n     case TxHashRole:\n-        return QString::fromStdString(rec->hash.ToString());\n+        return rec->getTxHash();\n     case TxHexRole:\n         return priv->getTxHex(rec);\n     case TxPlainTextRole:"
      },
      {
        "sha": "781874d16010ea2326510d4dbcb7f7510f08bf6d",
        "filename": "src/qt/transactiontablemodel.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiontablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactiontablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -56,8 +56,6 @@ class TransactionTableModel : public QAbstractTableModel\n         LabelRole,\n         /** Net amount of transaction */\n         AmountRole,\n-        /** Unique identifier */\n-        TxIDRole,\n         /** Transaction hash */\n         TxHashRole,\n         /** Transaction data, hex-encoded */"
      },
      {
        "sha": "26391452da3291c317e204892e3e04392cb2bd21",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 4,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -263,8 +263,7 @@ void TransactionView::setModel(WalletModel *_model)\n \n void TransactionView::chooseDate(int idx)\n {\n-    if(!transactionProxyModel)\n-        return;\n+    if (!transactionProxyModel) return;\n     QDate current = QDate::currentDate();\n     dateRangeWidget->setVisible(false);\n     switch(dateWidget->itemData(idx).toInt())\n@@ -372,7 +371,7 @@ void TransactionView::exportClicked()\n     writer.addColumn(tr(\"Label\"), 0, TransactionTableModel::LabelRole);\n     writer.addColumn(tr(\"Address\"), 0, TransactionTableModel::AddressRole);\n     writer.addColumn(BitcoinUnits::getAmountColumnTitle(model->getOptionsModel()->getDisplayUnit()), 0, TransactionTableModel::FormattedAmountRole);\n-    writer.addColumn(tr(\"ID\"), 0, TransactionTableModel::TxIDRole);\n+    writer.addColumn(tr(\"ID\"), 0, TransactionTableModel::TxHashRole);\n \n     if(!writer.write()) {\n         Q_EMIT message(tr(\"Exporting Failed\"), tr(\"There was an error trying to save the transaction history to %1.\").arg(filename),\n@@ -456,7 +455,7 @@ void TransactionView::copyAmount()\n \n void TransactionView::copyTxID()\n {\n-    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::TxIDRole);\n+    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::TxHashRole);\n }\n \n void TransactionView::copyTxHex()\n@@ -592,6 +591,32 @@ void TransactionView::focusTransaction(const QModelIndex &idx)\n     transactionView->setFocus();\n }\n \n+void TransactionView::focusTransaction(const uint256& txid)\n+{\n+    if (!transactionProxyModel)\n+        return;\n+\n+    const QModelIndexList results = this->model->getTransactionTableModel()->match(\n+        this->model->getTransactionTableModel()->index(0,0),\n+        TransactionTableModel::TxHashRole,\n+        QString::fromStdString(txid.ToString()), -1);\n+\n+    transactionView->setFocus();\n+    transactionView->selectionModel()->clearSelection();\n+    for (const QModelIndex& index : results) {\n+        const QModelIndex targetIndex = transactionProxyModel->mapFromSource(index);\n+        transactionView->selectionModel()->select(\n+            targetIndex,\n+            QItemSelectionModel::Rows | QItemSelectionModel::Select);\n+        // Called once per destination to ensure all results are in view, unless\n+        // transactions are not ordered by (ascending or descending) date.\n+        transactionView->scrollTo(targetIndex);\n+        // scrollTo() does not scroll far enough the first time when transactions\n+        // are ordered by ascending date.\n+        if (index == results[0]) transactionView->scrollTo(targetIndex);\n+    }\n+}\n+\n // We override the virtual resizeEvent of the QWidget to adjust tables column\n // sizes as the tables width is proportional to the dialogs width.\n void TransactionView::resizeEvent(QResizeEvent* event)"
      },
      {
        "sha": "66dc5bc86bf1f961ca8de02ec29378597b53ff27",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -7,6 +7,8 @@\n \n #include <qt/guiutil.h>\n \n+#include <uint256.h>\n+\n #include <QWidget>\n #include <QKeyEvent>\n \n@@ -116,7 +118,7 @@ public Q_SLOTS:\n     void changedSearch();\n     void exportClicked();\n     void focusTransaction(const QModelIndex&);\n-\n+    void focusTransaction(const uint256& txid);\n };\n \n #endif // BITCOIN_QT_TRANSACTIONVIEW_H"
      },
      {
        "sha": "c19e6aae78ee44aa9786df5a7a1a7e087cb5413d",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -77,7 +77,7 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n         cursor.insertText(header);\n         cursor.insertBlock();\n \n-        std::string strUsage = HelpMessage(HMM_BITCOIN_QT);\n+        std::string strUsage = HelpMessage(HelpMessageMode::BITCOIN_QT);\n         const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n         strUsage += HelpMessageGroup(tr(\"UI Options:\").toStdString());\n         if (showDebug) {"
      },
      {
        "sha": "5b13353d7bfc37cb654329381c8fe3332f40efab",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <qt/walletframe.h>\n+#include <qt/walletmodel.h>\n \n #include <qt/bitcoingui.h>\n #include <qt/walletview.h>\n@@ -39,10 +40,16 @@ void WalletFrame::setClientModel(ClientModel *_clientModel)\n     this->clientModel = _clientModel;\n }\n \n-bool WalletFrame::addWallet(const QString& name, WalletModel *walletModel)\n+bool WalletFrame::addWallet(WalletModel *walletModel)\n {\n-    if (!gui || !clientModel || !walletModel || mapWalletViews.count(name) > 0)\n+    if (!gui || !clientModel || !walletModel) {\n         return false;\n+    }\n+\n+    const QString name = walletModel->getWalletName();\n+    if (mapWalletViews.count(name) > 0) {\n+        return false;\n+    }\n \n     WalletView *walletView = new WalletView(platformStyle, this);\n     walletView->setBitcoinGUI(gui);"
      },
      {
        "sha": "6eedcf370c60c0a6046e5070a164367d471464ed",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -36,7 +36,7 @@ class WalletFrame : public QFrame\n \n     void setClientModel(ClientModel *clientModel);\n \n-    bool addWallet(const QString& name, WalletModel *walletModel);\n+    bool addWallet(WalletModel *walletModel);\n     bool setCurrentWallet(const QString& name);\n     bool removeWallet(const QString &name);\n     void removeAllWallets();\n@@ -59,6 +59,7 @@ class WalletFrame : public QFrame\n \n     const PlatformStyle *platformStyle;\n \n+public:\n     WalletView *currentWalletView();\n \n public Q_SLOTS:"
      },
      {
        "sha": "795302be587028ce3886fdaaaa2004caeea2bbdf",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 13,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -14,8 +14,8 @@\n #include <qt/sendcoinsdialog.h>\n #include <qt/transactiontablemodel.h>\n \n-#include <base58.h>\n #include <chain.h>\n+#include <key_io.h>\n #include <keystore.h>\n #include <validation.h>\n #include <net.h> // for g_connman\n@@ -110,8 +110,9 @@ void WalletModel::updateStatus()\n {\n     EncryptionStatus newEncryptionStatus = getEncryptionStatus();\n \n-    if(cachedEncryptionStatus != newEncryptionStatus)\n-        Q_EMIT encryptionStatusChanged(newEncryptionStatus);\n+    if(cachedEncryptionStatus != newEncryptionStatus) {\n+        Q_EMIT encryptionStatusChanged();\n+    }\n }\n \n void WalletModel::pollBalanceChanged()\n@@ -275,9 +276,9 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         int nChangePosRet = -1;\n         std::string strFailReason;\n \n-        CWalletTx *newTx = transaction.getTransaction();\n+        CTransactionRef& newTx = transaction.getTransaction();\n         CReserveKey *keyChange = transaction.getPossibleKeyChange();\n-        bool fCreated = wallet->CreateTransaction(vecSend, *newTx, *keyChange, nFeeRequired, nChangePosRet, strFailReason, coinControl);\n+        bool fCreated = wallet->CreateTransaction(vecSend, newTx, *keyChange, nFeeRequired, nChangePosRet, strFailReason, coinControl);\n         transaction.setTransactionFee(nFeeRequired);\n         if (fSubtractFeeFromAmount && fCreated)\n             transaction.reassignAmounts(nChangePosRet);\n@@ -309,8 +310,8 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n \n     {\n         LOCK2(cs_main, wallet->cs_wallet);\n-        CWalletTx *newTx = transaction.getTransaction();\n \n+        std::vector<std::pair<std::string, std::string>> vOrderForm;\n         for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n         {\n             if (rcp.paymentRequest.IsInitialized())\n@@ -321,22 +322,22 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n                 }\n \n                 // Store PaymentRequests in wtx.vOrderForm in wallet.\n-                std::string key(\"PaymentRequest\");\n                 std::string value;\n                 rcp.paymentRequest.SerializeToString(&value);\n-                newTx->vOrderForm.push_back(make_pair(key, value));\n+                vOrderForm.emplace_back(\"PaymentRequest\", std::move(value));\n             }\n             else if (!rcp.message.isEmpty()) // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n-                newTx->vOrderForm.push_back(make_pair(\"Message\", rcp.message.toStdString()));\n+                vOrderForm.emplace_back(\"Message\", rcp.message.toStdString());\n         }\n \n+        CTransactionRef& newTx = transaction.getTransaction();\n         CReserveKey *keyChange = transaction.getPossibleKeyChange();\n         CValidationState state;\n-        if(!wallet->CommitTransaction(*newTx, *keyChange, g_connman.get(), state))\n+        if (!wallet->CommitTransaction(newTx, {} /* mapValue */, std::move(vOrderForm), {} /* fromAccount */, *keyChange, g_connman.get(), state))\n             return SendCoinsReturn(TransactionCommitFailed, QString::fromStdString(state.GetRejectReason()));\n \n         CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-        ssTx << *newTx->tx;\n+        ssTx << newTx;\n         transaction_array.append(&(ssTx[0]), ssTx.size());\n     }\n \n@@ -698,7 +699,7 @@ bool WalletModel::bumpFee(uint256 hash)\n     confirmationDialog.exec();\n     QMessageBox::StandardButton retval = static_cast<QMessageBox::StandardButton>(confirmationDialog.result());\n \n-    // cancel sign&broadcast if users doesn't want to bump the fee\n+    // cancel sign&broadcast if user doesn't want to bump the fee\n     if (retval != QMessageBox::Yes) {\n         return false;\n     }\n@@ -736,10 +737,21 @@ bool WalletModel::hdEnabled() const\n \n OutputType WalletModel::getDefaultAddressType() const\n {\n-    return g_address_type;\n+    return wallet->m_default_address_type;\n }\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n     return nTxConfirmTarget;\n }\n+\n+QString WalletModel::getWalletName() const\n+{\n+    LOCK(wallet->cs_wallet);\n+    return QString::fromStdString(wallet->GetName());\n+}\n+\n+bool WalletModel::isMultiwallet()\n+{\n+    return gArgs.GetArgs(\"-wallet\").size() > 1;\n+}"
      },
      {
        "sha": "ff4b38a804a45b300f91346f7a284638ba126510",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -5,6 +5,11 @@\n #ifndef BITCOIN_QT_WALLETMODEL_H\n #define BITCOIN_QT_WALLETMODEL_H\n \n+#include <amount.h>\n+#include <key.h>\n+#include <serialize.h>\n+#include <script/standard.h>\n+\n #include <qt/paymentrequestplus.h>\n #include <qt/walletmodeltransaction.h>\n \n@@ -15,7 +20,7 @@\n \n #include <QObject>\n \n-enum OutputType : int;\n+enum class OutputType;\n \n class AddressTableModel;\n class OptionsModel;\n@@ -131,6 +136,8 @@ class WalletModel : public QObject\n     TransactionTableModel *getTransactionTableModel();\n     RecentRequestsTableModel *getRecentRequestsTableModel();\n \n+    CWallet *getWallet() const { return wallet; };\n+\n     CAmount getBalance(const CCoinControl *coinControl = nullptr) const;\n     CAmount getUnconfirmedBalance() const;\n     CAmount getImmatureBalance() const;\n@@ -220,6 +227,9 @@ class WalletModel : public QObject\n \n     int getDefaultConfirmTarget() const;\n \n+    QString getWalletName() const;\n+\n+    static bool isMultiwallet();\n private:\n     CWallet *wallet;\n     bool fHaveWatchOnly;\n@@ -255,7 +265,7 @@ class WalletModel : public QObject\n                         const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n \n     // Encryption status of wallet changed\n-    void encryptionStatusChanged(int status);\n+    void encryptionStatusChanged();\n \n     // Signal emitted when wallet needs to be unlocked\n     // It is valid behaviour for listeners to keep the wallet locked after this signal;"
      },
      {
        "sha": "4df8a5687eb57f2d15c7d26c9ed66d04a4314944",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -12,27 +12,21 @@ WalletModelTransaction::WalletModelTransaction(const QList<SendCoinsRecipient> &\n     walletTransaction(0),\n     fee(0)\n {\n-    walletTransaction = new CWalletTx();\n-}\n-\n-WalletModelTransaction::~WalletModelTransaction()\n-{\n-    delete walletTransaction;\n }\n \n QList<SendCoinsRecipient> WalletModelTransaction::getRecipients() const\n {\n     return recipients;\n }\n \n-CWalletTx *WalletModelTransaction::getTransaction() const\n+CTransactionRef& WalletModelTransaction::getTransaction()\n {\n     return walletTransaction;\n }\n \n unsigned int WalletModelTransaction::getTransactionSize()\n {\n-    return (!walletTransaction ? 0 : ::GetVirtualTransactionSize(*walletTransaction->tx));\n+    return (!walletTransaction ? 0 : ::GetVirtualTransactionSize(*walletTransaction));\n }\n \n CAmount WalletModelTransaction::getTransactionFee() const\n@@ -62,7 +56,7 @@ void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n                 if (out.amount() <= 0) continue;\n                 if (i == nChangePosRet)\n                     i++;\n-                subtotal += walletTransaction->tx->vout[i].nValue;\n+                subtotal += walletTransaction->vout[i].nValue;\n                 i++;\n             }\n             rcp.amount = subtotal;\n@@ -71,7 +65,7 @@ void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n         {\n             if (i == nChangePosRet)\n                 i++;\n-            rcp.amount = walletTransaction->tx->vout[i].nValue;\n+            rcp.amount = walletTransaction->vout[i].nValue;\n             i++;\n         }\n     }"
      },
      {
        "sha": "931e960d183c19d999f66d7c4cb35216ad18405e",
        "filename": "src/qt/walletmodeltransaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodeltransaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletmodeltransaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -20,11 +20,10 @@ class WalletModelTransaction\n {\n public:\n     explicit WalletModelTransaction(const QList<SendCoinsRecipient> &recipients);\n-    ~WalletModelTransaction();\n \n     QList<SendCoinsRecipient> getRecipients() const;\n \n-    CWalletTx *getTransaction() const;\n+    CTransactionRef& getTransaction();\n     unsigned int getTransactionSize();\n \n     void setTransactionFee(const CAmount& newFee);\n@@ -39,7 +38,7 @@ class WalletModelTransaction\n \n private:\n     QList<SendCoinsRecipient> recipients;\n-    CWalletTx *walletTransaction;\n+    CTransactionRef walletTransaction;\n     std::unique_ptr<CReserveKey> keyChange;\n     CAmount fee;\n };"
      },
      {
        "sha": "cc4300a7a1766447af1391ad9173280c63a4fadd",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -68,6 +68,9 @@ WalletView::WalletView(const PlatformStyle *_platformStyle, QWidget *parent):\n     connect(overviewPage, SIGNAL(transactionClicked(QModelIndex)), transactionView, SLOT(focusTransaction(QModelIndex)));\n     connect(overviewPage, SIGNAL(outOfSyncWarningClicked()), this, SLOT(requestedSyncWarningInfo()));\n \n+    // Highlight transaction after send\n+    connect(sendCoinsPage, SIGNAL(coinsSent(uint256)), transactionView, SLOT(focusTransaction(uint256)));\n+\n     // Double-clicking on a transaction on the transaction history page shows details\n     connect(transactionView, SIGNAL(doubleClicked(QModelIndex)), transactionView, SLOT(showDetails()));\n \n@@ -91,17 +94,20 @@ void WalletView::setBitcoinGUI(BitcoinGUI *gui)\n         // Clicking on a transaction on the overview page simply sends you to transaction history page\n         connect(overviewPage, SIGNAL(transactionClicked(QModelIndex)), gui, SLOT(gotoHistoryPage()));\n \n+        // Navigate to transaction history page after send\n+        connect(sendCoinsPage, SIGNAL(coinsSent(uint256)), gui, SLOT(gotoHistoryPage()));\n+\n         // Receive and report messages\n         connect(this, SIGNAL(message(QString,QString,unsigned int)), gui, SLOT(message(QString,QString,unsigned int)));\n \n         // Pass through encryption status changed signals\n-        connect(this, SIGNAL(encryptionStatusChanged(int)), gui, SLOT(setEncryptionStatus(int)));\n+        connect(this, SIGNAL(encryptionStatusChanged()), gui, SLOT(updateWalletStatus()));\n \n         // Pass through transaction notifications\n-        connect(this, SIGNAL(incomingTransaction(QString,int,CAmount,QString,QString,QString)), gui, SLOT(incomingTransaction(QString,int,CAmount,QString,QString,QString)));\n+        connect(this, SIGNAL(incomingTransaction(QString,int,CAmount,QString,QString,QString,QString)), gui, SLOT(incomingTransaction(QString,int,CAmount,QString,QString,QString,QString)));\n \n         // Connect HD enabled state signal \n-        connect(this, SIGNAL(hdEnabledStatusChanged(int)), gui, SLOT(setHDStatus(int)));\n+        connect(this, SIGNAL(hdEnabledStatusChanged()), gui, SLOT(updateWalletStatus()));\n     }\n }\n \n@@ -131,11 +137,11 @@ void WalletView::setWalletModel(WalletModel *_walletModel)\n         connect(_walletModel, SIGNAL(message(QString,QString,unsigned int)), this, SIGNAL(message(QString,QString,unsigned int)));\n \n         // Handle changes in encryption status\n-        connect(_walletModel, SIGNAL(encryptionStatusChanged(int)), this, SIGNAL(encryptionStatusChanged(int)));\n+        connect(_walletModel, SIGNAL(encryptionStatusChanged()), this, SIGNAL(encryptionStatusChanged()));\n         updateEncryptionStatus();\n \n         // update HD status\n-        Q_EMIT hdEnabledStatusChanged(_walletModel->hdEnabled());\n+        Q_EMIT hdEnabledStatusChanged();\n \n         // Balloon pop-up for new transaction\n         connect(_walletModel->getTransactionTableModel(), SIGNAL(rowsInserted(QModelIndex,int,int)),\n@@ -166,7 +172,7 @@ void WalletView::processNewTransaction(const QModelIndex& parent, int start, int\n     QString address = ttm->data(index, TransactionTableModel::AddressRole).toString();\n     QString label = ttm->data(index, TransactionTableModel::LabelRole).toString();\n \n-    Q_EMIT incomingTransaction(date, walletModel->getOptionsModel()->getDisplayUnit(), amount, type, address, label);\n+    Q_EMIT incomingTransaction(date, walletModel->getOptionsModel()->getDisplayUnit(), amount, type, address, label, walletModel->getWalletName());\n }\n \n void WalletView::gotoOverviewPage()\n@@ -228,7 +234,7 @@ void WalletView::showOutOfSyncWarning(bool fShow)\n \n void WalletView::updateEncryptionStatus()\n {\n-    Q_EMIT encryptionStatusChanged(walletModel->getEncryptionStatus());\n+    Q_EMIT encryptionStatusChanged();\n }\n \n void WalletView::encryptWallet(bool status)"
      },
      {
        "sha": "878a5966d607dde258f295b9527e0864d847a195",
        "filename": "src/qt/walletview.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/qt/walletview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -44,6 +44,7 @@ class WalletView : public QStackedWidget\n         The client model represents the part of the core that communicates with the P2P network, and is wallet-agnostic.\n     */\n     void setClientModel(ClientModel *clientModel);\n+    WalletModel *getWalletModel() { return walletModel; }\n     /** Set the wallet model.\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n         functionality.\n@@ -119,11 +120,11 @@ public Q_SLOTS:\n     /**  Fired when a message should be reported to the user */\n     void message(const QString &title, const QString &message, unsigned int style);\n     /** Encryption status of wallet changed */\n-    void encryptionStatusChanged(int status);\n+    void encryptionStatusChanged();\n     /** HD-Enabled status of wallet changed (only possible during startup) */\n-    void hdEnabledStatusChanged(int hdEnabled);\n+    void hdEnabledStatusChanged();\n     /** Notify that a new transaction appeared */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n     /** Notify that the out of sync warning icon has been pressed */\n     void outOfSyncWarningClicked();\n };"
      },
      {
        "sha": "1d6b13a537f4a36695c0a1a46ad1498f77936b45",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -11,6 +11,7 @@\n #include <uint256.h>\n \n #include <stdint.h>\n+#include <limits>\n \n /* Seed OpenSSL PRNG with additional entropy data */\n void RandAddSeed();\n@@ -32,7 +33,7 @@ void RandAddSeedSleep();\n \n /**\n  * Function to gather random data from multiple sources, failing whenever any\n- * of those source fail to provide a result.\n+ * of those sources fail to provide a result.\n  */\n void GetStrongRandBytes(unsigned char* buf, int num);\n \n@@ -121,6 +122,12 @@ class FastRandomContext {\n \n     /** Generate a random boolean. */\n     bool randbool() { return randbits(1); }\n+\n+    // Compatibility with the C++11 UniformRandomBitGenerator concept\n+    typedef uint64_t result_type;\n+    static constexpr uint64_t min() { return 0; }\n+    static constexpr uint64_t max() { return std::numeric_limits<uint64_t>::max(); }\n+    inline uint64_t operator()() { return rand64(); }\n };\n \n /* Number of random bytes returned by GetOSRand."
      },
      {
        "sha": "5871b554a6ae2c0bd8056a2480942b89ccd2a802",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 50,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -24,21 +24,21 @@\n \n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n \n-enum RetFormat {\n-    RF_UNDEF,\n-    RF_BINARY,\n-    RF_HEX,\n-    RF_JSON,\n+enum class RetFormat {\n+    UNDEF,\n+    BINARY,\n+    HEX,\n+    JSON,\n };\n \n static const struct {\n     enum RetFormat rf;\n     const char* name;\n } rf_names[] = {\n-      {RF_UNDEF, \"\"},\n-      {RF_BINARY, \"bin\"},\n-      {RF_HEX, \"hex\"},\n-      {RF_JSON, \"json\"},\n+      {RetFormat::UNDEF, \"\"},\n+      {RetFormat::BINARY, \"bin\"},\n+      {RetFormat::HEX, \"hex\"},\n+      {RetFormat::JSON, \"json\"},\n };\n \n struct CCoin {\n@@ -90,7 +90,7 @@ static enum RetFormat ParseDataFormat(std::string& param, const std::string& str\n \n static std::string AvailableDataFormatsString()\n {\n-    std::string formats = \"\";\n+    std::string formats;\n     for (unsigned int i = 0; i < ARRAYLEN(rf_names); i++)\n         if (strlen(rf_names[i].name) > 0) {\n             formats.append(\".\");\n@@ -147,8 +147,7 @@ static bool rest_headers(HTTPRequest* req,\n     headers.reserve(count);\n     {\n         LOCK(cs_main);\n-        BlockMap::const_iterator it = mapBlockIndex.find(hash);\n-        const CBlockIndex *pindex = (it != mapBlockIndex.end()) ? it->second : nullptr;\n+        const CBlockIndex* pindex = LookupBlockIndex(hash);\n         while (pindex != nullptr && chainActive.Contains(pindex)) {\n             headers.push_back(pindex);\n             if (headers.size() == (unsigned long)count)\n@@ -163,20 +162,20 @@ static bool rest_headers(HTTPRequest* req,\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryHeader = ssHeader.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue jsonHeaders(UniValue::VARR);\n         {\n             LOCK(cs_main);\n@@ -212,10 +211,11 @@ static bool rest_block(HTTPRequest* req,\n     CBlockIndex* pblockindex = nullptr;\n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n+        }\n \n-        pblockindex = mapBlockIndex[hash];\n         if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n             return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n \n@@ -227,21 +227,21 @@ static bool rest_block(HTTPRequest* req,\n     ssBlock << block;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryBlock = ssBlock.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objBlock;\n         {\n             LOCK(cs_main);\n@@ -280,7 +280,7 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         JSONRPCRequest jsonRequest;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\n@@ -303,7 +303,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n         std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n@@ -325,7 +325,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolObject = mempoolToJSON(true);\n \n         std::string strJSON = mempoolObject.write() + \"\\n\";\n@@ -359,21 +359,21 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     ssTx << tx;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryTx = ssTx.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToUniv(*tx, hashBlock, objTx);\n         std::string strJSON = objTx.write() + \"\\n\";\n@@ -440,13 +440,13 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     }\n \n     switch (rf) {\n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         // convert hex to bin, continue then with bin part\n         std::vector<unsigned char> strRequestV = ParseHex(strRequestMutable);\n         strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n     }\n \n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         try {\n             //deserialize only if user sent a request\n             if (strRequestMutable.size() > 0)\n@@ -466,7 +466,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         break;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         if (!fInputParsed)\n             return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\n         break;\n@@ -487,33 +487,35 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     std::vector<bool> hits;\n     bitmap.resize((vOutPoints.size() + 7) / 8);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-\n-        CCoinsView viewDummy;\n-        CCoinsViewCache view(&viewDummy);\n-\n-        CCoinsViewCache& viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-\n-        if (fCheckMemPool)\n-            view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n-\n-        for (size_t i = 0; i < vOutPoints.size(); i++) {\n-            bool hit = false;\n-            Coin coin;\n-            if (view.GetCoin(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n-                hit = true;\n-                outs.emplace_back(std::move(coin));\n+        auto process_utxos = [&vOutPoints, &outs, &hits](const CCoinsView& view, const CTxMemPool& mempool) {\n+            for (const COutPoint& vOutPoint : vOutPoints) {\n+                Coin coin;\n+                bool hit = !mempool.isSpent(vOutPoint) && view.GetCoin(vOutPoint, coin);\n+                hits.push_back(hit);\n+                if (hit) outs.emplace_back(std::move(coin));\n             }\n+        };\n+\n+        if (fCheckMemPool) {\n+            // use db+mempool as cache backend in case user likes to query mempool\n+            LOCK2(cs_main, mempool.cs);\n+            CCoinsViewCache& viewChain = *pcoinsTip;\n+            CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+            process_utxos(viewMempool, mempool);\n+        } else {\n+            LOCK(cs_main);  // no need to lock mempool!\n+            process_utxos(*pcoinsTip, CTxMemPool());\n+        }\n \n-            hits.push_back(hit);\n+        for (size_t i = 0; i < hits.size(); ++i) {\n+            const bool hit = hits[i];\n             bitmapStringRepresentation.append(hit ? \"1\" : \"0\"); // form a binary string representation (human-readable for json output)\n             bitmap[i / 8] |= ((uint8_t)hit) << (i % 8);\n         }\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         // serialize data\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n@@ -525,7 +527,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n         std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n@@ -535,7 +537,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objGetUTXOResponse(UniValue::VOBJ);\n \n         // pack in some essentials"
      },
      {
        "sha": "31cbec4c8664f5938b48ab7753b2a0a02094b84a",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 45,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -372,6 +372,9 @@ std::string EntryDescriptionString()\n            \"    \\\"wtxid\\\" : hash,         (string) hash of serialized transaction, including witness data\\n\"\n            \"    \\\"depends\\\" : [           (array) unconfirmed transactions used as inputs for this transaction\\n\"\n            \"        \\\"transactionid\\\",    (string) parent transaction id\\n\"\n+           \"       ... ]\\n\"\n+           \"    \\\"spentby\\\" : [           (array) unconfirmed transactions spending outputs from this transaction\\n\"\n+           \"        \\\"transactionid\\\",    (string) child transaction id\\n\"\n            \"       ... ]\\n\";\n }\n \n@@ -406,6 +409,15 @@ void entryToJSON(UniValue &info, const CTxMemPoolEntry &e)\n     }\n \n     info.pushKV(\"depends\", depends);\n+\n+    UniValue spent(UniValue::VARR);\n+    const CTxMemPool::txiter &it = mempool.mapTx.find(tx.GetHash());\n+    const CTxMemPool::setEntries &setChildren = mempool.GetMemPoolChildren(it);\n+    for (const CTxMemPool::txiter &childiter : setChildren) {\n+        spent.push_back(childiter->GetTx().GetHash().ToString());\n+    }\n+\n+    info.pushKV(\"spentby\", spent);\n }\n \n UniValue mempoolToJSON(bool fVerbose)\n@@ -697,10 +709,10 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n         fVerbose = request.params[1].get_bool();\n \n-    if (mapBlockIndex.count(hash) == 0)\n+    const CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+    if (!pblockindex) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+    }\n \n     if (!fVerbose)\n     {\n@@ -776,12 +788,12 @@ UniValue getblock(const JSONRPCRequest& request)\n             verbosity = request.params[1].get_bool() ? 1 : 0;\n     }\n \n-    if (mapBlockIndex.count(hash) == 0)\n+    const CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+    if (!pblockindex) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+    }\n \n     CBlock block;\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n-\n     if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not available (pruned data)\");\n \n@@ -822,18 +834,18 @@ static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash,\n {\n     assert(!outputs.empty());\n     ss << hash;\n-    ss << VARINT(outputs.begin()->second.nHeight * 2 + outputs.begin()->second.fCoinBase);\n+    ss << VARINT(outputs.begin()->second.nHeight * 2 + outputs.begin()->second.fCoinBase ? 1u : 0u);\n     stats.nTransactions++;\n     for (const auto output : outputs) {\n         ss << VARINT(output.first + 1);\n         ss << output.second.out.scriptPubKey;\n-        ss << VARINT(output.second.out.nValue);\n+        ss << VARINT(output.second.out.nValue, VarIntMode::NONNEGATIVE_SIGNED);\n         stats.nTransactionOutputs++;\n         stats.nTotalAmount += output.second.out.nValue;\n         stats.nBogoSize += 32 /* txid */ + 4 /* vout index */ + 4 /* height + coinbase */ + 8 /* amount */ +\n                            2 /* scriptPubKey len */ + output.second.out.scriptPubKey.size() /* scriptPubKey */;\n     }\n-    ss << VARINT(0);\n+    ss << VARINT(0u);\n }\n \n //! Calculate statistics about the unspent transaction output set\n@@ -846,7 +858,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n     stats.hashBlock = pcursor->GetBestBlock();\n     {\n         LOCK(cs_main);\n-        stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n+        stats.nHeight = LookupBlockIndex(stats.hashBlock)->nHeight;\n     }\n     ss << stats.hashBlock;\n     uint256 prevkey;\n@@ -1029,8 +1041,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n         }\n     }\n \n-    BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n-    CBlockIndex *pindex = it->second;\n+    const CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n     ret.pushKV(\"bestblock\", pindex->GetBlockHash().GetHex());\n     if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.pushKV(\"confirmations\", 0);\n@@ -1109,20 +1120,20 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     UniValue rv(UniValue::VOBJ);\n     const ThresholdState thresholdState = VersionBitsTipState(consensusParams, id);\n     switch (thresholdState) {\n-    case THRESHOLD_DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n-    case THRESHOLD_STARTED: rv.pushKV(\"status\", \"started\"); break;\n-    case THRESHOLD_LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n-    case THRESHOLD_ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n-    case THRESHOLD_FAILED: rv.pushKV(\"status\", \"failed\"); break;\n+    case ThresholdState::DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n+    case ThresholdState::STARTED: rv.pushKV(\"status\", \"started\"); break;\n+    case ThresholdState::LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n+    case ThresholdState::ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n+    case ThresholdState::FAILED: rv.pushKV(\"status\", \"failed\"); break;\n     }\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         rv.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n     }\n     rv.pushKV(\"startTime\", consensusParams.vDeployments[id].nStartTime);\n     rv.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n     rv.pushKV(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id));\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n         BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);\n@@ -1424,10 +1435,10 @@ UniValue preciousblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-\n-        pblockindex = mapBlockIndex[hash];\n+        }\n     }\n \n     CValidationState state;\n@@ -1460,10 +1471,11 @@ UniValue invalidateblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+        }\n \n-        CBlockIndex* pblockindex = mapBlockIndex[hash];\n         InvalidateBlock(state, Params(), pblockindex);\n     }\n \n@@ -1498,10 +1510,11 @@ UniValue reconsiderblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        if (mapBlockIndex.count(hash) == 0)\n+        CBlockIndex* pblockindex = LookupBlockIndex(hash);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+        }\n \n-        CBlockIndex* pblockindex = mapBlockIndex[hash];\n         ResetBlockFailureFlags(pblockindex);\n     }\n \n@@ -1542,25 +1555,18 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     const CBlockIndex* pindex;\n     int blockcount = 30 * 24 * 60 * 60 / Params().GetConsensus().nPowTargetSpacing; // By default: 1 month\n \n-    bool havehash = !request.params[1].isNull();\n-    uint256 hash;\n-    if (havehash) {\n-        hash = uint256S(request.params[1].get_str());\n-    }\n-\n-    {\n+    if (request.params[1].isNull()) {\n         LOCK(cs_main);\n-        if (havehash) {\n-            auto it = mapBlockIndex.find(hash);\n-            if (it == mapBlockIndex.end()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-            }\n-            pindex = it->second;\n-            if (!chainActive.Contains(pindex)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n-            }\n-        } else {\n-            pindex = chainActive.Tip();\n+        pindex = chainActive.Tip();\n+    } else {\n+        uint256 hash = uint256S(request.params[1].get_str());\n+        LOCK(cs_main);\n+        pindex = LookupBlockIndex(hash);\n+        if (!pindex) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+        }\n+        if (!chainActive.Contains(pindex)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n         }\n     }\n \n@@ -1601,13 +1607,17 @@ UniValue savemempool(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 0) {\n         throw std::runtime_error(\n             \"savemempool\\n\"\n-            \"\\nDumps the mempool to disk.\\n\"\n+            \"\\nDumps the mempool to disk. It will fail until the previous dump is fully loaded.\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"savemempool\", \"\")\n             + HelpExampleRpc(\"savemempool\", \"\")\n         );\n     }\n \n+    if (!g_is_mempool_loaded) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"The mempool was not loaded yet\");\n+    }\n+\n     if (!DumpMempool()) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Unable to dump mempool to disk\");\n     }"
      },
      {
        "sha": "e12685da650be6975dcbfc3c137b13186efeb676",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -40,12 +40,17 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"settxfee\", 0, \"amount\" },\n     { \"getreceivedbyaddress\", 1, \"minconf\" },\n     { \"getreceivedbyaccount\", 1, \"minconf\" },\n+    { \"getreceivedbylabel\", 1, \"minconf\" },\n     { \"listreceivedbyaddress\", 0, \"minconf\" },\n     { \"listreceivedbyaddress\", 1, \"include_empty\" },\n     { \"listreceivedbyaddress\", 2, \"include_watchonly\" },\n+    { \"listreceivedbyaddress\", 3, \"address_filter\" },\n     { \"listreceivedbyaccount\", 0, \"minconf\" },\n     { \"listreceivedbyaccount\", 1, \"include_empty\" },\n     { \"listreceivedbyaccount\", 2, \"include_watchonly\" },\n+    { \"listreceivedbylabel\", 0, \"minconf\" },\n+    { \"listreceivedbylabel\", 1, \"include_empty\" },\n+    { \"listreceivedbylabel\", 2, \"include_watchonly\" },\n     { \"getbalance\", 1, \"minconf\" },\n     { \"getbalance\", 2, \"include_watchonly\" },\n     { \"getblockhash\", 0, \"height\" },"
      },
      {
        "sha": "06882c0dfdd29347ccc2c459616b802f91609464",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 16,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -3,7 +3,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <base58.h>\n #include <amount.h>\n #include <chain.h>\n #include <chainparams.h>\n@@ -13,6 +12,7 @@\n #include <core_io.h>\n #include <init.h>\n #include <validation.h>\n+#include <key_io.h>\n #include <miner.h>\n #include <net.h>\n #include <policy/fees.h>\n@@ -396,9 +396,8 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n \n             uint256 hash = block.GetHash();\n-            BlockMap::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end()) {\n-                CBlockIndex *pindex = mi->second;\n+            const CBlockIndex* pindex = LookupBlockIndex(hash);\n+            if (pindex) {\n                 if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n                     return \"duplicate\";\n                 if (pindex->nStatus & BLOCK_FAILED_MASK)\n@@ -533,7 +532,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     pblock->nNonce = 0;\n \n     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n-    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n+    const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n \n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n@@ -594,15 +593,15 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n         ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n         switch (state) {\n-            case THRESHOLD_DEFINED:\n-            case THRESHOLD_FAILED:\n+            case ThresholdState::DEFINED:\n+            case ThresholdState::FAILED:\n                 // Not exposed to GBT at all\n                 break;\n-            case THRESHOLD_LOCKED_IN:\n+            case ThresholdState::LOCKED_IN:\n                 // Ensure bit is set in block version\n                 pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n                 // FALL THROUGH to get vbavailable set...\n-            case THRESHOLD_STARTED:\n+            case ThresholdState::STARTED:\n             {\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                 vbavailable.pushKV(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit);\n@@ -614,7 +613,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 }\n                 break;\n             }\n-            case THRESHOLD_ACTIVE:\n+            case ThresholdState::ACTIVE:\n             {\n                 // Add to rules only\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n@@ -727,9 +726,8 @@ UniValue submitblock(const JSONRPCRequest& request)\n     bool fBlockPresent = false;\n     {\n         LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(hash);\n-        if (mi != mapBlockIndex.end()) {\n-            CBlockIndex *pindex = mi->second;\n+        const CBlockIndex* pindex = LookupBlockIndex(hash);\n+        if (pindex) {\n             if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n                 return \"duplicate\";\n             }\n@@ -743,9 +741,9 @@ UniValue submitblock(const JSONRPCRequest& request)\n \n     {\n         LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi != mapBlockIndex.end()) {\n-            UpdateUncommittedBlockStructures(block, mi->second, Params().GetConsensus());\n+        const CBlockIndex* pindex = LookupBlockIndex(block.hashPrevBlock);\n+        if (pindex) {\n+            UpdateUncommittedBlockStructures(block, pindex, Params().GetConsensus());\n         }\n     }\n "
      },
      {
        "sha": "49e865a64ac3c6257f41066ccc5077f6bc1ceea6",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -3,12 +3,12 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <base58.h>\n #include <chain.h>\n #include <clientversion.h>\n #include <core_io.h>\n #include <crypto/ripemd160.h>\n #include <init.h>\n+#include <key_io.h>\n #include <validation.h>\n #include <httpserver.h>\n #include <net.h>\n@@ -224,13 +224,10 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n     std::string strPrivkey = request.params[0].get_str();\n     std::string strMessage = request.params[1].get_str();\n \n-    CBitcoinSecret vchSecret;\n-    bool fGood = vchSecret.SetString(strPrivkey);\n-    if (!fGood)\n+    CKey key = DecodeSecret(strPrivkey);\n+    if (!key.IsValid()) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n-    CKey key = vchSecret.GetKey();\n-    if (!key.IsValid())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+    }\n \n     CHashWriter ss(SER_GETHASH, 0);\n     ss << strMessageMagic;"
      },
      {
        "sha": "fee2b765ba8a9bc8aee9c260a092f6c246b3a61f",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -89,7 +89,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n             \"    \\\"pingtime\\\": n,             (numeric) ping time (if available)\\n\"\n             \"    \\\"minping\\\": n,              (numeric) minimum observed ping time (if any at all)\\n\"\n             \"    \\\"pingwait\\\": n,             (numeric) ping wait (if non-zero)\\n\"\n-            \"    \\\"version\\\": v,              (numeric) The peer version, such as 7001\\n\"\n+            \"    \\\"version\\\": v,              (numeric) The peer version, such as 70001\\n\"\n             \"    \\\"subver\\\": \\\"/Satoshi:0.8.5/\\\",  (string) The string version\\n\"\n             \"    \\\"inbound\\\": true|false,     (boolean) Inbound (true) or Outbound (false)\\n\"\n             \"    \\\"addnode\\\": true|false,     (boolean) Whether connection was due to addnode/-connect or if it was an automatic/inbound connection\\n\""
      },
      {
        "sha": "ff63bf49016e97e46c4648255cc07621934ccdda",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -76,7 +76,7 @@ enum RPCErrorCode\n     //! Wallet errors\n     RPC_WALLET_ERROR                = -4,  //!< Unspecified problem with wallet (key not found etc.)\n     RPC_WALLET_INSUFFICIENT_FUNDS   = -6,  //!< Not enough funds in wallet or account\n-    RPC_WALLET_INVALID_ACCOUNT_NAME = -11, //!< Invalid account name\n+    RPC_WALLET_INVALID_LABEL_NAME   = -11, //!< Invalid label name\n     RPC_WALLET_KEYPOOL_RAN_OUT      = -12, //!< Keypool ran out, call keypoolrefill first\n     RPC_WALLET_UNLOCK_NEEDED        = -13, //!< Enter the wallet passphrase with walletpassphrase first\n     RPC_WALLET_PASSPHRASE_INCORRECT = -14, //!< The wallet passphrase entered was incorrect\n@@ -85,6 +85,9 @@ enum RPCErrorCode\n     RPC_WALLET_ALREADY_UNLOCKED     = -17, //!< Wallet is already unlocked\n     RPC_WALLET_NOT_FOUND            = -18, //!< Invalid wallet specified\n     RPC_WALLET_NOT_SPECIFIED        = -19, //!< No wallet specified (error when there are multiple wallets loaded)\n+\n+    //! Backwards compatible aliases\n+    RPC_WALLET_INVALID_ACCOUNT_NAME = RPC_WALLET_INVALID_LABEL_NAME,\n };\n \n UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id);"
      },
      {
        "sha": "77040f75fda7fff1105e62f51cc2f5ee27999a6a",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 42,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -3,7 +3,6 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <base58.h>\n #include <chain.h>\n #include <coins.h>\n #include <consensus/validation.h>\n@@ -12,6 +11,7 @@\n #include <keystore.h>\n #include <validation.h>\n #include <validationinterface.h>\n+#include <key_io.h>\n #include <merkleblock.h>\n #include <net.h>\n #include <policy/policy.h>\n@@ -48,9 +48,8 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n \n     if (!hashBlock.IsNull()) {\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n-        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end() && (*mi).second) {\n-            CBlockIndex* pindex = (*mi).second;\n+        CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n+        if (pindex) {\n             if (chainActive.Contains(pindex)) {\n                 entry.pushKV(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight);\n                 entry.pushKV(\"time\", pindex->GetBlockTime());\n@@ -160,11 +159,10 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n \n     if (!request.params[2].isNull()) {\n         uint256 blockhash = ParseHashV(request.params[2], \"parameter 3\");\n-        BlockMap::iterator it = mapBlockIndex.find(blockhash);\n-        if (it == mapBlockIndex.end()) {\n+        blockindex = LookupBlockIndex(blockhash);\n+        if (!blockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block hash not found\");\n         }\n-        blockindex = it->second;\n         in_active_chain = chainActive.Contains(blockindex);\n     }\n \n@@ -238,9 +236,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n     {\n         hashBlock = uint256S(request.params[1].get_str());\n-        if (!mapBlockIndex.count(hashBlock))\n+        pblockindex = LookupBlockIndex(hashBlock);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-        pblockindex = mapBlockIndex[hashBlock];\n+        }\n     } else {\n         // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n         for (const auto& tx : setTxids) {\n@@ -257,9 +256,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         CTransactionRef tx;\n         if (!GetTransaction(oneTxid, tx, Params().GetConsensus(), hashBlock, false) || hashBlock.IsNull())\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\n-        if (!mapBlockIndex.count(hashBlock))\n+        pblockindex = LookupBlockIndex(hashBlock);\n+        if (!pblockindex) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction index corrupt\");\n-        pblockindex = mapBlockIndex[hashBlock];\n+        }\n     }\n \n     CBlock block;\n@@ -306,8 +306,10 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n+    const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n+    if (!pindex || !chainActive.Contains(pindex)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n+    }\n \n     for (const uint256& hash : vMatch)\n         res.push_back(hash.GetHex());\n@@ -316,9 +318,10 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n \n UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n         throw std::runtime_error(\n-            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime ) ( replaceable )\\n\"\n+            // clang-format off\n+            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n             \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n             \"Outputs can be addresses or data.\\n\"\n             \"Returns hex-encoded raw transaction.\\n\"\n@@ -329,37 +332,53 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n             \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n             \"     [\\n\"\n             \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",    (string, required) The transaction id\\n\"\n+            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n             \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n             \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n             \"       } \\n\"\n             \"       ,...\\n\"\n             \"     ]\\n\"\n-            \"2. \\\"outputs\\\"               (object, required) a json object with outputs\\n\"\n+            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+            \"   [\\n\"\n             \"    {\\n\"\n-            \"      \\\"address\\\": x.xxx,    (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the \" + CURRENCY_UNIT + \" amount\\n\"\n-            \"      \\\"data\\\": \\\"hex\\\"      (string, required) The key is \\\"data\\\", the value is hex encoded data\\n\"\n-            \"      ,...\\n\"\n+            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+            \"    },\\n\"\n+            \"    {\\n\"\n+            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n             \"    }\\n\"\n+            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+            \"                             accepted as second parameter.\\n\"\n+            \"   ]\\n\"\n             \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n             \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n             \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n \n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n+            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+            // clang-format on\n         );\n+    }\n \n-    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VOBJ, UniValue::VNUM, UniValue::VBOOL}, true);\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL\n+        }, true\n+    );\n     if (request.params[0].isNull() || request.params[1].isNull())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, arguments 1 and 2 must be non-null\");\n \n     UniValue inputs = request.params[0].get_array();\n-    UniValue sendTo = request.params[1].get_obj();\n+    const bool outputs_is_obj = request.params[1].isObject();\n+    UniValue outputs = outputs_is_obj ?\n+                           request.params[1].get_obj() :\n+                           request.params[1].get_array();\n \n     CMutableTransaction rawTx;\n \n@@ -411,11 +430,24 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n     }\n \n     std::set<CTxDestination> destinations;\n-    std::vector<std::string> addrList = sendTo.getKeys();\n-    for (const std::string& name_ : addrList) {\n-\n+    if (!outputs_is_obj) {\n+        // Translate array of key-value pairs into dict\n+        UniValue outputs_dict = UniValue(UniValue::VOBJ);\n+        for (size_t i = 0; i < outputs.size(); ++i) {\n+            const UniValue& output = outputs[i];\n+            if (!output.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, key-value pair not an object as expected\");\n+            }\n+            if (output.size() != 1) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, key-value pair must contain exactly one key\");\n+            }\n+            outputs_dict.pushKVs(output);\n+        }\n+        outputs = std::move(outputs_dict);\n+    }\n+    for (const std::string& name_ : outputs.getKeys()) {\n         if (name_ == \"data\") {\n-            std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),\"Data\");\n+            std::vector<unsigned char> data = ParseHexV(outputs[name_].getValStr(), \"Data\");\n \n             CTxOut out(0, CScript() << OP_RETURN << data);\n             rawTx.vout.push_back(out);\n@@ -430,7 +462,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n             }\n \n             CScript scriptPubKey = GetScriptForDestination(destination);\n-            CAmount nAmount = AmountFromValue(sendTo[name_]);\n+            CAmount nAmount = AmountFromValue(outputs[name_]);\n \n             CTxOut out(nAmount, scriptPubKey);\n             rawTx.vout.push_back(out);\n@@ -896,13 +928,9 @@ UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n     const UniValue& keys = request.params[1].get_array();\n     for (unsigned int idx = 0; idx < keys.size(); ++idx) {\n         UniValue k = keys[idx];\n-        CBitcoinSecret vchSecret;\n-        if (!vchSecret.SetString(k.get_str())) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n-        }\n-        CKey key = vchSecret.GetKey();\n+        CKey key = DecodeSecret(k.get_str());\n         if (!key.IsValid()) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n         }\n         keystore.AddKey(key);\n     }\n@@ -995,18 +1023,18 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         new_request.params.push_back(request.params[1]);\n         new_request.params.push_back(request.params[3]);\n         return signrawtransactionwithkey(new_request);\n-    }\n-    // Otherwise sign with the wallet which does not take a privkeys parameter\n+    } else {\n #ifdef ENABLE_WALLET\n-    else {\n+        // Otherwise sign with the wallet which does not take a privkeys parameter\n         new_request.params.push_back(request.params[0]);\n         new_request.params.push_back(request.params[1]);\n         new_request.params.push_back(request.params[3]);\n         return signrawtransactionwithwallet(new_request);\n-    }\n+#else\n+        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"No private keys available.\");\n #endif\n-    // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.\n-    throw JSONRPCError(RPC_INVALID_PARAMETER, \"No private keys available.\");\n+    }\n }\n \n UniValue sendrawtransaction(const JSONRPCRequest& request)"
      },
      {
        "sha": "c7c3b1f0d372d97df0395047471c2bfc7b1c2de6",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -5,9 +5,9 @@\n \n #include <rpc/server.h>\n \n-#include <base58.h>\n #include <fs.h>\n #include <init.h>\n+#include <key_io.h>\n #include <random.h>\n #include <sync.h>\n #include <ui_interface.h>\n@@ -50,12 +50,11 @@ void RPCServer::OnStopped(std::function<void ()> slot)\n }\n \n void RPCTypeCheck(const UniValue& params,\n-                  const std::list<UniValue::VType>& typesExpected,\n+                  const std::list<UniValueType>& typesExpected,\n                   bool fAllowNull)\n {\n     unsigned int i = 0;\n-    for (UniValue::VType t : typesExpected)\n-    {\n+    for (const UniValueType& t : typesExpected) {\n         if (params.size() <= i)\n             break;\n \n@@ -67,10 +66,10 @@ void RPCTypeCheck(const UniValue& params,\n     }\n }\n \n-void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected)\n+void RPCTypeCheckArgument(const UniValue& value, const UniValueType& typeExpected)\n {\n-    if (value.type() != typeExpected) {\n-        throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Expected type %s, got %s\", uvTypeName(typeExpected), uvTypeName(value.type())));\n+    if (!typeExpected.typeAny && value.type() != typeExpected.type) {\n+        throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Expected type %s, got %s\", uvTypeName(typeExpected.type), uvTypeName(value.type())));\n     }\n }\n \n@@ -368,7 +367,11 @@ void JSONRPCRequest::parse(const UniValue& valRequest)\n     if (!valMethod.isStr())\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n-    LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n+    if (fLogIPs)\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s user=%s peeraddr=%s\\n\", SanitizeString(strMethod),\n+            this->authUser, this->peerAddr);\n+    else\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s user=%s\\n\", SanitizeString(strMethod), this->authUser);\n \n     // Parse params\n     UniValue valParams = find_value(request, \"params\");"
      },
      {
        "sha": "7fc300f554cbaa3913f1ae7f818e1d4a77869de6",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -28,9 +28,9 @@ namespace RPCServer\n }\n \n /** Wrapper for UniValue::VType, which includes typeAny:\n- * Used to denote don't care type. Only used by RPCTypeCheckObj */\n+ * Used to denote don't care type. */\n struct UniValueType {\n-    explicit UniValueType(UniValue::VType _type) : typeAny(false), type(_type) {}\n+    UniValueType(UniValue::VType _type) : typeAny(false), type(_type) {}\n     UniValueType() : typeAny(true) {}\n     bool typeAny;\n     UniValue::VType type;\n@@ -45,6 +45,7 @@ class JSONRPCRequest\n     bool fHelp;\n     std::string URI;\n     std::string authUser;\n+    std::string peerAddr;\n \n     JSONRPCRequest() : id(NullUniValue), params(NullUniValue), fHelp(false) {}\n     void parse(const UniValue& valRequest);\n@@ -69,12 +70,12 @@ bool RPCIsInWarmup(std::string *outStatus);\n  * the right number of arguments are passed, just that any passed are the correct type.\n  */\n void RPCTypeCheck(const UniValue& params,\n-                  const std::list<UniValue::VType>& typesExpected, bool fAllowNull=false);\n+                  const std::list<UniValueType>& typesExpected, bool fAllowNull=false);\n \n /**\n  * Type-check one argument; throws JSONRPCError if wrong type given.\n  */\n-void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected);\n+void RPCTypeCheckArgument(const UniValue& value, const UniValueType& typeExpected);\n \n /*\n   Check for expected keys/value types in an Object.\n@@ -165,8 +166,17 @@ class CRPCTable\n \n     /**\n      * Appends a CRPCCommand to the dispatch table.\n+     *\n      * Returns false if RPC server is already running (dump concurrency protection).\n+     *\n      * Commands cannot be overwritten (returns false).\n+     *\n+     * Commands with different method names but the same callback function will\n+     * be considered aliases, and only the first registered method name will\n+     * show up in the help text command listing. Aliased commands do not have\n+     * to have the same behavior. Server and client code can distinguish\n+     * between calls based on method name, and aliased commands can also\n+     * register different names, types, and numbers of parameters.\n      */\n     bool appendCommand(const std::string& name, const CRPCCommand* pcmd);\n };"
      },
      {
        "sha": "e72b1c4840ec7246ff64bced2acf8493125a7918",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -2,9 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <base58.h>\n+#include <key_io.h>\n #include <keystore.h>\n-#include <pubkey.h>\n #include <rpc/protocol.h>\n #include <rpc/util.h>\n #include <tinyformat.h>"
      },
      {
        "sha": "c6a79d5cf9527de3c18936ce4f677f019d7eb84e",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,7 +8,6 @@\n #include <pubkey.h>\n #include <script/standard.h>\n #include <univalue.h>\n-#include <utilstrencodings.h>\n \n #include <boost/variant/static_visitor.hpp>\n "
      },
      {
        "sha": "8cc44b675ffe0271e9e908da0d4d16e3cca83bab",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -40,7 +40,7 @@ class TxInputStream\n     }\n \n     template<typename T>\n-    TxInputStream& operator>>(T& obj)\n+    TxInputStream& operator>>(T&& obj)\n     {\n         ::Unserialize(*this, obj);\n         return *this;"
      },
      {
        "sha": "07b2292d461a462beab7fe866ea8733bfc48daf7",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 18,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -110,7 +110,7 @@ bool static IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n     //   excluding the sighash byte.\n     // * R-length: 1-byte length descriptor of the R value that follows.\n     // * R: arbitrary-length big-endian encoded R value. It must use the shortest\n-    //   possible encoding for a positive integers (which means no null bytes at\n+    //   possible encoding for a positive integer (which means no null bytes at\n     //   the start, except a single one when the next byte has its highest bit set).\n     // * S-length: 1-byte length descriptor of the S value that follows.\n     // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n@@ -219,30 +219,32 @@ bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, co\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n     // Only compressed keys are accepted in segwit\n-    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SigVersion::WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n     }\n     return true;\n }\n \n bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n+    // Excludes OP_1NEGATE, OP_1-16 since they are by definition minimal\n+    assert(0 <= opcode && opcode <= OP_PUSHDATA4);\n     if (data.size() == 0) {\n-        // Could have used OP_0.\n+        // Should have used OP_0.\n         return opcode == OP_0;\n     } else if (data.size() == 1 && data[0] >= 1 && data[0] <= 16) {\n-        // Could have used OP_1 .. OP_16.\n-        return opcode == OP_1 + (data[0] - 1);\n+        // Should have used OP_1 .. OP_16.\n+        return false;\n     } else if (data.size() == 1 && data[0] == 0x81) {\n-        // Could have used OP_1NEGATE.\n-        return opcode == OP_1NEGATE;\n+        // Should have used OP_1NEGATE.\n+        return false;\n     } else if (data.size() <= 75) {\n-        // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n+        // Must have used a direct push (opcode indicating number of bytes pushed + those bytes).\n         return opcode == data.size();\n     } else if (data.size() <= 255) {\n-        // Could have used OP_PUSHDATA.\n+        // Must have used OP_PUSHDATA.\n         return opcode == OP_PUSHDATA1;\n     } else if (data.size() <= 65535) {\n-        // Could have used OP_PUSHDATA2.\n+        // Must have used OP_PUSHDATA2.\n         return opcode == OP_PUSHDATA2;\n     }\n     return true;\n@@ -441,7 +443,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SIGVERSION_WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n                             if (vch.size() == 1 && vch[0] != 1)\n@@ -888,7 +890,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signature in pre-segwit scripts but not segwit scripts\n-                    if (sigversion == SIGVERSION_BASE) {\n+                    if (sigversion == SigVersion::BASE) {\n                         scriptCode.FindAndDelete(CScript(vchSig));\n                     }\n \n@@ -952,7 +954,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     for (int k = 0; k < nSigsCount; k++)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n-                        if (sigversion == SIGVERSION_BASE) {\n+                        if (sigversion == SigVersion::BASE) {\n                             scriptCode.FindAndDelete(CScript(vchSig));\n                         }\n                     }\n@@ -1180,7 +1182,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n {\n     assert(nIn < txTo.vin.size());\n \n-    if (sigversion == SIGVERSION_WITNESS_V0) {\n+    if (sigversion == SigVersion::WITNESS_V0) {\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n@@ -1394,7 +1396,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror)) {\n         return false;\n     }\n \n@@ -1421,12 +1423,12 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     }\n \n     std::vector<std::vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (stack.empty())\n@@ -1472,7 +1474,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stack);\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, SIGVERSION_BASE, serror))\n+        if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n             // serror is set\n             return false;\n         if (stack.empty())"
      },
      {
        "sha": "bb7750d78346d1ae354333997c740ed45e6409be",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -123,10 +123,10 @@ struct PrecomputedTransactionData\n     explicit PrecomputedTransactionData(const CTransaction& tx);\n };\n \n-enum SigVersion\n+enum class SigVersion\n {\n-    SIGVERSION_BASE = 0,\n-    SIGVERSION_WITNESS_V0 = 1,\n+    BASE = 0,\n+    WITNESS_V0 = 1,\n };\n \n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);"
      },
      {
        "sha": "05bc5e9bd692852bd2798c7400794934ee5142e6",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -61,7 +61,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        if (sigversion != SIGVERSION_BASE && vSolutions[0].size() != 33) {\n+        if (sigversion != SigVersion::BASE && vSolutions[0].size() != 33) {\n             isInvalid = true;\n             return ISMINE_NO;\n         }\n@@ -76,14 +76,14 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n             // This also applies to the P2WSH case.\n             break;\n         }\n-        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SIGVERSION_WITNESS_V0);\n+        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SigVersion::WITNESS_V0);\n         if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n             return ret;\n         break;\n     }\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (sigversion != SigVersion::BASE) {\n             CPubKey pubkey;\n             if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n                 isInvalid = true;\n@@ -114,7 +114,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript, isInvalid, SIGVERSION_WITNESS_V0);\n+            isminetype ret = IsMine(keystore, subscript, isInvalid, SigVersion::WITNESS_V0);\n             if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n@@ -129,7 +129,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (sigversion != SigVersion::BASE) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {\n                     isInvalid = true;"
      },
      {
        "sha": "f93a66e35aa8fd3a8210a9fe3fcf79721697bf3c",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -31,11 +31,11 @@ typedef uint8_t isminefilter;\n /* isInvalid becomes true when the script is found invalid by consensus or policy. This will terminate the recursion\n  * and return ISMINE_NO immediately, as an invalid script should never be considered as \"mine\". This is needed as\n  * different SIGVERSION may have different network rules. Currently the only use of isInvalid is indicate uncompressed\n- * keys in SIGVERSION_WITNESS_V0 script, but could also be used in similar cases in the future\n+ * keys in SigVersion::WITNESS_V0 script, but could also be used in similar cases in the future\n  */\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SigVersion::BASE);\n \n #endif // BITCOIN_SCRIPT_ISMINE_H"
      },
      {
        "sha": "910bb39ce6aa08e0a5e0e4e961547916248af3be",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 24,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -6,7 +6,6 @@\n #include <script/sign.h>\n \n #include <key.h>\n-#include <keystore.h>\n #include <policy/policy.h>\n #include <primitives/transaction.h>\n #include <script/standard.h>\n@@ -15,16 +14,16 @@\n \n typedef std::vector<unsigned char> valtype;\n \n-TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n+TransactionSignatureCreator::TransactionSignatureCreator(const SigningProvider* provider, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(provider), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n \n bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CKey key;\n-    if (!keystore->GetKey(address, key))\n+    if (!m_provider->GetKey(address, key))\n         return false;\n \n     // Signing with uncompressed keys is disabled in witness scripts\n-    if (sigversion == SIGVERSION_WITNESS_V0 && !key.IsCompressed())\n+    if (sigversion == SigVersion::WITNESS_V0 && !key.IsCompressed())\n         return false;\n \n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n@@ -91,12 +90,12 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n         else\n         {\n             CPubKey vch;\n-            creator.KeyStore().GetPubKey(keyID, vch);\n+            creator.Provider().GetPubKey(keyID, vch);\n             ret.push_back(ToByteVector(vch));\n         }\n         return true;\n     case TX_SCRIPTHASH:\n-        if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) {\n+        if (creator.Provider().GetCScript(uint160(vSolutions[0]), scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -112,7 +111,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n \n     case TX_WITNESS_V0_SCRIPTHASH:\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin());\n-        if (creator.KeyStore().GetCScript(h160, scriptRet)) {\n+        if (creator.Provider().GetCScript(h160, scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -140,10 +139,9 @@ static CScript PushAll(const std::vector<valtype>& values)\n \n bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)\n {\n-    CScript script = fromPubKey;\n     std::vector<valtype> result;\n     txnouttype whichType;\n-    bool solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);\n+    bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE);\n     bool P2SH = false;\n     CScript subscript;\n     sigdata.scriptWitness.stack.clear();\n@@ -153,8 +151,8 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         // Solver returns the subscript that needs to be evaluated;\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n-        script = subscript = CScript(result[0].begin(), result[0].end());\n-        solved = solved && SignStep(creator, script, result, whichType, SIGVERSION_BASE) && whichType != TX_SCRIPTHASH;\n+        subscript = CScript(result[0].begin(), result[0].end());\n+        solved = solved && SignStep(creator, subscript, result, whichType, SigVersion::BASE) && whichType != TX_SCRIPTHASH;\n         P2SH = true;\n     }\n \n@@ -163,15 +161,15 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         CScript witnessscript;\n         witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0);\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SigVersion::WITNESS_V0);\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n     }\n     else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n     {\n         CScript witnessscript(result[0].begin(), result[0].end());\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SigVersion::WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n         result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n@@ -195,34 +193,39 @@ SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nI\n     return data;\n }\n \n+void UpdateInput(CTxIn& input, const SignatureData& data)\n+{\n+    input.scriptSig = data.scriptSig;\n+    input.scriptWitness = data.scriptWitness;\n+}\n+\n void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data)\n {\n     assert(tx.vin.size() > nIn);\n-    tx.vin[nIn].scriptSig = data.scriptSig;\n-    tx.vin[nIn].scriptWitness = data.scriptWitness;\n+    UpdateInput(tx.vin[nIn], data);\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n+bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n \n     CTransaction txToConst(txTo);\n-    TransactionSignatureCreator creator(&keystore, &txToConst, nIn, amount, nHashType);\n+    TransactionSignatureCreator creator(&provider, &txToConst, nIn, amount, nHashType);\n \n     SignatureData sigdata;\n     bool ret = ProduceSignature(creator, fromPubKey, sigdata);\n     UpdateTransaction(txTo, nIn, sigdata);\n     return ret;\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n     assert(txin.prevout.n < txFrom.vout.size());\n     const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n-    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n+    return SignSignature(provider, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n@@ -290,7 +293,7 @@ struct Stacks\n     Stacks() {}\n     explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n     explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n-        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     }\n \n     SignatureData Output() const {\n@@ -366,7 +369,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             sigs2.witness.pop_back();\n             sigs2.script = sigs2.witness;\n             sigs2.witness.clear();\n-            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SIGVERSION_WITNESS_V0);\n+            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SigVersion::WITNESS_V0);\n             result.witness = result.script;\n             result.script.clear();\n             result.witness.push_back(valtype(pubKey2.begin(), pubKey2.end()));\n@@ -384,7 +387,7 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n     std::vector<std::vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n-    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();\n+    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SigVersion::BASE).Output();\n }\n \n namespace {\n@@ -423,13 +426,13 @@ bool DummySignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const\n     return true;\n }\n \n-bool IsSolvable(const CKeyStore& store, const CScript& script)\n+bool IsSolvable(const SigningProvider& provider, const CScript& script)\n {\n     // This check is to make sure that the script we created can actually be solved for and signed by us\n     // if we were to have the private keys. This is just to make sure that the script is valid and that,\n     // if found in a transaction, we would still accept and relay that transaction. In particular,\n     // it will reject witness outputs that require signing with an uncompressed public key.\n-    DummySignatureCreator creator(&store);\n+    DummySignatureCreator creator(&provider);\n     SignatureData sigs;\n     // Make sure that STANDARD_SCRIPT_VERIFY_FLAGS includes SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, the most\n     // important property this function is designed to test for."
      },
      {
        "sha": "c301f0544f7b4ad0c22ba8ad8ebc12a082639b09",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 23,
        "deletions": 11,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,21 +8,32 @@\n \n #include <script/interpreter.h>\n \n+class CKey;\n class CKeyID;\n-class CKeyStore;\n class CScript;\n+class CScriptID;\n class CTransaction;\n \n struct CMutableTransaction;\n \n+/** An interface to be implemented by keystores that support signing. */\n+class SigningProvider\n+{\n+public:\n+    virtual ~SigningProvider() {}\n+    virtual bool GetCScript(const CScriptID &scriptid, CScript& script) const =0;\n+    virtual bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const =0;\n+    virtual bool GetKey(const CKeyID &address, CKey& key) const =0;\n+};\n+\n /** Virtual base class for signature creators. */\n class BaseSignatureCreator {\n protected:\n-    const CKeyStore* keystore;\n+    const SigningProvider* m_provider;\n \n public:\n-    explicit BaseSignatureCreator(const CKeyStore* keystoreIn) : keystore(keystoreIn) {}\n-    const CKeyStore& KeyStore() const { return *keystore; };\n+    explicit BaseSignatureCreator(const SigningProvider* provider) : m_provider(provider) {}\n+    const SigningProvider& Provider() const { return *m_provider; }\n     virtual ~BaseSignatureCreator() {}\n     virtual const BaseSignatureChecker& Checker() const =0;\n \n@@ -39,7 +50,7 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n     const TransactionSignatureChecker checker;\n \n public:\n-    TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n+    TransactionSignatureCreator(const SigningProvider* provider, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n     const BaseSignatureChecker& Checker() const override { return checker; }\n     bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n@@ -48,13 +59,13 @@ class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n     CTransaction tx;\n \n public:\n-    MutableTransactionSignatureCreator(const CKeyStore* keystoreIn, const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(keystoreIn, &tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n+    MutableTransactionSignatureCreator(const SigningProvider* provider, const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(provider, &tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n };\n \n /** A signature creator that just produces 72-byte empty signatures. */\n class DummySignatureCreator : public BaseSignatureCreator {\n public:\n-    explicit DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n+    explicit DummySignatureCreator(const SigningProvider* provider) : BaseSignatureCreator(provider) {}\n     const BaseSignatureChecker& Checker() const override;\n     bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n@@ -71,20 +82,21 @@ struct SignatureData {\n bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n /** Produce a script signature for a transaction. */\n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n+bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n+bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n /** Combine two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders. */\n SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const SignatureData& scriptSig1, const SignatureData& scriptSig2);\n \n /** Extract signature data from a transaction, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn);\n void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data);\n+void UpdateInput(CTxIn& input, const SignatureData& data);\n \n /* Check whether we know how to sign for an output like this, assuming we\n  * have all private keys. While this function does not need private keys, the passed\n- * keystore is used to look up public keys and redeemscripts by hash.\n+ * provider is used to look up public keys and redeemscripts by hash.\n  * Solvability is unrelated to whether we consider this output to be ours. */\n-bool IsSolvable(const CKeyStore& store, const CScript& script);\n+bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n #endif // BITCOIN_SCRIPT_SIGN_H"
      },
      {
        "sha": "247e915298443401b203c093fd1bc4e4cc310f8d",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 55,
        "deletions": 47,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -59,6 +59,12 @@ inline T* NCONST_PTR(const T* val)\n     return const_cast<T*>(val);\n }\n \n+//! Safely convert odd char pointer types to standard ones.\n+inline char* CharCast(char* c) { return c; }\n+inline char* CharCast(unsigned char* c) { return (char*)c; }\n+inline const char* CharCast(const char* c) { return c; }\n+inline const char* CharCast(const unsigned char* c) { return (const char*)c; }\n+\n /*\n  * Lowest-level serialization and conversion.\n  * @note Sizes of these types are verified in the tests\n@@ -148,8 +154,7 @@ enum\n     SER_GETHASH         = (1 << 2),\n };\n \n-#define READWRITE(obj)      (::SerReadWrite(s, (obj), ser_action))\n-#define READWRITEMANY(...)      (::SerReadWriteMany(s, ser_action, __VA_ARGS__))\n+#define READWRITE(...)      (::SerReadWriteMany(s, ser_action, __VA_ARGS__))\n \n /** \n  * Implement three methods for serializable objects. These are actually wrappers over\n@@ -178,6 +183,8 @@ template<typename Stream> inline void Serialize(Stream& s, int64_t a ) { ser_wri\n template<typename Stream> inline void Serialize(Stream& s, uint64_t a) { ser_writedata64(s, a); }\n template<typename Stream> inline void Serialize(Stream& s, float a   ) { ser_writedata32(s, ser_float_to_uint32(a)); }\n template<typename Stream> inline void Serialize(Stream& s, double a  ) { ser_writedata64(s, ser_double_to_uint64(a)); }\n+template<typename Stream, int N> inline void Serialize(Stream& s, const char (&a)[N]) { s.write(a, N); }\n+template<typename Stream, int N> inline void Serialize(Stream& s, const unsigned char (&a)[N]) { s.write(CharCast(a), N); }\n \n template<typename Stream> inline void Unserialize(Stream& s, char& a    ) { a = ser_readdata8(s); } // TODO Get rid of bare char\n template<typename Stream> inline void Unserialize(Stream& s, int8_t& a  ) { a = ser_readdata8(s); }\n@@ -190,6 +197,8 @@ template<typename Stream> inline void Unserialize(Stream& s, int64_t& a ) { a =\n template<typename Stream> inline void Unserialize(Stream& s, uint64_t& a) { a = ser_readdata64(s); }\n template<typename Stream> inline void Unserialize(Stream& s, float& a   ) { a = ser_uint32_to_float(ser_readdata32(s)); }\n template<typename Stream> inline void Unserialize(Stream& s, double& a  ) { a = ser_uint64_to_double(ser_readdata64(s)); }\n+template<typename Stream, int N> inline void Unserialize(Stream& s, char (&a)[N]) { s.read(a, N); }\n+template<typename Stream, int N> inline void Unserialize(Stream& s, unsigned char (&a)[N]) { s.read(CharCast(a), N); }\n \n template<typename Stream> inline void Serialize(Stream& s, bool a)    { char f=a; ser_writedata8(s, f); }\n template<typename Stream> inline void Unserialize(Stream& s, bool& a) { char f=ser_readdata8(s); a=f; }\n@@ -297,9 +306,31 @@ uint64_t ReadCompactSize(Stream& is)\n  * 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n  */\n \n-template<typename I>\n+/**\n+ * Mode for encoding VarInts.\n+ *\n+ * Currently there is no support for signed encodings. The default mode will not\n+ * compile with signed values, and the legacy \"nonnegative signed\" mode will\n+ * accept signed values, but improperly encode and decode them if they are\n+ * negative. In the future, the DEFAULT mode could be extended to support\n+ * negative numbers in a backwards compatible way, and additional modes could be\n+ * added to support different varint formats (e.g. zigzag encoding).\n+ */\n+enum class VarIntMode { DEFAULT, NONNEGATIVE_SIGNED };\n+\n+template <VarIntMode Mode, typename I>\n+struct CheckVarIntMode {\n+    constexpr CheckVarIntMode()\n+    {\n+        static_assert(Mode != VarIntMode::DEFAULT || std::is_unsigned<I>::value, \"Unsigned type required with mode DEFAULT.\");\n+        static_assert(Mode != VarIntMode::NONNEGATIVE_SIGNED || std::is_signed<I>::value, \"Signed type required with mode NONNEGATIVE_SIGNED.\");\n+    }\n+};\n+\n+template<VarIntMode Mode, typename I>\n inline unsigned int GetSizeOfVarInt(I n)\n {\n+    CheckVarIntMode<Mode, I>();\n     int nRet = 0;\n     while(true) {\n         nRet++;\n@@ -313,9 +344,10 @@ inline unsigned int GetSizeOfVarInt(I n)\n template<typename I>\n inline void WriteVarInt(CSizeComputer& os, I n);\n \n-template<typename Stream, typename I>\n+template<typename Stream, VarIntMode Mode, typename I>\n void WriteVarInt(Stream& os, I n)\n {\n+    CheckVarIntMode<Mode, I>();\n     unsigned char tmp[(sizeof(n)*8+6)/7];\n     int len=0;\n     while(true) {\n@@ -330,9 +362,10 @@ void WriteVarInt(Stream& os, I n)\n     } while(len--);\n }\n \n-template<typename Stream, typename I>\n+template<typename Stream, VarIntMode Mode, typename I>\n I ReadVarInt(Stream& is)\n {\n+    CheckVarIntMode<Mode, I>();\n     I n = 0;\n     while(true) {\n         unsigned char chData = ser_readdata8(is);\n@@ -351,10 +384,10 @@ I ReadVarInt(Stream& is)\n     }\n }\n \n-#define FLATDATA(obj) REF(CFlatData((char*)&(obj), (char*)&(obj) + sizeof(obj)))\n-#define VARINT(obj) REF(WrapVarInt(REF(obj)))\n-#define COMPACTSIZE(obj) REF(CCompactSize(REF(obj)))\n-#define LIMITED_STRING(obj,n) REF(LimitedString< n >(REF(obj)))\n+#define FLATDATA(obj) CFlatData((char*)&(obj), (char*)&(obj) + sizeof(obj))\n+#define VARINT(obj, ...) WrapVarInt<__VA_ARGS__>(REF(obj))\n+#define COMPACTSIZE(obj) CCompactSize(REF(obj))\n+#define LIMITED_STRING(obj,n) LimitedString< n >(REF(obj))\n \n /** \n  * Wrapper for serializing arrays and POD.\n@@ -396,7 +429,7 @@ class CFlatData\n     }\n };\n \n-template<typename I>\n+template<VarIntMode Mode, typename I>\n class CVarInt\n {\n protected:\n@@ -406,12 +439,12 @@ class CVarInt\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        WriteVarInt<Stream,I>(s, n);\n+        WriteVarInt<Stream,Mode,I>(s, n);\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream& s) {\n-        n = ReadVarInt<Stream,I>(s);\n+        n = ReadVarInt<Stream,Mode,I>(s);\n     }\n };\n \n@@ -462,8 +495,8 @@ class LimitedString\n     }\n };\n \n-template<typename I>\n-CVarInt<I> WrapVarInt(I& n) { return CVarInt<I>(n); }\n+template<VarIntMode Mode=VarIntMode::DEFAULT, typename I>\n+CVarInt<Mode, I> WrapVarInt(I& n) { return CVarInt<Mode, I>{n}; }\n \n /**\n  * Forward declarations\n@@ -539,7 +572,7 @@ inline void Serialize(Stream& os, const T& a)\n }\n \n template<typename Stream, typename T>\n-inline void Unserialize(Stream& is, T& a)\n+inline void Unserialize(Stream& is, T&& a)\n {\n     a.Unserialize(is);\n }\n@@ -825,19 +858,6 @@ struct CSerActionUnserialize\n     constexpr bool ForRead() const { return true; }\n };\n \n-template<typename Stream, typename T>\n-inline void SerReadWrite(Stream& s, const T& obj, CSerActionSerialize ser_action)\n-{\n-    ::Serialize(s, obj);\n-}\n-\n-template<typename Stream, typename T>\n-inline void SerReadWrite(Stream& s, T& obj, CSerActionUnserialize ser_action)\n-{\n-    ::Unserialize(s, obj);\n-}\n-\n-\n \n \n \n@@ -897,45 +917,33 @@ void SerializeMany(Stream& s)\n {\n }\n \n-template<typename Stream, typename Arg>\n-void SerializeMany(Stream& s, Arg&& arg)\n-{\n-    ::Serialize(s, std::forward<Arg>(arg));\n-}\n-\n template<typename Stream, typename Arg, typename... Args>\n-void SerializeMany(Stream& s, Arg&& arg, Args&&... args)\n+void SerializeMany(Stream& s, const Arg& arg, const Args&... args)\n {\n-    ::Serialize(s, std::forward<Arg>(arg));\n-    ::SerializeMany(s, std::forward<Args>(args)...);\n+    ::Serialize(s, arg);\n+    ::SerializeMany(s, args...);\n }\n \n template<typename Stream>\n inline void UnserializeMany(Stream& s)\n {\n }\n \n-template<typename Stream, typename Arg>\n-inline void UnserializeMany(Stream& s, Arg& arg)\n-{\n-    ::Unserialize(s, arg);\n-}\n-\n template<typename Stream, typename Arg, typename... Args>\n-inline void UnserializeMany(Stream& s, Arg& arg, Args&... args)\n+inline void UnserializeMany(Stream& s, Arg&& arg, Args&&... args)\n {\n     ::Unserialize(s, arg);\n     ::UnserializeMany(s, args...);\n }\n \n template<typename Stream, typename... Args>\n-inline void SerReadWriteMany(Stream& s, CSerActionSerialize ser_action, Args&&... args)\n+inline void SerReadWriteMany(Stream& s, CSerActionSerialize ser_action, const Args&... args)\n {\n-    ::SerializeMany(s, std::forward<Args>(args)...);\n+    ::SerializeMany(s, args...);\n }\n \n template<typename Stream, typename... Args>\n-inline void SerReadWriteMany(Stream& s, CSerActionUnserialize ser_action, Args&... args)\n+inline void SerReadWriteMany(Stream& s, CSerActionUnserialize ser_action, Args&&... args)\n {\n     ::UnserializeMany(s, args...);\n }"
      },
      {
        "sha": "6ba4f103daa7a5cf96b4c47b5fc442e11ef808e4",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -42,7 +42,7 @@ class OverrideStream\n     }\n \n     template<typename T>\n-    OverrideStream<Stream>& operator>>(T& obj)\n+    OverrideStream<Stream>& operator>>(T&& obj)\n     {\n         // Unserialize from this stream\n         ::Unserialize(*this, obj);\n@@ -399,7 +399,7 @@ class CDataStream\n     }\n \n     template<typename T>\n-    CDataStream& operator>>(T& obj)\n+    CDataStream& operator>>(T&& obj)\n     {\n         // Unserialize from this stream\n         ::Unserialize(*this, obj);\n@@ -543,7 +543,7 @@ class CAutoFile\n     }\n \n     template<typename T>\n-    CAutoFile& operator>>(T& obj)\n+    CAutoFile& operator>>(T&& obj)\n     {\n         // Unserialize from this stream\n         if (!file)\n@@ -686,7 +686,7 @@ class CBufferedFile\n     }\n \n     template<typename T>\n-    CBufferedFile& operator>>(T& obj) {\n+    CBufferedFile& operator>>(T&& obj) {\n         // Unserialize from this stream\n         ::Unserialize(*this, obj);\n         return (*this);"
      },
      {
        "sha": "f10fd07c630526144070ed3640a083182dffc971",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 26,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -47,7 +47,9 @@ Arena::Arena(void *base_in, size_t size_in, size_t alignment_in):\n     base(static_cast<char*>(base_in)), end(static_cast<char*>(base_in) + size_in), alignment(alignment_in)\n {\n     // Start with one free chunk that covers the entire arena\n-    chunks_free.emplace(base, size_in);\n+    auto it = size_to_free_chunk.emplace(size_in, base);\n+    chunks_free.emplace(base, it);\n+    chunks_free_end.emplace(base + size_in, it);\n }\n \n Arena::~Arena()\n@@ -63,26 +65,30 @@ void* Arena::alloc(size_t size)\n     if (size == 0)\n         return nullptr;\n \n-    // Pick a large enough free-chunk\n-    auto it = std::find_if(chunks_free.begin(), chunks_free.end(),\n-        [=](const std::map<char*, size_t>::value_type& chunk){ return chunk.second >= size; });\n-    if (it == chunks_free.end())\n+    // Pick a large enough free-chunk. Returns an iterator pointing to the first element that is not less than key.\n+    // This allocation strategy is best-fit. According to \"Dynamic Storage Allocation: A Survey and Critical Review\",\n+    // Wilson et. al. 1995, http://www.scs.stanford.edu/14wi-cs140/sched/readings/wilson.pdf, best-fit and first-fit\n+    // policies seem to work well in practice.\n+    auto size_ptr_it = size_to_free_chunk.lower_bound(size);\n+    if (size_ptr_it == size_to_free_chunk.end())\n         return nullptr;\n \n     // Create the used-chunk, taking its space from the end of the free-chunk\n-    auto alloced = chunks_used.emplace(it->first + it->second - size, size).first;\n-    if (!(it->second -= size))\n-        chunks_free.erase(it);\n-    return reinterpret_cast<void*>(alloced->first);\n-}\n-\n-/* extend the Iterator if other begins at its end */\n-template <class Iterator, class Pair> bool extend(Iterator it, const Pair& other) {\n-    if (it->first + it->second == other.first) {\n-        it->second += other.second;\n-        return true;\n+    const size_t size_remaining = size_ptr_it->first - size;\n+    auto alloced = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;\n+    chunks_free_end.erase(size_ptr_it->second + size_ptr_it->first);\n+    if (size_ptr_it->first == size) {\n+        // whole chunk is used up\n+        chunks_free.erase(size_ptr_it->second);\n+    } else {\n+        // still some memory left in the chunk\n+        auto it_remaining = size_to_free_chunk.emplace(size_remaining, size_ptr_it->second);\n+        chunks_free[size_ptr_it->second] = it_remaining;\n+        chunks_free_end.emplace(size_ptr_it->second + size_remaining, it_remaining);\n     }\n-    return false;\n+    size_to_free_chunk.erase(size_ptr_it);\n+\n+    return reinterpret_cast<void*>(alloced->first);\n }\n \n void Arena::free(void *ptr)\n@@ -97,16 +103,30 @@ void Arena::free(void *ptr)\n     if (i == chunks_used.end()) {\n         throw std::runtime_error(\"Arena: invalid or double free\");\n     }\n-    auto freed = *i;\n+    std::pair<char*, size_t> freed = *i;\n     chunks_used.erase(i);\n \n-    // Add space to free map, coalescing contiguous chunks\n-    auto next = chunks_free.upper_bound(freed.first);\n-    auto prev = (next == chunks_free.begin()) ? chunks_free.end() : std::prev(next);\n-    if (prev == chunks_free.end() || !extend(prev, freed))\n-        prev = chunks_free.emplace_hint(next, freed);\n-    if (next != chunks_free.end() && extend(prev, *next))\n+    // coalesce freed with previous chunk\n+    auto prev = chunks_free_end.find(freed.first);\n+    if (prev != chunks_free_end.end()) {\n+        freed.first -= prev->second->first;\n+        freed.second += prev->second->first;\n+        size_to_free_chunk.erase(prev->second);\n+        chunks_free_end.erase(prev);\n+    }\n+\n+    // coalesce freed with chunk after freed\n+    auto next = chunks_free.find(freed.first + freed.second);\n+    if (next != chunks_free.end()) {\n+        freed.second += next->second->first;\n+        size_to_free_chunk.erase(next->second);\n         chunks_free.erase(next);\n+    }\n+\n+    // Add/set space with coalesced free chunk\n+    auto it = size_to_free_chunk.emplace(freed.second, freed.first);\n+    chunks_free[freed.first] = it;\n+    chunks_free_end[freed.first + freed.second] = it;\n }\n \n Arena::Stats Arena::stats() const\n@@ -115,7 +135,7 @@ Arena::Stats Arena::stats() const\n     for (const auto& chunk: chunks_used)\n         r.used += chunk.second;\n     for (const auto& chunk: chunks_free)\n-        r.free += chunk.second;\n+        r.free += chunk.second->first;\n     r.total = r.used + r.free;\n     return r;\n }\n@@ -184,7 +204,7 @@ void Win32LockedPageAllocator::FreeLocked(void* addr, size_t len)\n \n size_t Win32LockedPageAllocator::GetLimit()\n {\n-    // TODO is there a limit on windows, how to get it?\n+    // TODO is there a limit on Windows, how to get it?\n     return std::numeric_limits<size_t>::max();\n }\n #endif"
      },
      {
        "sha": "ccfae16701bfe44b2fbc72229964e8db2c96ed0f",
        "filename": "src/support/lockedpool.h",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/support/lockedpool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/support/lockedpool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,6 +10,7 @@\n #include <map>\n #include <mutex>\n #include <memory>\n+#include <unordered_map>\n \n /**\n  * OS-dependent allocation and deallocation of locked/pinned memory pages.\n@@ -88,11 +89,19 @@ class Arena\n      */\n     bool addressInArena(void *ptr) const { return ptr >= base && ptr < end; }\n private:\n-    /** Map of chunk address to chunk information. This class makes use of the\n-     * sorted order to merge previous and next chunks during deallocation.\n-     */\n-    std::map<char*, size_t> chunks_free;\n-    std::map<char*, size_t> chunks_used;\n+    typedef std::multimap<size_t, char*> SizeToChunkSortedMap;\n+    /** Map to enable O(log(n)) best-fit allocation, as it's sorted by size */\n+    SizeToChunkSortedMap size_to_free_chunk;\n+\n+    typedef std::unordered_map<char*, SizeToChunkSortedMap::const_iterator> ChunkToSizeMap;\n+    /** Map from begin of free chunk to its node in size_to_free_chunk */\n+    ChunkToSizeMap chunks_free;\n+    /** Map from end of free chunk to its node in size_to_free_chunk */\n+    ChunkToSizeMap chunks_free_end;\n+\n+    /** Map from begin of used chunk to its size */\n+    std::unordered_map<char*, size_t> chunks_used;\n+\n     /** Base address of arena */\n     char* base;\n     /** End address of arena */"
      },
      {
        "sha": "6b188a06b42760f12e9a3f85611fffd75f50a520",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 177,
        "deletions": 12,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -52,6 +52,17 @@ class CAddrManTest : public CAddrMan\n     {\n         CAddrMan::Delete(nId);\n     }\n+\n+    // Simulates connection failure so that we can test eviction of offline nodes\n+    void SimConnFail(CService& addr)\n+    {\n+         int64_t nLastSuccess = 1;\n+         Good_(addr, true, nLastSuccess); // Set last good connection in the deep past.\n+\n+         bool count_failure = false;\n+         int64_t nLastTry = GetAdjustedTime()-61;\n+         Attempt(addr, count_failure, nLastTry);\n+     }\n };\n \n static CNetAddr ResolveIP(const char* ip)\n@@ -226,7 +237,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n-        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n         //Test: No collision in new table yet.\n@@ -252,7 +263,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n-        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n@@ -385,7 +396,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n         int octet1 = i % 256;\n         int octet2 = i >> 8 % 256;\n-        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".1.23\";\n+        std::string strAddr = std::to_string(octet1) + \".\" + std::to_string(octet2) + \".1.23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n \n         // Ensure that for all addrs in addrman, isTerrible == false.\n@@ -436,8 +447,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -448,8 +459,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(ResolveService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n-            ResolveIP(\"250.\" + boost::to_string(j) + \".1.1\"));\n+            CAddress(ResolveService(\"250.\" + std::to_string(j) + \".1.1\"), NODE_NONE),\n+            ResolveIP(\"250.\" + std::to_string(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -480,16 +491,16 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n \n-    // Test: Ports should not effect bucket placement in the addr\n+    // Test: Ports should not affect bucket placement in the addr\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), info2.GetNewBucket(nKey1));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n+            CAddress(ResolveService(\"250.1.1.\" + std::to_string(i)), NODE_NONE),\n+            ResolveIP(\"250.1.1.\" + std::to_string(i)));\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -501,7 +512,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int j = 0; j < 4 * 255; j++) {\n         CAddrInfo infoj = CAddrInfo(CAddress(\n                                         ResolveService(\n-                                            boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\"), NODE_NONE),\n+                                            std::to_string(250 + (j / 255)) + \".\" + std::to_string(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n@@ -514,12 +525,166 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int p = 0; p < 255; p++) {\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n-            ResolveIP(\"250.\" + boost::to_string(p) + \".1.1\"));\n+            ResolveIP(\"250.\" + std::to_string(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different source groups should map to more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() > 64);\n }\n+\n+\n+BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    // Empty addrman should return blank addrman info.\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        // No collisions yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Ensure Good handles duplicates well.\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Good(addr);\n+\n+        BOOST_CHECK(addrman.size() == 22);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_noevict)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        // No collision yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Collision between 23 and 19.\n+    CService addr23 = ResolveService(\"250.1.1.23\");\n+    addrman.Add(CAddress(addr23, NODE_NONE), source);\n+    addrman.Good(addr23);\n+\n+    BOOST_CHECK(addrman.size() == 23);\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.19:0\");\n+\n+    // 23 should be discarded and 19 not evicted.\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Lets create two collisions.\n+    for (unsigned int i = 24; i < 33; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Cause a collision.\n+    CService addr33 = ResolveService(\"250.1.1.33\");\n+    addrman.Add(CAddress(addr33, NODE_NONE), source);\n+    addrman.Good(addr33);\n+    BOOST_CHECK(addrman.size() == 33);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.27:0\");\n+\n+    // Cause a second collision.\n+    addrman.Add(CAddress(addr23, NODE_NONE), source);\n+    addrman.Good(addr23);\n+    BOOST_CHECK(addrman.size() == 33);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    // Empty addrman should return blank addrman info.\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++) {\n+        CService addr = ResolveService(\"250.1.1.\"+std::to_string(i));\n+        addrman.Add(CAddress(addr, NODE_NONE), source);\n+        addrman.Good(addr);\n+\n+        // No collision yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Collision between 23 and 19.\n+    CService addr = ResolveService(\"250.1.1.23\");\n+    addrman.Add(CAddress(addr, NODE_NONE), source);\n+    addrman.Good(addr);\n+\n+    BOOST_CHECK(addrman.size() == 23);\n+    CAddrInfo info = addrman.SelectTriedCollision();\n+    BOOST_CHECK(info.ToString() == \"250.1.1.19:0\");\n+\n+    // Ensure test of address fails, so that it is evicted.\n+    addrman.SimConnFail(info);\n+\n+    // Should swap 23 for 19.\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // If 23 was swapped for 19, then this should cause no collisions.\n+    addrman.Add(CAddress(addr, NODE_NONE), source);\n+    addrman.Good(addr);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // If we insert 19 is should collide with 23.\n+    CService addr19 = ResolveService(\"250.1.1.19\");\n+    addrman.Add(CAddress(addr19, NODE_NONE), source);\n+    addrman.Good(addr19);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.23:0\");\n+\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1210c7a7eec46e82b61872b4e66f4cdb2af10cf6",
        "filename": "src/test/base32_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/base32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/base32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base32_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -16,9 +16,9 @@ BOOST_AUTO_TEST_CASE(base32_testvectors)\n     for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n     {\n         std::string strEnc = EncodeBase32(vstrIn[i]);\n-        BOOST_CHECK(strEnc == vstrOut[i]);\n+        BOOST_CHECK_EQUAL(strEnc, vstrOut[i]);\n         std::string strDec = DecodeBase32(vstrOut[i]);\n-        BOOST_CHECK(strDec == vstrIn[i]);\n+        BOOST_CHECK_EQUAL(strDec, vstrIn[i]);\n     }\n }\n "
      },
      {
        "sha": "f90d4f90cb655ca2a19b5a909b892737d4da6015",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 139,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -2,17 +2,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <base58.h>\n-\n #include <test/data/base58_encode_decode.json.h>\n-#include <test/data/base58_keys_invalid.json.h>\n-#include <test/data/base58_keys_valid.json.h>\n \n-#include <key.h>\n-#include <script/script.h>\n+#include <base58.h>\n #include <test/test_bitcoin.h>\n-#include <uint256.h>\n-#include <util.h>\n #include <utilstrencodings.h>\n \n #include <univalue.h>\n@@ -73,135 +66,4 @@ BOOST_AUTO_TEST_CASE(base58_DecodeBase58)\n     BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n }\n \n-// Goal: check that parsed keys match test payload\n-BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n-{\n-    UniValue tests = read_json(std::string(json_tests::base58_keys_valid, json_tests::base58_keys_valid + sizeof(json_tests::base58_keys_valid)));\n-    CBitcoinSecret secret;\n-    CTxDestination destination;\n-    SelectParams(CBaseChainParams::MAIN);\n-\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n-        UniValue test = tests[idx];\n-        std::string strTest = test.write();\n-        if (test.size() < 3) { // Allow for extra stuff (useful for comments)\n-            BOOST_ERROR(\"Bad test: \" << strTest);\n-            continue;\n-        }\n-        std::string exp_base58string = test[0].get_str();\n-        std::vector<unsigned char> exp_payload = ParseHex(test[1].get_str());\n-        const UniValue &metadata = test[2].get_obj();\n-        bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n-        SelectParams(find_value(metadata, \"chain\").get_str());\n-        bool try_case_flip = find_value(metadata, \"tryCaseFlip\").isNull() ? false : find_value(metadata, \"tryCaseFlip\").get_bool();\n-        if (isPrivkey) {\n-            bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n-            // Must be valid private key\n-            BOOST_CHECK_MESSAGE(secret.SetString(exp_base58string), \"!SetString:\"+ strTest);\n-            BOOST_CHECK_MESSAGE(secret.IsValid(), \"!IsValid:\" + strTest);\n-            CKey privkey = secret.GetKey();\n-            BOOST_CHECK_MESSAGE(privkey.IsCompressed() == isCompressed, \"compressed mismatch:\" + strTest);\n-            BOOST_CHECK_MESSAGE(privkey.size() == exp_payload.size() && std::equal(privkey.begin(), privkey.end(), exp_payload.begin()), \"key mismatch:\" + strTest);\n-\n-            // Private key must be invalid public key\n-            destination = DecodeDestination(exp_base58string);\n-            BOOST_CHECK_MESSAGE(!IsValidDestination(destination), \"IsValid privkey as pubkey:\" + strTest);\n-        } else {\n-            // Must be valid public key\n-            destination = DecodeDestination(exp_base58string);\n-            CScript script = GetScriptForDestination(destination);\n-            BOOST_CHECK_MESSAGE(IsValidDestination(destination), \"!IsValid:\" + strTest);\n-            BOOST_CHECK_EQUAL(HexStr(script), HexStr(exp_payload));\n-\n-            // Try flipped case version\n-            for (char& c : exp_base58string) {\n-                if (c >= 'a' && c <= 'z') {\n-                    c = (c - 'a') + 'A';\n-                } else if (c >= 'A' && c <= 'Z') {\n-                    c = (c - 'A') + 'a';\n-                }\n-            }\n-            destination = DecodeDestination(exp_base58string);\n-            BOOST_CHECK_MESSAGE(IsValidDestination(destination) == try_case_flip, \"!IsValid case flipped:\" + strTest);\n-            if (IsValidDestination(destination)) {\n-                script = GetScriptForDestination(destination);\n-                BOOST_CHECK_EQUAL(HexStr(script), HexStr(exp_payload));\n-            }\n-\n-            // Public key must be invalid private key\n-            secret.SetString(exp_base58string);\n-            BOOST_CHECK_MESSAGE(!secret.IsValid(), \"IsValid pubkey as privkey:\" + strTest);\n-        }\n-    }\n-}\n-\n-// Goal: check that generated keys match test vectors\n-BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n-{\n-    UniValue tests = read_json(std::string(json_tests::base58_keys_valid, json_tests::base58_keys_valid + sizeof(json_tests::base58_keys_valid)));\n-\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n-        UniValue test = tests[idx];\n-        std::string strTest = test.write();\n-        if (test.size() < 3) // Allow for extra stuff (useful for comments)\n-        {\n-            BOOST_ERROR(\"Bad test: \" << strTest);\n-            continue;\n-        }\n-        std::string exp_base58string = test[0].get_str();\n-        std::vector<unsigned char> exp_payload = ParseHex(test[1].get_str());\n-        const UniValue &metadata = test[2].get_obj();\n-        bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n-        SelectParams(find_value(metadata, \"chain\").get_str());\n-        if (isPrivkey) {\n-            bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n-            CKey key;\n-            key.Set(exp_payload.begin(), exp_payload.end(), isCompressed);\n-            assert(key.IsValid());\n-            CBitcoinSecret secret;\n-            secret.SetKey(key);\n-            BOOST_CHECK_MESSAGE(secret.ToString() == exp_base58string, \"result mismatch: \" + strTest);\n-        } else {\n-            CTxDestination dest;\n-            CScript exp_script(exp_payload.begin(), exp_payload.end());\n-            ExtractDestination(exp_script, dest);\n-            std::string address = EncodeDestination(dest);\n-\n-            BOOST_CHECK_EQUAL(address, exp_base58string);\n-        }\n-    }\n-\n-    SelectParams(CBaseChainParams::MAIN);\n-}\n-\n-\n-// Goal: check that base58 parsing code is robust against a variety of corrupted data\n-BOOST_AUTO_TEST_CASE(base58_keys_invalid)\n-{\n-    UniValue tests = read_json(std::string(json_tests::base58_keys_invalid, json_tests::base58_keys_invalid + sizeof(json_tests::base58_keys_invalid))); // Negative testcases\n-    CBitcoinSecret secret;\n-    CTxDestination destination;\n-\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n-        UniValue test = tests[idx];\n-        std::string strTest = test.write();\n-        if (test.size() < 1) // Allow for extra stuff (useful for comments)\n-        {\n-            BOOST_ERROR(\"Bad test: \" << strTest);\n-            continue;\n-        }\n-        std::string exp_base58string = test[0].get_str();\n-\n-        // must be invalid as public and as private key\n-        for (auto chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {\n-            SelectParams(chain);\n-            destination = DecodeDestination(exp_base58string);\n-            BOOST_CHECK_MESSAGE(!IsValidDestination(destination), \"IsValid pubkey in mainnet:\" + strTest);\n-            secret.SetString(exp_base58string);\n-            BOOST_CHECK_MESSAGE(!secret.IsValid(), \"IsValid privkey in mainnet:\" + strTest);\n-        }\n-    }\n-}\n-\n-\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "f785cede81db81b7c92595237f9a1c16447784be",
        "filename": "src/test/base64_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/base64_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/base64_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base64_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -16,9 +16,9 @@ BOOST_AUTO_TEST_CASE(base64_testvectors)\n     for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n     {\n         std::string strEnc = EncodeBase64(vstrIn[i]);\n-        BOOST_CHECK(strEnc == vstrOut[i]);\n+        BOOST_CHECK_EQUAL(strEnc, vstrOut[i]);\n         std::string strDec = DecodeBase64(strEnc);\n-        BOOST_CHECK(strDec == vstrIn[i]);\n+        BOOST_CHECK_EQUAL(strDec, vstrIn[i]);\n     }\n }\n "
      },
      {
        "sha": "3c9ff1877dd8fda9964e6df06ab6e33132f11c6f",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 13,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,8 +4,8 @@\n \n #include <boost/test/unit_test.hpp>\n \n-#include <base58.h>\n #include <key.h>\n+#include <key_io.h>\n #include <uint256.h>\n #include <util.h>\n #include <utilstrencodings.h>\n@@ -99,20 +99,12 @@ void RunTest(const TestVector &test) {\n         pubkey.Encode(data);\n \n         // Test private key\n-        CBitcoinExtKey b58key; b58key.SetKey(key);\n-        BOOST_CHECK(b58key.ToString() == derive.prv);\n-\n-        CBitcoinExtKey b58keyDecodeCheck(derive.prv);\n-        CExtKey checkKey = b58keyDecodeCheck.GetKey();\n-        assert(checkKey == key); //ensure a base58 decoded key also matches\n+        BOOST_CHECK(EncodeExtKey(key) == derive.prv);\n+        BOOST_CHECK(DecodeExtKey(derive.prv) == key); //ensure a base58 decoded key also matches\n \n         // Test public key\n-        CBitcoinExtPubKey b58pubkey; b58pubkey.SetKey(pubkey);\n-        BOOST_CHECK(b58pubkey.ToString() == derive.pub);\n-\n-        CBitcoinExtPubKey b58PubkeyDecodeCheck(derive.pub);\n-        CExtPubKey checkPubKey = b58PubkeyDecodeCheck.GetKey();\n-        assert(checkPubKey == pubkey); //ensure a base58 decoded pubkey also matches\n+        BOOST_CHECK(EncodeExtPubKey(pubkey) == derive.pub);\n+        BOOST_CHECK(DecodeExtPubKey(derive.pub) == pubkey); //ensure a base58 decoded pubkey also matches\n \n         // Derive new keys\n         CExtKey keyNew;"
      },
      {
        "sha": "73c8eb5168abb941fdde90b93c1a0502b6237a43",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,9 +4,9 @@\n \n #include <bloom.h>\n \n-#include <base58.h>\n #include <clientversion.h>\n #include <key.h>\n+#include <key_io.h>\n #include <merkleblock.h>\n #include <primitives/block.h>\n #include <random.h>\n@@ -85,10 +85,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n {\n     std::string strSecret = std::string(\"5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C\");\n-    CBitcoinSecret vchSecret;\n-    BOOST_CHECK(vchSecret.SetString(strSecret));\n-\n-    CKey key = vchSecret.GetKey();\n+    CKey key = DecodeSecret(strSecret);\n     CPubKey pubkey = key.GetPubKey();\n     std::vector<unsigned char> vchPubKey(pubkey.begin(), pubkey.end());\n "
      },
      {
        "sha": "de7d8f7b90a664372e5149ce2ffb866150f73ab3",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -313,7 +313,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n                     auto utxod = FindRandomFrom(coinbase_coins);\n                     // Reuse the exact same coinbase\n                     tx = std::get<0>(utxod->second);\n-                    // shouldn't be available for reconnection if its been duplicated\n+                    // shouldn't be available for reconnection if it's been duplicated\n                     disconnected_coins.erase(utxod->first);\n \n                     duplicate_coins.insert(utxod->first);"
      },
      {
        "sha": "127cc154df5f04da54a6ac1d7fc8f49b9971f3d3",
        "filename": "src/test/compress_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -25,16 +25,16 @@\n BOOST_FIXTURE_TEST_SUITE(compress_tests, BasicTestingSetup)\n \n bool static TestEncode(uint64_t in) {\n-    return in == CTxOutCompressor::DecompressAmount(CTxOutCompressor::CompressAmount(in));\n+    return in == DecompressAmount(CompressAmount(in));\n }\n \n bool static TestDecode(uint64_t in) {\n-    return in == CTxOutCompressor::CompressAmount(CTxOutCompressor::DecompressAmount(in));\n+    return in == CompressAmount(DecompressAmount(in));\n }\n \n bool static TestPair(uint64_t dec, uint64_t enc) {\n-    return CTxOutCompressor::CompressAmount(dec) == enc &&\n-           CTxOutCompressor::DecompressAmount(enc) == dec;\n+    return CompressAmount(dec) == enc &&\n+           DecompressAmount(enc) == dec;\n }\n \n BOOST_AUTO_TEST_CASE(compress_amounts)"
      },
      {
        "sha": "ccd5caacd5c466960b671416871a453eed2564f5",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -163,7 +163,7 @@ void test_cache_erase(size_t megabytes)\n     for (uint32_t i = (n_insert / 2); i < n_insert; ++i)\n         set.insert(hashes_insert_copy[i]);\n \n-    /** elements that we marked erased but that are still there */\n+    /** elements that we marked as erased but are still there */\n     size_t count_erased_but_contained = 0;\n     /** elements that we did not erase but are older */\n     size_t count_stale = 0;\n@@ -303,7 +303,7 @@ void test_cache_generations()\n     local_rand_ctx = FastRandomContext(true);\n \n     // block_activity models a chunk of network activity. n_insert elements are\n-    // adde to the cache. The first and last n/4 are stored for removal later\n+    // added to the cache. The first and last n/4 are stored for removal later\n     // and the middle n/2 are not stored. This models a network which uses half\n     // the signatures of recently (since the last block) added transactions\n     // immediately and never uses the other half."
      },
      {
        "sha": "1a4bd7f458418d0236afb99d51c953c60afff8bb",
        "filename": "src/test/data/base58_encode_decode.json",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/base58_encode_decode.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/base58_encode_decode.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/base58_encode_decode.json?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -10,5 +10,7 @@\n [\"572e4794\", \"3EFU7m\"],\n [\"ecac89cad93923c02321\", \"EJDM8drfXA6uyA\"],\n [\"10c8511e\", \"Rt5zm\"],\n-[\"00000000000000000000\", \"1111111111\"]\n+[\"00000000000000000000\", \"1111111111\"],\n+[\"000111d38e5fc9071ffcd20b4a763cc9ae4f252bb4e48fd66a835e252ada93ff480d6dd43dc62a641155a5\", \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"],\n+[\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\", \"1cWB5HCBdLjAuqGGReWE3R3CguuwSjw6RHn39s2yuDRTS5NsBgNiFpWgAnEx6VQi8csexkgYw3mdYrMHr8x9i7aEwP8kZ7vccXWqKDvGv3u1GxFKPuAkn8JCPPGDMf3vMMnbzm6Nh9zh1gcNsMvH3ZNLmP5fSG6DGbbi2tuwMWPthr4boWwCxf7ewSgNQeacyozhKDDQQ1qL5fQFUW52QKUZDZ5fw3KXNQJMcNTcaB723LchjeKun7MuGW5qyCBZYzA1KjofN1gYBV3NqyhQJ3Ns746GNuf9N2pQPmHz4xpnSrrfCvy6TVVz5d4PdrjeshsWQwpZsZGzvbdAdN8MKV5QsBDY\"]\n ]"
      },
      {
        "sha": "2056c7491c491bdab249ea193dd35f82a3731eb6",
        "filename": "src/test/data/key_io_invalid.json",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/key_io_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/key_io_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/key_io_invalid.json?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "previous_filename": "src/test/data/base58_keys_invalid.json"
      },
      {
        "sha": "8418a6002da810ca44f7a84561777af3aa99ab5c",
        "filename": "src/test/data/key_io_valid.json",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/key_io_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/key_io_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/key_io_valid.json?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "previous_filename": "src/test/data/base58_keys_valid.json"
      },
      {
        "sha": "abb46fe533b776ce61232cd040f2d87a370810b9",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -321,7 +321,7 @@\n [\"where the pubkey is obtained through key recovery with sig and the wrong sighash.\"],\n [\"This is to show that FindAndDelete is applied only to non-segwit scripts\"],\n [\"To show that the tests are 'correctly wrong', they should pass by modifying OP_CHECKSIG under interpreter.cpp\"],\n-[\"by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE)\"],\n+[\"by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE)\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 1ba1fe3bc90c5d1265460e684ce6774e324f0fabdf67619eda729e64e8b6bc08\"],\n [[[\"f18783ace138abac5d3a7a5cf08e88fe6912f267ef936452e0c27d090621c169\", 7000, \"HASH160 0x14 0x0c746489e2d83cdbb5b90b432773342ba809c134 EQUAL\", 200000]],\n \"010000000169c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f1581b0000b64830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e012103b12a1ec8428fc74166926318c15e17408fea82dbb157575e16a8c365f546248f4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],\n@@ -332,7 +332,7 @@\n [\"Script is 2 CHECKMULTISIGVERIFY <sig1> <sig2> DROP\"],\n [\"52af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175\"],\n [\"Signature is 0 <sig1> <sig2> 2 <key1> <key2>\"],\n-[\"Should pass by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE) under OP_CHECKMULTISIG\"],\n+[\"Should pass by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE) under OP_CHECKMULTISIG\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 4bc6a53e8e16ef508c19e38bba08831daba85228b0211f323d4cb0999cf2a5e8\"],\n [[[\"9628667ad48219a169b41b020800162287d2c0f713c04157e95c484a8dcb7592\", 7000, \"HASH160 0x14 0x5748407f5ca5cdca53ba30b79040260770c9ee1b EQUAL\", 200000]],\n \"01000000019275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a662896581b0000fd6f01004830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c039596015221023fd5dd42b44769c5653cbc5947ff30ab8871f240ad0c0e7432aefe84b5b4ff3421039d52178dbde360b83f19cf348deb04fa8360e1bf5634577be8e50fafc2b0e4ef4c9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],"
      },
      {
        "sha": "0bcecc58feefd99554487d0b247fd78430dcd6d1",
        "filename": "src/test/data/tx_valid.json",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/tx_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/data/tx_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_valid.json?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -516,5 +516,9 @@\n [[[\"9628667ad48219a169b41b020800162287d2c0f713c04157e95c484a8dcb7592\", 7500, \"0x00 0x20 0x9b66c15b4e0b4eb49fa877982cafded24859fe5b0e2dbfbe4f0df1de7743fd52\", 200000]],\n \"010000000001019275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a6628964c1d000000ffffffff0101000000000000000007004830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960101022102966f109c54e85d3aee8321301136cedeb9fc710fdef58a9de8a73942f8e567c021034ffc99dd9a79dd3cb31e2ab3e0b09e0e67db41ac068c625cd1f491576016c84e9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c039596017500000000\", \"P2SH,WITNESS\"],\n \n+[\"Test long outputs, which are streamed using length-prefixed bitcoin strings. This might be surprising.\"],\n+[[[\"1111111111111111111111111111111111111111111111111111111111111111\", 0, \"0x00 0x14 0x751e76e8199196d454941c45d1b3a323f1433bd6\", 5000000]],\n+\"0100000000010111111111111111111111111111111111111111111111111111111111111111110000000000ffffffff0130244c0000000000fd02014cdc1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111175210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ac02483045022100c1a4a6581996a7fdfea77d58d537955a5655c1d619b6f3ab6874f28bb2e19708022056402db6fede03caae045a3be616a1a2d0919a475ed4be828dc9ff21f24063aa01210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179800000000\", \"P2SH,WITNESS\"],\n+\n [\"Make diffs cleaner by leaving a comment here without comma at the end\"]\n ]"
      },
      {
        "sha": "6694401a29c74b5ebc99e7bb389277c4dd56080e",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -237,7 +237,7 @@ BOOST_AUTO_TEST_CASE(iterator_ordering)\n }\n \n struct StringContentsSerializer {\n-    // Used to make two serialized objects the same while letting them have a different lengths\n+    // Used to make two serialized objects the same while letting them have different lengths\n     // This is a terrible idea\n     std::string str;\n     StringContentsSerializer() {}"
      },
      {
        "sha": "1ac1e0015bf3e569c641680966cd42c2ae6642dc",
        "filename": "src/test/key_io_tests.cpp",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/key_io_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/key_io_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_io_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,149 @@\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <test/data/key_io_invalid.json.h>\n+#include <test/data/key_io_valid.json.h>\n+\n+#include <key.h>\n+#include <key_io.h>\n+#include <script/script.h>\n+#include <utilstrencodings.h>\n+#include <test/test_bitcoin.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <univalue.h>\n+\n+extern UniValue read_json(const std::string& jsondata);\n+\n+BOOST_FIXTURE_TEST_SUITE(key_io_tests, BasicTestingSetup)\n+\n+// Goal: check that parsed keys match test payload\n+BOOST_AUTO_TEST_CASE(key_io_valid_parse)\n+{\n+    UniValue tests = read_json(std::string(json_tests::key_io_valid, json_tests::key_io_valid + sizeof(json_tests::key_io_valid)));\n+    CKey privkey;\n+    CTxDestination destination;\n+    SelectParams(CBaseChainParams::MAIN);\n+\n+    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n+        UniValue test = tests[idx];\n+        std::string strTest = test.write();\n+        if (test.size() < 3) { // Allow for extra stuff (useful for comments)\n+            BOOST_ERROR(\"Bad test: \" << strTest);\n+            continue;\n+        }\n+        std::string exp_base58string = test[0].get_str();\n+        std::vector<unsigned char> exp_payload = ParseHex(test[1].get_str());\n+        const UniValue &metadata = test[2].get_obj();\n+        bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n+        SelectParams(find_value(metadata, \"chain\").get_str());\n+        bool try_case_flip = find_value(metadata, \"tryCaseFlip\").isNull() ? false : find_value(metadata, \"tryCaseFlip\").get_bool();\n+        if (isPrivkey) {\n+            bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n+            // Must be valid private key\n+            privkey = DecodeSecret(exp_base58string);\n+            BOOST_CHECK_MESSAGE(privkey.IsValid(), \"!IsValid:\" + strTest);\n+            BOOST_CHECK_MESSAGE(privkey.IsCompressed() == isCompressed, \"compressed mismatch:\" + strTest);\n+            BOOST_CHECK_MESSAGE(privkey.size() == exp_payload.size() && std::equal(privkey.begin(), privkey.end(), exp_payload.begin()), \"key mismatch:\" + strTest);\n+\n+            // Private key must be invalid public key\n+            destination = DecodeDestination(exp_base58string);\n+            BOOST_CHECK_MESSAGE(!IsValidDestination(destination), \"IsValid privkey as pubkey:\" + strTest);\n+        } else {\n+            // Must be valid public key\n+            destination = DecodeDestination(exp_base58string);\n+            CScript script = GetScriptForDestination(destination);\n+            BOOST_CHECK_MESSAGE(IsValidDestination(destination), \"!IsValid:\" + strTest);\n+            BOOST_CHECK_EQUAL(HexStr(script), HexStr(exp_payload));\n+\n+            // Try flipped case version\n+            for (char& c : exp_base58string) {\n+                if (c >= 'a' && c <= 'z') {\n+                    c = (c - 'a') + 'A';\n+                } else if (c >= 'A' && c <= 'Z') {\n+                    c = (c - 'A') + 'a';\n+                }\n+            }\n+            destination = DecodeDestination(exp_base58string);\n+            BOOST_CHECK_MESSAGE(IsValidDestination(destination) == try_case_flip, \"!IsValid case flipped:\" + strTest);\n+            if (IsValidDestination(destination)) {\n+                script = GetScriptForDestination(destination);\n+                BOOST_CHECK_EQUAL(HexStr(script), HexStr(exp_payload));\n+            }\n+\n+            // Public key must be invalid private key\n+            privkey = DecodeSecret(exp_base58string);\n+            BOOST_CHECK_MESSAGE(!privkey.IsValid(), \"IsValid pubkey as privkey:\" + strTest);\n+        }\n+    }\n+}\n+\n+// Goal: check that generated keys match test vectors\n+BOOST_AUTO_TEST_CASE(key_io_valid_gen)\n+{\n+    UniValue tests = read_json(std::string(json_tests::key_io_valid, json_tests::key_io_valid + sizeof(json_tests::key_io_valid)));\n+\n+    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n+        UniValue test = tests[idx];\n+        std::string strTest = test.write();\n+        if (test.size() < 3) // Allow for extra stuff (useful for comments)\n+        {\n+            BOOST_ERROR(\"Bad test: \" << strTest);\n+            continue;\n+        }\n+        std::string exp_base58string = test[0].get_str();\n+        std::vector<unsigned char> exp_payload = ParseHex(test[1].get_str());\n+        const UniValue &metadata = test[2].get_obj();\n+        bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n+        SelectParams(find_value(metadata, \"chain\").get_str());\n+        if (isPrivkey) {\n+            bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n+            CKey key;\n+            key.Set(exp_payload.begin(), exp_payload.end(), isCompressed);\n+            assert(key.IsValid());\n+            BOOST_CHECK_MESSAGE(EncodeSecret(key) == exp_base58string, \"result mismatch: \" + strTest);\n+        } else {\n+            CTxDestination dest;\n+            CScript exp_script(exp_payload.begin(), exp_payload.end());\n+            ExtractDestination(exp_script, dest);\n+            std::string address = EncodeDestination(dest);\n+\n+            BOOST_CHECK_EQUAL(address, exp_base58string);\n+        }\n+    }\n+\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+\n+\n+// Goal: check that base58 parsing code is robust against a variety of corrupted data\n+BOOST_AUTO_TEST_CASE(key_io_invalid)\n+{\n+    UniValue tests = read_json(std::string(json_tests::key_io_invalid, json_tests::key_io_invalid + sizeof(json_tests::key_io_invalid))); // Negative testcases\n+    CKey privkey;\n+    CTxDestination destination;\n+\n+    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n+        UniValue test = tests[idx];\n+        std::string strTest = test.write();\n+        if (test.size() < 1) // Allow for extra stuff (useful for comments)\n+        {\n+            BOOST_ERROR(\"Bad test: \" << strTest);\n+            continue;\n+        }\n+        std::string exp_base58string = test[0].get_str();\n+\n+        // must be invalid as public and as private key\n+        for (auto chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {\n+            SelectParams(chain);\n+            destination = DecodeDestination(exp_base58string);\n+            BOOST_CHECK_MESSAGE(!IsValidDestination(destination), \"IsValid pubkey in mainnet:\" + strTest);\n+            privkey = DecodeSecret(exp_base58string);\n+            BOOST_CHECK_MESSAGE(!privkey.IsValid(), \"IsValid privkey in mainnet:\" + strTest);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "64c57f0705f00bf362a32e7a1b2702cf8a977cab",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 16,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,7 +4,7 @@\n \n #include <key.h>\n \n-#include <base58.h>\n+#include <key_io.h>\n #include <script/script.h>\n #include <uint256.h>\n #include <util.h>\n@@ -32,21 +32,16 @@ BOOST_FIXTURE_TEST_SUITE(key_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(key_test1)\n {\n-    CBitcoinSecret bsecret1, bsecret2, bsecret1C, bsecret2C, baddress1;\n-    BOOST_CHECK( bsecret1.SetString (strSecret1));\n-    BOOST_CHECK( bsecret2.SetString (strSecret2));\n-    BOOST_CHECK( bsecret1C.SetString(strSecret1C));\n-    BOOST_CHECK( bsecret2C.SetString(strSecret2C));\n-    BOOST_CHECK(!baddress1.SetString(strAddressBad));\n-\n-    CKey key1  = bsecret1.GetKey();\n-    BOOST_CHECK(key1.IsCompressed() == false);\n-    CKey key2  = bsecret2.GetKey();\n-    BOOST_CHECK(key2.IsCompressed() == false);\n-    CKey key1C = bsecret1C.GetKey();\n-    BOOST_CHECK(key1C.IsCompressed() == true);\n-    CKey key2C = bsecret2C.GetKey();\n-    BOOST_CHECK(key2C.IsCompressed() == true);\n+    CKey key1  = DecodeSecret(strSecret1);\n+    BOOST_CHECK(key1.IsValid() && !key1.IsCompressed());\n+    CKey key2  = DecodeSecret(strSecret2);\n+    BOOST_CHECK(key2.IsValid() && !key2.IsCompressed());\n+    CKey key1C = DecodeSecret(strSecret1C);\n+    BOOST_CHECK(key1C.IsValid() && key1C.IsCompressed());\n+    CKey key2C = DecodeSecret(strSecret2C);\n+    BOOST_CHECK(key2C.IsValid() && key2C.IsCompressed());\n+    CKey bad_key = DecodeSecret(strAddressBad);\n+    BOOST_CHECK(!bad_key.IsValid());\n \n     CPubKey pubkey1  = key1. GetPubKey();\n     CPubKey pubkey2  = key2. GetPubKey();"
      },
      {
        "sha": "19cd3b0963a3d0ff0ec93f78da02eca2d68e6929",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -523,7 +523,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     pool.addUnchecked(tx6.GetHash(), entry.Fee(1100LL).FromTx(tx6));\n     pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7));\n \n-    // we only require this remove, at max, 2 txn, because its not clear what we're really optimizing for aside from that\n+    // we only require this to remove, at max, 2 txn, because it's not clear what we're really optimizing for aside from that\n     pool.TrimToSize(pool.DynamicMemoryUsage() - 1);\n     BOOST_CHECK(pool.exists(tx4.GetHash()));\n     BOOST_CHECK(pool.exists(tx6.GetHash()));"
      },
      {
        "sha": "b593f9633ce945cac1087265fc98384010405fd8",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -21,7 +21,7 @@ BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround"
      },
      {
        "sha": "6552613c042c31f60479fa2a112c03768e880180",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -64,7 +64,7 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n {\n     CDataStream ssPeersIn(SER_DISK, CLIENT_VERSION);\n-    ssPeersIn << FLATDATA(Params().MessageStart());\n+    ssPeersIn << Params().MessageStart();\n     ssPeersIn << _addrman;\n     std::string str = ssPeersIn.str();\n     std::vector<unsigned char> vchData(str.begin(), str.end());\n@@ -110,7 +110,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n-        ssPeers1 >> FLATDATA(pchMsgTmp);\n+        ssPeers1 >> pchMsgTmp;\n         ssPeers1 >> addrman1;\n     } catch (const std::exception& e) {\n         exceptionThrown = true;\n@@ -142,7 +142,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n-        ssPeers1 >> FLATDATA(pchMsgTmp);\n+        ssPeers1 >> pchMsgTmp;\n         ssPeers1 >> addrman1;\n     } catch (const std::exception& e) {\n         exceptionThrown = true;\n@@ -171,7 +171,7 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     ipv4Addr.s_addr = 0xa0b0c001;\n     \n     CAddress addr = CAddress(CService(ipv4Addr, 7777), NODE_NETWORK);\n-    std::string pszDest = \"\";\n+    std::string pszDest;\n     bool fInboundIn = false;\n \n     // Test that fFeeler is false by default."
      },
      {
        "sha": "01c3a6cedd1bc11a4c507187ae21c137df29dc3f",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -206,7 +206,7 @@ BOOST_AUTO_TEST_CASE(PrevectorTestInt)\n                 test.erase(InsecureRandRange(test.size()));\n             }\n             if (InsecureRandBits(3) == 2) {\n-                int new_size = std::max<int>(0, std::min<int>(30, test.size() + (InsecureRandRange(5)) - 2));\n+                int new_size = std::max(0, std::min(30, (int)test.size() + (int)InsecureRandRange(5) - 2));\n                 test.resize(new_size);\n             }\n             if (InsecureRandBits(3) == 3) {"
      },
      {
        "sha": "623ed239f04942b0afb66415ccddcb844c6e9199",
        "filename": "src/test/random_tests.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/random_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/random_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/random_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -8,6 +8,9 @@\n \n #include <boost/test/unit_test.hpp>\n \n+#include <random>\n+#include <algorithm>\n+\n BOOST_FIXTURE_TEST_SUITE(random_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(osrandom_tests)\n@@ -57,4 +60,23 @@ BOOST_AUTO_TEST_CASE(fastrandom_randbits)\n     }\n }\n \n+/** Does-it-compile test for compatibility with standard C++11 RNG interface. */\n+BOOST_AUTO_TEST_CASE(stdrandom_test)\n+{\n+    FastRandomContext ctx;\n+    std::uniform_int_distribution<int> distribution(3, 9);\n+    for (int i = 0; i < 100; ++i) {\n+        int x = distribution(ctx);\n+        BOOST_CHECK(x >= 3);\n+        BOOST_CHECK(x <= 9);\n+\n+        std::vector<int> test{1,2,3,4,5,6,7,8,9,10};\n+        std::shuffle(test.begin(), test.end(), ctx);\n+        for (int j = 1; j <= 10; ++j) {\n+            BOOST_CHECK(std::find(test.begin(), test.end(), j) != test.end());\n+        }\n+    }\n+\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "8d9f80ada09280c8ca70f9779006e27032b7471c",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -5,8 +5,8 @@\n #include <rpc/server.h>\n #include <rpc/client.h>\n \n-#include <base58.h>\n #include <core_io.h>\n+#include <key_io.h>\n #include <netbase.h>\n \n #include <test/test_bitcoin.h>\n@@ -52,7 +52,6 @@ BOOST_AUTO_TEST_CASE(rpc_rawparams)\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction\"), std::runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction null null\"), std::runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction not_array\"), std::runtime_error);\n-    BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] []\"), std::runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction {} {}\"), std::runtime_error);\n     BOOST_CHECK_NO_THROW(CallRPC(\"createrawtransaction [] {}\"));\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction [] {} extra\"), std::runtime_error);"
      },
      {
        "sha": "179df7dd3871faa2a6cdd23a13a49e9b5d893b0e",
        "filename": "src/test/scheduler_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/scheduler_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/scheduler_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scheduler_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -56,8 +56,8 @@ BOOST_AUTO_TEST_CASE(manythreads)\n     int counter[10] = { 0 };\n     FastRandomContext rng(42);\n     auto zeroToNine = [](FastRandomContext& rc) -> int { return rc.randrange(10); }; // [0, 9]\n-    auto randomMsec = [](FastRandomContext& rc) -> int { return -11 + rc.randrange(1012); }; // [-11, 1000]\n-    auto randomDelta = [](FastRandomContext& rc) -> int { return -1000 + rc.randrange(2001); }; // [-1000, 1000]\n+    auto randomMsec = [](FastRandomContext& rc) -> int { return -11 + (int)rc.randrange(1012); }; // [-11, 1000]\n+    auto randomDelta = [](FastRandomContext& rc) -> int { return -1000 + (int)rc.randrange(2001); }; // [-1000, 1000]\n \n     boost::chrono::system_clock::time_point start = boost::chrono::system_clock::now();\n     boost::chrono::system_clock::time_point now = start;"
      },
      {
        "sha": "46a2d13745019556e48e6d7729aec4f4730c4979",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 67,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -267,10 +267,10 @@ struct KeyData\n     }\n };\n \n-enum WitnessMode {\n-    WITNESS_NONE,\n-    WITNESS_PKH,\n-    WITNESS_SH\n+enum class WitnessMode {\n+    NONE,\n+    PKH,\n+    SH\n };\n \n class TestBuilder\n@@ -308,15 +308,15 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WitnessMode::NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n-        if (wm == WITNESS_PKH) {\n+        if (wm == WitnessMode::PKH) {\n             uint160 hash;\n             CHash160().Write(&script[1], script.size() - 1).Finalize(hash.begin());\n             script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n             scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n-        } else if (wm == WITNESS_SH) {\n+        } else if (wm == WitnessMode::SH) {\n             witscript = scriptPubKey;\n             uint256 hash;\n             CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n@@ -361,7 +361,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE, CAmount amount = 0)\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::BASE, CAmount amount = 0)\n     {\n         uint256 hash = SignatureHash(script, spendTx, 0, nHashType, amount, sigversion);\n         std::vector<unsigned char> vchSig, r, s;\n@@ -379,7 +379,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n+    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::WITNESS_V0)\n     {\n         if (amount == -1)\n             amount = nValue;\n@@ -747,57 +747,57 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).PushSig(keys.key0).PushRedeem());\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n                                 \"P2WPKH with future witness version\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH |\n-                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WITNESS_PKH, 1\n+                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WitnessMode::PKH, 1\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0);\n@@ -810,118 +810,118 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                    ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG;\n         tests.push_back(TestBuilder(witscript,\n-                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                    ).PushWitSig(keys.key0).Push(witscript).DamagePush(0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Num(11).ScriptError(SCRIPT_ERR_WITNESS_MALLEATED));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().Num(11).PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_MALLEATED_P2SH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n                                 \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n                                ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n \n     // Compressed keys should pass SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit().PushRedeem());\n \n     // Testing uncompressed key in witness with SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     // P2WSH 1-of-2 multisig with compressed keys\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n \n     // P2WSH 1-of-2 multisig with first key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     // P2WSH 1-of-2 multisig with second key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     std::set<std::string> tests_set;\n@@ -1009,29 +1009,29 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n \n     ScriptError err;\n     std::vector<std::vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     //\n@@ -1227,15 +1227,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n \n     // A couple of partially-signed versions:\n     std::vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n     std::vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n     std::vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n "
      },
      {
        "sha": "9b8b7bdc56a6c80c91cdf240614e6004ba0414d2",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 19,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -19,19 +19,23 @@ class CSerializeMethodsTestSingle\n     int intval;\n     bool boolval;\n     std::string stringval;\n-    const char* charstrval;\n+    char charstrval[16];\n     CTransactionRef txval;\n public:\n     CSerializeMethodsTestSingle() = default;\n-    CSerializeMethodsTestSingle(int intvalin, bool boolvalin, std::string stringvalin, const char* charstrvalin, CTransaction txvalin) : intval(intvalin), boolval(boolvalin), stringval(std::move(stringvalin)), charstrval(charstrvalin), txval(MakeTransactionRef(txvalin)){}\n+    CSerializeMethodsTestSingle(int intvalin, bool boolvalin, std::string stringvalin, const char* charstrvalin, CTransaction txvalin) : intval(intvalin), boolval(boolvalin), stringval(std::move(stringvalin)), txval(MakeTransactionRef(txvalin))\n+    {\n+        memcpy(charstrval, charstrvalin, sizeof(charstrval));\n+    }\n+\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(intval);\n         READWRITE(boolval);\n         READWRITE(stringval);\n-        READWRITE(FLATDATA(charstrval));\n+        READWRITE(charstrval);\n         READWRITE(txval);\n     }\n \n@@ -53,7 +57,7 @@ class CSerializeMethodsTestMany : public CSerializeMethodsTestSingle\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITEMANY(intval, boolval, stringval, FLATDATA(charstrval), txval);\n+        READWRITE(intval, boolval, stringval, charstrval, txval);\n     }\n };\n \n@@ -177,8 +181,8 @@ BOOST_AUTO_TEST_CASE(varints)\n     CDataStream ss(SER_DISK, 0);\n     CDataStream::size_type size = 0;\n     for (int i = 0; i < 100000; i++) {\n-        ss << VARINT(i);\n-        size += ::GetSerializeSize(VARINT(i), 0, 0);\n+        ss << VARINT(i, VarIntMode::NONNEGATIVE_SIGNED);\n+        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0, 0);\n         BOOST_CHECK(size == ss.size());\n     }\n \n@@ -191,7 +195,7 @@ BOOST_AUTO_TEST_CASE(varints)\n     // decode\n     for (int i = 0; i < 100000; i++) {\n         int j = -1;\n-        ss >> VARINT(j);\n+        ss >> VARINT(j, VarIntMode::NONNEGATIVE_SIGNED);\n         BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n     }\n \n@@ -205,21 +209,21 @@ BOOST_AUTO_TEST_CASE(varints)\n BOOST_AUTO_TEST_CASE(varints_bitpatterns)\n {\n     CDataStream ss(SER_DISK, 0);\n-    ss << VARINT(0); BOOST_CHECK_EQUAL(HexStr(ss), \"00\"); ss.clear();\n-    ss << VARINT(0x7f); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n-    ss << VARINT((int8_t)0x7f); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n-    ss << VARINT(0x80); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n+    ss << VARINT(0, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"00\"); ss.clear();\n+    ss << VARINT(0x7f, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n+    ss << VARINT((int8_t)0x7f, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"7f\"); ss.clear();\n+    ss << VARINT(0x80, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n     ss << VARINT((uint8_t)0x80); BOOST_CHECK_EQUAL(HexStr(ss), \"8000\"); ss.clear();\n-    ss << VARINT(0x1234); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n-    ss << VARINT((int16_t)0x1234); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n-    ss << VARINT(0xffff); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n+    ss << VARINT(0x1234, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n+    ss << VARINT((int16_t)0x1234, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"a334\"); ss.clear();\n+    ss << VARINT(0xffff, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n     ss << VARINT((uint16_t)0xffff); BOOST_CHECK_EQUAL(HexStr(ss), \"82fe7f\"); ss.clear();\n-    ss << VARINT(0x123456); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n-    ss << VARINT((int32_t)0x123456); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n+    ss << VARINT(0x123456, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n+    ss << VARINT((int32_t)0x123456, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"c7e756\"); ss.clear();\n     ss << VARINT(0x80123456U); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n     ss << VARINT((uint32_t)0x80123456U); BOOST_CHECK_EQUAL(HexStr(ss), \"86ffc7e756\"); ss.clear();\n     ss << VARINT(0xffffffff); BOOST_CHECK_EQUAL(HexStr(ss), \"8efefefe7f\"); ss.clear();\n-    ss << VARINT(0x7fffffffffffffffLL); BOOST_CHECK_EQUAL(HexStr(ss), \"fefefefefefefefe7f\"); ss.clear();\n+    ss << VARINT(0x7fffffffffffffffLL, VarIntMode::NONNEGATIVE_SIGNED); BOOST_CHECK_EQUAL(HexStr(ss), \"fefefefefefefefe7f\"); ss.clear();\n     ss << VARINT(0xffffffffffffffffULL); BOOST_CHECK_EQUAL(HexStr(ss), \"80fefefefefefefefe7f\"); ss.clear();\n }\n \n@@ -344,7 +348,7 @@ BOOST_AUTO_TEST_CASE(class_methods)\n     int intval(100);\n     bool boolval(true);\n     std::string stringval(\"testing\");\n-    const char* charstrval(\"testing charstr\");\n+    const char charstrval[16] = \"testing charstr\";\n     CMutableTransaction txval;\n     CSerializeMethodsTestSingle methodtest1(intval, boolval, stringval, charstrval, txval);\n     CSerializeMethodsTestMany methodtest2(intval, boolval, stringval, charstrval, txval);\n@@ -360,7 +364,7 @@ BOOST_AUTO_TEST_CASE(class_methods)\n     BOOST_CHECK(methodtest2 == methodtest3);\n     BOOST_CHECK(methodtest3 == methodtest4);\n \n-    CDataStream ss2(SER_DISK, PROTOCOL_VERSION, intval, boolval, stringval, FLATDATA(charstrval), txval);\n+    CDataStream ss2(SER_DISK, PROTOCOL_VERSION, intval, boolval, stringval, charstrval, txval);\n     ss2 >> methodtest3;\n     BOOST_CHECK(methodtest3 == methodtest4);\n }"
      },
      {
        "sha": "a2bd8998b1a192051b19db7b5abfc05dacf31590",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n \n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n-        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SigVersion::BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n         ss << txTo;\n@@ -204,7 +204,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           continue;\n         }\n \n-        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SigVersion::BASE);\n         BOOST_CHECK_MESSAGE(sh.GetHex() == sigHashHex, strTest);\n     }\n }"
      },
      {
        "sha": "5d057108b13b327ee5c9cbb8b3136d1816efad12",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -57,16 +57,16 @@ BOOST_AUTO_TEST_CASE(streams_vector_writer)\n     BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 0, 0, 1, 2}}));\n     vch.clear();\n \n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, FLATDATA(bytes));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, bytes);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{3, 4, 5, 6}}));\n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, FLATDATA(bytes));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, bytes);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{3, 4, 5, 6}}));\n     vch.clear();\n \n     vch.resize(4, 8);\n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, FLATDATA(bytes), b);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, bytes, b);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{8, 8, 1, 3, 4, 5, 6, 2}}));\n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, FLATDATA(bytes), b);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, bytes, b);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{8, 8, 1, 3, 4, 5, 6, 2}}));\n     vch.clear();\n }"
      },
      {
        "sha": "9390a93b99f8c3b72da66dd081c5ff81539f1c46",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -145,9 +145,9 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     for (const CMutableTransaction& tx : txns)\n         block.vtx.push_back(MakeTransactionRef(tx));\n     // IncrementExtraNonce creates a valid coinbase and merkleRoot\n-    unsigned int extraNonce = 0;\n     {\n         LOCK(cs_main);\n+        unsigned int extraNonce = 0;\n         IncrementExtraNonce(&block, chainActive.Tip(), extraNonce);\n     }\n "
      },
      {
        "sha": "b222392ee5176557f2302d2d252cc3b49dde77ea",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -407,7 +407,7 @@ static CScript PushAll(const std::vector<valtype>& values)\n void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n {\n     std::vector<valtype> stack;\n-    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     assert(stack.size() > 0);\n     stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n     script = PushAll(stack);"
      },
      {
        "sha": "7087c267747cc1d529635f4c33fe47efedb6a429",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -35,7 +35,7 @@ ToMemPool(CMutableTransaction& tx)\n \n BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n {\n-    // Make sure skipping validation of transctions that were\n+    // Make sure skipping validation of transactions that were\n     // validated going into the memory pool does not allow\n     // double-spends in blocks to pass validation when they should not.\n \n@@ -56,7 +56,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n         // Sign:\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         spends[i].vin[0].scriptSig << vchSig;\n@@ -182,7 +182,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     // Sign, with a non-DER signature\n     {\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n@@ -256,7 +256,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n@@ -284,7 +284,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;"
      },
      {
        "sha": "4b44bbadacd6b8649919811be15886697d74c73f",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 154,
        "deletions": 14,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -81,6 +81,20 @@ BOOST_AUTO_TEST_CASE(util_HexStr)\n         HexStr(ParseHex_expected, ParseHex_expected + 5, true),\n         \"04 67 8a fd b0\");\n \n+    BOOST_CHECK_EQUAL(\n+        HexStr(ParseHex_expected + sizeof(ParseHex_expected),\n+               ParseHex_expected + sizeof(ParseHex_expected)),\n+        \"\");\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(ParseHex_expected + sizeof(ParseHex_expected),\n+               ParseHex_expected + sizeof(ParseHex_expected), true),\n+        \"\");\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(ParseHex_expected, ParseHex_expected),\n+        \"\");\n+\n     BOOST_CHECK_EQUAL(\n         HexStr(ParseHex_expected, ParseHex_expected, true),\n         \"\");\n@@ -90,6 +104,58 @@ BOOST_AUTO_TEST_CASE(util_HexStr)\n     BOOST_CHECK_EQUAL(\n         HexStr(ParseHex_vec, true),\n         \"04 67 8a fd b0\");\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(ParseHex_vec.rbegin(), ParseHex_vec.rend()),\n+        \"b0fd8a6704\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(ParseHex_vec.rbegin(), ParseHex_vec.rend(), true),\n+        \"b0 fd 8a 67 04\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected)),\n+        \"\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected), true),\n+        \"\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected + 1),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected)),\n+        \"04\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected + 1),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected), true),\n+        \"04\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected + 5),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected)),\n+        \"b0fd8a6704\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected + 5),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected), true),\n+        \"b0 fd 8a 67 04\"\n+    );\n+\n+    BOOST_CHECK_EQUAL(\n+        HexStr(std::reverse_iterator<const uint8_t *>(ParseHex_expected + 65),\n+               std::reverse_iterator<const uint8_t *>(ParseHex_expected)),\n+        \"5f1df16b2b704c8a578d0bbaf74d385cde12c11ee50455f3c438ef4c3fbcf649b6de611feae06279a60939e028a8d65c10b73071a6f16719274855feb0fd8a6704\"\n+    );\n }\n \n \n@@ -98,21 +164,32 @@ BOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0), \"1970-01-01 00:00:00\");\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0x7FFFFFFF), \"2038-01-19 03:14:07\");\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 1317425777), \"2011-09-30 23:36:17\");\n+    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", 1317425777), \"2011-09-30T23:36:17Z\");\n+    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%H:%M:%SZ\", 1317425777), \"23:36:17Z\");\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M\", 1317425777), \"2011-09-30 23:36\");\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", 1317425777), \"Fri, 30 Sep 2011 23:36:17 +0000\");\n }\n \n-class TestArgsManager : public ArgsManager\n+BOOST_AUTO_TEST_CASE(util_FormatISO8601DateTime)\n {\n-public:\n-    std::map<std::string, std::string>& GetMapArgs()\n-    {\n-        return mapArgs;\n-    };\n-    const std::map<std::string, std::vector<std::string> >& GetMapMultiArgs()\n-    {\n-        return mapMultiArgs;\n-    };\n+    BOOST_CHECK_EQUAL(FormatISO8601DateTime(1317425777), \"2011-09-30T23:36:17Z\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_FormatISO8601Date)\n+{\n+    BOOST_CHECK_EQUAL(FormatISO8601Date(1317425777), \"2011-09-30\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_FormatISO8601Time)\n+{\n+    BOOST_CHECK_EQUAL(FormatISO8601Time(1317425777), \"23:36:17Z\");\n+}\n+\n+struct TestArgsManager : public ArgsManager\n+{\n+    std::map<std::string, std::string>& GetMapArgs() { return mapArgs; }\n+    const std::map<std::string, std::vector<std::string> >& GetMapMultiArgs() { return mapMultiArgs; }\n+    const std::unordered_set<std::string>& GetNegatedArgs() { return m_negated_args; }\n };\n \n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n@@ -140,6 +217,54 @@ BOOST_AUTO_TEST_CASE(util_ParseParameters)\n     BOOST_CHECK(testArgs.GetArgs(\"-ccc\").size() == 2);\n }\n \n+BOOST_AUTO_TEST_CASE(util_GetBoolArg)\n+{\n+    TestArgsManager testArgs;\n+    const char *argv_test[] = {\n+        \"ignored\", \"-a\", \"-nob\", \"-c=0\", \"-d=1\", \"-e=false\", \"-f=true\"};\n+    testArgs.ParseParameters(7, (char**)argv_test);\n+\n+    // Each letter should be set.\n+    for (char opt : \"abcdef\")\n+        BOOST_CHECK(testArgs.IsArgSet({'-', opt}) || !opt);\n+\n+    // Nothing else should be in the map\n+    BOOST_CHECK(testArgs.GetMapArgs().size() == 6 &&\n+                testArgs.GetMapMultiArgs().size() == 6);\n+\n+    // The -no prefix should get stripped on the way in.\n+    BOOST_CHECK(!testArgs.IsArgSet(\"-nob\"));\n+\n+    // The -b option is flagged as negated, and nothing else is\n+    BOOST_CHECK(testArgs.IsArgNegated(\"-b\"));\n+    BOOST_CHECK(testArgs.GetNegatedArgs().size() == 1);\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-a\"));\n+\n+    // Check expected values.\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-a\", false) == true);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-b\", true) == false);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-c\", true) == false);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-d\", false) == true);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-e\", true) == false);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-f\", true) == false);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_GetBoolArgEdgeCases)\n+{\n+    // Test some awful edge cases that hopefully no user will ever exercise.\n+    TestArgsManager testArgs;\n+    const char *argv_test[] = {\"ignored\", \"-nofoo\", \"-foo\", \"-nobar=0\"};\n+    testArgs.ParseParameters(4, (char**)argv_test);\n+\n+    // This was passed twice, second one overrides the negative setting.\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-foo\"));\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-foo\", false) == true);\n+\n+    // A double negative is a positive.\n+    BOOST_CHECK(testArgs.IsArgNegated(\"-bar\"));\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-bar\", false) == true);\n+}\n+\n BOOST_AUTO_TEST_CASE(util_GetArg)\n {\n     TestArgsManager testArgs;\n@@ -621,9 +746,8 @@ static constexpr char ExitCommand = 'X';\n static void TestOtherProcess(fs::path dirname, std::string lockname, int fd)\n {\n     char ch;\n-    int rv;\n     while (true) {\n-        rv = read(fd, &ch, 1); // Wait for command\n+        int rv = read(fd, &ch, 1); // Wait for command\n         assert(rv == 1);\n         switch(ch) {\n         case LockCommand:\n@@ -688,7 +812,7 @@ BOOST_AUTO_TEST_CASE(test_LockDirectory)\n     thr.join();\n     BOOST_CHECK_EQUAL(threadresult, true);\n #ifndef WIN32\n-    // Try to aquire lock in child process while we're holding it, this should fail.\n+    // Try to acquire lock in child process while we're holding it, this should fail.\n     char ch;\n     BOOST_CHECK_EQUAL(write(fd[1], &LockCommand, 1), 1);\n     BOOST_CHECK_EQUAL(read(fd[1], &ch, 1), 1);\n@@ -699,7 +823,7 @@ BOOST_AUTO_TEST_CASE(test_LockDirectory)\n     // Probing lock from our side now should succeed, but not hold on to the lock.\n     BOOST_CHECK_EQUAL(LockDirectory(dirname, lockname, true), true);\n \n-    // Try to acquire the lock in the child process, this should be succesful.\n+    // Try to acquire the lock in the child process, this should be successful.\n     BOOST_CHECK_EQUAL(write(fd[1], &LockCommand, 1), 1);\n     BOOST_CHECK_EQUAL(read(fd[1], &ch, 1), 1);\n     BOOST_CHECK_EQUAL((bool)ch, true);\n@@ -734,4 +858,20 @@ BOOST_AUTO_TEST_CASE(test_LockDirectory)\n     fs::remove_all(dirname);\n }\n \n+BOOST_AUTO_TEST_CASE(test_DirIsWritable)\n+{\n+    // Should be able to write to the system tmp dir.\n+    fs::path tmpdirname = fs::temp_directory_path();\n+    BOOST_CHECK_EQUAL(DirIsWritable(tmpdirname), true);\n+\n+    // Should not be able to write to a non-existent dir.\n+    tmpdirname = fs::temp_directory_path() / fs::unique_path();\n+    BOOST_CHECK_EQUAL(DirIsWritable(tmpdirname), false);\n+\n+    fs::create_directory(tmpdirname);\n+    // Should be able to write to it now.\n+    BOOST_CHECK_EQUAL(DirIsWritable(tmpdirname), true);\n+    fs::remove(tmpdirname);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "92ef58e517ded6090474524fa649d048ace5b2ea",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -101,8 +101,8 @@ class VersionBitsTester\n     VersionBitsTester& TestDefined() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::DEFINED, strprintf(\"Test %i for DEFINED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -112,8 +112,8 @@ class VersionBitsTester\n     VersionBitsTester& TestStarted() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::STARTED, strprintf(\"Test %i for STARTED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -123,8 +123,8 @@ class VersionBitsTester\n     VersionBitsTester& TestLockedIn() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -134,8 +134,8 @@ class VersionBitsTester\n     VersionBitsTester& TestActive() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -145,8 +145,8 @@ class VersionBitsTester\n     VersionBitsTester& TestFailed() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::FAILED, strprintf(\"Test %i for FAILED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;"
      },
      {
        "sha": "14b7cd30262fd0a63376329be7a5e7546e7aa19e",
        "filename": "src/tinyformat.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -155,7 +155,7 @@ namespace tfm = tinyformat;\n #endif\n \n #ifdef __APPLE__\n-// Workaround OSX linker warning: xcode uses different default symbol\n+// Workaround OSX linker warning: Xcode uses different default symbol\n // visibilities for static libs vs executables (see issue #25)\n #   define TINYFORMAT_HIDDEN __attribute__((visibility(\"hidden\")))\n #else\n@@ -592,7 +592,7 @@ inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)\n // Formatting options which can't be natively represented using the ostream\n // state are returned in spacePadPositive (for space padded positive numbers)\n // and ntrunc (for truncating conversions).  argIndex is incremented if\n-// necessary to pull out variable width and precision .  The function returns a\n+// necessary to pull out variable width and precision.  The function returns a\n // pointer to the character after the end of the current format spec.\n inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,\n                                          int& ntrunc, const char* fmtStart,"
      },
      {
        "sha": "8550a7e8893e313c534bc730cb6f1a320036fde2",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -147,7 +147,7 @@ size_t CCoinsViewDB::EstimateSize() const\n     return db.EstimateSize(DB_COIN, (char)(DB_COIN+1));\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(gArgs.IsArgSet(\"-blocksdir\") ? GetDataDir() / \"blocks\" / \"index\" : GetBlocksDir() / \"index\", nCacheSize, fMemory, fWipe) {\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n@@ -324,7 +324,7 @@ class CCoins\n     void Unserialize(Stream &s) {\n         unsigned int nCode = 0;\n         // version\n-        int nVersionDummy;\n+        unsigned int nVersionDummy;\n         ::Unserialize(s, VARINT(nVersionDummy));\n         // header code\n         ::Unserialize(s, VARINT(nCode));\n@@ -348,10 +348,10 @@ class CCoins\n         vout.assign(vAvail.size(), CTxOut());\n         for (unsigned int i = 0; i < vAvail.size(); i++) {\n             if (vAvail[i])\n-                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n+                ::Unserialize(s, CTxOutCompressor(vout[i]));\n         }\n         // coinbase height\n-        ::Unserialize(s, VARINT(nHeight));\n+        ::Unserialize(s, VARINT(nHeight, VarIntMode::NONNEGATIVE_SIGNED));\n     }\n };\n "
      },
      {
        "sha": "cc639288d37e5d1a082199cf85eb6c1e78ae96df",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -339,7 +339,7 @@ CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n     nCheckFrequency = 0;\n }\n \n-bool CTxMemPool::isSpent(const COutPoint& outpoint)\n+bool CTxMemPool::isSpent(const COutPoint& outpoint) const\n {\n     LOCK(cs);\n     return mapNextTx.count(outpoint);"
      },
      {
        "sha": "699f6b554bd9344f7f1df32e7ba853d3bdbadc59",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -550,7 +550,7 @@ class CTxMemPool\n     void _clear(); //lock free\n     bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n     void queryHashes(std::vector<uint256>& vtxid);\n-    bool isSpent(const COutPoint& outpoint);\n+    bool isSpent(const COutPoint& outpoint) const;\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n     /**\n@@ -689,7 +689,7 @@ class CTxMemPool\n };\n \n /** \n- * CCoinsView that brings transactions from a memorypool into view.\n+ * CCoinsView that brings transactions from a mempool into view.\n  * It does not check for spendings by memory pool transactions.\n  * Instead, it provides access to all Coins which are either unspent in the\n  * base CCoinsView, or are outputs from any mempool transaction!"
      },
      {
        "sha": "f292924165d158d8d83217c7bb2ca3290d4110eb",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -15,7 +15,7 @@\n  *\n  *  Contains the prevout's CTxOut being spent, and its metadata as well\n  *  (coinbase or not, height). The serialization contains a dummy value of\n- *  zero. This is be compatible with older versions which expect to see\n+ *  zero. This is compatible with older versions which expect to see\n  *  the transaction version there.\n  */\n class TxInUndoSerializer\n@@ -25,7 +25,7 @@ class TxInUndoSerializer\n public:\n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        ::Serialize(s, VARINT(txout->nHeight * 2 + (txout->fCoinBase ? 1 : 0)));\n+        ::Serialize(s, VARINT(txout->nHeight * 2 + (txout->fCoinBase ? 1u : 0u)));\n         if (txout->nHeight > 0) {\n             // Required to maintain compatibility with older undo format.\n             ::Serialize(s, (unsigned char)0);\n@@ -51,10 +51,10 @@ class TxInUndoDeserializer\n             // Old versions stored the version number for the last spend of\n             // a transaction's outputs. Non-final spends were indicated with\n             // height = 0.\n-            int nVersionDummy;\n+            unsigned int nVersionDummy;\n             ::Unserialize(s, VARINT(nVersionDummy));\n         }\n-        ::Unserialize(s, REF(CTxOutCompressor(REF(txout->out))));\n+        ::Unserialize(s, CTxOutCompressor(REF(txout->out)));\n     }\n \n     explicit TxInUndoDeserializer(Coin* coin) : txout(coin) {}\n@@ -76,7 +76,7 @@ class CTxUndo\n         uint64_t count = vprevout.size();\n         ::Serialize(s, COMPACTSIZE(REF(count)));\n         for (const auto& prevout : vprevout) {\n-            ::Serialize(s, REF(TxInUndoSerializer(&prevout)));\n+            ::Serialize(s, TxInUndoSerializer(&prevout));\n         }\n     }\n \n@@ -90,7 +90,7 @@ class CTxUndo\n         }\n         vprevout.resize(count);\n         for (auto& prevout : vprevout) {\n-            ::Unserialize(s, REF(TxInUndoDeserializer(&prevout)));\n+            ::Unserialize(s, TxInUndoDeserializer(&prevout));\n         }\n     }\n };"
      },
      {
        "sha": "490897899bdb34c3735f307b0fa836a4583006ab",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 130,
        "deletions": 49,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,7 +4,6 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <util.h>\n-#include <fs.h>\n \n #include <chainparamsbase.h>\n #include <random.h>\n@@ -71,14 +70,13 @@\n #include <malloc.h>\n #endif\n \n-#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n-#include <boost/algorithm/string/predicate.hpp> // for startswith() and endswith()\n #include <boost/interprocess/sync/file_lock.hpp>\n #include <boost/program_options/detail/config_file.hpp>\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n #include <openssl/rand.h>\n #include <openssl/conf.h>\n+#include <thread>\n \n // Application startup time (used for uptime calculation)\n const int64_t nStartupTime = GetTime();\n@@ -159,10 +157,10 @@ instance_of_cinit;\n  * the mutex).\n  */\n \n-static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;\n+static std::once_flag debugPrintInitFlag;\n \n /**\n- * We use boost::call_once() to make sure mutexDebugLog and\n+ * We use std::call_once() to make sure mutexDebugLog and\n  * vMsgsBeforeOpenLog are initialized in a thread-safe manner.\n  *\n  * NOTE: fileout, mutexDebugLog and sometimes vMsgsBeforeOpenLog\n@@ -171,7 +169,7 @@ static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;\n  * tested, explicit destruction of these objects can be implemented.\n  */\n static FILE* fileout = nullptr;\n-static boost::mutex* mutexDebugLog = nullptr;\n+static std::mutex* mutexDebugLog = nullptr;\n static std::list<std::string>* vMsgsBeforeOpenLog;\n \n static int FileWriteStr(const std::string &str, FILE *fp)\n@@ -182,7 +180,7 @@ static int FileWriteStr(const std::string &str, FILE *fp)\n static void DebugPrintInit()\n {\n     assert(mutexDebugLog == nullptr);\n-    mutexDebugLog = new boost::mutex();\n+    mutexDebugLog = new std::mutex();\n     vMsgsBeforeOpenLog = new std::list<std::string>;\n }\n \n@@ -194,8 +192,8 @@ fs::path GetDebugLogPath()\n \n bool OpenDebugLog()\n {\n-    boost::call_once(&DebugPrintInit, debugPrintInitFlag);\n-    boost::mutex::scoped_lock scoped_lock(*mutexDebugLog);\n+    std::call_once(debugPrintInitFlag, &DebugPrintInit);\n+    std::lock_guard<std::mutex> scoped_lock(*mutexDebugLog);\n \n     assert(fileout == nullptr);\n     assert(vMsgsBeforeOpenLog);\n@@ -314,12 +312,14 @@ static std::string LogTimestampStr(const std::string &str, std::atomic_bool *fSt\n \n     if (*fStartedNewLine) {\n         int64_t nTimeMicros = GetTimeMicros();\n-        strStamped = DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", nTimeMicros/1000000);\n-        if (fLogTimeMicros)\n-            strStamped += strprintf(\".%06d\", nTimeMicros%1000000);\n+        strStamped = FormatISO8601DateTime(nTimeMicros/1000000);\n+        if (fLogTimeMicros) {\n+            strStamped.pop_back();\n+            strStamped += strprintf(\".%06dZ\", nTimeMicros%1000000);\n+        }\n         int64_t mocktime = GetMockTime();\n         if (mocktime) {\n-            strStamped += \" (mocktime: \" + DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", mocktime) + \")\";\n+            strStamped += \" (mocktime: \" + FormatISO8601DateTime(mocktime) + \")\";\n         }\n         strStamped += ' ' + str;\n     } else\n@@ -348,8 +348,8 @@ int LogPrintStr(const std::string &str)\n     }\n     else if (fPrintToDebugLog)\n     {\n-        boost::call_once(&DebugPrintInit, debugPrintInitFlag);\n-        boost::mutex::scoped_lock scoped_lock(*mutexDebugLog);\n+        std::call_once(debugPrintInitFlag, &DebugPrintInit);\n+        std::lock_guard<std::mutex> scoped_lock(*mutexDebugLog);\n \n         // buffer if we haven't opened the log yet\n         if (fileout == nullptr) {\n@@ -417,21 +417,67 @@ void ReleaseDirectoryLocks()\n     dir_locks.clear();\n }\n \n-/** Interpret string as boolean, for argument parsing */\n+bool DirIsWritable(const fs::path& directory)\n+{\n+    fs::path tmpFile = directory / fs::unique_path();\n+\n+    FILE* file = fsbridge::fopen(tmpFile, \"a\");\n+    if (!file) return false;\n+\n+    fclose(file);\n+    remove(tmpFile);\n+\n+    return true;\n+}\n+\n+/**\n+ * Interpret a string argument as a boolean.\n+ *\n+ * The definition of atoi() requires that non-numeric string values like \"foo\",\n+ * return 0. This means that if a user unintentionally supplies a non-integer\n+ * argument here, the return value is always false. This means that -foo=false\n+ * does what the user probably expects, but -foo=true is well defined but does\n+ * not do what they probably expected.\n+ *\n+ * The return value of atoi() is undefined when given input not representable as\n+ * an int. On most systems this means string value between \"-2147483648\" and\n+ * \"2147483647\" are well defined (this method will return true). Setting\n+ * -txindex=2147483648 on most systems, however, is probably undefined.\n+ *\n+ * For a more extensive discussion of this topic (and a wide range of opinions\n+ * on the Right Way to change this code), see PR12713.\n+ */\n static bool InterpretBool(const std::string& strValue)\n {\n     if (strValue.empty())\n         return true;\n     return (atoi(strValue) != 0);\n }\n \n-/** Turn -noX into -X=0 */\n-static void InterpretNegativeSetting(std::string& strKey, std::string& strValue)\n+/**\n+ * Interpret -nofoo as if the user supplied -foo=0.\n+ *\n+ * This method also tracks when the -no form was supplied, and treats \"-foo\" as\n+ * a negated option when this happens. This can be later checked using the\n+ * IsArgNegated() method. One use case for this is to have a way to disable\n+ * options that are not normally boolean (e.g. using -nodebuglogfile to request\n+ * that debug log output is not sent to any file at all).\n+ */\n+void ArgsManager::InterpretNegatedOption(std::string& key, std::string& val)\n {\n-    if (strKey.length()>3 && strKey[0]=='-' && strKey[1]=='n' && strKey[2]=='o')\n-    {\n-        strKey = \"-\" + strKey.substr(3);\n-        strValue = InterpretBool(strValue) ? \"0\" : \"1\";\n+    if (key.substr(0, 3) == \"-no\") {\n+        bool bool_val = InterpretBool(val);\n+        if (!bool_val ) {\n+            // Double negatives like -nofoo=0 are supported (but discouraged)\n+            LogPrintf(\"Warning: parsed potentially confusing double-negative %s=%s\\n\", key, val);\n+        }\n+        key.erase(1, 2);\n+        m_negated_args.insert(key);\n+        val = bool_val ? \"0\" : \"1\";\n+    } else {\n+        // In an invocation like \"bitcoind -nofoo -foo\" we want to unmark -foo\n+        // as negated when we see the second option.\n+        m_negated_args.erase(key);\n     }\n }\n \n@@ -440,34 +486,34 @@ void ArgsManager::ParseParameters(int argc, const char* const argv[])\n     LOCK(cs_args);\n     mapArgs.clear();\n     mapMultiArgs.clear();\n-\n-    for (int i = 1; i < argc; i++)\n-    {\n-        std::string str(argv[i]);\n-        std::string strValue;\n-        size_t is_index = str.find('=');\n-        if (is_index != std::string::npos)\n-        {\n-            strValue = str.substr(is_index+1);\n-            str = str.substr(0, is_index);\n+    m_negated_args.clear();\n+\n+    for (int i = 1; i < argc; i++) {\n+        std::string key(argv[i]);\n+        std::string val;\n+        size_t is_index = key.find('=');\n+        if (is_index != std::string::npos) {\n+            val = key.substr(is_index + 1);\n+            key.erase(is_index);\n         }\n #ifdef WIN32\n-        boost::to_lower(str);\n-        if (boost::algorithm::starts_with(str, \"/\"))\n-            str = \"-\" + str.substr(1);\n+        std::transform(key.begin(), key.end(), key.begin(), ::tolower);\n+        if (key[0] == '/')\n+            key[0] = '-';\n #endif\n \n-        if (str[0] != '-')\n+        if (key[0] != '-')\n             break;\n \n-        // Interpret --foo as -foo.\n-        // If both --foo and -foo are set, the last takes effect.\n-        if (str.length() > 1 && str[1] == '-')\n-            str = str.substr(1);\n-        InterpretNegativeSetting(str, strValue);\n+        // Transform --foo to -foo\n+        if (key.length() > 1 && key[1] == '-')\n+            key.erase(0, 1);\n \n-        mapArgs[str] = strValue;\n-        mapMultiArgs[str].push_back(strValue);\n+        // Transform -nofoo to -foo=0\n+        InterpretNegatedOption(key, val);\n+\n+        mapArgs[key] = val;\n+        mapMultiArgs[key].push_back(val);\n     }\n }\n \n@@ -485,6 +531,12 @@ bool ArgsManager::IsArgSet(const std::string& strArg) const\n     return mapArgs.count(strArg);\n }\n \n+bool ArgsManager::IsArgNegated(const std::string& strArg) const\n+{\n+    LOCK(cs_args);\n+    return m_negated_args.find(strArg) != m_negated_args.end();\n+}\n+\n std::string ArgsManager::GetArg(const std::string& strArg, const std::string& strDefault) const\n {\n     LOCK(cs_args);\n@@ -598,10 +650,41 @@ fs::path GetDefaultDataDir()\n #endif\n }\n \n+static fs::path g_blocks_path_cached;\n+static fs::path g_blocks_path_cache_net_specific;\n static fs::path pathCached;\n static fs::path pathCachedNetSpecific;\n static CCriticalSection csPathCached;\n \n+const fs::path &GetBlocksDir(bool fNetSpecific)\n+{\n+\n+    LOCK(csPathCached);\n+\n+    fs::path &path = fNetSpecific ? g_blocks_path_cache_net_specific : g_blocks_path_cached;\n+\n+    // This can be called during exceptions by LogPrintf(), so we cache the\n+    // value so we don't have to do memory allocations after that.\n+    if (!path.empty())\n+        return path;\n+\n+    if (gArgs.IsArgSet(\"-blocksdir\")) {\n+        path = fs::system_complete(gArgs.GetArg(\"-blocksdir\", \"\"));\n+        if (!fs::is_directory(path)) {\n+            path = \"\";\n+            return path;\n+        }\n+    } else {\n+        path = GetDataDir(false);\n+    }\n+    if (fNetSpecific)\n+        path /= BaseParams().DataDir();\n+\n+    path /= \"blocks\";\n+    fs::create_directories(path);\n+    return path;\n+}\n+\n const fs::path &GetDataDir(bool fNetSpecific)\n {\n \n@@ -640,6 +723,8 @@ void ClearDatadirCache()\n \n     pathCached = fs::path();\n     pathCachedNetSpecific = fs::path();\n+    g_blocks_path_cached = fs::path();\n+    g_blocks_path_cache_net_specific = fs::path();\n }\n \n fs::path GetConfigFile(const std::string& confPath)\n@@ -663,7 +748,7 @@ void ArgsManager::ReadConfigFile(const std::string& confPath)\n             // Don't overwrite existing settings so command line settings override bitcoin.conf\n             std::string strKey = std::string(\"-\") + it->string_key;\n             std::string strValue = it->value[0];\n-            InterpretNegativeSetting(strKey, strValue);\n+            InterpretNegatedOption(strKey, strValue);\n             if (mapArgs.count(strKey) == 0)\n                 mapArgs[strKey] = strValue;\n             mapMultiArgs[strKey].push_back(strValue);\n@@ -927,11 +1012,7 @@ bool SetupNetworking()\n \n int GetNumCores()\n {\n-#if BOOST_VERSION >= 105600\n-    return boost::thread::physical_concurrency();\n-#else // Must fall back to hardware_concurrency, which unfortunately counts virtual cores\n-    return boost::thread::hardware_concurrency();\n-#endif\n+    return std::thread::hardware_concurrency();\n }\n \n std::string CopyrightHolders(const std::string& strPrefix)"
      },
      {
        "sha": "4c473c935491ffe476e36d38c8a4d19a091b7ddd",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 22,
        "deletions": 4,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -25,6 +25,7 @@\n #include <map>\n #include <stdint.h>\n #include <string>\n+#include <unordered_set>\n #include <vector>\n \n #include <boost/signals2/signal.hpp>\n@@ -136,7 +137,7 @@ template<typename T, typename... Args> static inline void MarkUsed(const T& t, c\n \n // Be conservative when using LogPrintf/error or other things which\n // unconditionally log to debug.log! It should not be the case that an inbound\n-// peer can fill up a users disk with debug.log entries.\n+// peer can fill up a user's disk with debug.log entries.\n \n #ifdef USE_COVERAGE\n #define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n@@ -174,6 +175,7 @@ int RaiseFileDescriptorLimit(int nMinFD);\n void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);\n bool RenameOver(fs::path src, fs::path dest);\n bool LockDirectory(const fs::path& directory, const std::string lockfile_name, bool probe_only=false);\n+bool DirIsWritable(const fs::path& directory);\n \n /** Release all directory locks. This is used for unit testing only, at runtime\n  * the global destructor will take care of the locks.\n@@ -182,6 +184,7 @@ void ReleaseDirectoryLocks();\n \n bool TryCreateDirectories(const fs::path& p);\n fs::path GetDefaultDataDir();\n+const fs::path &GetBlocksDir(bool fNetSpecific = true);\n const fs::path &GetDataDir(bool fNetSpecific = true);\n void ClearDatadirCache();\n fs::path GetConfigFile(const std::string& confPath);\n@@ -222,6 +225,8 @@ class ArgsManager\n     mutable CCriticalSection cs_args;\n     std::map<std::string, std::string> mapArgs;\n     std::map<std::string, std::vector<std::string>> mapMultiArgs;\n+    std::unordered_set<std::string> m_negated_args;\n+\n public:\n     void ParseParameters(int argc, const char*const argv[]);\n     void ReadConfigFile(const std::string& confPath);\n@@ -242,6 +247,15 @@ class ArgsManager\n      */\n     bool IsArgSet(const std::string& strArg) const;\n \n+    /**\n+     * Return true if the argument was originally passed as a negated option,\n+     * i.e. -nofoo.\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @return true if the argument was passed negated\n+     */\n+    bool IsArgNegated(const std::string& strArg) const;\n+\n     /**\n      * Return string argument or default value\n      *\n@@ -290,6 +304,11 @@ class ArgsManager\n     // Forces an arg setting. Called by SoftSetArg() if the arg hasn't already\n     // been set. Also called directly in testing.\n     void ForceSetArg(const std::string& strArg, const std::string& strValue);\n+\n+private:\n+\n+    // Munge -nofoo into -foo=0 and track the value as negated.\n+    void InterpretNegatedOption(std::string &key, std::string &val);\n };\n \n extern ArgsManager gArgs;\n@@ -312,9 +331,8 @@ std::string HelpMessageGroup(const std::string& message);\n std::string HelpMessageOpt(const std::string& option, const std::string& message);\n \n /**\n- * Return the number of physical cores available on the current system.\n- * @note This does not count virtual cores, such as those provided by HyperThreading\n- * when boost is newer than 1.56.\n+ * Return the number of cores available on the current system.\n+ * @note This does count virtual cores, such as those provided by HyperThreading.\n  */\n int GetNumCores();\n "
      },
      {
        "sha": "d1025fc7bf6b9236b5fc2a6e87ed87819fa92b72",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 243,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -127,46 +127,11 @@ std::string EncodeBase64(const unsigned char* pch, size_t len)\n {\n     static const char *pbase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n \n-    std::string strRet = \"\";\n-    strRet.reserve((len+2)/3*4);\n-\n-    int mode=0, left=0;\n-    const unsigned char *pchEnd = pch+len;\n-\n-    while (pch<pchEnd)\n-    {\n-        int enc = *(pch++);\n-        switch (mode)\n-        {\n-            case 0: // we have no bits\n-                strRet += pbase64[enc >> 2];\n-                left = (enc & 3) << 4;\n-                mode = 1;\n-                break;\n-\n-            case 1: // we have two bits\n-                strRet += pbase64[left | (enc >> 4)];\n-                left = (enc & 15) << 2;\n-                mode = 2;\n-                break;\n-\n-            case 2: // we have four bits\n-                strRet += pbase64[left | (enc >> 6)];\n-                strRet += pbase64[enc & 63];\n-                mode = 0;\n-                break;\n-        }\n-    }\n-\n-    if (mode)\n-    {\n-        strRet += pbase64[left];\n-        strRet += '=';\n-        if (mode == 1)\n-            strRet += '=';\n-    }\n-\n-    return strRet;\n+    std::string str;\n+    str.reserve(((len + 2) / 3) * 4);\n+    ConvertBits<8, 6, true>([&](int v) { str += pbase64[v]; }, pch, pch + len);\n+    while (str.size() % 4) str += '=';\n+    return str;\n }\n \n std::string EncodeBase64(const std::string& str)\n@@ -193,68 +158,32 @@ std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n     };\n \n-    if (pfInvalid)\n-        *pfInvalid = false;\n-\n-    std::vector<unsigned char> vchRet;\n-    vchRet.reserve(strlen(p)*3/4);\n-\n-    int mode = 0;\n-    int left = 0;\n-\n-    while (1)\n-    {\n-         int dec = decode64_table[(unsigned char)*p];\n-         if (dec == -1) break;\n-         p++;\n-         switch (mode)\n-         {\n-             case 0: // we have no bits and get 6\n-                 left = dec;\n-                 mode = 1;\n-                 break;\n-\n-              case 1: // we have 6 bits and keep 4\n-                  vchRet.push_back((left<<2) | (dec>>4));\n-                  left = dec & 15;\n-                  mode = 2;\n-                  break;\n-\n-             case 2: // we have 4 bits and get 6, we keep 2\n-                 vchRet.push_back((left<<4) | (dec>>2));\n-                 left = dec & 3;\n-                 mode = 3;\n-                 break;\n-\n-             case 3: // we have 2 bits and get 6\n-                 vchRet.push_back((left<<6) | dec);\n-                 mode = 0;\n-                 break;\n-         }\n+    const char* e = p;\n+    std::vector<uint8_t> val;\n+    val.reserve(strlen(p));\n+    while (*p != 0) {\n+        int x = decode64_table[(unsigned char)*p];\n+        if (x == -1) break;\n+        val.push_back(x);\n+        ++p;\n     }\n \n-    if (pfInvalid)\n-        switch (mode)\n-        {\n-            case 0: // 4n base64 characters processed: ok\n-                break;\n-\n-            case 1: // 4n+1 base64 character processed: impossible\n-                *pfInvalid = true;\n-                break;\n-\n-            case 2: // 4n+2 base64 characters processed: require '=='\n-                if (left || p[0] != '=' || p[1] != '=' || decode64_table[(unsigned char)p[2]] != -1)\n-                    *pfInvalid = true;\n-                break;\n-\n-            case 3: // 4n+3 base64 characters processed: require '='\n-                if (left || p[0] != '=' || decode64_table[(unsigned char)p[1]] != -1)\n-                    *pfInvalid = true;\n-                break;\n+    std::vector<unsigned char> ret;\n+    ret.reserve((val.size() * 3) / 4);\n+    bool valid = ConvertBits<6, 8, false>([&](unsigned char c) { ret.push_back(c); }, val.begin(), val.end());\n+\n+    const char* q = p;\n+    while (valid && *p != 0) {\n+        if (*p != '=') {\n+            valid = false;\n+            break;\n         }\n+        ++p;\n+    }\n+    valid = valid && (p - e) % 4 == 0 && p - q < 4;\n+    if (pfInvalid) *pfInvalid = !valid;\n \n-    return vchRet;\n+    return ret;\n }\n \n std::string DecodeBase64(const std::string& str)\n@@ -267,59 +196,11 @@ std::string EncodeBase32(const unsigned char* pch, size_t len)\n {\n     static const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n \n-    std::string strRet=\"\";\n-    strRet.reserve((len+4)/5*8);\n-\n-    int mode=0, left=0;\n-    const unsigned char *pchEnd = pch+len;\n-\n-    while (pch<pchEnd)\n-    {\n-        int enc = *(pch++);\n-        switch (mode)\n-        {\n-            case 0: // we have no bits\n-                strRet += pbase32[enc >> 3];\n-                left = (enc & 7) << 2;\n-                mode = 1;\n-                break;\n-\n-            case 1: // we have three bits\n-                strRet += pbase32[left | (enc >> 6)];\n-                strRet += pbase32[(enc >> 1) & 31];\n-                left = (enc & 1) << 4;\n-                mode = 2;\n-                break;\n-\n-            case 2: // we have one bit\n-                strRet += pbase32[left | (enc >> 4)];\n-                left = (enc & 15) << 1;\n-                mode = 3;\n-                break;\n-\n-            case 3: // we have four bits\n-                strRet += pbase32[left | (enc >> 7)];\n-                strRet += pbase32[(enc >> 2) & 31];\n-                left = (enc & 3) << 3;\n-                mode = 4;\n-                break;\n-\n-            case 4: // we have two bits\n-                strRet += pbase32[left | (enc >> 5)];\n-                strRet += pbase32[enc & 31];\n-                mode = 0;\n-        }\n-    }\n-\n-    static const int nPadding[5] = {0, 6, 4, 3, 1};\n-    if (mode)\n-    {\n-        strRet += pbase32[left];\n-        for (int n=0; n<nPadding[mode]; n++)\n-             strRet += '=';\n-    }\n-\n-    return strRet;\n+    std::string str;\n+    str.reserve(((len + 4) / 5) * 8);\n+    ConvertBits<8, 5, true>([&](int v) { str += pbase32[v]; }, pch, pch + len);\n+    while (str.size() % 8) str += '=';\n+    return str;\n }\n \n std::string EncodeBase32(const std::string& str)\n@@ -346,102 +227,32 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n     };\n \n-    if (pfInvalid)\n-        *pfInvalid = false;\n-\n-    std::vector<unsigned char> vchRet;\n-    vchRet.reserve((strlen(p))*5/8);\n-\n-    int mode = 0;\n-    int left = 0;\n-\n-    while (1)\n-    {\n-         int dec = decode32_table[(unsigned char)*p];\n-         if (dec == -1) break;\n-         p++;\n-         switch (mode)\n-         {\n-             case 0: // we have no bits and get 5\n-                 left = dec;\n-                 mode = 1;\n-                 break;\n-\n-              case 1: // we have 5 bits and keep 2\n-                  vchRet.push_back((left<<3) | (dec>>2));\n-                  left = dec & 3;\n-                  mode = 2;\n-                  break;\n-\n-             case 2: // we have 2 bits and keep 7\n-                 left = left << 5 | dec;\n-                 mode = 3;\n-                 break;\n-\n-             case 3: // we have 7 bits and keep 4\n-                 vchRet.push_back((left<<1) | (dec>>4));\n-                 left = dec & 15;\n-                 mode = 4;\n-                 break;\n-\n-             case 4: // we have 4 bits, and keep 1\n-                 vchRet.push_back((left<<4) | (dec>>1));\n-                 left = dec & 1;\n-                 mode = 5;\n-                 break;\n-\n-             case 5: // we have 1 bit, and keep 6\n-                 left = left << 5 | dec;\n-                 mode = 6;\n-                 break;\n-\n-             case 6: // we have 6 bits, and keep 3\n-                 vchRet.push_back((left<<2) | (dec>>3));\n-                 left = dec & 7;\n-                 mode = 7;\n-                 break;\n-\n-             case 7: // we have 3 bits, and keep 0\n-                 vchRet.push_back((left<<5) | dec);\n-                 mode = 0;\n-                 break;\n-         }\n+    const char* e = p;\n+    std::vector<uint8_t> val;\n+    val.reserve(strlen(p));\n+    while (*p != 0) {\n+        int x = decode32_table[(unsigned char)*p];\n+        if (x == -1) break;\n+        val.push_back(x);\n+        ++p;\n     }\n \n-    if (pfInvalid)\n-        switch (mode)\n-        {\n-            case 0: // 8n base32 characters processed: ok\n-                break;\n-\n-            case 1: // 8n+1 base32 characters processed: impossible\n-            case 3: //   +3\n-            case 6: //   +6\n-                *pfInvalid = true;\n-                break;\n-\n-            case 2: // 8n+2 base32 characters processed: require '======'\n-                if (left || p[0] != '=' || p[1] != '=' || p[2] != '=' || p[3] != '=' || p[4] != '=' || p[5] != '=' || decode32_table[(unsigned char)p[6]] != -1)\n-                    *pfInvalid = true;\n-                break;\n-\n-            case 4: // 8n+4 base32 characters processed: require '===='\n-                if (left || p[0] != '=' || p[1] != '=' || p[2] != '=' || p[3] != '=' || decode32_table[(unsigned char)p[4]] != -1)\n-                    *pfInvalid = true;\n-                break;\n-\n-            case 5: // 8n+5 base32 characters processed: require '==='\n-                if (left || p[0] != '=' || p[1] != '=' || p[2] != '=' || decode32_table[(unsigned char)p[3]] != -1)\n-                    *pfInvalid = true;\n-                break;\n-\n-            case 7: // 8n+7 base32 characters processed: require '='\n-                if (left || p[0] != '=' || decode32_table[(unsigned char)p[1]] != -1)\n-                    *pfInvalid = true;\n-                break;\n+    std::vector<unsigned char> ret;\n+    ret.reserve((val.size() * 5) / 8);\n+    bool valid = ConvertBits<5, 8, false>([&](unsigned char c) { ret.push_back(c); }, val.begin(), val.end());\n+\n+    const char* q = p;\n+    while (valid && *p != 0) {\n+        if (*p != '=') {\n+            valid = false;\n+            break;\n         }\n+        ++p;\n+    }\n+    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    if (pfInvalid) *pfInvalid = !valid;\n \n-    return vchRet;\n+    return ret;\n }\n \n std::string DecodeBase32(const std::string& str)"
      },
      {
        "sha": "1c9cca90b2f110be44ae57cb558a2a4fee9bf8f0",
        "filename": "src/utilstrencodings.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/utilstrencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/utilstrencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -151,7 +151,7 @@ bool ParseFixedPoint(const std::string &val, int decimals, int64_t *amount_out);\n \n /** Convert from one power-of-2 number base to another. */\n template<int frombits, int tobits, bool pad, typename O, typename I>\n-bool ConvertBits(O& out, I it, I end) {\n+bool ConvertBits(const O& outfn, I it, I end) {\n     size_t acc = 0;\n     size_t bits = 0;\n     constexpr size_t maxv = (1 << tobits) - 1;\n@@ -161,12 +161,12 @@ bool ConvertBits(O& out, I it, I end) {\n         bits += frombits;\n         while (bits >= tobits) {\n             bits -= tobits;\n-            out.push_back((acc >> bits) & maxv);\n+            outfn((acc >> bits) & maxv);\n         }\n         ++it;\n     }\n     if (pad) {\n-        if (bits) out.push_back((acc << (tobits - bits)) & maxv);\n+        if (bits) outfn((acc << (tobits - bits)) & maxv);\n     } else if (bits >= frombits || ((acc << (tobits - bits)) & maxv)) {\n         return false;\n     }"
      },
      {
        "sha": "8a861039b3ade9f34ec0d4cf77d415531fb8c7b0",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -85,3 +85,15 @@ std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n     ss << boost::posix_time::from_time_t(nTime);\n     return ss.str();\n }\n+\n+std::string FormatISO8601DateTime(int64_t nTime) {\n+    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n+}\n+\n+std::string FormatISO8601Date(int64_t nTime) {\n+    return DateTimeStrFormat(\"%Y-%m-%d\", nTime);\n+}\n+\n+std::string FormatISO8601Time(int64_t nTime) {\n+    return DateTimeStrFormat(\"%H:%M:%SZ\", nTime);\n+}"
      },
      {
        "sha": "807c52ffafd1a56fc2c9d9db0dcc0e947344fffd",
        "filename": "src/utiltime.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/utiltime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/utiltime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -27,6 +27,14 @@ void SetMockTime(int64_t nMockTimeIn);\n int64_t GetMockTime();\n void MilliSleep(int64_t n);\n \n+/**\n+ * ISO 8601 formatting is preferred. Use the FormatISO8601{DateTime,Date,Time}\n+ * helper functions if possible.\n+ */\n std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime);\n \n+std::string FormatISO8601DateTime(int64_t nTime);\n+std::string FormatISO8601Date(int64_t nTime);\n+std::string FormatISO8601Time(int64_t nTime);\n+\n #endif // BITCOIN_UTILTIME_H"
      },
      {
        "sha": "77764ff9232babe5301d684a8a9adbc9e77e283b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 152,
        "deletions": 84,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -227,6 +227,7 @@ CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;\n \n CBlockPolicyEstimator feeEstimator;\n CTxMemPool mempool(&feeEstimator);\n+std::atomic_bool g_is_mempool_loaded{false};\n \n /** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n@@ -260,12 +261,12 @@ namespace {\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n {\n+    AssertLockHeld(cs_main);\n+\n     // Find the first block the caller has in the main chain\n     for (const uint256& hash : locator.vHave) {\n-        BlockMap::iterator mi = mapBlockIndex.find(hash);\n-        if (mi != mapBlockIndex.end())\n-        {\n-            CBlockIndex* pindex = (*mi).second;\n+        CBlockIndex* pindex = LookupBlockIndex(hash);\n+        if (pindex) {\n             if (chain.Contains(pindex))\n                 return pindex;\n             if (pindex->GetAncestor(chain.Height()) == chain.Tip()) {\n@@ -280,11 +281,11 @@ std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n std::unique_ptr<CCoinsViewCache> pcoinsTip;\n std::unique_ptr<CBlockTreeDB> pblocktree;\n \n-enum FlushStateMode {\n-    FLUSH_STATE_NONE,\n-    FLUSH_STATE_IF_NEEDED,\n-    FLUSH_STATE_PERIODIC,\n-    FLUSH_STATE_ALWAYS\n+enum class FlushStateMode {\n+    NONE,\n+    IF_NEEDED,\n+    PERIODIC,\n+    ALWAYS\n };\n \n // See definition for documentation\n@@ -949,7 +950,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // This transaction should only count for fee estimation if:\n         // - it isn't a BIP 125 replacement transaction (may not be widely supported)\n-        // - it's not being readded during a reorg which bypasses typical mempool fee limits\n+        // - it's not being re-added during a reorg which bypasses typical mempool fee limits\n         // - the node is not behind\n         // - the transaction is not dependent on any other transactions in the mempool\n         bool validForFeeEstimation = !fReplacementTransaction && !bypass_limits && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);\n@@ -983,7 +984,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n-    FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC);\n+    FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n     return res;\n }\n \n@@ -1077,7 +1078,7 @@ static bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMes\n \n     // Write index header\n     unsigned int nSize = GetSerializeSize(fileout, block);\n-    fileout << FLATDATA(messageStart) << nSize;\n+    fileout << messageStart << nSize;\n \n     // Write block\n     long fileOutPos = ftell(fileout.Get());\n@@ -1267,13 +1268,12 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n \n     LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,\n-      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n-      pindexNew->GetBlockTime()));\n+      log(pindexNew->nChainWork.getdouble())/log(2.0), FormatISO8601DateTime(pindexNew->GetBlockTime()));\n     CBlockIndex *tip = chainActive.Tip();\n     assert (tip);\n     LogPrintf(\"%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n       tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", tip->GetBlockTime()));\n+      FormatISO8601DateTime(tip->GetBlockTime()));\n     CheckForkWarningConditions();\n }\n \n@@ -1317,7 +1317,7 @@ bool CScriptCheck::operator()() {\n int GetSpendHeight(const CCoinsViewCache& inputs)\n {\n     LOCK(cs_main);\n-    CBlockIndex* pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;\n+    CBlockIndex* pindexPrev = LookupBlockIndex(inputs.GetBestBlock());\n     return pindexPrev->nHeight + 1;\n }\n \n@@ -1442,7 +1442,7 @@ bool UndoWriteToDisk(const CBlockUndo& blockundo, CDiskBlockPos& pos, const uint\n \n     // Write index header\n     unsigned int nSize = GetSerializeSize(fileout, blockundo);\n-    fileout << FLATDATA(messageStart) << nSize;\n+    fileout << messageStart << nSize;\n \n     // Write undo data\n     long fileOutPos = ftell(fileout.Get());\n@@ -1685,7 +1685,7 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n \n     for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n         ThresholdState state = VersionBitsState(pindexPrev, params, static_cast<Consensus::DeploymentPos>(i), versionbitscache);\n-        if (state == THRESHOLD_LOCKED_IN || state == THRESHOLD_STARTED) {\n+        if (state == ThresholdState::LOCKED_IN || state == ThresholdState::STARTED) {\n             nVersion |= VersionBitsMask(params, static_cast<Consensus::DeploymentPos>(i));\n         }\n     }\n@@ -1741,7 +1741,7 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n     }\n \n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n-    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n     }\n \n@@ -1773,9 +1773,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n {\n     AssertLockHeld(cs_main);\n     assert(pindex);\n-    // pindex->phashBlock can be null if called by CreateNewBlock/TestBlockValidity\n-    assert((pindex->phashBlock == nullptr) ||\n-           (*pindex->phashBlock == block.GetHash()));\n+    assert(*pindex->phashBlock == block.GetHash());\n     int64_t nTimeStart = GetTimeMicros();\n \n     // Check it again in case a previous version let a bad block in\n@@ -1849,22 +1847,74 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n     // two in the chain that violate it. This prevents exploiting the issue against nodes during their\n     // initial block download.\n-    bool fEnforceBIP30 = (!pindex->phashBlock) || // Enforce on CreateNewBlock invocations which don't have a hash.\n-                          !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||\n+    bool fEnforceBIP30 = !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||\n                            (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256S(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));\n \n     // Once BIP34 activated it was not possible to create new duplicate coinbases and thus other than starting\n     // with the 2 existing duplicate coinbase pairs, not possible to create overwriting txs.  But by the\n     // time BIP34 activated, in each of the existing pairs the duplicate coinbase had overwritten the first\n-    // before the first had been spent.  Since those coinbases are sufficiently buried its no longer possible to create further\n+    // before the first had been spent.  Since those coinbases are sufficiently buried it's no longer possible to create further\n     // duplicate transactions descending from the known pairs either.\n     // If we're on the known chain at height greater than where BIP34 activated, we can save the db accesses needed for the BIP30 check.\n+\n+    // BIP34 requires that a block at height X (block X) has its coinbase\n+    // scriptSig start with a CScriptNum of X (indicated height X).  The above\n+    // logic of no longer requiring BIP30 once BIP34 activates is flawed in the\n+    // case that there is a block X before the BIP34 height of 227,931 which has\n+    // an indicated height Y where Y is greater than X.  The coinbase for block\n+    // X would also be a valid coinbase for block Y, which could be a BIP30\n+    // violation.  An exhaustive search of all mainnet coinbases before the\n+    // BIP34 height which have an indicated height greater than the block height\n+    // reveals many occurrences. The 3 lowest indicated heights found are\n+    // 209,921, 490,897, and 1,983,702 and thus coinbases for blocks at these 3\n+    // heights would be the first opportunity for BIP30 to be violated.\n+\n+    // The search reveals a great many blocks which have an indicated height\n+    // greater than 1,983,702, so we simply remove the optimization to skip\n+    // BIP30 checking for blocks at height 1,983,702 or higher.  Before we reach\n+    // that block in another 25 years or so, we should take advantage of a\n+    // future consensus change to do a new and improved version of BIP34 that\n+    // will actually prevent ever creating any duplicate coinbases in the\n+    // future.\n+    static constexpr int BIP34_IMPLIES_BIP30_LIMIT = 1983702;\n+\n+    // There is no potential to create a duplicate coinbase at block 209,921\n+    // because this is still before the BIP34 height and so explicit BIP30\n+    // checking is still active.\n+\n+    // The final case is block 176,684 which has an indicated height of\n+    // 490,897. Unfortunately, this issue was not discovered until about 2 weeks\n+    // before block 490,897 so there was not much opportunity to address this\n+    // case other than to carefully analyze it and determine it would not be a\n+    // problem. Block 490,897 was, in fact, mined with a different coinbase than\n+    // block 176,684, but it is important to note that even if it hadn't been or\n+    // is remined on an alternate fork with a duplicate coinbase, we would still\n+    // not run into a BIP30 violation.  This is because the coinbase for 176,684\n+    // is spent in block 185,956 in transaction\n+    // d4f7fbbf92f4a3014a230b2dc70b8058d02eb36ac06b4a0736d9d60eaa9e8781.  This\n+    // spending transaction can't be duplicated because it also spends coinbase\n+    // 0328dd85c331237f18e781d692c92de57649529bd5edf1d01036daea32ffde29.  This\n+    // coinbase has an indicated height of over 4.2 billion, and wouldn't be\n+    // duplicatable until that height, and it's currently impossible to create a\n+    // chain that long. Nevertheless we may wish to consider a future soft fork\n+    // which retroactively prevents block 490,897 from creating a duplicate\n+    // coinbase. The two historical BIP30 violations often provide a confusing\n+    // edge case when manipulating the UTXO and it would be simpler not to have\n+    // another edge case to deal with.\n+\n+    // testnet3 has no blocks before the BIP34 height with indicated heights\n+    // post BIP34 before approximately height 486,000,000 and presumably will\n+    // be reset before it reaches block 1,983,702 and starts doing unnecessary\n+    // BIP30 checking again.\n     assert(pindex->pprev);\n     CBlockIndex *pindexBIP34height = pindex->pprev->GetAncestor(chainparams.GetConsensus().BIP34Height);\n     //Only continue to enforce if we're below BIP34 activation height or the block hash at that height doesn't correspond.\n     fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash));\n \n-    if (fEnforceBIP30) {\n+    // TODO: Remove BIP30 checking from block height 1,983,702 on, once we have a\n+    // consensus change that ensures coinbases at those heights can not\n+    // duplicate earlier coinbases.\n+    if (fEnforceBIP30 || pindex->nHeight >= BIP34_IMPLIES_BIP30_LIMIT) {\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n@@ -1877,7 +1927,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n@@ -2047,19 +2097,19 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n         int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n         // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n-        bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n+        bool fCacheLarge = mode == FlushStateMode::PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n         // The cache is over the limit, we have to write now.\n-        bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;\n+        bool fCacheCritical = mode == FlushStateMode::IF_NEEDED && cacheSize > nTotalSpace;\n         // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash.\n-        bool fPeriodicWrite = mode == FLUSH_STATE_PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n+        bool fPeriodicWrite = mode == FlushStateMode::PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n         // It's been very long since we flushed the cache. Do this infrequently, to optimize cache usage.\n-        bool fPeriodicFlush = mode == FLUSH_STATE_PERIODIC && nNow > nLastFlush + (int64_t)DATABASE_FLUSH_INTERVAL * 1000000;\n+        bool fPeriodicFlush = mode == FlushStateMode::PERIODIC && nNow > nLastFlush + (int64_t)DATABASE_FLUSH_INTERVAL * 1000000;\n         // Combine all conditions that result in a full cache flush.\n-        fDoFullFlush = (mode == FLUSH_STATE_ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;\n+        fDoFullFlush = (mode == FlushStateMode::ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;\n         // Write blocks and block index to disk.\n         if (fDoFullFlush || fPeriodicWrite) {\n             // Depend on nMinDiskSpace to ensure we can write block index\n-            if (!CheckDiskSpace(0))\n+            if (!CheckDiskSpace(0, true))\n                 return state.Error(\"out of disk space\");\n             // First make sure all block and undo data is flushed to disk.\n             FlushBlockFile();\n@@ -2101,7 +2151,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n             nLastFlush = nNow;\n         }\n     }\n-    if (fDoFullFlush || ((mode == FLUSH_STATE_ALWAYS || mode == FLUSH_STATE_PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {\n+    if (fDoFullFlush || ((mode == FlushStateMode::ALWAYS || mode == FlushStateMode::PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {\n         // Update best block in wallet (so we can detect restored wallets).\n         GetMainSignals().SetBestChain(chainActive.GetLocator());\n         nLastSetChain = nNow;\n@@ -2115,14 +2165,14 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n void FlushStateToDisk() {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS);\n }\n \n void PruneAndFlush() {\n     CValidationState state;\n     fCheckForPruning = true;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::NONE);\n }\n \n static void DoWarning(const std::string& strWarning)\n@@ -2150,9 +2200,9 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n             WarningBitsConditionChecker checker(bit);\n             ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n-            if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n+            if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {\n                 const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n-                if (state == THRESHOLD_ACTIVE) {\n+                if (state == ThresholdState::ACTIVE) {\n                     DoWarning(strWarning);\n                 } else {\n                     warningMessages.push_back(strWarning);\n@@ -2179,7 +2229,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n     LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight, pindexNew->nVersion,\n       log(pindexNew->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexNew->GetBlockTime()),\n+      FormatISO8601DateTime(pindexNew->GetBlockTime()),\n       GuessVerificationProgress(chainParams.TxData(), pindexNew), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize());\n     if (!warningMessages.empty())\n         LogPrintf(\" warning='%s'\", boost::algorithm::join(warningMessages, \", \"));\n@@ -2218,7 +2268,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n     }\n     LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * MILLI);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n         return false;\n \n     if (disconnectpool) {\n@@ -2356,7 +2406,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime4 - nTime3) * MILLI, nTimeFlush * MICRO, nTimeFlush * MILLI / nBlocksTotal);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime5 - nTime4) * MILLI, nTimeChainState * MICRO, nTimeChainState * MILLI / nBlocksTotal);\n@@ -2633,7 +2683,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     CheckBlockIndex(chainparams.GetConsensus());\n \n     // Write changes periodically to disk, after relay.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)) {\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::PERIODIC)) {\n         return false;\n     }\n \n@@ -2731,7 +2781,11 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n     }\n \n     InvalidChainFound(pindex);\n-    uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);\n+\n+    // Only notify about a new block tip if the active chain was modified.\n+    if (pindex_was_in_chain) {\n+        uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);\n+    }\n     return true;\n }\n bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex) {\n@@ -2777,6 +2831,8 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n \n CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n {\n+    AssertLockHeld(cs_main);\n+\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator it = mapBlockIndex.find(hash);\n@@ -2898,7 +2954,7 @@ static bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int\n         if (nNewChunks > nOldChunks) {\n             if (fPruneMode)\n                 fCheckForPruning = true;\n-            if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)) {\n+            if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos, true)) {\n                 FILE *file = OpenBlockFile(pos);\n                 if (file) {\n                     LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);\n@@ -2931,7 +2987,7 @@ static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos,\n     if (nNewChunks > nOldChunks) {\n         if (fPruneMode)\n             fCheckForPruning = true;\n-        if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)) {\n+        if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos, true)) {\n             FILE *file = OpenUndoFile(pos);\n             if (file) {\n                 LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile);\n@@ -3021,7 +3077,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n {\n     LOCK(cs_main);\n-    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE);\n }\n \n // Compute at which vout of the block's coinbase transaction the witness\n@@ -3140,7 +3196,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n \n     // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;\n     }\n \n@@ -3168,13 +3224,13 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Validation for witness commitments.\n     // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n     //   coinbase (where 0x0000....0000 is used instead).\n-    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness reserved value (unconstrained).\n     // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n     // * There must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\n-    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness nonce). In case there are\n+    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness reserved value). In case there are\n     //   multiple, the last one is used.\n     bool fHaveWitness = false;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE) {\n         int commitpos = GetWitnessCommitmentIndex(block);\n         if (commitpos != -1) {\n             bool malleated = false;\n@@ -3183,7 +3239,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n@@ -3202,7 +3258,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         }\n     }\n \n-    // After the coinbase witness nonce and commitment are verified,\n+    // After the coinbase witness reserved value and commitment are verified,\n     // we can check if the block weight passes (before we've checked the\n     // coinbase witness, it would be possible for the weight to be too\n     // large by filling up the coinbase witness, which doesn't change\n@@ -3223,7 +3279,6 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n-\n         if (miSelf != mapBlockIndex.end()) {\n             // Block header is already known.\n             pindex = miSelf->second;\n@@ -3389,7 +3444,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     }\n \n     if (fCheckForPruning)\n-        FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE); // we just allocated more disk space for block files\n+        FlushStateToDisk(chainparams, state, FlushStateMode::NONE); // we just allocated more disk space for block files\n \n     CheckBlockIndex(chainparams.GetConsensus());\n \n@@ -3434,9 +3489,11 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n     AssertLockHeld(cs_main);\n     assert(pindexPrev && pindexPrev == chainActive.Tip());\n     CCoinsViewCache viewNew(pcoinsTip.get());\n+    uint256 block_hash(block.GetHash());\n     CBlockIndex indexDummy(block);\n     indexDummy.pprev = pindexPrev;\n     indexDummy.nHeight = pindexPrev->nHeight + 1;\n+    indexDummy.phashBlock = &block_hash;\n \n     // NOTE: CheckBlockHeader is called by CheckBlock\n     if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n@@ -3540,7 +3597,7 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::NONE, nManualPruneHeight);\n }\n \n /**\n@@ -3605,9 +3662,9 @@ static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfte\n            nLastBlockWeCanPrune, count);\n }\n \n-bool CheckDiskSpace(uint64_t nAdditionalBytes)\n+bool CheckDiskSpace(uint64_t nAdditionalBytes, bool blocks_dir)\n {\n-    uint64_t nFreeBytesAvailable = fs::space(GetDataDir()).available;\n+    uint64_t nFreeBytesAvailable = fs::space(blocks_dir ? GetBlocksDir() : GetDataDir()).available;\n \n     // Check for nMinDiskSpace bytes (currently 50MB)\n     if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n@@ -3650,11 +3707,13 @@ static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n \n fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix)\n {\n-    return GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n+    return GetBlocksDir() / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n }\n \n CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n {\n+    AssertLockHeld(cs_main);\n+\n     if (hash.IsNull())\n         return nullptr;\n \n@@ -3782,6 +3841,8 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n \n bool LoadChainTip(const CChainParams& chainparams)\n {\n+    AssertLockHeld(cs_main);\n+\n     if (chainActive.Tip() && chainActive.Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return true;\n \n     if (pcoinsTip->GetBestBlock().IsNull() && mapBlockIndex.size() == 1) {\n@@ -3795,16 +3856,17 @@ bool LoadChainTip(const CChainParams& chainparams)\n     }\n \n     // Load pointer to end of best chain\n-    BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n-    if (it == mapBlockIndex.end())\n+    CBlockIndex* pindex = LookupBlockIndex(pcoinsTip->GetBestBlock());\n+    if (!pindex) {\n         return false;\n-    chainActive.SetTip(it->second);\n+    }\n+    chainActive.SetTip(pindex);\n \n     g_chainstate.PruneBlockIndexCandidates();\n \n     LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n         chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n-        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n+        FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()),\n         GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));\n     return true;\n }\n@@ -4033,7 +4095,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk.\n-        if (!FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC))\n+        if (!FlushStateToDisk(params, state, FlushStateMode::PERIODIC))\n             return false;\n     }\n \n@@ -4099,7 +4161,7 @@ bool RewindBlockIndex(const CChainParams& params) {\n         // and skip it here, we're about to -reindex-chainstate anyway, so\n         // it'll get called a bunch real soon.\n         CValidationState state;\n-        if (!FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)) {\n+        if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n             return false;\n         }\n     }\n@@ -4222,7 +4284,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 unsigned char buf[CMessageHeader::MESSAGE_START_SIZE];\n                 blkdat.FindByte(chainparams.MessageStart()[0]);\n                 nRewind = blkdat.GetPos()+1;\n-                blkdat >> FLATDATA(buf);\n+                blkdat >> buf;\n                 if (memcmp(buf, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE))\n                     continue;\n                 // read size\n@@ -4245,26 +4307,31 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 blkdat >> block;\n                 nRewind = blkdat.GetPos();\n \n-                // detect out of order blocks, and store them for later\n                 uint256 hash = block.GetHash();\n-                if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {\n-                    LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n-                            block.hashPrevBlock.ToString());\n-                    if (dbp)\n-                        mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n-                    continue;\n-                }\n-\n-                // process in case the block isn't known yet\n-                if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                {\n                     LOCK(cs_main);\n-                    CValidationState state;\n-                    if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n-                        nLoaded++;\n-                    if (state.IsError())\n-                        break;\n-                } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {\n-                    LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);\n+                    // detect out of order blocks, and store them for later\n+                    if (hash != chainparams.GetConsensus().hashGenesisBlock && !LookupBlockIndex(block.hashPrevBlock)) {\n+                        LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n+                                block.hashPrevBlock.ToString());\n+                        if (dbp)\n+                            mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n+                        continue;\n+                    }\n+\n+                    // process in case the block isn't known yet\n+                    CBlockIndex* pindex = LookupBlockIndex(hash);\n+                    if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                      CValidationState state;\n+                      if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr)) {\n+                          nLoaded++;\n+                      }\n+                      if (state.IsError()) {\n+                          break;\n+                      }\n+                    } else if (hash != chainparams.GetConsensus().hashGenesisBlock && pindex->nHeight % 1000 == 0) {\n+                      LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), pindex->nHeight);\n+                    }\n                 }\n \n                 // Activate the genesis block so normal node progress can continue\n@@ -4502,7 +4569,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n \n std::string CBlockFileInfo::ToString() const\n {\n-    return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast));\n+    return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, FormatISO8601Date(nTimeFirst), FormatISO8601Date(nTimeLast));\n }\n \n CBlockFileInfo* GetBlockFileInfo(size_t n)\n@@ -4658,6 +4725,7 @@ bool DumpMempool(void)\n }\n \n //! Guess how far we are in the verification process at the given block index\n+//! require cs_main if pindex has not been validated yet (because nChainTx might be unset)\n double GuessVerificationProgress(const ChainTxData& data, const CBlockIndex *pindex) {\n     if (pindex == nullptr)\n         return 0.0;"
      },
      {
        "sha": "4031989f006a0521c72d045f129758f1bfdaf274",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -158,6 +158,7 @@ extern CScript COINBASE_FLAGS;\n extern CCriticalSection cs_main;\n extern CBlockPolicyEstimator feeEstimator;\n extern CTxMemPool mempool;\n+extern std::atomic_bool g_is_mempool_loaded;\n typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern BlockMap& mapBlockIndex;\n extern uint64_t nLastBlockTx;\n@@ -254,7 +255,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr, CBlockHeader *first_invalid=nullptr);\n \n /** Check whether enough disk space is available for an incoming block */\n-bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n+bool CheckDiskSpace(uint64_t nAdditionalBytes = 0, bool blocks_dir = false);\n /** Open a block file (blk?????.dat) */\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n@@ -411,7 +412,7 @@ bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& pa\n /** When there are blocks in the active chain with missing data, rewind the chainstate and remove them from the block index */\n bool RewindBlockIndex(const CChainParams& params);\n \n-/** Update uncommitted block structures (currently: only the witness nonce). This is safe for submitted blocks. */\n+/** Update uncommitted block structures (currently: only the witness reserved value). This is safe for submitted blocks. */\n void UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams);\n \n /** Produce the necessary coinbase commitment for a block (modifies the hash, don't call for mined blocks). */\n@@ -428,6 +429,13 @@ class CVerifyDB {\n /** Replay blocks that aren't fully applied to the database. */\n bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n \n+inline CBlockIndex* LookupBlockIndex(const uint256& hash)\n+{\n+    AssertLockHeld(cs_main);\n+    BlockMap::const_iterator it = mapBlockIndex.find(hash);\n+    return it == mapBlockIndex.end() ? nullptr : it->second;\n+}\n+\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n "
      },
      {
        "sha": "63097166af597fd28e53fd09013aaccca9416c29",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -55,6 +55,11 @@ void SyncWithValidationInterfaceQueue();\n \n class CValidationInterface {\n protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~CValidationInterface() = default;\n     /**\n      * Notifies listeners of updated block chain tip\n      *"
      },
      {
        "sha": "e3ec078173408b1e835fc605a00126606f78d6d0",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -29,7 +29,7 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n \n     // Check if this deployment is always active.\n     if (nTimeStart == Consensus::BIP9Deployment::ALWAYS_ACTIVE) {\n-        return THRESHOLD_ACTIVE;\n+        return ThresholdState::ACTIVE;\n     }\n \n     // A block's state is always the same as that of the first of its period, so it is computed based on a pindexPrev whose height equals a multiple of nPeriod - 1.\n@@ -42,12 +42,12 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n     while (cache.count(pindexPrev) == 0) {\n         if (pindexPrev == nullptr) {\n             // The genesis block is by definition defined.\n-            cache[pindexPrev] = THRESHOLD_DEFINED;\n+            cache[pindexPrev] = ThresholdState::DEFINED;\n             break;\n         }\n         if (pindexPrev->GetMedianTimePast() < nTimeStart) {\n             // Optimization: don't recompute down further, as we know every earlier block will be before the start time\n-            cache[pindexPrev] = THRESHOLD_DEFINED;\n+            cache[pindexPrev] = ThresholdState::DEFINED;\n             break;\n         }\n         vToCompute.push_back(pindexPrev);\n@@ -65,17 +65,17 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n         vToCompute.pop_back();\n \n         switch (state) {\n-            case THRESHOLD_DEFINED: {\n+            case ThresholdState::DEFINED: {\n                 if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = THRESHOLD_FAILED;\n+                    stateNext = ThresholdState::FAILED;\n                 } else if (pindexPrev->GetMedianTimePast() >= nTimeStart) {\n-                    stateNext = THRESHOLD_STARTED;\n+                    stateNext = ThresholdState::STARTED;\n                 }\n                 break;\n             }\n-            case THRESHOLD_STARTED: {\n+            case ThresholdState::STARTED: {\n                 if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = THRESHOLD_FAILED;\n+                    stateNext = ThresholdState::FAILED;\n                     break;\n                 }\n                 // We need to count\n@@ -88,17 +88,17 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n                     pindexCount = pindexCount->pprev;\n                 }\n                 if (count >= nThreshold) {\n-                    stateNext = THRESHOLD_LOCKED_IN;\n+                    stateNext = ThresholdState::LOCKED_IN;\n                 }\n                 break;\n             }\n-            case THRESHOLD_LOCKED_IN: {\n+            case ThresholdState::LOCKED_IN: {\n                 // Always progresses into ACTIVE.\n-                stateNext = THRESHOLD_ACTIVE;\n+                stateNext = ThresholdState::ACTIVE;\n                 break;\n             }\n-            case THRESHOLD_FAILED:\n-            case THRESHOLD_ACTIVE: {\n+            case ThresholdState::FAILED:\n+            case ThresholdState::ACTIVE: {\n                 // Nothing happens, these are terminal states.\n                 break;\n             }\n@@ -149,7 +149,7 @@ int AbstractThresholdConditionChecker::GetStateSinceHeightFor(const CBlockIndex*\n     const ThresholdState initialState = GetStateFor(pindexPrev, params, cache);\n \n     // BIP 9 about state DEFINED: \"The genesis block is by definition in this state for each deployment.\"\n-    if (initialState == THRESHOLD_DEFINED) {\n+    if (initialState == ThresholdState::DEFINED) {\n         return 0;\n     }\n "
      },
      {
        "sha": "65cf308c7942edab01583e66e8e24929a7346911",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -17,12 +17,12 @@ static const int32_t VERSIONBITS_TOP_MASK = 0xE0000000UL;\n /** Total bits available for versionbits */\n static const int32_t VERSIONBITS_NUM_BITS = 29;\n \n-enum ThresholdState {\n-    THRESHOLD_DEFINED,\n-    THRESHOLD_STARTED,\n-    THRESHOLD_LOCKED_IN,\n-    THRESHOLD_ACTIVE,\n-    THRESHOLD_FAILED,\n+enum class ThresholdState {\n+    DEFINED,\n+    STARTED,\n+    LOCKED_IN,\n+    ACTIVE,\n+    FAILED,\n };\n \n // A map that gives the state for blocks whose height is a multiple of Period()."
      },
      {
        "sha": "52d6a291c9877c323f3eeb21e77e070caf0588a4",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -18,8 +18,8 @@ class CCoinControl\n public:\n     //! Custom change destination, if not set an address is generated\n     CTxDestination destChange;\n-    //! Custom change type, ignored if destChange is set, defaults to g_change_type\n-    OutputType change_type;\n+    //! Override the default change type if set, ignored if destChange is set\n+    boost::optional<OutputType> m_change_type;\n     //! If false, allows unselected inputs, but requires all selected inputs be used\n     bool fAllowOtherInputs;\n     //! Includes watch only addresses which match the ISMINE_WATCH_SOLVABLE criteria\n@@ -43,7 +43,7 @@ class CCoinControl\n     void SetNull()\n     {\n         destChange = CNoDestination();\n-        change_type = g_change_type;\n+        m_change_type.reset();\n         fAllowOtherInputs = false;\n         fAllowWatchOnly = false;\n         setSelected.clear();"
      },
      {
        "sha": "8596ad2adc5df9390c60150c043ff78c0799d850",
        "filename": "src/wallet/coinselection.cpp",
        "status": "added",
        "additions": 300,
        "deletions": 0,
        "changes": 300,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/coinselection.h>\n+#include <util.h>\n+#include <utilmoneystr.h>\n+\n+// Descending order comparator\n+struct {\n+    bool operator()(const CInputCoin& a, const CInputCoin& b) const\n+    {\n+        return a.effective_value > b.effective_value;\n+    }\n+} descending;\n+\n+/*\n+ * This is the Branch and Bound Coin Selection algorithm designed by Murch. It searches for an input\n+ * set that can pay for the spending target and does not exceed the spending target by more than the\n+ * cost of creating and spending a change output. The algorithm uses a depth-first search on a binary\n+ * tree. In the binary tree, each node corresponds to the inclusion or the omission of a UTXO. UTXOs\n+ * are sorted by their effective values and the trees is explored deterministically per the inclusion\n+ * branch first. At each node, the algorithm checks whether the selection is within the target range.\n+ * While the selection has not reached the target range, more UTXOs are included. When a selection's\n+ * value exceeds the target range, the complete subtree deriving from this selection can be omitted.\n+ * At that point, the last included UTXO is deselected and the corresponding omission branch explored\n+ * instead. The search ends after the complete tree has been searched or after a limited number of tries.\n+ *\n+ * The search continues to search for better solutions after one solution has been found. The best\n+ * solution is chosen by minimizing the waste metric. The waste metric is defined as the cost to\n+ * spend the current inputs at the given fee rate minus the long term expected cost to spend the\n+ * inputs, plus the amount the selection exceeds the spending target:\n+ *\n+ * waste = selectionTotal - target + inputs \u00d7 (currentFeeRate - longTermFeeRate)\n+ *\n+ * The algorithm uses two additional optimizations. A lookahead keeps track of the total value of\n+ * the unexplored UTXOs. A subtree is not explored if the lookahead indicates that the target range\n+ * cannot be reached. Further, it is unnecessary to test equivalent combinations. This allows us\n+ * to skip testing the inclusion of UTXOs that match the effective value and waste of an omitted\n+ * predecessor.\n+ *\n+ * The Branch and Bound algorithm is described in detail in Murch's Master Thesis:\n+ * https://murch.one/wp-content/uploads/2016/11/erhardt2016coinselection.pdf\n+ *\n+ * @param const std::vector<CInputCoin>& utxo_pool The set of UTXOs that we are choosing from.\n+ *        These UTXOs will be sorted in descending order by effective value and the CInputCoins'\n+ *        values are their effective values.\n+ * @param const CAmount& target_value This is the value that we want to select. It is the lower\n+ *        bound of the range.\n+ * @param const CAmount& cost_of_change This is the cost of creating and spending a change output.\n+ *        This plus target_value is the upper bound of the range.\n+ * @param std::set<CInputCoin>& out_set -> This is an output parameter for the set of CInputCoins\n+ *        that have been selected.\n+ * @param CAmount& value_ret -> This is an output parameter for the total value of the CInputCoins\n+ *        that were selected.\n+ * @param CAmount not_input_fees -> The fees that need to be paid for the outputs and fixed size\n+ *        overhead (version, locktime, marker and flag)\n+ */\n+\n+static const size_t TOTAL_TRIES = 100000;\n+\n+bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees)\n+{\n+    out_set.clear();\n+    CAmount curr_value = 0;\n+\n+    std::vector<bool> curr_selection; // select the utxo at this index\n+    curr_selection.reserve(utxo_pool.size());\n+    CAmount actual_target = not_input_fees + target_value;\n+\n+    // Calculate curr_available_value\n+    CAmount curr_available_value = 0;\n+    for (const CInputCoin& utxo : utxo_pool) {\n+        // Assert that this utxo is not negative. It should never be negative, effective value calculation should have removed it\n+        assert(utxo.effective_value > 0);\n+        curr_available_value += utxo.effective_value;\n+    }\n+    if (curr_available_value < actual_target) {\n+        return false;\n+    }\n+\n+    // Sort the utxo_pool\n+    std::sort(utxo_pool.begin(), utxo_pool.end(), descending);\n+\n+    CAmount curr_waste = 0;\n+    std::vector<bool> best_selection;\n+    CAmount best_waste = MAX_MONEY;\n+\n+    // Depth First search loop for choosing the UTXOs\n+    for (size_t i = 0; i < TOTAL_TRIES; ++i) {\n+        // Conditions for starting a backtrack\n+        bool backtrack = false;\n+        if (curr_value + curr_available_value < actual_target ||                // Cannot possibly reach target with the amount remaining in the curr_available_value.\n+            curr_value > actual_target + cost_of_change ||    // Selected value is out of range, go back and try other branch\n+            (curr_waste > best_waste && (utxo_pool.at(0).fee - utxo_pool.at(0).long_term_fee) > 0)) { // Don't select things which we know will be more wasteful if the waste is increasing\n+            backtrack = true;\n+        } else if (curr_value >= actual_target) {       // Selected value is within range\n+            curr_waste += (curr_value - actual_target); // This is the excess value which is added to the waste for the below comparison\n+            // Adding another UTXO after this check could bring the waste down if the long term fee is higher than the current fee.\n+            // However we are not going to explore that because this optimization for the waste is only done when we have hit our target\n+            // value. Adding any more UTXOs will be just burning the UTXO; it will go entirely to fees. Thus we aren't going to\n+            // explore any more UTXOs to avoid burning money like that.\n+            if (curr_waste <= best_waste) {\n+                best_selection = curr_selection;\n+                best_selection.resize(utxo_pool.size());\n+                best_waste = curr_waste;\n+            }\n+            curr_waste -= (curr_value - actual_target); // Remove the excess value as we will be selecting different coins now\n+            backtrack = true;\n+        }\n+\n+        // Backtracking, moving backwards\n+        if (backtrack) {\n+            // Walk backwards to find the last included UTXO that still needs to have its omission branch traversed.\n+            while (!curr_selection.empty() && !curr_selection.back()) {\n+                curr_selection.pop_back();\n+                curr_available_value += utxo_pool.at(curr_selection.size()).effective_value;\n+            };\n+\n+            if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched\n+                break;\n+            }\n+\n+            // Output was included on previous iterations, try excluding now.\n+            curr_selection.back() = false;\n+            CInputCoin& utxo = utxo_pool.at(curr_selection.size() - 1);\n+            curr_value -= utxo.effective_value;\n+            curr_waste -= utxo.fee - utxo.long_term_fee;\n+        } else { // Moving forwards, continuing down this branch\n+            CInputCoin& utxo = utxo_pool.at(curr_selection.size());\n+\n+            // Remove this utxo from the curr_available_value utxo amount\n+            curr_available_value -= utxo.effective_value;\n+\n+            // Avoid searching a branch if the previous UTXO has the same value and same waste and was excluded. Since the ratio of fee to\n+            // long term fee is the same, we only need to check if one of those values match in order to know that the waste is the same.\n+            if (!curr_selection.empty() && !curr_selection.back() &&\n+                utxo.effective_value == utxo_pool.at(curr_selection.size() - 1).effective_value &&\n+                utxo.fee == utxo_pool.at(curr_selection.size() - 1).fee) {\n+                curr_selection.push_back(false);\n+            } else {\n+                // Inclusion branch first (Largest First Exploration)\n+                curr_selection.push_back(true);\n+                curr_value += utxo.effective_value;\n+                curr_waste += utxo.fee - utxo.long_term_fee;\n+            }\n+        }\n+    }\n+\n+    // Check for solution\n+    if (best_selection.empty()) {\n+        return false;\n+    }\n+\n+    // Set output set\n+    value_ret = 0;\n+    for (size_t i = 0; i < best_selection.size(); ++i) {\n+        if (best_selection.at(i)) {\n+            out_set.insert(utxo_pool.at(i));\n+            value_ret += utxo_pool.at(i).txout.nValue;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n+                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n+{\n+    std::vector<char> vfIncluded;\n+\n+    vfBest.assign(vValue.size(), true);\n+    nBest = nTotalLower;\n+\n+    FastRandomContext insecure_rand;\n+\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n+    {\n+        vfIncluded.assign(vValue.size(), false);\n+        CAmount nTotal = 0;\n+        bool fReachedTarget = false;\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        {\n+            for (unsigned int i = 0; i < vValue.size(); i++)\n+            {\n+                //The solver here uses a randomized algorithm,\n+                //the randomness serves no real security purpose but is just\n+                //needed to prevent degenerate behavior and it is important\n+                //that the rng is fast. We do not use a constant random sequence,\n+                //because there may be some privacy improvement by making\n+                //the selection random.\n+                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])\n+                {\n+                    nTotal += vValue[i].txout.nValue;\n+                    vfIncluded[i] = true;\n+                    if (nTotal >= nTargetValue)\n+                    {\n+                        fReachedTarget = true;\n+                        if (nTotal < nBest)\n+                        {\n+                            nBest = nTotal;\n+                            vfBest = vfIncluded;\n+                        }\n+                        nTotal -= vValue[i].txout.nValue;\n+                        vfIncluded[i] = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+bool KnapsackSolver(const CAmount& nTargetValue, std::vector<CInputCoin>& vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet)\n+{\n+    setCoinsRet.clear();\n+    nValueRet = 0;\n+\n+    // List of values less than target\n+    boost::optional<CInputCoin> coinLowestLarger;\n+    std::vector<CInputCoin> vValue;\n+    CAmount nTotalLower = 0;\n+\n+    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n+\n+    for (const CInputCoin &coin : vCoins)\n+    {\n+        if (coin.txout.nValue == nTargetValue)\n+        {\n+            setCoinsRet.insert(coin);\n+            nValueRet += coin.txout.nValue;\n+            return true;\n+        }\n+        else if (coin.txout.nValue < nTargetValue + MIN_CHANGE)\n+        {\n+            vValue.push_back(coin);\n+            nTotalLower += coin.txout.nValue;\n+        }\n+        else if (!coinLowestLarger || coin.txout.nValue < coinLowestLarger->txout.nValue)\n+        {\n+            coinLowestLarger = coin;\n+        }\n+    }\n+\n+    if (nTotalLower == nTargetValue)\n+    {\n+        for (const auto& input : vValue)\n+        {\n+            setCoinsRet.insert(input);\n+            nValueRet += input.txout.nValue;\n+        }\n+        return true;\n+    }\n+\n+    if (nTotalLower < nTargetValue)\n+    {\n+        if (!coinLowestLarger)\n+            return false;\n+        setCoinsRet.insert(coinLowestLarger.get());\n+        nValueRet += coinLowestLarger->txout.nValue;\n+        return true;\n+    }\n+\n+    // Solve subset sum by stochastic approximation\n+    std::sort(vValue.begin(), vValue.end(), descending);\n+    std::vector<char> vfBest;\n+    CAmount nBest;\n+\n+    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);\n+    if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE)\n+        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);\n+\n+    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n+    //                                   or the next bigger coin is closer), return the bigger coin\n+    if (coinLowestLarger &&\n+        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger->txout.nValue <= nBest))\n+    {\n+        setCoinsRet.insert(coinLowestLarger.get());\n+        nValueRet += coinLowestLarger->txout.nValue;\n+    }\n+    else {\n+        for (unsigned int i = 0; i < vValue.size(); i++)\n+            if (vfBest[i])\n+            {\n+                setCoinsRet.insert(vValue[i]);\n+                nValueRet += vValue[i].txout.nValue;\n+            }\n+\n+        if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n+            LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n+            for (unsigned int i = 0; i < vValue.size(); i++) {\n+                if (vfBest[i]) {\n+                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].txout.nValue));\n+                }\n+            }\n+            LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n+        }\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "4d1a43bc17c8aa54b3b5a365e2bf9acfa80647b9",
        "filename": "src/wallet/coinselection.h",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COINSELECTION_H\n+#define BITCOIN_COINSELECTION_H\n+\n+#include <amount.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+\n+//! target minimum change amount\n+static const CAmount MIN_CHANGE = CENT;\n+//! final minimum change amount after paying for fees\n+static const CAmount MIN_FINAL_CHANGE = MIN_CHANGE/2;\n+\n+class CInputCoin {\n+public:\n+    CInputCoin(const CTransactionRef& tx, unsigned int i)\n+    {\n+        if (!tx)\n+            throw std::invalid_argument(\"tx should not be null\");\n+        if (i >= tx->vout.size())\n+            throw std::out_of_range(\"The output index is out of range\");\n+\n+        outpoint = COutPoint(tx->GetHash(), i);\n+        txout = tx->vout[i];\n+        effective_value = txout.nValue;\n+    }\n+\n+    COutPoint outpoint;\n+    CTxOut txout;\n+    CAmount effective_value;\n+    CAmount fee = 0;\n+    CAmount long_term_fee = 0;\n+\n+    bool operator<(const CInputCoin& rhs) const {\n+        return outpoint < rhs.outpoint;\n+    }\n+\n+    bool operator!=(const CInputCoin& rhs) const {\n+        return outpoint != rhs.outpoint;\n+    }\n+\n+    bool operator==(const CInputCoin& rhs) const {\n+        return outpoint == rhs.outpoint;\n+    }\n+};\n+\n+bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n+\n+// Original coin selection algorithm as a fallback\n+bool KnapsackSolver(const CAmount& nTargetValue, std::vector<CInputCoin>& vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet);\n+#endif // BITCOIN_COINSELECTION_H"
      },
      {
        "sha": "553cae4d026cf32bb5f48a92b74d78b3dc2eb6a7",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 35,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -52,20 +52,55 @@ void CheckUniqueFileid(const CDBEnv& env, const std::string& filename, Db& db)\n         }\n     }\n }\n+\n+CCriticalSection cs_db;\n+std::map<std::string, CDBEnv> g_dbenvs; //!< Map from directory name to open db environment.\n } // namespace\n \n+CDBEnv* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename)\n+{\n+    fs::path env_directory;\n+    if (fs::is_regular_file(wallet_path)) {\n+        // Special case for backwards compatibility: if wallet path points to an\n+        // existing file, treat it as the path to a BDB data file in a parent\n+        // directory that also contains BDB log files.\n+        env_directory = wallet_path.parent_path();\n+        database_filename = wallet_path.filename().string();\n+    } else {\n+        // Normal case: Interpret wallet path as a directory path containing\n+        // data and log files.\n+        env_directory = wallet_path;\n+        database_filename = \"wallet.dat\";\n+    }\n+    LOCK(cs_db);\n+    // Note: An ununsed temporary CDBEnv object may be created inside the\n+    // emplace function if the key already exists. This is a little inefficient,\n+    // but not a big concern since the map will be changed in the future to hold\n+    // pointers instead of objects, anyway.\n+    return &g_dbenvs.emplace(std::piecewise_construct, std::forward_as_tuple(env_directory.string()), std::forward_as_tuple(env_directory)).first->second;\n+}\n+\n //\n // CDB\n //\n \n-CDBEnv bitdb;\n-\n-void CDBEnv::EnvShutdown()\n+void CDBEnv::Close()\n {\n     if (!fDbEnvInit)\n         return;\n \n     fDbEnvInit = false;\n+\n+    for (auto& db : mapDb) {\n+        auto count = mapFileUseCount.find(db.first);\n+        assert(count == mapFileUseCount.end() || count->second == 0);\n+        if (db.second) {\n+            db.second->close(0);\n+            delete db.second;\n+            db.second = nullptr;\n+        }\n+    }\n+\n     int ret = dbenv->close(0);\n     if (ret != 0)\n         LogPrintf(\"CDBEnv::EnvShutdown: Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n@@ -80,29 +115,25 @@ void CDBEnv::Reset()\n     fMockDb = false;\n }\n \n-CDBEnv::CDBEnv()\n+CDBEnv::CDBEnv(const fs::path& dir_path) : strPath(dir_path.string())\n {\n     Reset();\n }\n \n CDBEnv::~CDBEnv()\n {\n-    EnvShutdown();\n+    Close();\n }\n \n-void CDBEnv::Close()\n-{\n-    EnvShutdown();\n-}\n-\n-bool CDBEnv::Open(const fs::path& pathIn, bool retry)\n+bool CDBEnv::Open(bool retry)\n {\n     if (fDbEnvInit)\n         return true;\n \n     boost::this_thread::interruption_point();\n \n-    strPath = pathIn.string();\n+    fs::path pathIn = strPath;\n+    TryCreateDirectories(pathIn);\n     if (!LockDirectory(pathIn, \".walletlock\")) {\n         LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", strPath);\n         return false;\n@@ -150,7 +181,7 @@ bool CDBEnv::Open(const fs::path& pathIn, bool retry)\n                 // failure is ok (well, not really, but it's not worse than what we started with)\n             }\n             // try opening it again one more time\n-            if (!Open(pathIn, false)) {\n+            if (!Open(false /* retry */)) {\n                 // if it still fails, it probably means we can't even create the database env\n                 return false;\n             }\n@@ -204,17 +235,20 @@ CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type\n     Db db(dbenv.get(), 0);\n     int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n     if (result == 0)\n-        return VERIFY_OK;\n+        return VerifyResult::VERIFY_OK;\n     else if (recoverFunc == nullptr)\n-        return RECOVER_FAIL;\n+        return VerifyResult::RECOVER_FAIL;\n \n     // Try to recover:\n-    bool fRecovered = (*recoverFunc)(strFile, out_backup_filename);\n-    return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n+    bool fRecovered = (*recoverFunc)(fs::path(strPath) / strFile, out_backup_filename);\n+    return (fRecovered ? VerifyResult::RECOVER_OK : VerifyResult::RECOVER_FAIL);\n }\n \n-bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n+bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n {\n+    std::string filename;\n+    CDBEnv* env = GetWalletEnv(file_path, filename);\n+\n     // Recovery procedure:\n     // move wallet file to walletfilename.timestamp.bak\n     // Call Salvage with fAggressive=true to\n@@ -225,7 +259,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     int64_t now = GetTime();\n     newFilename = strprintf(\"%s.%d.bak\", filename, now);\n \n-    int result = bitdb.dbenv->dbrename(nullptr, filename.c_str(), nullptr,\n+    int result = env->dbenv->dbrename(nullptr, filename.c_str(), nullptr,\n                                        newFilename.c_str(), DB_AUTO_COMMIT);\n     if (result == 0)\n         LogPrintf(\"Renamed %s to %s\\n\", filename, newFilename);\n@@ -236,15 +270,15 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     }\n \n     std::vector<CDBEnv::KeyValPair> salvagedData;\n-    bool fSuccess = bitdb.Salvage(newFilename, true, salvagedData);\n+    bool fSuccess = env->Salvage(newFilename, true, salvagedData);\n     if (salvagedData.empty())\n     {\n         LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename);\n         return false;\n     }\n     LogPrintf(\"Salvage(aggressive) found %u records\\n\", salvagedData.size());\n \n-    std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(bitdb.dbenv.get(), 0);\n+    std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(env->dbenv.get(), 0);\n     int ret = pdbCopy->open(nullptr,               // Txn pointer\n                             filename.c_str(),   // Filename\n                             \"main\",             // Logical db name\n@@ -257,7 +291,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n         return false;\n     }\n \n-    DbTxn* ptxn = bitdb.TxnBegin();\n+    DbTxn* ptxn = env->TxnBegin();\n     for (CDBEnv::KeyValPair& row : salvagedData)\n     {\n         if (recoverKVcallback)\n@@ -279,8 +313,12 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     return fSuccess;\n }\n \n-bool CDB::VerifyEnvironment(const std::string& walletFile, const fs::path& walletDir, std::string& errorStr)\n+bool CDB::VerifyEnvironment(const fs::path& file_path, std::string& errorStr)\n {\n+    std::string walletFile;\n+    CDBEnv* env = GetWalletEnv(file_path, walletFile);\n+    fs::path walletDir = env->Directory();\n+\n     LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n     LogPrintf(\"Using wallet %s\\n\", walletFile);\n \n@@ -291,29 +329,33 @@ bool CDB::VerifyEnvironment(const std::string& walletFile, const fs::path& walle\n         return false;\n     }\n \n-    if (!bitdb.Open(walletDir, true)) {\n+    if (!env->Open(true /* retry */)) {\n         errorStr = strprintf(_(\"Error initializing wallet database environment %s!\"), walletDir);\n         return false;\n     }\n \n     return true;\n }\n \n-bool CDB::VerifyDatabaseFile(const std::string& walletFile, const fs::path& walletDir, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc)\n+bool CDB::VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc)\n {\n+    std::string walletFile;\n+    CDBEnv* env = GetWalletEnv(file_path, walletFile);\n+    fs::path walletDir = env->Directory();\n+\n     if (fs::exists(walletDir / walletFile))\n     {\n         std::string backup_filename;\n-        CDBEnv::VerifyResult r = bitdb.Verify(walletFile, recoverFunc, backup_filename);\n-        if (r == CDBEnv::RECOVER_OK)\n+        CDBEnv::VerifyResult r = env->Verify(walletFile, recoverFunc, backup_filename);\n+        if (r == CDBEnv::VerifyResult::RECOVER_OK)\n         {\n             warningStr = strprintf(_(\"Warning: Wallet file corrupt, data salvaged!\"\n                                      \" Original %s saved as %s in %s; if\"\n                                      \" your balance or transactions are incorrect you should\"\n                                      \" restore from a backup.\"),\n                                    walletFile, backup_filename, walletDir);\n         }\n-        if (r == CDBEnv::RECOVER_FAIL)\n+        if (r == CDBEnv::VerifyResult::RECOVER_FAIL)\n         {\n             errorStr = strprintf(_(\"%s corrupt, salvage failed\"), walletFile);\n             return false;\n@@ -414,8 +456,8 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n         nFlags |= DB_CREATE;\n \n     {\n-        LOCK(env->cs_db);\n-        if (!env->Open(GetWalletDir()))\n+        LOCK(cs_db);\n+        if (!env->Open(false /* retry */))\n             throw std::runtime_error(\"CDB: Failed to open database environment.\");\n \n         pdb = env->mapDb[strFilename];\n@@ -442,7 +484,25 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n             if (ret != 0) {\n                 throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n             }\n-            CheckUniqueFileid(*env, strFilename, *pdb_temp);\n+\n+            // Call CheckUniqueFileid on the containing BDB environment to\n+            // avoid BDB data consistency bugs that happen when different data\n+            // files in the same environment have the same fileid.\n+            //\n+            // Also call CheckUniqueFileid on all the other g_dbenvs to prevent\n+            // bitcoin from opening the same data file through another\n+            // environment when the file is referenced through equivalent but\n+            // not obviously identical symlinked or hard linked or bind mounted\n+            // paths. In the future a more relaxed check for equal inode and\n+            // device ids could be done instead, which would allow opening\n+            // different backup copies of a wallet at the same time. Maybe even\n+            // more ideally, an exclusive lock for accessing the database could\n+            // be implemented, so no equality checks are needed at all. (Newer\n+            // versions of BDB have an set_lk_exclusive method for this\n+            // purpose, but the older version we use does not.)\n+            for (auto& env : g_dbenvs) {\n+                CheckUniqueFileid(env.second, strFilename, *pdb_temp);\n+            }\n \n             pdb = pdb_temp.release();\n             env->mapDb[strFilename] = pdb;\n@@ -490,7 +550,7 @@ void CDB::Close()\n         Flush();\n \n     {\n-        LOCK(env->cs_db);\n+        LOCK(cs_db);\n         --env->mapFileUseCount[strFile];\n     }\n }\n@@ -518,7 +578,7 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n     const std::string& strFile = dbw.strFile;\n     while (true) {\n         {\n-            LOCK(env->cs_db);\n+            LOCK(cs_db);\n             if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0) {\n                 // Flush log data to the dat file\n                 env->CloseDb(strFile);\n@@ -646,7 +706,7 @@ bool CDB::PeriodicFlush(CWalletDBWrapper& dbw)\n     bool ret = false;\n     CDBEnv *env = dbw.env;\n     const std::string& strFile = dbw.strFile;\n-    TRY_LOCK(bitdb.cs_db,lockDb);\n+    TRY_LOCK(cs_db, lockDb);\n     if (lockDb)\n     {\n         // Don't do this if any databases are in use\n@@ -694,7 +754,7 @@ bool CWalletDBWrapper::Backup(const std::string& strDest)\n     while (true)\n     {\n         {\n-            LOCK(env->cs_db);\n+            LOCK(cs_db);\n             if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0)\n             {\n                 // Flush log data to the dat file"
      },
      {
        "sha": "65bb8cc2532f65186c1d9efbda58c7d389552eb4",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 39,
        "deletions": 18,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -11,6 +11,7 @@\n #include <serialize.h>\n #include <streams.h>\n #include <sync.h>\n+#include <util.h>\n #include <version.h>\n \n #include <atomic>\n@@ -32,31 +33,30 @@ class CDBEnv\n     // shutdown problems/crashes caused by a static initialized internal pointer.\n     std::string strPath;\n \n-    void EnvShutdown();\n-\n public:\n-    mutable CCriticalSection cs_db;\n     std::unique_ptr<DbEnv> dbenv;\n     std::map<std::string, int> mapFileUseCount;\n     std::map<std::string, Db*> mapDb;\n \n-    CDBEnv();\n+    CDBEnv(const fs::path& env_directory);\n     ~CDBEnv();\n     void Reset();\n \n     void MakeMock();\n     bool IsMock() const { return fMockDb; }\n+    bool IsInitialized() const { return fDbEnvInit; }\n+    fs::path Directory() const { return strPath; }\n \n     /**\n      * Verify that database file strFile is OK. If it is not,\n      * call the callback to try to recover.\n      * This must be called BEFORE strFile is opened.\n      * Returns true if strFile is OK.\n      */\n-    enum VerifyResult { VERIFY_OK,\n+    enum class VerifyResult { VERIFY_OK,\n                         RECOVER_OK,\n                         RECOVER_FAIL };\n-    typedef bool (*recoverFunc_type)(const std::string& strFile, std::string& out_backup_filename);\n+    typedef bool (*recoverFunc_type)(const fs::path& file_path, std::string& out_backup_filename);\n     VerifyResult Verify(const std::string& strFile, recoverFunc_type recoverFunc, std::string& out_backup_filename);\n     /**\n      * Salvage data from a file that Verify says is bad.\n@@ -68,7 +68,7 @@ class CDBEnv\n     typedef std::pair<std::vector<unsigned char>, std::vector<unsigned char> > KeyValPair;\n     bool Salvage(const std::string& strFile, bool fAggressive, std::vector<KeyValPair>& vResult);\n \n-    bool Open(const fs::path& path, bool retry = 0);\n+    bool Open(bool retry);\n     void Close();\n     void Flush(bool fShutdown);\n     void CheckpointLSN(const std::string& strFile);\n@@ -85,7 +85,8 @@ class CDBEnv\n     }\n };\n \n-extern CDBEnv bitdb;\n+/** Get CDBEnv and database filename given a wallet path. */\n+CDBEnv* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename);\n \n /** An instance of this class represents one database.\n  * For BerkeleyDB this is just a (env, strFile) tuple.\n@@ -100,9 +101,33 @@ class CWalletDBWrapper\n     }\n \n     /** Create DB handle to real database */\n-    CWalletDBWrapper(CDBEnv *env_in, const std::string &strFile_in) :\n-        nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(env_in), strFile(strFile_in)\n+    CWalletDBWrapper(const fs::path& wallet_path, bool mock = false) :\n+        nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0)\n     {\n+        env = GetWalletEnv(wallet_path, strFile);\n+        if (mock) {\n+            env->Close();\n+            env->Reset();\n+            env->MakeMock();\n+        }\n+    }\n+\n+    /** Return object for accessing database at specified path. */\n+    static std::unique_ptr<CWalletDBWrapper> Create(const fs::path& path)\n+    {\n+        return MakeUnique<CWalletDBWrapper>(path);\n+    }\n+\n+    /** Return object for accessing dummy database with no read/write capabilities. */\n+    static std::unique_ptr<CWalletDBWrapper> CreateDummy()\n+    {\n+        return MakeUnique<CWalletDBWrapper>();\n+    }\n+\n+    /** Return object for accessing temporary in-memory database. */\n+    static std::unique_ptr<CWalletDBWrapper> CreateMock()\n+    {\n+        return MakeUnique<CWalletDBWrapper>(\"\", true /* mock */);\n     }\n \n     /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n@@ -113,10 +138,6 @@ class CWalletDBWrapper\n      */\n     bool Backup(const std::string& strDest);\n \n-    /** Get a name for this database, for debugging etc.\n-     */\n-    std::string GetName() const { return strFile; }\n-\n     /** Make sure all changes are flushed to disk.\n      */\n     void Flush(bool shutdown);\n@@ -161,15 +182,15 @@ class CDB\n \n     void Flush();\n     void Close();\n-    static bool Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename);\n+    static bool Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename);\n \n     /* flush the wallet passively (TRY_LOCK)\n        ideal to be called periodically */\n     static bool PeriodicFlush(CWalletDBWrapper& dbw);\n     /* verifies the database environment */\n-    static bool VerifyEnvironment(const std::string& walletFile, const fs::path& walletDir, std::string& errorStr);\n+    static bool VerifyEnvironment(const fs::path& file_path, std::string& errorStr);\n     /* verifies the database file */\n-    static bool VerifyDatabaseFile(const std::string& walletFile, const fs::path& walletDir, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc);\n+    static bool VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc);\n \n public:\n     template <typename K, typename T>\n@@ -329,7 +350,7 @@ class CDB\n     {\n         if (!pdb || activeTxn)\n             return false;\n-        DbTxn* ptxn = bitdb.TxnBegin();\n+        DbTxn* ptxn = env->TxnBegin();\n         if (!ptxn)\n             return false;\n         activeTxn = ptxn;"
      },
      {
        "sha": "82a5017de0a77c9c4ba69c1b0571b3d500332780",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 37,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -16,33 +16,6 @@\n #include <util.h>\n #include <net.h>\n \n-// Calculate the size of the transaction assuming all signatures are max size\n-// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n-// TODO: re-use this in CWallet::CreateTransaction (right now\n-// CreateTransaction uses the constructed dummy-signed tx to do a priority\n-// calculation, but we should be able to refactor after priority is removed).\n-// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n-// be IsAllFromMe).\n-static int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n-{\n-    CMutableTransaction txNew(tx);\n-    std::vector<CInputCoin> vCoins;\n-    // Look up the inputs.  We should have already checked that this transaction\n-    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n-    // wallet, with a valid index into the vout array.\n-    for (auto& input : tx.vin) {\n-        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n-        assert(mi != wallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n-        vCoins.emplace_back(CInputCoin(&(mi->second), input.prevout.n));\n-    }\n-    if (!wallet->DummySignTx(txNew, vCoins)) {\n-        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n-        // implies that we can sign for every input.\n-        return -1;\n-    }\n-    return GetVirtualTransactionSize(txNew);\n-}\n-\n //! Check whether transaction has descendant in wallet or mempool, or has been\n //! mined, or conflicts with a mined transaction. Return a feebumper::Result.\n static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors)\n@@ -262,31 +235,28 @@ Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransacti\n         return result;\n     }\n \n-    CWalletTx wtxBumped(wallet, MakeTransactionRef(std::move(mtx)));\n     // commit/broadcast the tx\n+    CTransactionRef tx = MakeTransactionRef(std::move(mtx));\n+    mapValue_t mapValue = oldWtx.mapValue;\n+    mapValue[\"replaces_txid\"] = oldWtx.GetHash().ToString();\n+\n     CReserveKey reservekey(wallet);\n-    wtxBumped.mapValue = oldWtx.mapValue;\n-    wtxBumped.mapValue[\"replaces_txid\"] = oldWtx.GetHash().ToString();\n-    wtxBumped.vOrderForm = oldWtx.vOrderForm;\n-    wtxBumped.strFromAccount = oldWtx.strFromAccount;\n-    wtxBumped.fTimeReceivedIsTxTime = true;\n-    wtxBumped.fFromMe = true;\n     CValidationState state;\n-    if (!wallet->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, oldWtx.strFromAccount, reservekey, g_connman.get(), state)) {\n         // NOTE: CommitTransaction never returns false, so this should never happen.\n         errors.push_back(strprintf(\"The transaction was rejected: %s\", FormatStateMessage(state)));\n         return Result::WALLET_ERROR;\n     }\n \n-    bumped_txid = wtxBumped.GetHash();\n+    bumped_txid = tx->GetHash();\n     if (state.IsInvalid()) {\n         // This can happen if the mempool rejected the transaction.  Report\n         // what happened in the \"errors\" response.\n         errors.push_back(strprintf(\"Error: The transaction was rejected: %s\", FormatStateMessage(state)));\n     }\n \n     // mark the original tx as bumped\n-    if (!wallet->MarkReplaced(oldWtx.GetHash(), wtxBumped.GetHash())) {\n+    if (!wallet->MarkReplaced(oldWtx.GetHash(), bumped_txid)) {\n         // TODO: see if JSON-RPC has a standard way of returning a response\n         // along with an exception. It would be good to return information about\n         // wtxBumped to the caller even if marking the original transaction"
      },
      {
        "sha": "03c32d3b9733f6ab889506671ca718667df520ab",
        "filename": "src/wallet/fees.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 20,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -20,6 +20,22 @@ CAmount GetRequiredFee(unsigned int nTxBytes)\n \n \n CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc)\n+{\n+    CAmount fee_needed = GetMinimumFeeRate(coin_control, pool, estimator, feeCalc).GetFee(nTxBytes);\n+    // Always obey the maximum\n+    if (fee_needed > maxTxFee) {\n+        fee_needed = maxTxFee;\n+        if (feeCalc) feeCalc->reason = FeeReason::MAXTXFEE;\n+    }\n+    return fee_needed;\n+}\n+\n+CFeeRate GetRequiredFeeRate()\n+{\n+    return std::max(CWallet::minTxFee, ::minRelayTxFee);\n+}\n+\n+CFeeRate GetMinimumFeeRate(const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc)\n {\n     /* User control of how to calculate fee uses the following parameter precedence:\n        1. coin_control.m_feerate\n@@ -28,15 +44,15 @@ CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, c\n        4. nTxConfirmTarget (user-set global variable)\n        The first parameter that is set is used.\n     */\n-    CAmount fee_needed;\n+    CFeeRate feerate_needed ;\n     if (coin_control.m_feerate) { // 1.\n-        fee_needed = coin_control.m_feerate->GetFee(nTxBytes);\n+        feerate_needed = *(coin_control.m_feerate);\n         if (feeCalc) feeCalc->reason = FeeReason::PAYTXFEE;\n         // Allow to override automatic min/max check over coin control instance\n-        if (coin_control.fOverrideFeeRate) return fee_needed;\n+        if (coin_control.fOverrideFeeRate) return feerate_needed;\n     }\n     else if (!coin_control.m_confirm_target && ::payTxFee != CFeeRate(0)) { // 3. TODO: remove magic value of 0 for global payTxFee\n-        fee_needed = ::payTxFee.GetFee(nTxBytes);\n+        feerate_needed = ::payTxFee;\n         if (feeCalc) feeCalc->reason = FeeReason::PAYTXFEE;\n     }\n     else { // 2. or 4.\n@@ -48,35 +64,32 @@ CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, c\n         if (coin_control.m_fee_mode == FeeEstimateMode::CONSERVATIVE) conservative_estimate = true;\n         else if (coin_control.m_fee_mode == FeeEstimateMode::ECONOMICAL) conservative_estimate = false;\n \n-        fee_needed = estimator.estimateSmartFee(target, feeCalc, conservative_estimate).GetFee(nTxBytes);\n-        if (fee_needed == 0) {\n+        feerate_needed = estimator.estimateSmartFee(target, feeCalc, conservative_estimate);\n+        if (feerate_needed == CFeeRate(0)) {\n             // if we don't have enough data for estimateSmartFee, then use fallbackFee\n-            fee_needed = CWallet::fallbackFee.GetFee(nTxBytes);\n+            feerate_needed = CWallet::fallbackFee;\n             if (feeCalc) feeCalc->reason = FeeReason::FALLBACK;\n+\n+            // directly return if fallback fee is disabled (feerate 0 == disabled)\n+            if (CWallet::fallbackFee == CFeeRate(0)) return feerate_needed;\n         }\n         // Obey mempool min fee when using smart fee estimation\n-        CAmount min_mempool_fee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nTxBytes);\n-        if (fee_needed < min_mempool_fee) {\n-            fee_needed = min_mempool_fee;\n+        CFeeRate min_mempool_feerate = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+        if (feerate_needed < min_mempool_feerate) {\n+            feerate_needed = min_mempool_feerate;\n             if (feeCalc) feeCalc->reason = FeeReason::MEMPOOL_MIN;\n         }\n     }\n \n     // prevent user from paying a fee below minRelayTxFee or minTxFee\n-    CAmount required_fee = GetRequiredFee(nTxBytes);\n-    if (required_fee > fee_needed) {\n-        fee_needed = required_fee;\n+    CFeeRate required_feerate = GetRequiredFeeRate();\n+    if (required_feerate > feerate_needed) {\n+        feerate_needed = required_feerate;\n         if (feeCalc) feeCalc->reason = FeeReason::REQUIRED;\n     }\n-    // But always obey the maximum\n-    if (fee_needed > maxTxFee) {\n-        fee_needed = maxTxFee;\n-        if (feeCalc) feeCalc->reason = FeeReason::MAXTXFEE;\n-    }\n-    return fee_needed;\n+    return feerate_needed;\n }\n \n-\n CFeeRate GetDiscardRate(const CBlockPolicyEstimator& estimator)\n {\n     unsigned int highest_target = estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);"
      },
      {
        "sha": "a627af70b0a69efeda80f61ee14b494da0b303ea",
        "filename": "src/wallet/fees.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -26,6 +26,18 @@ CAmount GetRequiredFee(unsigned int nTxBytes);\n  */\n CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc);\n \n+/**\n+ * Return the minimum required feerate taking into account the\n+ * floating relay feerate and user set minimum transaction feerate\n+ */\n+CFeeRate GetRequiredFeeRate();\n+\n+/**\n+ * Estimate the minimum fee rate considering user set parameters\n+ * and the required fee\n+ */\n+CFeeRate GetMinimumFeeRate(const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc);\n+\n /**\n  * Return the maximum feerate for discarding change.\n  */"
      },
      {
        "sha": "3d7bb674f03f7a71318bbaefe2ebfcb76b15797b",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 40,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -5,6 +5,7 @@\n \n #include <wallet/init.h>\n \n+#include <chainparams.h>\n #include <net.h>\n #include <util.h>\n #include <utilmoneystr.h>\n@@ -13,10 +14,10 @@\n #include <wallet/wallet.h>\n #include <wallet/walletutil.h>\n \n-std::string GetWalletHelpString(bool showDebug)\n+std::string WalletInit::GetHelpString(bool showDebug)\n {\n     std::string strUsage = HelpMessageGroup(_(\"Wallet options:\"));\n-    strUsage += HelpMessageOpt(\"-addresstype\", strprintf(\"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \\\"%s\\\")\", FormatOutputType(OUTPUT_TYPE_DEFAULT)));\n+    strUsage += HelpMessageOpt(\"-addresstype\", strprintf(\"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \\\"%s\\\")\", FormatOutputType(DEFAULT_ADDRESS_TYPE)));\n     strUsage += HelpMessageOpt(\"-changetype\", \"What type of change to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\"). Default is same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is used when sending to a native segwit address)\");\n     strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n     strUsage += HelpMessageOpt(\"-discardfee=<amt>\", strprintf(_(\"The fee rate (in %s/kB) that indicates your tolerance for discarding change by adding it to the fee (default: %s). \"\n@@ -34,7 +35,7 @@ std::string GetWalletHelpString(bool showDebug)\n     strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), DEFAULT_SPEND_ZEROCONF_CHANGE));\n     strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n     strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format on startup\"));\n-    strUsage += HelpMessageOpt(\"-wallet=<file>\", _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), DEFAULT_WALLET_DAT));\n+    strUsage += HelpMessageOpt(\"-wallet=<path>\", _(\"Specify wallet database path. Can be specified multiple times to load multiple wallets. Path is interpreted relative to <walletdir> if it is not absolute, and will be created if it does not exist (as a directory containing a wallet.dat file and log files). For backwards compatibility this will also accept names of existing data files in <walletdir>.)\"));\n     strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_WALLETBROADCAST));\n     strUsage += HelpMessageOpt(\"-walletdir=<dir>\", _(\"Specify directory to hold wallets (default: <datadir>/wallets if it exists, otherwise <datadir>)\"));\n     strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n@@ -55,7 +56,7 @@ std::string GetWalletHelpString(bool showDebug)\n     return strUsage;\n }\n \n-bool WalletParameterInteraction()\n+bool WalletInit::ParameterInteraction()\n {\n     if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n         for (const std::string& wallet : gArgs.GetArgs(\"-wallet\")) {\n@@ -65,7 +66,7 @@ bool WalletParameterInteraction()\n         return true;\n     }\n \n-    gArgs.SoftSetArg(\"-wallet\", DEFAULT_WALLET_DAT);\n+    gArgs.SoftSetArg(\"-wallet\", \"\");\n     const bool is_multiwallet = gArgs.GetArgs(\"-wallet\").size() > 1;\n \n     if (gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY) && gArgs.SoftSetBoolArg(\"-walletbroadcast\", false)) {\n@@ -123,6 +124,8 @@ bool WalletParameterInteraction()\n                         _(\"This is the minimum transaction fee you pay on every transaction.\"));\n         CWallet::minTxFee = CFeeRate(n);\n     }\n+\n+    g_wallet_allow_fallback_fee = Params().IsFallbackFeeEnabled();\n     if (gArgs.IsArgSet(\"-fallbackfee\"))\n     {\n         CAmount nFeePerK = 0;\n@@ -132,6 +135,7 @@ bool WalletParameterInteraction()\n             InitWarning(AmountHighWarn(\"-fallbackfee\") + \" \" +\n                         _(\"This is the transaction fee you may pay when fee estimates are not available.\"));\n         CWallet::fallbackFee = CFeeRate(nFeePerK);\n+        g_wallet_allow_fallback_fee = nFeePerK != 0; //disable fallback fee in case value was set to 0, enable if non-null value\n     }\n     if (gArgs.IsArgSet(\"-discardfee\"))\n     {\n@@ -177,22 +181,10 @@ bool WalletParameterInteraction()\n     bSpendZeroConfChange = gArgs.GetBoolArg(\"-spendzeroconfchange\", DEFAULT_SPEND_ZEROCONF_CHANGE);\n     fWalletRbf = gArgs.GetBoolArg(\"-walletrbf\", DEFAULT_WALLET_RBF);\n \n-    g_address_type = ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"));\n-    if (g_address_type == OUTPUT_TYPE_NONE) {\n-        return InitError(strprintf(\"Unknown address type '%s'\", gArgs.GetArg(\"-addresstype\", \"\")));\n-    }\n-\n-    // If changetype is set in config file or parameter, check that it's valid.\n-    // Default to OUTPUT_TYPE_NONE if not set.\n-    g_change_type = ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"), OUTPUT_TYPE_NONE);\n-    if (g_change_type == OUTPUT_TYPE_NONE && !gArgs.GetArg(\"-changetype\", \"\").empty()) {\n-        return InitError(strprintf(\"Unknown change type '%s'\", gArgs.GetArg(\"-changetype\", \"\")));\n-    }\n-\n     return true;\n }\n \n-void RegisterWalletRPC(CRPCTable &t)\n+void WalletInit::RegisterRPC(CRPCTable &t)\n {\n     if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n         return;\n@@ -201,7 +193,7 @@ void RegisterWalletRPC(CRPCTable &t)\n     RegisterWalletRPCCommands(t);\n }\n \n-bool VerifyWallets()\n+bool WalletInit::Verify()\n {\n     if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n         return true;\n@@ -226,40 +218,44 @@ bool VerifyWallets()\n     std::set<fs::path> wallet_paths;\n \n     for (const std::string& walletFile : gArgs.GetArgs(\"-wallet\")) {\n-        if (boost::filesystem::path(walletFile).filename() != walletFile) {\n-            return InitError(strprintf(_(\"Error loading wallet %s. -wallet parameter must only specify a filename (not a path).\"), walletFile));\n-        }\n-\n-        if (SanitizeString(walletFile, SAFE_CHARS_FILENAME) != walletFile) {\n-            return InitError(strprintf(_(\"Error loading wallet %s. Invalid characters in -wallet filename.\"), walletFile));\n-        }\n-\n+        // Do some checking on wallet path. It should be either a:\n+        //\n+        // 1. Path where a directory can be created.\n+        // 2. Path to an existing directory.\n+        // 3. Path to a symlink to a directory.\n+        // 4. For backwards compatibility, the name of a data file in -walletdir.\n         fs::path wallet_path = fs::absolute(walletFile, GetWalletDir());\n-\n-        if (fs::exists(wallet_path) && (!fs::is_regular_file(wallet_path) || fs::is_symlink(wallet_path))) {\n-            return InitError(strprintf(_(\"Error loading wallet %s. -wallet filename must be a regular file.\"), walletFile));\n+        fs::file_type path_type = fs::symlink_status(wallet_path).type();\n+        if (!(path_type == fs::file_not_found || path_type == fs::directory_file ||\n+              (path_type == fs::symlink_file && fs::is_directory(wallet_path)) ||\n+              (path_type == fs::regular_file && fs::path(walletFile).filename() == walletFile))) {\n+            return InitError(strprintf(\n+                _(\"Invalid -wallet path '%s'. -wallet path should point to a directory where wallet.dat and \"\n+                  \"database/log.?????????? files can be stored, a location where such a directory could be created, \"\n+                  \"or (for backwards compatibility) the name of an existing data file in -walletdir (%s)\"),\n+                walletFile, GetWalletDir()));\n         }\n \n         if (!wallet_paths.insert(wallet_path).second) {\n             return InitError(strprintf(_(\"Error loading wallet %s. Duplicate -wallet filename specified.\"), walletFile));\n         }\n \n         std::string strError;\n-        if (!CWalletDB::VerifyEnvironment(walletFile, GetWalletDir().string(), strError)) {\n+        if (!CWalletDB::VerifyEnvironment(wallet_path, strError)) {\n             return InitError(strError);\n         }\n \n         if (gArgs.GetBoolArg(\"-salvagewallet\", false)) {\n             // Recover readable keypairs:\n-            CWallet dummyWallet;\n+            CWallet dummyWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n             std::string backup_filename;\n-            if (!CWalletDB::Recover(walletFile, (void *)&dummyWallet, CWalletDB::RecoverKeysOnlyFilter, backup_filename)) {\n+            if (!CWalletDB::Recover(wallet_path, (void *)&dummyWallet, CWalletDB::RecoverKeysOnlyFilter, backup_filename)) {\n                 return false;\n             }\n         }\n \n         std::string strWarning;\n-        bool dbV = CWalletDB::VerifyDatabaseFile(walletFile, GetWalletDir().string(), strWarning, strError);\n+        bool dbV = CWalletDB::VerifyDatabaseFile(wallet_path, strWarning, strError);\n         if (!strWarning.empty()) {\n             InitWarning(strWarning);\n         }\n@@ -272,15 +268,15 @@ bool VerifyWallets()\n     return true;\n }\n \n-bool OpenWallets()\n+bool WalletInit::Open()\n {\n     if (gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n         LogPrintf(\"Wallet disabled!\\n\");\n         return true;\n     }\n \n     for (const std::string& walletFile : gArgs.GetArgs(\"-wallet\")) {\n-        CWallet * const pwallet = CWallet::CreateWalletFromFile(walletFile);\n+        CWallet * const pwallet = CWallet::CreateWalletFromFile(walletFile, fs::absolute(walletFile, GetWalletDir()));\n         if (!pwallet) {\n             return false;\n         }\n@@ -290,25 +286,29 @@ bool OpenWallets()\n     return true;\n }\n \n-void StartWallets(CScheduler& scheduler) {\n+void WalletInit::Start(CScheduler& scheduler)\n+{\n     for (CWalletRef pwallet : vpwallets) {\n         pwallet->postInitProcess(scheduler);\n     }\n }\n \n-void FlushWallets() {\n+void WalletInit::Flush()\n+{\n     for (CWalletRef pwallet : vpwallets) {\n         pwallet->Flush(false);\n     }\n }\n \n-void StopWallets() {\n+void WalletInit::Stop()\n+{\n     for (CWalletRef pwallet : vpwallets) {\n         pwallet->Flush(true);\n     }\n }\n \n-void CloseWallets() {\n+void WalletInit::Close()\n+{\n     for (CWalletRef pwallet : vpwallets) {\n         delete pwallet;\n     }"
      },
      {
        "sha": "f8be90d3e31b6c1f023b5c8b2553363141c04914",
        "filename": "src/wallet/init.h",
        "status": "modified",
        "additions": 25,
        "deletions": 20,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -6,38 +6,43 @@\n #ifndef BITCOIN_WALLET_INIT_H\n #define BITCOIN_WALLET_INIT_H\n \n+#include <walletinitinterface.h>\n #include <string>\n \n class CRPCTable;\n class CScheduler;\n \n-//! Return the wallets help message.\n-std::string GetWalletHelpString(bool showDebug);\n+class WalletInit : public WalletInitInterface {\n+public:\n \n-//! Wallets parameter interaction\n-bool WalletParameterInteraction();\n+    //! Return the wallets help message.\n+    std::string GetHelpString(bool showDebug) override;\n \n-//! Register wallet RPCs.\n-void RegisterWalletRPC(CRPCTable &tableRPC);\n+    //! Wallets parameter interaction\n+    bool ParameterInteraction() override;\n \n-//! Responsible for reading and validating the -wallet arguments and verifying the wallet database.\n-//  This function will perform salvage on the wallet if requested, as long as only one wallet is\n-//  being loaded (WalletParameterInteraction forbids -salvagewallet, -zapwallettxes or -upgradewallet with multiwallet).\n-bool VerifyWallets();\n+    //! Register wallet RPCs.\n+    void RegisterRPC(CRPCTable &tableRPC) override;\n \n-//! Load wallet databases.\n-bool OpenWallets();\n+    //! Responsible for reading and validating the -wallet arguments and verifying the wallet database.\n+    //  This function will perform salvage on the wallet if requested, as long as only one wallet is\n+    //  being loaded (WalletParameterInteraction forbids -salvagewallet, -zapwallettxes or -upgradewallet with multiwallet).\n+    bool Verify() override;\n \n-//! Complete startup of wallets.\n-void StartWallets(CScheduler& scheduler);\n+    //! Load wallet databases.\n+    bool Open() override;\n \n-//! Flush all wallets in preparation for shutdown.\n-void FlushWallets();\n+    //! Complete startup of wallets.\n+    void Start(CScheduler& scheduler) override;\n \n-//! Stop all wallets. Wallets will be flushed first.\n-void StopWallets();\n+    //! Flush all wallets in preparation for shutdown.\n+    void Flush() override;\n \n-//! Close all wallets.\n-void CloseWallets();\n+    //! Stop all wallets. Wallets will be flushed first.\n+    void Stop() override;\n+\n+    //! Close all wallets.\n+    void Close() override;\n+};\n \n #endif // BITCOIN_WALLET_INIT_H"
      },
      {
        "sha": "28b6153ce14b6e950bff1605eee4b63a035ff136",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 48,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <base58.h>\n #include <chain.h>\n+#include <key_io.h>\n #include <rpc/safemode.h>\n #include <rpc/server.h>\n #include <wallet/init.h>\n@@ -28,10 +28,6 @@\n #include <univalue.h>\n \n \n-std::string static EncodeDumpTime(int64_t nTime) {\n-    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n-}\n-\n int64_t static DecodeDumpTime(const std::string &str) {\n     static const boost::posix_time::ptime epoch = boost::posix_time::from_time_t(0);\n     static const std::locale loc(std::locale::classic(),\n@@ -87,7 +83,7 @@ bool GetWalletAddressesForKey(CWallet * const pwallet, const CKeyID &keyid, std:\n         }\n     }\n     if (!fLabelFound) {\n-        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), g_address_type));\n+        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), pwallet->m_default_address_type));\n     }\n     return fLabelFound;\n }\n@@ -147,13 +143,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet is currently rescanning. Abort existing rescan or wait.\");\n         }\n \n-        CBitcoinSecret vchSecret;\n-        bool fGood = vchSecret.SetString(strSecret);\n-\n-        if (!fGood) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-\n-        CKey key = vchSecret.GetKey();\n-        if (!key.IsValid()) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+        CKey key = DecodeSecret(strSecret);\n+        if (!key.IsValid()) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n \n         CPubKey pubkey = key.GetPubKey();\n         assert(key.VerifyPubKey(pubkey));\n@@ -279,7 +270,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n         );\n \n \n-    std::string strLabel = \"\";\n+    std::string strLabel;\n     if (!request.params[1].isNull())\n         strLabel = request.params[1].get_str();\n \n@@ -359,9 +350,10 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n         LOCK(cs_main);\n-\n-        if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n+        const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n+        if (!pindex || !chainActive.Contains(pindex)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n+        }\n \n         std::vector<uint256>::const_iterator it;\n         if ((it = std::find(vMatch.begin(), vMatch.end(), hashTx))==vMatch.end()) {\n@@ -414,7 +406,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n     vHash.push_back(hash);\n     std::vector<uint256> vHashOut;\n \n-    if (pwallet->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n+    if (pwallet->ZapSelectTx(vHash, vHashOut) != DBErrors::LOAD_OK) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Could not properly delete the transaction.\");\n     }\n \n@@ -452,7 +444,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n         );\n \n \n-    std::string strLabel = \"\";\n+    std::string strLabel;\n     if (!request.params[1].isNull())\n         strLabel = request.params[1].get_str();\n \n@@ -554,9 +546,8 @@ UniValue importwallet(const JSONRPCRequest& request)\n             boost::split(vstr, line, boost::is_any_of(\" \"));\n             if (vstr.size() < 2)\n                 continue;\n-            CBitcoinSecret vchSecret;\n-            if (vchSecret.SetString(vstr[0])) {\n-                CKey key = vchSecret.GetKey();\n+            CKey key = DecodeSecret(vstr[0]);\n+            if (key.IsValid()) {\n                 CPubKey pubkey = key.GetPubKey();\n                 assert(key.VerifyPubKey(pubkey));\n                 CKeyID keyid = pubkey.GetID();\n@@ -659,7 +650,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n     if (!pwallet->GetKey(keyid, vchSecret)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n     }\n-    return CBitcoinSecret(vchSecret).ToString();\n+    return EncodeSecret(vchSecret);\n }\n \n \n@@ -728,9 +719,9 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n     // produce output\n     file << strprintf(\"# Wallet dump created by Bitcoin %s\\n\", CLIENT_BUILD);\n-    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()));\n+    file << strprintf(\"# * Created on %s\\n\", FormatISO8601DateTime(GetTime()));\n     file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n-    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->GetBlockTime()));\n+    file << strprintf(\"#   mined on %s\\n\", FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()));\n     file << \"\\n\";\n \n     // add the base58check encoded extended master if the wallet uses HD\n@@ -742,20 +733,17 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n             CExtKey masterKey;\n             masterKey.SetMaster(key.begin(), key.size());\n \n-            CBitcoinExtKey b58extkey;\n-            b58extkey.SetKey(masterKey);\n-\n-            file << \"# extended private masterkey: \" << b58extkey.ToString() << \"\\n\\n\";\n+            file << \"# extended private masterkey: \" << EncodeExtKey(masterKey) << \"\\n\\n\";\n         }\n     }\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;\n-        std::string strTime = EncodeDumpTime(it->first);\n+        std::string strTime = FormatISO8601DateTime(it->first);\n         std::string strAddr;\n         std::string strLabel;\n         CKey key;\n         if (pwallet->GetKey(keyid, key)) {\n-            file << strprintf(\"%s %s \", CBitcoinSecret(key).ToString(), strTime);\n+            file << strprintf(\"%s %s \", EncodeSecret(key), strTime);\n             if (GetWalletAddressesForKey(pwallet, keyid, strAddr, strLabel)) {\n                file << strprintf(\"label=%s\", strLabel);\n             } else if (keyid == masterKeyID) {\n@@ -778,7 +766,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n         // get birth times for scripts with metadata\n         auto it = pwallet->m_script_metadata.find(scriptid);\n         if (it != pwallet->m_script_metadata.end()) {\n-            create_time = EncodeDumpTime(it->second.nCreateTime);\n+            create_time = FormatISO8601DateTime(it->second.nCreateTime);\n         }\n         if(pwallet->GetCScript(scriptid, script)) {\n             file << strprintf(\"%s %s script=1\", HexStr(script.begin(), script.end()), create_time);\n@@ -911,17 +899,10 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 for (size_t i = 0; i < keys.size(); i++) {\n                     const std::string& privkey = keys[i].get_str();\n \n-                    CBitcoinSecret vchSecret;\n-                    bool fGood = vchSecret.SetString(privkey);\n-\n-                    if (!fGood) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CKey key = vchSecret.GetKey();\n+                    CKey key = DecodeSecret(privkey);\n \n                     if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n                     }\n \n                     CPubKey pubkey = key.GetPubKey();\n@@ -1018,16 +999,10 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n                 const std::string& strPrivkey = keys[0].get_str();\n \n                 // Checks.\n-                CBitcoinSecret vchSecret;\n-                bool fGood = vchSecret.SetString(strPrivkey);\n+                CKey key = DecodeSecret(strPrivkey);\n \n-                if (!fGood) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n-\n-                CKey key = vchSecret.GetKey();\n                 if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n                 }\n \n                 CPubKey pubKey = key.GetPubKey();"
      },
      {
        "sha": "c34b166a41c31c3a175c0d51cc004882dd96f24a",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 183,
        "deletions": 155,
        "changes": 338,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -4,12 +4,12 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <amount.h>\n-#include <base58.h>\n #include <chain.h>\n #include <consensus/validation.h>\n #include <core_io.h>\n #include <httpserver.h>\n #include <validation.h>\n+#include <key_io.h>\n #include <net.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n@@ -95,7 +95,7 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     {\n         entry.pushKV(\"blockhash\", wtx.hashBlock.GetHex());\n         entry.pushKV(\"blockindex\", wtx.nIndex);\n-        entry.pushKV(\"blocktime\", mapBlockIndex[wtx.hashBlock]->GetBlockTime());\n+        entry.pushKV(\"blocktime\", LookupBlockIndex(wtx.hashBlock)->GetBlockTime());\n     } else {\n         entry.pushKV(\"trusted\", wtx.IsTrusted());\n     }\n@@ -113,9 +113,9 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     if (confirms <= 0) {\n         LOCK(mempool.cs);\n         RBFTransactionState rbfState = IsRBFOptIn(*wtx.tx, mempool);\n-        if (rbfState == RBF_TRANSACTIONSTATE_UNKNOWN)\n+        if (rbfState == RBFTransactionState::UNKNOWN)\n             rbfStatus = \"unknown\";\n-        else if (rbfState == RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125)\n+        else if (rbfState == RBFTransactionState::REPLACEABLE_BIP125)\n             rbfStatus = \"yes\";\n     }\n     entry.pushKV(\"bip125-replaceable\", rbfStatus);\n@@ -124,12 +124,12 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n         entry.pushKV(item.first, item.second);\n }\n \n-std::string AccountFromValue(const UniValue& value)\n+std::string LabelFromValue(const UniValue& value)\n {\n-    std::string strAccount = value.get_str();\n-    if (strAccount == \"*\")\n-        throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid account name\");\n-    return strAccount;\n+    std::string label = value.get_str();\n+    if (label == \"*\")\n+        throw JSONRPCError(RPC_WALLET_INVALID_LABEL_NAME, \"Invalid label name\");\n+    return label;\n }\n \n UniValue getnewaddress(const JSONRPCRequest& request)\n@@ -141,12 +141,12 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getnewaddress ( \\\"account\\\" \\\"address_type\\\" )\\n\"\n+            \"getnewaddress ( \\\"label\\\" \\\"address_type\\\" )\\n\"\n             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n-            \"If 'account' is specified (DEPRECATED), it is added to the address book \\n\"\n-            \"so payments received with the address will be credited to 'account'.\\n\"\n+            \"If 'label' is specified, it is added to the address book \\n\"\n+            \"so payments received with the address will be associated with 'label'.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"        (string, optional) DEPRECATED. The account name for the address to be linked to. If not provided, the default account \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.\\n\"\n+            \"1. \\\"label\\\"          (string, optional) The label name for the address to be linked to. If not provided, the default label \\\"\\\" is used. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created if there is no label by the given name.\\n\"\n             \"2. \\\"address_type\\\"   (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -addresstype.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"address\\\"    (string) The new bitcoin address\\n\"\n@@ -157,15 +157,15 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    // Parse the account first so we don't generate a key if there's an error\n-    std::string strAccount;\n+    // Parse the label first so we don't generate a key if there's an error\n+    std::string label;\n     if (!request.params[0].isNull())\n-        strAccount = AccountFromValue(request.params[0]);\n+        label = LabelFromValue(request.params[0]);\n \n-    OutputType output_type = g_address_type;\n+    OutputType output_type = pwallet->m_default_address_type;\n     if (!request.params[1].isNull()) {\n-        output_type = ParseOutputType(request.params[1].get_str(), g_address_type);\n-        if (output_type == OUTPUT_TYPE_NONE) {\n+        output_type = ParseOutputType(request.params[1].get_str(), pwallet->m_default_address_type);\n+        if (output_type == OutputType::NONE) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[1].get_str()));\n         }\n     }\n@@ -182,23 +182,23 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n     pwallet->LearnRelatedScripts(newKey, output_type);\n     CTxDestination dest = GetDestinationForKey(newKey, output_type);\n \n-    pwallet->SetAddressBook(dest, strAccount, \"receive\");\n+    pwallet->SetAddressBook(dest, label, \"receive\");\n \n     return EncodeDestination(dest);\n }\n \n \n-CTxDestination GetAccountDestination(CWallet* const pwallet, std::string strAccount, bool bForceNew=false)\n+CTxDestination GetLabelDestination(CWallet* const pwallet, const std::string& label, bool bForceNew=false)\n {\n     CTxDestination dest;\n-    if (!pwallet->GetAccountDestination(dest, strAccount, bForceNew)) {\n+    if (!pwallet->GetLabelDestination(dest, label, bForceNew)) {\n         throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n     }\n \n     return dest;\n }\n \n-UniValue getaccountaddress(const JSONRPCRequest& request)\n+UniValue getlabeladdress(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -207,27 +207,27 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n-            \"getaccountaddress \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\\n\"\n+            \"getlabeladdress \\\"label\\\"\\n\"\n+            \"\\nReturns the current Bitcoin address for receiving payments to this label.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"       (string, required) The account name for the address. It can also be set to the empty string \\\"\\\" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.\\n\"\n+            \"1. \\\"label\\\"         (string, required) The label name for the address. It can also be set to the empty string \\\"\\\" to represent the default label. The label does not need to exist, it will be created and a new address created  if there is no label by the given name.\\n\"\n             \"\\nResult:\\n\"\n-            \"\\\"address\\\"          (string) The account bitcoin address\\n\"\n+            \"\\\"address\\\"          (string) The label bitcoin address\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaccountaddress\", \"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"\\\"\")\n-            + HelpExampleCli(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n-            + HelpExampleRpc(\"getaccountaddress\", \"\\\"myaccount\\\"\")\n+            + HelpExampleCli(\"getlabeladdress\", \"\")\n+            + HelpExampleCli(\"getlabeladdress\", \"\\\"\\\"\")\n+            + HelpExampleCli(\"getlabeladdress\", \"\\\"mylabel\\\"\")\n+            + HelpExampleRpc(\"getlabeladdress\", \"\\\"mylabel\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    // Parse the account first so we don't generate a key if there's an error\n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    // Parse the label first so we don't generate a key if there's an error\n+    std::string label = LabelFromValue(request.params[0]);\n \n     UniValue ret(UniValue::VSTR);\n \n-    ret = EncodeDestination(GetAccountDestination(pwallet, strAccount));\n+    ret = EncodeDestination(GetLabelDestination(pwallet, label));\n     return ret;\n }\n \n@@ -259,10 +259,10 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n         pwallet->TopUpKeyPool();\n     }\n \n-    OutputType output_type = g_change_type != OUTPUT_TYPE_NONE ? g_change_type : g_address_type;\n+    OutputType output_type = pwallet->m_default_change_type != OutputType::NONE ? pwallet->m_default_change_type : pwallet->m_default_address_type;\n     if (!request.params[0].isNull()) {\n         output_type = ParseOutputType(request.params[0].get_str(), output_type);\n-        if (output_type == OUTPUT_TYPE_NONE) {\n+        if (output_type == OutputType::NONE) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[0].get_str()));\n         }\n     }\n@@ -281,7 +281,7 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n }\n \n \n-UniValue setaccount(const JSONRPCRequest& request)\n+UniValue setlabel(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -290,14 +290,14 @@ UniValue setaccount(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"setaccount \\\"address\\\" \\\"account\\\"\\n\"\n-            \"\\nDEPRECATED. Sets the account associated with the given address.\\n\"\n+            \"setlabel \\\"address\\\" \\\"label\\\"\\n\"\n+            \"\\nSets the label associated with the given address.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address to be associated with an account.\\n\"\n-            \"2. \\\"account\\\"         (string, required) The account to assign the address to.\\n\"\n+            \"1. \\\"address\\\"         (string, required) The bitcoin address to be associated with a label.\\n\"\n+            \"2. \\\"label\\\"           (string, required) The label to assign the address to.\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"tabby\\\"\")\n-            + HelpExampleRpc(\"setaccount\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"tabby\\\"\")\n+            + HelpExampleCli(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"tabby\\\"\")\n+            + HelpExampleRpc(\"setlabel\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"tabby\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n@@ -307,23 +307,23 @@ UniValue setaccount(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n     }\n \n-    std::string strAccount;\n+    std::string label;\n     if (!request.params[1].isNull())\n-        strAccount = AccountFromValue(request.params[1]);\n+        label = LabelFromValue(request.params[1]);\n \n-    // Only add the account if the address is yours.\n+    // Only add the label if the address is yours.\n     if (IsMine(*pwallet, dest)) {\n-        // Detect when changing the account of an address that is the 'unused current key' of another account:\n+        // Detect when changing the label of an address that is the 'unused current key' of another label:\n         if (pwallet->mapAddressBook.count(dest)) {\n-            std::string strOldAccount = pwallet->mapAddressBook[dest].name;\n-            if (dest == GetAccountDestination(pwallet, strOldAccount)) {\n-                GetAccountDestination(pwallet, strOldAccount, true);\n+            std::string old_label = pwallet->mapAddressBook[dest].name;\n+            if (dest == GetLabelDestination(pwallet, old_label)) {\n+                GetLabelDestination(pwallet, old_label, true);\n             }\n         }\n-        pwallet->SetAddressBook(dest, strAccount, \"receive\");\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n     }\n     else\n-        throw JSONRPCError(RPC_MISC_ERROR, \"setaccount can only be used with own address\");\n+        throw JSONRPCError(RPC_MISC_ERROR, \"setlabel can only be used with own address\");\n \n     return NullUniValue;\n }\n@@ -390,7 +390,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = LabelFromValue(request.params[0]);\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n@@ -404,7 +404,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n     return ret;\n }\n \n-static void SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew, const CCoinControl& coin_control)\n+static CTransactionRef SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue, std::string fromAccount)\n {\n     CAmount curBalance = pwallet->GetBalance();\n \n@@ -430,16 +430,18 @@ static void SendMoney(CWallet * const pwallet, const CTxDestination &address, CA\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n-    if (!pwallet->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError, coin_control)) {\n+    CTransactionRef tx;\n+    if (!pwallet->CreateTransaction(vecSend, tx, reservekey, nFeeRequired, nChangePosRet, strError, coin_control)) {\n         if (!fSubtractFeeFromAmount && nValue + nFeeRequired > curBalance)\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s\", FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n     CValidationState state;\n-    if (!pwallet->CommitTransaction(wtxNew, reservekey, g_connman.get(), state)) {\n+    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, std::move(fromAccount), reservekey, g_connman.get(), state)) {\n         strError = strprintf(\"Error: The transaction was rejected! Reason given: %s\", FormatStateMessage(state));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n     }\n+    return tx;\n }\n \n UniValue sendtoaddress(const JSONRPCRequest& request)\n@@ -498,11 +500,11 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n \n     // Wallet comments\n-    CWalletTx wtx;\n+    mapValue_t mapValue;\n     if (!request.params[2].isNull() && !request.params[2].get_str().empty())\n-        wtx.mapValue[\"comment\"] = request.params[2].get_str();\n+        mapValue[\"comment\"] = request.params[2].get_str();\n     if (!request.params[3].isNull() && !request.params[3].get_str().empty())\n-        wtx.mapValue[\"to\"]      = request.params[3].get_str();\n+        mapValue[\"to\"] = request.params[3].get_str();\n \n     bool fSubtractFeeFromAmount = false;\n     if (!request.params[4].isNull()) {\n@@ -527,9 +529,8 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, wtx, coin_control);\n-\n-    return wtx.GetHash().GetHex();\n+    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue), {} /* fromAccount */);\n+    return tx->GetHash().GetHex();\n }\n \n UniValue listaddressgroupings(const JSONRPCRequest& request)\n@@ -551,7 +552,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n             \"    [\\n\"\n             \"      \\\"address\\\",            (string) The bitcoin address\\n\"\n             \"      amount,                 (numeric) The amount in \" + CURRENCY_UNIT + \"\\n\"\n-            \"      \\\"account\\\"             (string, optional) DEPRECATED. The account\\n\"\n+            \"      \\\"label\\\"               (string, optional) The label\\n\"\n             \"    ]\\n\"\n             \"    ,...\\n\"\n             \"  ]\\n\"\n@@ -719,7 +720,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n }\n \n \n-UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n+UniValue getreceivedbylabel(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -728,22 +729,22 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getreceivedbyaccount \\\"account\\\" ( minconf )\\n\"\n-            \"\\nDEPRECATED. Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\\n\"\n+            \"getreceivedbylabel \\\"label\\\" ( minconf )\\n\"\n+            \"\\nReturns the total amount received by addresses with <label> in transactions with at least [minconf] confirmations.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"account\\\"      (string, required) The selected account, may be the default account using \\\"\\\".\\n\"\n+            \"1. \\\"label\\\"        (string, required) The selected label, may be the default label using \\\"\\\".\\n\"\n             \"2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n             \"\\nResult:\\n\"\n-            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this account.\\n\"\n+            \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this label.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nAmount received by the default account with at least 1 confirmation\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"\\\"\") +\n-            \"\\nAmount received at the tabby account including unconfirmed amounts with zero confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 0\") +\n+            \"\\nAmount received by the default label with at least 1 confirmation\\n\"\n+            + HelpExampleCli(\"getreceivedbylabel\", \"\\\"\\\"\") +\n+            \"\\nAmount received at the tabby label including unconfirmed amounts with zero confirmations\\n\"\n+            + HelpExampleCli(\"getreceivedbylabel\", \"\\\"tabby\\\" 0\") +\n             \"\\nThe amount with at least 6 confirmations\\n\"\n-            + HelpExampleCli(\"getreceivedbyaccount\", \"\\\"tabby\\\" 6\") +\n+            + HelpExampleCli(\"getreceivedbylabel\", \"\\\"tabby\\\" 6\") +\n             \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"getreceivedbyaccount\", \"\\\"tabby\\\", 6\")\n+            + HelpExampleRpc(\"getreceivedbylabel\", \"\\\"tabby\\\", 6\")\n         );\n \n     ObserveSafeMode();\n@@ -759,9 +760,9 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n     if (!request.params[1].isNull())\n         nMinDepth = request.params[1].get_int();\n \n-    // Get the set of pub keys assigned to account\n-    std::string strAccount = AccountFromValue(request.params[0]);\n-    std::set<CTxDestination> setAddress = pwallet->GetAccountAddresses(strAccount);\n+    // Get the set of pub keys assigned to label\n+    std::string label = LabelFromValue(request.params[0]);\n+    std::set<CTxDestination> setAddress = pwallet->GetLabelAddresses(label);\n \n     // Tally\n     CAmount nAmount = 0;\n@@ -919,8 +920,8 @@ UniValue movecmd(const JSONRPCRequest& request)\n     ObserveSafeMode();\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strFrom = AccountFromValue(request.params[0]);\n-    std::string strTo = AccountFromValue(request.params[1]);\n+    std::string strFrom = LabelFromValue(request.params[0]);\n+    std::string strTo = LabelFromValue(request.params[1]);\n     CAmount nAmount = AmountFromValue(request.params[2]);\n     if (nAmount <= 0)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n@@ -983,7 +984,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = LabelFromValue(request.params[0]);\n     CTxDestination dest = DecodeDestination(request.params[1].get_str());\n     if (!IsValidDestination(dest)) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -995,12 +996,11 @@ UniValue sendfrom(const JSONRPCRequest& request)\n     if (!request.params[3].isNull())\n         nMinDepth = request.params[3].get_int();\n \n-    CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n+    mapValue_t mapValue;\n     if (!request.params[4].isNull() && !request.params[4].get_str().empty())\n-        wtx.mapValue[\"comment\"] = request.params[4].get_str();\n+        mapValue[\"comment\"] = request.params[4].get_str();\n     if (!request.params[5].isNull() && !request.params[5].get_str().empty())\n-        wtx.mapValue[\"to\"]      = request.params[5].get_str();\n+        mapValue[\"to\"] = request.params[5].get_str();\n \n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -1010,9 +1010,8 @@ UniValue sendfrom(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n     CCoinControl no_coin_control; // This is a deprecated API\n-    SendMoney(pwallet, dest, nAmount, false, wtx, no_coin_control);\n-\n-    return wtx.GetHash().GetHex();\n+    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, false, no_coin_control, std::move(mapValue), std::move(strAccount));\n+    return tx->GetHash().GetHex();\n }\n \n \n@@ -1077,16 +1076,15 @@ UniValue sendmany(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n \n-    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = LabelFromValue(request.params[0]);\n     UniValue sendTo = request.params[1].get_obj();\n     int nMinDepth = 1;\n     if (!request.params[2].isNull())\n         nMinDepth = request.params[2].get_int();\n \n-    CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n+    mapValue_t mapValue;\n     if (!request.params[3].isNull() && !request.params[3].get_str().empty())\n-        wtx.mapValue[\"comment\"] = request.params[3].get_str();\n+        mapValue[\"comment\"] = request.params[3].get_str();\n \n     UniValue subtractFeeFromAmount(UniValue::VARR);\n     if (!request.params[4].isNull())\n@@ -1147,21 +1145,25 @@ UniValue sendmany(const JSONRPCRequest& request)\n     if (totalAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n+    // Shuffle recipient list\n+    std::shuffle(vecSend.begin(), vecSend.end(), FastRandomContext());\n+\n     // Send\n     CReserveKey keyChange(pwallet);\n     CAmount nFeeRequired = 0;\n     int nChangePosRet = -1;\n     std::string strFailReason;\n-    bool fCreated = pwallet->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n+    CTransactionRef tx;\n+    bool fCreated = pwallet->CreateTransaction(vecSend, tx, keyChange, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n     CValidationState state;\n-    if (!pwallet->CommitTransaction(wtx, keyChange, g_connman.get(), state)) {\n+    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, std::move(strAccount), keyChange, g_connman.get(), state)) {\n         strFailReason = strprintf(\"Transaction commit failed:: %s\", FormatStateMessage(state));\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n \n-    return wtx.GetHash().GetHex();\n+    return tx->GetHash().GetHex();\n }\n \n UniValue addmultisigaddress(const JSONRPCRequest& request)\n@@ -1172,12 +1174,12 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n-        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" \\\"address_type\\\" )\\n\"\n+        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"label\\\" \\\"address_type\\\" )\\n\"\n             \"\\nAdd a nrequired-to-sign multisignature address to the wallet. Requires a new wallet backup.\\n\"\n             \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n             \"This functionality is only intended for use with non-watchonly addresses.\\n\"\n             \"See `importaddress` for watchonly p2sh address support.\\n\"\n-            \"If 'account' is specified (DEPRECATED), assign address to that account.\\n\"\n+            \"If 'label' is specified, assign address to that label.\\n\"\n \n             \"\\nArguments:\\n\"\n             \"1. nrequired                      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n@@ -1186,7 +1188,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n             \"       \\\"address\\\"                  (string) bitcoin address or hex-encoded public key\\n\"\n             \"       ...,\\n\"\n             \"     ]\\n\"\n-            \"3. \\\"account\\\"                      (string, optional) DEPRECATED. An account to assign the addresses to.\\n\"\n+            \"3. \\\"label\\\"                        (string, optional) A label to assign the addresses to.\\n\"\n             \"4. \\\"address_type\\\"                 (string, optional) The address type to use. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -addresstype.\\n\"\n \n             \"\\nResult:\\n\"\n@@ -1205,9 +1207,9 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    std::string strAccount;\n+    std::string label;\n     if (!request.params[2].isNull())\n-        strAccount = AccountFromValue(request.params[2]);\n+        label = LabelFromValue(request.params[2]);\n \n     int required = request.params[0].get_int();\n \n@@ -1222,10 +1224,10 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n         }\n     }\n \n-    OutputType output_type = g_address_type;\n+    OutputType output_type = pwallet->m_default_address_type;\n     if (!request.params[3].isNull()) {\n         output_type = ParseOutputType(request.params[3].get_str(), output_type);\n-        if (output_type == OUTPUT_TYPE_NONE) {\n+        if (output_type == OutputType::NONE) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown address type '%s'\", request.params[3].get_str()));\n         }\n     }\n@@ -1234,7 +1236,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     CScript inner = CreateMultisigRedeemscript(required, pubkeys);\n     pwallet->AddCScript(inner);\n     CTxDestination dest = pwallet->AddAndGetDestinationForScript(inner, output_type);\n-    pwallet->SetAddressBook(dest, strAccount, \"send\");\n+    pwallet->SetAddressBook(dest, label, \"send\");\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"address\", EncodeDestination(dest));\n@@ -1386,14 +1388,14 @@ struct tallyitem\n     }\n };\n \n-UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByAccounts)\n+UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool by_label)\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n     if (!params[0].isNull())\n         nMinDepth = params[0].get_int();\n \n-    // Whether to include empty accounts\n+    // Whether to include empty labels\n     bool fIncludeEmpty = false;\n     if (!params[1].isNull())\n         fIncludeEmpty = params[1].get_bool();\n@@ -1403,6 +1405,16 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n         if(params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n+    bool has_filtered_address = false;\n+    CTxDestination filtered_address = CNoDestination();\n+    if (!by_label && params.size() > 3) {\n+        if (!IsValidDestinationString(params[3].get_str())) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"address_filter parameter was invalid\");\n+        }\n+        filtered_address = DecodeDestination(params[3].get_str());\n+        has_filtered_address = true;\n+    }\n+\n     // Tally\n     std::map<CTxDestination, tallyitem> mapTally;\n     for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n@@ -1421,6 +1433,10 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             if (!ExtractDestination(txout.scriptPubKey, address))\n                 continue;\n \n+            if (has_filtered_address && !(filtered_address == address)) {\n+                continue;\n+            }\n+\n             isminefilter mine = IsMine(*pwallet, address);\n             if(!(mine & filter))\n                 continue;\n@@ -1436,11 +1452,25 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n     // Reply\n     UniValue ret(UniValue::VARR);\n-    std::map<std::string, tallyitem> mapAccountTally;\n-    for (const std::pair<CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {\n-        const CTxDestination& dest = item.first;\n-        const std::string& strAccount = item.second.name;\n-        std::map<CTxDestination, tallyitem>::iterator it = mapTally.find(dest);\n+    std::map<std::string, tallyitem> label_tally;\n+\n+    // Create mapAddressBook iterator\n+    // If we aren't filtering, go from begin() to end()\n+    auto start = pwallet->mapAddressBook.begin();\n+    auto end = pwallet->mapAddressBook.end();\n+    // If we are filtering, find() the applicable entry\n+    if (has_filtered_address) {\n+        start = pwallet->mapAddressBook.find(filtered_address);\n+        if (start != end) {\n+            end = std::next(start);\n+        }\n+    }\n+\n+    for (auto item_it = start; item_it != end; ++item_it)\n+    {\n+        const CTxDestination& address = item_it->first;\n+        const std::string& label = item_it->second.name;\n+        auto it = mapTally.find(address);\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n \n@@ -1454,9 +1484,9 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             fIsWatchonly = (*it).second.fIsWatchonly;\n         }\n \n-        if (fByAccounts)\n+        if (by_label)\n         {\n-            tallyitem& _item = mapAccountTally[strAccount];\n+            tallyitem& _item = label_tally[label];\n             _item.nAmount += nAmount;\n             _item.nConf = std::min(_item.nConf, nConf);\n             _item.fIsWatchonly = fIsWatchonly;\n@@ -1466,12 +1496,11 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             UniValue obj(UniValue::VOBJ);\n             if(fIsWatchonly)\n                 obj.pushKV(\"involvesWatchonly\", true);\n-            obj.pushKV(\"address\",       EncodeDestination(dest));\n-            obj.pushKV(\"account\",       strAccount);\n+            obj.pushKV(\"address\",       EncodeDestination(address));\n+            obj.pushKV(\"account\",       label);\n             obj.pushKV(\"amount\",        ValueFromAmount(nAmount));\n             obj.pushKV(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf));\n-            if (!fByAccounts)\n-                obj.pushKV(\"label\", strAccount);\n+            obj.pushKV(\"label\", label);\n             UniValue transactions(UniValue::VARR);\n             if (it != mapTally.end())\n             {\n@@ -1485,9 +1514,9 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n         }\n     }\n \n-    if (fByAccounts)\n+    if (by_label)\n     {\n-        for (const auto& entry : mapAccountTally)\n+        for (const auto& entry : label_tally)\n         {\n             CAmount nAmount = entry.second.nAmount;\n             int nConf = entry.second.nConf;\n@@ -1497,6 +1526,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             obj.pushKV(\"account\",       entry.first);\n             obj.pushKV(\"amount\",        ValueFromAmount(nAmount));\n             obj.pushKV(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf));\n+            obj.pushKV(\"label\",         entry.first);\n             ret.push_back(obj);\n         }\n     }\n@@ -1511,24 +1541,24 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() > 3)\n+    if (request.fHelp || request.params.size() > 4)\n         throw std::runtime_error(\n-            \"listreceivedbyaddress ( minconf include_empty include_watchonly)\\n\"\n+            \"listreceivedbyaddress ( minconf include_empty include_watchonly address_filter )\\n\"\n             \"\\nList balances by receiving address.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n             \"2. include_empty     (bool, optional, default=false) Whether to include addresses that haven't received any payments.\\n\"\n             \"3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').\\n\"\n-\n+            \"4. address_filter    (string, optional) If present, only return information on this address.\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"involvesWatchonly\\\" : true,        (bool) Only returned if imported addresses were involved in transaction\\n\"\n             \"    \\\"address\\\" : \\\"receivingaddress\\\",  (string) The receiving address\\n\"\n-            \"    \\\"account\\\" : \\\"accountname\\\",       (string) DEPRECATED. The account of the receiving address. The default account is \\\"\\\".\\n\"\n+            \"    \\\"account\\\" : \\\"accountname\\\",       (string) DEPRECATED. Backwards compatible alias for label.\\n\"\n             \"    \\\"amount\\\" : x.xxx,                  (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n             \"    \\\"confirmations\\\" : n,               (numeric) The number of confirmations of the most recent transaction included\\n\"\n-            \"    \\\"label\\\" : \\\"label\\\",               (string) A comment for the address/transaction, if any\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\",               (string) The label of the receiving address. The default label is \\\"\\\".\\n\"\n             \"    \\\"txids\\\": [\\n\"\n             \"       n,                                (numeric) The ids of transactions received with the address \\n\"\n             \"       ...\\n\"\n@@ -1541,6 +1571,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n             + HelpExampleCli(\"listreceivedbyaddress\", \"\")\n             + HelpExampleCli(\"listreceivedbyaddress\", \"6 true\")\n             + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true\")\n+            + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true, \\\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\\\"\")\n         );\n \n     ObserveSafeMode();\n@@ -1554,7 +1585,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n     return ListReceived(pwallet, request.params, false);\n }\n \n-UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n+UniValue listreceivedbylabel(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n     if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n@@ -1563,29 +1594,29 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() > 3)\n         throw std::runtime_error(\n-            \"listreceivedbyaccount ( minconf include_empty include_watchonly)\\n\"\n-            \"\\nDEPRECATED. List balances by account.\\n\"\n+            \"listreceivedbylabel ( minconf include_empty include_watchonly)\\n\"\n+            \"\\nList received transactions by label.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n-            \"2. include_empty     (bool, optional, default=false) Whether to include accounts that haven't received any payments.\\n\"\n+            \"2. include_empty     (bool, optional, default=false) Whether to include labels that haven't received any payments.\\n\"\n             \"3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').\\n\"\n \n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"involvesWatchonly\\\" : true,   (bool) Only returned if imported addresses were involved in transaction\\n\"\n-            \"    \\\"account\\\" : \\\"accountname\\\",  (string) The account name of the receiving account\\n\"\n-            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount received by addresses with this account\\n\"\n+            \"    \\\"account\\\" : \\\"accountname\\\",  (string) DEPRECATED. Backwards compatible alias for label.\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount received by addresses with this label\\n\"\n             \"    \\\"confirmations\\\" : n,          (numeric) The number of confirmations of the most recent transaction included\\n\"\n-            \"    \\\"label\\\" : \\\"label\\\"           (string) A comment for the address/transaction, if any\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\"           (string) The label of the receiving address. The default label is \\\"\\\".\\n\"\n             \"  }\\n\"\n             \"  ,...\\n\"\n             \"]\\n\"\n \n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"\")\n-            + HelpExampleCli(\"listreceivedbyaccount\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n+            + HelpExampleCli(\"listreceivedbylabel\", \"\")\n+            + HelpExampleCli(\"listreceivedbylabel\", \"6 true\")\n+            + HelpExampleRpc(\"listreceivedbylabel\", \"6, true, true\")\n         );\n \n     ObserveSafeMode();\n@@ -1987,7 +2018,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n             \"  ],\\n\"\n             \"  \\\"removed\\\": [\\n\"\n             \"    <structure is the same as \\\"transactions\\\" above, only present if include_removed=true>\\n\"\n-            \"    Note: transactions that were readded in the active chain will appear as-is in this array, and may thus have a positive confirmation count.\\n\"\n+            \"    Note: transactions that were re-added in the active chain will appear as-is in this array, and may thus have a positive confirmation count.\\n\"\n             \"  ],\\n\"\n             \"  \\\"lastblock\\\": \\\"lastblockhash\\\"     (string) The hash of the block (target_confirmations-1) from the best block on the main chain. This is typically used to feed back into listsinceblock the next time you call it. So you would generally use a target_confirmations of say 6, so you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones\\n\"\n             \"}\\n\"\n@@ -2014,11 +2045,10 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n         uint256 blockId;\n \n         blockId.SetHex(request.params[0].get_str());\n-        BlockMap::iterator it = mapBlockIndex.find(blockId);\n-        if (it == mapBlockIndex.end()) {\n+        paltindex = pindex = LookupBlockIndex(blockId);\n+        if (!pindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        paltindex = pindex = it->second;\n         if (chainActive[pindex->nHeight] != pindex) {\n             // the block being asked for is a part of a deactivated chain;\n             // we don't want to depend on its perceived height in the block\n@@ -2336,8 +2366,6 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    if (request.fHelp)\n-        return true;\n     if (!pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n     }\n@@ -2402,8 +2430,6 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    if (request.fHelp)\n-        return true;\n     if (!pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n     }\n@@ -2458,8 +2484,6 @@ UniValue walletlock(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    if (request.fHelp)\n-        return true;\n     if (!pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n     }\n@@ -2505,8 +2529,6 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    if (request.fHelp)\n-        return true;\n     if (pwallet->IsCrypted()) {\n         throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n     }\n@@ -2908,7 +2930,8 @@ UniValue listunspent(const JSONRPCRequest& request)\n             \"    \\\"txid\\\" : \\\"txid\\\",          (string) the transaction id \\n\"\n             \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n             \"    \\\"address\\\" : \\\"address\\\",    (string) the bitcoin address\\n\"\n-            \"    \\\"account\\\" : \\\"account\\\",    (string) DEPRECATED. The associated account, or \\\"\\\" for the default account\\n\"\n+            \"    \\\"label\\\" : \\\"label\\\",        (string) The associated label, or \\\"\\\" for the default label\\n\"\n+            \"    \\\"account\\\" : \\\"account\\\",    (string) DEPRECATED. Backwards compatible alias for label.\\n\"\n             \"    \\\"scriptPubKey\\\" : \\\"key\\\",   (string) the script key\\n\"\n             \"    \\\"amount\\\" : x.xxx,         (numeric) the transaction output amount in \" + CURRENCY_UNIT + \"\\n\"\n             \"    \\\"confirmations\\\" : n,      (numeric) The number of confirmations\\n\"\n@@ -3012,6 +3035,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n             entry.pushKV(\"address\", EncodeDestination(address));\n \n             if (pwallet->mapAddressBook.count(address)) {\n+                entry.pushKV(\"label\", pwallet->mapAddressBook[address].name);\n                 entry.pushKV(\"account\", pwallet->mapAddressBook[address].name);\n             }\n \n@@ -3156,8 +3180,8 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n             if (options.exists(\"changeAddress\")) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot specify both changeAddress and address_type options\");\n             }\n-            coinControl.change_type = ParseOutputType(options[\"change_type\"].get_str(), coinControl.change_type);\n-            if (coinControl.change_type == OUTPUT_TYPE_NONE) {\n+            coinControl.m_change_type = ParseOutputType(options[\"change_type\"].get_str(), pwallet->m_default_change_type);\n+            if (coinControl.m_change_type == OutputType::NONE) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Unknown change type '%s'\", options[\"change_type\"].get_str()));\n             }\n         }\n@@ -3551,7 +3575,7 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid stop_height\");\n             }\n             else if (pindexStop->nHeight < pindexStart->nHeight) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"stop_height must be greater then start_height\");\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"stop_height must be greater than start_height\");\n             }\n         }\n     }\n@@ -3807,21 +3831,23 @@ static const CRPCCommand commands[] =\n     { \"hidden\",             \"resendwallettransactions\",         &resendwallettransactions,      {} },\n     { \"wallet\",             \"abandontransaction\",               &abandontransaction,            {\"txid\"} },\n     { \"wallet\",             \"abortrescan\",                      &abortrescan,                   {} },\n-    { \"wallet\",             \"addmultisigaddress\",               &addmultisigaddress,            {\"nrequired\",\"keys\",\"account\",\"address_type\"} },\n+    { \"wallet\",             \"addmultisigaddress\",               &addmultisigaddress,            {\"nrequired\",\"keys\",\"label|account\",\"address_type\"} },\n     { \"hidden\",             \"addwitnessaddress\",                &addwitnessaddress,             {\"address\",\"p2sh\"} },\n     { \"wallet\",             \"backupwallet\",                     &backupwallet,                  {\"destination\"} },\n     { \"wallet\",             \"bumpfee\",                          &bumpfee,                       {\"txid\", \"options\"} },\n     { \"wallet\",             \"dumpprivkey\",                      &dumpprivkey,                   {\"address\"}  },\n     { \"wallet\",             \"dumpwallet\",                       &dumpwallet,                    {\"filename\"} },\n     { \"wallet\",             \"encryptwallet\",                    &encryptwallet,                 {\"passphrase\"} },\n-    { \"wallet\",             \"getaccountaddress\",                &getaccountaddress,             {\"account\"} },\n+    { \"wallet\",             \"getlabeladdress\",                  &getlabeladdress,               {\"label\"} },\n+    { \"wallet\",             \"getaccountaddress\",                &getlabeladdress,               {\"account\"} },\n     { \"wallet\",             \"getaccount\",                       &getaccount,                    {\"address\"} },\n     { \"wallet\",             \"getaddressesbyaccount\",            &getaddressesbyaccount,         {\"account\"} },\n     { \"wallet\",             \"getaddressinfo\",                   &getaddressinfo,                {\"address\"} },\n     { \"wallet\",             \"getbalance\",                       &getbalance,                    {\"account\",\"minconf\",\"include_watchonly\"} },\n-    { \"wallet\",             \"getnewaddress\",                    &getnewaddress,                 {\"account\",\"address_type\"} },\n+    { \"wallet\",             \"getnewaddress\",                    &getnewaddress,                 {\"label|account\",\"address_type\"} },\n     { \"wallet\",             \"getrawchangeaddress\",              &getrawchangeaddress,           {\"address_type\"} },\n-    { \"wallet\",             \"getreceivedbyaccount\",             &getreceivedbyaccount,          {\"account\",\"minconf\"} },\n+    { \"wallet\",             \"getreceivedbylabel\",               &getreceivedbylabel,            {\"label\",\"minconf\"} },\n+    { \"wallet\",             \"getreceivedbyaccount\",             &getreceivedbylabel,            {\"account\",\"minconf\"} },\n     { \"wallet\",             \"getreceivedbyaddress\",             &getreceivedbyaddress,          {\"address\",\"minconf\"} },\n     { \"wallet\",             \"gettransaction\",                   &gettransaction,                {\"txid\",\"include_watchonly\"} },\n     { \"wallet\",             \"getunconfirmedbalance\",            &getunconfirmedbalance,         {} },\n@@ -3836,8 +3862,9 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listaccounts\",                     &listaccounts,                  {\"minconf\",\"include_watchonly\"} },\n     { \"wallet\",             \"listaddressgroupings\",             &listaddressgroupings,          {} },\n     { \"wallet\",             \"listlockunspent\",                  &listlockunspent,               {} },\n-    { \"wallet\",             \"listreceivedbyaccount\",            &listreceivedbyaccount,         {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n-    { \"wallet\",             \"listreceivedbyaddress\",            &listreceivedbyaddress,         {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listreceivedbylabel\",              &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listreceivedbyaccount\",            &listreceivedbylabel,           {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n+    { \"wallet\",             \"listreceivedbyaddress\",            &listreceivedbyaddress,         {\"minconf\",\"include_empty\",\"include_watchonly\",\"address_filter\"} },\n     { \"wallet\",             \"listsinceblock\",                   &listsinceblock,                {\"blockhash\",\"target_confirmations\",\"include_watchonly\",\"include_removed\"} },\n     { \"wallet\",             \"listtransactions\",                 &listtransactions,              {\"account\",\"count\",\"skip\",\"include_watchonly\"} },\n     { \"wallet\",             \"listunspent\",                      &listunspent,                   {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\",\"query_options\"} },\n@@ -3847,7 +3874,8 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"sendfrom\",                         &sendfrom,                      {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },\n     { \"wallet\",             \"sendmany\",                         &sendmany,                      {\"fromaccount\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n     { \"wallet\",             \"sendtoaddress\",                    &sendtoaddress,                 {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n-    { \"wallet\",             \"setaccount\",                       &setaccount,                    {\"address\",\"account\"} },\n+    { \"wallet\",             \"setlabel\",                         &setlabel,                      {\"address\",\"label\"} },\n+    { \"wallet\",             \"setaccount\",                       &setlabel,                      {\"address\",\"account\"} },\n     { \"wallet\",             \"settxfee\",                         &settxfee,                      {\"amount\"} },\n     { \"wallet\",             \"signmessage\",                      &signmessage,                   {\"address\",\"message\"} },\n     { \"wallet\",             \"signrawtransactionwithwallet\",     &signrawtransactionwithwallet,  {\"hexstring\",\"prevtxs\",\"sighashtype\"} },"
      },
      {
        "sha": "cc6e491f5308944b8e221f5b2182b7d38a936aec",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -13,13 +13,13 @@\n BOOST_FIXTURE_TEST_SUITE(accounting_tests, WalletTestingSetup)\n \n static void\n-GetResults(CWallet *wallet, std::map<CAmount, CAccountingEntry>& results)\n+GetResults(CWallet& wallet, std::map<CAmount, CAccountingEntry>& results)\n {\n     std::list<CAccountingEntry> aes;\n \n     results.clear();\n-    BOOST_CHECK(wallet->ReorderTransactions() == DB_LOAD_OK);\n-    wallet->ListAccountCreditDebit(\"\", aes);\n+    BOOST_CHECK(wallet.ReorderTransactions() == DBErrors::LOAD_OK);\n+    wallet.ListAccountCreditDebit(\"\", aes);\n     for (CAccountingEntry& ae : aes)\n     {\n         results[ae.nOrderPos] = ae;\n@@ -29,32 +29,32 @@ GetResults(CWallet *wallet, std::map<CAmount, CAccountingEntry>& results)\n BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n {\n     std::vector<CWalletTx*> vpwtx;\n-    CWalletTx wtx;\n+    CWalletTx wtx(nullptr /* pwallet */, MakeTransactionRef());\n     CAccountingEntry ae;\n     std::map<CAmount, CAccountingEntry> results;\n \n-    LOCK(pwalletMain->cs_wallet);\n+    LOCK(m_wallet.cs_wallet);\n \n     ae.strAccount = \"\";\n     ae.nCreditDebit = 1;\n     ae.nTime = 1333333333;\n     ae.strOtherAccount = \"b\";\n     ae.strComment = \"\";\n-    pwalletMain->AddAccountingEntry(ae);\n+    m_wallet.AddAccountingEntry(ae);\n \n     wtx.mapValue[\"comment\"] = \"z\";\n-    pwalletMain->AddToWallet(wtx);\n-    vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n+    m_wallet.AddToWallet(wtx);\n+    vpwtx.push_back(&m_wallet.mapWallet.at(wtx.GetHash()));\n     vpwtx[0]->nTimeReceived = (unsigned int)1333333335;\n     vpwtx[0]->nOrderPos = -1;\n \n     ae.nTime = 1333333336;\n     ae.strOtherAccount = \"c\";\n-    pwalletMain->AddAccountingEntry(ae);\n+    m_wallet.AddAccountingEntry(ae);\n \n-    GetResults(pwalletMain.get(), results);\n+    GetResults(m_wallet, results);\n \n-    BOOST_CHECK(pwalletMain->nOrderPosNext == 3);\n+    BOOST_CHECK(m_wallet.nOrderPosNext == 3);\n     BOOST_CHECK(2 == results.size());\n     BOOST_CHECK(results[0].nTime == 1333333333);\n     BOOST_CHECK(results[0].strComment.empty());\n@@ -65,13 +65,13 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n \n     ae.nTime = 1333333330;\n     ae.strOtherAccount = \"d\";\n-    ae.nOrderPos = pwalletMain->IncOrderPosNext();\n-    pwalletMain->AddAccountingEntry(ae);\n+    ae.nOrderPos = m_wallet.IncOrderPosNext();\n+    m_wallet.AddAccountingEntry(ae);\n \n-    GetResults(pwalletMain.get(), results);\n+    GetResults(m_wallet, results);\n \n     BOOST_CHECK(results.size() == 3);\n-    BOOST_CHECK(pwalletMain->nOrderPosNext == 4);\n+    BOOST_CHECK(m_wallet.nOrderPosNext == 4);\n     BOOST_CHECK(results[0].nTime == 1333333333);\n     BOOST_CHECK(1 == vpwtx[0]->nOrderPos);\n     BOOST_CHECK(results[2].nTime == 1333333336);\n@@ -82,28 +82,28 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     wtx.mapValue[\"comment\"] = \"y\";\n     {\n         CMutableTransaction tx(*wtx.tx);\n-        --tx.nLockTime;  // Just to change the hash :)\n+        ++tx.nLockTime;  // Just to change the hash :)\n         wtx.SetTx(MakeTransactionRef(std::move(tx)));\n     }\n-    pwalletMain->AddToWallet(wtx);\n-    vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n+    m_wallet.AddToWallet(wtx);\n+    vpwtx.push_back(&m_wallet.mapWallet.at(wtx.GetHash()));\n     vpwtx[1]->nTimeReceived = (unsigned int)1333333336;\n \n     wtx.mapValue[\"comment\"] = \"x\";\n     {\n         CMutableTransaction tx(*wtx.tx);\n-        --tx.nLockTime;  // Just to change the hash :)\n+        ++tx.nLockTime;  // Just to change the hash :)\n         wtx.SetTx(MakeTransactionRef(std::move(tx)));\n     }\n-    pwalletMain->AddToWallet(wtx);\n-    vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n+    m_wallet.AddToWallet(wtx);\n+    vpwtx.push_back(&m_wallet.mapWallet.at(wtx.GetHash()));\n     vpwtx[2]->nTimeReceived = (unsigned int)1333333329;\n     vpwtx[2]->nOrderPos = -1;\n \n-    GetResults(pwalletMain.get(), results);\n+    GetResults(m_wallet, results);\n \n     BOOST_CHECK(results.size() == 3);\n-    BOOST_CHECK(pwalletMain->nOrderPosNext == 6);\n+    BOOST_CHECK(m_wallet.nOrderPosNext == 6);\n     BOOST_CHECK(0 == vpwtx[2]->nOrderPos);\n     BOOST_CHECK(results[1].nTime == 1333333333);\n     BOOST_CHECK(2 == vpwtx[0]->nOrderPos);\n@@ -116,12 +116,12 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n     ae.nTime = 1333333334;\n     ae.strOtherAccount = \"e\";\n     ae.nOrderPos = -1;\n-    pwalletMain->AddAccountingEntry(ae);\n+    m_wallet.AddAccountingEntry(ae);\n \n-    GetResults(pwalletMain.get(), results);\n+    GetResults(m_wallet, results);\n \n     BOOST_CHECK(results.size() == 4);\n-    BOOST_CHECK(pwalletMain->nOrderPosNext == 7);\n+    BOOST_CHECK(m_wallet.nOrderPosNext == 7);\n     BOOST_CHECK(0 == vpwtx[2]->nOrderPos);\n     BOOST_CHECK(results[1].nTime == 1333333333);\n     BOOST_CHECK(2 == vpwtx[0]->nOrderPos);"
      },
      {
        "sha": "6c36e2e965b5f384c3df19047dee89336798a88d",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "added",
        "additions": 575,
        "deletions": 0,
        "changes": 575,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,575 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet/wallet.h\"\n+#include \"wallet/coinselection.h\"\n+#include \"wallet/coincontrol.h\"\n+#include \"amount.h\"\n+#include \"primitives/transaction.h\"\n+#include \"random.h\"\n+#include \"test/test_bitcoin.h\"\n+#include \"wallet/test/wallet_test_fixture.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+#include <random>\n+\n+BOOST_FIXTURE_TEST_SUITE(coin_selection_tests, WalletTestingSetup)\n+\n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// some tests fail 1% of the time due to bad luck.\n+// we repeat those tests this many times and only complain if all iterations of the test fail\n+#define RANDOM_REPEATS 5\n+\n+std::vector<std::unique_ptr<CWalletTx>> wtxn;\n+\n+typedef std::set<CInputCoin> CoinSet;\n+\n+static std::vector<COutput> vCoins;\n+static CWallet testWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+static CAmount balance = 0;\n+\n+CoinEligibilityFilter filter_standard(1, 6, 0);\n+CoinEligibilityFilter filter_confirmed(1, 1, 0);\n+CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n+CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0);\n+\n+static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n+{\n+    CMutableTransaction tx;\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    set.emplace_back(MakeTransactionRef(tx), nInput);\n+}\n+\n+static void add_coin(const CAmount& nValue, int nInput, CoinSet& set)\n+{\n+    CMutableTransaction tx;\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    set.emplace(MakeTransactionRef(tx), nInput);\n+}\n+\n+static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    balance += nValue;\n+    static int nextLockTime = 0;\n+    CMutableTransaction tx;\n+    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    if (fIsFromMe) {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        tx.vin.resize(1);\n+    }\n+    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));\n+    if (fIsFromMe)\n+    {\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx.get(), nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n+    vCoins.push_back(output);\n+    testWallet.AddToWallet(*wtx.get());\n+    wtxn.emplace_back(std::move(wtx));\n+}\n+\n+static void empty_wallet(void)\n+{\n+    vCoins.clear();\n+    wtxn.clear();\n+    balance = 0;\n+}\n+\n+static bool equal_sets(CoinSet a, CoinSet b)\n+{\n+    std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    return ret.first == a.end() && ret.second == b.end();\n+}\n+\n+static CAmount make_hard_case(int utxos, std::vector<CInputCoin>& utxo_pool)\n+{\n+    utxo_pool.clear();\n+    CAmount target = 0;\n+    for (int i = 0; i < utxos; ++i) {\n+        target += (CAmount)1 << (utxos+i);\n+        add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n+        add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n+    }\n+    return target;\n+}\n+\n+// Branch and bound coin selection tests\n+BOOST_AUTO_TEST_CASE(bnb_search_test)\n+{\n+\n+    LOCK(testWallet.cs_wallet);\n+\n+    // Setup\n+    std::vector<CInputCoin> utxo_pool;\n+    CoinSet selection;\n+    CoinSet actual_selection;\n+    CAmount value_ret = 0;\n+    CAmount not_input_fees = 0;\n+\n+    /////////////////////////\n+    // Known Outcome tests //\n+    /////////////////////////\n+    BOOST_TEST_MESSAGE(\"Testing known outcomes\");\n+\n+    // Empty utxo pool\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 1 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    selection.clear();\n+\n+    // Add utxos\n+    add_coin(1 * CENT, 1, utxo_pool);\n+    add_coin(2 * CENT, 2, utxo_pool);\n+    add_coin(3 * CENT, 3, utxo_pool);\n+    add_coin(4 * CENT, 4, utxo_pool);\n+\n+    // Select 1 Cent\n+    add_coin(1 * CENT, 1, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 1 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 2 Cent\n+    add_coin(2 * CENT, 2, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 2 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 5 Cent\n+    add_coin(3 * CENT, 3, actual_selection);\n+    add_coin(2 * CENT, 2, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 5 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 11 Cent, not possible\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 11 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 10 Cent\n+    add_coin(5 * CENT, 5, utxo_pool);\n+    add_coin(4 * CENT, 4, actual_selection);\n+    add_coin(3 * CENT, 3, actual_selection);\n+    add_coin(2 * CENT, 2, actual_selection);\n+    add_coin(1 * CENT, 1, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 10 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Negative effective value\n+    // Select 10 Cent but have 1 Cent not be possible because too small\n+    add_coin(5 * CENT, 5, actual_selection);\n+    add_coin(3 * CENT, 3, actual_selection);\n+    add_coin(2 * CENT, 2, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 10 * CENT, 5000, selection, value_ret, not_input_fees));\n+\n+    // Select 0.25 Cent, not possible\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 0.25 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Iteration exhaustion test\n+    CAmount target = make_hard_case(17, utxo_pool);\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees)); // Should exhaust\n+    target = make_hard_case(14, utxo_pool);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees)); // Should not exhaust\n+\n+    // Test same value early bailout optimization\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(2 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(2 * CENT, 7, utxo_pool);\n+    for (int i = 0; i < 50000; ++i) {\n+        add_coin(5 * CENT, 7, utxo_pool);\n+    }\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 30 * CENT, 5000, selection, value_ret, not_input_fees));\n+\n+    ////////////////////\n+    // Behavior tests //\n+    ////////////////////\n+    // Select 1 Cent with pool of only greater than 5 Cent\n+    utxo_pool.clear();\n+    for (int i = 5; i <= 20; ++i) {\n+        add_coin(i * CENT, i, utxo_pool);\n+    }\n+    // Run 100 times, to make sure it is never finding a solution\n+    for (int i = 0; i < 100; ++i) {\n+        BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 1 * CENT, 2 * CENT, selection, value_ret, not_input_fees));\n+    }\n+\n+    // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n+    CoinSelectionParams coin_selection_params_bnb(true, 0, 0, CFeeRate(3000), 0);\n+    CoinSet setCoinsRet;\n+    CAmount nValueRet;\n+    bool bnb_used;\n+    empty_wallet();\n+    add_coin(1);\n+    vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+\n+    // Make sure that we aren't using BnB when there are preset inputs\n+    empty_wallet();\n+    add_coin(5 * CENT);\n+    add_coin(3 * CENT);\n+    add_coin(2 * CENT);\n+    CCoinControl coin_control;\n+    coin_control.fAllowOtherInputs = true;\n+    coin_control.Select(COutPoint(vCoins.at(0).tx->GetHash(), vCoins.at(0).i));\n+    BOOST_CHECK(testWallet.SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb, bnb_used));\n+    BOOST_CHECK(!bnb_used);\n+    BOOST_CHECK(!coin_selection_params_bnb.use_bnb);\n+}\n+\n+BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n+{\n+    CoinSet setCoinsRet, setCoinsRet2;\n+    CAmount nValueRet;\n+    bool bnb_used;\n+\n+    LOCK(testWallet.cs_wallet);\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+\n+        // we can make 3 cents of new coins\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we should get 5+6\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n+\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 1 / 10);\n+        add_coin(MIN_CHANGE * 2 / 10);\n+        add_coin(MIN_CHANGE * 3 / 10);\n+        add_coin(MIN_CHANGE * 4 / 10);\n+        add_coin(MIN_CHANGE * 5 / 10);\n+\n+        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n+        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n+\n+        // but if we add a bigger coin, small change is avoided\n+        add_coin(1111*MIN_CHANGE);\n+\n+        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // if we add more small coins:\n+        add_coin(MIN_CHANGE * 6 / 10);\n+        add_coin(MIN_CHANGE * 7 / 10);\n+\n+        // and try again to make 1.0 * MIN_CHANGE\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int j = 0; j < 20; j++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n+\n+        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 5 / 10);\n+        add_coin(MIN_CHANGE * 6 / 10);\n+        add_coin(MIN_CHANGE * 7 / 10);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 4 / 10);\n+        add_coin(MIN_CHANGE * 6 / 10);\n+        add_coin(MIN_CHANGE * 8 / 10);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n+\n+        // test avoiding small change\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 5 / 100);\n+        add_coin(MIN_CHANGE * 1);\n+        add_coin(MIN_CHANGE * 100);\n+\n+        // trying to make 100.01 from these three coins\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // test with many inputs\n+        for (CAmount amt=1500; amt < COIN; amt*=10) {\n+             empty_wallet();\n+             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n+             for (uint16_t j = 0; j < 676; j++)\n+                 add_coin(amt);\n+             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+             if (amt - 2000 < MIN_CHANGE) {\n+                 // needs more than one input:\n+                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n+                 CAmount returnValue = amt * returnSize;\n+                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n+             } else {\n+                 // one input is sufficient:\n+                 BOOST_CHECK_EQUAL(nValueRet, amt);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+             }\n+        }\n+\n+        // test randomness\n+        {\n+            empty_wallet();\n+            for (int i2 = 0; i2 < 100; i2++)\n+                add_coin(COIN);\n+\n+            // picking 50 from 100 coins doesn't depend on the shuffle,\n+            // but does depend on randomness in the stochastic approximation code\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n+\n+            int fails = 0;\n+            for (int j = 0; j < RANDOM_REPEATS; j++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+\n+            // add 75 cents in small change.  not enough to make 90 cents,\n+            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n+            // one of which should be picked at random\n+            add_coin(5 * CENT);\n+            add_coin(10 * CENT);\n+            add_coin(15 * CENT);\n+            add_coin(20 * CENT);\n+            add_coin(25 * CENT);\n+\n+            fails = 0;\n+            for (int j = 0; j < RANDOM_REPEATS; j++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+        }\n+    }\n+    empty_wallet();\n+}\n+\n+BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n+{\n+    CoinSet setCoinsRet;\n+    CAmount nValueRet;\n+    bool bnb_used;\n+\n+    LOCK(testWallet.cs_wallet);\n+\n+    empty_wallet();\n+\n+    // Test vValue sort order\n+    for (int i = 0; i < 1000; i++)\n+        add_coin(1000 * COIN);\n+    add_coin(3 * COIN);\n+\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n+    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+    empty_wallet();\n+}\n+\n+// Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n+BOOST_AUTO_TEST_CASE(SelectCoins_test)\n+{\n+    // Random generator stuff\n+    std::default_random_engine generator;\n+    std::exponential_distribution<double> distribution (100);\n+    FastRandomContext rand;\n+\n+    // Output stuff\n+    CAmount out_value = 0;\n+    CoinSet out_set;\n+    CAmount target = 0;\n+    bool bnb_used;\n+\n+    // Run this test 100 times\n+    for (int i = 0; i < 100; ++i)\n+    {\n+        // Reset\n+        out_value = 0;\n+        target = 0;\n+        out_set.clear();\n+        empty_wallet();\n+\n+        // Make a wallet with 1000 exponentially distributed random inputs\n+        for (int j = 0; j < 1000; ++j)\n+        {\n+            add_coin((CAmount)(distribution(generator)*10000000));\n+        }\n+\n+        // Generate a random fee rate in the range of 100 - 400\n+        CFeeRate rate(rand.randrange(300) + 100);\n+\n+        // Generate a random target value between 1000 and wallet balance\n+        target = rand.randrange(balance - 1000) + 1000;\n+\n+        // Perform selection\n+        CoinSelectionParams coin_selection_params_knapsack(false, 34, 148, CFeeRate(0), 0);\n+        CoinSelectionParams coin_selection_params_bnb(true, 34, 148, CFeeRate(0), 0);\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_bnb, bnb_used) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_knapsack, bnb_used));\n+        BOOST_CHECK_GE(out_value, target);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "5c550742c8f840a76bea084333f9c40a160e8f89",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 13,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -6,27 +6,19 @@\n \n #include <rpc/server.h>\n #include <wallet/db.h>\n+#include <wallet/wallet.h>\n \n WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n-    TestingSetup(chainName)\n+    TestingSetup(chainName), m_wallet(\"mock\", CWalletDBWrapper::CreateMock())\n {\n-    bitdb.MakeMock();\n-\n     bool fFirstRun;\n-    g_address_type = OUTPUT_TYPE_DEFAULT;\n-    g_change_type = OUTPUT_TYPE_DEFAULT;\n-    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"));\n-    pwalletMain = MakeUnique<CWallet>(std::move(dbw));\n-    pwalletMain->LoadWallet(fFirstRun);\n-    RegisterValidationInterface(pwalletMain.get());\n+    m_wallet.LoadWallet(fFirstRun);\n+    RegisterValidationInterface(&m_wallet);\n \n     RegisterWalletRPCCommands(tableRPC);\n }\n \n WalletTestingSetup::~WalletTestingSetup()\n {\n-    UnregisterValidationInterface(pwalletMain.get());\n-\n-    bitdb.Flush(true);\n-    bitdb.Reset();\n+    UnregisterValidationInterface(&m_wallet);\n }"
      },
      {
        "sha": "663836a95525cd0a267fe2a64c0e2c1aa79e3211",
        "filename": "src/wallet/test/wallet_test_fixture.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/wallet_test_fixture.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/wallet_test_fixture.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -15,7 +15,7 @@ struct WalletTestingSetup: public TestingSetup {\n     explicit WalletTestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~WalletTestingSetup();\n \n-    std::unique_ptr<CWallet> pwalletMain;\n+    CWallet m_wallet;\n };\n \n #endif"
      },
      {
        "sha": "808f8b88385df87bbe7137697d196717367c051c",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 371,
        "changes": 398,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -23,345 +23,8 @@ extern UniValue importmulti(const JSONRPCRequest& request);\n extern UniValue dumpwallet(const JSONRPCRequest& request);\n extern UniValue importwallet(const JSONRPCRequest& request);\n \n-// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n-#define RUN_TESTS 100\n-\n-// some tests fail 1% of the time due to bad luck.\n-// we repeat those tests this many times and only complain if all iterations of the test fail\n-#define RANDOM_REPEATS 5\n-\n-std::vector<std::unique_ptr<CWalletTx>> wtxn;\n-\n-typedef std::set<CInputCoin> CoinSet;\n-\n BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletTestingSetup)\n \n-static const CWallet testWallet;\n-static std::vector<COutput> vCoins;\n-\n-static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n-{\n-    static int nextLockTime = 0;\n-    CMutableTransaction tx;\n-    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n-    tx.vout.resize(nInput+1);\n-    tx.vout[nInput].nValue = nValue;\n-    if (fIsFromMe) {\n-        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n-        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n-        tx.vin.resize(1);\n-    }\n-    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));\n-    if (fIsFromMe)\n-    {\n-        wtx->fDebitCached = true;\n-        wtx->nDebitCached = 1;\n-    }\n-    COutput output(wtx.get(), nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n-    vCoins.push_back(output);\n-    wtxn.emplace_back(std::move(wtx));\n-}\n-\n-static void empty_wallet(void)\n-{\n-    vCoins.clear();\n-    wtxn.clear();\n-}\n-\n-static bool equal_sets(CoinSet a, CoinSet b)\n-{\n-    std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n-    return ret.first == a.end() && ret.second == b.end();\n-}\n-\n-BOOST_AUTO_TEST_CASE(coin_selection_tests)\n-{\n-    CoinSet setCoinsRet, setCoinsRet2;\n-    CAmount nValueRet;\n-\n-    LOCK(testWallet.cs_wallet);\n-\n-    // test multiple times to allow for differences in the shuffle order\n-    for (int i = 0; i < RUN_TESTS; i++)\n-    {\n-        empty_wallet();\n-\n-        // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n-\n-        add_coin(1*CENT, 4);        // add a new 1 cent coin\n-\n-        // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n-\n-        // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n-\n-        add_coin(2*CENT);           // add a mature 2 cent coin\n-\n-        // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n-\n-        // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n-\n-        add_coin(5*CENT);           // add a mature 5 cent coin,\n-        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n-        add_coin(20*CENT);          // and a mature 20 cent coin\n-\n-        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n-\n-        // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n-        // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, 6, 6, 0, vCoins, setCoinsRet, nValueRet));\n-        // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n-        // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n-\n-        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n-\n-        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK(nValueRet == 8 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n-        empty_wallet();\n-\n-        add_coin( 6*CENT);\n-        add_coin( 7*CENT);\n-        add_coin( 8*CENT);\n-        add_coin(20*CENT);\n-        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n-\n-        // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-\n-        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n-\n-        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n-\n-        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n-\n-        // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // check that the smallest bigger coin is used\n-        add_coin( 1*COIN);\n-        add_coin( 2*COIN);\n-        add_coin( 3*COIN);\n-        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n-\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 1 / 10);\n-        add_coin(MIN_CHANGE * 2 / 10);\n-        add_coin(MIN_CHANGE * 3 / 10);\n-        add_coin(MIN_CHANGE * 4 / 10);\n-        add_coin(MIN_CHANGE * 5 / 10);\n-\n-        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n-        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n-\n-        // but if we add a bigger coin, small change is avoided\n-        add_coin(1111*MIN_CHANGE);\n-\n-        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n-\n-        // if we add more small coins:\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 7 / 10);\n-\n-        // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n-\n-        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n-        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n-        empty_wallet();\n-        for (int j = 0; j < 20; j++)\n-            add_coin(50000 * COIN);\n-\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n-\n-        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n-        // we need to try finding an exact subset anyway\n-\n-        // sometimes it will fail, and so we use the next biggest coin:\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 5 / 10);\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 7 / 10);\n-        add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 4 / 10);\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 8 / 10);\n-        add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n-\n-        // test avoiding small change\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 5 / 100);\n-        add_coin(MIN_CHANGE * 1);\n-        add_coin(MIN_CHANGE * 100);\n-\n-        // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // test with many inputs\n-        for (CAmount amt=1500; amt < COIN; amt*=10) {\n-             empty_wallet();\n-             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n-             for (uint16_t j = 0; j < 676; j++)\n-                 add_coin(amt);\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-             if (amt - 2000 < MIN_CHANGE) {\n-                 // needs more than one input:\n-                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n-                 CAmount returnValue = amt * returnSize;\n-                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n-                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n-             } else {\n-                 // one input is sufficient:\n-                 BOOST_CHECK_EQUAL(nValueRet, amt);\n-                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-             }\n-        }\n-\n-        // test randomness\n-        {\n-            empty_wallet();\n-            for (int i2 = 0; i2 < 100; i2++)\n-                add_coin(COIN);\n-\n-            // picking 50 from 100 coins doesn't depend on the shuffle,\n-            // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, 1, 6, 0, vCoins, setCoinsRet , nValueRet));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, 1, 6, 0, vCoins, setCoinsRet2, nValueRet));\n-            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n-\n-            int fails = 0;\n-            for (int j = 0; j < RANDOM_REPEATS; j++)\n-            {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, 1, 6, 0, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, 1, 6, 0, vCoins, setCoinsRet2, nValueRet));\n-                if (equal_sets(setCoinsRet, setCoinsRet2))\n-                    fails++;\n-            }\n-            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n-\n-            // add 75 cents in small change.  not enough to make 90 cents,\n-            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n-            // one of which should be picked at random\n-            add_coin(5 * CENT);\n-            add_coin(10 * CENT);\n-            add_coin(15 * CENT);\n-            add_coin(20 * CENT);\n-            add_coin(25 * CENT);\n-\n-            fails = 0;\n-            for (int j = 0; j < RANDOM_REPEATS; j++)\n-            {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, 1, 6, 0, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, 1, 6, 0, vCoins, setCoinsRet2, nValueRet));\n-                if (equal_sets(setCoinsRet, setCoinsRet2))\n-                    fails++;\n-            }\n-            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n-        }\n-    }\n-    empty_wallet();\n-}\n-\n-BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n-{\n-    CoinSet setCoinsRet;\n-    CAmount nValueRet;\n-\n-    LOCK(testWallet.cs_wallet);\n-\n-    empty_wallet();\n-\n-    // Test vValue sort order\n-    for (int i = 0; i < 1000; i++)\n-        add_coin(1000 * COIN);\n-    add_coin(3 * COIN);\n-\n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n-    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n-    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-    empty_wallet();\n-}\n-\n static void AddKey(CWallet& wallet, const CKey& key)\n {\n     LOCK(wallet.cs_wallet);\n@@ -382,7 +45,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // Verify ScanForWalletTransactions picks up transactions in both the old\n     // and new block files.\n     {\n-        CWallet wallet;\n+        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n@@ -397,7 +60,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // Verify ScanForWalletTransactions only picks transactions in the new block\n     // file.\n     {\n-        CWallet wallet;\n+        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n@@ -409,7 +72,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // before the missing block, and success for a key whose creation time is\n     // after.\n     {\n-        CWallet wallet;\n+        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n         vpwallets.insert(vpwallets.begin(), &wallet);\n         UniValue keys;\n         keys.setArray();\n@@ -451,9 +114,6 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n // than or equal to key birthday.\n BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n {\n-    g_address_type = OUTPUT_TYPE_DEFAULT;\n-    g_change_type = OUTPUT_TYPE_DEFAULT;\n-\n     // Create two blocks with same timestamp to verify that importwallet rescan\n     // will pick up both blocks, not just the first.\n     const int64_t BLOCK_TIME = chainActive.Tip()->GetBlockTimeMax() + 5;\n@@ -471,7 +131,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n \n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n-        CWallet wallet;\n+        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n         LOCK(wallet.cs_wallet);\n         wallet.mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n         wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n@@ -486,7 +146,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n     // were scanned, and no prior blocks were scanned.\n     {\n-        CWallet wallet;\n+        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n \n         JSONRPCRequest request;\n         request.params.setArray();\n@@ -516,7 +176,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n // debit functions.\n BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n-    CWallet wallet;\n+    CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n     CWalletTx wtx(&wallet, MakeTransactionRef(coinbaseTxns.back()));\n     LOCK2(cs_main, wallet.cs_wallet);\n     wtx.hashBlock = chainActive.Tip()->GetBlockHash();\n@@ -553,7 +213,10 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n     if (block) {\n         wtx.SetMerkleBranch(block, 0);\n     }\n-    wallet.AddToWallet(wtx);\n+    {\n+        LOCK(cs_main);\n+        wallet.AddToWallet(wtx);\n+    }\n     LOCK(wallet.cs_wallet);\n     return wallet.mapWallet.at(wtx.GetHash()).nTimeSmart;\n }\n@@ -562,27 +225,25 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n-    CWallet wallet;\n-\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(wallet, 1, 100, 120), 100);\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n \n     // Test that updating existing transaction does not change smart time.\n-    BOOST_CHECK_EQUAL(AddTx(wallet, 1, 200, 220), 100);\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 200, 220), 100);\n \n     // New transaction should use clock time if there's no block time.\n-    BOOST_CHECK_EQUAL(AddTx(wallet, 2, 300, 0), 300);\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, 300, 0), 300);\n \n     // New transaction should use block time if lower than clock time.\n-    BOOST_CHECK_EQUAL(AddTx(wallet, 3, 420, 400), 400);\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, 420, 400), 400);\n \n     // New transaction should use latest entry time if higher than\n     // min(block time, clock time).\n-    BOOST_CHECK_EQUAL(AddTx(wallet, 4, 500, 390), 400);\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, 500, 390), 400);\n \n     // If there are future entries, new transaction should use time of the\n     // newest entry that is no more than 300 seconds ahead of the clock time.\n-    BOOST_CHECK_EQUAL(AddTx(wallet, 5, 50, 600), 300);\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 5, 50, 600), 300);\n \n     // Reset mock time for other tests.\n     SetMockTime(0);\n@@ -591,12 +252,12 @@ BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n BOOST_AUTO_TEST_CASE(LoadReceiveRequests)\n {\n     CTxDestination dest = CKeyID();\n-    LOCK(pwalletMain->cs_wallet);\n-    pwalletMain->AddDestData(dest, \"misc\", \"val_misc\");\n-    pwalletMain->AddDestData(dest, \"rr0\", \"val_rr0\");\n-    pwalletMain->AddDestData(dest, \"rr1\", \"val_rr1\");\n+    LOCK(m_wallet.cs_wallet);\n+    m_wallet.AddDestData(dest, \"misc\", \"val_misc\");\n+    m_wallet.AddDestData(dest, \"rr0\", \"val_rr0\");\n+    m_wallet.AddDestData(dest, \"rr1\", \"val_rr1\");\n \n-    auto values = pwalletMain->GetDestValues(\"rr\");\n+    auto values = m_wallet.GetDestValues(\"rr\");\n     BOOST_CHECK_EQUAL(values.size(), 2);\n     BOOST_CHECK_EQUAL(values[0], \"val_rr0\");\n     BOOST_CHECK_EQUAL(values[1], \"val_rr1\");\n@@ -608,10 +269,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     ListCoinsTestingSetup()\n     {\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-        ::bitdb.MakeMock();\n-        g_address_type = OUTPUT_TYPE_DEFAULT;\n-        g_change_type = OUTPUT_TYPE_DEFAULT;\n-        wallet.reset(new CWallet(std::unique_ptr<CWalletDBWrapper>(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"))));\n+        wallet = MakeUnique<CWallet>(\"mock\", CWalletDBWrapper::CreateMock());\n         bool firstRun;\n         wallet->LoadWallet(firstRun);\n         AddKey(*wallet, coinbaseKey);\n@@ -623,29 +281,27 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     ~ListCoinsTestingSetup()\n     {\n         wallet.reset();\n-        ::bitdb.Flush(true);\n-        ::bitdb.Reset();\n     }\n \n     CWalletTx& AddTx(CRecipient recipient)\n     {\n-        CWalletTx wtx;\n+        CTransactionRef tx;\n         CReserveKey reservekey(wallet.get());\n         CAmount fee;\n         int changePos = -1;\n         std::string error;\n         CCoinControl dummy;\n-        BOOST_CHECK(wallet->CreateTransaction({recipient}, wtx, reservekey, fee, changePos, error, dummy));\n+        BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, reservekey, fee, changePos, error, dummy));\n         CValidationState state;\n-        BOOST_CHECK(wallet->CommitTransaction(wtx, reservekey, nullptr, state));\n+        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, {}, reservekey, nullptr, state));\n         CMutableTransaction blocktx;\n         {\n             LOCK(wallet->cs_wallet);\n-            blocktx = CMutableTransaction(*wallet->mapWallet.at(wtx.GetHash()).tx);\n+            blocktx = CMutableTransaction(*wallet->mapWallet.at(tx->GetHash()).tx);\n         }\n         CreateAndProcessBlock({CMutableTransaction(blocktx)}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n         LOCK(wallet->cs_wallet);\n-        auto it = wallet->mapWallet.find(wtx.GetHash());\n+        auto it = wallet->mapWallet.find(tx->GetHash());\n         BOOST_CHECK(it != wallet->mapWallet.end());\n         it->second.SetMerkleBranch(chainActive.Tip(), 1);\n         return it->second;"
      },
      {
        "sha": "c9843599d6d9b7653ebb9b7dd352d5ae77089a60",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 330,
        "deletions": 305,
        "changes": 635,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -5,15 +5,16 @@\n \n #include <wallet/wallet.h>\n \n-#include <base58.h>\n #include <checkpoints.h>\n #include <chain.h>\n #include <wallet/coincontrol.h>\n+#include <wallet/coinselection.h>\n #include <consensus/consensus.h>\n #include <consensus/validation.h>\n #include <fs.h>\n #include <wallet/init.h>\n #include <key.h>\n+#include <key_io.h>\n #include <keystore.h>\n #include <validation.h>\n #include <net.h>\n@@ -41,10 +42,8 @@ CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;\n bool bSpendZeroConfChange = DEFAULT_SPEND_ZEROCONF_CHANGE;\n bool fWalletRbf = DEFAULT_WALLET_RBF;\n-OutputType g_address_type = OUTPUT_TYPE_NONE;\n-OutputType g_change_type = OUTPUT_TYPE_NONE;\n+bool g_wallet_allow_fallback_fee = true; //<! will be defined via chainparams\n \n-const char * DEFAULT_WALLET_DAT = \"wallet.dat\";\n const uint32_t BIP32_HARDENED_KEY_LIMIT = 0x80000000;\n \n /**\n@@ -68,15 +67,6 @@ const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"00000000000000000000000000000000\n  * @{\n  */\n \n-struct CompareValueOnly\n-{\n-    bool operator()(const CInputCoin& t1,\n-                    const CInputCoin& t2) const\n-    {\n-        return t1.txout.nValue < t2.txout.nValue;\n-    }\n-};\n-\n std::string COutput::ToString() const\n {\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n@@ -531,7 +521,7 @@ void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> ran\n     int nMinOrderPos = std::numeric_limits<int>::max();\n     const CWalletTx* copyFrom = nullptr;\n     for (TxSpends::iterator it = range.first; it != range.second; ++it) {\n-        const CWalletTx* wtx = &mapWallet[it->second];\n+        const CWalletTx* wtx = &mapWallet.at(it->second);\n         if (wtx->nOrderPos < nMinOrderPos) {\n             nMinOrderPos = wtx->nOrderPos;;\n             copyFrom = wtx;\n@@ -544,7 +534,7 @@ void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> ran\n     for (TxSpends::iterator it = range.first; it != range.second; ++it)\n     {\n         const uint256& hash = it->second;\n-        CWalletTx* copyTo = &mapWallet[hash];\n+        CWalletTx* copyTo = &mapWallet.at(hash);\n         if (copyFrom == copyTo) continue;\n         assert(copyFrom && \"Oldest wallet transaction in range assumed to have been found.\");\n         if (!copyFrom->IsEquivalentTo(*copyTo)) continue;\n@@ -737,11 +727,11 @@ DBErrors CWallet::ReorderTransactions()\n             if (pwtx)\n             {\n                 if (!walletdb.WriteTx(*pwtx))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n             }\n             else\n                 if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n         }\n         else\n         {\n@@ -761,16 +751,16 @@ DBErrors CWallet::ReorderTransactions()\n             if (pwtx)\n             {\n                 if (!walletdb.WriteTx(*pwtx))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n             }\n             else\n                 if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n         }\n     }\n     walletdb.WriteOrderPosNext(nOrderPosNext);\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n@@ -819,19 +809,19 @@ bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmoun\n     return true;\n }\n \n-bool CWallet::GetAccountDestination(CTxDestination &dest, std::string strAccount, bool bForceNew)\n+bool CWallet::GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew)\n {\n     CWalletDB walletdb(*dbw);\n \n     CAccount account;\n-    walletdb.ReadAccount(strAccount, account);\n+    walletdb.ReadAccount(label, account);\n \n     if (!bForceNew) {\n         if (!account.vchPubKey.IsValid())\n             bForceNew = true;\n         else {\n             // Check if the current key has been used (TODO: check other addresses with the same key)\n-            CScript scriptPubKey = GetScriptForDestination(GetDestinationForKey(account.vchPubKey, g_address_type));\n+            CScript scriptPubKey = GetScriptForDestination(GetDestinationForKey(account.vchPubKey, m_default_address_type));\n             for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n                  it != mapWallet.end() && account.vchPubKey.IsValid();\n                  ++it)\n@@ -848,12 +838,12 @@ bool CWallet::GetAccountDestination(CTxDestination &dest, std::string strAccount\n         if (!GetKeyFromPool(account.vchPubKey, false))\n             return false;\n \n-        LearnRelatedScripts(account.vchPubKey, g_address_type);\n-        dest = GetDestinationForKey(account.vchPubKey, g_address_type);\n-        SetAddressBook(dest, strAccount, \"receive\");\n-        walletdb.WriteAccount(strAccount, account);\n+        LearnRelatedScripts(account.vchPubKey, m_default_address_type);\n+        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n+        SetAddressBook(dest, label, \"receive\");\n+        walletdb.WriteAccount(label, account);\n     } else {\n-        dest = GetDestinationForKey(account.vchPubKey, g_address_type);\n+        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n     }\n \n     return true;\n@@ -1147,11 +1137,9 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     LOCK2(cs_main, cs_wallet);\n \n     int conflictconfirms = 0;\n-    if (mapBlockIndex.count(hashBlock)) {\n-        CBlockIndex* pindex = mapBlockIndex[hashBlock];\n-        if (chainActive.Contains(pindex)) {\n-            conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n-        }\n+    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n+    if (pindex && chainActive.Contains(pindex)) {\n+        conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n     }\n     // If number of conflict confirms cannot be determined, this means\n     // that the block is still unknown or not yet part of the main chain,\n@@ -1279,7 +1267,7 @@ void CWallet::BlockUntilSyncedToCurrentChain() {\n         // chainActive.Tip()...\n         // We could also take cs_wallet here, and call m_last_block_processed\n         // protected by cs_wallet instead of cs_main, but as long as we need\n-        // cs_main here anyway, its easier to just call it cs_main-protected.\n+        // cs_main here anyway, it's easier to just call it cs_main-protected.\n         LOCK(cs_main);\n         const CBlockIndex* initialChainTip = chainActive.Tip();\n \n@@ -1543,6 +1531,79 @@ int CWalletTx::GetRequestCount() const\n     return nRequests;\n }\n \n+// Helper for producing a max-sized low-S signature (eg 72 bytes)\n+bool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout) const\n+{\n+    // Fill in dummy signatures for fee calculation.\n+    const CScript& scriptPubKey = txout.scriptPubKey;\n+    SignatureData sigdata;\n+\n+    if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n+    {\n+        return false;\n+    } else {\n+        UpdateInput(tx_in, sigdata);\n+    }\n+    return true;\n+}\n+\n+// Helper for producing a bunch of max-sized low-S signatures (eg 72 bytes)\n+bool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts) const\n+{\n+    // Fill in dummy signatures for fee calculation.\n+    int nIn = 0;\n+    for (const auto& txout : txouts)\n+    {\n+        if (!DummySignInput(txNew.vin[nIn], txout)) {\n+            return false;\n+        }\n+\n+        nIn++;\n+    }\n+    return true;\n+}\n+\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n+{\n+    std::vector<CTxOut> txouts;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array, and the ability to sign.\n+    for (auto& input : tx.vin) {\n+        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n+        if (mi == wallet->mapWallet.end()) {\n+            return -1;\n+        }\n+        assert(input.prevout.n < mi->second.tx->vout.size());\n+        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n+    }\n+    return CalculateMaximumSignedTxSize(tx, wallet, txouts);\n+}\n+\n+// txouts needs to be in the order of tx.vin\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts)\n+{\n+    CMutableTransaction txNew(tx);\n+    if (!wallet->DummySignTx(txNew, txouts)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet)\n+{\n+    CMutableTransaction txn;\n+    txn.vin.push_back(CTxIn(COutPoint()));\n+    if (!wallet->DummySignInput(txn.vin[0], txout)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionInputSize(txn.vin[0]);\n+}\n+\n void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n                            std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const\n {\n@@ -1668,20 +1729,15 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n             dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n             dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n         }\n+        double gvp = dProgressStart;\n         while (pindex && !fAbortRescan)\n         {\n             if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n-                double gvp = 0;\n-                {\n-                    LOCK(cs_main);\n-                    gvp = GuessVerificationProgress(chainParams.TxData(), pindex);\n-                }\n                 ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((gvp - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                LOCK(cs_main);\n-                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n+                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n             }\n \n             CBlock block;\n@@ -1705,6 +1761,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n             {\n                 LOCK(cs_main);\n                 pindex = chainActive.Next(pindex);\n+                gvp = GuessVerificationProgress(chainParams.TxData(), pindex);\n                 if (tip != chainActive.Tip()) {\n                     tip = chainActive.Tip();\n                     // in case the tip has changed, update progress max\n@@ -1713,7 +1770,7 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlock\n             }\n         }\n         if (pindex && fAbortRescan) {\n-            LogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, GuessVerificationProgress(chainParams.TxData(), pindex));\n+            LogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n         }\n         ShowProgress(_(\"Rescanning...\"), 100); // hide progress dialog in GUI\n     }\n@@ -2163,7 +2220,7 @@ CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, cons\n         for (const CTxOut& out : wtx.tx->vout) {\n             if (outgoing && IsChange(out)) {\n                 debit -= out.nValue;\n-            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetAccountName(out.scriptPubKey))) {\n+            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetLabelName(out.scriptPubKey))) {\n                 balance += out.nValue;\n             }\n         }\n@@ -2368,171 +2425,88 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n     return ptx->vout[n];\n }\n \n-static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n-                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n+bool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibility_filter) const\n {\n-    std::vector<char> vfIncluded;\n+    if (!output.fSpendable)\n+        return false;\n \n-    vfBest.assign(vValue.size(), true);\n-    nBest = nTotalLower;\n+    if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? eligibility_filter.conf_mine : eligibility_filter.conf_theirs))\n+        return false;\n \n-    FastRandomContext insecure_rand;\n+    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), eligibility_filter.max_ancestors))\n+        return false;\n \n-    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n-    {\n-        vfIncluded.assign(vValue.size(), false);\n-        CAmount nTotal = 0;\n-        bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n-            for (unsigned int i = 0; i < vValue.size(); i++)\n-            {\n-                //The solver here uses a randomized algorithm,\n-                //the randomness serves no real security purpose but is just\n-                //needed to prevent degenerate behavior and it is important\n-                //that the rng is fast. We do not use a constant random sequence,\n-                //because there may be some privacy improvement by making\n-                //the selection random.\n-                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])\n-                {\n-                    nTotal += vValue[i].txout.nValue;\n-                    vfIncluded[i] = true;\n-                    if (nTotal >= nTargetValue)\n-                    {\n-                        fReachedTarget = true;\n-                        if (nTotal < nBest)\n-                        {\n-                            nBest = nTotal;\n-                            vfBest = vfIncluded;\n-                        }\n-                        nTotal -= vValue[i].txout.nValue;\n-                        vfIncluded[i] = false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    return true;\n }\n \n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors, std::vector<COutput> vCoins,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const\n+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> vCoins,\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n-    // List of values less than target\n-    boost::optional<CInputCoin> coinLowestLarger;\n-    std::vector<CInputCoin> vValue;\n-    CAmount nTotalLower = 0;\n-\n-    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n-\n-    for (const COutput &output : vCoins)\n-    {\n-        if (!output.fSpendable)\n-            continue;\n-\n-        const CWalletTx *pcoin = output.tx;\n-\n-        if (output.nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? nConfMine : nConfTheirs))\n-            continue;\n-\n-        if (!mempool.TransactionWithinChainLimit(pcoin->GetHash(), nMaxAncestors))\n-            continue;\n-\n-        int i = output.i;\n+    std::vector<CInputCoin> utxo_pool;\n+    if (coin_selection_params.use_bnb) {\n \n-        CInputCoin coin = CInputCoin(pcoin, i);\n+        // Get long term estimate\n+        FeeCalculation feeCalc;\n+        CCoinControl temp;\n+        temp.m_confirm_target = 1008;\n+        CFeeRate long_term_feerate = GetMinimumFeeRate(temp, ::mempool, ::feeEstimator, &feeCalc);\n \n-        if (coin.txout.nValue == nTargetValue)\n-        {\n-            setCoinsRet.insert(coin);\n-            nValueRet += coin.txout.nValue;\n-            return true;\n-        }\n-        else if (coin.txout.nValue < nTargetValue + MIN_CHANGE)\n-        {\n-            vValue.push_back(coin);\n-            nTotalLower += coin.txout.nValue;\n-        }\n-        else if (!coinLowestLarger || coin.txout.nValue < coinLowestLarger->txout.nValue)\n-        {\n-            coinLowestLarger = coin;\n-        }\n-    }\n+        // Calculate cost of change\n+        CAmount cost_of_change = GetDiscardRate(::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n-    if (nTotalLower == nTargetValue)\n-    {\n-        for (const auto& input : vValue)\n+        // Filter by the min conf specs and add to utxo_pool and calculate effective value\n+        for (const COutput &output : vCoins)\n         {\n-            setCoinsRet.insert(input);\n-            nValueRet += input.txout.nValue;\n-        }\n-        return true;\n-    }\n-\n-    if (nTotalLower < nTargetValue)\n-    {\n-        if (!coinLowestLarger)\n-            return false;\n-        setCoinsRet.insert(coinLowestLarger.get());\n-        nValueRet += coinLowestLarger->txout.nValue;\n-        return true;\n-    }\n-\n-    // Solve subset sum by stochastic approximation\n-    std::sort(vValue.begin(), vValue.end(), CompareValueOnly());\n-    std::reverse(vValue.begin(), vValue.end());\n-    std::vector<char> vfBest;\n-    CAmount nBest;\n-\n-    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);\n-    if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE)\n-        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);\n+            if (!OutputEligibleForSpending(output, eligibility_filter))\n+                continue;\n \n-    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n-    //                                   or the next bigger coin is closer), return the bigger coin\n-    if (coinLowestLarger &&\n-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger->txout.nValue <= nBest))\n-    {\n-        setCoinsRet.insert(coinLowestLarger.get());\n-        nValueRet += coinLowestLarger->txout.nValue;\n-    }\n-    else {\n-        for (unsigned int i = 0; i < vValue.size(); i++)\n-            if (vfBest[i])\n-            {\n-                setCoinsRet.insert(vValue[i]);\n-                nValueRet += vValue[i].txout.nValue;\n+            CInputCoin coin(output.tx->tx, output.i);\n+            coin.effective_value = coin.txout.nValue - (output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes));\n+            // Only include outputs that are positive effective value (i.e. not dust)\n+            if (coin.effective_value > 0) {\n+                coin.fee = output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes);\n+                coin.long_term_fee = output.nInputBytes < 0 ? 0 : long_term_feerate.GetFee(output.nInputBytes);\n+                utxo_pool.push_back(coin);\n             }\n+        }\n+        // Calculate the fees for things that aren't inputs\n+        CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+        bnb_used = true;\n+        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+    } else {\n+        // Filter by the min conf specs and add to utxo_pool\n+        for (const COutput &output : vCoins)\n+        {\n+            if (!OutputEligibleForSpending(output, eligibility_filter))\n+                continue;\n \n-        if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n-            LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n-            for (unsigned int i = 0; i < vValue.size(); i++) {\n-                if (vfBest[i]) {\n-                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].txout.nValue));\n-                }\n-            }\n-            LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n+            CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n+            utxo_pool.push_back(coin);\n         }\n+        bnb_used = false;\n+        return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n     }\n-\n-    return true;\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n \n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n-    if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n+    if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n     {\n+        // We didn't use BnB here, so set it to false.\n+        bnb_used = false;\n+\n         for (const COutput& out : vCoins)\n         {\n             if (!out.fSpendable)\n                  continue;\n             nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(CInputCoin(out.tx, out.i));\n+            setCoinsRet.insert(CInputCoin(out.tx->tx, out.i));\n         }\n         return (nValueRet >= nTargetValue);\n     }\n@@ -2542,27 +2516,31 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     CAmount nValueFromPresetInputs = 0;\n \n     std::vector<COutPoint> vPresetInputs;\n-    if (coinControl)\n-        coinControl->ListSelected(vPresetInputs);\n+    coin_control.ListSelected(vPresetInputs);\n     for (const COutPoint& outpoint : vPresetInputs)\n     {\n+        // For now, don't use BnB if preset inputs are selected. TODO: Enable this later\n+        bnb_used = false;\n+        coin_selection_params.use_bnb = false;\n+\n         std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())\n         {\n             const CWalletTx* pcoin = &it->second;\n             // Clearly invalid input, fail\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n+            // Just to calculate the marginal byte size\n             nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n-            setPresetCoins.insert(CInputCoin(pcoin, outpoint.n));\n+            setPresetCoins.insert(CInputCoin(pcoin->tx, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n     // remove preset inputs from vCoins\n-    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n+    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n     {\n-        if (setPresetCoins.count(CInputCoin(it->tx, it->i)))\n+        if (setPresetCoins.count(CInputCoin(it->tx->tx, it->i)))\n             it = vCoins.erase(it);\n         else\n             ++it;\n@@ -2572,13 +2550,13 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, 0, vCoins, setCoinsRet, nValueRet) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, 0, vCoins, setCoinsRet, nValueRet) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, 2, vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::min((size_t)4, nMaxChainLength/3), vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength/2, vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength, vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::numeric_limits<uint64_t>::max(), vCoins, setCoinsRet, nValueRet));\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());\n@@ -2635,13 +2613,13 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n     LOCK2(cs_main, cs_wallet);\n \n     CReserveKey reservekey(this);\n-    CWalletTx wtx;\n-    if (!CreateTransaction(vecSend, wtx, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n+    CTransactionRef tx_new;\n+    if (!CreateTransaction(vecSend, tx_new, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n         return false;\n     }\n \n     if (nChangePosInOut != -1) {\n-        tx.vout.insert(tx.vout.begin() + nChangePosInOut, wtx.tx->vout[nChangePosInOut]);\n+        tx.vout.insert(tx.vout.begin() + nChangePosInOut, tx_new->vout[nChangePosInOut]);\n         // We don't have the normal Create/Commit cycle, and don't want to risk\n         // reusing change, so just remove the key from the keypool here.\n         reservekey.KeepKey();\n@@ -2650,11 +2628,11 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n     // Copy output sizes from new transaction; they may have had the fee\n     // subtracted from them.\n     for (unsigned int idx = 0; idx < tx.vout.size(); idx++) {\n-        tx.vout[idx].nValue = wtx.tx->vout[idx].nValue;\n+        tx.vout[idx].nValue = tx_new->vout[idx].nValue;\n     }\n \n     // Add new txins while keeping original txin scriptSig/order.\n-    for (const CTxIn& txin : wtx.tx->vin) {\n+    for (const CTxIn& txin : tx_new->vin) {\n         if (!coinControl.IsSelected(txin.prevout)) {\n             tx.vin.push_back(txin);\n \n@@ -2670,14 +2648,14 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n OutputType CWallet::TransactionChangeType(OutputType change_type, const std::vector<CRecipient>& vecSend)\n {\n     // If -changetype is specified, always use that change type.\n-    if (change_type != OUTPUT_TYPE_NONE) {\n+    if (change_type != OutputType::NONE) {\n         return change_type;\n     }\n \n-    // if g_address_type is legacy, use legacy address as change (even\n+    // if m_default_address_type is legacy, use legacy address as change (even\n     // if some of the outputs are P2WPKH or P2WSH).\n-    if (g_address_type == OUTPUT_TYPE_LEGACY) {\n-        return OUTPUT_TYPE_LEGACY;\n+    if (m_default_address_type == OutputType::LEGACY) {\n+        return OutputType::LEGACY;\n     }\n \n     // if any destination is P2WPKH or P2WSH, use P2WPKH for the change\n@@ -2687,15 +2665,15 @@ OutputType CWallet::TransactionChangeType(OutputType change_type, const std::vec\n         int witnessversion = 0;\n         std::vector<unsigned char> witnessprogram;\n         if (recipient.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n-            return OUTPUT_TYPE_BECH32;\n+            return OutputType::BECH32;\n         }\n     }\n \n-    // else use g_address_type for change\n-    return g_address_type;\n+    // else use m_default_address_type for change\n+    return m_default_address_type;\n }\n \n-bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n+bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n                                 int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n {\n     CAmount nValue = 0;\n@@ -2719,8 +2697,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n         return false;\n     }\n \n-    wtxNew.fTimeReceivedIsTxTime = true;\n-    wtxNew.BindWallet(this);\n     CMutableTransaction txNew;\n \n     // Discourage fee sniping.\n@@ -2756,13 +2732,14 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n     FeeCalculation feeCalc;\n     CAmount nFeeNeeded;\n-    unsigned int nBytes;\n+    int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n         LOCK2(cs_main, cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n             AvailableCoins(vAvailableCoins, true, &coin_control);\n+            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n \n             // Create change script that will be used if we need change\n             // TODO: pass in scriptChange instead of reservekey so\n@@ -2790,31 +2767,40 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     return false;\n                 }\n \n-                const OutputType change_type = TransactionChangeType(coin_control.change_type, vecSend);\n+                const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n \n                 LearnRelatedScripts(vchPubKey, change_type);\n                 scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));\n             }\n             CTxOut change_prototype_txout(0, scriptChange);\n-            size_t change_prototype_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n+            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n \n             CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n+\n+            // Get the fee rate to use effective values in coin selection\n+            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+\n             nFeeRet = 0;\n             bool pick_new_inputs = true;\n             CAmount nValueIn = 0;\n+\n+            // BnB selector is the only selector used when this is true.\n+            // That should only happen on the first pass through the loop.\n+            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n             // Start with no fee and loop until there is enough fee\n             while (true)\n             {\n                 nChangePosInOut = nChangePosRequest;\n                 txNew.vin.clear();\n                 txNew.vout.clear();\n-                wtxNew.fFromMe = true;\n                 bool fFirst = true;\n \n                 CAmount nValueToSelect = nValue;\n                 if (nSubtractFeeFromAmount == 0)\n                     nValueToSelect += nFeeRet;\n+\n                 // vouts to the payees\n+                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n                 for (const auto& recipient : vecSend)\n                 {\n                     CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n@@ -2830,6 +2816,8 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                             txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                         }\n                     }\n+                    // Include the fee cost for outputs. Note this is only used for BnB right now\n+                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n \n                     if (IsDust(txout, ::dustRelayFee))\n                     {\n@@ -2848,26 +2836,36 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 }\n \n                 // Choose coins to use\n+                bool bnb_used;\n                 if (pick_new_inputs) {\n                     nValueIn = 0;\n                     setCoins.clear();\n-                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, &coin_control))\n+                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+                    coin_selection_params.effective_fee = nFeeRateNeeded;\n+                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                     {\n-                        strFailReason = _(\"Insufficient funds\");\n-                        return false;\n+                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n+                        if (bnb_used) {\n+                            coin_selection_params.use_bnb = false;\n+                            continue;\n+                        }\n+                        else {\n+                            strFailReason = _(\"Insufficient funds\");\n+                            return false;\n+                        }\n                     }\n                 }\n \n                 const CAmount nChange = nValueIn - nValueToSelect;\n-\n                 if (nChange > 0)\n                 {\n                     // Fill a vout to ourself\n                     CTxOut newTxOut(nChange, scriptChange);\n \n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n-                    if (IsDust(newTxOut, discard_rate))\n+                    // The nChange when BnB is used is always going to go to fees.\n+                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n                     {\n                         nChangePosInOut = -1;\n                         nFeeRet += nChange;\n@@ -2892,36 +2890,24 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     nChangePosInOut = -1;\n                 }\n \n-                // Fill vin\n-                //\n-                // Note how the sequence number is set to non-maxint so that\n-                // the nLockTime set above actually works.\n+                // Dummy fill vin for maximum size estimation\n                 //\n-                // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-                // we use the highest possible value in that range (maxint-2)\n-                // to avoid conflicting with other possible uses of nSequence,\n-                // and in the spirit of \"smallest possible change from prior\n-                // behavior.\"\n-                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-                for (const auto& coin : setCoins)\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n-                                              nSequence));\n-\n-                // Fill in dummy signatures for fee calculation.\n-                if (!DummySignTx(txNew, setCoins)) {\n-                    strFailReason = _(\"Signing transaction failed\");\n-                    return false;\n+                for (const auto& coin : setCoins) {\n+                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n                 }\n \n-                nBytes = GetVirtualTransactionSize(txNew);\n-\n-                // Remove scriptSigs to eliminate the fee calculation dummy signatures\n-                for (auto& vin : txNew.vin) {\n-                    vin.scriptSig = CScript();\n-                    vin.scriptWitness.SetNull();\n+                nBytes = CalculateMaximumSignedTxSize(txNew, this);\n+                if (nBytes < 0) {\n+                    strFailReason = _(\"Signing transaction failed\");\n+                    return false;\n                 }\n \n                 nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+                if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {\n+                    // eventually allow a fallback fee\n+                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+                    return false;\n+                }\n \n                 // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n                 // because we must be at the maximum allowed fee.\n@@ -2943,7 +2929,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     // (because of reduced tx size) and so we should add a\n                     // change output. Only try this once.\n                     if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n-                        unsigned int tx_size_with_change = nBytes + change_prototype_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n+                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n                         CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n                         CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                         if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n@@ -2991,17 +2977,36 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n \n                 // Include more fee and try again.\n                 nFeeRet = nFeeNeeded;\n+                coin_selection_params.use_bnb = false;\n                 continue;\n             }\n         }\n \n         if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n \n+        // Shuffle selected coins and fill in final vin\n+        txNew.vin.clear();\n+        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+\n+        // Note how the sequence number is set to non-maxint so that\n+        // the nLockTime set above actually works.\n+        //\n+        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+        // we use the highest possible value in that range (maxint-2)\n+        // to avoid conflicting with other possible uses of nSequence,\n+        // and in the spirit of \"smallest possible change from prior\n+        // behavior.\"\n+        const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+        for (const auto& coin : selected_coins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+        }\n+\n         if (sign)\n         {\n             CTransaction txNewConst(txNew);\n             int nIn = 0;\n-            for (const auto& coin : setCoins)\n+            for (const auto& coin : selected_coins)\n             {\n                 const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                 SignatureData sigdata;\n@@ -3018,11 +3023,11 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n             }\n         }\n \n-        // Embed the constructed transaction data in wtxNew.\n-        wtxNew.SetTx(MakeTransactionRef(std::move(txNew)));\n+        // Return the constructed transaction data.\n+        tx = MakeTransactionRef(std::move(txNew));\n \n         // Limit size\n-        if (GetTransactionWeight(*wtxNew.tx) >= MAX_STANDARD_TX_WEIGHT)\n+        if (GetTransactionWeight(*tx) >= MAX_STANDARD_TX_WEIGHT)\n         {\n             strFailReason = _(\"Transaction too large\");\n             return false;\n@@ -3032,7 +3037,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n     if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n         // Lastly, ensure this tx will pass the mempool's chain limits\n         LockPoints lp;\n-        CTxMemPoolEntry entry(wtxNew.tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n@@ -3059,10 +3064,18 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n /**\n  * Call after CreateTransaction unless you want to abort\n  */\n-bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n+bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state)\n {\n     {\n         LOCK2(cs_main, cs_wallet);\n+\n+        CWalletTx wtxNew(this, std::move(tx));\n+        wtxNew.mapValue = std::move(mapValue);\n+        wtxNew.vOrderForm = std::move(orderForm);\n+        wtxNew.strFromAccount = std::move(fromAccount);\n+        wtxNew.fTimeReceivedIsTxTime = true;\n+        wtxNew.fFromMe = true;\n+\n         LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.tx->ToString());\n         {\n             // Take key pair from key pool so it won't be used again\n@@ -3075,7 +3088,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CCon\n             // Notify that old coins are spent\n             for (const CTxIn& txin : wtxNew.tx->vin)\n             {\n-                CWalletTx &coin = mapWallet[txin.prevout.hash];\n+                CWalletTx &coin = mapWallet.at(txin.prevout.hash);\n                 coin.BindWallet(this);\n                 NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n             }\n@@ -3086,7 +3099,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CCon\n \n         // Get the inserted-CWalletTx from mapWallet so that the\n         // fInMempool flag is cached properly\n-        CWalletTx& wtx = mapWallet[wtxNew.GetHash()];\n+        CWalletTx& wtx = mapWallet.at(wtxNew.GetHash());\n \n         if (fBroadcastTransactions)\n         {\n@@ -3133,7 +3146,7 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n     fFirstRunRet = false;\n     DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n-    if (nLoadWalletRet == DB_NEED_REWRITE)\n+    if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3149,12 +3162,12 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     // This wallet is in its first run if all of these are empty\n     fFirstRunRet = mapKeys.empty() && mapCryptedKeys.empty() && mapWatchKeys.empty() && setWatchOnly.empty() && mapScripts.empty();\n \n-    if (nLoadWalletRet != DB_LOAD_OK)\n+    if (nLoadWalletRet != DBErrors::LOAD_OK)\n         return nLoadWalletRet;\n \n     uiInterface.LoadWallet(this);\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n@@ -3164,7 +3177,7 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n     for (uint256 hash : vHashOut)\n         mapWallet.erase(hash);\n \n-    if (nZapSelectTxRet == DB_NEED_REWRITE)\n+    if (nZapSelectTxRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3177,19 +3190,19 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n         }\n     }\n \n-    if (nZapSelectTxRet != DB_LOAD_OK)\n+    if (nZapSelectTxRet != DBErrors::LOAD_OK)\n         return nZapSelectTxRet;\n \n     MarkDirty();\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n \n }\n \n DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n-    if (nZapWalletTxRet == DB_NEED_REWRITE)\n+    if (nZapWalletTxRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3203,10 +3216,10 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n         }\n     }\n \n-    if (nZapWalletTxRet != DB_LOAD_OK)\n+    if (nZapWalletTxRet != DBErrors::LOAD_OK)\n         return nZapWalletTxRet;\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n \n@@ -3248,7 +3261,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n     return CWalletDB(*dbw).EraseName(EncodeDestination(address));\n }\n \n-const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n+const std::string& CWallet::GetLabelName(const CScript& scriptPubKey) const\n {\n     CTxDestination address;\n     if (ExtractDestination(scriptPubKey, address) && !scriptPubKey.IsUnspendable()) {\n@@ -3258,9 +3271,9 @@ const std::string& CWallet::GetAccountName(const CScript& scriptPubKey) const\n         }\n     }\n     // A scriptPubKey that doesn't have an entry in the address book is\n-    // associated with the default account (\"\").\n-    const static std::string DEFAULT_ACCOUNT_NAME;\n-    return DEFAULT_ACCOUNT_NAME;\n+    // associated with the default label (\"\").\n+    const static std::string DEFAULT_LABEL_NAME;\n+    return DEFAULT_LABEL_NAME;\n }\n \n /**\n@@ -3542,7 +3555,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n                 CTxDestination address;\n                 if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n                     continue;\n-                if(!ExtractDestination(mapWallet[txin.prevout.hash].tx->vout[txin.prevout.n].scriptPubKey, address))\n+                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n                     continue;\n                 grouping.insert(address);\n                 any_mine = true;\n@@ -3616,15 +3629,15 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n     return ret;\n }\n \n-std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n+std::set<CTxDestination> CWallet::GetLabelAddresses(const std::string& label) const\n {\n     LOCK(cs_wallet);\n     std::set<CTxDestination> result;\n     for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n         const std::string& strName = item.second.name;\n-        if (strName == strAccount)\n+        if (strName == label)\n             result.insert(address);\n     }\n     return result;\n@@ -3766,18 +3779,18 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     for (const auto& entry : mapWallet) {\n         // iterate over all wallet transactions...\n         const CWalletTx &wtx = entry.second;\n-        BlockMap::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n-        if (blit != mapBlockIndex.end() && chainActive.Contains(blit->second)) {\n+        CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n+        if (pindex && chainActive.Contains(pindex)) {\n             // ... which are already in a block\n-            int nHeight = blit->second->nHeight;\n+            int nHeight = pindex->nHeight;\n             for (const CTxOut &txout : wtx.tx->vout) {\n                 // iterate over all their outputs\n                 CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n                 for (const CKeyID &keyid : vAffected) {\n                     // ... and all their affected keys\n                     std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                     if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n-                        rit->second = blit->second;\n+                        rit->second = pindex;\n                 }\n                 vAffected.clear();\n             }\n@@ -3814,7 +3827,7 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n {\n     unsigned int nTimeSmart = wtx.nTimeReceived;\n     if (!wtx.hashUnset()) {\n-        if (mapBlockIndex.count(wtx.hashBlock)) {\n+        if (const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock)) {\n             int64_t latestNow = wtx.nTimeReceived;\n             int64_t latestEntry = 0;\n \n@@ -3845,7 +3858,7 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n                 }\n             }\n \n-            int64_t blocktime = mapBlockIndex[wtx.hashBlock]->GetBlockTime();\n+            int64_t blocktime = pindex->GetBlockTime();\n             nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n         } else {\n             LogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.hashBlock.ToString());\n@@ -3906,18 +3919,19 @@ std::vector<std::string> CWallet::GetDestValues(const std::string& prefix) const\n     return values;\n }\n \n-CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n+CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path& path)\n {\n+    const std::string& walletFile = name;\n+\n     // needed to restore wallet transaction meta data after -zapwallettxes\n     std::vector<CWalletTx> vWtx;\n \n     if (gArgs.GetBoolArg(\"-zapwallettxes\", false)) {\n         uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n-        std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, walletFile));\n-        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(std::move(dbw));\n+        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, CWalletDBWrapper::Create(path));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n-        if (nZapWalletRet != DB_LOAD_OK) {\n+        if (nZapWalletRet != DBErrors::LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n@@ -3927,26 +3941,25 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n \n     int64_t nStart = GetTimeMillis();\n     bool fFirstRun = true;\n-    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, walletFile));\n-    CWallet *walletInstance = new CWallet(std::move(dbw));\n+    CWallet *walletInstance = new CWallet(name, CWalletDBWrapper::Create(path));\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n-    if (nLoadWalletRet != DB_LOAD_OK)\n+    if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n-        if (nLoadWalletRet == DB_CORRUPT) {\n+        if (nLoadWalletRet == DBErrors::CORRUPT) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n-        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n+        else if (nLoadWalletRet == DBErrors::NONCRITICAL_ERROR)\n         {\n             InitWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n                                          \" or address book entries might be missing or incorrect.\"),\n                 walletFile));\n         }\n-        else if (nLoadWalletRet == DB_TOO_NEW) {\n+        else if (nLoadWalletRet == DBErrors::TOO_NEW) {\n             InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n             return nullptr;\n         }\n-        else if (nLoadWalletRet == DB_NEED_REWRITE)\n+        else if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n         {\n             InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n             return nullptr;\n@@ -3997,8 +4010,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         }\n \n         walletInstance->SetBestChain(chainActive.GetLocator());\n-    }\n-    else if (gArgs.IsArgSet(\"-usehd\")) {\n+    } else if (gArgs.IsArgSet(\"-usehd\")) {\n         bool useHD = gArgs.GetBoolArg(\"-usehd\", true);\n         if (walletInstance->IsHDEnabled() && !useHD) {\n             InitError(strprintf(_(\"Error loading %s: You can't disable HD on an already existing HD wallet\"), walletFile));\n@@ -4010,11 +4022,27 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         }\n     }\n \n+    walletInstance->m_default_address_type = ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"), DEFAULT_ADDRESS_TYPE);\n+    if (walletInstance->m_default_address_type == OutputType::NONE) {\n+        InitError(strprintf(\"Unknown address type '%s'\", gArgs.GetArg(\"-addresstype\", \"\")));\n+        return nullptr;\n+    }\n+\n+    // If changetype is set in config file or parameter, check that it's valid.\n+    // Default to OutputType::NONE if not set.\n+    walletInstance->m_default_change_type = ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"), OutputType::NONE);\n+    if (walletInstance->m_default_change_type == OutputType::NONE && !gArgs.GetArg(\"-changetype\", \"\").empty()) {\n+        InitError(strprintf(\"Unknown change type '%s'\", gArgs.GetArg(\"-changetype\", \"\")));\n+        return nullptr;\n+    }\n+\n     LogPrintf(\" wallet      %15dms\\n\", GetTimeMillis() - nStart);\n \n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n+    LOCK(cs_main);\n+\n     CBlockIndex *pindexRescan = chainActive.Genesis();\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {\n@@ -4158,10 +4186,7 @@ int CMerkleTx::GetDepthInMainChain(const CBlockIndex* &pindexRet) const\n     AssertLockHeld(cs_main);\n \n     // Find the block it claims to be in\n-    BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n-    if (mi == mapBlockIndex.end())\n-        return 0;\n-    CBlockIndex* pindex = (*mi).second;\n+    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n     if (!pindex || !chainActive.Contains(pindex))\n         return 0;\n \n@@ -4182,8 +4207,8 @@ bool CWalletTx::AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState&\n     // We must set fInMempool here - while it will be re-set to true by the\n     // entered-mempool callback, if we did not there would be a race where a\n     // user could call sendmoney in a loop and hit spurious out of funds errors\n-    // because we think that the transaction they just generated's change is\n-    // unavailable as we're not yet aware its in mempool.\n+    // because we think that this newly generated transaction's change is\n+    // unavailable as we're not yet aware that it is in the mempool.\n     bool ret = ::AcceptToMemoryPool(mempool, state, tx, nullptr /* pfMissingInputs */,\n                                 nullptr /* plTxnReplaced */, false /* bypass_limits */, nAbsurdFee);\n     fInMempool |= ret;\n@@ -4199,29 +4224,29 @@ OutputType ParseOutputType(const std::string& type, OutputType default_type)\n     if (type.empty()) {\n         return default_type;\n     } else if (type == OUTPUT_TYPE_STRING_LEGACY) {\n-        return OUTPUT_TYPE_LEGACY;\n+        return OutputType::LEGACY;\n     } else if (type == OUTPUT_TYPE_STRING_P2SH_SEGWIT) {\n-        return OUTPUT_TYPE_P2SH_SEGWIT;\n+        return OutputType::P2SH_SEGWIT;\n     } else if (type == OUTPUT_TYPE_STRING_BECH32) {\n-        return OUTPUT_TYPE_BECH32;\n+        return OutputType::BECH32;\n     } else {\n-        return OUTPUT_TYPE_NONE;\n+        return OutputType::NONE;\n     }\n }\n \n const std::string& FormatOutputType(OutputType type)\n {\n     switch (type) {\n-    case OUTPUT_TYPE_LEGACY: return OUTPUT_TYPE_STRING_LEGACY;\n-    case OUTPUT_TYPE_P2SH_SEGWIT: return OUTPUT_TYPE_STRING_P2SH_SEGWIT;\n-    case OUTPUT_TYPE_BECH32: return OUTPUT_TYPE_STRING_BECH32;\n+    case OutputType::LEGACY: return OUTPUT_TYPE_STRING_LEGACY;\n+    case OutputType::P2SH_SEGWIT: return OUTPUT_TYPE_STRING_P2SH_SEGWIT;\n+    case OutputType::BECH32: return OUTPUT_TYPE_STRING_BECH32;\n     default: assert(false);\n     }\n }\n \n void CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n {\n-    if (key.IsCompressed() && (type == OUTPUT_TYPE_P2SH_SEGWIT || type == OUTPUT_TYPE_BECH32)) {\n+    if (key.IsCompressed() && (type == OutputType::P2SH_SEGWIT || type == OutputType::BECH32)) {\n         CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n         CScript witprog = GetScriptForDestination(witdest);\n         // Make sure the resulting program is solvable.\n@@ -4232,20 +4257,20 @@ void CWallet::LearnRelatedScripts(const CPubKey& key, OutputType type)\n \n void CWallet::LearnAllRelatedScripts(const CPubKey& key)\n {\n-    // OUTPUT_TYPE_P2SH_SEGWIT always adds all necessary scripts for all types.\n-    LearnRelatedScripts(key, OUTPUT_TYPE_P2SH_SEGWIT);\n+    // OutputType::P2SH_SEGWIT always adds all necessary scripts for all types.\n+    LearnRelatedScripts(key, OutputType::P2SH_SEGWIT);\n }\n \n CTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)\n {\n     switch (type) {\n-    case OUTPUT_TYPE_LEGACY: return key.GetID();\n-    case OUTPUT_TYPE_P2SH_SEGWIT:\n-    case OUTPUT_TYPE_BECH32: {\n+    case OutputType::LEGACY: return key.GetID();\n+    case OutputType::P2SH_SEGWIT:\n+    case OutputType::BECH32: {\n         if (!key.IsCompressed()) return key.GetID();\n         CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n         CScript witprog = GetScriptForDestination(witdest);\n-        if (type == OUTPUT_TYPE_P2SH_SEGWIT) {\n+        if (type == OutputType::P2SH_SEGWIT) {\n             return CScriptID(witprog);\n         } else {\n             return witdest;\n@@ -4271,10 +4296,10 @@ CTxDestination CWallet::AddAndGetDestinationForScript(const CScript& script, Out\n {\n     // Note that scripts over 520 bytes are not yet supported.\n     switch (type) {\n-    case OUTPUT_TYPE_LEGACY:\n+    case OutputType::LEGACY:\n         return CScriptID(script);\n-    case OUTPUT_TYPE_P2SH_SEGWIT:\n-    case OUTPUT_TYPE_BECH32: {\n+    case OutputType::P2SH_SEGWIT:\n+    case OutputType::BECH32: {\n         WitnessV0ScriptHash hash;\n         CSHA256().Write(script.data(), script.size()).Finalize(hash.begin());\n         CTxDestination witdest = hash;\n@@ -4283,7 +4308,7 @@ CTxDestination CWallet::AddAndGetDestinationForScript(const CScript& script, Out\n         if (!IsSolvable(*this, witprog)) return CScriptID(script);\n         // Add the redeemscript, so that P2WSH and P2SH-P2WSH outputs are recognized as ours.\n         AddCScript(witprog);\n-        if (type == OUTPUT_TYPE_BECH32) {\n+        if (type == OutputType::BECH32) {\n             return witdest;\n         } else {\n             return CScriptID(witprog);"
      },
      {
        "sha": "3ef5bfbb6567e655ec525ebb0b25655cde66c25c",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 154,
        "deletions": 174,
        "changes": 328,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -15,7 +15,9 @@\n #include <validationinterface.h>\n #include <script/ismine.h>\n #include <script/sign.h>\n+#include <util.h>\n #include <wallet/crypter.h>\n+#include <wallet/coinselection.h>\n #include <wallet/walletdb.h>\n #include <wallet/rpcwallet.h>\n \n@@ -39,7 +41,9 @@ extern CFeeRate payTxFee;\n extern unsigned int nTxConfirmTarget;\n extern bool bSpendZeroConfChange;\n extern bool fWalletRbf;\n+extern bool g_wallet_allow_fallback_fee;\n \n+//! Default for -keypool\n static const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n //! -paytxfee default\n static const CAmount DEFAULT_TRANSACTION_FEE = 0;\n@@ -51,10 +55,6 @@ static const CAmount DEFAULT_DISCARD_FEE = 10000;\n static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;\n //! minimum recommended increment for BIP 125 replacement txs\n static const CAmount WALLET_INCREMENTAL_RELAY_FEE = 5000;\n-//! target minimum change amount\n-static const CAmount MIN_CHANGE = CENT;\n-//! final minimum change amount after paying for fees\n-static const CAmount MIN_FINAL_CHANGE = MIN_CHANGE/2;\n //! Default for -spendzeroconfchange\n static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true;\n //! Default for -walletrejectlongchains\n@@ -66,8 +66,6 @@ static const bool DEFAULT_WALLET_RBF = false;\n static const bool DEFAULT_WALLETBROADCAST = true;\n static const bool DEFAULT_DISABLE_WALLET = false;\n \n-extern const char * DEFAULT_WALLET_DAT;\n-\n static const int64_t TIMESTAMP_MIN = 0;\n \n class CBlockIndex;\n@@ -99,18 +97,15 @@ enum WalletFeature\n     FEATURE_LATEST = FEATURE_COMPRPUBKEY // HD is optional, use FEATURE_COMPRPUBKEY as latest version\n };\n \n-enum OutputType : int\n-{\n-    OUTPUT_TYPE_NONE,\n-    OUTPUT_TYPE_LEGACY,\n-    OUTPUT_TYPE_P2SH_SEGWIT,\n-    OUTPUT_TYPE_BECH32,\n-\n-    OUTPUT_TYPE_DEFAULT = OUTPUT_TYPE_P2SH_SEGWIT\n+enum class OutputType {\n+    NONE,\n+    LEGACY,\n+    P2SH_SEGWIT,\n+    BECH32,\n };\n \n-extern OutputType g_address_type;\n-extern OutputType g_change_type;\n+//! Default for -addresstype\n+constexpr OutputType DEFAULT_ADDRESS_TYPE{OutputType::P2SH_SEGWIT};\n \n \n /** A key pool entry */\n@@ -269,6 +264,9 @@ class CMerkleTx\n     bool IsCoinBase() const { return tx->IsCoinBase(); }\n };\n \n+//Get the marginal bytes of spending the specified output\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet);\n+\n /** \n  * A transaction with a bunch of additional info that only the owner cares about.\n  * It includes any unrecorded transactions needed to link it back to the block chain.\n@@ -348,11 +346,6 @@ class CWalletTx : public CMerkleTx\n     mutable CAmount nAvailableWatchCreditCached;\n     mutable CAmount nChangeCached;\n \n-    CWalletTx()\n-    {\n-        Init(nullptr);\n-    }\n-\n     CWalletTx(const CWallet* pwalletIn, CTransactionRef arg) : CMerkleTx(std::move(arg))\n     {\n         Init(pwalletIn);\n@@ -390,42 +383,36 @@ class CWalletTx : public CMerkleTx\n         nOrderPos = -1;\n     }\n \n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        if (ser_action.ForRead())\n-            Init(nullptr);\n+    template<typename Stream>\n+    void Serialize(Stream& s) const\n+    {\n         char fSpent = false;\n+        mapValue_t mapValueCopy = mapValue;\n \n-        if (!ser_action.ForRead())\n-        {\n-            mapValue[\"fromaccount\"] = strFromAccount;\n-\n-            WriteOrderPos(nOrderPos, mapValue);\n-\n-            if (nTimeSmart)\n-                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+        mapValueCopy[\"fromaccount\"] = strFromAccount;\n+        WriteOrderPos(nOrderPos, mapValueCopy);\n+        if (nTimeSmart) {\n+            mapValueCopy[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n         }\n \n-        READWRITE(*static_cast<CMerkleTx*>(this));\n+        s << *static_cast<const CMerkleTx*>(this);\n         std::vector<CMerkleTx> vUnused; //!< Used to be vtxPrev\n-        READWRITE(vUnused);\n-        READWRITE(mapValue);\n-        READWRITE(vOrderForm);\n-        READWRITE(fTimeReceivedIsTxTime);\n-        READWRITE(nTimeReceived);\n-        READWRITE(fFromMe);\n-        READWRITE(fSpent);\n-\n-        if (ser_action.ForRead())\n-        {\n-            strFromAccount = mapValue[\"fromaccount\"];\n+        s << vUnused << mapValueCopy << vOrderForm << fTimeReceivedIsTxTime << nTimeReceived << fFromMe << fSpent;\n+    }\n \n-            ReadOrderPos(nOrderPos, mapValue);\n+    template<typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        Init(nullptr);\n+        char fSpent;\n \n-            nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n-        }\n+        s >> *static_cast<CMerkleTx*>(this);\n+        std::vector<CMerkleTx> vUnused; //!< Used to be vtxPrev\n+        s >> vUnused >> mapValue >> vOrderForm >> fTimeReceivedIsTxTime >> nTimeReceived >> fFromMe >> fSpent;\n+\n+        strFromAccount = std::move(mapValue[\"fromaccount\"]);\n+        ReadOrderPos(nOrderPos, mapValue);\n+        nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n \n         mapValue.erase(\"fromaccount\");\n         mapValue.erase(\"spent\");\n@@ -462,6 +449,12 @@ class CWalletTx : public CMerkleTx\n     CAmount GetAvailableWatchOnlyCredit(const bool fUseCache=true) const;\n     CAmount GetChange() const;\n \n+    // Get the marginal bytes if spending the specified output from this transaction\n+    int GetSpendSize(unsigned int out) const\n+    {\n+        return CalculateMaximumSignedInputSize(tx->vout[out], pwallet);\n+    }\n+\n     void GetAmounts(std::list<COutputEntry>& listReceived,\n                     std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n \n@@ -488,43 +481,16 @@ class CWalletTx : public CMerkleTx\n     std::set<uint256> GetConflicts() const;\n };\n \n-\n-class CInputCoin {\n-public:\n-    CInputCoin(const CWalletTx* walletTx, unsigned int i)\n-    {\n-        if (!walletTx)\n-            throw std::invalid_argument(\"walletTx should not be null\");\n-        if (i >= walletTx->tx->vout.size())\n-            throw std::out_of_range(\"The output index is out of range\");\n-\n-        outpoint = COutPoint(walletTx->GetHash(), i);\n-        txout = walletTx->tx->vout[i];\n-    }\n-\n-    COutPoint outpoint;\n-    CTxOut txout;\n-\n-    bool operator<(const CInputCoin& rhs) const {\n-        return outpoint < rhs.outpoint;\n-    }\n-\n-    bool operator!=(const CInputCoin& rhs) const {\n-        return outpoint != rhs.outpoint;\n-    }\n-\n-    bool operator==(const CInputCoin& rhs) const {\n-        return outpoint == rhs.outpoint;\n-    }\n-};\n-\n class COutput\n {\n public:\n     const CWalletTx *tx;\n     int i;\n     int nDepth;\n \n+    /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n+    int nInputBytes;\n+\n     /** Whether we have the private keys to spend this output */\n     bool fSpendable;\n \n@@ -540,7 +506,12 @@ class COutput\n \n     COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn)\n     {\n-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn;\n+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1;\n+        // If known and signable by the given wallet, compute nInputBytes\n+        // Failure will keep this value -1\n+        if (fSpendable && tx) {\n+            nInputBytes = tx->GetSpendSize(i);\n+        }\n     }\n \n     std::string ToString() const;\n@@ -608,48 +579,49 @@ class CAccountingEntry\n         nEntryNo = 0;\n     }\n \n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    template <typename Stream>\n+    void Serialize(Stream& s) const {\n         int nVersion = s.GetVersion();\n-        if (!(s.GetType() & SER_GETHASH))\n-            READWRITE(nVersion);\n+        if (!(s.GetType() & SER_GETHASH)) {\n+            s << nVersion;\n+        }\n         //! Note: strAccount is serialized as part of the key, not here.\n-        READWRITE(nCreditDebit);\n-        READWRITE(nTime);\n-        READWRITE(LIMITED_STRING(strOtherAccount, 65536));\n-\n-        if (!ser_action.ForRead())\n-        {\n-            WriteOrderPos(nOrderPos, mapValue);\n-\n-            if (!(mapValue.empty() && _ssExtra.empty()))\n-            {\n-                CDataStream ss(s.GetType(), s.GetVersion());\n-                ss.insert(ss.begin(), '\\0');\n-                ss << mapValue;\n-                ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());\n-                strComment.append(ss.str());\n-            }\n+        s << nCreditDebit << nTime << strOtherAccount;\n+\n+        mapValue_t mapValueCopy = mapValue;\n+        WriteOrderPos(nOrderPos, mapValueCopy);\n+\n+        std::string strCommentCopy = strComment;\n+        if (!mapValueCopy.empty() || !_ssExtra.empty()) {\n+            CDataStream ss(s.GetType(), s.GetVersion());\n+            ss.insert(ss.begin(), '\\0');\n+            ss << mapValueCopy;\n+            ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());\n+            strCommentCopy.append(ss.str());\n         }\n+        s << strCommentCopy;\n+    }\n \n-        READWRITE(LIMITED_STRING(strComment, 65536));\n+    template <typename Stream>\n+    void Unserialize(Stream& s) {\n+        int nVersion = s.GetVersion();\n+        if (!(s.GetType() & SER_GETHASH)) {\n+            s >> nVersion;\n+        }\n+        //! Note: strAccount is serialized as part of the key, not here.\n+        s >> nCreditDebit >> nTime >> LIMITED_STRING(strOtherAccount, 65536) >> LIMITED_STRING(strComment, 65536);\n \n         size_t nSepPos = strComment.find(\"\\0\", 0, 1);\n-        if (ser_action.ForRead())\n-        {\n-            mapValue.clear();\n-            if (std::string::npos != nSepPos)\n-            {\n-                CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), s.GetType(), s.GetVersion());\n-                ss >> mapValue;\n-                _ssExtra = std::vector<char>(ss.begin(), ss.end());\n-            }\n-            ReadOrderPos(nOrderPos, mapValue);\n+        mapValue.clear();\n+        if (std::string::npos != nSepPos) {\n+            CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), s.GetType(), s.GetVersion());\n+            ss >> mapValue;\n+            _ssExtra = std::vector<char>(ss.begin(), ss.end());\n         }\n-        if (std::string::npos != nSepPos)\n+        ReadOrderPos(nOrderPos, mapValue);\n+        if (std::string::npos != nSepPos) {\n             strComment.erase(nSepPos);\n+        }\n \n         mapValue.erase(\"n\");\n     }\n@@ -658,6 +630,26 @@ class CAccountingEntry\n     std::vector<char> _ssExtra;\n };\n \n+struct CoinSelectionParams\n+{\n+    bool use_bnb = true;\n+    size_t change_output_size = 0;\n+    size_t change_spend_size = 0;\n+    CFeeRate effective_fee = CFeeRate(0);\n+    size_t tx_noinputs_size = 0;\n+\n+    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size) : use_bnb(use_bnb), change_output_size(change_output_size), change_spend_size(change_spend_size), effective_fee(effective_fee), tx_noinputs_size(tx_noinputs_size) {}\n+    CoinSelectionParams() {}\n+};\n+\n+struct CoinEligibilityFilter\n+{\n+    const int conf_mine;\n+    const int conf_theirs;\n+    const uint64_t max_ancestors;\n+\n+    CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors) {}\n+};\n \n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n /** \n@@ -673,14 +665,6 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::mutex mutexScanning;\n     friend class WalletRescanReserver;\n \n-\n-    /**\n-     * Select a set of coins such that nValueRet >= nTargetValue and at least\n-     * all coins from coinControl are selected; Never select unconfirmed coins\n-     * if they are not ours\n-     */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = nullptr) const;\n-\n     CWalletDB *pwalletdbEncryption;\n \n     //! the current wallet version: clients below this version are not able to load the wallet\n@@ -736,6 +720,14 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      */\n     bool AddWatchOnly(const CScript& dest) override;\n \n+    /**\n+     * Wallet filename from wallet=<path> command line or config option.\n+     * Used in debug logs and to send RPCs to the right wallet instance when\n+     * more than one wallet is loaded.\n+     */\n+    std::string m_name;\n+\n+    /** Internal database handle. */\n     std::unique_ptr<CWalletDBWrapper> dbw;\n \n     /**\n@@ -765,16 +757,17 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n         return *dbw;\n     }\n \n+    /**\n+     * Select a set of coins such that nValueRet >= nTargetValue and at least\n+     * all coins from coinControl are selected; Never select unconfirmed coins\n+     * if they are not ours\n+     */\n+    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n+                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n+\n     /** Get a name for this wallet for logging/debugging purposes.\n      */\n-    std::string GetName() const\n-    {\n-        if (dbw) {\n-            return dbw->GetName();\n-        } else {\n-            return \"dummy\";\n-        }\n-    }\n+    const std::string& GetName() const { return m_name; }\n \n     void LoadKeyPool(int64_t nIndex, const CKeyPool &keypool);\n \n@@ -788,14 +781,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     MasterKeyMap mapMasterKeys;\n     unsigned int nMasterKeyMaxID;\n \n-    // Create wallet with dummy database handle\n-    CWallet(): dbw(new CWalletDBWrapper())\n-    {\n-        SetNull();\n-    }\n-\n-    // Create wallet with passed-in database handle\n-    explicit CWallet(std::unique_ptr<CWalletDBWrapper> dbw_in) : dbw(std::move(dbw_in))\n+    /** Construct wallet with specified name and database implementation. */\n+    CWallet(std::string name, std::unique_ptr<CWalletDBWrapper> dbw) : m_name(std::move(name)), dbw(std::move(dbw))\n     {\n         SetNull();\n     }\n@@ -865,7 +852,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * completion the coin set and corresponding actual target value is\n      * assembled\n      */\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, uint64_t nMaxAncestors, std::vector<COutput> vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const;\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> vCoins,\n+        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n \n@@ -940,7 +928,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     int64_t IncOrderPosNext(CWalletDB *pwalletdb = nullptr);\n     DBErrors ReorderTransactions();\n     bool AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment = \"\");\n-    bool GetAccountDestination(CTxDestination &dest, std::string strAccount, bool bForceNew = false);\n+    bool GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew = false);\n \n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose=true);\n@@ -979,19 +967,27 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * selected by SelectCoins(); Also create the change output, when needed\n      * @note passing nChangePosInOut as -1 will result in setting a random position\n      */\n-    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosInOut,\n+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosInOut,\n                            std::string& strFailReason, const CCoinControl& coin_control, bool sign = true);\n-    bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CConnman* connman, CValidationState& state);\n+    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state);\n \n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);\n     bool AddAccountingEntry(const CAccountingEntry&);\n     bool AddAccountingEntry(const CAccountingEntry&, CWalletDB *pwalletdb);\n-    template <typename ContainerType>\n-    bool DummySignTx(CMutableTransaction &txNew, const ContainerType &coins) const;\n+    bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts) const\n+    {\n+        std::vector<CTxOut> v_txouts(txouts.size());\n+        std::copy(txouts.begin(), txouts.end(), v_txouts.begin());\n+        return DummySignTx(txNew, v_txouts);\n+    }\n+    bool DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts) const;\n+    bool DummySignInput(CTxIn &tx_in, const CTxOut &txout) const;\n \n     static CFeeRate minTxFee;\n     static CFeeRate fallbackFee;\n     static CFeeRate m_discard_rate;\n+    OutputType m_default_address_type{DEFAULT_ADDRESS_TYPE};\n+    OutputType m_default_change_type{OutputType::NONE}; // Default to OutputType::NONE if not set by -changetype\n \n     bool NewKeyPool();\n     size_t KeypoolCountExternalKeys();\n@@ -1010,7 +1006,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::set< std::set<CTxDestination> > GetAddressGroupings();\n     std::map<CTxDestination, CAmount> GetAddressBalances();\n \n-    std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n+    std::set<CTxDestination> GetLabelAddresses(const std::string& label) const;\n \n     isminetype IsMine(const CTxIn& txin) const;\n     /**\n@@ -1040,7 +1036,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     bool DelAddressBook(const CTxDestination& address);\n \n-    const std::string& GetAccountName(const CScript& scriptPubKey) const;\n+    const std::string& GetLabelName(const CScript& scriptPubKey) const;\n \n     void Inventory(const uint256 &hash) override\n     {\n@@ -1115,7 +1111,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     bool MarkReplaced(const uint256& originalHash, const uint256& newHash);\n \n     /* Initializes the wallet, returns a new CWallet instance or a null pointer in case of an error */\n-    static CWallet* CreateWalletFromFile(const std::string walletFile);\n+    static CWallet* CreateWalletFromFile(const std::string& name, const fs::path& path);\n \n     /**\n      * Wallet post-init setup\n@@ -1168,6 +1164,9 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * This function will automatically add the necessary scripts to the wallet.\n      */\n     CTxDestination AddAndGetDestinationForScript(const CScript& script, OutputType);\n+\n+    /** Whether a given output is spendable by this wallet */\n+    bool OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibility_filter) const;\n };\n \n /** A key allocated from the key pool. */\n@@ -1232,32 +1231,7 @@ class CAccount\n     }\n };\n \n-// Helper for producing a bunch of max-sized low-S signatures (eg 72 bytes)\n-// ContainerType is meant to hold pair<CWalletTx *, int>, and be iterable\n-// so that each entry corresponds to each vIn, in order.\n-template <typename ContainerType>\n-bool CWallet::DummySignTx(CMutableTransaction &txNew, const ContainerType &coins) const\n-{\n-    // Fill in dummy signatures for fee calculation.\n-    int nIn = 0;\n-    for (const auto& coin : coins)\n-    {\n-        const CScript& scriptPubKey = coin.txout.scriptPubKey;\n-        SignatureData sigdata;\n-\n-        if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n-        {\n-            return false;\n-        } else {\n-            UpdateTransaction(txNew, nIn, sigdata);\n-        }\n-\n-        nIn++;\n-    }\n-    return true;\n-}\n-\n-OutputType ParseOutputType(const std::string& str, OutputType default_type = OUTPUT_TYPE_DEFAULT);\n+OutputType ParseOutputType(const std::string& str, OutputType default_type);\n const std::string& FormatOutputType(OutputType type);\n \n /**\n@@ -1304,4 +1278,10 @@ class WalletRescanReserver\n     }\n };\n \n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet);\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts);\n #endif // BITCOIN_WALLET_WALLET_H"
      },
      {
        "sha": "77cdfe7dd0f051f6216504e99c2cab06fdd28255",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -5,10 +5,10 @@\n \n #include <wallet/walletdb.h>\n \n-#include <base58.h>\n #include <consensus/tx_verify.h>\n #include <consensus/validation.h>\n #include <fs.h>\n+#include <key_io.h>\n #include <protocol.h>\n #include <serialize.h>\n #include <sync.h>\n@@ -265,7 +265,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         {\n             uint256 hash;\n             ssKey >> hash;\n-            CWalletTx wtx;\n+            CWalletTx wtx(nullptr /* pwallet */, MakeTransactionRef());\n             ssValue >> wtx;\n             CValidationState state;\n             if (!(CheckTransaction(*wtx.tx, state) && (wtx.GetHash() == hash) && state.IsValid()))\n@@ -522,15 +522,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n {\n     CWalletScanState wss;\n     bool fNoncriticalErrors = false;\n-    DBErrors result = DB_LOAD_OK;\n+    DBErrors result = DBErrors::LOAD_OK;\n \n     LOCK(pwallet->cs_wallet);\n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n+                return DBErrors::TOO_NEW;\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n@@ -539,7 +539,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n         }\n \n         while (true)\n@@ -553,7 +553,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             else if (ret != 0)\n             {\n                 LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n+                return DBErrors::CORRUPT;\n             }\n \n             // Try to be tolerant of single corrupt records:\n@@ -563,7 +563,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n                 // losing keys is considered a catastrophic error, anything else\n                 // we assume the user can live with:\n                 if (IsKeyType(strType) || strType == \"defaultkey\")\n-                    result = DB_CORRUPT;\n+                    result = DBErrors::CORRUPT;\n                 else\n                 {\n                     // Leave other errors alone, if we try to fix them we might make things worse.\n@@ -582,15 +582,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         throw;\n     }\n     catch (...) {\n-        result = DB_CORRUPT;\n+        result = DBErrors::CORRUPT;\n     }\n \n-    if (fNoncriticalErrors && result == DB_LOAD_OK)\n-        result = DB_NONCRITICAL_ERROR;\n+    if (fNoncriticalErrors && result == DBErrors::LOAD_OK)\n+        result = DBErrors::NONCRITICAL_ERROR;\n \n     // Any wallet corruption at all: skip any rewriting or\n     // upgrading, we don't want to make it worse.\n-    if (result != DB_LOAD_OK)\n+    if (result != DBErrors::LOAD_OK)\n         return result;\n \n     LogPrintf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n@@ -603,11 +603,11 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         pwallet->UpdateTimeFirstKey(1);\n \n     for (uint256 hash : wss.vWalletUpgrade)\n-        WriteTx(pwallet->mapWallet[hash]);\n+        WriteTx(pwallet->mapWallet.at(hash));\n \n     // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n     if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n-        return DB_NEED_REWRITE;\n+        return DBErrors::NEED_REWRITE;\n \n     if (wss.nFileVersion < CLIENT_VERSION) // Update\n         WriteVersion(CLIENT_VERSION);\n@@ -626,22 +626,22 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n \n DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n {\n-    DBErrors result = DB_LOAD_OK;\n+    DBErrors result = DBErrors::LOAD_OK;\n \n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n+                return DBErrors::TOO_NEW;\n         }\n \n         // Get cursor\n         Dbc* pcursor = batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n         }\n \n         while (true)\n@@ -655,7 +655,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n             else if (ret != 0)\n             {\n                 LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n+                return DBErrors::CORRUPT;\n             }\n \n             std::string strType;\n@@ -664,7 +664,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n                 uint256 hash;\n                 ssKey >> hash;\n \n-                CWalletTx wtx;\n+                CWalletTx wtx(nullptr /* pwallet */, MakeTransactionRef());\n                 ssValue >> wtx;\n \n                 vTxHash.push_back(hash);\n@@ -677,7 +677,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n         throw;\n     }\n     catch (...) {\n-        result = DB_CORRUPT;\n+        result = DBErrors::CORRUPT;\n     }\n \n     return result;\n@@ -689,7 +689,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     std::vector<uint256> vTxHash;\n     std::vector<CWalletTx> vWtx;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n-    if (err != DB_LOAD_OK) {\n+    if (err != DBErrors::LOAD_OK) {\n         return err;\n     }\n \n@@ -716,26 +716,26 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     }\n \n     if (delerror) {\n-        return DB_CORRUPT;\n+        return DBErrors::CORRUPT;\n     }\n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n     std::vector<uint256> vTxHash;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n-    if (err != DB_LOAD_OK)\n+    if (err != DBErrors::LOAD_OK)\n         return err;\n \n     // erase each wallet TX\n     for (uint256& hash : vTxHash) {\n         if (!EraseTx(hash))\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n     }\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n void MaybeCompactWalletDB()\n@@ -771,16 +771,16 @@ void MaybeCompactWalletDB()\n //\n // Try to (very carefully!) recover wallet file if there is a problem.\n //\n-bool CWalletDB::Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename)\n+bool CWalletDB::Recover(const fs::path& wallet_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename)\n {\n-    return CDB::Recover(filename, callbackDataIn, recoverKVcallback, out_backup_filename);\n+    return CDB::Recover(wallet_path, callbackDataIn, recoverKVcallback, out_backup_filename);\n }\n \n-bool CWalletDB::Recover(const std::string& filename, std::string& out_backup_filename)\n+bool CWalletDB::Recover(const fs::path& wallet_path, std::string& out_backup_filename)\n {\n     // recover without a key filter callback\n     // results in recovering all record types\n-    return CWalletDB::Recover(filename, nullptr, nullptr, out_backup_filename);\n+    return CWalletDB::Recover(wallet_path, nullptr, nullptr, out_backup_filename);\n }\n \n bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDataStream ssValue)\n@@ -806,14 +806,14 @@ bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDa\n     return true;\n }\n \n-bool CWalletDB::VerifyEnvironment(const std::string& walletFile, const fs::path& walletDir, std::string& errorStr)\n+bool CWalletDB::VerifyEnvironment(const fs::path& wallet_path, std::string& errorStr)\n {\n-    return CDB::VerifyEnvironment(walletFile, walletDir, errorStr);\n+    return CDB::VerifyEnvironment(wallet_path, errorStr);\n }\n \n-bool CWalletDB::VerifyDatabaseFile(const std::string& walletFile, const fs::path& walletDir, std::string& warningStr, std::string& errorStr)\n+bool CWalletDB::VerifyDatabaseFile(const fs::path& wallet_path, std::string& warningStr, std::string& errorStr)\n {\n-    return CDB::VerifyDatabaseFile(walletFile, walletDir, warningStr, errorStr, CWalletDB::Recover);\n+    return CDB::VerifyDatabaseFile(wallet_path, warningStr, errorStr, CWalletDB::Recover);\n }\n \n bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)"
      },
      {
        "sha": "606b7dace721ead8015ba7671d5373a0ac0df78a",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -46,14 +46,14 @@ class uint160;\n class uint256;\n \n /** Error statuses for the wallet database */\n-enum DBErrors\n+enum class DBErrors\n {\n-    DB_LOAD_OK,\n-    DB_CORRUPT,\n-    DB_NONCRITICAL_ERROR,\n-    DB_TOO_NEW,\n-    DB_LOAD_FAIL,\n-    DB_NEED_REWRITE\n+    LOAD_OK,\n+    CORRUPT,\n+    NONCRITICAL_ERROR,\n+    TOO_NEW,\n+    LOAD_FAIL,\n+    NEED_REWRITE\n };\n \n /* simple HD chain data model */\n@@ -218,17 +218,17 @@ class CWalletDB\n     DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n     DBErrors ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut);\n     /* Try to (very carefully!) recover wallet database (with a possible key type filter) */\n-    static bool Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename);\n+    static bool Recover(const fs::path& wallet_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename);\n     /* Recover convenience-function to bypass the key filter callback, called when verify fails, recovers everything */\n-    static bool Recover(const std::string& filename, std::string& out_backup_filename);\n+    static bool Recover(const fs::path& wallet_path, std::string& out_backup_filename);\n     /* Recover filter (used as callback), will only let keys (cryptographical keys) as KV/key-type pass through */\n     static bool RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDataStream ssValue);\n     /* Function to determine if a certain KV/key-type is a key (cryptographical key) type */\n     static bool IsKeyType(const std::string& strType);\n     /* verifies the database environment */\n-    static bool VerifyEnvironment(const std::string& walletFile, const fs::path& walletDir, std::string& errorStr);\n+    static bool VerifyEnvironment(const fs::path& wallet_path, std::string& errorStr);\n     /* verifies the database file */\n-    static bool VerifyDatabaseFile(const std::string& walletFile, const fs::path& walletDir, std::string& warningStr, std::string& errorStr);\n+    static bool VerifyDatabaseFile(const fs::path& wallet_path, std::string& warningStr, std::string& errorStr);\n \n     //! write the hdchain model (external chain child index counter)\n     bool WriteHDChain(const CHDChain& chain);"
      },
      {
        "sha": "47e4e2cce1b721f40da9d527afc42c65eb8b716a",
        "filename": "src/walletinitinterface.h",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/src/walletinitinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/src/walletinitinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletinitinterface.h?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef WALLETINITINTERFACE_H\n+#define WALLETINITINTERFACE_H\n+\n+#include <string>\n+\n+class CScheduler;\n+class CRPCTable;\n+\n+class WalletInitInterface {\n+public:\n+    /** Get wallet help string */\n+    virtual std::string GetHelpString(bool showDebug) = 0;\n+    /** Check wallet parameter interaction */\n+    virtual bool ParameterInteraction() = 0;\n+    /** Register wallet RPC*/\n+    virtual void RegisterRPC(CRPCTable &) = 0;\n+    /** Verify wallets */\n+    virtual bool Verify() = 0;\n+    /** Open wallets*/\n+    virtual bool Open() = 0;\n+    /** Start wallets*/\n+    virtual void Start(CScheduler& scheduler) = 0;\n+    /** Flush Wallets*/\n+    virtual void Flush() = 0;\n+    /** Stop Wallets*/\n+    virtual void Stop() = 0;\n+    /** Close wallets */\n+    virtual void Close() = 0;\n+\n+    virtual ~WalletInitInterface() {}\n+};\n+\n+class DummyWalletInit : public WalletInitInterface {\n+public:\n+\n+    std::string GetHelpString(bool showDebug) override {return std::string{};}\n+    bool ParameterInteraction() override {return true;}\n+    void RegisterRPC(CRPCTable &) override {}\n+    bool Verify() override {return true;}\n+    bool Open() override {return true;}\n+    void Start(CScheduler& scheduler) override {}\n+    void Flush() override {}\n+    void Stop() override {}\n+    void Close() override {}\n+};\n+\n+#endif // WALLETINITINTERFACE_H"
      },
      {
        "sha": "d1bf9206b257fad875b6a1bf5a82705a7a7b0b58",
        "filename": "test/functional/combine_logs.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/combine_logs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/combine_logs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/combine_logs.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -13,7 +13,7 @@\n import sys\n \n # Matches on the date format at the start of the log event\n-TIMESTAMP_PATTERN = re.compile(r\"^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{6}\")\n+TIMESTAMP_PATTERN = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}Z\")\n \n LogEvent = namedtuple('LogEvent', ['timestamp', 'source', 'event'])\n "
      },
      {
        "sha": "05d1c1bf4ef0fdbe8573f6cd59d6981fa59f7ea4",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -38,7 +38,7 @@ class BaseNode(P2PInterface):\n     def __init__(self):\n         \"\"\"Initialize the P2PInterface\n \n-        Used to inialize custom properties for the Node that aren't\n+        Used to initialize custom properties for the Node that aren't\n         included by default in the base class. Be aware that the P2PInterface\n         base class already stores a counter for each P2P message type and the\n         last received message of each type, which should be sufficient for the"
      },
      {
        "sha": "ac6176e976e377df783f2efdecfe8ba4ac388244",
        "filename": "test/functional/feature_bip9_softforks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_bip9_softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_bip9_softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip9_softforks.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2",
        "patch": "@@ -241,7 +241,7 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n         self.test.clear_all_connections()\n         self.stop_nodes()\n         self.nodes = []\n-        shutil.rmtree(self.options.tmpdir + \"/node0\")\n+        shutil.rmtree(get_datadir_path(self.options.tmpdir, 0))\n         self.setup_chain()\n         self.setup_network()\n         self.test.add_all_connections(self.nodes)"
      },
      {
        "sha": "181c7f336941634b660c2d7a7b530bdfd946d818",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "a77014a5247d17a3fa065a582190c52ef5ef1744",
        "filename": "test/functional/feature_blocksdir.py",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_blocksdir.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_blocksdir.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blocksdir.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "6b1e473aa277901581babd543a1408e55a19d9e7",
        "filename": "test/functional/feature_config_args.py",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_config_args.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_config_args.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_config_args.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "32a6bd5d591569553afe3cb5d317bd570c0e53d0",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "a4ebc7cca3fa343b95a7c8972c82de440b9054e7",
        "filename": "test/functional/feature_logging.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_logging.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_logging.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_logging.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "ce6ec76c613ec05b458aa025c160d1e6761e65a8",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "3adde8dd735116dd023b0edfcce0a2ebc0897393",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 15,
        "deletions": 22,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "d1d3f1d7f15b66b975d9e348318ecdd703928aa7",
        "filename": "test/functional/feature_reindex.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_reindex.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "c73bdcfbb8516cf827d29b1eda3e2ebfdd214706",
        "filename": "test/functional/feature_uacomment.py",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_uacomment.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/feature_uacomment.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_uacomment.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "e29fdc84e7bb3dd140bdaa4a40eee7b7da19aafd",
        "filename": "test/functional/interface_bitcoin_cli.py",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/interface_bitcoin_cli.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/interface_bitcoin_cli.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_bitcoin_cli.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "6f585f6825a8342cfc85a5d32bc182dc22dc2dce",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 36,
        "deletions": 9,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "5382fe439e4edb6eb34991a19935cf910bfcc049",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "8880db80021012ebad9440c46720d02857ef1b8a",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 43,
        "deletions": 3,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "75eb9b17840009250908d765f9aa504b0d3ac8e8",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "e754dd31ad1f9358d230999e4ee82aeb5de087f5",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "1657d972811616c4916d4fcb01a50b581b42b1ef",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "7c954cdca2d7e69f0615d72b95df310b3174bcb4",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "e1f328ba774ca171c956aacfe619410f0d4c57cc",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 50,
        "deletions": 66,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "69ce529ad6b4f882b23ea122e623e80d8b91c95c",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "198dcc14901992ea1396760a740e8c246a3f707e",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "301d8c181ad95617e1dc9ece52d7e0137cb14005",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 71,
        "deletions": 9,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "e6af35fc3dc017386b5a0d420533d21be7f0c1d1",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "6a21b693b4e40c9a2bfd3c3174f71112ce328b90",
        "filename": "test/functional/p2p_timeouts.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_timeouts.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "53b2856eb5d247ea4b98e2fdcb6b588b9b35fd8e",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "5b50520d3f9a9591be8a3e407432508e4a6bbabc",
        "filename": "test/functional/rpc_bind.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_bind.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_bind.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_bind.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "17e24453e547e3021b5811f650ead346ac540a39",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 73,
        "deletions": 2,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "72b5f4748feab65319d16f502b1ea60897239961",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 25,
        "deletions": 23,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "796a2edbefbf5f515482c757f74df793a78c427a",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "825b897871cdf161f5c284f45b8b4564e1969de2",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 52,
        "deletions": 12,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "0ce412f74a0e5d1d01da52489338965886856f7f",
        "filename": "test/functional/rpc_users.py",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_users.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/rpc_users.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_users.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "e0ca78e5d166685e88dc9193e4beec90129b6703",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "ee573e01cc2250917ef0bf3f7f9e522704a60597",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "f1f7d0c0cd8fbdfd955ba19752fc5f7524779d72",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "36d1a2f856133b22ab5233ad09f6deb7f8168de2",
        "filename": "test/functional/test_framework/netutil.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/netutil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/netutil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/netutil.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "6fe0b445da67c1c61425ca49f8a850b0146c3189",
        "filename": "test/functional/test_framework/script.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "d427f62856f2215dbfad2e691469d2f0824b17a4",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 23,
        "deletions": 36,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "291ac3ee46ca89409d1f6809767859ad661ef107",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 49,
        "deletions": 4,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "a24a2ec4f5ff997a44b22e62afcaf1e689f4b8d0",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 27,
        "deletions": 50,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "39f1180a4514c39e0809a593702de3f887ac49cb",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 50,
        "deletions": 36,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "d5ef08d782ad0751bd3fa960b388cd00f22c3ba5",
        "filename": "test/functional/wallet_abandonconflict.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/wallet_abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924d4ae38d34738b6313992a2b10984c398b23d2/test/functional/wallet_abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_abandonconflict.py?ref=924d4ae38d34738b6313992a2b10984c398b23d2"
      },
      {
        "sha": "ecd1cfc82b1bb4a297284cc0ca546661c27f0256",
        "filename": "test/functional/wallet_accounts.py",
        "status": "removed",
        "additions": 0,
        "deletions": 206,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07090c5339436f856e79a8036d1c85deeb453803/test/functional/wallet_accounts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07090c5339436f856e79a8036d1c85deeb453803/test/functional/wallet_accounts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_accounts.py?ref=07090c5339436f856e79a8036d1c85deeb453803"
      }
    ]
  }
]