[
  {
    "sha": "cc046f66a7f3bb8d615998ebce38468d90ad8681",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzA0NmY2NmE3ZjNiYjhkNjE1OTk4ZWJjZTM4NDY4ZDkwYWQ4Njgx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T16:47:37Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-01-29T14:48:17Z"
      },
      "message": "[tests] Reduce NodeConn connection logging from info to debug",
      "tree": {
        "sha": "497901cb2be54d90aa404a281000f301a40b0af6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/497901cb2be54d90aa404a281000f301a40b0af6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc046f66a7f3bb8d615998ebce38468d90ad8681",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc046f66a7f3bb8d615998ebce38468d90ad8681",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc046f66a7f3bb8d615998ebce38468d90ad8681",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc046f66a7f3bb8d615998ebce38468d90ad8681/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6378e5c51414b1f084fe01d31003fe8fd66b9501",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6378e5c51414b1f084fe01d31003fe8fd66b9501",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6378e5c51414b1f084fe01d31003fe8fd66b9501"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "bdc12de93e1af1a341cd164d3cc7d90d242a576b",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc046f66a7f3bb8d615998ebce38468d90ad8681/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc046f66a7f3bb8d615998ebce38468d90ad8681/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=cc046f66a7f3bb8d615998ebce38468d90ad8681",
        "patch": "@@ -86,7 +86,7 @@ def peer_connect(self, dstaddr, dstport, net=\"regtest\"):\n         self.network = net\n         self.disconnect = False\n \n-        logger.info('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n+        logger.debug('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n         try:\n             self.connect((dstaddr, dstport))"
      }
    ]
  },
  {
    "sha": "c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMzJjZjlmNjIyODViNWNkMThhNTA2NGFlZTkxZjA4MDJmMGY4N2E4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T16:45:14Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-01-30T14:31:31Z"
      },
      "message": "[tests] Add P2PDataStore class\n\nP2PDataStore subclasses NodeConnCB. This class keeps a store\nof txs and blocks and responds to getdata requests from\nthe node-under-test.",
      "tree": {
        "sha": "41e9fc0adb4a01c4deb9bf44d95885763f65c04f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/41e9fc0adb4a01c4deb9bf44d95885763f65c04f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c32cf9f62285b5cd18a5064aee91f0802f0f87a8/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc046f66a7f3bb8d615998ebce38468d90ad8681",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc046f66a7f3bb8d615998ebce38468d90ad8681",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc046f66a7f3bb8d615998ebce38468d90ad8681"
      }
    ],
    "stats": {
      "total": 158,
      "additions": 155,
      "deletions": 3
    },
    "files": [
      {
        "sha": "46ef7521e098e036559788f5842e8d9592f977ad",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c32cf9f62285b5cd18a5064aee91f0802f0f87a8/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c32cf9f62285b5cd18a5064aee91f0802f0f87a8/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
        "patch": "@@ -44,6 +44,11 @@\n NODE_UNSUPPORTED_SERVICE_BIT_7 = (1 << 7)\n NODE_NETWORK_LIMITED = (1 << 10)\n \n+MSG_TX = 1\n+MSG_BLOCK = 2\n+MSG_WITNESS_FLAG = 1 << 30\n+MSG_TYPE_MASK = 0xffffffff >> 2\n+\n # Serialization/deserialization tools\n def sha256(s):\n     return hashlib.new('sha256', s).digest()\n@@ -204,8 +209,6 @@ def __repr__(self):\n         return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n                                                          self.ip, self.port)\n \n-MSG_WITNESS_FLAG = 1<<30\n-\n class CInv():\n     typemap = {\n         0: \"Error\","
      },
      {
        "sha": "31aa146a9ee9e6a5a261626f0df7530e41cfb3f3",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 150,
        "deletions": 1,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c32cf9f62285b5cd18a5064aee91f0802f0f87a8/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c32cf9f62285b5cd18a5064aee91f0802f0f87a8/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
        "patch": "@@ -10,7 +10,9 @@\n found in the mini-node branch of http://github.com/jgarzik/pynode.\n \n P2PConnection: A low-level connection object to a node's P2P interface\n-P2PInterface: A high-level interface object for communicating to a node over P2P\"\"\"\n+P2PInterface: A high-level interface object for communicating to a node over P2P\n+P2PDataStore: A p2p interface class that keeps a store of transactions and blocks\n+              and can respond correctly to getdata and getheaders messages\"\"\"\n import asyncore\n from collections import defaultdict\n from io import BytesIO\n@@ -356,10 +358,22 @@ def wait_for_block(self, blockhash, timeout=60):\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_getdata(self, timeout=60):\n+        \"\"\"Waits for a getdata message.\n+\n+        Receiving any getdata message will satisfy the predicate. the last_message[\"getdata\"]\n+        value must be explicitly cleared before calling this method, or this will return\n+        immediately with success. TODO: change this method to take a hash value and only\n+        return true if the correct block/tx has been requested.\"\"\"\n         test_function = lambda: self.last_message.get(\"getdata\")\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_getheaders(self, timeout=60):\n+        \"\"\"Waits for a getheaders message.\n+\n+        Receiving any getheaders message will satisfy the predicate. the last_message[\"getheaders\"]\n+        value must be explicitly cleared before calling this method, or this will return\n+        immediately with success. TODO: change this method to take a hash value and only\n+        return true if the correct block header has been requested.\"\"\"\n         test_function = lambda: self.last_message.get(\"getheaders\")\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n@@ -440,3 +454,138 @@ def network_thread_join(timeout=10):\n     for thread in network_threads:\n         thread.join(timeout)\n         assert not thread.is_alive()\n+\n+class P2PDataStore(P2PInterface):\n+    \"\"\"A P2P data store class.\n+\n+    Keeps a block and transaction store and responds correctly to getdata and getheaders requests.\"\"\"\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.reject_code_received = None\n+        self.reject_reason_received = None\n+        # store of blocks. key is block hash, value is a CBlock object\n+        self.block_store = {}\n+        self.last_block_hash = ''\n+        # store of txs. key is txid, value is a CTransaction object\n+        self.tx_store = {}\n+        self.getdata_requests = []\n+\n+    def on_getdata(self, message):\n+        \"\"\"Check for the tx/block in our stores and if found, reply with an inv message.\"\"\"\n+        for inv in message.inv:\n+            self.getdata_requests.append(inv.hash)\n+            if (inv.type & MSG_TYPE_MASK) == MSG_TX and inv.hash in self.tx_store.keys():\n+                self.send_message(msg_tx(self.tx_store[inv.hash]))\n+            elif (inv.type & MSG_TYPE_MASK) == MSG_BLOCK and inv.hash in self.block_store.keys():\n+                self.send_message(msg_block(self.block_store[inv.hash]))\n+            else:\n+                logger.debug('getdata message type {} received.'.format(hex(inv.type)))\n+\n+    def on_getheaders(self, message):\n+        \"\"\"Search back through our block store for the locator, and reply with a headers message if found.\"\"\"\n+\n+        locator, hash_stop = message.locator, message.hashstop\n+\n+        # Assume that the most recent block added is the tip\n+        if not self.block_store:\n+            return\n+\n+        headers_list = [self.block_store[self.last_block_hash]]\n+        maxheaders = 2000\n+        while headers_list[-1].sha256 not in locator.vHave:\n+            # Walk back through the block store, adding headers to headers_list\n+            # as we go.\n+            prev_block_hash = headers_list[-1].hashPrevBlock\n+            if prev_block_hash in self.block_store:\n+                prev_block_header = self.block_store[prev_block_hash]\n+                headers_list.append(prev_block_header)\n+                if prev_block_header.sha256 == hash_stop:\n+                    # if this is the hashstop header, stop here\n+                    break\n+            else:\n+                logger.debug('block hash {} not found in block store'.format(hex(prev_block_hash)))\n+                break\n+\n+        # Truncate the list if there are too many headers\n+        headers_list = headers_list[:-maxheaders - 1:-1]\n+        response = msg_headers(headers_list)\n+\n+        if response is not None:\n+            self.send_message(response)\n+\n+    def on_reject(self, message):\n+        \"\"\"Store reject reason and code for testing.\"\"\"\n+        self.reject_code_received = message.code\n+        self.reject_reason_received = message.reason\n+\n+    def send_blocks_and_test(self, blocks, rpc, success=True, request_block=True, reject_code=None, reject_reason=None, timeout=60):\n+        \"\"\"Send blocks to test node and test whether the tip advances.\n+\n+         - add all blocks to our block_store\n+         - send a headers message for the final block\n+         - the on_getheaders handler will ensure that any getheaders are responded to\n+         - if request_block is True: wait for getdata for each of the blocks. The on_getdata handler will\n+           ensure that any getdata messages are responded to\n+         - if success is True: assert that the node's tip advances to the most recent block\n+         - if success is False: assert that the node's tip doesn't advance\n+         - if reject_code and reject_reason are set: assert that the correct reject message is received\"\"\"\n+\n+        with mininode_lock:\n+            self.reject_code_received = None\n+            self.reject_reason_received = None\n+\n+            for block in blocks:\n+                self.block_store[block.sha256] = block\n+                self.last_block_hash = block.sha256\n+\n+        self.send_message(msg_headers([blocks[-1]]))\n+\n+        if request_block:\n+            wait_until(lambda: blocks[-1].sha256 in self.getdata_requests, timeout=timeout, lock=mininode_lock)\n+\n+        if success:\n+            wait_until(lambda: rpc.getbestblockhash() == blocks[-1].hash, timeout=timeout)\n+        else:\n+            assert rpc.getbestblockhash() != blocks[-1].hash\n+\n+        if reject_code is not None:\n+            wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n+        if reject_reason is not None:\n+            wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)\n+\n+    def send_txs_and_test(self, txs, rpc, success=True, reject_code=None, reject_reason=None):\n+        \"\"\"Send txs to test node and test whether they're accepted to the mempool.\n+\n+         - add all txs to our tx_store\n+         - send tx messages for all txs\n+         - if success is True: assert that the tx is accepted to the mempool\n+         - if success is False: assert that the tx is not accepted to the mempool\n+         - if reject_code and reject_reason are set: assert that the correct reject message is received.\"\"\"\n+\n+        with mininode_lock:\n+            self.reject_code_received = None\n+            self.reject_reason_received = None\n+\n+            for tx in txs:\n+                self.tx_store[tx.sha256] = tx\n+\n+        for tx in txs:\n+            self.send_message(msg_tx(tx))\n+\n+        self.sync_with_ping()\n+\n+        raw_mempool = rpc.getrawmempool()\n+        if success:\n+            # Check that all txs are now in the mempool\n+            for tx in txs:\n+                assert tx.hash in raw_mempool, \"{} not found in mempool\".format(tx.hash)\n+        else:\n+            # Check that none of the txs are now in the mempool\n+            for tx in txs:\n+                assert tx.hash not in raw_mempool, \"{} tx found in mempool\".format(tx.hash)\n+\n+        if reject_code is not None:\n+            wait_until(lambda: self.reject_code_received == reject_code, lock=mininode_lock)\n+        if reject_reason is not None:\n+            wait_until(lambda: self.reject_reason_received == reject_reason, lock=mininode_lock)"
      }
    ]
  },
  {
    "sha": "359d06757249b34b36688eaef31e7626a46bd52a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTlkMDY3NTcyNDliMzRiMzY2ODhlYWVmMzFlNzYyNmE0NmJkNTJh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T17:31:58Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-01-30T14:31:31Z"
      },
      "message": "[tests] Fix flake8 warnings in invalidtxrequest",
      "tree": {
        "sha": "fcdce74b27b036e2a6be66ea036cadf16808e360",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcdce74b27b036e2a6be66ea036cadf16808e360"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/359d06757249b34b36688eaef31e7626a46bd52a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/359d06757249b34b36688eaef31e7626a46bd52a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/359d06757249b34b36688eaef31e7626a46bd52a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/359d06757249b34b36688eaef31e7626a46bd52a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c32cf9f62285b5cd18a5064aee91f0802f0f87a8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c32cf9f62285b5cd18a5064aee91f0802f0f87a8"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 10,
      "deletions": 19
    },
    "files": [
      {
        "sha": "66505c1ffbfe62108d6a538784ee215072b17c42",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 10,
        "deletions": 19,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/359d06757249b34b36688eaef31e7626a46bd52a/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/359d06757249b34b36688eaef31e7626a46bd52a/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=359d06757249b34b36688eaef31e7626a46bd52a",
        "patch": "@@ -4,21 +4,17 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test node responses to invalid transactions.\n \n-In this test we connect to one node over p2p, and test tx requests.\n-\"\"\"\n-\n-from test_framework.test_framework import ComparisonTestFramework\n-from test_framework.comptool import TestManager, TestInstance, RejectResult\n-from test_framework.blocktools import *\n+In this test we connect to one node over p2p, and test tx requests.\"\"\"\n import time\n \n+from test_framework.blocktools import create_block, create_coinbase, create_transaction\n+from test_framework.comptool import RejectResult, TestInstance, TestManager\n+from test_framework.messages import COIN\n+from test_framework.mininode import network_thread_start\n+from test_framework.test_framework import ComparisonTestFramework\n \n-\n-# Use the ComparisonTestFramework with 1 node: only use --testbinary.\n class InvalidTxRequestTest(ComparisonTestFramework):\n \n-    ''' Can either run this test as 1 node with expected answers, or two and compare them. \n-        Change the \"outcome\" variable from each TestInstance object to only do the comparison. '''\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n@@ -32,13 +28,10 @@ def run_test(self):\n         test.run()\n \n     def get_tests(self):\n-        if self.tip is None:\n-            self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n-        self.block_time = int(time.time())+1\n+        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n+        self.block_time = int(time.time()) + 1\n \n-        '''\n-        Create a new block with an anyone-can-spend coinbase\n-        '''\n+        self.log.info(\"Create a new block with an anyone-can-spend coinbase.\")\n         height = 1\n         block = create_block(self.tip, create_coinbase(height), self.block_time)\n         self.block_time += 1\n@@ -49,9 +42,7 @@ def get_tests(self):\n         height += 1\n         yield TestInstance([[block, True]])\n \n-        '''\n-        Now we need that block to mature so we can spend the coinbase.\n-        '''\n+        self.log.info(\"Mature the block.\")\n         test = TestInstance(sync_every_block=False)\n         for i in range(100):\n             block = create_block(self.tip, create_coinbase(height), self.block_time)"
      }
    ]
  },
  {
    "sha": "95e2e9af124595aae4801fc9813ee1c294d404cd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NWUyZTlhZjEyNDU5NWFhZTQ4MDFmYzk4MTNlZTFjMjk0ZDQwNGNk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-04-10T13:01:22Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-01-30T14:31:31Z"
      },
      "message": "[tests] Change invalidtxrequest to use BitcoinTestFramework",
      "tree": {
        "sha": "3454e73a7c31e30c1afc4e18aed4d723afa58299",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3454e73a7c31e30c1afc4e18aed4d723afa58299"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95e2e9af124595aae4801fc9813ee1c294d404cd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95e2e9af124595aae4801fc9813ee1c294d404cd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/95e2e9af124595aae4801fc9813ee1c294d404cd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95e2e9af124595aae4801fc9813ee1c294d404cd/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "359d06757249b34b36688eaef31e7626a46bd52a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/359d06757249b34b36688eaef31e7626a46bd52a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/359d06757249b34b36688eaef31e7626a46bd52a"
      }
    ],
    "stats": {
      "total": 51,
      "additions": 21,
      "deletions": 30
    },
    "files": [
      {
        "sha": "64fada38e2cf26c23375d3484e6918e7373367cb",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 21,
        "deletions": 30,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95e2e9af124595aae4801fc9813ee1c294d404cd/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95e2e9af124595aae4801fc9813ee1c294d404cd/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=95e2e9af124595aae4801fc9813ee1c294d404cd",
        "patch": "@@ -5,58 +5,49 @@\n \"\"\"Test node responses to invalid transactions.\n \n In this test we connect to one node over p2p, and test tx requests.\"\"\"\n-import time\n-\n from test_framework.blocktools import create_block, create_coinbase, create_transaction\n-from test_framework.comptool import RejectResult, TestInstance, TestManager\n from test_framework.messages import COIN\n-from test_framework.mininode import network_thread_start\n-from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.mininode import network_thread_start, P2PDataStore\n+from test_framework.test_framework import BitcoinTestFramework\n \n-class InvalidTxRequestTest(ComparisonTestFramework):\n+class InvalidTxRequestTest(BitcoinTestFramework):\n \n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\"]]\n \n     def run_test(self):\n-        test = TestManager(self, self.options.tmpdir)\n-        test.add_all_connections(self.nodes)\n-        self.tip = None\n-        self.block_time = None\n+        # Add p2p connection to node0\n+        node = self.nodes[0]  # convenience reference to the node\n+        node.add_p2p_connection(P2PDataStore())\n+\n         network_thread_start()\n-        test.run()\n+        node.p2p.wait_for_verack()\n \n-    def get_tests(self):\n-        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n-        self.block_time = int(time.time()) + 1\n+        best_block = self.nodes[0].getbestblockhash()\n+        tip = int(best_block, 16)\n+        best_block_time = self.nodes[0].getblock(best_block)['time']\n+        block_time = best_block_time + 1\n \n         self.log.info(\"Create a new block with an anyone-can-spend coinbase.\")\n         height = 1\n-        block = create_block(self.tip, create_coinbase(height), self.block_time)\n-        self.block_time += 1\n+        block = create_block(tip, create_coinbase(height), block_time)\n+        block_time += 1\n         block.solve()\n         # Save the coinbase for later\n-        self.block1 = block\n-        self.tip = block.sha256\n+        block1 = block\n+        tip = block.sha256\n         height += 1\n-        yield TestInstance([[block, True]])\n+        node.p2p.send_blocks_and_test([block], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n-        test = TestInstance(sync_every_block=False)\n-        for i in range(100):\n-            block = create_block(self.tip, create_coinbase(height), self.block_time)\n-            block.solve()\n-            self.tip = block.sha256\n-            self.block_time += 1\n-            test.blocks_and_transactions.append([block, True])\n-            height += 1\n-        yield test\n+        self.nodes[0].generate(100)\n \n         # b'\\x64' is OP_NOTIF\n         # Transaction will be rejected with code 16 (REJECT_INVALID)\n-        tx1 = create_transaction(self.block1.vtx[0], 0, b'\\x64', 50 * COIN - 12000)\n-        yield TestInstance([[tx1, RejectResult(16, b'mandatory-script-verify-flag-failed')]])\n+        tx1 = create_transaction(block1.vtx[0], 0, b'\\x64', 50 * COIN - 12000)\n+        node.p2p.send_txs_and_test([tx1], node, success=False, reject_code=16, reject_reason=b'mandatory-script-verify-flag-failed (Invalid OP_IF construction)')\n \n         # TODO: test further transactions...\n "
      }
    ]
  }
]