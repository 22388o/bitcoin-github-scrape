[
  {
    "sha": "a00eb388e8046fe105666445dff6c91e8f8664cb",
    "node_id": "C_kwDOABII59oAKGEwMGViMzg4ZTgwNDZmZTEwNTY2NjQ0NWRmZjZjOTFlOGY4NjY0Y2I",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-18T18:44:58Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-09-29T20:48:43Z"
      },
      "message": "Allow CInputCoin to also be constructed with COutPoint and CTxOut",
      "tree": {
        "sha": "5823838efd17a1c85fb067014cd0b0e0c815d81a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5823838efd17a1c85fb067014cd0b0e0c815d81a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a00eb388e8046fe105666445dff6c91e8f8664cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a00eb388e8046fe105666445dff6c91e8f8664cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a00eb388e8046fe105666445dff6c91e8f8664cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a00eb388e8046fe105666445dff6c91e8f8664cb/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "419afa93419e6840f78cb94b4a39d826eb10e139",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/419afa93419e6840f78cb94b4a39d826eb10e139",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/419afa93419e6840f78cb94b4a39d826eb10e139"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 12,
      "deletions": 0
    },
    "files": [
      {
        "sha": "78d877a10ba828e707b747f332badc0eeb9210b3",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a00eb388e8046fe105666445dff6c91e8f8664cb/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a00eb388e8046fe105666445dff6c91e8f8664cb/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=a00eb388e8046fe105666445dff6c91e8f8664cb",
        "patch": "@@ -37,6 +37,18 @@ class CInputCoin {\n         m_input_bytes = input_bytes;\n     }\n \n+    CInputCoin(const COutPoint& outpoint_in, const CTxOut& txout_in)\n+    {\n+        outpoint = outpoint_in;\n+        txout = txout_in;\n+        effective_value = txout.nValue;\n+    }\n+\n+    CInputCoin(const COutPoint& outpoint_in, const CTxOut& txout_in, int input_bytes) : CInputCoin(outpoint_in, txout_in)\n+    {\n+        m_input_bytes = input_bytes;\n+    }\n+\n     COutPoint outpoint;\n     CTxOut txout;\n     CAmount effective_value;"
      }
    ]
  },
  {
    "sha": "d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
    "node_id": "C_kwDOABII59oAKGQ1Y2ZiODY0YWUxNmRhNjIzOTliYzk3YWIxZWQ1NGQzMmNmMGNjZTk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-18T21:17:17Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-09-29T20:48:43Z"
      },
      "message": "Allow Coin Selection be able to take external inputs",
      "tree": {
        "sha": "4c6a359a5f1ee2a86778d39b64ec5300211e3b83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c6a359a5f1ee2a86778d39b64ec5300211e3b83"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a00eb388e8046fe105666445dff6c91e8f8664cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a00eb388e8046fe105666445dff6c91e8f8664cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a00eb388e8046fe105666445dff6c91e8f8664cb"
      }
    ],
    "stats": {
      "total": 147,
      "additions": 101,
      "deletions": 46
    },
    "files": [
      {
        "sha": "c989512d3ef60e31018e83088f382a3b908d6a99",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "patch": "@@ -9,9 +9,14 @@\n #include <policy/feerate.h>\n #include <policy/fees.h>\n #include <primitives/transaction.h>\n+#include <script/keyorigin.h>\n+#include <script/signingprovider.h>\n #include <script/standard.h>\n \n #include <optional>\n+#include <algorithm>\n+#include <map>\n+#include <set>\n \n const int DEFAULT_MIN_DEPTH = 0;\n const int DEFAULT_MAX_DEPTH = 9999999;\n@@ -53,6 +58,8 @@ class CCoinControl\n     int m_min_depth = DEFAULT_MIN_DEPTH;\n     //! Maximum chain depth value for coin availability\n     int m_max_depth = DEFAULT_MAX_DEPTH;\n+    //! SigningProvider that has pubkeys and scripts to do spend size estimation for external inputs\n+    FlatSigningProvider m_external_provider;\n \n     CCoinControl();\n \n@@ -66,11 +73,32 @@ class CCoinControl\n         return (setSelected.count(output) > 0);\n     }\n \n+    bool IsExternalSelected(const COutPoint& output) const\n+    {\n+        return (m_external_txouts.count(output) > 0);\n+    }\n+\n+    bool GetExternalOutput(const COutPoint& outpoint, CTxOut& txout) const\n+    {\n+        const auto ext_it = m_external_txouts.find(outpoint);\n+        if (ext_it == m_external_txouts.end()) {\n+            return false;\n+        }\n+        txout = ext_it->second;\n+        return true;\n+    }\n+\n     void Select(const COutPoint& output)\n     {\n         setSelected.insert(output);\n     }\n \n+    void Select(const COutPoint& outpoint, const CTxOut& txout)\n+    {\n+        setSelected.insert(outpoint);\n+        m_external_txouts.emplace(outpoint, txout);\n+    }\n+\n     void UnSelect(const COutPoint& output)\n     {\n         setSelected.erase(output);\n@@ -88,6 +116,7 @@ class CCoinControl\n \n private:\n     std::set<COutPoint> setSelected;\n+    std::map<COutPoint, CTxOut> m_external_txouts;\n };\n \n #endif // BITCOIN_WALLET_COINCONTROL_H"
      },
      {
        "sha": "43fcc0416d6c522b86e252ca85670156fff89489",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 29,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "patch": "@@ -5,6 +5,7 @@\n #include <consensus/validation.h>\n #include <interfaces/chain.h>\n #include <policy/policy.h>\n+#include <script/signingprovider.h>\n #include <util/check.h>\n #include <util/fees.h>\n #include <util/moneystr.h>\n@@ -31,21 +32,27 @@ std::string COutput::ToString() const\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n }\n \n-int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet, bool use_max_sig)\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const SigningProvider* provider, bool use_max_sig)\n {\n     CMutableTransaction txn;\n     txn.vin.push_back(CTxIn(COutPoint()));\n-    if (!wallet->DummySignInput(txn.vin[0], txout, use_max_sig)) {\n+    if (!provider || !DummySignInput(*provider, txn.vin[0], txout, use_max_sig)) {\n         return -1;\n     }\n     return GetVirtualTransactionInputSize(txn.vin[0]);\n }\n \n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet, bool use_max_sig)\n+{\n+    const std::unique_ptr<SigningProvider> provider = wallet->GetSolvingProvider(txout.scriptPubKey);\n+    return CalculateMaximumSignedInputSize(txout, provider.get(), use_max_sig);\n+}\n+\n // txouts needs to be in the order of tx.vin\n-TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, bool use_max_sig)\n+TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts, const CCoinControl* coin_control)\n {\n     CMutableTransaction txNew(tx);\n-    if (!wallet->DummySignTx(txNew, txouts, use_max_sig)) {\n+    if (!wallet->DummySignTx(txNew, txouts, coin_control)) {\n         return TxSize{-1, -1};\n     }\n     CTransaction ctx(txNew);\n@@ -54,19 +61,27 @@ TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *walle\n     return TxSize{vsize, weight};\n }\n \n-TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, bool use_max_sig)\n+TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const CCoinControl* coin_control)\n {\n     std::vector<CTxOut> txouts;\n+    // Look up the inputs. The inputs are either in the wallet, or in coin_control.\n     for (const CTxIn& input : tx.vin) {\n         const auto mi = wallet->mapWallet.find(input.prevout.hash);\n         // Can not estimate size without knowing the input details\n-        if (mi == wallet->mapWallet.end()) {\n+        if (mi != wallet->mapWallet.end()) {\n+            assert(input.prevout.n < mi->second.tx->vout.size());\n+            txouts.emplace_back(mi->second.tx->vout.at(input.prevout.n));\n+        } else if (coin_control) {\n+            CTxOut txout;\n+            if (!coin_control->GetExternalOutput(input.prevout, txout)) {\n+                return TxSize{-1, -1};\n+            }\n+            txouts.emplace_back(txout);\n+        } else {\n             return TxSize{-1, -1};\n         }\n-        assert(input.prevout.n < mi->second.tx->vout.size());\n-        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n     }\n-    return CalculateMaximumSignedTxSize(tx, wallet, txouts, use_max_sig);\n+    return CalculateMaximumSignedTxSize(tx, wallet, txouts, coin_control);\n }\n \n void AvailableCoins(const CWallet& wallet, std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount)\n@@ -435,32 +450,40 @@ bool SelectCoins(const CWallet& wallet, const std::vector<COutput>& vAvailableCo\n \n     std::vector<COutPoint> vPresetInputs;\n     coin_control.ListSelected(vPresetInputs);\n-    for (const COutPoint& outpoint : vPresetInputs)\n-    {\n+    for (const COutPoint& outpoint : vPresetInputs) {\n+        int input_bytes = -1;\n+        CTxOut txout;\n         std::map<uint256, CWalletTx>::const_iterator it = wallet.mapWallet.find(outpoint.hash);\n-        if (it != wallet.mapWallet.end())\n-        {\n+        if (it != wallet.mapWallet.end()) {\n             const CWalletTx& wtx = it->second;\n             // Clearly invalid input, fail\n             if (wtx.tx->vout.size() <= outpoint.n) {\n                 return false;\n             }\n-            // Just to calculate the marginal byte size\n-            CInputCoin coin(wtx.tx, outpoint.n, GetTxSpendSize(wallet, wtx, outpoint.n, false));\n-            nValueFromPresetInputs += coin.txout.nValue;\n-            if (coin.m_input_bytes <= 0) {\n-                return false; // Not solvable, can't estimate size for fee\n-            }\n-            coin.effective_value = coin.txout.nValue - coin_selection_params.m_effective_feerate.GetFee(coin.m_input_bytes);\n-            if (coin_selection_params.m_subtract_fee_outputs) {\n-                value_to_select -= coin.txout.nValue;\n-            } else {\n-                value_to_select -= coin.effective_value;\n+            input_bytes = GetTxSpendSize(wallet, wtx, outpoint.n, false);\n+            txout = wtx.tx->vout.at(outpoint.n);\n+        }\n+        if (input_bytes == -1) {\n+            // The input is external. We either did not find the tx in mapWallet, or we did but couldn't compute the input size with wallet data\n+            if (!coin_control.GetExternalOutput(outpoint, txout)) {\n+                // Not ours, and we don't have solving data.\n+                return false;\n             }\n-            setPresetCoins.insert(coin);\n+            input_bytes = CalculateMaximumSignedInputSize(txout, &coin_control.m_external_provider, /* use_max_sig */ true);\n+        }\n+\n+        CInputCoin coin(outpoint, txout, input_bytes);\n+        nValueFromPresetInputs += coin.txout.nValue;\n+        if (coin.m_input_bytes <= 0) {\n+            return false; // Not solvable, can't estimate size for fee\n+        }\n+        coin.effective_value = coin.txout.nValue - coin_selection_params.m_effective_feerate.GetFee(coin.m_input_bytes);\n+        if (coin_selection_params.m_subtract_fee_outputs) {\n+            value_to_select -= coin.txout.nValue;\n         } else {\n-            return false; // TODO: Allow non-wallet inputs\n+            value_to_select -= coin.effective_value;\n         }\n+        setPresetCoins.insert(coin);\n     }\n \n     // remove preset inputs from vCoins so that Coin Selection doesn't pick them.\n@@ -788,10 +811,10 @@ static bool CreateTransactionInternal(\n     }\n \n     // Calculate the transaction fee\n-    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, coin_control.fAllowWatchOnly);\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, &coin_control);\n     int nBytes = tx_sizes.vsize;\n     if (nBytes < 0) {\n-        error = _(\"Signing transaction failed\");\n+        error = _(\"Missing solving data for estimating transaction size\");\n         return false;\n     }\n     nFeeRet = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n@@ -813,7 +836,7 @@ static bool CreateTransactionInternal(\n         txNew.vout.erase(change_position);\n \n         // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, coin_control.fAllowWatchOnly);\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, &coin_control);\n         nBytes = tx_sizes.vsize;\n         fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n     }"
      },
      {
        "sha": "3a723d9832872d490ac4b1cd8c89bb51fdf973b9",
        "filename": "src/wallet/spend.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/spend.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/spend.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.h?ref=d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "patch": "@@ -66,6 +66,7 @@ class COutput\n \n //Get the marginal bytes of spending the specified output\n int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const SigningProvider* pwallet, bool use_max_sig = false);\n \n struct TxSize {\n     int64_t vsize{-1};\n@@ -76,8 +77,8 @@ struct TxSize {\n * Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n * NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n * be AllInputsMine). */\n-TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n-TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n+TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const std::vector<CTxOut>& txouts, const CCoinControl* coin_control = nullptr);\n+TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const CCoinControl* coin_control = nullptr) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n \n /**\n  * populate vCoins with vector of available COutputs."
      },
      {
        "sha": "2900fb7f93771c8c10d96abcd0dfcb84b93ac92f",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "patch": "@@ -1448,34 +1448,35 @@ bool CWallet::AddWalletFlags(uint64_t flags)\n \n // Helper for producing a max-sized low-S low-R signature (eg 71 bytes)\n // or a max-sized low-S signature (e.g. 72 bytes) if use_max_sig is true\n-bool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout, bool use_max_sig) const\n+bool DummySignInput(const SigningProvider& provider, CTxIn &tx_in, const CTxOut &txout, bool use_max_sig)\n {\n     // Fill in dummy signatures for fee calculation.\n     const CScript& scriptPubKey = txout.scriptPubKey;\n     SignatureData sigdata;\n \n-    std::unique_ptr<SigningProvider> provider = GetSolvingProvider(scriptPubKey);\n-    if (!provider) {\n-        // We don't know about this scriptpbuKey;\n-        return false;\n-    }\n-\n-    if (!ProduceSignature(*provider, use_max_sig ? DUMMY_MAXIMUM_SIGNATURE_CREATOR : DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata)) {\n+    if (!ProduceSignature(provider, use_max_sig ? DUMMY_MAXIMUM_SIGNATURE_CREATOR : DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata)) {\n         return false;\n     }\n     UpdateInput(tx_in, sigdata);\n     return true;\n }\n \n // Helper for producing a bunch of max-sized low-S low-R signatures (eg 71 bytes)\n-bool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts, bool use_max_sig) const\n+bool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts, const CCoinControl* coin_control) const\n {\n     // Fill in dummy signatures for fee calculation.\n     int nIn = 0;\n     for (const auto& txout : txouts)\n     {\n-        if (!DummySignInput(txNew.vin[nIn], txout, use_max_sig)) {\n-            return false;\n+        CTxIn& txin = txNew.vin[nIn];\n+        // Use max sig if watch only inputs were used or if this particular input is an external input\n+        // to ensure a sufficient fee is attained for the requested feerate.\n+        const bool use_max_sig = coin_control && (coin_control->fAllowWatchOnly || coin_control->IsExternalSelected(txin.prevout));\n+        const std::unique_ptr<SigningProvider> provider = GetSolvingProvider(txout.scriptPubKey);\n+        if (!provider || !DummySignInput(*provider, txin, txout, use_max_sig)) {\n+            if (!coin_control || !DummySignInput(coin_control->m_external_provider, txin, txout, use_max_sig)) {\n+                return false;\n+            }\n         }\n \n         nIn++;"
      },
      {
        "sha": "0624e00859157bf209e1b7b792149e3f421d6814",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "patch": "@@ -576,14 +576,13 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n     bool SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const;\n \n-    bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts, bool use_max_sig = false) const\n+    bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts, const CCoinControl* coin_control = nullptr) const\n     {\n         std::vector<CTxOut> v_txouts(txouts.size());\n         std::copy(txouts.begin(), txouts.end(), v_txouts.begin());\n-        return DummySignTx(txNew, v_txouts, use_max_sig);\n+        return DummySignTx(txNew, v_txouts, coin_control);\n     }\n-    bool DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts, bool use_max_sig = false) const;\n-    bool DummySignInput(CTxIn &tx_in, const CTxOut &txout, bool use_max_sig = false) const;\n+    bool DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts, const CCoinControl* coin_control = nullptr) const;\n \n     bool ImportScripts(const std::set<CScript> scripts, int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool ImportPrivKeys(const std::map<CKeyID, CKey>& privkey_map, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n@@ -928,4 +927,6 @@ bool AddWalletSetting(interfaces::Chain& chain, const std::string& wallet_name);\n //! Remove wallet name from persistent configuration so it will not be loaded on startup.\n bool RemoveWalletSetting(interfaces::Chain& chain, const std::string& wallet_name);\n \n+bool DummySignInput(const SigningProvider& provider, CTxIn &tx_in, const CTxOut &txout, bool use_max_sig);\n+\n #endif // BITCOIN_WALLET_WALLET_H"
      }
    ]
  },
  {
    "sha": "38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
    "node_id": "C_kwDOABII59oAKDM4ZjU2NDJjY2NmMmI2NzA4ZTU4ZjVlMmFmNWVjZGNmNzUyZTYxZWM",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-18T23:43:01Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-03T16:57:05Z"
      },
      "message": "allow fundtx rpcs to work with external inputs",
      "tree": {
        "sha": "5861407c5e810bf5feb2de20d75c789d093a4e6b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5861407c5e810bf5feb2de20d75c789d093a4e6b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d5cfb864ae16da62399bc97ab1ed54d32cf0cce9"
      }
    ],
    "stats": {
      "total": 112,
      "additions": 109,
      "deletions": 3
    },
    "files": [
      {
        "sha": "9906fb384c49fc6b2e1307d4c565f59c43ec9be1",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 3,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
        "patch": "@@ -43,6 +43,7 @@\n \n #include <univalue.h>\n \n+#include <map>\n \n using interfaces::FoundBlock;\n \n@@ -3213,6 +3214,7 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n                 {\"fee_rate\", UniValueType()}, // will be checked by AmountFromValue() in SetFeeEstimateMode()\n                 {\"feeRate\", UniValueType()}, // will be checked by AmountFromValue() below\n                 {\"psbt\", UniValueType(UniValue::VBOOL)},\n+                {\"solving_data\", UniValueType(UniValue::VOBJ)},\n                 {\"subtractFeeFromOutputs\", UniValueType(UniValue::VARR)},\n                 {\"subtract_fee_from_outputs\", UniValueType(UniValue::VARR)},\n                 {\"replaceable\", UniValueType(UniValue::VBOOL)},\n@@ -3289,6 +3291,54 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n         coinControl.fAllowWatchOnly = ParseIncludeWatchonly(NullUniValue, wallet);\n     }\n \n+    if (options.exists(\"solving_data\")) {\n+        UniValue solving_data = options[\"solving_data\"].get_obj();\n+        if (solving_data.exists(\"pubkeys\")) {\n+            for (const UniValue& pk_univ : solving_data[\"pubkeys\"].get_array().getValues()) {\n+                const std::string& pk_str = pk_univ.get_str();\n+                if (!IsHex(pk_str)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"'%s' is not hex\", pk_str));\n+                }\n+                const std::vector<unsigned char> data(ParseHex(pk_str));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"'%s' is not a valid public key\", pk_str));\n+                }\n+                coinControl.m_external_provider.pubkeys.emplace(pubkey.GetID(), pubkey);\n+                // Add witness script for pubkeys\n+                const CScript wit_script = GetScriptForDestination(WitnessV0KeyHash(pubkey));\n+                coinControl.m_external_provider.scripts.emplace(CScriptID(wit_script), wit_script);\n+            }\n+        }\n+\n+        if (solving_data.exists(\"scripts\")) {\n+            for (const UniValue& script_univ : solving_data[\"scripts\"].get_array().getValues()) {\n+                const std::string& script_str = script_univ.get_str();\n+                if (!IsHex(script_str)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"'%s' is not hex\", script_str));\n+                }\n+                std::vector<unsigned char> script_data(ParseHex(script_str));\n+                const CScript script(script_data.begin(), script_data.end());\n+                coinControl.m_external_provider.scripts.emplace(CScriptID(script), script);\n+            }\n+        }\n+\n+        if (solving_data.exists(\"descriptors\")) {\n+            for (const UniValue& desc_univ : solving_data[\"descriptors\"].get_array().getValues()) {\n+                const std::string& desc_str  = desc_univ.get_str();\n+                FlatSigningProvider desc_out;\n+                std::string error;\n+                std::vector<CScript> scripts_temp;\n+                std::unique_ptr<Descriptor> desc = Parse(desc_str, desc_out, error, true);\n+                if (!desc) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Unable to parse descriptor '%s': %s\", desc_str, error));\n+                }\n+                desc->Expand(0, desc_out, scripts_temp, desc_out);\n+                coinControl.m_external_provider = Merge(coinControl.m_external_provider, desc_out);\n+            }\n+        }\n+    }\n+\n     if (tx.vout.size() == 0)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"TX must have at least one output\");\n \n@@ -3306,6 +3356,19 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n         setSubtractFeeFromOutputs.insert(pos);\n     }\n \n+    // Fetch specified UTXOs from the UTXO set to get the scriptPubKeys and values of the outputs being selected\n+    // and to match with the given solving_data. Only used for non-wallet outputs.\n+    std::map<COutPoint, Coin> coins;\n+    for (const CTxIn& txin : tx.vin) {\n+        coins[txin.prevout]; // Create empty map entry keyed by prevout.\n+    }\n+    wallet.chain().findCoins(coins);\n+    for (const auto& coin : coins) {\n+        if (!coin.second.out.IsNull()) {\n+            coinControl.Select(coin.first, coin.second.out);\n+        }\n+    }\n+\n     bilingual_str error;\n \n     if (!FundTransaction(wallet, tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n@@ -3321,8 +3384,9 @@ static RPCHelpMan fundrawtransaction()\n                 \"No existing outputs will be modified unless \\\"subtractFeeFromOutputs\\\" is specified.\\n\"\n                 \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n                 \"The inputs added will not be signed, use signrawtransactionwithkey\\n\"\n-                \" or signrawtransactionwithwallet for that.\\n\"\n-                \"Note that all existing inputs must have their previous output transaction be in the wallet.\\n\"\n+                \"or signrawtransactionwithwallet for that.\\n\"\n+                \"All existing inputs must either have their previous output transaction be in the wallet\\n\"\n+                \"or be in the UTXO set. Solving data must be provided for non-wallet inputs.\\n\"\n                 \"Note that all inputs selected must be of standard form and P2SH scripts must be\\n\"\n                 \"in the wallet using importaddress or addmultisigaddress (to calculate fees).\\n\"\n                 \"You can see whether this is the case by checking the \\\"solvable\\\" field in the listunspent output.\\n\"\n@@ -3357,6 +3421,26 @@ static RPCHelpMan fundrawtransaction()\n                             {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n                             {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n                             \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+                            {\"solving_data\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"Keys and scripts needed for producing a final transaction with a dummy signature.\\n\"\n+                                \"Used for fee estimation during coin selection.\",\n+                                {\n+                                    {\"pubkeys\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Public keys involved in this transaction.\",\n+                                        {\n+                                            {\"pubkey\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"A public key\"},\n+                                        },\n+                                    },\n+                                    {\"scripts\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Scripts involved in this transaction.\",\n+                                        {\n+                                            {\"script\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"A script\"},\n+                                        },\n+                                    },\n+                                    {\"descriptors\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Descriptors that provide solving data for this transaction.\",\n+                                        {\n+                                            {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"A descriptor\"},\n+                                        },\n+                                    }\n+                                }\n+                            },\n                         },\n                         \"options\"},\n                     {\"iswitness\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"depends on heuristic tests\"}, \"Whether the transaction hex is a serialized witness transaction.\\n\"\n@@ -4489,7 +4573,9 @@ static RPCHelpMan walletcreatefundedpsbt()\n {\n     return RPCHelpMan{\"walletcreatefundedpsbt\",\n                 \"\\nCreates and funds a transaction in the Partially Signed Transaction format.\\n\"\n-                \"Implements the Creator and Updater roles.\\n\",\n+                \"Implements the Creator and Updater roles.\\n\"\n+                \"All existing inputs must either have their previous output transaction be in the wallet\\n\"\n+                \"or be in the UTXO set. Solving data must be provided for non-wallet inputs.\\n\",\n                 {\n                     {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Leave empty to add inputs automatically. See add_inputs option.\",\n                         {\n@@ -4546,6 +4632,26 @@ static RPCHelpMan walletcreatefundedpsbt()\n                             {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n                             {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n                             \"         \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+                            {\"solving_data\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"Keys and scripts needed for producing a final transaction with a dummy signature.\\n\"\n+                                \"Used for fee estimation during coin selection.\",\n+                                {\n+                                    {\"pubkeys\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Public keys involved in this transaction.\",\n+                                        {\n+                                            {\"pubkey\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"A public key\"},\n+                                        },\n+                                    },\n+                                    {\"scripts\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Scripts involved in this transaction.\",\n+                                        {\n+                                            {\"script\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"A script\"},\n+                                        },\n+                                    },\n+                                    {\"descriptors\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Descriptors that provide solving data for this transaction.\",\n+                                        {\n+                                            {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"A descriptor\"},\n+                                        },\n+                                    }\n+                                }\n+                            },\n                         },\n                         \"options\"},\n                     {\"bip32derivs\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"Include BIP 32 derivation paths for public keys if we know them\"},"
      }
    ]
  },
  {
    "sha": "e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
    "node_id": "C_kwDOABII59oAKGUzOWI1YTVlN2FhNGQwMTUyNTc1NjVjYTc5ZGM3YjFmN2E2NWUwNzQ",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2019-10-21T20:55:07Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-03T17:24:14Z"
      },
      "message": "Tests for funding with external inputs",
      "tree": {
        "sha": "0a3196eabe8ab0144b0224fafa5c4941b629217d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a3196eabe8ab0144b0224fafa5c4941b629217d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/38f5642cccf2b6708e58f5e2af5ecdcf752e61ec"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 94,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3b015069861bcc4a315a8c30cbd744a27cf74697",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
        "patch": "@@ -8,6 +8,7 @@\n from itertools import product\n \n from test_framework.descriptors import descsum_create\n+from test_framework.key import ECKey\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_approx,\n@@ -19,6 +20,7 @@\n     count_bytes,\n     find_vout_for_address,\n )\n+from test_framework.wallet_util import bytes_to_wif\n \n \n def get_unspent(listunspent, amount):\n@@ -132,6 +134,7 @@ def run_test(self):\n         self.test_subtract_fee_with_presets()\n         self.test_transaction_too_large()\n         self.test_include_unsafe()\n+        self.test_external_inputs()\n         self.test_22670()\n \n     def test_change_position(self):\n@@ -983,6 +986,56 @@ def test_transaction_too_large(self):\n         wallet.sendmany(\"\", outputs)\n         self.generate(self.nodes[0], 10)\n         assert_raises_rpc_error(-4, \"Transaction too large\", recipient.fundrawtransaction, rawtx)\n+        self.nodes[0].unloadwallet(\"large\")\n+\n+    def test_external_inputs(self):\n+        self.log.info(\"Test funding with external inputs\")\n+\n+        eckey = ECKey()\n+        eckey.generate()\n+        privkey = bytes_to_wif(eckey.get_bytes())\n+\n+        self.nodes[2].createwallet(\"extfund\")\n+        wallet = self.nodes[2].get_wallet_rpc(\"extfund\")\n+\n+        # Make a weird but signable script. sh(pkh()) descriptor accomplishes this\n+        desc = descsum_create(\"sh(pkh({}))\".format(privkey))\n+        if self.options.descriptors:\n+            res = self.nodes[0].importdescriptors([{\"desc\": desc, \"timestamp\": \"now\"}])\n+        else:\n+            res = self.nodes[0].importmulti([{\"desc\": desc, \"timestamp\": \"now\"}])\n+        assert res[0][\"success\"]\n+        addr = self.nodes[0].deriveaddresses(desc)[0]\n+        addr_info = self.nodes[0].getaddressinfo(addr)\n+\n+        self.nodes[0].sendtoaddress(addr, 10)\n+        self.nodes[0].sendtoaddress(wallet.getnewaddress(), 10)\n+        self.nodes[0].generate(6)\n+        ext_utxo = self.nodes[0].listunspent(addresses=[addr])[0]\n+\n+        # An external input without solving data should result in an error\n+        raw_tx = wallet.createrawtransaction([ext_utxo], {self.nodes[0].getnewaddress(): 15})\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", wallet.fundrawtransaction, raw_tx)\n+\n+        # Error conditions\n+        assert_raises_rpc_error(-5, \"'not a pubkey' is not hex\", wallet.fundrawtransaction, raw_tx, {\"solving_data\": {\"pubkeys\":[\"not a pubkey\"]}})\n+        assert_raises_rpc_error(-5, \"'01234567890a0b0c0d0e0f' is not a valid public key\", wallet.fundrawtransaction, raw_tx, {\"solving_data\": {\"pubkeys\":[\"01234567890a0b0c0d0e0f\"]}})\n+        assert_raises_rpc_error(-5, \"'not a script' is not hex\", wallet.fundrawtransaction, raw_tx, {\"solving_data\": {\"scripts\":[\"not a script\"]}})\n+        assert_raises_rpc_error(-8, \"Unable to parse descriptor 'not a descriptor'\", wallet.fundrawtransaction, raw_tx, {\"solving_data\": {\"descriptors\":[\"not a descriptor\"]}})\n+\n+        # But funding should work when the solving data is provided\n+        funded_tx = wallet.fundrawtransaction(raw_tx, {\"solving_data\": {\"pubkeys\": [addr_info['pubkey']], \"scripts\": [addr_info[\"embedded\"][\"scriptPubKey\"]]}})\n+        signed_tx = wallet.signrawtransactionwithwallet(funded_tx['hex'])\n+        assert not signed_tx['complete']\n+        signed_tx = self.nodes[0].signrawtransactionwithwallet(signed_tx['hex'])\n+        assert signed_tx['complete']\n+\n+        funded_tx = wallet.fundrawtransaction(raw_tx, {\"solving_data\": {\"descriptors\": [desc]}})\n+        signed_tx = wallet.signrawtransactionwithwallet(funded_tx['hex'])\n+        assert not signed_tx['complete']\n+        signed_tx = self.nodes[0].signrawtransactionwithwallet(signed_tx['hex'])\n+        assert signed_tx['complete']\n+        self.nodes[2].unloadwallet(\"extfund\")\n \n     def test_include_unsafe(self):\n         self.log.info(\"Test fundrawtxn with unsafe inputs\")\n@@ -1017,6 +1070,7 @@ def test_include_unsafe(self):\n         assert all((txin[\"txid\"], txin[\"vout\"]) in inputs for txin in tx_dec[\"vin\"])\n         signedtx = wallet.signrawtransactionwithwallet(fundedtx['hex'])\n         assert wallet.testmempoolaccept([signedtx['hex']])[0][\"allowed\"]\n+        self.nodes[0].unloadwallet(\"unsafe\")\n \n     def test_22670(self):\n         # In issue #22670, it was observed that ApproximateBestSubset may"
      },
      {
        "sha": "6b5b2c6a0f3f5baaf69d71c4e634122ac61d62c9",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
        "patch": "@@ -8,6 +8,8 @@\n from decimal import Decimal\n from itertools import product\n \n+from test_framework.descriptors import descsum_create\n+from test_framework.key import ECKey\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_approx,\n@@ -16,6 +18,7 @@\n     assert_raises_rpc_error,\n     find_output,\n )\n+from test_framework.wallet_util import bytes_to_wif\n \n import json\n import os\n@@ -608,5 +611,42 @@ def test_psbt_input_keys(psbt_input, keys):\n \n         assert_raises_rpc_error(-25, 'Inputs missing or spent', self.nodes[0].walletprocesspsbt, 'cHNidP8BAJoCAAAAAkvEW8NnDtdNtDpsmze+Ht2LH35IJcKv00jKAlUs21RrAwAAAAD/////S8Rbw2cO1020OmybN74e3Ysffkglwq/TSMoCVSzbVGsBAAAAAP7///8CwLYClQAAAAAWABSNJKzjaUb3uOxixsvh1GGE3fW7zQD5ApUAAAAAFgAUKNw0x8HRctAgmvoevm4u1SbN7XIAAAAAAAEAnQIAAAACczMa321tVHuN4GKWKRncycI22aX3uXgwSFUKM2orjRsBAAAAAP7///9zMxrfbW1Ue43gYpYpGdzJwjbZpfe5eDBIVQozaiuNGwAAAAAA/v///wIA+QKVAAAAABl2qRT9zXUVA8Ls5iVqynLHe5/vSe1XyYisQM0ClQAAAAAWABRmWQUcjSjghQ8/uH4Bn/zkakwLtAAAAAAAAQEfQM0ClQAAAAAWABRmWQUcjSjghQ8/uH4Bn/zkakwLtAAAAA==')\n \n+        # Test that we can fund psbts with external inputs specified\n+        eckey = ECKey()\n+        eckey.generate()\n+        privkey = bytes_to_wif(eckey.get_bytes())\n+\n+        # Make a weird but signable script. sh(pkh()) descriptor accomplishes this\n+        desc = descsum_create(\"sh(pkh({}))\".format(privkey))\n+        if self.options.descriptors:\n+            res = self.nodes[0].importdescriptors([{\"desc\": desc, \"timestamp\": \"now\"}])\n+        else:\n+            res = self.nodes[0].importmulti([{\"desc\": desc, \"timestamp\": \"now\"}])\n+        assert res[0][\"success\"]\n+        addr = self.nodes[0].deriveaddresses(desc)[0]\n+        addr_info = self.nodes[0].getaddressinfo(addr)\n+\n+        self.nodes[0].sendtoaddress(addr, 10)\n+        self.nodes[0].generate(6)\n+        ext_utxo = self.nodes[0].listunspent(addresses=[addr])[0]\n+\n+        # An external input without solving data should result in an error\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[1].walletcreatefundedpsbt, [ext_utxo], {self.nodes[0].getnewaddress(): 10 + ext_utxo['amount']}, 0, {'add_inputs': True})\n+\n+        # But funding should work when the solving data is provided\n+        psbt = self.nodes[1].walletcreatefundedpsbt([ext_utxo], {self.nodes[0].getnewaddress(): 15}, 0, {'add_inputs': True, \"solving_data\": {\"pubkeys\": [addr_info['pubkey']], \"scripts\": [addr_info[\"embedded\"][\"scriptPubKey\"]]}})\n+        signed = self.nodes[1].walletprocesspsbt(psbt['psbt'])\n+        assert not signed['complete']\n+        signed = self.nodes[0].walletprocesspsbt(signed['psbt'])\n+        assert signed['complete']\n+        self.nodes[0].finalizepsbt(signed['psbt'])\n+\n+        psbt = self.nodes[1].walletcreatefundedpsbt([ext_utxo], {self.nodes[0].getnewaddress(): 15}, 0, {'add_inputs': True, \"solving_data\":{\"descriptors\": [desc]}})\n+        signed = self.nodes[1].walletprocesspsbt(psbt['psbt'])\n+        assert not signed['complete']\n+        signed = self.nodes[0].walletprocesspsbt(signed['psbt'])\n+        assert signed['complete']\n+        self.nodes[0].finalizepsbt(signed['psbt'])\n+\n if __name__ == '__main__':\n     PSBTTest().main()"
      }
    ]
  },
  {
    "sha": "928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9",
    "node_id": "C_kwDOABII59oAKDkyOGFmNjFjZGIyYzRkZTFjM2QxMGU2ZmRhMTNiYmJhNWNhMGJiYTk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-01-12T20:17:29Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2021-10-03T17:24:14Z"
      },
      "message": "allow send rpc take external inputs and solving data",
      "tree": {
        "sha": "f3b5346681dfe30ac20141936eb22ce9afe92522",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3b5346681dfe30ac20141936eb22ce9afe92522"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e39b5a5e7aa4d015257565ca79dc7b1f7a65e074"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 65,
      "deletions": 1
    },
    "files": [
      {
        "sha": "09081943d3c6ed85609504e498c0a35d15fbbe55",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9",
        "patch": "@@ -4286,6 +4286,26 @@ static RPCHelpMan send()\n                     },\n                     {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"}, \"Marks this transaction as BIP125 replaceable.\\n\"\n                                                   \"Allows this transaction to be replaced by a transaction with higher fees\"},\n+                    {\"solving_data\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"Keys and scripts needed for producing a final transaction with a dummy signature.\\n\"\n+                        \"Used for fee estimation during coin selection.\",\n+                        {\n+                            {\"pubkeys\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Public keys involved in this transaction.\",\n+                                {\n+                                    {\"pubkey\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"A public key\"},\n+                                },\n+                            },\n+                            {\"scripts\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Scripts involved in this transaction.\",\n+                                {\n+                                    {\"script\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"A script\"},\n+                                },\n+                            },\n+                            {\"descriptors\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Descriptors that provide solving data for this transaction.\",\n+                                {\n+                                    {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"A descriptor\"},\n+                                },\n+                            }\n+                        }\n+                    },\n                 },\n                 \"options\"},\n         },"
      },
      {
        "sha": "7b23235945aaf42866cc9dc80a13fb9652e68b4e",
        "filename": "test/functional/wallet_send.py",
        "status": "modified",
        "additions": 45,
        "deletions": 1,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9/test/functional/wallet_send.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9/test/functional/wallet_send.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_send.py?ref=928af61cdb2c4de1c3d10e6fda13bbba5ca0bba9",
        "patch": "@@ -9,13 +9,15 @@\n \n from test_framework.authproxy import JSONRPCException\n from test_framework.descriptors import descsum_create\n+from test_framework.key import ECKey\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_fee_amount,\n     assert_greater_than,\n     assert_raises_rpc_error,\n )\n+from test_framework.wallet_util import bytes_to_wif\n \n class WalletSendTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -35,7 +37,7 @@ def test_send(self, from_wallet, to_wallet=None, amount=None, data=None,\n                   conf_target=None, estimate_mode=None, fee_rate=None, add_to_wallet=None, psbt=None,\n                   inputs=None, add_inputs=None, include_unsafe=None, change_address=None, change_position=None, change_type=None,\n                   include_watching=None, locktime=None, lock_unspents=None, replaceable=None, subtract_fee_from_outputs=None,\n-                  expect_error=None):\n+                  expect_error=None, solving_data=None):\n         assert (amount is None) != (data is None)\n \n         from_balance_before = from_wallet.getbalances()[\"mine\"][\"trusted\"]\n@@ -94,6 +96,8 @@ def test_send(self, from_wallet, to_wallet=None, amount=None, data=None,\n             options[\"replaceable\"] = replaceable\n         if subtract_fee_from_outputs is not None:\n             options[\"subtract_fee_from_outputs\"] = subtract_fee_from_outputs\n+        if solving_data is not None:\n+            options[\"solving_data\"] = solving_data\n \n         if len(options.keys()) == 0:\n             options = None\n@@ -476,6 +480,46 @@ def run_test(self):\n         res = self.test_send(from_wallet=w5, to_wallet=w0, amount=1, include_unsafe=True)\n         assert res[\"complete\"]\n \n+        self.log.info(\"External outputs\")\n+        eckey = ECKey()\n+        eckey.generate()\n+        privkey = bytes_to_wif(eckey.get_bytes())\n+\n+        self.nodes[1].createwallet(\"extsend\")\n+        ext_wallet = self.nodes[1].get_wallet_rpc(\"extsend\")\n+        self.nodes[1].createwallet(\"extfund\")\n+        ext_fund = self.nodes[1].get_wallet_rpc(\"extfund\")\n+\n+        # Make a weird but signable script. sh(pkh()) descriptor accomplishes this\n+        desc = descsum_create(\"sh(pkh({}))\".format(privkey))\n+        if self.options.descriptors:\n+            res = ext_fund.importdescriptors([{\"desc\": desc, \"timestamp\": \"now\"}])\n+        else:\n+            res = ext_fund.importmulti([{\"desc\": desc, \"timestamp\": \"now\"}])\n+        assert res[0][\"success\"]\n+        addr = self.nodes[0].deriveaddresses(desc)[0]\n+        addr_info = ext_fund.getaddressinfo(addr)\n+\n+        self.nodes[0].sendtoaddress(addr, 10)\n+        self.nodes[0].sendtoaddress(ext_wallet.getnewaddress(), 10)\n+        self.nodes[0].generate(6)\n+        ext_utxo = ext_fund.listunspent(addresses=[addr])[0]\n+\n+        # An external input without solving data should result in an error\n+        self.test_send(from_wallet=ext_wallet, to_wallet=self.nodes[0], amount=15, inputs=[ext_utxo], add_inputs=True, psbt=True, include_watching=True, expect_error=(-4, \"Insufficient funds\"))\n+\n+        # But funding should work when the solving data is provided\n+        res = self.test_send(from_wallet=ext_wallet, to_wallet=self.nodes[0], amount=15, inputs=[ext_utxo], add_inputs=True, psbt=True, include_watching=True, solving_data={\"pubkeys\": [addr_info['pubkey']], \"scripts\": [addr_info[\"embedded\"][\"scriptPubKey\"]]})\n+        signed = ext_wallet.walletprocesspsbt(res[\"psbt\"])\n+        signed = ext_fund.walletprocesspsbt(res[\"psbt\"])\n+        assert signed[\"complete\"]\n+        self.nodes[0].finalizepsbt(signed[\"psbt\"])\n+\n+        res = self.test_send(from_wallet=ext_wallet, to_wallet=self.nodes[0], amount=15, inputs=[ext_utxo], add_inputs=True, psbt=True, include_watching=True, solving_data={\"descriptors\": [desc]})\n+        signed = ext_wallet.walletprocesspsbt(res[\"psbt\"])\n+        signed = ext_fund.walletprocesspsbt(res[\"psbt\"])\n+        assert signed[\"complete\"]\n+        self.nodes[0].finalizepsbt(signed[\"psbt\"])\n \n if __name__ == '__main__':\n     WalletSendTest().main()"
      }
    ]
  }
]