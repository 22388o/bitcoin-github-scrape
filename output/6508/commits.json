[
  {
    "sha": "ee60e5625bf8a11c8e5509b9cea8b6465056c448",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTYwZTU2MjViZjhhMTFjOGU1NTA5YjljZWE4YjY0NjUwNTZjNDQ4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-17T16:35:40Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-27T14:31:01Z"
      },
      "message": "Add merkle.{h,cpp}, generic merkle root/branch algorithm",
      "tree": {
        "sha": "4369d0745993de5ee1b347d67bd37f6284b753a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4369d0745993de5ee1b347d67bd37f6284b753a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee60e5625bf8a11c8e5509b9cea8b6465056c448",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee60e5625bf8a11c8e5509b9cea8b6465056c448",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee60e5625bf8a11c8e5509b9cea8b6465056c448",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee60e5625bf8a11c8e5509b9cea8b6465056c448/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "93e0514fd083971dcef1fea8d107895244270f4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93e0514fd083971dcef1fea8d107895244270f4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/93e0514fd083971dcef1fea8d107895244270f4c"
      }
    ],
    "stats": {
      "total": 171,
      "additions": 171,
      "deletions": 0
    },
    "files": [
      {
        "sha": "40f2e19af03f67f8e23c255d2a800626e304a483",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee60e5625bf8a11c8e5509b9cea8b6465056c448/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee60e5625bf8a11c8e5509b9cea8b6465056c448/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ee60e5625bf8a11c8e5509b9cea8b6465056c448",
        "patch": "@@ -100,6 +100,7 @@ BITCOIN_CORE_H = \\\n   compat/sanity.h \\\n   compressor.h \\\n   consensus/consensus.h \\\n+  consensus/merkle.h \\\n   consensus/params.h \\\n   consensus/validation.h \\\n   core_io.h \\\n@@ -268,6 +269,7 @@ libbitcoin_common_a_SOURCES = \\\n   chainparams.cpp \\\n   coins.cpp \\\n   compressor.cpp \\\n+  consensus/merkle.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\\n   hash.cpp \\"
      },
      {
        "sha": "6be9c26df241e806671a639c1ce7c96600fb5f25",
        "filename": "src/consensus/merkle.cpp",
        "status": "added",
        "additions": 152,
        "deletions": 0,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee60e5625bf8a11c8e5509b9cea8b6465056c448/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee60e5625bf8a11c8e5509b9cea8b6465056c448/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=ee60e5625bf8a11c8e5509b9cea8b6465056c448",
        "patch": "@@ -0,0 +1,152 @@\n+#include \"merkle.h\"\n+#include \"hash.h\"\n+#include \"utilstrencodings.h\"\n+\n+/*     WARNING! If you're reading this because you're learning about crypto\n+       and/or designing a new system that will use merkle trees, keep in mind\n+       that the following merkle tree algorithm has a serious flaw related to\n+       duplicate txids, resulting in a vulnerability (CVE-2012-2459).\n+\n+       The reason is that if the number of hashes in the list at a given time\n+       is odd, the last one is duplicated before computing the next level (which\n+       is unusual in Merkle trees). This results in certain sequences of\n+       transactions leading to the same merkle root. For example, these two\n+       trees:\n+\n+                    A               A\n+                  /  \\            /   \\\n+                B     C         B       C\n+               / \\    |        / \\     / \\\n+              D   E   F       D   E   F   F\n+             / \\ / \\ / \\     / \\ / \\ / \\ / \\\n+             1 2 3 4 5 6     1 2 3 4 5 6 5 6\n+\n+       for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and\n+       6 are repeated) result in the same root hash A (because the hash of both\n+       of (F) and (F,F) is C).\n+\n+       The vulnerability results from being able to send a block with such a\n+       transaction list, with the same merkle root, and the same block hash as\n+       the original without duplication, resulting in failed validation. If the\n+       receiving node proceeds to mark that block as permanently invalid\n+       however, it will fail to accept further unmodified (and thus potentially\n+       valid) versions of the same block. We defend against this by detecting\n+       the case where we would hash two identical hashes at the end of the list\n+       together, and treating that identically to the block having an invalid\n+       merkle root. Assuming no double-SHA256 collisions, this will detect all\n+       known ways of changing the transactions without affecting the merkle\n+       root.\n+*/\n+\n+/* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */\n+static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector<uint256>* pbranch) {\n+    if (pbranch) pbranch->clear();\n+    if (leaves.size() == 0) {\n+        if (pmutated) *pmutated = false;\n+        if (proot) *proot = uint256();\n+        return;\n+    }\n+    bool mutated = false;\n+    // count is the number of leaves processed so far.\n+    uint32_t count = 0;\n+    // inner is an array of eagerly computed subtree hashes, indexed by tree\n+    // level (0 being the leaves).\n+    // For example, when count is 25 (11001 in binary), inner[4] is the hash of\n+    // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to\n+    // the last leaf. The other inner entries are undefined.\n+    uint256 inner[32];\n+    // Which position in inner is a hash that depends on the matching leaf.\n+    int matchlevel = -1;\n+    // First process all leaves into 'inner' values.\n+    while (count < leaves.size()) {\n+        uint256 h = leaves[count];\n+        bool matchh = count == branchpos;\n+        count++;\n+        int level;\n+        // For each of the lower bits in count that are 0, do 1 step. Each\n+        // corresponds to an inner value that existed before processing the\n+        // current leaf, and each needs a hash to combine it.\n+        for (level = 0; !(count & (((uint32_t)1) << level)); level++) {\n+            if (pbranch) {\n+                if (matchh) {\n+                    pbranch->push_back(inner[level]);\n+                } else if (matchlevel == level) {\n+                    pbranch->push_back(h);\n+                    matchh = true;\n+                }\n+            }\n+            mutated |= (inner[level] == h);\n+            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+        }\n+        // Store the resulting hash at inner position level.\n+        inner[level] = h;\n+        if (matchh) {\n+            matchlevel = level;\n+        }\n+    }\n+    // Do a final 'sweep' over the rightmost branch of the tree to process\n+    // odd levels, and reduce everything to a single top value.\n+    // Level is the level (counted from the bottom) up to which we've sweeped.\n+    int level = 0;\n+    // As long as bit number level in count is zero, skip it. It means there\n+    // is nothing left at this level.\n+    while (!(count & (((uint32_t)1) << level))) {\n+        level++;\n+    }\n+    uint256 h = inner[level];\n+    bool matchh = matchlevel == level;\n+    while (count != (((uint32_t)1) << level)) {\n+        // If we reach this point, h is an inner value that is not the top.\n+        // We combine it with itself (Bitcoin's special rule for odd levels in\n+        // the tree) to produce a higher level one.\n+        if (pbranch && matchh) {\n+            pbranch->push_back(h);\n+        }\n+        CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+        // Increment count to the value it would have if two entries at this\n+        // level had existed.\n+        count += (((uint32_t)1) << level);\n+        level++;\n+        // And propagate the result upwards accordingly.\n+        while (!(count & (((uint32_t)1) << level))) {\n+            if (pbranch) {\n+                if (matchh) {\n+                    pbranch->push_back(inner[level]);\n+                } else if (matchlevel == level) {\n+                    pbranch->push_back(h);\n+                    matchh = true;\n+                }\n+            }\n+            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());\n+            level++;\n+        }\n+    }\n+    // Return result.\n+    if (pmutated) *pmutated = mutated;\n+    if (proot) *proot = h;\n+}\n+\n+uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated) {\n+    uint256 hash;\n+    MerkleComputation(leaves, &hash, mutated, -1, NULL);\n+    return hash;\n+}\n+\n+std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position) {\n+    std::vector<uint256> ret;\n+    MerkleComputation(leaves, NULL, NULL, position, &ret);\n+    return ret;\n+}\n+\n+uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& vMerkleBranch, uint32_t nIndex) {\n+    uint256 hash = leaf;\n+    for (std::vector<uint256>::const_iterator it = vMerkleBranch.begin(); it != vMerkleBranch.end(); ++it) {\n+        if (nIndex & 1) {\n+            hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));\n+        } else {\n+            hash = Hash(BEGIN(hash), END(hash), BEGIN(*it), END(*it));\n+        }\n+        nIndex >>= 1;\n+    }\n+    return hash;\n+}"
      },
      {
        "sha": "7fd13d3e4325d903aedd9f9b8b6d74deba403e07",
        "filename": "src/consensus/merkle.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee60e5625bf8a11c8e5509b9cea8b6465056c448/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee60e5625bf8a11c8e5509b9cea8b6465056c448/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=ee60e5625bf8a11c8e5509b9cea8b6465056c448",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MERKLE\n+#define BITCOIN_MERKLE\n+\n+#include <stdint.h>\n+#include <vector>\n+\n+#include \"uint256.h\"\n+\n+uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = NULL);\n+std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position);\n+uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t position);\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZWNlNjNmYTcyNTY2MDY4Y2IyYTFiZjg1Yzk1YTcyYTViYTU5YmM5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-17T16:35:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-27T14:36:52Z"
      },
      "message": "Switch blocks to a constant-space Merkle root/branch algorithm.\n\nThis switches the Merkle tree logic for blocks to one that runs in constant (small) space.\nThe old code is moved to tests, and a new test is added that for various combinations of\nblock sizes, transaction positions to compute a branch for, and mutations:\n * Verifies that the old code and new code agree for the Merkle root.\n * Verifies that the old code and new code agree for the Merkle branch.\n * Verifies that the computed Merkle branch is valid.\n * Verifies that mutations don't change the Merkle root.\n * Verifies that mutations are correctly detected.",
      "tree": {
        "sha": "093633b56700e77f3bc4d8fda2b3032d2aa7c4dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/093633b56700e77f3bc4d8fda2b3032d2aa7c4dd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ee60e5625bf8a11c8e5509b9cea8b6465056c448",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee60e5625bf8a11c8e5509b9cea8b6465056c448",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ee60e5625bf8a11c8e5509b9cea8b6465056c448"
      }
    ],
    "stats": {
      "total": 257,
      "additions": 182,
      "deletions": 75
    },
    "files": [
      {
        "sha": "c377183ad53ab143a7f5fbe5aee42dd061914f33",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -57,6 +57,7 @@ BITCOIN_TESTS =\\\n   test/dbwrapper_tests.cpp \\\n   test/main_tests.cpp \\\n   test/mempool_tests.cpp \\\n+  test/merkle_tests.cpp \\\n   test/miner_tests.cpp \\\n   test/mruset_tests.cpp \\\n   test/multisig_tests.cpp \\"
      },
      {
        "sha": "a46866a2be8fd8bb1c0573aba241293fd96fb12d",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"chainparams.h\"\n+#include \"consensus/merkle.h\"\n \n #include \"tinyformat.h\"\n #include \"util.h\"\n@@ -32,7 +33,7 @@ static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesi\n     genesis.nVersion = nVersion;\n     genesis.vtx.push_back(txNew);\n     genesis.hashPrevBlock.SetNull();\n-    genesis.hashMerkleRoot = genesis.ComputeMerkleRoot();\n+    genesis.hashMerkleRoot = BlockMerkleRoot(genesis);\n     return genesis;\n }\n "
      },
      {
        "sha": "9a8afa8a33f3b2043dac36a009ae46c5254883a0",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -150,3 +150,23 @@ uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint2\n     }\n     return hash;\n }\n+\n+uint256 BlockMerkleRoot(const CBlock& block, bool* mutated)\n+{\n+    std::vector<uint256> leaves;\n+    leaves.resize(block.vtx.size());\n+    for (size_t s = 0; s < block.vtx.size(); s++) {\n+        leaves[s] = block.vtx[s].GetHash();\n+    }\n+    return ComputeMerkleRoot(leaves, mutated);\n+}\n+\n+std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n+{\n+    std::vector<uint256> leaves;\n+    leaves.resize(block.vtx.size());\n+    for (size_t s = 0; s < block.vtx.size(); s++) {\n+        leaves[s] = block.vtx[s].GetHash();\n+    }\n+    return ComputeMerkleBranch(leaves, position);\n+}"
      },
      {
        "sha": "6ef59745ac6538ebbcee0d94228650c2fb133a77",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -8,10 +8,25 @@\n #include <stdint.h>\n #include <vector>\n \n+#include \"primitives/transaction.h\"\n+#include \"primitives/block.h\"\n #include \"uint256.h\"\n \n uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = NULL);\n std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position);\n uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t position);\n \n+/*\n+ * Compute the Merkle root of the transactions in a block.\n+ * *mutated is set to true if a duplicated subtree was found.\n+ */\n+uint256 BlockMerkleRoot(const CBlock& block, bool* mutated = NULL);\n+\n+/*\n+ * Compute the Merkle branch for the tree of transactions in a block, for a\n+ * given position.\n+ * This can be verified using ComputeMerkleRootFromBranch.\n+ */\n+std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position);\n+\n #endif"
      },
      {
        "sha": "191b2b3c12bc5d2af9050a43b26269db17346c82",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -12,6 +12,7 @@\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"hash.h\"\n #include \"init.h\"\n@@ -2876,7 +2877,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     // Check the merkle root.\n     if (fCheckMerkleRoot) {\n         bool mutated;\n-        uint256 hashMerkleRoot2 = block.ComputeMerkleRoot(&mutated);\n+        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n             return state.DoS(100, error(\"CheckBlock(): hashMerkleRoot mismatch\"),\n                              REJECT_INVALID, \"bad-txnmrklroot\", true);"
      },
      {
        "sha": "8187e58186dba8176028e88719341f8fbb463e9d",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -10,6 +10,7 @@\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"hash.h\"\n #include \"main.h\"\n@@ -373,7 +374,7 @@ void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned\n     assert(txCoinbase.vin[0].scriptSig.size() <= 100);\n \n     pblock->vtx[0] = txCoinbase;\n-    pblock->hashMerkleRoot = pblock->ComputeMerkleRoot();\n+    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n }\n \n //////////////////////////////////////////////////////////////////////////////"
      },
      {
        "sha": "7280c18f7766a74f4ef45432f7499ea9952b00c7",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 63,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -15,69 +15,6 @@ uint256 CBlockHeader::GetHash() const\n     return SerializeHash(*this);\n }\n \n-uint256 CBlock::ComputeMerkleRoot(bool* fMutated) const\n-{\n-    /* WARNING! If you're reading this because you're learning about crypto\n-       and/or designing a new system that will use merkle trees, keep in mind\n-       that the following merkle tree algorithm has a serious flaw related to\n-       duplicate txids, resulting in a vulnerability (CVE-2012-2459).\n-\n-       The reason is that if the number of hashes in the list at a given time\n-       is odd, the last one is duplicated before computing the next level (which\n-       is unusual in Merkle trees). This results in certain sequences of\n-       transactions leading to the same merkle root. For example, these two\n-       trees:\n-\n-                    A               A\n-                  /  \\            /   \\\n-                B     C         B       C\n-               / \\    |        / \\     / \\\n-              D   E   F       D   E   F   F\n-             / \\ / \\ / \\     / \\ / \\ / \\ / \\\n-             1 2 3 4 5 6     1 2 3 4 5 6 5 6\n-\n-       for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and\n-       6 are repeated) result in the same root hash A (because the hash of both\n-       of (F) and (F,F) is C).\n-\n-       The vulnerability results from being able to send a block with such a\n-       transaction list, with the same merkle root, and the same block hash as\n-       the original without duplication, resulting in failed validation. If the\n-       receiving node proceeds to mark that block as permanently invalid\n-       however, it will fail to accept further unmodified (and thus potentially\n-       valid) versions of the same block. We defend against this by detecting\n-       the case where we would hash two identical hashes at the end of the list\n-       together, and treating that identically to the block having an invalid\n-       merkle root. Assuming no double-SHA256 collisions, this will detect all\n-       known ways of changing the transactions without affecting the merkle\n-       root.\n-    */\n-    std::vector<uint256> vMerkleTree;\n-    vMerkleTree.reserve(vtx.size() * 2 + 16); // Safe upper bound for the number of total nodes.\n-    for (std::vector<CTransaction>::const_iterator it(vtx.begin()); it != vtx.end(); ++it)\n-        vMerkleTree.push_back(it->GetHash());\n-    int j = 0;\n-    bool mutated = false;\n-    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-    {\n-        for (int i = 0; i < nSize; i += 2)\n-        {\n-            int i2 = std::min(i+1, nSize-1);\n-            if (i2 == i + 1 && i2 + 1 == nSize && vMerkleTree[j+i] == vMerkleTree[j+i2]) {\n-                // Two identical hashes at the end of the list at a particular level.\n-                mutated = true;\n-            }\n-            vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n-                                       BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n-        }\n-        j += nSize;\n-    }\n-    if (fMutated) {\n-        *fMutated = mutated;\n-    }\n-    return (vMerkleTree.empty() ? uint256() : vMerkleTree.back());\n-}\n-\n std::string CBlock::ToString() const\n {\n     std::stringstream s;"
      },
      {
        "sha": "5c017d436f50ec5e7ac95d965fc2a3964b152d8b",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -118,12 +118,6 @@ class CBlock : public CBlockHeader\n         return block;\n     }\n \n-    // Build the merkle tree for this block and return the merkle root.\n-    // If non-NULL, *mutated is set to whether mutation was detected in the merkle\n-    // tree (a duplication of transactions in the block leading to an identical\n-    // merkle root).\n-    uint256 ComputeMerkleRoot(bool* mutated = NULL) const;\n-\n     std::string ToString() const;\n };\n "
      },
      {
        "sha": "2b92d239e90ec204df7115b5dd0eca3a5d45d82c",
        "filename": "src/test/main_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/main_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/main_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/main_tests.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -72,5 +72,4 @@ BOOST_AUTO_TEST_CASE(test_combiner_all)\n     Test.disconnect(&ReturnTrue);\n     BOOST_CHECK(Test());\n }\n-\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1e31f2e6791fa853dfcb249bee5d139f2ee24306",
        "filename": "src/test/merkle_tests.cpp",
        "status": "added",
        "additions": 136,
        "deletions": 0,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/merkle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/merkle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkle_tests.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -0,0 +1,136 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/merkle.h\"\n+#include \"test/test_bitcoin.h\"\n+#include \"random.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(merkle_tests, TestingSetup)\n+\n+// Older version of the merkle root computation code, for comparison.\n+static uint256 BlockBuildMerkleTree(const CBlock& block, bool* fMutated, std::vector<uint256>& vMerkleTree)\n+{\n+    vMerkleTree.clear();\n+    vMerkleTree.reserve(block.vtx.size() * 2 + 16); // Safe upper bound for the number of total nodes.\n+    for (std::vector<CTransaction>::const_iterator it(block.vtx.begin()); it != block.vtx.end(); ++it)\n+        vMerkleTree.push_back(it->GetHash());\n+    int j = 0;\n+    bool mutated = false;\n+    for (int nSize = block.vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n+    {\n+        for (int i = 0; i < nSize; i += 2)\n+        {\n+            int i2 = std::min(i+1, nSize-1);\n+            if (i2 == i + 1 && i2 + 1 == nSize && vMerkleTree[j+i] == vMerkleTree[j+i2]) {\n+                // Two identical hashes at the end of the list at a particular level.\n+                mutated = true;\n+            }\n+            vMerkleTree.push_back(Hash(vMerkleTree[j+i].begin(), vMerkleTree[j+i].end(),\n+                                       vMerkleTree[j+i2].begin(), vMerkleTree[j+i2].end()));\n+        }\n+        j += nSize;\n+    }\n+    if (fMutated) {\n+        *fMutated = mutated;\n+    }\n+    return (vMerkleTree.empty() ? uint256() : vMerkleTree.back());\n+}\n+\n+// Older version of the merkle branch computation code, for comparison.\n+static std::vector<uint256> BlockGetMerkleBranch(const CBlock& block, const std::vector<uint256>& vMerkleTree, int nIndex)\n+{\n+    std::vector<uint256> vMerkleBranch;\n+    int j = 0;\n+    for (int nSize = block.vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n+    {\n+        int i = std::min(nIndex^1, nSize-1);\n+        vMerkleBranch.push_back(vMerkleTree[j+i]);\n+        nIndex >>= 1;\n+        j += nSize;\n+    }\n+    return vMerkleBranch;\n+}\n+\n+static inline int ctz(uint32_t i) {\n+    if (i == 0) return 0;\n+    int j = 0;\n+    while (!(i & 1)) {\n+        j++;\n+        i >>= 1;\n+    }\n+    return j;\n+}\n+\n+BOOST_AUTO_TEST_CASE(merkle_test)\n+{\n+    for (int i = 0; i < 32; i++) {\n+        // Try 32 block sizes: all sizes from 0 to 16 inclusive, and then 15 random sizes.\n+        int ntx = (i <= 16) ? i : 17 + (insecure_rand() % 4000);\n+        // Try up to 3 mutations.\n+        for (int mutate = 0; mutate <= 3; mutate++) {\n+            int duplicate1 = mutate >= 1 ? 1 << ctz(ntx) : 0; // The last how many transactions to duplicate first.\n+            if (duplicate1 >= ntx) break; // Duplication of the entire tree results in a different root (it adds a level).\n+            int ntx1 = ntx + duplicate1; // The resulting number of transactions after the first duplication.\n+            int duplicate2 = mutate >= 2 ? 1 << ctz(ntx1) : 0; // Likewise for the second mutation.\n+            if (duplicate2 >= ntx1) break;\n+            int ntx2 = ntx1 + duplicate2;\n+            int duplicate3 = mutate >= 3 ? 1 << ctz(ntx2) : 0; // And for the the third mutation.\n+            if (duplicate3 >= ntx2) break;\n+            int ntx3 = ntx2 + duplicate3;\n+            // Build a block with ntx different transactions.\n+            CBlock block;\n+            block.vtx.resize(ntx);\n+            for (int j = 0; j < ntx; j++) {\n+                CMutableTransaction mtx;\n+                mtx.nLockTime = j;\n+                block.vtx[j] = mtx;\n+            }\n+            // Compute the root of the block before mutating it.\n+            bool unmutatedMutated = false;\n+            uint256 unmutatedRoot = BlockMerkleRoot(block, &unmutatedMutated);\n+            BOOST_CHECK(unmutatedMutated == false);\n+            // Optionally mutate by duplicating the last transactions, resulting in the same merkle root.\n+            block.vtx.resize(ntx3);\n+            for (int j = 0; j < duplicate1; j++) {\n+                block.vtx[ntx + j] = block.vtx[ntx + j - duplicate1];\n+            }\n+            for (int j = 0; j < duplicate2; j++) {\n+                block.vtx[ntx1 + j] = block.vtx[ntx1 + j - duplicate2];\n+            }\n+            for (int j = 0; j < duplicate3; j++) {\n+                block.vtx[ntx2 + j] = block.vtx[ntx2 + j - duplicate3];\n+            }\n+            // Compute the merkle root and merkle tree using the old mechanism.\n+            bool oldMutated = false;\n+            std::vector<uint256> merkleTree;\n+            uint256 oldRoot = BlockBuildMerkleTree(block, &oldMutated, merkleTree);\n+            // Compute the merkle root using the new mechanism.\n+            bool newMutated = false;\n+            uint256 newRoot = BlockMerkleRoot(block, &newMutated);\n+            BOOST_CHECK(oldRoot == newRoot);\n+            BOOST_CHECK(newRoot == unmutatedRoot);\n+            BOOST_CHECK((newRoot == uint256()) == (ntx == 0));\n+            BOOST_CHECK(oldMutated == newMutated);\n+            BOOST_CHECK(newMutated == !!mutate);\n+            // If no mutation was done (once for every ntx value), try up to 16 branches.\n+            if (mutate == 0) {\n+                for (int loop = 0; loop < std::min(ntx, 16); loop++) {\n+                    // If ntx <= 16, try all branches. Otherise, try 16 random ones.\n+                    int mtx = loop;\n+                    if (ntx > 16) {\n+                        mtx = insecure_rand() % ntx;\n+                    }\n+                    std::vector<uint256> newBranch = BlockMerkleBranch(block, mtx);\n+                    std::vector<uint256> oldBranch = BlockGetMerkleBranch(block, merkleTree, mtx);\n+                    BOOST_CHECK(oldBranch == newBranch);\n+                    BOOST_CHECK(ComputeMerkleRootFromBranch(block.vtx[mtx].GetHash(), newBranch, mtx) == oldRoot);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1d7c9f65c096c486f96893b679099875d6a7582f",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -5,6 +5,7 @@\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"main.h\"\n #include \"miner.h\"\n@@ -93,7 +94,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->vtx[0] = CTransaction(txCoinbase);\n         if (txFirst.size() < 2)\n             txFirst.push_back(new CTransaction(pblock->vtx[0]));\n-        pblock->hashMerkleRoot = pblock->ComputeMerkleRoot();\n+        pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n         BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));"
      },
      {
        "sha": "0d7fb2bc35cdfd2db5ed3345f1bbb87007091769",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eece63fa72566068cb2a1bf85c95a72a5ba59bc9/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=eece63fa72566068cb2a1bf85c95a72a5ba59bc9",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"consensus/merkle.h\"\n #include \"merkleblock.h\"\n #include \"serialize.h\"\n #include \"streams.h\"\n@@ -48,7 +49,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n         }\n \n         // calculate actual merkle root and height\n-        uint256 merkleRoot1 = block.ComputeMerkleRoot();\n+        uint256 merkleRoot1 = BlockMerkleRoot(block);\n         std::vector<uint256> vTxid(nTx, uint256());\n         for (unsigned int j=0; j<nTx; j++)\n             vTxid[j] = block.vtx[j].GetHash();"
      }
    ]
  }
]