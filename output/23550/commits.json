[
  {
    "sha": "184e1fac177a4af7284df283cd75a8a4da17161d",
    "node_id": "C_kwDOABII59oAKDE4NGUxZmFjMTc3YTRhZjcyODRkZjI4M2NkNzVhOGE0ZGExNzE2MWQ",
    "commit": {
      "author": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-02T21:52:55Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-02T21:52:55Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from be8d9c262..af4047cf8\n\naf4047cf8 Add ellsq testing to CI\n1ab129a5c Elligator Squared module\n13fe9daa9 Native jacobi symbol algorithm\n2a3a97c66 Merge bitcoin-core/secp256k1#976: `secp256k1_schnorrsig_sign_internal` should be static\naa5d34a8f Merge bitcoin-core/secp256k1#783: Make the public API docs more consistent and explicit\n72713872a Add missing static to secp256k1_schnorrsig_sign_internal\n9a5a87e0f Merge bitcoin-core/secp256k1#956: Replace ecmult_context with a generated static array.\n20abd52c2 Add tests for pre_g tables.\n6815761cf Remove ecmult_context.\nf20dcbbad Correct typo.\n16a3cc07e Generate ecmult_static_pre_g.h\n8de2d86a0 Bump memory limits in advance of making the ecmult context static.\nd7ec49a68 Merge bitcoin-core/secp256k1#969: ci: Fixes after Debian release\n5d5c74a05 tests: Rewrite code to circument potential bug in clang\n3d2f492ce ci: Install libasan6 (instead of 5) after Debian upgrade\nadec5a163 Add missing null check for ctx and input keys in the public API\nf4edfc758 Improve consistency for NULL arguments in the public interface\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: af4047cf871df2875e492c27885fcaca2cbc760e",
      "tree": {
        "sha": "9b929470d420b195ff04f9bbba71c9c567677245",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b929470d420b195ff04f9bbba71c9c567677245"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/184e1fac177a4af7284df283cd75a8a4da17161d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/184e1fac177a4af7284df283cd75a8a4da17161d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/184e1fac177a4af7284df283cd75a8a4da17161d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/184e1fac177a4af7284df283cd75a8a4da17161d/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c020cbaa5c8e9e61b2b8efd8dc09be743fcd4273"
      }
    ],
    "stats": {
      "total": 18884,
      "additions": 18261,
      "deletions": 623
    },
    "files": [
      {
        "sha": "3eb44ba6f494daefb9145425ae9a0b86c735e589",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 4,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -18,6 +18,7 @@ env:\n   ECDH: no\n   RECOVERY: no\n   SCHNORRSIG: no\n+  ELLSQ: no\n   ### test options\n   TEST_ITERS:\n   BENCH: yes\n@@ -60,12 +61,12 @@ task:\n     memory: 1G\n   matrix: &ENV_MATRIX\n     - env: {WIDEMUL:  int64,  RECOVERY: yes}\n-    - env: {WIDEMUL:  int64,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL:  int64,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes, ELLSQ: yes}\n     - env: {WIDEMUL: int128}\n-    - env: {WIDEMUL: int128,  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128,  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes, ELLSQ: yes}\n     - env: {WIDEMUL: int128,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n     - env: {WIDEMUL: int128,  ASM: x86_64}\n-    - env: {                  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {                  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes, ELLSQ: yes}\n     - env: {                  STATICPRECOMPUTATION: no}\n     - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n     - env: {CPPFLAGS: -DDETERMINISTIC}\n@@ -91,6 +92,7 @@ task:\n   env:\n     HOST: i686-linux-gnu\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -175,6 +177,7 @@ task:\n     HOST: s390x-linux-gnu\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -198,6 +201,7 @@ task:\n     HOST: arm-linux-gnueabihf\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: tes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -222,6 +226,7 @@ task:\n     HOST: aarch64-linux-gnu\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -243,6 +248,7 @@ task:\n     HOST: powerpc64le-linux-gnu\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -264,6 +270,7 @@ task:\n     HOST: x86_64-w64-mingw32\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -278,9 +285,10 @@ task:\n   container:\n     dockerfile: ci/linux-debian.Dockerfile\n     cpu: 1\n-    memory: 1G\n+    memory: 2G\n   env:\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -334,6 +342,7 @@ task:\n     WERROR_CFLAGS:\n     EXPERIMENTAL: yes\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     SCHNORRSIG: yes\n   << : *MERGE_BASE"
      },
      {
        "sha": "9cf2163c3978bbb5bfd37314ad2a40102d6a6a6a",
        "filename": ".gitattributes",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/.gitattributes",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/.gitattributes",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitattributes?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1 @@\n+src/ecmult_static_pre_g.h linguist-generated"
      },
      {
        "sha": "9e187a34a9606bed2564ec80148d9e2ef366f5d0",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -9,6 +9,7 @@ bench_internal\n tests\n exhaustive_tests\n gen_context\n+gen_ecmult_static_pre_g\n valgrind_ctime_test\n *.exe\n *.so"
      },
      {
        "sha": "4a23eea8613cac436641108742df8d20220704a3",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -127,12 +127,19 @@ exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n \n+EXTRA_PROGRAMS = gen_ecmult_static_pre_g\n+gen_ecmult_static_pre_g_SOURCES = src/gen_ecmult_static_pre_g.c\n+# See Automake manual, Section \"Errors with distclean\"\n+src/ecmult_static_pre_g.h:\n+\t$(MAKE) $(AM_MAKEFLAGS) gen_ecmult_static_pre_g$(EXEEXT)\n+\t./gen_ecmult_static_pre_g$(EXEEXT)\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n+$(gen_context_OBJECTS): src/gen_context.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n@@ -149,7 +156,7 @@ src/ecmult_static_context.h: $(gen_context_BIN)\n CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/ecmult_static_pre_g.h src/basic-config.h\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n@@ -166,3 +173,7 @@ endif\n if ENABLE_MODULE_SCHNORRSIG\n include src/modules/schnorrsig/Makefile.am.include\n endif\n+\n+if ENABLE_MODULE_ELLSQ\n+include src/modules/ellsq/Makefile.am.include\n+endif"
      },
      {
        "sha": "61352f228e25533f6e2aca11ed1f5c8032ac7f27",
        "filename": "ci/cirrus.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/cirrus.sh?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -16,7 +16,7 @@ valgrind --version || true\n     --enable-experimental=\"$EXPERIMENTAL\" \\\n     --with-test-override-wide-multiply=\"$WIDEMUL\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n-    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" --enable-module-ellsq=\"$ELLSQ\" \\\n     --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n     --with-valgrind=\"$WITH_VALGRIND\" \\\n     --host=\"$HOST\" $EXTRAFLAGS\n@@ -60,6 +60,10 @@ then\n     then\n         $EXEC ./bench_ecdh >> bench.log 2>&1\n     fi\n+    if [ \"$ELLSQ\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_ellsq >> bench.log 2>&1\n+    fi\n     if [ \"$SCHNORRSIG\" = \"yes\" ]\n     then\n         $EXEC ./bench_schnorrsig >> bench.log 2>&1"
      },
      {
        "sha": "fdba12aa00b474a9043d8eb56eab1ff20bda6145",
        "filename": "ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/linux-debian.Dockerfile?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -14,7 +14,7 @@ RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n         gcc clang llvm libc6-dbg \\\n         g++ \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan6:i386 \\\n         gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n         gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n         gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\"
      },
      {
        "sha": "e6410fed9b0ec62dae8426dac38c327b540b01ec",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -161,6 +161,11 @@ AC_ARG_ENABLE(module_schnorrsig,\n     [enable_module_schnorrsig=$enableval],\n     [enable_module_schnorrsig=no])\n \n+AC_ARG_ENABLE(module_ellsq,\n+    AS_HELP_STRING([--enable-module-ellsq],[enable Elligator^2 module (experimental)]),\n+    [enable_module_ellsq=$enableval],\n+    [enable_module_ellsq=no])\n+\n AC_ARG_ENABLE(external_default_callbacks,\n     AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n     [use_external_default_callbacks=$enableval],\n@@ -177,6 +182,8 @@ AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n [window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n [Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n [The table will store 2^(SIZE-1) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[A window size larger than 15 will require you delete the prebuilt ecmult_static_pre_g.h file so that it can be rebuilt.]\n+[For very large window sizes, use \"make -j 1\" to reduce memory use during compilation.]\n [\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n )],\n [req_ecmult_window=$withval], [req_ecmult_window=auto])\n@@ -454,6 +461,10 @@ if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_EXTRAKEYS, 1, [Define this symbol to enable the extrakeys module])\n fi\n \n+if test x\"$enable_module_ellsq\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_ELLSQ, 1, [Define this symbol to enable the Elligator^2 module])\n+fi\n+\n if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n fi\n@@ -468,6 +479,7 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building extrakeys module: $enable_module_extrakeys])\n   AC_MSG_NOTICE([Building schnorrsig module: $enable_module_schnorrsig])\n+  AC_MSG_NOTICE([Building Elligator^2 module: $enable_module_ellsq])\n   AC_MSG_NOTICE([******])\n else\n   if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n@@ -476,6 +488,9 @@ else\n   if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n     AC_MSG_ERROR([schnorrsig module is experimental. Use --enable-experimental to allow.])\n   fi\n+  if test x\"$enable_module_ellsq\" = x\"yes\"; then\n+    AC_MSG_ERROR([Elligator^2 module is experimental. Use --enable-experimental to allow.])\n+  fi\n   if test x\"$set_asm\" = x\"arm\"; then\n     AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -501,6 +516,7 @@ AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_EXTRAKEYS], [test x\"$enable_module_extrakeys\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_ELLSQ], [test x\"$enable_module_ellsq\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -523,6 +539,7 @@ echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\"\n echo \"  module extrakeys        = $enable_module_extrakeys\"\n echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n+echo \"  module ellsq            = $enable_module_ellsq\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  ecmult window size      = $set_ecmult_window\""
      },
      {
        "sha": "576953f49d4aaaf10165a5aa4715984fbe6154eb",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 48,
        "deletions": 49,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -226,7 +226,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n  *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx: an existing context to copy (cannot be NULL)\n+ *  Args:    ctx: an existing context to copy\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n@@ -247,7 +247,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Set a callback function to be called when an illegal argument is passed to\n  *  an API call. It will only trigger for violations that are mentioned\n@@ -278,11 +278,11 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  fails. In this case, the corresponding default handler will be called with\n  *  the data pointer argument set to NULL.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n  *              passed to the API, taking a message and an opaque pointer.\n  *              (NULL restores the default handler.)\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_error_callback.\n  */\n@@ -302,12 +302,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *  for that). After this callback returns, anything may happen, including\n  *  crashing.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n  *              taking a message and an opaque pointer (NULL restores the\n  *              default handler, see secp256k1_context_set_illegal_callback\n  *              for details).\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_illegal_callback.\n  */\n@@ -320,7 +320,7 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n /** Create a secp256k1 scratch space object.\n  *\n  *  Returns: a newly created scratch space.\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   size: amount of memory to be available as scratch space. Some extra\n  *              (<100 bytes) will be allocated for extra accounting.\n  */\n@@ -480,16 +480,16 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n  *  Returns: 1: correct signature\n  *           0: incorrect or unparseable signature\n  *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig:       the signature being verified (cannot be NULL)\n- *           msghash32: the 32-byte message hash being verified (cannot be NULL).\n+ *  In:      sig:       the signature being verified.\n+ *           msghash32: the 32-byte message hash being verified.\n  *                      The verifier must make sure to apply a cryptographic\n  *                      hash function to the message by itself and not accept an\n  *                      msghash32 value directly. Otherwise, it would be easy to\n  *                      create a \"valid\" signature without knowledge of the\n  *                      secret key. See also\n  *                      https://bitcoin.stackexchange.com/a/81116/35586 for more\n  *                      background on this topic.\n- *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)\n+ *           pubkey:    pointer to an initialized public key to verify with.\n  *\n  * To avoid accepting malleable signatures, only ECDSA signatures in lower-S\n  * form are accepted.\n@@ -515,8 +515,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n  *                or copy if the input was already normalized. (can be NULL if\n  *                you're only interested in whether the input was already\n  *                normalized).\n- *  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,\n- *                can be identical to sigout)\n+ *  In:   sigin:  a pointer to a signature to check/normalize (can be identical to sigout)\n  *\n  *  With ECDSA a third-party can forge a second distinct signature of the same\n  *  message, given a single initial signature, but without knowing the key. This\n@@ -568,12 +567,16 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL). If it is non-NULL and\n+ *                      secp256k1_nonce_function_default is used, then ndata must be a\n+ *                      pointer to 32-bytes of additional data.\n  *\n  * The created signature is always in lower-S form. See\n  * secp256k1_ecdsa_signature_normalize for more details.\n@@ -596,8 +599,8 @@ SECP256K1_API int secp256k1_ecdsa_sign(\n  *\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n- *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n     const secp256k1_context* ctx,\n@@ -606,11 +609,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n \n /** Compute the public key for a secret key.\n  *\n- *  Returns: 1: secret was valid, public key stores\n- *           0: secret was invalid, try again\n- *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:    pubkey:     pointer to the created public key (cannot be NULL)\n- *  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)\n+ *  Returns: 1: secret was valid, public key stores.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:    pointer to a context object, initialized for signing.\n+ *  Out:     pubkey: pointer to the created public key.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const secp256k1_context* ctx,\n@@ -626,8 +629,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n  *  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the\n  *                  secret key is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0 and\n- *                  seckey will be set to some unspecified value. (cannot be\n- *                  NULL)\n+ *                  seckey will be set to some unspecified value.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_negate(\n     const secp256k1_context* ctx,\n@@ -645,7 +647,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n  *\n  *  Returns: 1 always\n  *  Args:   ctx:        pointer to a context object\n- *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ *  In/Out: pubkey:     pointer to the public key to be negated.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n     const secp256k1_context* ctx,\n@@ -657,15 +659,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n  *  Returns: 0 if the arguments are invalid or the resulting secret key would be\n  *           invalid (only when the tweak is the negation of the secret key). 1\n  *           otherwise.\n- *  Args:    ctx:   pointer to a context object (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -686,14 +688,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n  *  Returns: 0 if the arguments are invalid or the resulting public key would be\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -704,15 +705,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n /** Tweak a secret key by multiplying it by a tweak.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx:    pointer to a context object (cannot be NULL).\n+ *  Args:   ctx:    pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -731,14 +732,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n /** Tweak a public key by multiplying it by a tweak value.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -749,7 +749,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n /** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated or nothing to randomize\n  *           0: error\n- *  Args:    ctx:       pointer to a context object (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object.\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n  *\n  * While secp256k1 code is written to be constant-time no matter what secret\n@@ -780,18 +780,17 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n  *\n  *  Returns: 1: the sum of the public keys is valid.\n  *           0: the sum of the public keys is not valid.\n- *  Args:   ctx:        pointer to a context object\n- *  Out:    out:        pointer to a public key object for placing the resulting public key\n- *                      (cannot be NULL)\n- *  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)\n- *          n:          the number of public keys to add together (must be at least 1)\n+ *  Args:   ctx:        pointer to a context object.\n+ *  Out:    out:        pointer to a public key object for placing the resulting public key.\n+ *  In:     ins:        pointer to array of pointers to public keys.\n+ *          n:          the number of public keys to add together (must be at least 1).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *out,\n     const secp256k1_pubkey * const * ins,\n     size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Compute a tagged hash as defined in BIP-340.\n  *"
      },
      {
        "sha": "c8577984b1a5ef35a8f3334e16e9865dd04e5ca1",
        "filename": "include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_ecdh.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -37,14 +37,15 @@ SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_func\n  *\n  *  Returns: 1: exponentiation was successful\n  *           0: scalar was invalid (zero or overflow) or hashfp returned 0\n- *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     output:     pointer to an array to be filled by hashfp\n- *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n- *                       initialized public key\n- *           seckey:     a 32-byte scalar with which to multiply the point\n- *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n- *                       (in which case, 32 bytes will be written to output)\n+ *  Args:    ctx:        pointer to a context object.\n+ *  Out:     output:     pointer to an array to be filled by hashfp.\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an initialized public key.\n+ *           seckey:     a 32-byte scalar with which to multiply the point.\n+ *           hashfp:     pointer to a hash function. If NULL,\n+ *                       secp256k1_ecdh_hash_function_sha256 is used\n+ *                       (in which case, 32 bytes will be written to output).\n  *           data:       arbitrary data pointer that is passed through to hashfp\n+ *                       (can be NULL for secp256k1_ecdh_hash_function_sha256).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,"
      },
      {
        "sha": "e01937e352f8216601ad44eca09e8834c630da78",
        "filename": "include/secp256k1_ellsq.h",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_ellsq.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_ellsq.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_ellsq.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1,78 @@\n+#ifndef SECP256K1_ELLSQ_H\n+#define SECP256K1_ELLSQ_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of the Elligator Squared encoding\n+ * for secp256k1 public keys. Given a uniformly random public key, this\n+ * produces a 64-byte encoding that is indistinguishable from uniformly\n+ * random bytes.\n+ *\n+ * Elligator Squared is described in https://eprint.iacr.org/2014/043.pdf by\n+ * Mehdi Tibouchi. The mapping function used is described in\n+ * https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf by Fouque and Tibouchi.\n+ *\n+ * Let f be the function from field elements to curve points, defined as\n+ * follows:\n+ * f(t):\n+ * - Let c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+ * - Let x1 = (c - 1)/2 - c*t^2 / (t^2 + 8) (mod p)\n+ * - Let x2 = (-c - 1)/2 + c*t^2 / (t^2 + 8) (mod p)\n+ * - Let x3 = 1 - (t^2 + 8)^2 / (3*t^2) (mod p)\n+ * - Let x be the first of [x1,x2,x3] that is an X coordinate on the curve\n+ *   (at least one of them is, for any field element t).\n+ * - Let y be the the corresponding Y coordinate to x, with the same parity\n+ *   as t (even if t is even, odd if t is odd).\n+ * - Return the curve point with coordinates (x, y).\n+ *\n+ * Then an Elligator Squared encoding of P consists of the 32-byte big-endian\n+ * encodings of field elements u1 and u2 concatenated, where f(u1)+f(u2) = P.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u1,u2) among those which encode P.\n+ *\n+ * To make the encoding able to deal with all inputs, if f(u1)+f(u2) is the\n+ * point at infinity, the decoding is defined to be f(u1) instead.\n+ */\n+\n+/* Construct a 64-byte Elligator Squared encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *           pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellsq_encode(\n+    const secp256k1_context* ctx,\n+    unsigned char *ell64,\n+    const unsigned char *rnd32,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes Elligator Squared encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellsq_decode(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_ELLSQ_H */"
      },
      {
        "sha": "a64d561b60bff825a71892f959082aff9f6c5448",
        "filename": "include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 34,
        "deletions": 48,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_extrakeys.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -39,11 +39,10 @@ typedef struct {\n  *  Returns: 1 if the public key was fully valid.\n  *           0 if the public key could not be parsed or is invalid.\n  *\n- *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Args:   ctx: a secp256k1 context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n  *               parsed version of input. If not, it's set to an invalid value.\n- *               (cannot be NULL).\n- *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  In: input32: pointer to a serialized xonly_pubkey.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n     const secp256k1_context* ctx,\n@@ -55,11 +54,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n  *\n  *  Returns: 1 always.\n  *\n- *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n- *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n- *                 (cannot be NULL).\n- *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n- *                 initialized public key (cannot be NULL).\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an initialized public key.\n  */\n SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_context* ctx,\n@@ -87,13 +84,12 @@ SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n  *  Returns: 1 if the public key was successfully converted\n  *           0 otherwise\n  *\n- *  Args:         ctx: pointer to a context object (cannot be NULL)\n- *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n- *                     converted public key (cannot be NULL)\n- *          pk_parity: pointer to an integer that will be set to 1 if the point\n- *                     encoded by xonly_pubkey is the negation of the pubkey and\n- *                     set to 0 otherwise. (can be NULL)\n- *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key.\n+ *          pk_parity: Ignored if NULL. Otherwise, pointer to an integer that\n+ *                     will be set to 1 if the point encoded by xonly_pubkey is\n+ *                     the negation of the pubkey and set to 0 otherwise.\n+ *  In:        pubkey: pointer to a public key that is converted.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n     const secp256k1_context* ctx,\n@@ -113,18 +109,14 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n  *\n- *  Args:           ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n+ *  Args:           ctx: pointer to a context object initialized for verification.\n  *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n- *                       to an invalid value if this function returns 0 (cannot\n- *                       be NULL)\n+ *                       to an invalid value if this function returns 0.\n  *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n- *                       (cannot be NULL).\n  *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n  *                       according to secp256k1_ec_seckey_verify, this function\n  *                       returns 0. For uniformly random 32-byte arrays the\n- *                       chance of being invalid is negligible (around 1 in\n- *                       2^128) (cannot be NULL).\n+ *                       chance of being invalid is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -146,17 +138,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n  *\n  *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n  *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n- *  Args:            ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n- *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  Args:            ctx: pointer to a context object initialized for verification.\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey.\n  *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n  *                        is passed in as tweaked_pubkey32). This must match the\n  *                        pk_parity value that is returned when calling\n  *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n  *                        this function will fail.\n- *       internal_pubkey: pointer to an x-only public key object to apply the\n- *                        tweak to (cannot be NULL)\n- *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ *       internal_pubkey: pointer to an x-only public key object to apply the tweak to.\n+ *               tweak32: pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n     const secp256k1_context* ctx,\n@@ -170,9 +160,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_\n  *\n  *  Returns: 1: secret was valid, keypair is ready to use\n  *           0: secret was invalid, try again with a different secret\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out: keypair: pointer to the created keypair (cannot be NULL)\n- *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out: keypair: pointer to the created keypair.\n+ *  In:   seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n     const secp256k1_context* ctx,\n@@ -183,9 +173,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n /** Get the secret key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n- *  Out: seckey: pointer to a 32-byte buffer for the secret key (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n+ *  Out: seckey: pointer to a 32-byte buffer for the secret key.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n     const secp256k1_context* ctx,\n@@ -196,11 +186,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n /** Get the public key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n  *               the keypair public key. If not, it's set to an invalid value.\n- *               (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n     const secp256k1_context* ctx,\n@@ -214,14 +203,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n  *  secp256k1_xonly_pubkey_from_pubkey.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n  *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n  *               to the keypair public key after converting it to an\n- *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n- *               NULL).\n- *    pk_parity: pointer to an integer that will be set to the pk_parity\n- *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *               xonly_pubkey. If not, it's set to an invalid value.\n+ *    pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the\n+ *               pk_parity argument of secp256k1_xonly_pubkey_from_pubkey.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n     const secp256k1_context* ctx,\n@@ -241,15 +229,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n  *           invalid (only when the tweak is the negation of the keypair's\n  *           secret key). 1 otherwise.\n  *\n- *  Args:       ctx: pointer to a context object initialized for verification\n- *                   (cannot be NULL)\n+ *  Args:       ctx: pointer to a context object initialized for verification.\n  *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n- *                   an invalid value if this function returns 0 (cannot be\n- *                   NULL).\n+ *                   an invalid value if this function returns 0.\n  *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n  *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n  *                   uniformly random 32-byte arrays the chance of being invalid\n- *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                   is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "d2d9014f02881c5ac36164af5c63932d170c3c46",
        "filename": "include/secp256k1_preallocated.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_preallocated.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -55,7 +55,7 @@ SECP256K1_API size_t secp256k1_context_preallocated_size(\n  *  Returns: a newly created context object.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  *           flags:    which parts of the context to initialize.\n  *\n  *  See also secp256k1_context_randomize (in secp256k1.h)\n@@ -70,7 +70,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n  *  caller-provided memory.\n  *\n  *  Returns: the required size of the caller-provided memory block.\n- *  In:      ctx: an existing context to copy (cannot be NULL)\n+ *  In:      ctx: an existing context to copy.\n  */\n SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n     const secp256k1_context* ctx\n@@ -87,10 +87,10 @@ SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n  *  secp256k1_context_preallocated_create for details.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  Args:    ctx:      an existing context to copy.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n     const secp256k1_context* ctx,\n@@ -115,11 +115,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n  *\n  *  Args:   ctx: an existing context to destroy, constructed using\n  *               secp256k1_context_preallocated_create or\n- *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ *               secp256k1_context_preallocated_clone.\n  */\n SECP256K1_API void secp256k1_context_preallocated_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "0e2847db96c6925d0bf58c897b839870bfc677b5",
        "filename": "include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_recovery.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -43,8 +43,9 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_parse_compact(\n /** Convert a recoverable signature into a normal signature.\n  *\n  *  Returns: 1\n- *  Out: sig:    a pointer to a normal signature (cannot be NULL).\n- *  In:  sigin:  a pointer to a recoverable signature (cannot be NULL).\n+ *  Args: ctx:    a secp256k1 context object.\n+ *  Out:  sig:    a pointer to a normal signature.\n+ *  In:   sigin:  a pointer to a recoverable signature.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n     const secp256k1_context* ctx,\n@@ -55,10 +56,10 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n /** Serialize an ECDSA signature in compact format (64 bytes + recovery id).\n  *\n  *  Returns: 1\n- *  Args: ctx:      a secp256k1 context object\n- *  Out:  output64: a pointer to a 64-byte array of the compact signature (cannot be NULL)\n- *        recid:    a pointer to an integer to hold the recovery id (can be NULL).\n- *  In:   sig:      a pointer to an initialized signature object (cannot be NULL)\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  Out:  output64: a pointer to a 64-byte array of the compact signature.\n+ *        recid:    a pointer to an integer to hold the recovery id.\n+ *  In:   sig:      a pointer to an initialized signature object.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n     const secp256k1_context* ctx,\n@@ -71,12 +72,14 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL for secp256k1_nonce_function_default).\n  */\n SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n     const secp256k1_context* ctx,\n@@ -91,10 +94,10 @@ SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n  *\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  Args:    ctx:       pointer to a context object, initialized for verification (cannot be NULL)\n- *  Out:     pubkey:    pointer to the recovered public key (cannot be NULL)\n- *  In:      sig:       pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n- *           msghash32: the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for verification.\n+ *  Out:     pubkey:    pointer to the recovered public key.\n+ *  In:      sig:       pointer to initialized signature that supports pubkey recovery.\n+ *           msghash32: the 32-byte message hash assumed to be signed.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "4ac421ea45c2b2812e4767053d79b24dc93f96e9",
        "filename": "include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorrsig.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -106,10 +106,10 @@ typedef struct {\n  *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n- *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n- *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature.\n+ *  In:    msg32: the 32-byte message being signed.\n+ *       keypair: pointer to an initialized keypair.\n  *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n  *                this, it is only supplemental to security and can be NULL. See\n  *                BIP-340 \"Default Signing\" for a full explanation of this\n@@ -150,7 +150,7 @@ SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n- *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *  In:    sig64: pointer to the 64-byte signature to verify.\n  *           msg: the message being verified. Can only be NULL if msglen is 0.\n  *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)"
      },
      {
        "sha": "420c4293c03330ff8c65fb114cc19f1f8a27f499",
        "filename": "src/bench_ecmult.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -129,7 +129,7 @@ static void bench_ecmult_1(void* arg, int iters) {\n     int i;\n \n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n     }\n }\n \n@@ -145,7 +145,7 @@ static void bench_ecmult_1g(void* arg, int iters) {\n \n     secp256k1_scalar_set_int(&zero, 0);\n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n@@ -159,7 +159,7 @@ static void bench_ecmult_2g(void* arg, int iters) {\n     int i;\n \n     for (i = 0; i < iters/2; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n@@ -207,7 +207,7 @@ static void bench_ecmult_multi(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -266,7 +266,7 @@ static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_\n             secp256k1_scalar_add(&total, &total, &tmp);\n         }\n         secp256k1_scalar_negate(&total, &total);\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->expected_output[iter], NULL, &zero, &total);\n+        secp256k1_ecmult(&data->expected_output[iter], NULL, &zero, &total);\n     }\n \n     /* Run the benchmark. */"
      },
      {
        "sha": "de1d97961afbecbae33e0bf2d6826bd75f424a27",
        "filename": "src/bench_ellsq.c",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/bench_ellsq.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/bench_ellsq.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ellsq.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1,70 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#include <string.h>\n+\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_ellsq.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey point;\n+    unsigned char rnd64[64];\n+} bench_ellsq_data;\n+\n+static void bench_ellsq_setup(void* arg) {\n+    bench_ellsq_data *data = (bench_ellsq_data*)arg;\n+    const unsigned char point[] = {\n+        0x03,\n+        0x54, 0x94, 0xc1, 0x5d, 0x32, 0x09, 0x97, 0x06,\n+        0xc2, 0x37, 0x5f, 0x94, 0x34, 0x87, 0x45, 0xfd,\n+        0x75, 0x7c, 0xe3, 0x0e, 0x4e, 0x8c, 0x90, 0xfb,\n+        0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n+    };\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->point, point, sizeof(point)) == 1);\n+}\n+\n+static void bench_ellsq_encode(void* arg, int iters) {\n+    int i;\n+    bench_ellsq_data *data = (bench_ellsq_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        data->rnd64[29] ^= 145;\n+        CHECK(secp256k1_ellsq_encode(data->ctx, data->rnd64, data->rnd64 + 16, &data->point) == 1);\n+    }\n+}\n+\n+static void bench_ellsq_decode(void* arg, int iters) {\n+    int i;\n+    secp256k1_pubkey out;\n+    bench_ellsq_data *data = (bench_ellsq_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        data->rnd64[13] ^= 247;\n+        data->rnd64[47] ^= 113;\n+        CHECK(secp256k1_ellsq_decode(data->ctx, &out, data->rnd64) == 1);\n+        memcpy(data->rnd64, &out.data, 64);\n+    }\n+}\n+\n+int main(void) {\n+    bench_ellsq_data data;\n+\n+    int iters = get_iters(10000);\n+\n+    /* create a context with no capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n+    memset(data.rnd64, 11, sizeof(data.rnd64));\n+\n+    run_benchmark(\"ellsq_encode\", bench_ellsq_encode, bench_ellsq_setup, NULL, &data, 10, iters);\n+    run_benchmark(\"ellsq_decode\", bench_ellsq_decode, bench_ellsq_setup, NULL, &data, 10, iters);\n+\n+    secp256k1_context_destroy(data.ctx);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "075ce456fc4f263aaffc2e669ab04c8cf919e519",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -209,6 +209,17 @@ void bench_field_sqrt(void* arg, int iters) {\n     CHECK(j <= iters);\n }\n \n+void bench_field_jacobi_var(void* arg, int iters) {\n+    int i, j = 0;\n+    bench_inv *data = (bench_inv*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_fe_jacobi_var(&data->fe[0]);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n+    }\n+    CHECK(j <= iters);\n+}\n+\n void bench_group_double_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n@@ -358,6 +369,7 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"field_jacobi_var\", bench_field_jacobi_var, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);"
      },
      {
        "sha": "4441b08398499ba58c729334d1436764f2c71a1a",
        "filename": "src/ecdsa.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -15,7 +15,7 @@\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *r, secp256k1_scalar *s, const unsigned char *sig, size_t size);\n static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const secp256k1_scalar *r, const secp256k1_scalar *s);\n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid);\n \n #endif /* SECP256K1_ECDSA_H */"
      },
      {
        "sha": "f1bce6fc6fb229a46a765211ac7813f8bb792fa8",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -204,7 +204,7 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n #if !defined(EXHAUSTIVE_TEST_ORDER)\n@@ -221,7 +221,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, sigr);\n     secp256k1_gej_set_ge(&pubkeyj, pubkey);\n-    secp256k1_ecmult(ctx, &pr, &pubkeyj, &u2, &u1);\n+    secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }"
      },
      {
        "sha": "d54d44c997b6ab90782ad176517999d369be0038",
        "filename": "src/eckey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -18,8 +18,8 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge *elem, const unsigned char\n static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *pub, size_t *size, int compressed);\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak);\n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak);\n \n #endif /* SECP256K1_ECKEY_H */"
      },
      {
        "sha": "e0506d3e2b7e05f6adb0654b0971d8f5a29a3fa4",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -57,12 +57,12 @@ static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp25\n     return !secp256k1_scalar_is_zero(key);\n }\n \n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_gej pt;\n     secp256k1_scalar one;\n     secp256k1_gej_set_ge(&pt, key);\n     secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_ecmult(ctx, &pt, &pt, &one, tweak);\n+    secp256k1_ecmult(&pt, &pt, &one, tweak);\n \n     if (secp256k1_gej_is_infinity(&pt)) {\n         return 0;\n@@ -79,7 +79,7 @@ static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp25\n     return ret;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_scalar zero;\n     secp256k1_gej pt;\n     if (secp256k1_scalar_is_zero(tweak)) {\n@@ -88,7 +88,7 @@ static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx,\n \n     secp256k1_scalar_set_int(&zero, 0);\n     secp256k1_gej_set_ge(&pt, key);\n-    secp256k1_ecmult(ctx, &pt, &pt, tweak, &zero);\n+    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }"
      },
      {
        "sha": "b47d8f494a8034c4bd01baae4f3b183af8877fcb",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 19,
        "deletions": 13,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -11,20 +11,26 @@\n #include \"scalar.h\"\n #include \"scratch.h\"\n \n-typedef struct {\n-    /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_storage (*pre_g)[];    /* odd multiples of the generator */\n-    secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n-} secp256k1_ecmult_context;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n+#endif\n+\n+/** The number of entries a table with precomputed multiples needs to have. */\n+#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))\n \n /** Double multiply: R = na*A + ng*G */\n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n \n@@ -39,6 +45,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "87ccc733d584882fd1abafa188d69212f872027c",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 29,
        "deletions": 256,
        "changes": 285,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -14,20 +14,18 @@\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n+#include \"ecmult_static_pre_g.h\"\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n /* We need to lower these values for exhaustive tests because\n  * the tables cannot have infinities in them (this breaks the\n  * affine-isomorphism stuff which tracks z-ratios) */\n #  if EXHAUSTIVE_TEST_ORDER > 128\n #    define WINDOW_A 5\n-#    define WINDOW_G 8\n #  elif EXHAUSTIVE_TEST_ORDER > 8\n #    define WINDOW_A 4\n-#    define WINDOW_G 4\n #  else\n #    define WINDOW_A 2\n-#    define WINDOW_G 2\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n@@ -41,31 +39,12 @@\n  *  Two tables of this size are used (due to the endomorphism\n  *  optimization).\n  */\n-#  define WINDOW_G ECMULT_WINDOW_SIZE\n-#endif\n-\n-/* Noone will ever need more than a window size of 24. The code might\n- * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n- * not tested.\n- *\n- * The following limitations are known, and there are probably more:\n- * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n- * because the size of the memory object that we allocate (in bytes)\n- * will not fit in a size_t.\n- * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n- * because certain expressions will overflow.\n- */\n-#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n-#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #define WNAF_BITS 128\n #define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n #define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n \n-/** The number of entries a table with precomputed multiples needs to have. */\n-#define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n-\n /* The number of objects allocated on the scratch space for ecmult_multi algorithms */\n #define PIPPENGER_SCRATCH_OBJECTS 6\n #define STRAUSS_SCRATCH_OBJECTS 6\n@@ -119,18 +98,12 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n \n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n- *  There are two versions of this function:\n- *  - secp256k1_ecmult_odd_multiples_table_globalz_windowa which brings its\n- *    resulting point set to a single constant Z denominator, stores the X and Y\n- *    coordinates as ge_storage points in pre, and stores the global Z in rz.\n- *    It only operates on tables sized for WINDOW_A wnaf multiples.\n- *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n- *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size.\n+ *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n+ *  coordinates as ge_storage points in pre, and stores the global Z in rz.\n+ *  It only operates on tables sized for WINDOW_A wnaf multiples.\n  *\n- *  To compute a*P + b*G, we compute a table for P using the first function,\n- *  and for G using the second (which requires an inverse, but it only needs to\n- *  happen once).\n+ *  To compute a*P + b*G, we compute a table for P using this function,\n+ *  and use the precomputed table in <ecmult_static_pre_g.h> for G.\n  */\n static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -142,137 +115,6 @@ static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *p\n     secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A), pre, globalz, prej, zr);\n }\n \n-static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp256k1_ge_storage *pre, const secp256k1_gej *a) {\n-    secp256k1_gej d;\n-    secp256k1_ge d_ge, p_ge;\n-    secp256k1_gej pj;\n-    secp256k1_fe zi;\n-    secp256k1_fe zr;\n-    secp256k1_fe dx_over_dz_squared;\n-    int i;\n-\n-    VERIFY_CHECK(!a->infinity);\n-\n-    secp256k1_gej_double_var(&d, a, NULL);\n-\n-    /* First, we perform all the additions in an isomorphic curve obtained by multiplying\n-     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use\n-     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store\n-     * the resulting y-coordinate and the z-ratio, since we only have enough memory to\n-     * store two field elements. These are sufficient to efficiently undo the isomorphism\n-     * and recompute all the `x`s.\n-     */\n-    d_ge.x = d.x;\n-    d_ge.y = d.y;\n-    d_ge.infinity = 0;\n-\n-    secp256k1_ge_set_gej_zinv(&p_ge, a, &d.z);\n-    pj.x = p_ge.x;\n-    pj.y = p_ge.y;\n-    pj.z = a->z;\n-    pj.infinity = 0;\n-\n-    for (i = 0; i < (n - 1); i++) {\n-        secp256k1_fe_normalize_var(&pj.y);\n-        secp256k1_fe_to_storage(&pre[i].y, &pj.y);\n-        secp256k1_gej_add_ge_var(&pj, &pj, &d_ge, &zr);\n-        secp256k1_fe_normalize_var(&zr);\n-        secp256k1_fe_to_storage(&pre[i].x, &zr);\n-    }\n-\n-    /* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */\n-    secp256k1_fe_mul(&zi, &pj.z, &d.z);\n-    secp256k1_fe_inv_var(&zi, &zi);\n-\n-    /* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so\n-     * that we can combine it with the saved z-ratios to compute the other zs\n-     * without any more inversions. */\n-    secp256k1_ge_set_gej_zinv(&p_ge, &pj, &zi);\n-    secp256k1_ge_to_storage(&pre[n - 1], &p_ge);\n-\n-    /* Compute the actual x-coordinate of D, which will be needed below. */\n-    secp256k1_fe_mul(&d.z, &zi, &pj.z);  /* d.z = 1/d.z */\n-    secp256k1_fe_sqr(&dx_over_dz_squared, &d.z);\n-    secp256k1_fe_mul(&dx_over_dz_squared, &dx_over_dz_squared, &d.x);\n-\n-    /* Going into the second loop, we have set `pre[n-1]` to its final affine\n-     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We\n-     * have `zi = (p.z * d.z)^-1`, where\n-     *\n-     *     `p.z` is the z-coordinate of the point on the isomorphic curve\n-     *           which was ultimately assigned to `pre[n-1]`.\n-     *     `d.z` is the multiplier that must be applied to all z-coordinates\n-     *           to move from our isomorphic curve back to secp256k1; so the\n-     *           product `p.z * d.z` is the z-coordinate of the secp256k1\n-     *           point assigned to `pre[n-1]`.\n-     *\n-     * All subsequent inverse-z-coordinates can be obtained by multiplying this\n-     * factor by successive z-ratios, which is much more efficient than directly\n-     * computing each one.\n-     *\n-     * Importantly, these inverse-zs will be coordinates of points on secp256k1,\n-     * while our other stored values come from computations on the isomorphic\n-     * curve. So in the below loop, we will take care not to actually use `zi`\n-     * or any derived values until we're back on secp256k1.\n-     */\n-    i = n - 1;\n-    while (i > 0) {\n-        secp256k1_fe zi2, zi3;\n-        const secp256k1_fe *rzr;\n-        i--;\n-\n-        secp256k1_ge_from_storage(&p_ge, &pre[i]);\n-\n-        /* For each remaining point, we extract the z-ratio from the stored\n-         * x-coordinate, compute its z^-1 from that, and compute the full\n-         * point from that. */\n-        rzr = &p_ge.x;\n-        secp256k1_fe_mul(&zi, &zi, rzr);\n-        secp256k1_fe_sqr(&zi2, &zi);\n-        secp256k1_fe_mul(&zi3, &zi2, &zi);\n-        /* To compute the actual x-coordinate, we use the stored z ratio and\n-         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`\n-         * in the loop above, as well as the inverse of the square of its\n-         * z-coordinate. We store the latter in the `zi2` variable, which is\n-         * computed iteratively starting from the overall Z inverse then\n-         * multiplying by each z-ratio in turn.\n-         *\n-         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`\n-         * from the inside of the above `gej_add_ge_var` call. This satisfies\n-         *\n-         *    rzr = d_x * z^2 - x * d_z^2\n-         *\n-         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`\n-         * are Jacobian coordinates of our desired point -- except both are on\n-         * the isomorphic curve that we were using when we called `gej_add_ge_var`.\n-         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or\n-         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes\n-         *\n-         *    rzr = d_x * z^2 / d_z^2 - x\n-         *\n-         * (The left-hand-side, being a ratio of z-coordinates, is unaffected\n-         * by the isomorphism.)\n-         *\n-         * Rearranging to solve for `x`, we have\n-         *\n-         *     x = d_x * z^2 / d_z^2 - rzr\n-         *\n-         * But what we actually want is the affine coordinate `X = x/z^2`,\n-         * which will satisfy\n-         *\n-         *     X = d_x / d_z^2 - rzr / z^2\n-         *       = dx_over_dz_squared - rzr * zi2\n-         */\n-        secp256k1_fe_mul(&p_ge.x, rzr, &zi2);\n-        secp256k1_fe_negate(&p_ge.x, &p_ge.x, 1);\n-        secp256k1_fe_add(&p_ge.x, &dx_over_dz_squared);\n-        /* y is stored_y/z^3, as we expect */\n-        secp256k1_fe_mul(&p_ge.y, &p_ge.y, &zi3);\n-        /* Store */\n-        secp256k1_ge_to_storage(&pre[i], &p_ge);\n-    }\n-}\n-\n /** The following two macro retrieves a particular odd multiple from a table\n  *  of precomputed multiples. */\n #define ECMULT_TABLE_GET_GE(r,pre,n,w) do { \\\n@@ -299,74 +141,6 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n-    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    ;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n-    ctx->pre_g = NULL;\n-    ctx->pre_g_128 = NULL;\n-}\n-\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n-    secp256k1_gej gj;\n-    void* const base = *prealloc;\n-    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-\n-    if (ctx->pre_g != NULL) {\n-        return;\n-    }\n-\n-    /* get the generator */\n-    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n-\n-    {\n-        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-    }\n-\n-    /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n-\n-    {\n-        secp256k1_gej g_128j;\n-        int i;\n-\n-        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-\n-        /* calculate 2^128*generator */\n-        g_128j = gj;\n-        for (i = 0; i < 128; i++) {\n-            secp256k1_gej_double_var(&g_128j, &g_128j, NULL);\n-        }\n-        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n-    }\n-}\n-\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n-    if (src->pre_g != NULL) {\n-        /* We cast to void* first to suppress a -Wcast-align warning. */\n-        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n-    }\n-    if (src->pre_g_128 != NULL) {\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n-    }\n-}\n-\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx) {\n-    return ctx->pre_g != NULL;\n-}\n-\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    secp256k1_ecmult_context_init(ctx);\n-}\n-\n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n  *  with the following guarantees:\n  *  - each wnaf[i] is either 0, or an odd integer between -(1<<(w-1) - 1) and (1<<(w-1) - 1)\n@@ -443,7 +217,7 @@ struct secp256k1_strauss_state {\n     struct secp256k1_strauss_point_state* ps;\n };\n \n-static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult_strauss_wnaf(const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n     /* Splitted G factors. */\n@@ -544,11 +318,11 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             }\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n     }\n@@ -558,7 +332,7 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n     }\n }\n \n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -571,15 +345,15 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     state.pre_a = pre_a;\n     state.pre_a_lam = pre_a_lam;\n     state.ps = ps;\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, 1, a, na, ng);\n }\n \n static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n@@ -612,14 +386,14 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, n_points, points, scalars, inp_g_sc);\n     secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n@@ -866,7 +640,7 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n@@ -881,7 +655,6 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n     int i, j;\n     int bucket_window;\n \n-    (void)ctx;\n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n@@ -941,8 +714,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n@@ -986,7 +759,7 @@ static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_cal\n \n /* Computes ecmult_multi by simply multiplying and adding each point. Does not\n  * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n+static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n     size_t point_idx;\n     secp256k1_scalar szero;\n     secp256k1_gej tmpj;\n@@ -995,7 +768,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n     secp256k1_gej_set_infinity(r);\n     secp256k1_gej_set_infinity(&tmpj);\n     /* r = inp_g_sc*G */\n-    secp256k1_ecmult(ctx, r, &tmpj, &szero, inp_g_sc);\n+    secp256k1_ecmult(r, &tmpj, &szero, inp_g_sc);\n     for (point_idx = 0; point_idx < n_points; point_idx++) {\n         secp256k1_ge point;\n         secp256k1_gej pointj;\n@@ -1005,7 +778,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n         }\n         /* r += scalar*point */\n         secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(ctx, &tmpj, &pointj, &scalar, NULL);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n     return 1;\n@@ -1031,11 +804,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1045,33 +818,33 @@ static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback,\n     } else if (n == 0) {\n         secp256k1_scalar szero;\n         secp256k1_scalar_set_int(&szero, 0);\n-        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        secp256k1_ecmult(r, r, &szero, inp_g_sc);\n         return 1;\n     }\n     if (scratch == NULL) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n \n     /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n      * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n      * As a first step check if there's enough space for Pippenger's algo (which requires less space\n      * than Strauss' algo) and if not, use the simple algorithm. */\n     if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n         if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n-            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+            return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "9072fb268860c959bbde3b0074d6451e39db7445",
        "filename": "src/ecmult_static_pre_g.h",
        "status": "added",
        "additions": 16611,
        "deletions": 0,
        "changes": 16611,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecmult_static_pre_g.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/ecmult_static_pre_g.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_static_pre_g.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d"
      },
      {
        "sha": "6fa16f6c3df3d909c2da01ef75b08aa970d1390a",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -122,4 +122,7 @@ static void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_f\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag);\n \n+/** Compute the Jacobi symbol of a / p. 0 if a=0; 1 if a square; -1 if a non-square. */\n+static int secp256k1_fe_jacobi_var(const secp256k1_fe *a);\n+\n #endif /* SECP256K1_FIELD_H */"
      },
      {
        "sha": "4d95f18efe59167c8b23c183b24b59d592656b89",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -1253,4 +1253,25 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n     VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n }\n \n+static int secp256k1_fe_jacobi_var(const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv32_signed30 s;\n+    int ret;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    /* secp256k1_jacobi32_maybe_var cannot deal with input=0; handle it specially. */\n+    if (secp256k1_fe_is_zero(&tmp)) return 0;\n+    secp256k1_fe_to_signed30(&s, &tmp);\n+    ret = secp256k1_jacobi32_maybe_var(&s, &secp256k1_const_modinfo_fe);\n+    if (ret == 0) {\n+        /* secp256k1_jacobi32_maybe_var failed to compute the Jacobi symbol. Fall back\n+         * to computing a square root. This should be extremely rare with random\n+         * input. */\n+        secp256k1_fe dummy;\n+        ret = 2*secp256k1_fe_sqrt(&dummy, &tmp) - 1;\n+    }\n+    return ret;\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "320dc8f4a0430ac156804af4d337165ae73dacb8",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -575,4 +575,25 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n #endif\n }\n \n+static int secp256k1_fe_jacobi_var(const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+    int ret;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    /* secp256k1_jacobi64_maybe_var cannot deal with input=0; handle it specially. */\n+    if (secp256k1_fe_is_zero(&tmp)) return 0;\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    ret = secp256k1_jacobi64_maybe_var(&s, &secp256k1_const_modinfo_fe);\n+    if (ret == 0) {\n+        /* secp256k1_jacobi64_maybe_var failed to compute the Jacobi symbol. Fall back\n+         * to computing a square root. This should be extremely rare with random\n+         * input. */\n+        secp256k1_fe dummy;\n+        ret = 2*secp256k1_fe_sqrt(&dummy, &tmp) - 1;\n+    }\n+    return ret;\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "af40d13f9c6a1dd76cf0a249a7ab4f82e75e45f6",
        "filename": "src/gen_ecmult_static_pre_g.c",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/gen_ecmult_static_pre_g.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/gen_ecmult_static_pre_g.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_ecmult_static_pre_g.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1,137 @@\n+/*****************************************************************************************************\n+ * Copyright (c) 2013, 2014, 2017, 2021 Pieter Wuille, Andrew Poelstra, Jonas Nick, Russell O'Connor *\n+ * Distributed under the MIT software license, see the accompanying                                  *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.                              *\n+ *****************************************************************************************************/\n+\n+#include <inttypes.h>\n+#include <stdio.h>\n+\n+/* Autotools creates libsecp256k1-config.h, of which ECMULT_WINDOW_SIZE is needed.\n+   ifndef guard so downstream users can define their own if they do not use autotools. */\n+#if !defined(ECMULT_WINDOW_SIZE)\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n+#include \"assumptions.h\"\n+#include \"util.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"ecmult.h\"\n+\n+void print_table(FILE *fp, const char *name, int window_g, const secp256k1_gej *gen, int with_conditionals) {\n+    static secp256k1_gej gj;\n+    static secp256k1_ge ge, dgen;\n+    static secp256k1_ge_storage ges;\n+    int j;\n+    int i;\n+\n+    gj = *gen;\n+    secp256k1_ge_set_gej_var(&ge, &gj);\n+    secp256k1_ge_to_storage(&ges, &ge);\n+\n+    fprintf(fp, \"static const secp256k1_ge_storage %s[ECMULT_TABLE_SIZE(WINDOW_G)] = {\\n\", name);\n+    fprintf(fp, \" S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                  \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                SECP256K1_GE_STORAGE_CONST_GET(ges));\n+\n+    secp256k1_gej_double_var(&gj, gen, NULL);\n+    secp256k1_ge_set_gej_var(&dgen, &gj);\n+\n+    j = 1;\n+    for(i = 3; i <= window_g; ++i) {\n+        if (with_conditionals) {\n+            fprintf(fp, \"#if ECMULT_TABLE_SIZE(WINDOW_G) > %ld\\n\", ECMULT_TABLE_SIZE(i-1));\n+        }\n+        for(;j < ECMULT_TABLE_SIZE(i); ++j) {\n+            secp256k1_gej_set_ge(&gj, &ge);\n+            secp256k1_gej_add_ge_var(&gj, &gj, &dgen, NULL);\n+            secp256k1_ge_set_gej_var(&ge, &gj);\n+            secp256k1_ge_to_storage(&ges, &ge);\n+\n+            fprintf(fp, \",S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                          \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                        SECP256K1_GE_STORAGE_CONST_GET(ges));\n+        }\n+        if (with_conditionals) {\n+            fprintf(fp, \"#endif\\n\");\n+        }\n+    }\n+    fprintf(fp, \"};\\n\");\n+}\n+\n+void print_two_tables(FILE *fp, int window_g, const secp256k1_ge *g, int with_conditionals) {\n+    secp256k1_gej gj;\n+    int i;\n+\n+    secp256k1_gej_set_ge(&gj, g);\n+    print_table(fp, \"secp256k1_pre_g\", window_g, &gj, with_conditionals);\n+    for (i = 0; i < 128; ++i) {\n+        secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    print_table(fp, \"secp256k1_pre_g_128\", window_g, &gj, with_conditionals);\n+}\n+\n+int main(void) {\n+    const secp256k1_ge g = SECP256K1_G;\n+    const secp256k1_ge g_13 = SECP256K1_G_ORDER_13;\n+    const secp256k1_ge g_199 = SECP256K1_G_ORDER_199;\n+    const int window_g_13 = 4;\n+    const int window_g_199 = 8;\n+    FILE* fp;\n+\n+    fp = fopen(\"src/ecmult_static_pre_g.h\",\"w\");\n+    if (fp == NULL) {\n+        fprintf(stderr, \"Could not open src/ecmult_static_pre_g.h for writing!\\n\");\n+        return -1;\n+    }\n+\n+    fprintf(fp, \"/* This file was automatically generated by gen_ecmult_static_pre_g. */\\n\");\n+    fprintf(fp, \"/* This file contains an array secp256k1_pre_g with odd multiples of the base point G and\\n\");\n+    fprintf(fp, \" * an array secp256k1_pre_g_128 with odd multiples of 2^128*G for accelerating the computation of a*P + b*G.\\n\");\n+    fprintf(fp, \" */\\n\");\n+    fprintf(fp, \"#ifndef SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#define SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#include \\\"group.h\\\"\\n\");\n+    fprintf(fp, \"#ifdef S\\n\");\n+    fprintf(fp, \"   #error macro identifier S already in use.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#define S(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \"\n+                \"SECP256K1_GE_STORAGE_CONST(0x##a##u,0x##b##u,0x##c##u,0x##d##u,0x##e##u,0x##f##u,0x##g##u,\"\n+                \"0x##h##u,0x##i##u,0x##j##u,0x##k##u,0x##l##u,0x##m##u,0x##n##u,0x##o##u,0x##p##u)\\n\");\n+    fprintf(fp, \"#if ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE) > %ld\\n\", ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE));\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_WINDOW_SIZE. Try deleting ecmult_static_pre_g.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#if defined(EXHAUSTIVE_TEST_ORDER)\\n\");\n+    fprintf(fp, \"#if EXHAUSTIVE_TEST_ORDER == 13\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_13);\n+\n+    print_two_tables(fp, window_g_13, &g_13, 0);\n+\n+    fprintf(fp, \"#elif EXHAUSTIVE_TEST_ORDER == 199\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_199);\n+\n+    print_two_tables(fp, window_g_199, &g_199, 0);\n+\n+    fprintf(fp, \"#else\\n\");\n+    fprintf(fp, \"   #error No known generator for the specified exhaustive test group order.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#else /* !defined(EXHAUSTIVE_TEST_ORDER) */\\n\");\n+    fprintf(fp, \"#define WINDOW_G ECMULT_WINDOW_SIZE\\n\");\n+\n+    print_two_tables(fp, ECMULT_WINDOW_SIZE, &g, 1);\n+\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#undef S\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fclose(fp);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "6fc58ea01599acdccf3ced5be62cc19030a861fa",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -10,6 +10,27 @@\n #include \"field.h\"\n #include \"group.h\"\n \n+#define SECP256K1_G_ORDER_13 SECP256K1_GE_CONST(\\\n+    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\\\n+    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\\\n+    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\\\n+    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\\\n+)\n+#define SECP256K1_G_ORDER_199 SECP256K1_GE_CONST(\\\n+    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\\\n+    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\\\n+    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\\\n+    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\\\n+)\n+/** Generator for secp256k1, value 'g' defined in\n+ *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n+ */\n+#define SECP256K1_G SECP256K1_GE_CONST(\\\n+    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\\\n+    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\\\n+    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\\\n+    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\\\n+)\n /* These exhaustive group test orders and generators are chosen such that:\n  * - The field size is equal to that of secp256k1, so field code is the same.\n  * - The curve equation is of the form y^2=x^3+B for some constant B.\n@@ -21,23 +42,15 @@\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 13\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\n-    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\n-    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\n-    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_13;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x3d3486b2, 0x159a9ca5, 0xc75638be, 0xb23a69bc,\n     0x946a45ab, 0x24801247, 0xb4ed2b8e, 0x26b6a417\n );\n #  elif EXHAUSTIVE_TEST_ORDER == 199\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\n-    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\n-    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\n-    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_199;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x2cca28fa, 0xfc614b80, 0x2a3db42b, 0x00ba00b1,\n     0xbea8d943, 0xdace9ab2, 0x9536daea, 0x0074defb\n@@ -46,15 +59,7 @@ static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n #else\n-/** Generator for secp256k1, value 'g' defined in\n- *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n- */\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\n-    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\n-    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\n-    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G;\n \n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 7);\n #endif"
      },
      {
        "sha": "fbeca01a358f605987a046bdf749ddc09a67eb44",
        "filename": "src/modinv32.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv32.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -39,4 +39,7 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\n /* Same as secp256k1_modinv32_var, but constant time in x (not in the modulus). */\n static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n \n+/* Compute the Jacobi symbol for x (where gcd(x,p) == 1), 0 if it cannot be determined. */\n+static int secp256k1_jacobi32_maybe_var(const secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n+\n #endif /* SECP256K1_MODINV32_H */"
      },
      {
        "sha": "47c774fa4c11049f7d7b2146152bf721e75501ba",
        "filename": "src/modinv32_impl.h",
        "status": "modified",
        "additions": 152,
        "deletions": 16,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv32_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -232,6 +232,21 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t zeta, uint32_t f0, uint32_\n     return zeta;\n }\n \n+/* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+static const uint8_t secp256k1_modinv32_inv256[128] = {\n+    0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+    0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+    0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+    0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+    0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+    0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+    0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+    0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+    0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+    0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+    0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+};\n+\n /* Compute the transition matrix and eta for 30 divsteps (variable time).\n  *\n  * Input:  eta: initial eta\n@@ -243,21 +258,6 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t zeta, uint32_t f0, uint32_\n  * Implements the divsteps_n_matrix_var function from the explanation.\n  */\n static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\n-    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n-    static const uint8_t inv256[128] = {\n-        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n-        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n-        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n-        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n-        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n-        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n-        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n-        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n-        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n-        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n-        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n-    };\n-\n     /* Transformation matrix; see comments in secp256k1_modinv32_divsteps_30. */\n     uint32_t u = 1, v = 0, q = 0, r = 1;\n     uint32_t f = f0, g = g0, m;\n@@ -297,7 +297,7 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\n         VERIFY_CHECK(limit > 0 && limit <= 30);\n         m = (UINT32_MAX >> (32 - limit)) & 255U;\n         /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n-        w = (g * inv256[(f >> 1) & 127]) & m;\n+        w = (g * secp256k1_modinv32_inv256[(f >> 1) & 127]) & m;\n         /* Do so. */\n         g += f * w;\n         q += u * w;\n@@ -317,6 +317,83 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\n     return eta;\n }\n \n+/* Compute the transition matrix and eta for 30 posdivsteps (variable time, eta=-delta), and keeps track\n+ * of the Jacobi symbol along the way. f0 and g0 must be f and g mod 2^32 rather than 2^30, because\n+ * Jacobi tracking requires knowing (f mod 8) rather than just (f mod 2).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ */\n+static int32_t secp256k1_modinv32_posdivsteps_30_var(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t, int *jacp) {\n+    /* Transformation matrix. */\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m;\n+    uint16_t w;\n+    int i = 30, limit, zeros;\n+    int jac = *jacp;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* Update the bottom bit of jac: when dividing g by an odd power of 2,\n+         * if (f mod 8) is 3 or 5, the Jacobi symbol changes sign. */\n+        jac ^= (zeros & ((f >> 1) ^ (f >> 2)));\n+        /* We're done once we've done 60 posdivsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint32_t tmp;\n+            eta = -eta;\n+            /* Update bottom bit of jac: when swapping f and g, the Jacobi symbol changes sign\n+             * if both f and g are 3 mod 4. */\n+            jac ^= ((f & g) >> 1);\n+            tmp = f; f = g; g = tmp;\n+            tmp = u; u = q; q = tmp;\n+            tmp = v; v = r; r = tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        VERIFY_CHECK(limit > 0 && limit <= 30);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * secp256k1_modinv32_inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int32_t)u;\n+    t->v = (int32_t)v;\n+    t->q = (int32_t)q;\n+    t->r = (int32_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2 or -2,\n+     * the aggregate of 30 of them will have determinant 2^30 or -2^30. */\n+    VERIFY_CHECK((int64_t)t->u * t->r - (int64_t)t->v * t->q == ((int64_t)1) << 30 ||\n+                 (int64_t)t->u * t->r - (int64_t)t->v * t->q == -(((int64_t)1) << 30));\n+    *jacp = jac;\n+    return eta;\n+}\n+\n /* Compute (t/2^30) * [d, e] mod modulus, where t is a transition matrix for 30 divsteps.\n  *\n  * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n@@ -584,4 +661,63 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\n     *x = d;\n }\n \n+/* Compute the Jacobi symbol of x modulo modinfo->modulus (variable time). gcd(x,modulus) must be 1. */\n+static int secp256k1_jacobi32_maybe_var(const secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo) {\n+    /* Start with f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv32_signed30 f = modinfo->modulus;\n+    secp256k1_modinv32_signed30 g = *x;\n+    int j, len = 9;\n+    int32_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int32_t cond, fn, gn;\n+    int jac = 0;\n+    int count;\n+\n+    /* Do up to 50 iterations of 30 posdivsteps (up to 1500 steps; more is extremely rare) each until f=1. */\n+    for (count = 0; count < 50; ++count) {\n+        /* Compute transition matrix and new eta after 30 posdivsteps. */\n+        secp256k1_modinv32_trans2x2 t;\n+        eta = secp256k1_modinv32_posdivsteps_30_var(eta, f.v[0] | ((uint32_t)f.v[1] << 30), g.v[0] | ((uint32_t)g.v[1] << 30), &t, &jac);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+        secp256k1_modinv32_update_fg_30_var(len, &f, &g, &t);\n+        /* If the bottom limb of f is 1, there is a chance that f=1. */\n+        if (f.v[0] == 1) {\n+            cond = 0;\n+            /* Check if the other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= f.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) return 1 - 2*(jac & 1);\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int32_t)len - 2) >> 31;\n+        cond |= fn;\n+        cond |= gn;\n+        /* If so, reduce length. */\n+        if (cond == 0) --len;\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+    }\n+\n+    /* While we don't want production code to assume that the loop above always reaches f=1,\n+     * it's a reasonable thing to check for in test code (as long as we don't have a way\n+     * for constructing known bad examples in the tests). */\n+    VERIFY_CHECK(0);\n+\n+    return 0;\n+}\n+\n #endif /* SECP256K1_MODINV32_IMPL_H */"
      },
      {
        "sha": "7c558f3e32ee1c3f35b0f46c4a9b351eddf682ec",
        "filename": "src/modinv64.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv64.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -43,4 +43,7 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\n /* Same as secp256k1_modinv64_var, but constant time in x (not in the modulus). */\n static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n \n+/* Compute the Jacobi symbol for x (where gcd(x,p) == 1), 0 if it cannot be determined. */\n+static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n+\n #endif /* SECP256K1_MODINV64_H */"
      },
      {
        "sha": "e717e63295b3f55eabb61c1d307e458a569e5ce9",
        "filename": "src/modinv64_impl.h",
        "status": "modified",
        "additions": 147,
        "deletions": 0,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modinv64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modinv64_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -294,6 +294,94 @@ static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint\n     return eta;\n }\n \n+/* Compute the transition matrix and eta for 62 posdivsteps (variable time, eta=-delta), and keeps track\n+ * of the Jacobi symbol along the way. f0 and g0 must be f and g mod 2^64 rather than 2^62, because\n+ * Jacobi tracking requires knowing (f mod 8) rather than just (f mod 2).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ */\n+static int64_t secp256k1_modinv64_posdivsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t, int *jacp) {\n+    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */\n+    uint64_t u = 1, v = 0, q = 0, r = 1;\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+    int jac = *jacp;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* Update the bottom bit of jac: when dividing g by an odd power of 2,\n+         * if (f mod 8) is 3 or 5, the Jacobi symbol changes sign. */\n+        jac ^= (zeros & ((f >> 1) ^ (f >> 2)));\n+        /* We're done once we've done 60 posdivsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = tmp;\n+            tmp = u; u = q; q = tmp;\n+            tmp = v; v = r; r = tmp;\n+            /* Update bottom bit of jac: when swapping f and g, the Jacobi symbol changes sign\n+             * if both f and g are 3 mod 4. */\n+            jac ^= ((f & g) >> 1);\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;\n+        } else {\n+            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as\n+             * eta tends to be smaller here. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 4) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 15U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 4)\n+             * bits. */\n+            w = f + (((f + 1) & 4) << 1);\n+            w = (-w * g) & m;\n+        }\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2 or -2,\n+     * the aggregate of 62 of them will have determinant 2^62 or -2^62. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 62 ||\n+                 (int128_t)t->u * t->r - (int128_t)t->v * t->q == -(((int128_t)1) << 62));\n+    *jacp = jac;\n+    return eta;\n+}\n+\n /* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix scaled by 2^62.\n  *\n  * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n@@ -590,4 +678,63 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\n     *x = d;\n }\n \n+/* Compute the Jacobi symbol of x modulo modinfo->modulus (variable time). gcd(x,modulus) must be 1. */\n+static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int j, len = 5;\n+    int64_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int64_t cond, fn, gn;\n+    int jac = 0;\n+    int count;\n+\n+    /* Do up to 25 iterations of 62 posdivsteps (up to 1550 steps; more is extremely rare) each until f=1. */\n+    for (count = 0; count < 25; ++count) {\n+        /* Compute transition matrix and new eta after 62 posdivsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_posdivsteps_62_var(eta, f.v[0] | ((uint64_t)f.v[1] << 62), g.v[0] | ((uint64_t)g.v[1] << 62), &t, &jac);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+        secp256k1_modinv64_update_fg_62_var(len, &f, &g, &t);\n+        /* If the bottom limb of f is 1, there is a chance that f=1. */\n+        if (f.v[0] == 1) {\n+            cond = 0;\n+            /* Check if the other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= f.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) return 1 - 2*(jac & 1);\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int64_t)len - 2) >> 63;\n+        cond |= fn;\n+        cond |= gn;\n+        /* If so, reduce length. */\n+        if (cond == 0) --len;\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+    }\n+\n+    /* While we don't want production code to assume that the loop above always reaches f=1,\n+     * it's a reasonable thing to check for in test code (as long as we don't have a way\n+     * for constructing known bad examples in the tests). */\n+    VERIFY_CHECK(0);\n+\n+    return 0;\n+}\n+\n #endif /* SECP256K1_MODINV64_IMPL_H */"
      },
      {
        "sha": "95baa686c277051fac1619e978adfecf67e0053b",
        "filename": "src/modules/ellsq/Makefile.am.include",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/ellsq/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/ellsq/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ellsq/Makefile.am.include?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_ellsq.h\n+noinst_HEADERS += src/modules/ellsq/main_impl.h\n+noinst_HEADERS += src/modules/ellsq/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_ellsq\n+bench_ellsq_SOURCES = src/bench_ellsq.c\n+bench_ellsq_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif"
      },
      {
        "sha": "81b2b9c7745cc04d413adfdf1b721ca8e2fef80a",
        "filename": "src/modules/ellsq/main_impl.h",
        "status": "added",
        "additions": 305,
        "deletions": 0,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/ellsq/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/ellsq/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ellsq/main_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellsq_decode(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe f1, f2;\n+    secp256k1_ge p1, p2;\n+    secp256k1_gej acc;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&f1, ell64);\n+    secp256k1_fe_set_b32(&f2, ell64 + 32);\n+    secp256k1_ellsq_fe_to_ge_var(&p1, &f1);\n+    secp256k1_ellsq_fe_to_ge_var(&p2, &f2);\n+    secp256k1_gej_set_ge(&acc, &p1);\n+    secp256k1_gej_add_ge_var(&acc, &acc, &p2, NULL);\n+    if (!secp256k1_gej_is_infinity(&acc)) {\n+        secp256k1_ge_set_gej_var(&p1, &acc);\n+    } else {\n+        /* f(u1)+f(u2) is infinity. In that case the decoding is defined to be\n+         * equal to f(u1) instead. f(u1) is already stored in the p1 variable\n+         * at this point. */\n+    }\n+    secp256k1_pubkey_save(pubkey, &p1);\n+    return 1;\n+}\n+\n+#endif"
      },
      {
        "sha": "59c3a7c6386cee2d48fb832ceafcbd1e8090447d",
        "filename": "src/modules/ellsq/tests_impl.h",
        "status": "added",
        "additions": 157,
        "deletions": 0,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/ellsq/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/ellsq/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ellsq/tests_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -0,0 +1,157 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_TESTS_H\n+#define SECP256K1_MODULE_ELLSQ_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellsq.h\"\n+\n+struct ellsq_test {\n+    secp256k1_ge point;\n+    int enc_bitmap;\n+    secp256k1_fe encs[4];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_test ellsq_tests[] = {\n+    {SECP256K1_GE_CONST(0xc27fb7a3, 0x283a7d3e, 0xc9f96421, 0x545ef6f5, 0x8ace7b71, 0x06c8a1b9, 0x07c0ae8a, 0x7598159c, 0xe05a060e, 0x839ef79f, 0xc0c1267c, 0xa17880c9, 0x584cdd34, 0xc05f9695, 0x55482207, 0xe6851f2a), 15, {SECP256K1_FE_CONST(0xc0ad127a, 0xa36824d6, 0x5b1f5be7, 0x4de1aa25, 0xbc4d5cbe, 0xcee15462, 0x0a12682a, 0xfc87df98), SECP256K1_FE_CONST(0xd40fd5bc, 0x51992484, 0x8f13273b, 0x1d857cba, 0x42d45e78, 0x9eaa4e47, 0xf458b83a, 0xbd5f8d1c), SECP256K1_FE_CONST(0xde636141, 0x7deb440b, 0x3a305924, 0x43635cf9, 0xcf42f9b5, 0xf5b891c1, 0x1e119f09, 0x71b570ac), SECP256K1_FE_CONST(0xd55135ce, 0x41bb4d05, 0x5b3757f4, 0xaf1d6537, 0x137376d7, 0x5270caae, 0xda68382d, 0x25d00708)}},\n+    {SECP256K1_GE_CONST(0x3f5ada4e, 0x8f646ec9, 0x10ffc1a2, 0xb74d94bb, 0xb1860631, 0xa3c2a349, 0xeddf55ca, 0xfd49cce9, 0x28ad9d8d, 0x77d9cd87, 0xf80aaa34, 0x8e9ad1b4, 0x40353d7a, 0x6e717714, 0x60425319, 0x38f530c3), 15, {SECP256K1_FE_CONST(0xac42348f, 0x1b356822, 0x5bb7d4c0, 0x0feab37e, 0xa5fb7fbb, 0x0cc3879d, 0xc74e2dda, 0xf9a393bf), SECP256K1_FE_CONST(0xda7a45b2, 0x6c87dcb6, 0x4a934c1d, 0xc841d250, 0xf98af5f0, 0x511be2a3, 0x82d17bab, 0xe1e4a533), SECP256K1_FE_CONST(0xc3d9b9a6, 0x570ca9c8, 0xa640fc75, 0x945850b2, 0xcc86b6d6, 0x399b4496, 0x4288d76d, 0x832a32d7), SECP256K1_FE_CONST(0xbf5ebc2f, 0x4060abe7, 0x884a1fa7, 0xcc0883cb, 0x97535c5a, 0x31dc6df4, 0xc6968e9d, 0x8554f3b1)}},\n+    {SECP256K1_GE_CONST(0xf5f74fab, 0x3ebbbcfd, 0xdcaef6cc, 0xd14eb934, 0xf9435a4e, 0x4a1ed2d8, 0x75352c47, 0x306d6c2f, 0xea6a5b2a, 0xe109897d, 0x046e1504, 0xf7a382d6, 0x1eb49a8a, 0xae8852ef, 0x48e29466, 0x194d9e66), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xe8362df2, 0x38e0405b, 0x49218747, 0x74f9ebca, 0x36dfe21b, 0x1a49ae2d, 0x0fa23fd4, 0x11a262a6), SECP256K1_FE_CONST(0x9e453426, 0xac973155, 0x19d11d63, 0xc3bb27ee, 0x89a7ec85, 0x5661dce4, 0xe428f6cc, 0x0be059cc)}},\n+    {SECP256K1_GE_CONST(0x977694f6, 0x6f0a3005, 0x2c638916, 0x61432fa0, 0x605528a7, 0xad87d829, 0x5c9eb9a3, 0x973c6fed, 0x16515f14, 0x00186fec, 0x67f6314c, 0x8a9e2d43, 0x3d2020e9, 0x38f86465, 0x39f749a1, 0x51a793ed), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x8f091a42, 0xce496be8, 0x877d43fc, 0x2f2b2927, 0x42c9c1fb, 0x0dfe570b, 0x9c9fbd3e, 0x04afa709), SECP256K1_FE_CONST(0xb5930cf1, 0x4db355a5, 0xa92b9f78, 0x9390b59a, 0x013c8e27, 0x7c41ddd6, 0xd8221622, 0x93d39141)}},\n+    {SECP256K1_GE_CONST(0x9c970ce9, 0x39e8a4ec, 0x70237f33, 0xad858370, 0xc9d30e8a, 0xadaac257, 0x546d1e16, 0xf374973b, 0x95755fab, 0x1bcae32e, 0xc811c63f, 0xb1e56da8, 0x97a1e140, 0xb1aae97e, 0x0b6ae6c5, 0x3879f51c), 13, {SECP256K1_FE_CONST(0xa7424f55, 0x60b58ceb, 0xbb9a6ee1, 0x5fc41b18, 0xf282b2cd, 0xd9e2fb4d, 0x02626c1a, 0xc0a89ec4), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xd7016e9b, 0x94db9b4c, 0x5bc61c87, 0xaf3b3c9c, 0x72707e5e, 0x48332958, 0xce5371bf, 0xd501a006), SECP256K1_FE_CONST(0xe95cd3a1, 0x2cff74bd, 0x6761a782, 0x61f73f0d, 0x755a80f6, 0x39ccd117, 0x136f9963, 0xf422b82a)}},\n+    {SECP256K1_GE_CONST(0x48206211, 0x5e6fc771, 0x738b4859, 0x4da66901, 0xa0a8c36e, 0xa61122b7, 0x745cf5fe, 0xec932b64, 0x01c9e1a1, 0x59effb22, 0x4442c868, 0x9119fd26, 0x8cdca070, 0x7edbefb6, 0xea81d5f6, 0x86333768), 13, {SECP256K1_FE_CONST(0xf1047fb9, 0x4cfa6dcd, 0x202e1acc, 0xa85afc88, 0x46381925, 0x7adf32aa, 0x25e19e52, 0xbf3cadd8), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x94dc1b2b, 0x6a24bbdb, 0x36afab1a, 0x6e036e7f, 0xdf1ded22, 0x915bf761, 0x97e5e5a5, 0xc6261582), SECP256K1_FE_CONST(0x8dd664ba, 0x47061bac, 0x0c99d727, 0xac2ade9f, 0xf8d33aff, 0x995a7a28, 0x97f2968c, 0x558ef724)}},\n+    {SECP256K1_GE_CONST(0x47e54d7b, 0x86025d30, 0x248b18e6, 0xc6b2b128, 0x3f8eb11e, 0x60d11cad, 0xf59884ea, 0x56939f5a, 0xb618d932, 0x6110c200, 0xcbed144f, 0xc6376800, 0xd8ba0de1, 0xd87fa02d, 0x17d1d58d, 0x9652c498),  3, {SECP256K1_FE_CONST(0x8797d6a9, 0xe3614b34, 0x80e43cb6, 0x936cd932, 0xbe4eee02, 0x1e47e067, 0x2d1d9f2f, 0xd0148558), SECP256K1_FE_CONST(0xb19c75d0, 0xb4856c81, 0xb467f8f5, 0xb9f8d849, 0x0e5296f0, 0x4c60d639, 0x6f772b7f, 0x427c5d38), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8fa5ffb5, 0x597068f6, 0x06785a63, 0x1f74cd6f, 0x8b16e94b, 0xe6cee831, 0x2970e0ec, 0xa9ecda52, 0x6c4f0efe, 0xf1d0eef2, 0xe3281b13, 0x4f29289f, 0x0a9d7b4d, 0xb3118c5f, 0x1d2d1da4, 0x75569ebf),  3, {SECP256K1_FE_CONST(0xe66995d0, 0x9cfdddda, 0xadf4b4ec, 0xc00270ed, 0xaeaacf01, 0x2db38d37, 0xe4143baf, 0x0ae7dfa3), SECP256K1_FE_CONST(0xfe0d264e, 0x3121942c, 0xd5126e26, 0x0766f36c, 0x3a08a689, 0x4e8ec172, 0xf3fdb252, 0x70def1ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x016a682d, 0x1df4f869, 0xb32c48b0, 0xa9b442a1, 0x493949fb, 0x85d951d1, 0x21c1143b, 0xd3d5c1af, 0x38d33fe5, 0xd3f9b4b9, 0x82e37dff, 0x7561428d, 0x47ef4ddf, 0x654bd959, 0x51b04e90, 0xa3be50e7),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ec42424, 0xb4d2226f, 0x83f94258, 0xc737d0da, 0xf93a4eb1, 0x1d9b9e3f, 0xd500d5b9, 0xc3aa7c71, 0x84975819, 0xb703da77, 0xca98bd3c, 0xd9bbdc7a, 0xf1dbc7b5, 0x85c590eb, 0xcbd417fd, 0x739ad572),  1, {SECP256K1_FE_CONST(0x945faa12, 0x7e8bf378, 0x63581bfb, 0xde084bf7, 0x63caee39, 0x1449c610, 0xc2074f86, 0xff1bf16c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x69ee52b2, 0x88dfb06a, 0x449d3db8, 0x7602e094, 0xb4f131e3, 0xf6a4b249, 0xdc0a76ff, 0xdebe989a, 0x3922f1a4, 0xdd208f94, 0xcbac1c5d, 0x34a9278d, 0x84310781, 0x84ff4430, 0x31a14018, 0x95ffd9e6),  1, {SECP256K1_FE_CONST(0xdc1e4760, 0x15bda784, 0xa1b9527b, 0x0357786a, 0xdf2a8028, 0x03957837, 0xe10cff92, 0x5ef4ca7e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0x3ac01550, 0x68185039, 0x6068aaf0, 0xc3f24144, 0x9a267956, 0x698833d4, 0x80c03dc5, 0x678b67cf),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9ddddd8e, 0xc1814a29, 0x3fcca202, 0xebfbe14e, 0x5d808dda, 0x142eee64, 0xc6108381, 0xe99e5cff, 0xb5072d55, 0x37223f39, 0x3e4176d2, 0xcfd93c86, 0x82ca2c22, 0xcd25ec40, 0x877296bd, 0xbb7c08f6),  3, {SECP256K1_FE_CONST(0xadd34f27, 0xc5f90171, 0x75186c23, 0xd14f6ef2, 0xaa182896, 0x77d5373a, 0xd6c31e9f, 0xf6358ae8), SECP256K1_FE_CONST(0xf5ee8614, 0x1916fe03, 0x945d028b, 0xbc354c4a, 0x09f6d6ab, 0x1468ab9a, 0xd8742075, 0x1543c2a2), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ee7e9a7, 0xfcd56edf, 0xabf3712e, 0x72cc24a3, 0x0a476f5a, 0x97f77825, 0xf0308620, 0x162f31ad, 0x77bfc7de, 0xc2401a39, 0x8c5e8675, 0x417c8a7b, 0x632f5d64, 0x2f1a5059, 0x9a830b8c, 0x7981f636),  3, {SECP256K1_FE_CONST(0xb3a8d9e7, 0x368af258, 0x3785be92, 0x2ad54dfb, 0x47329513, 0x6ade2d18, 0x2f931cd6, 0x54f35d02), SECP256K1_FE_CONST(0xe1d420e5, 0xfab5c26d, 0xf4294b2b, 0x0c19eb9a, 0x188409bf, 0x48a3741f, 0x31f72acc, 0x6ea93418), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9e24d0a5, 0xd5014164, 0x987f86bb, 0x1709305a, 0x6fd352a0, 0xa3478fae, 0x3f85e594, 0x21d72a80, 0x3729c39b, 0xbbb26d97, 0xa4ec6bf7, 0xcb4e6453, 0x058e448e, 0x7530b028, 0xd1ae345e, 0x35608d3c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x15f2f1a4, 0x339f5f2a, 0x313b9501, 0x5cad8124, 0xd054a171, 0xac2f31cf, 0x529dda7c, 0xfb6a38b4, 0xfe1d0fa5, 0x95b4f7d3, 0x63e82c29, 0x0095189f, 0x5f2be99c, 0x880be4fc, 0x9742a31b, 0x40041eda),  1, {SECP256K1_FE_CONST(0xc1c3ed27, 0x17ffabfd, 0x01132f5e, 0x54dd73c3, 0x475297e0, 0xfdbff814, 0xdc9456b8, 0x4a57b698), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd383134d, 0x721cf055, 0x143570e7, 0x82bb323d, 0x5c542a61, 0xe455823e, 0xd60b940f, 0x86826d54, 0x5a88e50b, 0x3f59874e, 0x84dab4a2, 0x07d34623, 0xd836c376, 0xc68dded3, 0xc095a716, 0xf563e4fc),  1, {SECP256K1_FE_CONST(0xe4d2660c, 0x1d50d031, 0x97f5e610, 0x4d9c2066, 0x01f6c791, 0xadb52178, 0xe2bd6c88, 0xe89cf012), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  3, {SECP256K1_FE_CONST(0xd3779b57, 0x3cb17828, 0xac118cff, 0x74412ab5, 0xb84c86f8, 0xa92f48b8, 0xefcbe4c7, 0x0a675631), SECP256K1_FE_CONST(0xea6f729d, 0xdc884123, 0xf0130aa0, 0x339bda36, 0x2166d034, 0xfe50d9d7, 0x53bf0dde, 0x7721fa3f), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x99a70224, 0xc3062c32, 0x6c45d3c6, 0x46a545e9, 0xb152b75b, 0xee868378, 0x07e47951, 0x9e5b600d, 0x95b6675a, 0x10845b66, 0x37ff96e8, 0xe67f2a75, 0xbbf0f764, 0xc56d26c5, 0x4b2db5eb, 0xb026d7de),  3, {SECP256K1_FE_CONST(0xb74a9552, 0xc5b9b6ed, 0x575d380f, 0xec3df8ed, 0xdb524ed1, 0x80b13607, 0x81e2eec6, 0x7ad06c04), SECP256K1_FE_CONST(0xbb702282, 0x4194fbe4, 0x4a74c4f4, 0xabd01ee3, 0xdac8f4cb, 0x5a0e3a67, 0xd2276039, 0xdd4aac1a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb5902433, 0x3110b310, 0x8625f254, 0x47665c1e, 0xbf10c6a6, 0xbbe9f018, 0xc421f4b0, 0xdcb5a993, 0x43bae2cd, 0xaae9c002, 0xe57ac99a, 0x17926e22, 0x76a66728, 0xf92b11bb, 0x7dc953b9, 0xea6d49b7),  3, {SECP256K1_FE_CONST(0xd5a57c1b, 0x71916606, 0xbfb235f0, 0xce8d880d, 0xe9109a01, 0xb86d58c8, 0x2852b211, 0x0e55ee0f), SECP256K1_FE_CONST(0xca6cf74b, 0x128e1d79, 0x75482bfd, 0xc9e81416, 0x71a5c3e7, 0xe2af854b, 0x23707630, 0x97ba917b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb526749e, 0x35fa04ef, 0x5d20b1d6, 0xcda6f57e, 0x2f3c10c9, 0x85098901, 0xc390da79, 0x31769e34, 0x182093b3, 0xce5883a2, 0x7b834af6, 0x18547fd1, 0x6017cee0, 0x4e9398da, 0x6aaaed2b, 0x87ca0e7c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x901c52d6, 0xa39718c7, 0x255e94e3, 0x3189cbeb, 0x41f2fa97, 0x95279076, 0xbecd6678, 0x99684c17, 0xf988a838, 0x156cc39f, 0x2182bbc5, 0xf7e4f707, 0x9cf75bfb, 0x58638cff, 0x5b201fd3, 0xcf499fc0),  1, {SECP256K1_FE_CONST(0xa356db31, 0x44b754a3, 0xdafdf2a9, 0x0767b65a, 0xbaea92ca, 0x56c69c3a, 0x31a4ff5b, 0xd7914d9c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x957d4fd4, 0x4a10f38a, 0x0d0e1e46, 0x2656dd2e, 0x7f2b6b8c, 0x9545ee02, 0x903f28b0, 0x8f9a57e7, 0x3f4bf4de, 0x3731bea3, 0x291627e3, 0x9daa7dac, 0xcdcd4e13, 0xb2418482, 0x488730b7, 0xa7a816b7),  1, {SECP256K1_FE_CONST(0xa761cd3a, 0x58385878, 0x300c6963, 0xe918b545, 0x99eb0254, 0x550f6254, 0xe414628c, 0x2f431bbd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x0a7b6db2, 0x56f01aea, 0x797a0798, 0x5eaf98d6, 0x64486f82, 0x723758bf, 0x1a5f7b00, 0xb74887e1, 0xe07ce7ec, 0x5f24b6da, 0x199329ff, 0x674788c4, 0x1b7312d4, 0xbb63672f, 0x81ebbfd3, 0x6d962235), 15, {SECP256K1_FE_CONST(0x442e15e3, 0xac31958b, 0x7acdb8b9, 0x7977b6d0, 0x533b1ef0, 0x5094f496, 0x126a04d0, 0xc6d6c327), SECP256K1_FE_CONST(0xc565d637, 0x6c8f4fa4, 0xa22ab5d4, 0xe1c87f5d, 0x6f9beb27, 0x7764a77f, 0x8ebe3796, 0xaa82cba5), SECP256K1_FE_CONST(0x2082a3b7, 0x04d3729c, 0x71a73a0c, 0xd745c7ce, 0x7a7c5e26, 0x77c688e2, 0x772806d1, 0xdd1a849f), SECP256K1_FE_CONST(0xc00c8cc3, 0x5ea8122e, 0xf17b0a8e, 0xc69218d1, 0x8cb45a3f, 0x0227a2c5, 0x68fbd9f9, 0xc6d6d141)}},\n+    {SECP256K1_GE_CONST(0x770ed6cb, 0xf6d2156b, 0x362523eb, 0xc2908f68, 0x65ab182c, 0x43468bc8, 0x69d6754e, 0x68dc71a0, 0x2a378713, 0x10223129, 0xbaba56c2, 0x0dc4a1e9, 0x634dba32, 0xa034d21f, 0x3104176b, 0x870c9916), 15, {SECP256K1_FE_CONST(0x092c79ab, 0xbbafd66d, 0x58c56208, 0x7ba5c385, 0x9fed6c1b, 0x5f8005af, 0x0087cedb, 0xec7dc084), SECP256K1_FE_CONST(0x3f5c280a, 0x60802515, 0x16dfd84a, 0x4488df47, 0x96198d5f, 0xbce0be21, 0x1ab0ee7d, 0xa456e73e), SECP256K1_FE_CONST(0x94057b6b, 0xd54b13b2, 0xe2b9d322, 0x687569f5, 0xdd16727d, 0x3d912ba3, 0xeb8aa33d, 0x36c15108), SECP256K1_FE_CONST(0x098360ae, 0xcf93979e, 0x7cd6df39, 0x6e8fe2f3, 0x18fa1da3, 0x9efa707a, 0xeab95cd8, 0xcd5dca2a)}},\n+    {SECP256K1_GE_CONST(0xab01575c, 0x0604c63e, 0xe77d3153, 0x4a5bcfa2, 0x0ce66c9d, 0xf47d6054, 0xb822bfd8, 0x6934f8ec, 0xce488d85, 0xd0875b40, 0x4fb92b6e, 0x8068602a, 0x670ac4f8, 0xd76b78b6, 0xc246b713, 0x595e226b), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4ab21b18, 0x1009aa48, 0xb8ba5eb9, 0xd373919b, 0xcfcb36a6, 0xf34961b2, 0xc859f5a8, 0x6da8ba41), SECP256K1_FE_CONST(0x9a11c401, 0x9a4ba9fc, 0xf4698a71, 0x2d85c8e4, 0x70028e02, 0x545ef049, 0xf9f3083d, 0x187c5b41)}},\n+    {SECP256K1_GE_CONST(0x6084cfdd, 0xf8d9736e, 0xa90100eb, 0xdb43338f, 0x65e2ab43, 0xef35a799, 0x926e6ce3, 0x2a89ae17, 0x753998b5, 0x9eaae7a3, 0xdcab34d9, 0xa15dbc71, 0xe539cdff, 0xdcf05927, 0x0eb27c86, 0xab6b62a4), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x18b1f707, 0x3fca3167, 0x04e1b3b8, 0x8cc8ff5a, 0x702d79bc, 0x756e4dea, 0x2ff948cc, 0xdb43a9f4), SECP256K1_FE_CONST(0xca02e589, 0x89eb16d1, 0x520463d2, 0x435745cf, 0x6e69fa52, 0x6b5c7adc, 0x57cea2b3, 0xf5a6441c)}},\n+    {SECP256K1_GE_CONST(0xc9fbac00, 0x9d8eda5d, 0x25c9aabb, 0x2b6794bc, 0x9a801afd, 0x17adef78, 0x78c65392, 0x04eb0f82, 0x95ed9e51, 0x898b903e, 0xe689e6ed, 0xff2b54bf, 0xed5c2da1, 0x69e2bdd0, 0x415a392e, 0x16b3de2b), 13, {SECP256K1_FE_CONST(0x21a95220, 0x8577e3f0, 0xcc5b4b17, 0xf5e434b2, 0x2bbdbaaa, 0x51cd2659, 0xe37880a6, 0xa25aa7dd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xcfd1ca13, 0x2f8d3eae, 0x73a97895, 0x01d2c82a, 0x6f057566, 0x7949fab9, 0x267bc1e8, 0xef9bf5bd), SECP256K1_FE_CONST(0x9cde02aa, 0x3acd2596, 0xdbea4b82, 0xf9f47ad1, 0x994ad567, 0x3c0d4fb2, 0xe8a3dca5, 0xe8e067fb)}},\n+    {SECP256K1_GE_CONST(0x8dcb38d9, 0x0059d4f1, 0x270455af, 0x6f3dd40e, 0x8d671a34, 0xa1fad81d, 0x2470db8a, 0x13b18f76, 0x603ed5be, 0x7bc3e67f, 0x439067da, 0x29949bcb, 0xd3c96c9f, 0x94da4231, 0x3c9c0feb, 0xe5cdf560), 13, {SECP256K1_FE_CONST(0x3ef4008a, 0x8a190a3f, 0x5c97d211, 0x3bb539e1, 0xf4261a78, 0xf7cd85c4, 0xfd254837, 0xeaacd020), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x0fe7af4f, 0xcab80199, 0x37ee0026, 0x47d55d97, 0x575474b3, 0x4b9cc1bb, 0x133f4261, 0x017124a0), SECP256K1_FE_CONST(0x09dcec3b, 0x93c4ab42, 0x91d01dce, 0xccc19525, 0xc801add3, 0x77170c2c, 0x919f5488, 0xf41d6d3e)}},\n+    {SECP256K1_GE_CONST(0xf69dfe44, 0x890d2b09, 0x4b749a56, 0xf680e851, 0x50c47c4c, 0xd51e7796, 0x3fec4e6a, 0x09dcd0a1, 0xfb5d321c, 0x1e243b63, 0x6dfb71f3, 0xcf0e8a01, 0x2e52b22c, 0x905cec6d, 0x2f6ae32a, 0x6a4eb7be),  3, {SECP256K1_FE_CONST(0xa17fd528, 0x7276cbf6, 0xc168dcde, 0xb32aba14, 0xe1aeae2f, 0xe7f5bea5, 0xa87d384e, 0xe8046aac), SECP256K1_FE_CONST(0x637f176a, 0xf2fe854a, 0x968ab19b, 0xee010554, 0x313e3eff, 0xc6ff8cb4, 0xcb538a6d, 0xbaedd954), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x043a0631, 0x871a3f67, 0xac03c5f8, 0x406b69a0, 0xdc14bd5b, 0x23e55f27, 0xa5d4462b, 0x0f0a2d23, 0x247b9bcc, 0x0019091c, 0x31eb4b03, 0xe731a0b5, 0xa9b33f75, 0xad9e5e63, 0x39286573, 0xa6439d88),  3, {SECP256K1_FE_CONST(0xd65add13, 0xad3044d9, 0x2ebcd0e6, 0xd42853d8, 0xe5733ff6, 0x5297f544, 0x09a3ce89, 0xfdaffbdc), SECP256K1_FE_CONST(0x7281ad3c, 0x85de3870, 0x84f64e14, 0x42b37154, 0xeab39453, 0x8b1c0753, 0x4b303ae7, 0x37f3973e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8855508a, 0xade16ec5, 0x73d21e6a, 0x485dfd0a, 0x7624085c, 0x1a14b5ec, 0xdd6485de, 0x0c6839a4, 0xe50aaeba, 0xa0ceceec, 0xa1bce62e, 0x5f0fac4b, 0xe78ab03a, 0x7b2deaa6, 0xe5c17e88, 0x98e277e9),  1, {SECP256K1_FE_CONST(0x4e96da73, 0xae14fc85, 0x25eccb2d, 0xf4416924, 0x8a7fd269, 0xa065e065, 0x04d315e6, 0x63666b03), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xc66327bc, 0x5b0b8b90, 0x37adfd63, 0xc2a9f192, 0x2ce2144a, 0xa513b390, 0xd48bc387, 0xae3ebff6, 0x17a1ca89, 0x64eb0b41, 0x162894e6, 0x4fb4112b, 0x638f96ec, 0xe0c6f30d, 0xef7616fe, 0x0e78386a),  1, {SECP256K1_FE_CONST(0x56e8e17e, 0xfaf989d6, 0xa7efb81d, 0x5a602393, 0x6814930e, 0xbc3f6fdf, 0x72ebf472, 0x69ba4c9a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0xc53feaaf, 0x97e7afc6, 0x9f97550f, 0x3c0dbebb, 0x65d986a9, 0x9677cc2b, 0x7f3fc239, 0x98749460),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9d709c02, 0x74604cb6, 0x3b531fea, 0x35932e2e, 0xc965f4bf, 0x5913e577, 0xff31080b, 0x67727a2e, 0xf2b0b821, 0xa24081a9, 0xd0ca84d9, 0x303068cf, 0x7ea32788, 0x05926b0a, 0xb90b9af7, 0x498efbd5),  3, {SECP256K1_FE_CONST(0xb06abefa, 0x192a6498, 0xbce368ff, 0xacc843fb, 0xb39f8117, 0xa56a1870, 0xf57197ef, 0xd9312f6d), SECP256K1_FE_CONST(0x1263d142, 0xaac9cfc5, 0x64c56650, 0x0fa4a62f, 0x38e727fb, 0xb4dbeaf2, 0x6fdf7d05, 0xfd022c71), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb4955dcb, 0x4daaa784, 0x9b421c14, 0x53ec8945, 0xd685d554, 0xf41103f8, 0x12cbfb2f, 0x54a4539b, 0x354d18e4, 0xb1cee7a3, 0xf98b0651, 0xf5544091, 0xe8a00656, 0x0c74750d, 0xaadf460e, 0xc3f620ea),  3, {SECP256K1_FE_CONST(0x6281a8a7, 0x0a3b5745, 0xb897ce4f, 0x58305fb0, 0xd6a0f8ab, 0xa6c5ba18, 0xed278ce1, 0x50f7911c), SECP256K1_FE_CONST(0x5f95a708, 0x2d2f6d69, 0xf7ff9b74, 0x2b88063c, 0x39a3003b, 0xb03f333c, 0x7e3d7c5e, 0xd861fb04), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x6ad63dfd, 0xcd231967, 0xff2508f4, 0x75896976, 0xf8728e40, 0xdd7a2acc, 0x6b5ced37, 0xcada8291, 0xf93e5181, 0x8f5329b8, 0xd520a9af, 0xd72938e1, 0x2e3f8be6, 0x421d2bce, 0x89d7b14e, 0x25bf5336),  1, {SECP256K1_FE_CONST(0x0f050318, 0x622f79f1, 0x5a2b23d9, 0xf76329b7, 0x8e195f1a, 0x4651aae0, 0x65d58bcd, 0xdfa4d3b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa91b7f2a, 0xb93de821, 0xabeec175, 0x0258e4d4, 0xf5f09831, 0xb0a11dda, 0x47e89ddf, 0x6944d819, 0x22eb9bf6, 0x4a517df2, 0xc27d1c55, 0x1df07609, 0x166fc995, 0xe2b39fee, 0x0473ea46, 0xed14efc1),  1, {SECP256K1_FE_CONST(0x7a01651a, 0x81a7f09e, 0x2733cf34, 0x9e6472a1, 0x18c16780, 0x6f5c880f, 0x534b89a6, 0x52be06a7), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  3, {SECP256K1_FE_CONST(0x2c8864a8, 0xc34e87d7, 0x53ee7300, 0x8bbed54a, 0x47b37907, 0x56d0b747, 0x10341b37, 0xf598a5fe), SECP256K1_FE_CONST(0x15908d62, 0x2377bedc, 0x0fecf55f, 0xcc6425c9, 0xde992fcb, 0x01af2628, 0xac40f220, 0x88de01f0), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa64de96a, 0x6254cefc, 0xffbeaf89, 0x8f2c228a, 0xf6d405f3, 0xbcc6a4cc, 0xe068312a, 0xf7ccf8e1, 0x8f9b3a1b, 0x2d146ea9, 0x54bfc5e2, 0xcdfe861c, 0xcbed8431, 0xc741c5f9, 0xd32f16a3, 0x073ea496),  3, {SECP256K1_FE_CONST(0x4591d33d, 0x1a133a87, 0x94689b1b, 0x0ca445b7, 0x8ada3bce, 0xc2e812b0, 0x8315e2b1, 0x07940ad4), SECP256K1_FE_CONST(0xa763d217, 0x6027d40e, 0x8a8ff34b, 0xd9c639b7, 0x3e2ea045, 0x92274fdc, 0xfa4051c6, 0x6d93a1b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x49a0dc06, 0x8c3f117a, 0xefdc842d, 0x3d358153, 0xf677f04c, 0x6dabc9c9, 0x1b09d452, 0xfef27b66, 0x7b944da4, 0x8a175dbc, 0x444ead8d, 0xb82eff66, 0xb081a8aa, 0xe6453fed, 0x2bca9720, 0xb44dd6e5),  3, {SECP256K1_FE_CONST(0x7bf1e2b1, 0x720c1c44, 0x0db64687, 0xf16439fa, 0x41b39833, 0x8095f24e, 0xbeec0cfa, 0x88750dc9), SECP256K1_FE_CONST(0xdc97e26d, 0x3137445d, 0x6c1269b6, 0x1a765501, 0x0c19c36a, 0x2e361066, 0xe31e2bb1, 0x0403470b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd09a4047, 0xf158fe52, 0xf96c661d, 0x02c68657, 0xc4c976ea, 0x96ea85ef, 0x46d6985b, 0xd540756b, 0xe793bfaa, 0xe9300f18, 0xe6f9b55a, 0xae263223, 0x68b61d51, 0xae5022ef, 0xe266c72d, 0x574178bc),  1, {SECP256K1_FE_CONST(0x7e6175fd, 0xfbb9fb4f, 0xaf6e2b92, 0x5ef86c4a, 0x444d819a, 0xaa82dbee, 0x545d3d9b, 0x296375be), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x34986625, 0x04b73c7c, 0x8cecb6c3, 0x3cd493bd, 0xfc190e0f, 0x87d913d7, 0xff9ad42e, 0x222bfe95, 0x245b3a61, 0xb8d46997, 0xf14f2fea, 0x28748996, 0x91eb3254, 0x2b9907d6, 0x5eb9d21d, 0x42454021),  1, {SECP256K1_FE_CONST(0x7f556282, 0xc3dd9d26, 0x3390d6bb, 0xddada698, 0xab8fd7c7, 0xd1a06498, 0xf42b3043, 0x7c8361ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}}\n+};\n+\n+struct ellsq_enc_test {\n+    unsigned char ell64[64];\n+    unsigned char pubkey[33];\n+};\n+\n+/* Set of (ell64, point) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_enc_test ellsq_enc_tests[] = {\n+    {{0x54,0xca,0xd2,0x27,0xb2,0xc9,0x8d,0x5f,0x7c,0x78,0x8c,0xfc,0x3d,0xaf,0xd6,0x52,0xf5,0x8f,0x69,0xcf,0xef,0x63,0x2b,0x82,0x2b,0x35,0xd0,0xb0,0xe2,0x4f,0xc0,0x3a,0xd2,0x8c,0xa1,0x4b,0x6f,0x62,0xd4,0x53,0x79,0xc5,0x3f,0x70,0xee,0x40,0x5c,0xa9,0x2c,0xe7,0xb6,0xf9,0x70,0x83,0x13,0x05,0xf2,0x7d,0xc4,0x1e,0xb6,0x9d,0xe0,0x6e}, {0x02,0x11,0x62,0x89,0x03,0x32,0x88,0x91,0xae,0x09,0xd1,0x08,0xd8,0x92,0x43,0xe4,0x7e,0x10,0x9f,0xe7,0xb8,0xbb,0x1e,0x2d,0xf1,0xa3,0xae,0x9b,0x0e,0x78,0x08,0x54,0x9c}},\n+    {{0xfb,0xe6,0xce,0xab,0x4c,0x5f,0xdf,0xa5,0xfb,0xee,0x8f,0x3d,0x09,0xa2,0xf7,0x23,0x53,0xe7,0x4e,0x5a,0x9c,0xd4,0xab,0x8e,0x6a,0x34,0xd4,0x95,0x23,0xa7,0xd1,0xa2,0xc4,0x50,0xb7,0x45,0xda,0xb1,0xaf,0xa9,0x95,0x4b,0x3a,0x35,0x75,0xe4,0xe8,0xe2,0xdb,0x3d,0xa5,0xcd,0x4d,0x56,0x48,0xea,0xd0,0x0a,0x60,0xb4,0xcd,0xfe,0x84,0xb3}, {0x02,0xc0,0x4c,0x84,0x85,0xf9,0x8d,0x56,0x6c,0x79,0xbf,0x33,0xa7,0x0c,0xb2,0x32,0x54,0x9e,0x3d,0xe1,0xc3,0xe3,0x01,0xe3,0x57,0x1c,0x83,0x68,0x97,0xf0,0x7c,0x5d,0x12}},\n+    {{0x71,0x7e,0x63,0xd7,0x71,0xdb,0xda,0x67,0x67,0xd5,0x8f,0x26,0xab,0x5f,0x54,0x9b,0xd2,0xd1,0x8a,0xcf,0x59,0xff,0x50,0x77,0x5f,0x4e,0xb5,0x0a,0xc0,0x17,0x4d,0xf1,0x7d,0xd0,0x34,0xc8,0xed,0x08,0x11,0x61,0x5e,0x3e,0xbb,0x36,0xf8,0xf3,0x3e,0x09,0x23,0x8e,0x4d,0xa8,0xf5,0x01,0x9d,0x37,0x00,0x78,0x4f,0x37,0xc1,0x53,0x53,0x94}, {0x02,0x72,0x81,0x15,0x0c,0xeb,0xc3,0xd7,0xb3,0xbb,0xb9,0x92,0xf5,0x81,0xbb,0xcb,0x9e,0x30,0x4f,0x87,0x44,0xf0,0x19,0x98,0xa7,0x1f,0x5d,0xe1,0x14,0xf8,0x22,0x91,0xc4}},\n+    {{0x01,0xf0,0xbf,0xe4,0xf9,0xbd,0xee,0x52,0x5e,0xb7,0x7c,0x8e,0x35,0x1e,0x1f,0x88,0x3f,0xb9,0xcd,0x37,0x7e,0xf7,0xc5,0xbd,0xde,0xe4,0xf6,0x60,0x64,0x43,0x90,0xf5,0x95,0x3e,0x7d,0x2b,0x6c,0xde,0x36,0x90,0x3e,0xa1,0x34,0x4b,0x0d,0x16,0x33,0x5c,0xc5,0x11,0x5d,0xaa,0x97,0x7c,0x3c,0x2b,0xf9,0x31,0xac,0xde,0x2f,0xf5,0x78,0x9a}, {0x02,0x10,0x44,0x9d,0x7e,0xa0,0x62,0x3e,0x80,0xa5,0x87,0x01,0x9f,0xa5,0x11,0xaf,0xd3,0x94,0xb2,0x55,0xb0,0x8f,0x91,0xb5,0xf7,0x48,0x2a,0xe9,0xd1,0xa1,0xa7,0xfb,0x7c}},\n+    {{0x82,0xd5,0x87,0x1e,0x18,0x37,0x66,0xbd,0x22,0xe1,0x13,0xa8,0x52,0x79,0xaa,0x61,0x7e,0x6b,0x9f,0x73,0x52,0x2c,0xd4,0x6b,0x90,0x59,0xba,0x51,0x97,0xfa,0x56,0x44,0xaf,0x90,0x41,0x89,0x30,0x98,0x7d,0xb7,0xab,0x4a,0x84,0x0c,0x72,0x64,0x1b,0x58,0xb3,0x66,0xe5,0x7c,0x92,0x8c,0x98,0x3a,0x47,0x37,0x82,0x00,0x3c,0x36,0x10,0xab}, {0x03,0xc8,0xb2,0x62,0xf9,0x31,0x69,0x43,0x75,0x51,0x48,0x3b,0x8a,0x61,0x19,0x83,0x82,0xe3,0x11,0x41,0xaf,0x61,0xbf,0x36,0x10,0x0b,0xd0,0x68,0x46,0x5d,0xdd,0xa8,0x40}},\n+    {{0xda,0x82,0x53,0xb4,0x3b,0x5a,0xc2,0x3b,0x42,0x36,0x07,0xe9,0x18,0xab,0x5c,0xaa,0x5d,0x7d,0x34,0x3d,0x77,0xa3,0x99,0x6a,0x42,0xeb,0x33,0x2a,0x3b,0x55,0x1d,0x8c,0xda,0x6c,0xb6,0xf9,0x57,0x4c,0xe3,0x60,0x91,0x2c,0xf4,0x5b,0x90,0x9a,0x96,0x2e,0x4d,0xed,0x63,0xae,0x5a,0xac,0xb0,0xab,0x23,0x29,0x45,0xb1,0x01,0xf7,0x2b,0x62}, {0x02,0xe7,0x28,0x34,0x1d,0xf6,0x93,0x48,0x71,0xb3,0x94,0xbb,0x4f,0xb2,0x8b,0xd8,0xd2,0xdf,0x39,0x92,0x55,0xb0,0x30,0x02,0xed,0x6f,0xc3,0x8f,0x28,0xcf,0xbf,0x53,0x56}},\n+    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x03,0x1b,0x41,0x2e,0x7a,0x96,0x6d,0x2c,0x24,0x3d,0xbc,0x5b,0x18,0xb7,0xf9,0xba,0xf1,0x85,0xbc,0xfe,0x41,0x38,0x96,0x04,0x79,0x64,0x1a,0xb1,0xe6,0x3b,0x38,0x1e,0x11}},\n+    {{0xdc,0x30,0x98,0xe4,0x00,0x61,0x83,0x30,0xf3,0x8b,0x19,0xe9,0x20,0x0a,0xdf,0x7f,0xfb,0x96,0x84,0x3f,0xa8,0x3c,0x49,0x1c,0xf6,0x7f,0x34,0xa7,0x90,0xbb,0xcf,0xe1,0x23,0xdc,0x30,0x07,0xa4,0xfd,0x13,0x3a,0x39,0x44,0x0b,0x06,0x03,0x1e,0x9e,0x2c,0x38,0x8e,0x41,0x47,0xaf,0x0e,0x82,0xbe,0xda,0x6d,0x56,0x4b,0xf8,0xcc,0x37,0xb1}, {0x02,0x5b,0x74,0x48,0x15,0x22,0xd4,0xc2,0x9f,0x2e,0x6a,0x2f,0x11,0x7f,0x9e,0x39,0xf9,0xab,0x01,0xb1,0xe9,0xf2,0xc3,0x4c,0x68,0xbe,0x8f,0x53,0x1b,0xe0,0x1f,0x6e,0xa7}},\n+    {{0x35,0xd7,0x0a,0x71,0x2c,0xc0,0x85,0x7f,0x8d,0xb1,0xbc,0x55,0x6a,0x6c,0x4e,0xf8,0x66,0x24,0xfd,0x0a,0x47,0x7f,0x96,0x7e,0xed,0xc0,0x32,0xfc,0xda,0xac,0xe7,0x96,0xc6,0x73,0xc5,0x43,0xd0,0x07,0x34,0x32,0x07,0x85,0x5b,0xeb,0xad,0x85,0xe9,0x4b,0xca,0xc7,0x78,0x2b,0x11,0x57,0x9a,0x70,0xdc,0x88,0xe2,0xa4,0x8d,0x9d,0xf2,0xd4}, {0x02,0xdb,0x21,0xb4,0x8f,0xe9,0xf9,0x95,0x08,0x3a,0x1f,0x9c,0x1f,0x3f,0x4b,0x31,0x1d,0x2c,0x43,0xa1,0x28,0xdb,0xb3,0xa4,0xd4,0x78,0x41,0xe4,0xff,0x5d,0xd0,0x2e,0x61}},\n+    {{0x5f,0xb8,0x07,0xce,0x10,0x0c,0x90,0xd2,0x83,0x7c,0xcf,0xc9,0x4d,0x8f,0x8b,0xa5,0xd3,0x5c,0xd3,0xd6,0xfa,0xfc,0xd2,0xf4,0x1f,0x24,0x5b,0x59,0x6e,0x36,0x00,0x57,0xa0,0x47,0xf8,0x31,0xef,0xf3,0x6f,0x2d,0x7c,0x83,0x30,0x36,0xb2,0x70,0x74,0x5a,0x2c,0xa3,0x2c,0x29,0x05,0x03,0x2d,0x0b,0xe0,0xdb,0xa4,0xa5,0x91,0xc9,0xfb,0xd8}, {0x03,0x41,0x58,0x28,0x65,0x43,0x5e,0xe9,0xc8,0xc9,0x27,0xc3,0x49,0xbd,0x3e,0x43,0x7b,0xce,0x2b,0x5c,0xfc,0xd0,0xc4,0x17,0x77,0xc3,0x4c,0x71,0xc6,0x7b,0x14,0x06,0x93}},\n+    {{0x1e,0x76,0x57,0x72,0xbf,0x72,0xde,0xb8,0x81,0x54,0x16,0xbd,0x54,0x45,0xdd,0x75,0x50,0xcd,0x86,0x7a,0xa2,0x5a,0xc6,0x3f,0x6f,0xd9,0xaf,0xd3,0x2f,0x92,0x1c,0xc8,0x8a,0x06,0x1a,0xb5,0xf6,0x98,0x1b,0x55,0x92,0x1b,0x90,0x5b,0x6f,0x4f,0x3d,0xf4,0x82,0x5d,0x79,0x72,0xd6,0x99,0xe3,0xb4,0x21,0x4e,0x40,0x44,0xcf,0xbe,0x65,0x34}, {0x03,0x90,0xd2,0x94,0x30,0x92,0xec,0x7e,0xd8,0xff,0x5a,0xf7,0x04,0x43,0x2d,0x0d,0xbe,0xb0,0x33,0x7c,0xbf,0x58,0x22,0x87,0x18,0x32,0x76,0x38,0x68,0x1f,0x70,0xd7,0xf0}},\n+    {{0x86,0xef,0x92,0xfd,0x28,0x09,0x85,0x4f,0x74,0xf7,0x5a,0xeb,0xbe,0xa1,0x8a,0xee,0xc0,0xee,0xdd,0x4e,0x81,0x92,0xc8,0x8c,0xd7,0xcf,0xf5,0xdf,0xc0,0x8a,0x57,0xdc,0x32,0x73,0xbf,0x6f,0x39,0x2d,0xee,0x48,0x4a,0x72,0x2c,0x3d,0xb0,0x0c,0x0e,0xfb,0x40,0xd5,0x1e,0x8a,0x72,0xfc,0xfb,0x78,0x3f,0xa7,0xeb,0xd4,0x30,0x82,0xdb,0x71}, {0x02,0x31,0x74,0x79,0x29,0x80,0x2d,0x79,0x76,0x02,0x26,0x71,0xb2,0xf7,0x5a,0xc0,0x31,0x18,0x56,0xb3,0x84,0xf4,0xb9,0xa8,0x00,0x0d,0x44,0xa2,0xab,0xc5,0x90,0x3a,0xd4}}\n+};\n+\n+void run_ellsq_tests(void) {\n+    int i = 0;\n+    /* Verify that secp256k1_ellsq_fe_to_ge_var maps everything to curve points for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        secp256k1_fe t;\n+        secp256k1_ge g;\n+        random_field_element_test(&t);\n+        secp256k1_ellsq_fe_to_ge_var(&g, &t);\n+        CHECK(secp256k1_ge_is_valid_var(&g));\n+    }\n+    /* Verify that secp256k1_ellsq_ge_to_fe_var + fe_to_ge_var roundtrips for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        int j;\n+        secp256k1_ge g;\n+        random_group_element_test(&g);\n+        for (j = 0; j < 4; j++) {\n+            secp256k1_fe f;\n+            if (secp256k1_ellsq_ge_to_fe_var(&f, &g, j)) {\n+                secp256k1_ge g2;\n+                secp256k1_ellsq_fe_to_ge_var(&g2, &f);\n+                ge_equals_ge(&g, &g2);\n+            }\n+        }\n+    }\n+    /* Verify precomputed test cases. */\n+    for (i = 0; i < (int)sizeof(ellsq_tests) / (int)sizeof(ellsq_tests[0]); ++i) {\n+        int j;\n+        const struct ellsq_test *test = ellsq_tests + i;\n+        for (j = 0; j < 4; j++) {\n+            secp256k1_fe f;\n+            int ret;\n+            ret = secp256k1_ellsq_ge_to_fe_var(&f, &test->point, j);\n+            CHECK(ret == ((test->enc_bitmap >> j) & 1));\n+            if (ret) {\n+                secp256k1_ge g;\n+                CHECK(check_fe_equal(&f, &test->encs[j]));\n+                secp256k1_ellsq_fe_to_ge_var(&g, &f);\n+                ge_equals_ge(&test->point, &g);\n+            }\n+        }\n+    }\n+    /* Verify that secp256k1_ellsq_encode + decode roundtrips. */\n+    for (i = 0; i < 1000*count; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        secp256k1_ellsq_encode(ctx, ell64, rnd32, &pubkey);\n+        secp256k1_ellsq_decode(ctx, &pubkey2, ell64);\n+        secp256k1_pubkey_load(ctx, &g2, &pubkey2);\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify decoding of precomputed test cases. */\n+    for (i = 0; i < (int)sizeof(ellsq_enc_tests) / (int)sizeof(ellsq_enc_tests[0]); ++i) {\n+        secp256k1_pubkey pubkey;\n+        unsigned char pk33[33];\n+        size_t size = 33;\n+        secp256k1_ellsq_decode(ctx, &pubkey, ellsq_enc_tests[i].ell64);\n+        secp256k1_ec_pubkey_serialize(ctx, pk33, &size, &pubkey, SECP256K1_EC_COMPRESSED);\n+        CHECK(size == 33);\n+        CHECK(secp256k1_memcmp_var(&pk33, ellsq_enc_tests[i].pubkey, size) == 0);\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "e1003052f4c623092457fe3f4e482c27486db441",
        "filename": "src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/main_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -120,12 +120,11 @@ int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pub\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output_pubkey != NULL);\n     memset(output_pubkey, 0, sizeof(*output_pubkey));\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_pubkey_save(output_pubkey, &pk);\n@@ -137,13 +136,12 @@ int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const u\n     unsigned char pk_expected32[32];\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweaked_pubkey32 != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&pk.x);\n@@ -260,7 +258,6 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     int ret;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(keypair != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n@@ -273,7 +270,7 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     }\n \n     ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n-    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32);\n \n     secp256k1_declassify(ctx, &ret, sizeof(ret));\n     if (ret) {"
      },
      {
        "sha": "dd53f9e12aedefaf3b43f654c98a0d52cde8ea05",
        "filename": "src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -197,19 +197,19 @@ void test_xonly_pubkey_tweak(void) {\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n     ecount = 0;\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* NULL internal_xonly_pk zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     /* NULL tweak zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n \n@@ -274,20 +274,20 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     /* invalid pk_parity value */\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     memset(tweak, 1, sizeof(tweak));\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n@@ -306,7 +306,7 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -479,15 +479,15 @@ void test_keypair_add(void) {\n     memset(overflows, 0xFF, 32);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n \n-    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, NULL, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* This does not set the keypair to zeroes */\n     CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) != 0);\n "
      },
      {
        "sha": "e7906eb62e0ea10248ad31e8b6faac9a51f7b117",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -40,7 +40,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n     ARG_CHECK(recid >= 0 && recid <= 3);\n@@ -60,7 +60,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n int secp256k1_ecdsa_recoverable_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, int *recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(recid != NULL);\n@@ -75,7 +75,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     secp256k1_scalar r, s;\n     int recid;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(sigin != NULL);\n \n@@ -84,7 +84,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n     unsigned char brx[32];\n     secp256k1_fe fx;\n     secp256k1_ge x;\n@@ -115,7 +115,7 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n     secp256k1_scalar_mul(&u1, &rn, message);\n     secp256k1_scalar_negate(&u1, &u1);\n     secp256k1_scalar_mul(&u2, &rn, sigs);\n-    secp256k1_ecmult(ctx, &qj, &xj, &u2, &u1);\n+    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n     secp256k1_ge_set_gej_var(pubkey, &qj);\n     return !secp256k1_gej_is_infinity(&qj);\n }\n@@ -140,15 +140,14 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     secp256k1_scalar m;\n     int recid;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n     VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msghash32, NULL);\n-    if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n+    if (secp256k1_ecdsa_sig_recover(&r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);\n         return 1;\n     } else {"
      },
      {
        "sha": "2fcd46d206abd8d3258bf300c2c3bc00cfd9779e",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -92,20 +92,20 @@ void test_ecdsa_recovery_api(void) {\n \n     /* Check bad contexts and NULLs for recovery */\n     ecount = 0;\n-    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     /* Check NULLs for conversion */\n     CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);"
      },
      {
        "sha": "3650e7c77b4b2a17eca3d7ba96f0e299b945cefe",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -122,7 +122,7 @@ static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned c\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+static int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -216,7 +216,6 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     int overflow;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n     ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n@@ -241,7 +240,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);\n     secp256k1_gej_set_ge(&pkj, &pk);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+    secp256k1_ecmult(&rj, &pkj, &e, &s);\n \n     secp256k1_ge_set_gej_var(&r, &rj);\n     if (secp256k1_ge_is_infinity(&r)) {"
      },
      {
        "sha": "096dbad8a8a4a466f3c530e7c0fba7bef507e6a6",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -193,22 +193,22 @@ void test_schnorrsig_api(void) {\n \n     ecount = 0;\n     CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n-    CHECK(ecount == 6);\n+    CHECK(ecount == 4);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);"
      },
      {
        "sha": "5b0e2f32c5be5527035b538e1f46faf603c29822",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 11,
        "deletions": 22,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -73,15 +73,13 @@ static const secp256k1_callback default_error_callback = {\n };\n \n struct secp256k1_context_struct {\n-    secp256k1_ecmult_context ecmult_ctx;\n     secp256k1_ecmult_gen_context ecmult_gen_ctx;\n     secp256k1_callback illegal_callback;\n     secp256k1_callback error_callback;\n     int declassify;\n };\n \n static const secp256k1_context secp256k1_context_no_precomp_ = {\n-    { 0 },\n     { 0 },\n     { secp256k1_default_illegal_callback_fn, 0 },\n     { secp256k1_default_error_callback_fn, 0 },\n@@ -103,9 +101,6 @@ size_t secp256k1_context_preallocated_size(unsigned int flags) {\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -115,9 +110,6 @@ size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n     if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -139,17 +131,13 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n-    secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     /* Flags have been checked by secp256k1_context_preallocated_size. */\n     VERIFY_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_CONTEXT);\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n-    }\n     ret->declassify = !!(flags & SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY);\n \n     return (secp256k1_context*) ret;\n@@ -176,7 +164,6 @@ secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context*\n     ret = (secp256k1_context*)prealloc;\n     memcpy(ret, ctx, prealloc_size);\n     secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n-    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n@@ -194,7 +181,6 @@ secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n     ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n-        secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n     }\n }\n@@ -458,7 +444,6 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(pubkey != NULL);\n@@ -467,7 +452,7 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_ecdsa_signature_load(ctx, &r, &s, sig);\n     return (!secp256k1_scalar_is_high(&s) &&\n             secp256k1_pubkey_load(ctx, &q, pubkey) &&\n-            secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &r, &s, &q, &m));\n+            secp256k1_ecdsa_sig_verify(&r, &s, &q, &m));\n }\n \n static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len) {\n@@ -685,24 +670,23 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak32);\n }\n \n-static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak32) {\n+static int secp256k1_ec_pubkey_tweak_add_helper(secp256k1_ge *p, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n     secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n-    return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n+    return !overflow && secp256k1_eckey_pubkey_tweak_add(p, &term);\n }\n \n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n-    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak32);\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&p, tweak32);\n     if (ret) {\n         secp256k1_pubkey_save(pubkey, &p);\n     }\n@@ -740,15 +724,14 @@ int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n     if (ret) {\n-        if (secp256k1_eckey_pubkey_tweak_mul(&ctx->ecmult_ctx, &p, &factor)) {\n+        if (secp256k1_eckey_pubkey_tweak_mul(&p, &factor)) {\n             secp256k1_pubkey_save(pubkey, &p);\n         } else {\n             ret = 0;\n@@ -771,6 +754,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej Qj;\n     secp256k1_ge Q;\n \n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubnonce != NULL);\n     memset(pubnonce, 0, sizeof(*pubnonce));\n     ARG_CHECK(n >= 1);\n@@ -779,6 +763,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej_set_infinity(&Qj);\n \n     for (i = 0; i < n; i++) {\n+        ARG_CHECK(pubnonces[i] != NULL);\n         secp256k1_pubkey_load(ctx, &Q, pubnonces[i]);\n         secp256k1_gej_add_ge(&Qj, &Qj, &Q);\n     }\n@@ -818,3 +803,7 @@ int secp256k1_tagged_sha256(const secp256k1_context* ctx, unsigned char *hash32,\n #ifdef ENABLE_MODULE_SCHNORRSIG\n # include \"modules/schnorrsig/main_impl.h\"\n #endif\n+\n+#ifdef ENABLE_MODULE_ELLSQ\n+# include \"modules/ellsq/main_impl.h\"\n+#endif"
      },
      {
        "sha": "e3319310ca8b1dcfc9f79c4c0b6ed8714a73b4c5",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 207,
        "deletions": 81,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -273,22 +273,22 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sign(sign, &sig, ctmp, ctmp, NULL, NULL) == 1);\n     VG_CHECK(&sig, sizeof(sig));\n     CHECK(ecount2 == 10);\n-    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 0);\n-    CHECK(ecount2 == 11);\n+    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ecdsa_verify(vrfy, &sig, ctmp, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 12);\n+    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_tweak_add(vrfy, &pubkey, ctmp) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 13);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n@@ -298,9 +298,9 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_context_randomize(vrfy, NULL) == 1);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_context_randomize(sign, ctmp) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -314,8 +314,8 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sigr, &sigs, &key, &msg, &nonce, NULL));\n \n     /* try verifying */\n-    CHECK(secp256k1_ecdsa_sig_verify(&vrfy->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n-    CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n     if (use_prealloc) {\n@@ -811,12 +811,29 @@ void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\n     uint16_to_signed30(&x, in);\n     nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4] | x.v[5] | x.v[6] | x.v[7] | x.v[8]) != 0;\n     uint16_to_signed30(&m.modulus, mod);\n-    mutate_sign_signed30(&m.modulus);\n \n     /* compute 1/modulus mod 2^30 */\n     m.modulus_inv30 = modinv2p64(m.modulus.v[0]) & 0x3fffffff;\n     CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\n \n+    /* Test secp256k1_jacobi32_maybe_var. */\n+    if (nonzero) {\n+        uint16_t sqr[16], negone[16];\n+        mulmod256(sqr, in, in, mod);\n+        uint16_to_signed30(&x, sqr);\n+        CHECK(secp256k1_jacobi32_maybe_var(&x, &m) == nonzero);\n+        if ((mod[0] & 3) == 3) {\n+            /* If mod % 4 == 3, x and -x have opposite jacobi symbols. */\n+            negone[0] = mod[0] - 1;\n+            for (i = 1; i < 16; ++i) negone[i] = mod[i];\n+            mulmod256(sqr, sqr, negone, mod);\n+            uint16_to_signed30(&x, sqr);\n+            CHECK(secp256k1_jacobi32_maybe_var(&x, &m) == -nonzero);\n+        }\n+    }\n+\n+    uint16_to_signed30(&x, in);\n+    mutate_sign_signed30(&m.modulus);\n     for (vartime = 0; vartime < 2; ++vartime) {\n         /* compute inverse */\n         (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n@@ -884,12 +901,29 @@ void test_modinv64_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\n     uint16_to_signed62(&x, in);\n     nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4]) != 0;\n     uint16_to_signed62(&m.modulus, mod);\n-    mutate_sign_signed62(&m.modulus);\n \n     /* compute 1/modulus mod 2^62 */\n     m.modulus_inv62 = modinv2p64(m.modulus.v[0]) & M62;\n     CHECK(((m.modulus_inv62 * m.modulus.v[0]) & M62) == 1);\n \n+    /* Test secp256k1_jacobi64_maybe_var. */\n+    if (nonzero) {\n+        uint16_t sqr[16], negone[16];\n+        mulmod256(sqr, in, in, mod);\n+        uint16_to_signed62(&x, sqr);\n+        CHECK(secp256k1_jacobi64_maybe_var(&x, &m) == 1);\n+        if ((mod[0] & 3) == 3) {\n+            /* If mod % 4 == 3, x and -x have opposite jacobi symbols. */\n+            negone[0] = mod[0] - 1;\n+            for (i = 1; i < 16; ++i) negone[i] = mod[i];\n+            mulmod256(sqr, sqr, negone, mod);\n+            uint16_to_signed62(&x, sqr);\n+            CHECK(secp256k1_jacobi64_maybe_var(&x, &m) == -1);\n+        }\n+    }\n+\n+    uint16_to_signed62(&x, in);\n+    mutate_sign_signed62(&m.modulus);\n     for (vartime = 0; vartime < 2; ++vartime) {\n         /* compute inverse */\n         (vartime ? secp256k1_modinv64_var : secp256k1_modinv64)(&x, &m);\n@@ -2659,11 +2693,14 @@ void run_sqrt(void) {\n         for (j = 0; j < count; j++) {\n             random_fe(&x);\n             secp256k1_fe_sqr(&s, &x);\n+            CHECK(secp256k1_fe_jacobi_var(&s) == 1);\n             test_sqrt(&s, &x);\n             secp256k1_fe_negate(&t, &s, 1);\n+            CHECK(secp256k1_fe_jacobi_var(&t) == -1);\n             test_sqrt(&t, NULL);\n             secp256k1_fe_mul(&t, &s, &ns);\n             test_sqrt(&t, NULL);\n+\n         }\n     }\n }\n@@ -3416,6 +3453,84 @@ void run_group_decompress(void) {\n \n /***** ECMULT TESTS *****/\n \n+void test_pre_g_table(const secp256k1_ge_storage * pre_g, size_t n) {\n+    /* Tests the pre_g / pre_g_128 tables for consistency.\n+     * For independent verification we take a \"geometric\" approach to verification.\n+     * We check that every entry is on-curve.\n+     * We check that for consecutive entries p and q, that p + gg - q = 0 by checking\n+     *  (1) p, gg, and -q are colinear.\n+     *  (2) p, gg, and -q are all distinct.\n+     * where gg is twice the generator, where the generator is the first table entry.\n+     *\n+     * Checking the table's generators are correct is done in run_ecmult_pre_g.\n+     */\n+    secp256k1_gej g2;\n+    secp256k1_ge p, q, gg;\n+    secp256k1_fe dpx, dpy, dqx, dqy;\n+    size_t i;\n+\n+    CHECK(0 < n);\n+\n+    secp256k1_ge_from_storage(&p, &pre_g[0]);\n+    secp256k1_fe_verify(&p.x);\n+    secp256k1_fe_verify(&p.y);\n+    CHECK(secp256k1_ge_is_valid_var(&p));\n+\n+    secp256k1_gej_set_ge(&g2, &p);\n+    secp256k1_gej_double_var(&g2, &g2, NULL);\n+    secp256k1_ge_set_gej_var(&gg, &g2);\n+    for (i = 1; i < n; ++i) {\n+        secp256k1_fe_negate(&dpx, &p.x, 1); secp256k1_fe_add(&dpx, &gg.x); secp256k1_fe_normalize_weak(&dpx);\n+        secp256k1_fe_negate(&dpy, &p.y, 1); secp256k1_fe_add(&dpy, &gg.y); secp256k1_fe_normalize_weak(&dpy);\n+        /* Check that p is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dpx) || !secp256k1_fe_normalizes_to_zero_var(&dpy));\n+\n+        secp256k1_ge_from_storage(&q, &pre_g[i]);\n+        secp256k1_fe_verify(&q.x);\n+        secp256k1_fe_verify(&q.y);\n+        CHECK(secp256k1_ge_is_valid_var(&q));\n+\n+        secp256k1_fe_negate(&dqx, &q.x, 1); secp256k1_fe_add(&dqx, &gg.x); secp256k1_fe_normalize_weak(&dqx);\n+        dqy = q.y; secp256k1_fe_add(&dqy, &gg.y); secp256k1_fe_normalize_weak(&dqy);\n+        /* Check that -q is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dqx) || !secp256k1_fe_normalizes_to_zero_var(&dqy));\n+\n+        /* Check that -q is not equal to p */\n+        CHECK(!secp256k1_fe_equal_var(&dpx, &dqx) || !secp256k1_fe_equal_var(&dpy, &dqy));\n+\n+        /* Check that p, -q and gg are colinear */\n+        secp256k1_fe_mul(&dpx, &dpx, &dqy);\n+        secp256k1_fe_mul(&dpy, &dpy, &dqx);\n+        CHECK(secp256k1_fe_equal_var(&dpx, &dpy));\n+\n+        p = q;\n+    }\n+}\n+\n+void run_ecmult_pre_g(void) {\n+    secp256k1_ge_storage gs;\n+    secp256k1_gej gj;\n+    secp256k1_ge g;\n+    size_t i;\n+\n+    /* Check that the pre_g and pre_g_128 tables are consistent. */\n+    test_pre_g_table(secp256k1_pre_g, ECMULT_TABLE_SIZE(WINDOW_G));\n+    test_pre_g_table(secp256k1_pre_g_128, ECMULT_TABLE_SIZE(WINDOW_G));\n+\n+    /* Check the first entry from the pre_g table. */\n+    secp256k1_ge_to_storage(&gs, &secp256k1_ge_const_g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g[0], sizeof(gs)) == 0);\n+\n+    /* Check the first entry from the pre_g_128 table. */\n+    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n+    for (i = 0; i < 128; ++i) {\n+      secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    secp256k1_ge_set_gej(&g, &gj);\n+    secp256k1_ge_to_storage(&gs, &g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g_128[0], sizeof(gs)) == 0);\n+}\n+\n void run_ecmult_chain(void) {\n     /* random starting point A (on the curve) */\n     secp256k1_gej a = SECP256K1_GEJ_CONST(\n@@ -3448,7 +3563,7 @@ void run_ecmult_chain(void) {\n     x = a;\n     for (i = 0; i < 200*count; i++) {\n         /* in each iteration, compute X = xn*X + gn*G; */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &x, &x, &xn, &gn);\n+        secp256k1_ecmult(&x, &x, &xn, &gn);\n         /* also compute ae and ge: the actual accumulated factors for A and G */\n         /* if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G) */\n         secp256k1_scalar_mul(&ae, &ae, &xn);\n@@ -3474,7 +3589,7 @@ void run_ecmult_chain(void) {\n         }\n     }\n     /* redo the computation, but directly with the resulting ae and ge coefficients: */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &x2, &a, &ae, &ge);\n+    secp256k1_ecmult(&x2, &a, &ae, &ge);\n     secp256k1_gej_neg(&x2, &x2);\n     secp256k1_gej_add_var(&x2, &x2, &x, NULL);\n     CHECK(secp256k1_gej_is_infinity(&x2));\n@@ -3492,8 +3607,8 @@ void test_point_times_order(const secp256k1_gej *point) {\n     size_t psize = 65;\n     random_scalar_order_test(&x);\n     secp256k1_scalar_negate(&nx, &x);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n+    secp256k1_ecmult(&res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n+    secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n     secp256k1_ge_set_gej(&res3, &res1);\n@@ -3503,13 +3618,13 @@ void test_point_times_order(const secp256k1_gej *point) {\n     psize = 65;\n     CHECK(secp256k1_eckey_pubkey_serialize(&res3, pub, &psize, 1) == 0);\n     /* check zero/one edge cases */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &zero);\n+    secp256k1_ecmult(&res1, point, &zero, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &one, &zero);\n+    secp256k1_ecmult(&res1, point, &one, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_gej(&res3, point);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &one);\n+    secp256k1_ecmult(&res1, point, &zero, &one);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_ge(&res3, &secp256k1_ge_const_g);\n }\n@@ -3568,9 +3683,9 @@ void test_ecmult_target(const secp256k1_scalar* target, int mode) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p2j, &n2);\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &ptj, target);\n     } else if (mode == 1) {\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p1j, &pj, &n1, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p2j, &pj, &n2, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptj, &pj, target, &zero);\n+        secp256k1_ecmult(&p1j, &pj, &n1, &zero);\n+        secp256k1_ecmult(&p2j, &pj, &n2, &zero);\n+        secp256k1_ecmult(&ptj, &pj, target, &zero);\n     } else {\n         secp256k1_ecmult_const(&p1j, &p, &n1, 256);\n         secp256k1_ecmult_const(&p2j, &p, &n2, 256);\n@@ -3753,7 +3868,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -3768,32 +3883,32 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         pt[1] = secp256k1_ge_const_g;\n \n         /* only G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        secp256k1_ecmult(&r2, &ptgj, &szero, &sc[0]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3810,7 +3925,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3820,7 +3935,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3833,7 +3948,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -3846,7 +3961,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3861,7 +3976,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -3879,8 +3994,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n         }\n \n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &r, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3902,8 +4017,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &p0j, &rs, &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3916,13 +4031,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -3946,8 +4061,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_scalar_set_int(&t1, (t1i + 1) / 2);\n                 secp256k1_scalar_cond_negate(&t1, t1i & 1);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t0p, &ptgj, &t0, &szero);\n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t1p, &ptgj, &t1, &szero);\n+                secp256k1_ecmult(&t0p, &ptgj, &t0, &szero);\n+                secp256k1_ecmult(&t1p, &ptgj, &t1, &szero);\n \n                 for(s0i = 0; s0i < TOP; s0i++) {\n                     for(s1i = 0; s1i < TOP; s1i++) {\n@@ -3966,8 +4081,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_mul(&tmp2, &t1, &sc[1]);\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n-                        secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        secp256k1_ecmult(&expected, &ptgj, &tmp1, &szero);\n+                        CHECK(ecmult_multi(&ctx->error_callback, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -3994,7 +4109,7 @@ void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n     scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    CHECK(!ecmult_multi(&ctx->error_callback, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n }\n \n@@ -4116,15 +4231,15 @@ void test_ecmult_multi_batching(void) {\n \n     /* Get random scalars and group elements and compute result */\n     random_scalar_order(&scG);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r2, &szero, &scG);\n+    secp256k1_ecmult(&r2, &r2, &szero, &scG);\n     for(i = 0; i < n_points; i++) {\n         secp256k1_ge ptg;\n         secp256k1_gej ptgj;\n         random_group_element_test(&ptg);\n         secp256k1_gej_set_ge(&ptgj, &ptg);\n         pt[i] = ptg;\n         random_scalar_order(&sc[i]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptgj, &ptgj, &sc[i], NULL);\n+        secp256k1_ecmult(&ptgj, &ptgj, &sc[i], NULL);\n         secp256k1_gej_add_var(&r2, &r2, &ptgj, NULL);\n     }\n     data.sc = sc;\n@@ -4134,7 +4249,7 @@ void test_ecmult_multi_batching(void) {\n     /* Test with empty scratch space. It should compute the correct result using\n      * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4143,7 +4258,7 @@ void test_ecmult_multi_batching(void) {\n      * ecmult_multi selects strauss which requires more memory. It should\n      * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4157,7 +4272,7 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n         secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -5262,22 +5377,24 @@ void test_ecdsa_sign_verify(void) {\n     secp256k1_scalar msg, key;\n     secp256k1_scalar sigr, sigs;\n     int getrec;\n-    /* Initialize recid to suppress a false positive -Wconditional-uninitialized in clang.\n-       VG_UNDEF ensures that valgrind will still treat the variable as uninitialized. */\n-    int recid = -1; VG_UNDEF(&recid, sizeof(recid));\n+    int recid;\n     random_scalar_order_test(&msg);\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n     getrec = secp256k1_testrand_bits(1);\n-    random_sign(&sigr, &sigs, &key, &msg, getrec?&recid:NULL);\n+    /* The specific way in which this conditional is written sidesteps a potential bug in clang.\n+       See the commit messages of the commit that introduced this comment for details. */\n     if (getrec) {\n+        random_sign(&sigr, &sigs, &key, &msg, &recid);\n         CHECK(recid >= 0 && recid < 4);\n+    } else {\n+        random_sign(&sigr, &sigs, &key, &msg, NULL);\n     }\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n }\n \n void run_ecdsa_sign_verify(void) {\n@@ -5955,7 +6072,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &keyj, &sr);\n         secp256k1_ge_set_gej(&key, &keyj);\n         msg = ss;\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with r of zero fails. */\n@@ -5974,7 +6091,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 0);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey_mods_zero, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify( &sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with s of zero fails. */\n@@ -5993,7 +6110,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 1);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with message 0 passes. */\n@@ -6021,14 +6138,14 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&sr, 2);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message 1 passes. */\n@@ -6062,15 +6179,15 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 2);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message -1 passes. */\n@@ -6096,12 +6213,12 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_negate(&msg, &msg);\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 3);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Signature where s would be zero. */\n@@ -6347,10 +6464,10 @@ void test_ecdsa_openssl(void) {\n     CHECK(ec_key != NULL);\n     CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n     CHECK(secp256k1_ecdsa_sig_parse(&sigr, &sigs, signature, sigsize));\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &q, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg2, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg2));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sigr, &sigs, &q, &msg2));\n \n     random_sign(&sigr, &sigs, &key, &msg, NULL);\n     CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sigr, &sigs));\n@@ -6383,6 +6500,10 @@ void run_ecdsa_openssl(void) {\n # include \"modules/schnorrsig/tests_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSQ\n+# include \"modules/ellsq/tests_impl.h\"\n+#endif\n+\n void run_secp256k1_memczero_test(void) {\n     unsigned char buf1[6] = {1, 2, 3, 4, 5, 6};\n     unsigned char buf2[sizeof(buf1)];\n@@ -6618,6 +6739,7 @@ int main(int argc, char **argv) {\n     run_group_decompress();\n \n     /* ecmult tests */\n+    run_ecmult_pre_g();\n     run_wnaf();\n     run_point_times_order();\n     run_ecmult_near_split_bound();\n@@ -6669,6 +6791,10 @@ int main(int argc, char **argv) {\n     run_schnorrsig_tests();\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSQ\n+    run_ellsq_tests();\n+#endif\n+\n     /* util tests */\n     run_secp256k1_memczero_test();\n "
      },
      {
        "sha": "4d96dd947b46f8beea95ca5631a7bf1b310e9463",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/184e1fac177a4af7284df283cd75a8a4da17161d/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/184e1fac177a4af7284df283cd75a8a4da17161d/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=184e1fac177a4af7284df283cd75a8a4da17161d",
        "patch": "@@ -163,7 +163,7 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     }\n }\n \n-void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj) {\n+void test_exhaustive_ecmult(const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j, r_log;\n     uint64_t iter = 0;\n     for (r_log = 1; r_log < EXHAUSTIVE_TEST_ORDER; r_log++) {\n@@ -175,7 +175,7 @@ void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *gr\n                 secp256k1_scalar_set_int(&na, i);\n                 secp256k1_scalar_set_int(&ng, j);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                secp256k1_ecmult(&tmp, &groupj[r_log], &na, &ng);\n                 ge_equals_gej(&group[(i * r_log + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n \n                 if (i > 0) {\n@@ -219,7 +219,7 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                     }\n                 }\n@@ -430,7 +430,7 @@ int main(int argc, char** argv) {\n         /* Run the tests */\n         test_exhaustive_endomorphism(group);\n         test_exhaustive_addition(group, groupj);\n-        test_exhaustive_ecmult(ctx, group, groupj);\n+        test_exhaustive_ecmult(group, groupj);\n         test_exhaustive_ecmult_multi(ctx, group);\n         test_exhaustive_sign(ctx, group);\n         test_exhaustive_verify(ctx, group);"
      }
    ]
  },
  {
    "sha": "fffcce1173506c41e90a18f516fd32ee32a8af4c",
    "node_id": "C_kwDOABII59oAKGZmZmNjZTExNzM1MDZjNDFlOTBhMThmNTE2ZmQzMmVlMzJhOGFmNGM",
    "commit": {
      "author": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-02T21:52:55Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-02T21:52:55Z"
      },
      "message": "Merge commit '184e1fac177a4af7284df283cd75a8a4da17161d' into bip324-ellsq",
      "tree": {
        "sha": "1f201d2520b8bc9442bd9f26bd23ccff4624c503",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f201d2520b8bc9442bd9f26bd23ccff4624c503"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fffcce1173506c41e90a18f516fd32ee32a8af4c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fffcce1173506c41e90a18f516fd32ee32a8af4c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fffcce1173506c41e90a18f516fd32ee32a8af4c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fffcce1173506c41e90a18f516fd32ee32a8af4c/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3c4729a515d85e3cfcd66220c849857c712597e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c4729a515d85e3cfcd66220c849857c712597e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3c4729a515d85e3cfcd66220c849857c712597e4"
      },
      {
        "sha": "184e1fac177a4af7284df283cd75a8a4da17161d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/184e1fac177a4af7284df283cd75a8a4da17161d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/184e1fac177a4af7284df283cd75a8a4da17161d"
      }
    ],
    "stats": {
      "total": 18884,
      "additions": 18261,
      "deletions": 623
    },
    "files": [
      {
        "sha": "3eb44ba6f494daefb9145425ae9a0b86c735e589",
        "filename": "src/secp256k1/.cirrus.yml",
        "status": "modified",
        "additions": 13,
        "deletions": 4,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.cirrus.yml?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -18,6 +18,7 @@ env:\n   ECDH: no\n   RECOVERY: no\n   SCHNORRSIG: no\n+  ELLSQ: no\n   ### test options\n   TEST_ITERS:\n   BENCH: yes\n@@ -60,12 +61,12 @@ task:\n     memory: 1G\n   matrix: &ENV_MATRIX\n     - env: {WIDEMUL:  int64,  RECOVERY: yes}\n-    - env: {WIDEMUL:  int64,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL:  int64,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes, ELLSQ: yes}\n     - env: {WIDEMUL: int128}\n-    - env: {WIDEMUL: int128,  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {WIDEMUL: int128,  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes, ELLSQ: yes}\n     - env: {WIDEMUL: int128,                 ECDH: yes, EXPERIMENTAL: yes, SCHNORRSIG: yes}\n     - env: {WIDEMUL: int128,  ASM: x86_64}\n-    - env: {                  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes}\n+    - env: {                  RECOVERY: yes,            EXPERIMENTAL: yes, SCHNORRSIG: yes, ELLSQ: yes}\n     - env: {                  STATICPRECOMPUTATION: no}\n     - env: {BUILD: distcheck, WITH_VALGRIND: no, CTIMETEST: no, BENCH: no}\n     - env: {CPPFLAGS: -DDETERMINISTIC}\n@@ -91,6 +92,7 @@ task:\n   env:\n     HOST: i686-linux-gnu\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -175,6 +177,7 @@ task:\n     HOST: s390x-linux-gnu\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -198,6 +201,7 @@ task:\n     HOST: arm-linux-gnueabihf\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: tes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -222,6 +226,7 @@ task:\n     HOST: aarch64-linux-gnu\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -243,6 +248,7 @@ task:\n     HOST: powerpc64le-linux-gnu\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -264,6 +270,7 @@ task:\n     HOST: x86_64-w64-mingw32\n     WITH_VALGRIND: no\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -278,9 +285,10 @@ task:\n   container:\n     dockerfile: ci/linux-debian.Dockerfile\n     cpu: 1\n-    memory: 1G\n+    memory: 2G\n   env:\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     EXPERIMENTAL: yes\n     SCHNORRSIG: yes\n@@ -334,6 +342,7 @@ task:\n     WERROR_CFLAGS:\n     EXPERIMENTAL: yes\n     ECDH: yes\n+    ELLSQ: yes\n     RECOVERY: yes\n     SCHNORRSIG: yes\n   << : *MERGE_BASE"
      },
      {
        "sha": "9cf2163c3978bbb5bfd37314ad2a40102d6a6a6a",
        "filename": "src/secp256k1/.gitattributes",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/.gitattributes",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/.gitattributes",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitattributes?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1 @@\n+src/ecmult_static_pre_g.h linguist-generated"
      },
      {
        "sha": "9e187a34a9606bed2564ec80148d9e2ef366f5d0",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -9,6 +9,7 @@ bench_internal\n tests\n exhaustive_tests\n gen_context\n+gen_ecmult_static_pre_g\n valgrind_ctime_test\n *.exe\n *.so"
      },
      {
        "sha": "4a23eea8613cac436641108742df8d20220704a3",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -127,12 +127,19 @@ exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n \n+EXTRA_PROGRAMS = gen_ecmult_static_pre_g\n+gen_ecmult_static_pre_g_SOURCES = src/gen_ecmult_static_pre_g.c\n+# See Automake manual, Section \"Errors with distclean\"\n+src/ecmult_static_pre_g.h:\n+\t$(MAKE) $(AM_MAKEFLAGS) gen_ecmult_static_pre_g$(EXEEXT)\n+\t./gen_ecmult_static_pre_g$(EXEEXT)\n+\n if USE_ECMULT_STATIC_PRECOMPUTATION\n CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n+$(gen_context_OBJECTS): src/gen_context.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(DEFS) $(CPPFLAGS_FOR_BUILD) $(SECP_CFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n@@ -149,7 +156,7 @@ src/ecmult_static_context.h: $(gen_context_BIN)\n CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/ecmult_static_pre_g.h src/basic-config.h\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n@@ -166,3 +173,7 @@ endif\n if ENABLE_MODULE_SCHNORRSIG\n include src/modules/schnorrsig/Makefile.am.include\n endif\n+\n+if ENABLE_MODULE_ELLSQ\n+include src/modules/ellsq/Makefile.am.include\n+endif"
      },
      {
        "sha": "61352f228e25533f6e2aca11ed1f5c8032ac7f27",
        "filename": "src/secp256k1/ci/cirrus.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/ci/cirrus.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/ci/cirrus.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/cirrus.sh?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -16,7 +16,7 @@ valgrind --version || true\n     --enable-experimental=\"$EXPERIMENTAL\" \\\n     --with-test-override-wide-multiply=\"$WIDEMUL\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n-    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" --enable-module-ellsq=\"$ELLSQ\" \\\n     --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n     --with-valgrind=\"$WITH_VALGRIND\" \\\n     --host=\"$HOST\" $EXTRAFLAGS\n@@ -60,6 +60,10 @@ then\n     then\n         $EXEC ./bench_ecdh >> bench.log 2>&1\n     fi\n+    if [ \"$ELLSQ\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_ellsq >> bench.log 2>&1\n+    fi\n     if [ \"$SCHNORRSIG\" = \"yes\" ]\n     then\n         $EXEC ./bench_schnorrsig >> bench.log 2>&1"
      },
      {
        "sha": "fdba12aa00b474a9043d8eb56eab1ff20bda6145",
        "filename": "src/secp256k1/ci/linux-debian.Dockerfile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/ci/linux-debian.Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/ci/linux-debian.Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/ci/linux-debian.Dockerfile?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -14,7 +14,7 @@ RUN apt-get install --no-install-recommends --no-upgrade -y \\\n         make automake libtool pkg-config dpkg-dev valgrind qemu-user \\\n         gcc clang llvm libc6-dbg \\\n         g++ \\\n-        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan5:i386 \\\n+        gcc-i686-linux-gnu libc6-dev-i386-cross libc6-dbg:i386 libubsan1:i386 libasan6:i386 \\\n         gcc-s390x-linux-gnu libc6-dev-s390x-cross libc6-dbg:s390x \\\n         gcc-arm-linux-gnueabihf libc6-dev-armhf-cross libc6-dbg:armhf \\\n         gcc-aarch64-linux-gnu libc6-dev-arm64-cross libc6-dbg:arm64 \\"
      },
      {
        "sha": "e6410fed9b0ec62dae8426dac38c327b540b01ec",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -161,6 +161,11 @@ AC_ARG_ENABLE(module_schnorrsig,\n     [enable_module_schnorrsig=$enableval],\n     [enable_module_schnorrsig=no])\n \n+AC_ARG_ENABLE(module_ellsq,\n+    AS_HELP_STRING([--enable-module-ellsq],[enable Elligator^2 module (experimental)]),\n+    [enable_module_ellsq=$enableval],\n+    [enable_module_ellsq=no])\n+\n AC_ARG_ENABLE(external_default_callbacks,\n     AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n     [use_external_default_callbacks=$enableval],\n@@ -177,6 +182,8 @@ AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n [window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n [Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n [The table will store 2^(SIZE-1) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[A window size larger than 15 will require you delete the prebuilt ecmult_static_pre_g.h file so that it can be rebuilt.]\n+[For very large window sizes, use \"make -j 1\" to reduce memory use during compilation.]\n [\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n )],\n [req_ecmult_window=$withval], [req_ecmult_window=auto])\n@@ -454,6 +461,10 @@ if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_EXTRAKEYS, 1, [Define this symbol to enable the extrakeys module])\n fi\n \n+if test x\"$enable_module_ellsq\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_MODULE_ELLSQ, 1, [Define this symbol to enable the Elligator^2 module])\n+fi\n+\n if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n fi\n@@ -468,6 +479,7 @@ if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n   AC_MSG_NOTICE([Building extrakeys module: $enable_module_extrakeys])\n   AC_MSG_NOTICE([Building schnorrsig module: $enable_module_schnorrsig])\n+  AC_MSG_NOTICE([Building Elligator^2 module: $enable_module_ellsq])\n   AC_MSG_NOTICE([******])\n else\n   if test x\"$enable_module_extrakeys\" = x\"yes\"; then\n@@ -476,6 +488,9 @@ else\n   if test x\"$enable_module_schnorrsig\" = x\"yes\"; then\n     AC_MSG_ERROR([schnorrsig module is experimental. Use --enable-experimental to allow.])\n   fi\n+  if test x\"$enable_module_ellsq\" = x\"yes\"; then\n+    AC_MSG_ERROR([Elligator^2 module is experimental. Use --enable-experimental to allow.])\n+  fi\n   if test x\"$set_asm\" = x\"arm\"; then\n     AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n   fi\n@@ -501,6 +516,7 @@ AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_EXTRAKEYS], [test x\"$enable_module_extrakeys\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_SCHNORRSIG], [test x\"$enable_module_schnorrsig\" = x\"yes\"])\n+AM_CONDITIONAL([ENABLE_MODULE_ELLSQ], [test x\"$enable_module_ellsq\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -523,6 +539,7 @@ echo \"  module ecdh             = $enable_module_ecdh\"\n echo \"  module recovery         = $enable_module_recovery\"\n echo \"  module extrakeys        = $enable_module_extrakeys\"\n echo \"  module schnorrsig       = $enable_module_schnorrsig\"\n+echo \"  module ellsq            = $enable_module_ellsq\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  ecmult window size      = $set_ecmult_window\""
      },
      {
        "sha": "576953f49d4aaaf10165a5aa4715984fbe6154eb",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 48,
        "deletions": 49,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -226,7 +226,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n  *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx: an existing context to copy (cannot be NULL)\n+ *  Args:    ctx: an existing context to copy\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n@@ -247,7 +247,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Set a callback function to be called when an illegal argument is passed to\n  *  an API call. It will only trigger for violations that are mentioned\n@@ -278,11 +278,11 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  fails. In this case, the corresponding default handler will be called with\n  *  the data pointer argument set to NULL.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n  *              passed to the API, taking a message and an opaque pointer.\n  *              (NULL restores the default handler.)\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_error_callback.\n  */\n@@ -302,12 +302,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *  for that). After this callback returns, anything may happen, including\n  *  crashing.\n  *\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n  *              taking a message and an opaque pointer (NULL restores the\n  *              default handler, see secp256k1_context_set_illegal_callback\n  *              for details).\n- *        data: the opaque pointer to pass to fun above.\n+ *        data: the opaque pointer to pass to fun above, must be NULL for the default handler.\n  *\n  *  See also secp256k1_context_set_illegal_callback.\n  */\n@@ -320,7 +320,7 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n /** Create a secp256k1 scratch space object.\n  *\n  *  Returns: a newly created scratch space.\n- *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  Args: ctx:  an existing context object.\n  *  In:   size: amount of memory to be available as scratch space. Some extra\n  *              (<100 bytes) will be allocated for extra accounting.\n  */\n@@ -480,16 +480,16 @@ SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(\n  *  Returns: 1: correct signature\n  *           0: incorrect or unparseable signature\n  *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig:       the signature being verified (cannot be NULL)\n- *           msghash32: the 32-byte message hash being verified (cannot be NULL).\n+ *  In:      sig:       the signature being verified.\n+ *           msghash32: the 32-byte message hash being verified.\n  *                      The verifier must make sure to apply a cryptographic\n  *                      hash function to the message by itself and not accept an\n  *                      msghash32 value directly. Otherwise, it would be easy to\n  *                      create a \"valid\" signature without knowledge of the\n  *                      secret key. See also\n  *                      https://bitcoin.stackexchange.com/a/81116/35586 for more\n  *                      background on this topic.\n- *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)\n+ *           pubkey:    pointer to an initialized public key to verify with.\n  *\n  * To avoid accepting malleable signatures, only ECDSA signatures in lower-S\n  * form are accepted.\n@@ -515,8 +515,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(\n  *                or copy if the input was already normalized. (can be NULL if\n  *                you're only interested in whether the input was already\n  *                normalized).\n- *  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,\n- *                can be identical to sigout)\n+ *  In:   sigin:  a pointer to a signature to check/normalize (can be identical to sigout)\n  *\n  *  With ECDSA a third-party can forge a second distinct signature of the same\n  *  message, given a single initial signature, but without knowing the key. This\n@@ -568,12 +567,16 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL). If it is non-NULL and\n+ *                      secp256k1_nonce_function_default is used, then ndata must be a\n+ *                      pointer to 32-bytes of additional data.\n  *\n  * The created signature is always in lower-S form. See\n  * secp256k1_ecdsa_signature_normalize for more details.\n@@ -596,8 +599,8 @@ SECP256K1_API int secp256k1_ecdsa_sign(\n  *\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n- *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n     const secp256k1_context* ctx,\n@@ -606,11 +609,11 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n \n /** Compute the public key for a secret key.\n  *\n- *  Returns: 1: secret was valid, public key stores\n- *           0: secret was invalid, try again\n- *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:    pubkey:     pointer to the created public key (cannot be NULL)\n- *  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)\n+ *  Returns: 1: secret was valid, public key stores.\n+ *           0: secret was invalid, try again.\n+ *  Args:    ctx:    pointer to a context object, initialized for signing.\n+ *  Out:     pubkey: pointer to the created public key.\n+ *  In:      seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const secp256k1_context* ctx,\n@@ -626,8 +629,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n  *  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the\n  *                  secret key is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0 and\n- *                  seckey will be set to some unspecified value. (cannot be\n- *                  NULL)\n+ *                  seckey will be set to some unspecified value.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_negate(\n     const secp256k1_context* ctx,\n@@ -645,7 +647,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n  *\n  *  Returns: 1 always\n  *  Args:   ctx:        pointer to a context object\n- *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ *  In/Out: pubkey:     pointer to the public key to be negated.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n     const secp256k1_context* ctx,\n@@ -657,15 +659,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n  *  Returns: 0 if the arguments are invalid or the resulting secret key would be\n  *           invalid (only when the tweak is the negation of the secret key). 1\n  *           otherwise.\n- *  Args:    ctx:   pointer to a context object (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -686,14 +688,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n  *  Returns: 0 if the arguments are invalid or the resulting public key would be\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -704,15 +705,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n /** Tweak a secret key by multiplying it by a tweak.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx:    pointer to a context object (cannot be NULL).\n+ *  Args:   ctx:    pointer to a context object.\n  *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n  *                  invalid according to secp256k1_ec_seckey_verify, this\n  *                  function returns 0. seckey will be set to some unspecified\n- *                  value if this function returns 0. (cannot be NULL)\n+ *                  value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -731,14 +732,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n /** Tweak a public key by multiplying it by a tweak value.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx:   pointer to a context object initialized for validation\n- *                  (cannot be NULL).\n+ *  Args:    ctx:   pointer to a context object initialized for validation.\n  *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n- *                  invalid value if this function returns 0 (cannot be NULL).\n+ *                  invalid value if this function returns 0.\n  *  In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to\n  *                  secp256k1_ec_seckey_verify, this function returns 0. For\n  *                  uniformly random 32-byte arrays the chance of being invalid\n- *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                  is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -749,7 +749,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n /** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated or nothing to randomize\n  *           0: error\n- *  Args:    ctx:       pointer to a context object (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object.\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n  *\n  * While secp256k1 code is written to be constant-time no matter what secret\n@@ -780,18 +780,17 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n  *\n  *  Returns: 1: the sum of the public keys is valid.\n  *           0: the sum of the public keys is not valid.\n- *  Args:   ctx:        pointer to a context object\n- *  Out:    out:        pointer to a public key object for placing the resulting public key\n- *                      (cannot be NULL)\n- *  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)\n- *          n:          the number of public keys to add together (must be at least 1)\n+ *  Args:   ctx:        pointer to a context object.\n+ *  Out:    out:        pointer to a public key object for placing the resulting public key.\n+ *  In:     ins:        pointer to array of pointers to public keys.\n+ *          n:          the number of public keys to add together (must be at least 1).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *out,\n     const secp256k1_pubkey * const * ins,\n     size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Compute a tagged hash as defined in BIP-340.\n  *"
      },
      {
        "sha": "c8577984b1a5ef35a8f3334e16e9865dd04e5ca1",
        "filename": "src/secp256k1/include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_ecdh.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -37,14 +37,15 @@ SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_func\n  *\n  *  Returns: 1: exponentiation was successful\n  *           0: scalar was invalid (zero or overflow) or hashfp returned 0\n- *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     output:     pointer to an array to be filled by hashfp\n- *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n- *                       initialized public key\n- *           seckey:     a 32-byte scalar with which to multiply the point\n- *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n- *                       (in which case, 32 bytes will be written to output)\n+ *  Args:    ctx:        pointer to a context object.\n+ *  Out:     output:     pointer to an array to be filled by hashfp.\n+ *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an initialized public key.\n+ *           seckey:     a 32-byte scalar with which to multiply the point.\n+ *           hashfp:     pointer to a hash function. If NULL,\n+ *                       secp256k1_ecdh_hash_function_sha256 is used\n+ *                       (in which case, 32 bytes will be written to output).\n  *           data:       arbitrary data pointer that is passed through to hashfp\n+ *                       (can be NULL for secp256k1_ecdh_hash_function_sha256).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,"
      },
      {
        "sha": "e01937e352f8216601ad44eca09e8834c630da78",
        "filename": "src/secp256k1/include/secp256k1_ellsq.h",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_ellsq.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_ellsq.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_ellsq.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1,78 @@\n+#ifndef SECP256K1_ELLSQ_H\n+#define SECP256K1_ELLSQ_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation of the Elligator Squared encoding\n+ * for secp256k1 public keys. Given a uniformly random public key, this\n+ * produces a 64-byte encoding that is indistinguishable from uniformly\n+ * random bytes.\n+ *\n+ * Elligator Squared is described in https://eprint.iacr.org/2014/043.pdf by\n+ * Mehdi Tibouchi. The mapping function used is described in\n+ * https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf by Fouque and Tibouchi.\n+ *\n+ * Let f be the function from field elements to curve points, defined as\n+ * follows:\n+ * f(t):\n+ * - Let c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852\n+ * - Let x1 = (c - 1)/2 - c*t^2 / (t^2 + 8) (mod p)\n+ * - Let x2 = (-c - 1)/2 + c*t^2 / (t^2 + 8) (mod p)\n+ * - Let x3 = 1 - (t^2 + 8)^2 / (3*t^2) (mod p)\n+ * - Let x be the first of [x1,x2,x3] that is an X coordinate on the curve\n+ *   (at least one of them is, for any field element t).\n+ * - Let y be the the corresponding Y coordinate to x, with the same parity\n+ *   as t (even if t is even, odd if t is odd).\n+ * - Return the curve point with coordinates (x, y).\n+ *\n+ * Then an Elligator Squared encoding of P consists of the 32-byte big-endian\n+ * encodings of field elements u1 and u2 concatenated, where f(u1)+f(u2) = P.\n+ * The encoding algorithm is described in the paper, and effectively picks a\n+ * uniformly random pair (u1,u2) among those which encode P.\n+ *\n+ * To make the encoding able to deal with all inputs, if f(u1)+f(u2) is the\n+ * point at infinity, the decoding is defined to be f(u1) instead.\n+ */\n+\n+/* Construct a 64-byte Elligator Squared encoding of a given pubkey.\n+ *\n+ *  Returns: 1 when pubkey is valid.\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     ell64:      pointer to a 64-byte array to be filled\n+ *  In:      rnd32:      pointer to 32 bytes of entropy (must be unpredictable)\n+ *           pubkey:     a pointer to a secp256k1_pubkey containing an\n+ *                       initialized public key\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellsq_encode(\n+    const secp256k1_context* ctx,\n+    unsigned char *ell64,\n+    const unsigned char *rnd32,\n+    const secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Decode a 64-bytes Elligator Squared encoded public key.\n+ *\n+ *  Returns: always 1\n+ *  Args:    ctx:        pointer to a context object\n+ *  Out:     pubkey:     pointer to a secp256k1_pubkey that will be filled\n+ *  In:      ell64:      pointer to a 64-byte array to decode\n+ *\n+ * This function runs in variable time.\n+ */\n+SECP256K1_API int secp256k1_ellsq_decode(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey,\n+    const unsigned char *ell64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_ELLSQ_H */"
      },
      {
        "sha": "a64d561b60bff825a71892f959082aff9f6c5448",
        "filename": "src/secp256k1/include/secp256k1_extrakeys.h",
        "status": "modified",
        "additions": 34,
        "deletions": 48,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_extrakeys.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_extrakeys.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_extrakeys.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -39,11 +39,10 @@ typedef struct {\n  *  Returns: 1 if the public key was fully valid.\n  *           0 if the public key could not be parsed or is invalid.\n  *\n- *  Args:   ctx: a secp256k1 context object (cannot be NULL).\n+ *  Args:   ctx: a secp256k1 context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a\n  *               parsed version of input. If not, it's set to an invalid value.\n- *               (cannot be NULL).\n- *  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  In: input32: pointer to a serialized xonly_pubkey.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n     const secp256k1_context* ctx,\n@@ -55,11 +54,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_parse(\n  *\n  *  Returns: 1 always.\n  *\n- *  Args:     ctx: a secp256k1 context object (cannot be NULL).\n- *  Out: output32: a pointer to a 32-byte array to place the serialized key in\n- *                 (cannot be NULL).\n- *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an\n- *                 initialized public key (cannot be NULL).\n+ *  Args:     ctx: a secp256k1 context object.\n+ *  Out: output32: a pointer to a 32-byte array to place the serialized key in.\n+ *  In:    pubkey: a pointer to a secp256k1_xonly_pubkey containing an initialized public key.\n  */\n SECP256K1_API int secp256k1_xonly_pubkey_serialize(\n     const secp256k1_context* ctx,\n@@ -87,13 +84,12 @@ SECP256K1_API int secp256k1_xonly_pubkey_cmp(\n  *  Returns: 1 if the public key was successfully converted\n  *           0 otherwise\n  *\n- *  Args:         ctx: pointer to a context object (cannot be NULL)\n- *  Out: xonly_pubkey: pointer to an x-only public key object for placing the\n- *                     converted public key (cannot be NULL)\n- *          pk_parity: pointer to an integer that will be set to 1 if the point\n- *                     encoded by xonly_pubkey is the negation of the pubkey and\n- *                     set to 0 otherwise. (can be NULL)\n- *  In:        pubkey: pointer to a public key that is converted (cannot be NULL)\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key.\n+ *          pk_parity: Ignored if NULL. Otherwise, pointer to an integer that\n+ *                     will be set to 1 if the point encoded by xonly_pubkey is\n+ *                     the negation of the pubkey and set to 0 otherwise.\n+ *  In:        pubkey: pointer to a public key that is converted.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubkey(\n     const secp256k1_context* ctx,\n@@ -113,18 +109,14 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_from_pubke\n  *           invalid (only when the tweak is the negation of the corresponding\n  *           secret key). 1 otherwise.\n  *\n- *  Args:           ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n+ *  Args:           ctx: pointer to a context object initialized for verification.\n  *  Out:  output_pubkey: pointer to a public key to store the result. Will be set\n- *                       to an invalid value if this function returns 0 (cannot\n- *                       be NULL)\n+ *                       to an invalid value if this function returns 0.\n  *  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.\n- *                       (cannot be NULL).\n  *              tweak32: pointer to a 32-byte tweak. If the tweak is invalid\n  *                       according to secp256k1_ec_seckey_verify, this function\n  *                       returns 0. For uniformly random 32-byte arrays the\n- *                       chance of being invalid is negligible (around 1 in\n- *                       2^128) (cannot be NULL).\n+ *                       chance of being invalid is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n@@ -146,17 +138,15 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add(\n  *\n  *  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the\n  *           result of tweaking the internal_pubkey with tweak32. 1 otherwise.\n- *  Args:            ctx: pointer to a context object initialized for verification\n- *                       (cannot be NULL)\n- *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)\n+ *  Args:            ctx: pointer to a context object initialized for verification.\n+ *  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey.\n  *     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization\n  *                        is passed in as tweaked_pubkey32). This must match the\n  *                        pk_parity value that is returned when calling\n  *                        secp256k1_xonly_pubkey with the tweaked pubkey, or\n  *                        this function will fail.\n- *       internal_pubkey: pointer to an x-only public key object to apply the\n- *                        tweak to (cannot be NULL)\n- *               tweak32: pointer to a 32-byte tweak (cannot be NULL)\n+ *       internal_pubkey: pointer to an x-only public key object to apply the tweak to.\n+ *               tweak32: pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_check(\n     const secp256k1_context* ctx,\n@@ -170,9 +160,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_xonly_pubkey_tweak_add_\n  *\n  *  Returns: 1: secret was valid, keypair is ready to use\n  *           0: secret was invalid, try again with a different secret\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out: keypair: pointer to the created keypair (cannot be NULL)\n- *  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out: keypair: pointer to the created keypair.\n+ *  In:   seckey: pointer to a 32-byte secret key.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n     const secp256k1_context* ctx,\n@@ -183,9 +173,9 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_create(\n /** Get the secret key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n- *  Out: seckey: pointer to a 32-byte buffer for the secret key (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n+ *  Out: seckey: pointer to a 32-byte buffer for the secret key.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n     const secp256k1_context* ctx,\n@@ -196,11 +186,10 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_sec(\n /** Get the public key from a keypair.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:    ctx: pointer to a context object (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object.\n  *  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to\n  *               the keypair public key. If not, it's set to an invalid value.\n- *               (cannot be NULL)\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n     const secp256k1_context* ctx,\n@@ -214,14 +203,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_pub(\n  *  secp256k1_xonly_pubkey_from_pubkey.\n  *\n  *  Returns: 0 if the arguments are invalid. 1 otherwise.\n- *  Args:   ctx: pointer to a context object (cannot be NULL)\n+ *  Args:   ctx: pointer to a context object.\n  *  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set\n  *               to the keypair public key after converting it to an\n- *               xonly_pubkey. If not, it's set to an invalid value (cannot be\n- *               NULL).\n- *    pk_parity: pointer to an integer that will be set to the pk_parity\n- *               argument of secp256k1_xonly_pubkey_from_pubkey (can be NULL).\n- *  In: keypair: pointer to a keypair (cannot be NULL)\n+ *               xonly_pubkey. If not, it's set to an invalid value.\n+ *    pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the\n+ *               pk_parity argument of secp256k1_xonly_pubkey_from_pubkey.\n+ *  In: keypair: pointer to a keypair.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n     const secp256k1_context* ctx,\n@@ -241,15 +229,13 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_pub(\n  *           invalid (only when the tweak is the negation of the keypair's\n  *           secret key). 1 otherwise.\n  *\n- *  Args:       ctx: pointer to a context object initialized for verification\n- *                   (cannot be NULL)\n+ *  Args:       ctx: pointer to a context object initialized for verification.\n  *  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to\n- *                   an invalid value if this function returns 0 (cannot be\n- *                   NULL).\n+ *                   an invalid value if this function returns 0.\n  *  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according\n  *                   to secp256k1_ec_seckey_verify, this function returns 0. For\n  *                   uniformly random 32-byte arrays the chance of being invalid\n- *                   is negligible (around 1 in 2^128) (cannot be NULL).\n+ *                   is negligible (around 1 in 2^128).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_keypair_xonly_tweak_add(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "d2d9014f02881c5ac36164af5c63932d170c3c46",
        "filename": "src/secp256k1/include/secp256k1_preallocated.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_preallocated.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -55,7 +55,7 @@ SECP256K1_API size_t secp256k1_context_preallocated_size(\n  *  Returns: a newly created context object.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  *           flags:    which parts of the context to initialize.\n  *\n  *  See also secp256k1_context_randomize (in secp256k1.h)\n@@ -70,7 +70,7 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n  *  caller-provided memory.\n  *\n  *  Returns: the required size of the caller-provided memory block.\n- *  In:      ctx: an existing context to copy (cannot be NULL)\n+ *  In:      ctx: an existing context to copy.\n  */\n SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n     const secp256k1_context* ctx\n@@ -87,10 +87,10 @@ SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n  *  secp256k1_context_preallocated_create for details.\n  *\n  *  Returns: a newly created context object.\n- *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  Args:    ctx:      an existing context to copy.\n  *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n  *                     size at least secp256k1_context_preallocated_size(flags)\n- *                     bytes, as detailed above (cannot be NULL)\n+ *                     bytes, as detailed above.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n     const secp256k1_context* ctx,\n@@ -115,11 +115,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n  *\n  *  Args:   ctx: an existing context to destroy, constructed using\n  *               secp256k1_context_preallocated_create or\n- *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ *               secp256k1_context_preallocated_clone.\n  */\n SECP256K1_API void secp256k1_context_preallocated_destroy(\n     secp256k1_context* ctx\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "0e2847db96c6925d0bf58c897b839870bfc677b5",
        "filename": "src/secp256k1/include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_recovery.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -43,8 +43,9 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_parse_compact(\n /** Convert a recoverable signature into a normal signature.\n  *\n  *  Returns: 1\n- *  Out: sig:    a pointer to a normal signature (cannot be NULL).\n- *  In:  sigin:  a pointer to a recoverable signature (cannot be NULL).\n+ *  Args: ctx:    a secp256k1 context object.\n+ *  Out:  sig:    a pointer to a normal signature.\n+ *  In:   sigin:  a pointer to a recoverable signature.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n     const secp256k1_context* ctx,\n@@ -55,10 +56,10 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert(\n /** Serialize an ECDSA signature in compact format (64 bytes + recovery id).\n  *\n  *  Returns: 1\n- *  Args: ctx:      a secp256k1 context object\n- *  Out:  output64: a pointer to a 64-byte array of the compact signature (cannot be NULL)\n- *        recid:    a pointer to an integer to hold the recovery id (can be NULL).\n- *  In:   sig:      a pointer to an initialized signature object (cannot be NULL)\n+ *  Args: ctx:      a secp256k1 context object.\n+ *  Out:  output64: a pointer to a 64-byte array of the compact signature.\n+ *        recid:    a pointer to an integer to hold the recovery id.\n+ *  In:   sig:      a pointer to an initialized signature object.\n  */\n SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n     const secp256k1_context* ctx,\n@@ -71,12 +72,14 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n  *\n  *  Returns: 1: signature created\n  *           0: the nonce generation function failed, or the secret key was invalid.\n- *  Args:    ctx:       pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:     sig:       pointer to an array where the signature will be placed (cannot be NULL)\n- *  In:      msghash32: the 32-byte message hash being signed (cannot be NULL)\n- *           seckey:    pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:   pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used\n- *           ndata:     pointer to arbitrary data used by the nonce generation function (can be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for signing.\n+ *  Out:     sig:       pointer to an array where the signature will be placed.\n+ *  In:      msghash32: the 32-byte message hash being signed.\n+ *           seckey:    pointer to a 32-byte secret key.\n+ *           noncefp:   pointer to a nonce generation function. If NULL,\n+ *                      secp256k1_nonce_function_default is used.\n+ *           ndata:     pointer to arbitrary data used by the nonce generation function\n+ *                      (can be NULL for secp256k1_nonce_function_default).\n  */\n SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n     const secp256k1_context* ctx,\n@@ -91,10 +94,10 @@ SECP256K1_API int secp256k1_ecdsa_sign_recoverable(\n  *\n  *  Returns: 1: public key successfully recovered (which guarantees a correct signature).\n  *           0: otherwise.\n- *  Args:    ctx:       pointer to a context object, initialized for verification (cannot be NULL)\n- *  Out:     pubkey:    pointer to the recovered public key (cannot be NULL)\n- *  In:      sig:       pointer to initialized signature that supports pubkey recovery (cannot be NULL)\n- *           msghash32: the 32-byte message hash assumed to be signed (cannot be NULL)\n+ *  Args:    ctx:       pointer to a context object, initialized for verification.\n+ *  Out:     pubkey:    pointer to the recovered public key.\n+ *  In:      sig:       pointer to initialized signature that supports pubkey recovery.\n+ *           msghash32: the 32-byte message hash assumed to be signed.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover(\n     const secp256k1_context* ctx,"
      },
      {
        "sha": "4ac421ea45c2b2812e4767053d79b24dc93f96e9",
        "filename": "src/secp256k1/include/secp256k1_schnorrsig.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_schnorrsig.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/include/secp256k1_schnorrsig.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorrsig.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -106,10 +106,10 @@ typedef struct {\n  *  signatures from being valid in multiple contexts by accident.\n  *\n  *  Returns 1 on success, 0 on failure.\n- *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n- *  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)\n- *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n- *       keypair: pointer to an initialized keypair (cannot be NULL)\n+ *  Args:    ctx: pointer to a context object, initialized for signing.\n+ *  Out:   sig64: pointer to a 64-byte array to store the serialized signature.\n+ *  In:    msg32: the 32-byte message being signed.\n+ *       keypair: pointer to an initialized keypair.\n  *    aux_rand32: 32 bytes of fresh randomness. While recommended to provide\n  *                this, it is only supplemental to security and can be NULL. See\n  *                BIP-340 \"Default Signing\" for a full explanation of this\n@@ -150,7 +150,7 @@ SECP256K1_API int secp256k1_schnorrsig_sign_custom(\n  *  Returns: 1: correct signature\n  *           0: incorrect signature\n  *  Args:    ctx: a secp256k1 context object, initialized for verification.\n- *  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)\n+ *  In:    sig64: pointer to the 64-byte signature to verify.\n  *           msg: the message being verified. Can only be NULL if msglen is 0.\n  *        msglen: length of the message\n  *        pubkey: pointer to an x-only public key to verify with (cannot be NULL)"
      },
      {
        "sha": "420c4293c03330ff8c65fb114cc19f1f8a27f499",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -129,7 +129,7 @@ static void bench_ecmult_1(void* arg, int iters) {\n     int i;\n \n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], NULL);\n     }\n }\n \n@@ -145,7 +145,7 @@ static void bench_ecmult_1g(void* arg, int iters) {\n \n     secp256k1_scalar_set_int(&zero, 0);\n     for (i = 0; i < iters; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], NULL, &zero, &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n@@ -159,7 +159,7 @@ static void bench_ecmult_2g(void* arg, int iters) {\n     int i;\n \n     for (i = 0; i < iters/2; ++i) {\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n+        secp256k1_ecmult(&data->output[i], &data->pubkeys_gej[(data->offset1+i) % POINTS], &data->scalars[(data->offset2+i) % POINTS], &data->scalars[(data->offset1+i) % POINTS]);\n     }\n }\n \n@@ -207,7 +207,7 @@ static void bench_ecmult_multi(void* arg, int iters) {\n     iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_ecmult_multi_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -266,7 +266,7 @@ static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_\n             secp256k1_scalar_add(&total, &total, &tmp);\n         }\n         secp256k1_scalar_negate(&total, &total);\n-        secp256k1_ecmult(&data->ctx->ecmult_ctx, &data->expected_output[iter], NULL, &zero, &total);\n+        secp256k1_ecmult(&data->expected_output[iter], NULL, &zero, &total);\n     }\n \n     /* Run the benchmark. */"
      },
      {
        "sha": "de1d97961afbecbae33e0bf2d6826bd75f424a27",
        "filename": "src/secp256k1/src/bench_ellsq.c",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/bench_ellsq.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/bench_ellsq.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ellsq.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1,70 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#include <string.h>\n+\n+#include \"../include/secp256k1.h\"\n+#include \"../include/secp256k1_ellsq.h\"\n+#include \"util.h\"\n+#include \"bench.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey point;\n+    unsigned char rnd64[64];\n+} bench_ellsq_data;\n+\n+static void bench_ellsq_setup(void* arg) {\n+    bench_ellsq_data *data = (bench_ellsq_data*)arg;\n+    const unsigned char point[] = {\n+        0x03,\n+        0x54, 0x94, 0xc1, 0x5d, 0x32, 0x09, 0x97, 0x06,\n+        0xc2, 0x37, 0x5f, 0x94, 0x34, 0x87, 0x45, 0xfd,\n+        0x75, 0x7c, 0xe3, 0x0e, 0x4e, 0x8c, 0x90, 0xfb,\n+        0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n+    };\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->point, point, sizeof(point)) == 1);\n+}\n+\n+static void bench_ellsq_encode(void* arg, int iters) {\n+    int i;\n+    bench_ellsq_data *data = (bench_ellsq_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        data->rnd64[29] ^= 145;\n+        CHECK(secp256k1_ellsq_encode(data->ctx, data->rnd64, data->rnd64 + 16, &data->point) == 1);\n+    }\n+}\n+\n+static void bench_ellsq_decode(void* arg, int iters) {\n+    int i;\n+    secp256k1_pubkey out;\n+    bench_ellsq_data *data = (bench_ellsq_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        data->rnd64[13] ^= 247;\n+        data->rnd64[47] ^= 113;\n+        CHECK(secp256k1_ellsq_decode(data->ctx, &out, data->rnd64) == 1);\n+        memcpy(data->rnd64, &out.data, 64);\n+    }\n+}\n+\n+int main(void) {\n+    bench_ellsq_data data;\n+\n+    int iters = get_iters(10000);\n+\n+    /* create a context with no capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n+    memset(data.rnd64, 11, sizeof(data.rnd64));\n+\n+    run_benchmark(\"ellsq_encode\", bench_ellsq_encode, bench_ellsq_setup, NULL, &data, 10, iters);\n+    run_benchmark(\"ellsq_decode\", bench_ellsq_decode, bench_ellsq_setup, NULL, &data, 10, iters);\n+\n+    secp256k1_context_destroy(data.ctx);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "075ce456fc4f263aaffc2e669ab04c8cf919e519",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -209,6 +209,17 @@ void bench_field_sqrt(void* arg, int iters) {\n     CHECK(j <= iters);\n }\n \n+void bench_field_jacobi_var(void* arg, int iters) {\n+    int i, j = 0;\n+    bench_inv *data = (bench_inv*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_fe_jacobi_var(&data->fe[0]);\n+        secp256k1_fe_add(&data->fe[0], &data->fe[1]);\n+    }\n+    CHECK(j <= iters);\n+}\n+\n void bench_group_double_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n@@ -358,6 +369,7 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"field_jacobi_var\", bench_field_jacobi_var, bench_setup, NULL, &data, 10, iters);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);"
      },
      {
        "sha": "4441b08398499ba58c729334d1436764f2c71a1a",
        "filename": "src/secp256k1/src/ecdsa.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -15,7 +15,7 @@\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *r, secp256k1_scalar *s, const unsigned char *sig, size_t size);\n static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const secp256k1_scalar *r, const secp256k1_scalar *s);\n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar* r, const secp256k1_scalar* s, const secp256k1_ge *pubkey, const secp256k1_scalar *message);\n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar* r, secp256k1_scalar* s, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid);\n \n #endif /* SECP256K1_ECDSA_H */"
      },
      {
        "sha": "f1bce6fc6fb229a46a765211ac7813f8bb792fa8",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -204,7 +204,7 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n+static int secp256k1_ecdsa_sig_verify(const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n #if !defined(EXHAUSTIVE_TEST_ORDER)\n@@ -221,7 +221,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     secp256k1_scalar_mul(&u1, &sn, message);\n     secp256k1_scalar_mul(&u2, &sn, sigr);\n     secp256k1_gej_set_ge(&pubkeyj, pubkey);\n-    secp256k1_ecmult(ctx, &pr, &pubkeyj, &u2, &u1);\n+    secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }"
      },
      {
        "sha": "d54d44c997b6ab90782ad176517999d369be0038",
        "filename": "src/secp256k1/src/eckey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -18,8 +18,8 @@ static int secp256k1_eckey_pubkey_parse(secp256k1_ge *elem, const unsigned char\n static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *pub, size_t *size, int compressed);\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak);\n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp256k1_scalar *tweak);\n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak);\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak);\n \n #endif /* SECP256K1_ECKEY_H */"
      },
      {
        "sha": "e0506d3e2b7e05f6adb0654b0971d8f5a29a3fa4",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -57,12 +57,12 @@ static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp25\n     return !secp256k1_scalar_is_zero(key);\n }\n \n-static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_add(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_gej pt;\n     secp256k1_scalar one;\n     secp256k1_gej_set_ge(&pt, key);\n     secp256k1_scalar_set_int(&one, 1);\n-    secp256k1_ecmult(ctx, &pt, &pt, &one, tweak);\n+    secp256k1_ecmult(&pt, &pt, &one, tweak);\n \n     if (secp256k1_gej_is_infinity(&pt)) {\n         return 0;\n@@ -79,7 +79,7 @@ static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp25\n     return ret;\n }\n \n-static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n+static int secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge *key, const secp256k1_scalar *tweak) {\n     secp256k1_scalar zero;\n     secp256k1_gej pt;\n     if (secp256k1_scalar_is_zero(tweak)) {\n@@ -88,7 +88,7 @@ static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx,\n \n     secp256k1_scalar_set_int(&zero, 0);\n     secp256k1_gej_set_ge(&pt, key);\n-    secp256k1_ecmult(ctx, &pt, &pt, tweak, &zero);\n+    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n     secp256k1_ge_set_gej(key, &pt);\n     return 1;\n }"
      },
      {
        "sha": "b47d8f494a8034c4bd01baae4f3b183af8877fcb",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 19,
        "deletions": 13,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -11,20 +11,26 @@\n #include \"scalar.h\"\n #include \"scratch.h\"\n \n-typedef struct {\n-    /* For accelerating the computation of a*P + b*G: */\n-    secp256k1_ge_storage (*pre_g)[];    /* odd multiples of the generator */\n-    secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n-} secp256k1_ecmult_context;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n+#endif\n+\n+/** The number of entries a table with precomputed multiples needs to have. */\n+#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))\n \n /** Double multiply: R = na*A + ng*G */\n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n \n@@ -39,6 +45,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "87ccc733d584882fd1abafa188d69212f872027c",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 29,
        "deletions": 256,
        "changes": 285,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -14,20 +14,18 @@\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n+#include \"ecmult_static_pre_g.h\"\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n /* We need to lower these values for exhaustive tests because\n  * the tables cannot have infinities in them (this breaks the\n  * affine-isomorphism stuff which tracks z-ratios) */\n #  if EXHAUSTIVE_TEST_ORDER > 128\n #    define WINDOW_A 5\n-#    define WINDOW_G 8\n #  elif EXHAUSTIVE_TEST_ORDER > 8\n #    define WINDOW_A 4\n-#    define WINDOW_G 4\n #  else\n #    define WINDOW_A 2\n-#    define WINDOW_G 2\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n@@ -41,31 +39,12 @@\n  *  Two tables of this size are used (due to the endomorphism\n  *  optimization).\n  */\n-#  define WINDOW_G ECMULT_WINDOW_SIZE\n-#endif\n-\n-/* Noone will ever need more than a window size of 24. The code might\n- * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n- * not tested.\n- *\n- * The following limitations are known, and there are probably more:\n- * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n- * because the size of the memory object that we allocate (in bytes)\n- * will not fit in a size_t.\n- * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n- * because certain expressions will overflow.\n- */\n-#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n-#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #define WNAF_BITS 128\n #define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n #define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n \n-/** The number of entries a table with precomputed multiples needs to have. */\n-#define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n-\n /* The number of objects allocated on the scratch space for ecmult_multi algorithms */\n #define PIPPENGER_SCRATCH_OBJECTS 6\n #define STRAUSS_SCRATCH_OBJECTS 6\n@@ -119,18 +98,12 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n \n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n- *  There are two versions of this function:\n- *  - secp256k1_ecmult_odd_multiples_table_globalz_windowa which brings its\n- *    resulting point set to a single constant Z denominator, stores the X and Y\n- *    coordinates as ge_storage points in pre, and stores the global Z in rz.\n- *    It only operates on tables sized for WINDOW_A wnaf multiples.\n- *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n- *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size.\n+ *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n+ *  coordinates as ge_storage points in pre, and stores the global Z in rz.\n+ *  It only operates on tables sized for WINDOW_A wnaf multiples.\n  *\n- *  To compute a*P + b*G, we compute a table for P using the first function,\n- *  and for G using the second (which requires an inverse, but it only needs to\n- *  happen once).\n+ *  To compute a*P + b*G, we compute a table for P using this function,\n+ *  and use the precomputed table in <ecmult_static_pre_g.h> for G.\n  */\n static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -142,137 +115,6 @@ static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *p\n     secp256k1_ge_globalz_set_table_gej(ECMULT_TABLE_SIZE(WINDOW_A), pre, globalz, prej, zr);\n }\n \n-static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp256k1_ge_storage *pre, const secp256k1_gej *a) {\n-    secp256k1_gej d;\n-    secp256k1_ge d_ge, p_ge;\n-    secp256k1_gej pj;\n-    secp256k1_fe zi;\n-    secp256k1_fe zr;\n-    secp256k1_fe dx_over_dz_squared;\n-    int i;\n-\n-    VERIFY_CHECK(!a->infinity);\n-\n-    secp256k1_gej_double_var(&d, a, NULL);\n-\n-    /* First, we perform all the additions in an isomorphic curve obtained by multiplying\n-     * all `z` coordinates by 1/`d.z`. In these coordinates `d` is affine so we can use\n-     * `secp256k1_gej_add_ge_var` to perform the additions. For each addition, we store\n-     * the resulting y-coordinate and the z-ratio, since we only have enough memory to\n-     * store two field elements. These are sufficient to efficiently undo the isomorphism\n-     * and recompute all the `x`s.\n-     */\n-    d_ge.x = d.x;\n-    d_ge.y = d.y;\n-    d_ge.infinity = 0;\n-\n-    secp256k1_ge_set_gej_zinv(&p_ge, a, &d.z);\n-    pj.x = p_ge.x;\n-    pj.y = p_ge.y;\n-    pj.z = a->z;\n-    pj.infinity = 0;\n-\n-    for (i = 0; i < (n - 1); i++) {\n-        secp256k1_fe_normalize_var(&pj.y);\n-        secp256k1_fe_to_storage(&pre[i].y, &pj.y);\n-        secp256k1_gej_add_ge_var(&pj, &pj, &d_ge, &zr);\n-        secp256k1_fe_normalize_var(&zr);\n-        secp256k1_fe_to_storage(&pre[i].x, &zr);\n-    }\n-\n-    /* Invert d.z in the same batch, preserving pj.z so we can extract 1/d.z */\n-    secp256k1_fe_mul(&zi, &pj.z, &d.z);\n-    secp256k1_fe_inv_var(&zi, &zi);\n-\n-    /* Directly set `pre[n - 1]` to `pj`, saving the inverted z-coordinate so\n-     * that we can combine it with the saved z-ratios to compute the other zs\n-     * without any more inversions. */\n-    secp256k1_ge_set_gej_zinv(&p_ge, &pj, &zi);\n-    secp256k1_ge_to_storage(&pre[n - 1], &p_ge);\n-\n-    /* Compute the actual x-coordinate of D, which will be needed below. */\n-    secp256k1_fe_mul(&d.z, &zi, &pj.z);  /* d.z = 1/d.z */\n-    secp256k1_fe_sqr(&dx_over_dz_squared, &d.z);\n-    secp256k1_fe_mul(&dx_over_dz_squared, &dx_over_dz_squared, &d.x);\n-\n-    /* Going into the second loop, we have set `pre[n-1]` to its final affine\n-     * form, but still need to set `pre[i]` for `i` in 0 through `n-2`. We\n-     * have `zi = (p.z * d.z)^-1`, where\n-     *\n-     *     `p.z` is the z-coordinate of the point on the isomorphic curve\n-     *           which was ultimately assigned to `pre[n-1]`.\n-     *     `d.z` is the multiplier that must be applied to all z-coordinates\n-     *           to move from our isomorphic curve back to secp256k1; so the\n-     *           product `p.z * d.z` is the z-coordinate of the secp256k1\n-     *           point assigned to `pre[n-1]`.\n-     *\n-     * All subsequent inverse-z-coordinates can be obtained by multiplying this\n-     * factor by successive z-ratios, which is much more efficient than directly\n-     * computing each one.\n-     *\n-     * Importantly, these inverse-zs will be coordinates of points on secp256k1,\n-     * while our other stored values come from computations on the isomorphic\n-     * curve. So in the below loop, we will take care not to actually use `zi`\n-     * or any derived values until we're back on secp256k1.\n-     */\n-    i = n - 1;\n-    while (i > 0) {\n-        secp256k1_fe zi2, zi3;\n-        const secp256k1_fe *rzr;\n-        i--;\n-\n-        secp256k1_ge_from_storage(&p_ge, &pre[i]);\n-\n-        /* For each remaining point, we extract the z-ratio from the stored\n-         * x-coordinate, compute its z^-1 from that, and compute the full\n-         * point from that. */\n-        rzr = &p_ge.x;\n-        secp256k1_fe_mul(&zi, &zi, rzr);\n-        secp256k1_fe_sqr(&zi2, &zi);\n-        secp256k1_fe_mul(&zi3, &zi2, &zi);\n-        /* To compute the actual x-coordinate, we use the stored z ratio and\n-         * y-coordinate, which we obtained from `secp256k1_gej_add_ge_var`\n-         * in the loop above, as well as the inverse of the square of its\n-         * z-coordinate. We store the latter in the `zi2` variable, which is\n-         * computed iteratively starting from the overall Z inverse then\n-         * multiplying by each z-ratio in turn.\n-         *\n-         * Denoting the z-ratio as `rzr`, we observe that it is equal to `h`\n-         * from the inside of the above `gej_add_ge_var` call. This satisfies\n-         *\n-         *    rzr = d_x * z^2 - x * d_z^2\n-         *\n-         * where (`d_x`, `d_z`) are Jacobian coordinates of `D` and `(x, z)`\n-         * are Jacobian coordinates of our desired point -- except both are on\n-         * the isomorphic curve that we were using when we called `gej_add_ge_var`.\n-         * To get back to secp256k1, we must multiply both `z`s by `d_z`, or\n-         * equivalently divide both `x`s by `d_z^2`. Our equation then becomes\n-         *\n-         *    rzr = d_x * z^2 / d_z^2 - x\n-         *\n-         * (The left-hand-side, being a ratio of z-coordinates, is unaffected\n-         * by the isomorphism.)\n-         *\n-         * Rearranging to solve for `x`, we have\n-         *\n-         *     x = d_x * z^2 / d_z^2 - rzr\n-         *\n-         * But what we actually want is the affine coordinate `X = x/z^2`,\n-         * which will satisfy\n-         *\n-         *     X = d_x / d_z^2 - rzr / z^2\n-         *       = dx_over_dz_squared - rzr * zi2\n-         */\n-        secp256k1_fe_mul(&p_ge.x, rzr, &zi2);\n-        secp256k1_fe_negate(&p_ge.x, &p_ge.x, 1);\n-        secp256k1_fe_add(&p_ge.x, &dx_over_dz_squared);\n-        /* y is stored_y/z^3, as we expect */\n-        secp256k1_fe_mul(&p_ge.y, &p_ge.y, &zi3);\n-        /* Store */\n-        secp256k1_ge_to_storage(&pre[i], &p_ge);\n-    }\n-}\n-\n /** The following two macro retrieves a particular odd multiple from a table\n  *  of precomputed multiples. */\n #define ECMULT_TABLE_GET_GE(r,pre,n,w) do { \\\n@@ -299,74 +141,6 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n-static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n-    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-    ;\n-\n-static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n-    ctx->pre_g = NULL;\n-    ctx->pre_g_128 = NULL;\n-}\n-\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n-    secp256k1_gej gj;\n-    void* const base = *prealloc;\n-    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-\n-    if (ctx->pre_g != NULL) {\n-        return;\n-    }\n-\n-    /* get the generator */\n-    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n-\n-    {\n-        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-    }\n-\n-    /* precompute the tables with odd multiples */\n-    secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n-\n-    {\n-        secp256k1_gej g_128j;\n-        int i;\n-\n-        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n-        /* check for overflow */\n-        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n-\n-        /* calculate 2^128*generator */\n-        g_128j = gj;\n-        for (i = 0; i < 128; i++) {\n-            secp256k1_gej_double_var(&g_128j, &g_128j, NULL);\n-        }\n-        secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n-    }\n-}\n-\n-static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n-    if (src->pre_g != NULL) {\n-        /* We cast to void* first to suppress a -Wcast-align warning. */\n-        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n-    }\n-    if (src->pre_g_128 != NULL) {\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n-    }\n-}\n-\n-static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx) {\n-    return ctx->pre_g != NULL;\n-}\n-\n-static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    secp256k1_ecmult_context_init(ctx);\n-}\n-\n /** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n  *  with the following guarantees:\n  *  - each wnaf[i] is either 0, or an odd integer between -(1<<(w-1) - 1) and (1<<(w-1) - 1)\n@@ -443,7 +217,7 @@ struct secp256k1_strauss_state {\n     struct secp256k1_strauss_point_state* ps;\n };\n \n-static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult_strauss_wnaf(const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n     /* Splitted G factors. */\n@@ -544,11 +318,11 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             }\n         }\n         if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n         if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n+            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, secp256k1_pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n     }\n@@ -558,7 +332,7 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n     }\n }\n \n-static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n@@ -571,15 +345,15 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     state.pre_a = pre_a;\n     state.pre_a_lam = pre_a_lam;\n     state.ps = ps;\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, 1, a, na, ng);\n }\n \n static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n@@ -612,14 +386,14 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n-    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    secp256k1_ecmult_strauss_wnaf(&state, r, n_points, points, scalars, inp_g_sc);\n     secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n@@ -866,7 +640,7 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n@@ -881,7 +655,6 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n     int i, j;\n     int bucket_window;\n \n-    (void)ctx;\n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n@@ -941,8 +714,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n@@ -986,7 +759,7 @@ static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_cal\n \n /* Computes ecmult_multi by simply multiplying and adding each point. Does not\n  * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n+static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n     size_t point_idx;\n     secp256k1_scalar szero;\n     secp256k1_gej tmpj;\n@@ -995,7 +768,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n     secp256k1_gej_set_infinity(r);\n     secp256k1_gej_set_infinity(&tmpj);\n     /* r = inp_g_sc*G */\n-    secp256k1_ecmult(ctx, r, &tmpj, &szero, inp_g_sc);\n+    secp256k1_ecmult(r, &tmpj, &szero, inp_g_sc);\n     for (point_idx = 0; point_idx < n_points; point_idx++) {\n         secp256k1_ge point;\n         secp256k1_gej pointj;\n@@ -1005,7 +778,7 @@ static int secp256k1_ecmult_multi_simple_var(const secp256k1_ecmult_context *ctx\n         }\n         /* r += scalar*point */\n         secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(ctx, &tmpj, &pointj, &scalar, NULL);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n     return 1;\n@@ -1031,11 +804,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1045,33 +818,33 @@ static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback,\n     } else if (n == 0) {\n         secp256k1_scalar szero;\n         secp256k1_scalar_set_int(&szero, 0);\n-        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        secp256k1_ecmult(r, r, &szero, inp_g_sc);\n         return 1;\n     }\n     if (scratch == NULL) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n \n     /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n      * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n      * As a first step check if there's enough space for Pippenger's algo (which requires less space\n      * than Strauss' algo) and if not, use the simple algorithm. */\n     if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n-        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+        return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n         if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n-            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n+            return secp256k1_ecmult_multi_simple_var(r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "9072fb268860c959bbde3b0074d6451e39db7445",
        "filename": "src/secp256k1/src/ecmult_static_pre_g.h",
        "status": "added",
        "additions": 16611,
        "deletions": 0,
        "changes": 16611,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecmult_static_pre_g.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/ecmult_static_pre_g.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_static_pre_g.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c"
      },
      {
        "sha": "6fa16f6c3df3d909c2da01ef75b08aa970d1390a",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -122,4 +122,7 @@ static void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_f\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag);\n \n+/** Compute the Jacobi symbol of a / p. 0 if a=0; 1 if a square; -1 if a non-square. */\n+static int secp256k1_fe_jacobi_var(const secp256k1_fe *a);\n+\n #endif /* SECP256K1_FIELD_H */"
      },
      {
        "sha": "4d95f18efe59167c8b23c183b24b59d592656b89",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -1253,4 +1253,25 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n     VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\n }\n \n+static int secp256k1_fe_jacobi_var(const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv32_signed30 s;\n+    int ret;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    /* secp256k1_jacobi32_maybe_var cannot deal with input=0; handle it specially. */\n+    if (secp256k1_fe_is_zero(&tmp)) return 0;\n+    secp256k1_fe_to_signed30(&s, &tmp);\n+    ret = secp256k1_jacobi32_maybe_var(&s, &secp256k1_const_modinfo_fe);\n+    if (ret == 0) {\n+        /* secp256k1_jacobi32_maybe_var failed to compute the Jacobi symbol. Fall back\n+         * to computing a square root. This should be extremely rare with random\n+         * input. */\n+        secp256k1_fe dummy;\n+        ret = 2*secp256k1_fe_sqrt(&dummy, &tmp) - 1;\n+    }\n+    return ret;\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "320dc8f4a0430ac156804af4d337165ae73dacb8",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -575,4 +575,25 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\n #endif\n }\n \n+static int secp256k1_fe_jacobi_var(const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+    int ret;\n+\n+    tmp = *x;\n+    secp256k1_fe_normalize_var(&tmp);\n+    /* secp256k1_jacobi64_maybe_var cannot deal with input=0; handle it specially. */\n+    if (secp256k1_fe_is_zero(&tmp)) return 0;\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    ret = secp256k1_jacobi64_maybe_var(&s, &secp256k1_const_modinfo_fe);\n+    if (ret == 0) {\n+        /* secp256k1_jacobi64_maybe_var failed to compute the Jacobi symbol. Fall back\n+         * to computing a square root. This should be extremely rare with random\n+         * input. */\n+        secp256k1_fe dummy;\n+        ret = 2*secp256k1_fe_sqrt(&dummy, &tmp) - 1;\n+    }\n+    return ret;\n+}\n+\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */"
      },
      {
        "sha": "af40d13f9c6a1dd76cf0a249a7ab4f82e75e45f6",
        "filename": "src/secp256k1/src/gen_ecmult_static_pre_g.c",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/gen_ecmult_static_pre_g.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/gen_ecmult_static_pre_g.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_ecmult_static_pre_g.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1,137 @@\n+/*****************************************************************************************************\n+ * Copyright (c) 2013, 2014, 2017, 2021 Pieter Wuille, Andrew Poelstra, Jonas Nick, Russell O'Connor *\n+ * Distributed under the MIT software license, see the accompanying                                  *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.                              *\n+ *****************************************************************************************************/\n+\n+#include <inttypes.h>\n+#include <stdio.h>\n+\n+/* Autotools creates libsecp256k1-config.h, of which ECMULT_WINDOW_SIZE is needed.\n+   ifndef guard so downstream users can define their own if they do not use autotools. */\n+#if !defined(ECMULT_WINDOW_SIZE)\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+/* In principle we could use ASM, but this yields only a minor speedup in\n+   build time and it's very complicated. In particular when cross-compiling, we'd\n+   need to build the ASM for the build and the host machine. */\n+#undef USE_EXTERNAL_ASM\n+#undef USE_ASM_X86_64\n+\n+#include \"../include/secp256k1.h\"\n+#include \"assumptions.h\"\n+#include \"util.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"ecmult.h\"\n+\n+void print_table(FILE *fp, const char *name, int window_g, const secp256k1_gej *gen, int with_conditionals) {\n+    static secp256k1_gej gj;\n+    static secp256k1_ge ge, dgen;\n+    static secp256k1_ge_storage ges;\n+    int j;\n+    int i;\n+\n+    gj = *gen;\n+    secp256k1_ge_set_gej_var(&ge, &gj);\n+    secp256k1_ge_to_storage(&ges, &ge);\n+\n+    fprintf(fp, \"static const secp256k1_ge_storage %s[ECMULT_TABLE_SIZE(WINDOW_G)] = {\\n\", name);\n+    fprintf(fp, \" S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                  \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                SECP256K1_GE_STORAGE_CONST_GET(ges));\n+\n+    secp256k1_gej_double_var(&gj, gen, NULL);\n+    secp256k1_ge_set_gej_var(&dgen, &gj);\n+\n+    j = 1;\n+    for(i = 3; i <= window_g; ++i) {\n+        if (with_conditionals) {\n+            fprintf(fp, \"#if ECMULT_TABLE_SIZE(WINDOW_G) > %ld\\n\", ECMULT_TABLE_SIZE(i-1));\n+        }\n+        for(;j < ECMULT_TABLE_SIZE(i); ++j) {\n+            secp256k1_gej_set_ge(&gj, &ge);\n+            secp256k1_gej_add_ge_var(&gj, &gj, &dgen, NULL);\n+            secp256k1_ge_set_gej_var(&ge, &gj);\n+            secp256k1_ge_to_storage(&ges, &ge);\n+\n+            fprintf(fp, \",S(%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\n+                          \",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\",%\"PRIx32\")\\n\",\n+                        SECP256K1_GE_STORAGE_CONST_GET(ges));\n+        }\n+        if (with_conditionals) {\n+            fprintf(fp, \"#endif\\n\");\n+        }\n+    }\n+    fprintf(fp, \"};\\n\");\n+}\n+\n+void print_two_tables(FILE *fp, int window_g, const secp256k1_ge *g, int with_conditionals) {\n+    secp256k1_gej gj;\n+    int i;\n+\n+    secp256k1_gej_set_ge(&gj, g);\n+    print_table(fp, \"secp256k1_pre_g\", window_g, &gj, with_conditionals);\n+    for (i = 0; i < 128; ++i) {\n+        secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    print_table(fp, \"secp256k1_pre_g_128\", window_g, &gj, with_conditionals);\n+}\n+\n+int main(void) {\n+    const secp256k1_ge g = SECP256K1_G;\n+    const secp256k1_ge g_13 = SECP256K1_G_ORDER_13;\n+    const secp256k1_ge g_199 = SECP256K1_G_ORDER_199;\n+    const int window_g_13 = 4;\n+    const int window_g_199 = 8;\n+    FILE* fp;\n+\n+    fp = fopen(\"src/ecmult_static_pre_g.h\",\"w\");\n+    if (fp == NULL) {\n+        fprintf(stderr, \"Could not open src/ecmult_static_pre_g.h for writing!\\n\");\n+        return -1;\n+    }\n+\n+    fprintf(fp, \"/* This file was automatically generated by gen_ecmult_static_pre_g. */\\n\");\n+    fprintf(fp, \"/* This file contains an array secp256k1_pre_g with odd multiples of the base point G and\\n\");\n+    fprintf(fp, \" * an array secp256k1_pre_g_128 with odd multiples of 2^128*G for accelerating the computation of a*P + b*G.\\n\");\n+    fprintf(fp, \" */\\n\");\n+    fprintf(fp, \"#ifndef SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#define SECP256K1_ECMULT_STATIC_PRE_G_H\\n\");\n+    fprintf(fp, \"#include \\\"group.h\\\"\\n\");\n+    fprintf(fp, \"#ifdef S\\n\");\n+    fprintf(fp, \"   #error macro identifier S already in use.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#define S(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \"\n+                \"SECP256K1_GE_STORAGE_CONST(0x##a##u,0x##b##u,0x##c##u,0x##d##u,0x##e##u,0x##f##u,0x##g##u,\"\n+                \"0x##h##u,0x##i##u,0x##j##u,0x##k##u,0x##l##u,0x##m##u,0x##n##u,0x##o##u,0x##p##u)\\n\");\n+    fprintf(fp, \"#if ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE) > %ld\\n\", ECMULT_TABLE_SIZE(ECMULT_WINDOW_SIZE));\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_WINDOW_SIZE. Try deleting ecmult_static_pre_g.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#if defined(EXHAUSTIVE_TEST_ORDER)\\n\");\n+    fprintf(fp, \"#if EXHAUSTIVE_TEST_ORDER == 13\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_13);\n+\n+    print_two_tables(fp, window_g_13, &g_13, 0);\n+\n+    fprintf(fp, \"#elif EXHAUSTIVE_TEST_ORDER == 199\\n\");\n+    fprintf(fp, \"#define WINDOW_G %d\\n\", window_g_199);\n+\n+    print_two_tables(fp, window_g_199, &g_199, 0);\n+\n+    fprintf(fp, \"#else\\n\");\n+    fprintf(fp, \"   #error No known generator for the specified exhaustive test group order.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#else /* !defined(EXHAUSTIVE_TEST_ORDER) */\\n\");\n+    fprintf(fp, \"#define WINDOW_G ECMULT_WINDOW_SIZE\\n\");\n+\n+    print_two_tables(fp, ECMULT_WINDOW_SIZE, &g, 1);\n+\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"#undef S\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fclose(fp);\n+\n+    return 0;\n+}"
      },
      {
        "sha": "6fc58ea01599acdccf3ced5be62cc19030a861fa",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -10,6 +10,27 @@\n #include \"field.h\"\n #include \"group.h\"\n \n+#define SECP256K1_G_ORDER_13 SECP256K1_GE_CONST(\\\n+    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\\\n+    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\\\n+    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\\\n+    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\\\n+)\n+#define SECP256K1_G_ORDER_199 SECP256K1_GE_CONST(\\\n+    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\\\n+    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\\\n+    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\\\n+    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\\\n+)\n+/** Generator for secp256k1, value 'g' defined in\n+ *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n+ */\n+#define SECP256K1_G SECP256K1_GE_CONST(\\\n+    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\\\n+    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\\\n+    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\\\n+    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\\\n+)\n /* These exhaustive group test orders and generators are chosen such that:\n  * - The field size is equal to that of secp256k1, so field code is the same.\n  * - The curve equation is of the form y^2=x^3+B for some constant B.\n@@ -21,23 +42,15 @@\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n #  if EXHAUSTIVE_TEST_ORDER == 13\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\n-    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\n-    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\n-    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_13;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x3d3486b2, 0x159a9ca5, 0xc75638be, 0xb23a69bc,\n     0x946a45ab, 0x24801247, 0xb4ed2b8e, 0x26b6a417\n );\n #  elif EXHAUSTIVE_TEST_ORDER == 199\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\n-    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\n-    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\n-    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G_ORDER_199;\n+\n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n     0x2cca28fa, 0xfc614b80, 0x2a3db42b, 0x00ba00b1,\n     0xbea8d943, 0xdace9ab2, 0x9536daea, 0x0074defb\n@@ -46,15 +59,7 @@ static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n #else\n-/** Generator for secp256k1, value 'g' defined in\n- *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n- */\n-static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0x79BE667EUL, 0xF9DCBBACUL, 0x55A06295UL, 0xCE870B07UL,\n-    0x029BFCDBUL, 0x2DCE28D9UL, 0x59F2815BUL, 0x16F81798UL,\n-    0x483ADA77UL, 0x26A3C465UL, 0x5DA4FBFCUL, 0x0E1108A8UL,\n-    0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n-);\n+static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_G;\n \n static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 7);\n #endif"
      },
      {
        "sha": "fbeca01a358f605987a046bdf749ddc09a67eb44",
        "filename": "src/secp256k1/src/modinv32.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv32.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -39,4 +39,7 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\n /* Same as secp256k1_modinv32_var, but constant time in x (not in the modulus). */\n static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n \n+/* Compute the Jacobi symbol for x (where gcd(x,p) == 1), 0 if it cannot be determined. */\n+static int secp256k1_jacobi32_maybe_var(const secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\n+\n #endif /* SECP256K1_MODINV32_H */"
      },
      {
        "sha": "47c774fa4c11049f7d7b2146152bf721e75501ba",
        "filename": "src/secp256k1/src/modinv32_impl.h",
        "status": "modified",
        "additions": 152,
        "deletions": 16,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv32_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -232,6 +232,21 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t zeta, uint32_t f0, uint32_\n     return zeta;\n }\n \n+/* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+static const uint8_t secp256k1_modinv32_inv256[128] = {\n+    0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+    0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+    0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+    0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+    0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+    0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+    0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+    0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+    0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+    0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+    0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+};\n+\n /* Compute the transition matrix and eta for 30 divsteps (variable time).\n  *\n  * Input:  eta: initial eta\n@@ -243,21 +258,6 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t zeta, uint32_t f0, uint32_\n  * Implements the divsteps_n_matrix_var function from the explanation.\n  */\n static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\n-    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n-    static const uint8_t inv256[128] = {\n-        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n-        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n-        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n-        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n-        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n-        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n-        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n-        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n-        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n-        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n-        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n-    };\n-\n     /* Transformation matrix; see comments in secp256k1_modinv32_divsteps_30. */\n     uint32_t u = 1, v = 0, q = 0, r = 1;\n     uint32_t f = f0, g = g0, m;\n@@ -297,7 +297,7 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\n         VERIFY_CHECK(limit > 0 && limit <= 30);\n         m = (UINT32_MAX >> (32 - limit)) & 255U;\n         /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n-        w = (g * inv256[(f >> 1) & 127]) & m;\n+        w = (g * secp256k1_modinv32_inv256[(f >> 1) & 127]) & m;\n         /* Do so. */\n         g += f * w;\n         q += u * w;\n@@ -317,6 +317,83 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\n     return eta;\n }\n \n+/* Compute the transition matrix and eta for 30 posdivsteps (variable time, eta=-delta), and keeps track\n+ * of the Jacobi symbol along the way. f0 and g0 must be f and g mod 2^32 rather than 2^30, because\n+ * Jacobi tracking requires knowing (f mod 8) rather than just (f mod 2).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ */\n+static int32_t secp256k1_modinv32_posdivsteps_30_var(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t, int *jacp) {\n+    /* Transformation matrix. */\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m;\n+    uint16_t w;\n+    int i = 30, limit, zeros;\n+    int jac = *jacp;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* Update the bottom bit of jac: when dividing g by an odd power of 2,\n+         * if (f mod 8) is 3 or 5, the Jacobi symbol changes sign. */\n+        jac ^= (zeros & ((f >> 1) ^ (f >> 2)));\n+        /* We're done once we've done 60 posdivsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint32_t tmp;\n+            eta = -eta;\n+            /* Update bottom bit of jac: when swapping f and g, the Jacobi symbol changes sign\n+             * if both f and g are 3 mod 4. */\n+            jac ^= ((f & g) >> 1);\n+            tmp = f; f = g; g = tmp;\n+            tmp = u; u = q; q = tmp;\n+            tmp = v; v = r; r = tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        VERIFY_CHECK(limit > 0 && limit <= 30);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * secp256k1_modinv32_inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int32_t)u;\n+    t->v = (int32_t)v;\n+    t->q = (int32_t)q;\n+    t->r = (int32_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2 or -2,\n+     * the aggregate of 30 of them will have determinant 2^30 or -2^30. */\n+    VERIFY_CHECK((int64_t)t->u * t->r - (int64_t)t->v * t->q == ((int64_t)1) << 30 ||\n+                 (int64_t)t->u * t->r - (int64_t)t->v * t->q == -(((int64_t)1) << 30));\n+    *jacp = jac;\n+    return eta;\n+}\n+\n /* Compute (t/2^30) * [d, e] mod modulus, where t is a transition matrix for 30 divsteps.\n  *\n  * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n@@ -584,4 +661,63 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\n     *x = d;\n }\n \n+/* Compute the Jacobi symbol of x modulo modinfo->modulus (variable time). gcd(x,modulus) must be 1. */\n+static int secp256k1_jacobi32_maybe_var(const secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo) {\n+    /* Start with f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv32_signed30 f = modinfo->modulus;\n+    secp256k1_modinv32_signed30 g = *x;\n+    int j, len = 9;\n+    int32_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int32_t cond, fn, gn;\n+    int jac = 0;\n+    int count;\n+\n+    /* Do up to 50 iterations of 30 posdivsteps (up to 1500 steps; more is extremely rare) each until f=1. */\n+    for (count = 0; count < 50; ++count) {\n+        /* Compute transition matrix and new eta after 30 posdivsteps. */\n+        secp256k1_modinv32_trans2x2 t;\n+        eta = secp256k1_modinv32_posdivsteps_30_var(eta, f.v[0] | ((uint32_t)f.v[1] << 30), g.v[0] | ((uint32_t)g.v[1] << 30), &t, &jac);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+        secp256k1_modinv32_update_fg_30_var(len, &f, &g, &t);\n+        /* If the bottom limb of f is 1, there is a chance that f=1. */\n+        if (f.v[0] == 1) {\n+            cond = 0;\n+            /* Check if the other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= f.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) return 1 - 2*(jac & 1);\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int32_t)len - 2) >> 31;\n+        cond |= fn;\n+        cond |= gn;\n+        /* If so, reduce length. */\n+        if (cond == 0) --len;\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+    }\n+\n+    /* While we don't want production code to assume that the loop above always reaches f=1,\n+     * it's a reasonable thing to check for in test code (as long as we don't have a way\n+     * for constructing known bad examples in the tests). */\n+    VERIFY_CHECK(0);\n+\n+    return 0;\n+}\n+\n #endif /* SECP256K1_MODINV32_IMPL_H */"
      },
      {
        "sha": "7c558f3e32ee1c3f35b0f46c4a9b351eddf682ec",
        "filename": "src/secp256k1/src/modinv64.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv64.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -43,4 +43,7 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\n /* Same as secp256k1_modinv64_var, but constant time in x (not in the modulus). */\n static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n \n+/* Compute the Jacobi symbol for x (where gcd(x,p) == 1), 0 if it cannot be determined. */\n+static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\n+\n #endif /* SECP256K1_MODINV64_H */"
      },
      {
        "sha": "e717e63295b3f55eabb61c1d307e458a569e5ce9",
        "filename": "src/secp256k1/src/modinv64_impl.h",
        "status": "modified",
        "additions": 147,
        "deletions": 0,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modinv64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modinv64_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -294,6 +294,94 @@ static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint\n     return eta;\n }\n \n+/* Compute the transition matrix and eta for 62 posdivsteps (variable time, eta=-delta), and keeps track\n+ * of the Jacobi symbol along the way. f0 and g0 must be f and g mod 2^64 rather than 2^62, because\n+ * Jacobi tracking requires knowing (f mod 8) rather than just (f mod 2).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ */\n+static int64_t secp256k1_modinv64_posdivsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t, int *jacp) {\n+    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */\n+    uint64_t u = 1, v = 0, q = 0, r = 1;\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+    int jac = *jacp;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* Update the bottom bit of jac: when dividing g by an odd power of 2,\n+         * if (f mod 8) is 3 or 5, the Jacobi symbol changes sign. */\n+        jac ^= (zeros & ((f >> 1) ^ (f >> 2)));\n+        /* We're done once we've done 60 posdivsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = tmp;\n+            tmp = u; u = q; q = tmp;\n+            tmp = v; v = r; r = tmp;\n+            /* Update bottom bit of jac: when swapping f and g, the Jacobi symbol changes sign\n+             * if both f and g are 3 mod 4. */\n+            jac ^= ((f & g) >> 1);\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;\n+        } else {\n+            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as\n+             * eta tends to be smaller here. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            VERIFY_CHECK(limit > 0 && limit <= 62);\n+            /* m is a mask for the bottom min(limit, 4) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 15U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 4)\n+             * bits. */\n+            w = f + (((f + 1) & 4) << 1);\n+            w = (-w * g) & m;\n+        }\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2 or -2,\n+     * the aggregate of 62 of them will have determinant 2^62 or -2^62. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 62 ||\n+                 (int128_t)t->u * t->r - (int128_t)t->v * t->q == -(((int128_t)1) << 62));\n+    *jacp = jac;\n+    return eta;\n+}\n+\n /* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix scaled by 2^62.\n  *\n  * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n@@ -590,4 +678,63 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\n     *x = d;\n }\n \n+/* Compute the Jacobi symbol of x modulo modinfo->modulus (variable time). gcd(x,modulus) must be 1. */\n+static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int j, len = 5;\n+    int64_t eta = -1; /* eta = -delta; delta is initially 1 */\n+    int64_t cond, fn, gn;\n+    int jac = 0;\n+    int count;\n+\n+    /* Do up to 25 iterations of 62 posdivsteps (up to 1550 steps; more is extremely rare) each until f=1. */\n+    for (count = 0; count < 25; ++count) {\n+        /* Compute transition matrix and new eta after 62 posdivsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_posdivsteps_62_var(eta, f.v[0] | ((uint64_t)f.v[1] << 62), g.v[0] | ((uint64_t)g.v[1] << 62), &t, &jac);\n+        /* Update f,g using that transition matrix. */\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+        secp256k1_modinv64_update_fg_62_var(len, &f, &g, &t);\n+        /* If the bottom limb of f is 1, there is a chance that f=1. */\n+        if (f.v[0] == 1) {\n+            cond = 0;\n+            /* Check if the other limbs are also 0. */\n+            for (j = 1; j < len; ++j) {\n+                cond |= f.v[j];\n+            }\n+            /* If so, we're done. */\n+            if (cond == 0) return 1 - 2*(jac & 1);\n+        }\n+\n+        /* Determine if len>1 and limb (len-1) of both f and g is 0. */\n+        fn = f.v[len - 1];\n+        gn = g.v[len - 1];\n+        cond = ((int64_t)len - 2) >> 63;\n+        cond |= fn;\n+        cond |= gn;\n+        /* If so, reduce length. */\n+        if (cond == 0) --len;\n+#ifdef VERIFY\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */\n+        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */\n+#endif\n+    }\n+\n+    /* While we don't want production code to assume that the loop above always reaches f=1,\n+     * it's a reasonable thing to check for in test code (as long as we don't have a way\n+     * for constructing known bad examples in the tests). */\n+    VERIFY_CHECK(0);\n+\n+    return 0;\n+}\n+\n #endif /* SECP256K1_MODINV64_IMPL_H */"
      },
      {
        "sha": "95baa686c277051fac1619e978adfecf67e0053b",
        "filename": "src/secp256k1/src/modules/ellsq/Makefile.am.include",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/ellsq/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/ellsq/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ellsq/Makefile.am.include?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1,8 @@\n+include_HEADERS += include/secp256k1_ellsq.h\n+noinst_HEADERS += src/modules/ellsq/main_impl.h\n+noinst_HEADERS += src/modules/ellsq/tests_impl.h\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_ellsq\n+bench_ellsq_SOURCES = src/bench_ellsq.c\n+bench_ellsq_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n+endif"
      },
      {
        "sha": "81b2b9c7745cc04d413adfdf1b721ca8e2fef80a",
        "filename": "src/secp256k1/src/modules/ellsq/main_impl.h",
        "status": "added",
        "additions": 305,
        "deletions": 0,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/ellsq/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/ellsq/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ellsq/main_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1,305 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuille                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_MAIN_H\n+#define SECP256K1_MODULE_ELLSQ_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_ellsq.h\"\n+#include \"../../hash.h\"\n+\n+/* c1 = the square root of -3 ((-3)**((p+1)/4)). */\n+static const secp256k1_fe secp256k1_ellsq_c1 = SECP256K1_FE_CONST(0x0a2d2ba9, 0x3507f1df, 0x233770c2, 0xa797962c, 0xc61f6d15, 0xda14ecd4, 0x7d8d27ae, 0x1cd5f852);\n+/* c2 = (c1-1)/2 (a cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c2 = SECP256K1_FE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40);\n+/* c3 = (-c1-1)/2 (another cube root of 1). */\n+static const secp256k1_fe secp256k1_ellsq_c3 = SECP256K1_FE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee);\n+/* c4 = 16*(c1-1) */\n+static const secp256k1_fe secp256k1_ellsq_c4 = SECP256K1_FE_CONST(0xa2d2ba93, 0x507f1df2, 0x33770c2a, 0x797962cc, 0x61f6d15d, 0xa14ecd47, 0xd8d27ae1, 0xcd5f8510);\n+/* c5 = 1/2 */\n+static const secp256k1_fe secp256k1_ellsq_c5 = SECP256K1_FE_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7ffffe18);\n+\n+/* Given a field element u, compute a group element out. This functions results in a\n+ * non-infinity point on the curve for every possible input u. It implements the function\n+ * f defined in secp256k1_ellsq.h.\n+ */\n+static void secp256k1_ellsq_fe_to_ge_var(secp256k1_ge* out, const secp256k1_fe* u) {\n+    secp256k1_fe t0, t1, t2, t3, t4, x, y;\n+    int ret;\n+    secp256k1_fe_sqr(&t0, u);\n+    secp256k1_fe_set_int(&t1, 8);\n+    secp256k1_fe_add(&t1, &t0);\n+    secp256k1_fe_mul(&t3, &t0, &secp256k1_ellsq_c1);\n+    secp256k1_fe_negate(&t3, &t3, 1);\n+    secp256k1_fe_mul(&t2, &t1, &secp256k1_ellsq_c2);\n+    secp256k1_fe_add(&t2, &t3);\n+    secp256k1_fe_sqr(&t4, &t1);\n+    secp256k1_fe_sqr(&t4, &t4);\n+    secp256k1_fe_mul_int(&t4, 7);\n+    secp256k1_fe_sqr(&t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t2);\n+    secp256k1_fe_mul(&t3, &t3, &t1);\n+    secp256k1_fe_add(&t3, &t4);\n+    if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+        ret = secp256k1_fe_sqrt(&t4, &t3);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_inv_var(&t1, &t1);\n+        secp256k1_fe_mul(&x, &t1, &t2);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul(&y, &t1, &t4);\n+    } else {\n+        secp256k1_fe_add(&t2, &t1);\n+        secp256k1_fe_negate(&t2, &t2, 5);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_add(&t3, &t4);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) {\n+            ret = secp256k1_fe_sqrt(&t4, &t3);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&x, &t1, &t2);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&y, &t1, &t4);\n+        } else {\n+            secp256k1_fe_mul_int(&t0, 3);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_sqr(&t1, &t1);\n+            secp256k1_fe_mul(&t0, &t0, &t1);\n+            secp256k1_fe_negate(&t0, &t0, 1);\n+            secp256k1_fe_set_int(&x, 1);\n+            secp256k1_fe_add(&x, &t0);\n+            secp256k1_fe_sqr(&t0, &x);\n+            secp256k1_fe_mul(&t0, &t0, &x);\n+            secp256k1_fe_set_int(&t1, 7);\n+            secp256k1_fe_add(&t1, &t0);\n+            ret = secp256k1_fe_sqrt(&y, &t1);\n+            VERIFY_CHECK(ret);\n+        }\n+    }\n+    t0 = *u;\n+    secp256k1_fe_normalize_var(&y);\n+    secp256k1_fe_normalize_var(&t0);\n+    if (secp256k1_fe_is_odd(&y) != secp256k1_fe_is_odd(&t0)) secp256k1_fe_negate(&y, &y, 1);\n+    secp256k1_ge_set_xy(out, &x, &y);\n+}\n+\n+/* Given a point on the curve p, and an integer branch value i in [0,4), compute a\n+ * field element out which secp256k1_ellsq_fe_to_ge_var would map back to p, or\n+ * fail. Combining all non-failing outs for a given p, over all values of i,\n+ * results in the set of all preimages of p under secp256k1_ellsq_fe_to_ge_var. No\n+ * two (p, i) inputs map to the same out, if successful.\n+ *\n+ * i=0 will compute a preimage that maps to p using the \"x1\" above.\n+ * i=1 will compute a preimage that maps to p using the \"x2\" above.\n+ * i=2 and i=3 will compute a preimage that maps to using the \"x3\" above.\n+ *\n+ * All of them will fail if no preimage under the respective x formula exists.\n+ * When i>0, the function will fail when the would-be preimage maps to the curve\n+ * using a lowered-numbered x (so i=1 fails when its x1 lands on the curve, and\n+ * i=2 and i=3 fail when its x1 or x2 land on the curve). In addition, failure is\n+ * returned when a lowered-value i would result in the same preimage.\n+ */\n+static int secp256k1_ellsq_ge_to_fe_var(secp256k1_fe* out, const secp256k1_ge* p, int i) {\n+    int ret;\n+    secp256k1_fe t0, t1, t2, t3, u, x = p->x, y = p->y;\n+    secp256k1_fe_normalize_var(&x);\n+    secp256k1_fe_normalize_var(&y);\n+    VERIFY_CHECK(i >= 0);\n+    VERIFY_CHECK(i < 4);\n+    if (i < 2) {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 2);\n+        secp256k1_fe_set_int(&t1, 1);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_negate(&t1, &t0, 3);\n+        secp256k1_fe_add(&t1, &secp256k1_ellsq_c1);\n+        secp256k1_fe_add(&t0, &secp256k1_ellsq_c1);\n+        secp256k1_fe_mul(&t2, &t0, &t1);\n+        secp256k1_fe_mul_int(&t2, 8);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        if (i == 0) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t0)) return 0;\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1) && secp256k1_fe_is_odd(&y)) return 0;\n+            ret = secp256k1_fe_sqrt(&t1, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t0, &t0);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        } else { /* i == 1 */\n+            secp256k1_fe_set_int(&t0, 1);\n+            secp256k1_fe_add(&t0, &x);\n+            secp256k1_fe_negate(&t0, &t0, 2);\n+            secp256k1_fe_sqr(&t3, &t0);\n+            secp256k1_fe_mul(&t0, &t0, &t3);\n+            secp256k1_fe_set_int(&t3, 7);\n+            secp256k1_fe_add(&t0, &t3);\n+            if (secp256k1_fe_jacobi_var(&t0) >= 0) return 0;\n+            ret = secp256k1_fe_sqrt(&t0, &t2);\n+            VERIFY_CHECK(ret);\n+            secp256k1_fe_inv_var(&t1, &t1);\n+            secp256k1_fe_mul(&u, &t0, &t1);\n+        }\n+    } else {\n+        t0 = x;\n+        secp256k1_fe_mul_int(&t0, 6);\n+        secp256k1_fe_set_int(&t1, 26);\n+        secp256k1_fe_add(&t0, &t1);\n+        secp256k1_fe_sqr(&t1, &t0);\n+        secp256k1_fe_set_int(&t2, 1024);\n+        secp256k1_fe_negate(&t2, &t2, 1);\n+        secp256k1_fe_add(&t2, &t1);\n+        if (secp256k1_fe_jacobi_var(&t2) < 0) return 0;\n+        ret = secp256k1_fe_sqrt(&t1, &t2);\n+        VERIFY_CHECK(ret);\n+        if (i == 3) {\n+            if (secp256k1_fe_normalizes_to_zero_var(&t1)) return 0;\n+            secp256k1_fe_negate(&t1, &t1, 1);\n+        }\n+        secp256k1_fe_negate(&t0, &t0, 7);\n+        secp256k1_fe_add(&t0, &t1);\n+        if (secp256k1_fe_jacobi_var(&t0) < 0) return 0;\n+        secp256k1_fe_set_int(&t1, 32);\n+        secp256k1_fe_normalize_weak(&t0);\n+        secp256k1_fe_add(&t1, &t0);\n+        secp256k1_fe_mul(&t2, &t0, &secp256k1_ellsq_c3);\n+        secp256k1_fe_add(&t2, &secp256k1_ellsq_c4);\n+        secp256k1_fe_sqr(&t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t2);\n+        secp256k1_fe_mul(&t3, &t3, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_sqr(&t1, &t1);\n+        secp256k1_fe_mul_int(&t1, 7);\n+        secp256k1_fe_add(&t3, &t1);\n+        if (secp256k1_fe_jacobi_var(&t3) >= 0) return 0;\n+        ret = secp256k1_fe_sqrt(&u, &t0);\n+        VERIFY_CHECK(ret);\n+        secp256k1_fe_mul(&u, &u, &secp256k1_ellsq_c5);\n+    }\n+    secp256k1_fe_normalize_var(&u);\n+    if (secp256k1_fe_is_odd(&u) != secp256k1_fe_is_odd(&y)) {\n+        secp256k1_fe_negate(&u, &u, 1);\n+    }\n+    *out = u;\n+    return 1;\n+}\n+\n+int secp256k1_ellsq_encode(const secp256k1_context* ctx, unsigned char *ell64, const unsigned char *rnd32, const secp256k1_pubkey *pubkey) {\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+    ARG_CHECK(rnd32 != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    if (secp256k1_pubkey_load(ctx, &p, pubkey)) {\n+        uint32_t cnt = 0;\n+        /* Field elements and branch values are extracted from\n+         * SHA256(\"secp256k1_ellsq_encode\\x00\" + uint32{cnt} + rnd32 + X + byte{Y & 1})\n+         * for consecutive values of cnt. cnt==0 is first used to populate a pool of\n+         * 128 2-bit branch values. The 128 cnt values that follow are used to\n+         * generate field elements u1. cnt==129 (and multiples thereof) are used to\n+         * repopulate the pool and start over, if that were ever necessary. */\n+        unsigned char hashdata[23 + 4 + 32 + 32 + 1] = \"secp256k1_ellsq_encode\";\n+        /* Pool of 2-bit branch values. */\n+        unsigned char branch_hash[32];\n+        /* Number of 2-bit values in branch_hash left. */\n+        int branches_left = 0;\n+        /* Fill up hashdata, excluding i. */\n+        memcpy(hashdata + 23 + 4, rnd32, 32);\n+        secp256k1_fe_get_b32(hashdata + 23 + 4 + 32, &p.x);\n+        hashdata[4 + 23 + 32 + 32] = secp256k1_fe_is_odd(&p.y);\n+        while (1) {\n+            int branch;\n+            secp256k1_fe u1, u2;\n+            secp256k1_ge q;\n+            secp256k1_gej qj;\n+            /* If the pool of branch values is empty, populate it. */\n+            if (branches_left == 0) {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, branch_hash);\n+                ++cnt;\n+                branches_left = 128;\n+            }\n+            /* Take a 2-bit branch value from the branch pool. */\n+            --branches_left;\n+            branch = (branch_hash[(127 - branches_left) >> 2] >> (((127 - branches_left) & 3) << 1)) & 3;\n+            /* Compute a new u1 value by hashing (a potential first 32 bytes of the output). */\n+            {\n+                secp256k1_sha256 hash;\n+                hashdata[23 + 0] = cnt;\n+                hashdata[23 + 1] = cnt >> 8;\n+                hashdata[23 + 2] = cnt >> 16;\n+                hashdata[23 + 3] = cnt >> 24;\n+                secp256k1_sha256_initialize(&hash);\n+                secp256k1_sha256_write(&hash, hashdata, sizeof(hashdata));\n+                secp256k1_sha256_finalize(&hash, ell64);\n+                ++cnt;\n+            }\n+            if (!secp256k1_fe_set_b32(&u1, ell64)) continue;\n+            /* Compute the remainder Q to encode in the last 32 bytes of the output. */\n+            secp256k1_ellsq_fe_to_ge_var(&q, &u1);\n+            secp256k1_ge_neg(&q, &q);\n+            secp256k1_gej_set_ge(&qj, &q);\n+            secp256k1_gej_add_ge_var(&qj, &qj, &p, NULL);\n+            if (!secp256k1_gej_is_infinity(&qj)) {\n+                 secp256k1_ge_set_gej_var(&q, &qj);\n+            } else {\n+                /* If Q=P-f(u1) is infinity, it means we're trying to encode P=f(u1).\n+                 * While no u2 exists such that f(u2)=Q in that case, it is still\n+                 * possible to encode P due to the special rule that if f(u1)+f(u2)\n+                 * is infinity, the result of decoding is f(u1).\n+                 * In other words, we're not trying to reach f(u2)=P-f(u1), but\n+                 * f(u2)=-f(u1) instead. -f(u1) is exactly what the variable q\n+                 * already holds at this point. Note that if u1 is generated using\n+                 * a secure hash function, the probability of reaching this branch\n+                 * is negligible. */\n+            }\n+            /* Try to find a u2 value which encodes Q. */\n+            if (secp256k1_ellsq_ge_to_fe_var(&u2, &q, branch)) {\n+                /* If that succeeds, store it in the output. */\n+                secp256k1_fe_normalize_var(&u2);\n+                secp256k1_fe_get_b32(ell64 + 32, &u2);\n+                break;\n+            }\n+        }\n+        memset(hashdata, 0, sizeof(hashdata));\n+        return 1;\n+    }\n+    /* Only returned in case the provided pubkey is invalid. */\n+    return 0;\n+}\n+\n+int secp256k1_ellsq_decode(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {\n+    secp256k1_fe f1, f2;\n+    secp256k1_ge p1, p2;\n+    secp256k1_gej acc;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+    ARG_CHECK(ell64 != NULL);\n+\n+    secp256k1_fe_set_b32(&f1, ell64);\n+    secp256k1_fe_set_b32(&f2, ell64 + 32);\n+    secp256k1_ellsq_fe_to_ge_var(&p1, &f1);\n+    secp256k1_ellsq_fe_to_ge_var(&p2, &f2);\n+    secp256k1_gej_set_ge(&acc, &p1);\n+    secp256k1_gej_add_ge_var(&acc, &acc, &p2, NULL);\n+    if (!secp256k1_gej_is_infinity(&acc)) {\n+        secp256k1_ge_set_gej_var(&p1, &acc);\n+    } else {\n+        /* f(u1)+f(u2) is infinity. In that case the decoding is defined to be\n+         * equal to f(u1) instead. f(u1) is already stored in the p1 variable\n+         * at this point. */\n+    }\n+    secp256k1_pubkey_save(pubkey, &p1);\n+    return 1;\n+}\n+\n+#endif"
      },
      {
        "sha": "59c3a7c6386cee2d48fb832ceafcbd1e8090447d",
        "filename": "src/secp256k1/src/modules/ellsq/tests_impl.h",
        "status": "added",
        "additions": 157,
        "deletions": 0,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/ellsq/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/ellsq/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ellsq/tests_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -0,0 +1,157 @@\n+/***********************************************************************\n+ * Copyright (c) 2021 Pieter Wuile                                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_ELLSQ_TESTS_H\n+#define SECP256K1_MODULE_ELLSQ_TESTS_H\n+\n+#include \"../../../include/secp256k1_ellsq.h\"\n+\n+struct ellsq_test {\n+    secp256k1_ge point;\n+    int enc_bitmap;\n+    secp256k1_fe encs[4];\n+};\n+\n+/* Set of (point, encodings) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_test ellsq_tests[] = {\n+    {SECP256K1_GE_CONST(0xc27fb7a3, 0x283a7d3e, 0xc9f96421, 0x545ef6f5, 0x8ace7b71, 0x06c8a1b9, 0x07c0ae8a, 0x7598159c, 0xe05a060e, 0x839ef79f, 0xc0c1267c, 0xa17880c9, 0x584cdd34, 0xc05f9695, 0x55482207, 0xe6851f2a), 15, {SECP256K1_FE_CONST(0xc0ad127a, 0xa36824d6, 0x5b1f5be7, 0x4de1aa25, 0xbc4d5cbe, 0xcee15462, 0x0a12682a, 0xfc87df98), SECP256K1_FE_CONST(0xd40fd5bc, 0x51992484, 0x8f13273b, 0x1d857cba, 0x42d45e78, 0x9eaa4e47, 0xf458b83a, 0xbd5f8d1c), SECP256K1_FE_CONST(0xde636141, 0x7deb440b, 0x3a305924, 0x43635cf9, 0xcf42f9b5, 0xf5b891c1, 0x1e119f09, 0x71b570ac), SECP256K1_FE_CONST(0xd55135ce, 0x41bb4d05, 0x5b3757f4, 0xaf1d6537, 0x137376d7, 0x5270caae, 0xda68382d, 0x25d00708)}},\n+    {SECP256K1_GE_CONST(0x3f5ada4e, 0x8f646ec9, 0x10ffc1a2, 0xb74d94bb, 0xb1860631, 0xa3c2a349, 0xeddf55ca, 0xfd49cce9, 0x28ad9d8d, 0x77d9cd87, 0xf80aaa34, 0x8e9ad1b4, 0x40353d7a, 0x6e717714, 0x60425319, 0x38f530c3), 15, {SECP256K1_FE_CONST(0xac42348f, 0x1b356822, 0x5bb7d4c0, 0x0feab37e, 0xa5fb7fbb, 0x0cc3879d, 0xc74e2dda, 0xf9a393bf), SECP256K1_FE_CONST(0xda7a45b2, 0x6c87dcb6, 0x4a934c1d, 0xc841d250, 0xf98af5f0, 0x511be2a3, 0x82d17bab, 0xe1e4a533), SECP256K1_FE_CONST(0xc3d9b9a6, 0x570ca9c8, 0xa640fc75, 0x945850b2, 0xcc86b6d6, 0x399b4496, 0x4288d76d, 0x832a32d7), SECP256K1_FE_CONST(0xbf5ebc2f, 0x4060abe7, 0x884a1fa7, 0xcc0883cb, 0x97535c5a, 0x31dc6df4, 0xc6968e9d, 0x8554f3b1)}},\n+    {SECP256K1_GE_CONST(0xf5f74fab, 0x3ebbbcfd, 0xdcaef6cc, 0xd14eb934, 0xf9435a4e, 0x4a1ed2d8, 0x75352c47, 0x306d6c2f, 0xea6a5b2a, 0xe109897d, 0x046e1504, 0xf7a382d6, 0x1eb49a8a, 0xae8852ef, 0x48e29466, 0x194d9e66), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xe8362df2, 0x38e0405b, 0x49218747, 0x74f9ebca, 0x36dfe21b, 0x1a49ae2d, 0x0fa23fd4, 0x11a262a6), SECP256K1_FE_CONST(0x9e453426, 0xac973155, 0x19d11d63, 0xc3bb27ee, 0x89a7ec85, 0x5661dce4, 0xe428f6cc, 0x0be059cc)}},\n+    {SECP256K1_GE_CONST(0x977694f6, 0x6f0a3005, 0x2c638916, 0x61432fa0, 0x605528a7, 0xad87d829, 0x5c9eb9a3, 0x973c6fed, 0x16515f14, 0x00186fec, 0x67f6314c, 0x8a9e2d43, 0x3d2020e9, 0x38f86465, 0x39f749a1, 0x51a793ed), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x8f091a42, 0xce496be8, 0x877d43fc, 0x2f2b2927, 0x42c9c1fb, 0x0dfe570b, 0x9c9fbd3e, 0x04afa709), SECP256K1_FE_CONST(0xb5930cf1, 0x4db355a5, 0xa92b9f78, 0x9390b59a, 0x013c8e27, 0x7c41ddd6, 0xd8221622, 0x93d39141)}},\n+    {SECP256K1_GE_CONST(0x9c970ce9, 0x39e8a4ec, 0x70237f33, 0xad858370, 0xc9d30e8a, 0xadaac257, 0x546d1e16, 0xf374973b, 0x95755fab, 0x1bcae32e, 0xc811c63f, 0xb1e56da8, 0x97a1e140, 0xb1aae97e, 0x0b6ae6c5, 0x3879f51c), 13, {SECP256K1_FE_CONST(0xa7424f55, 0x60b58ceb, 0xbb9a6ee1, 0x5fc41b18, 0xf282b2cd, 0xd9e2fb4d, 0x02626c1a, 0xc0a89ec4), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xd7016e9b, 0x94db9b4c, 0x5bc61c87, 0xaf3b3c9c, 0x72707e5e, 0x48332958, 0xce5371bf, 0xd501a006), SECP256K1_FE_CONST(0xe95cd3a1, 0x2cff74bd, 0x6761a782, 0x61f73f0d, 0x755a80f6, 0x39ccd117, 0x136f9963, 0xf422b82a)}},\n+    {SECP256K1_GE_CONST(0x48206211, 0x5e6fc771, 0x738b4859, 0x4da66901, 0xa0a8c36e, 0xa61122b7, 0x745cf5fe, 0xec932b64, 0x01c9e1a1, 0x59effb22, 0x4442c868, 0x9119fd26, 0x8cdca070, 0x7edbefb6, 0xea81d5f6, 0x86333768), 13, {SECP256K1_FE_CONST(0xf1047fb9, 0x4cfa6dcd, 0x202e1acc, 0xa85afc88, 0x46381925, 0x7adf32aa, 0x25e19e52, 0xbf3cadd8), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x94dc1b2b, 0x6a24bbdb, 0x36afab1a, 0x6e036e7f, 0xdf1ded22, 0x915bf761, 0x97e5e5a5, 0xc6261582), SECP256K1_FE_CONST(0x8dd664ba, 0x47061bac, 0x0c99d727, 0xac2ade9f, 0xf8d33aff, 0x995a7a28, 0x97f2968c, 0x558ef724)}},\n+    {SECP256K1_GE_CONST(0x47e54d7b, 0x86025d30, 0x248b18e6, 0xc6b2b128, 0x3f8eb11e, 0x60d11cad, 0xf59884ea, 0x56939f5a, 0xb618d932, 0x6110c200, 0xcbed144f, 0xc6376800, 0xd8ba0de1, 0xd87fa02d, 0x17d1d58d, 0x9652c498),  3, {SECP256K1_FE_CONST(0x8797d6a9, 0xe3614b34, 0x80e43cb6, 0x936cd932, 0xbe4eee02, 0x1e47e067, 0x2d1d9f2f, 0xd0148558), SECP256K1_FE_CONST(0xb19c75d0, 0xb4856c81, 0xb467f8f5, 0xb9f8d849, 0x0e5296f0, 0x4c60d639, 0x6f772b7f, 0x427c5d38), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8fa5ffb5, 0x597068f6, 0x06785a63, 0x1f74cd6f, 0x8b16e94b, 0xe6cee831, 0x2970e0ec, 0xa9ecda52, 0x6c4f0efe, 0xf1d0eef2, 0xe3281b13, 0x4f29289f, 0x0a9d7b4d, 0xb3118c5f, 0x1d2d1da4, 0x75569ebf),  3, {SECP256K1_FE_CONST(0xe66995d0, 0x9cfdddda, 0xadf4b4ec, 0xc00270ed, 0xaeaacf01, 0x2db38d37, 0xe4143baf, 0x0ae7dfa3), SECP256K1_FE_CONST(0xfe0d264e, 0x3121942c, 0xd5126e26, 0x0766f36c, 0x3a08a689, 0x4e8ec172, 0xf3fdb252, 0x70def1ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x016a682d, 0x1df4f869, 0xb32c48b0, 0xa9b442a1, 0x493949fb, 0x85d951d1, 0x21c1143b, 0xd3d5c1af, 0x38d33fe5, 0xd3f9b4b9, 0x82e37dff, 0x7561428d, 0x47ef4ddf, 0x654bd959, 0x51b04e90, 0xa3be50e7),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ec42424, 0xb4d2226f, 0x83f94258, 0xc737d0da, 0xf93a4eb1, 0x1d9b9e3f, 0xd500d5b9, 0xc3aa7c71, 0x84975819, 0xb703da77, 0xca98bd3c, 0xd9bbdc7a, 0xf1dbc7b5, 0x85c590eb, 0xcbd417fd, 0x739ad572),  1, {SECP256K1_FE_CONST(0x945faa12, 0x7e8bf378, 0x63581bfb, 0xde084bf7, 0x63caee39, 0x1449c610, 0xc2074f86, 0xff1bf16c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x69ee52b2, 0x88dfb06a, 0x449d3db8, 0x7602e094, 0xb4f131e3, 0xf6a4b249, 0xdc0a76ff, 0xdebe989a, 0x3922f1a4, 0xdd208f94, 0xcbac1c5d, 0x34a9278d, 0x84310781, 0x84ff4430, 0x31a14018, 0x95ffd9e6),  1, {SECP256K1_FE_CONST(0xdc1e4760, 0x15bda784, 0xa1b9527b, 0x0357786a, 0xdf2a8028, 0x03957837, 0xe10cff92, 0x5ef4ca7e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x7ae96a2b, 0x657c0710, 0x6e64479e, 0xac3434e9, 0x9cf04975, 0x12f58995, 0xc1396c28, 0x719501ee, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0x3ac01550, 0x68185039, 0x6068aaf0, 0xc3f24144, 0x9a267956, 0x698833d4, 0x80c03dc5, 0x678b67cf),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9ddddd8e, 0xc1814a29, 0x3fcca202, 0xebfbe14e, 0x5d808dda, 0x142eee64, 0xc6108381, 0xe99e5cff, 0xb5072d55, 0x37223f39, 0x3e4176d2, 0xcfd93c86, 0x82ca2c22, 0xcd25ec40, 0x877296bd, 0xbb7c08f6),  3, {SECP256K1_FE_CONST(0xadd34f27, 0xc5f90171, 0x75186c23, 0xd14f6ef2, 0xaa182896, 0x77d5373a, 0xd6c31e9f, 0xf6358ae8), SECP256K1_FE_CONST(0xf5ee8614, 0x1916fe03, 0x945d028b, 0xbc354c4a, 0x09f6d6ab, 0x1468ab9a, 0xd8742075, 0x1543c2a2), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x1ee7e9a7, 0xfcd56edf, 0xabf3712e, 0x72cc24a3, 0x0a476f5a, 0x97f77825, 0xf0308620, 0x162f31ad, 0x77bfc7de, 0xc2401a39, 0x8c5e8675, 0x417c8a7b, 0x632f5d64, 0x2f1a5059, 0x9a830b8c, 0x7981f636),  3, {SECP256K1_FE_CONST(0xb3a8d9e7, 0x368af258, 0x3785be92, 0x2ad54dfb, 0x47329513, 0x6ade2d18, 0x2f931cd6, 0x54f35d02), SECP256K1_FE_CONST(0xe1d420e5, 0xfab5c26d, 0xf4294b2b, 0x0c19eb9a, 0x188409bf, 0x48a3741f, 0x31f72acc, 0x6ea93418), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9e24d0a5, 0xd5014164, 0x987f86bb, 0x1709305a, 0x6fd352a0, 0xa3478fae, 0x3f85e594, 0x21d72a80, 0x3729c39b, 0xbbb26d97, 0xa4ec6bf7, 0xcb4e6453, 0x058e448e, 0x7530b028, 0xd1ae345e, 0x35608d3c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x15f2f1a4, 0x339f5f2a, 0x313b9501, 0x5cad8124, 0xd054a171, 0xac2f31cf, 0x529dda7c, 0xfb6a38b4, 0xfe1d0fa5, 0x95b4f7d3, 0x63e82c29, 0x0095189f, 0x5f2be99c, 0x880be4fc, 0x9742a31b, 0x40041eda),  1, {SECP256K1_FE_CONST(0xc1c3ed27, 0x17ffabfd, 0x01132f5e, 0x54dd73c3, 0x475297e0, 0xfdbff814, 0xdc9456b8, 0x4a57b698), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd383134d, 0x721cf055, 0x143570e7, 0x82bb323d, 0x5c542a61, 0xe455823e, 0xd60b940f, 0x86826d54, 0x5a88e50b, 0x3f59874e, 0x84dab4a2, 0x07d34623, 0xd836c376, 0xc68dded3, 0xc095a716, 0xf563e4fc),  1, {SECP256K1_FE_CONST(0xe4d2660c, 0x1d50d031, 0x97f5e610, 0x4d9c2066, 0x01f6c791, 0xadb52178, 0xe2bd6c88, 0xe89cf012), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x851695d4, 0x9a83f8ef, 0x919bb861, 0x53cbcb16, 0x630fb68a, 0xed0a766a, 0x3ec693d6, 0x8e6afa40, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xbde70df5, 0x1939b94c, 0x9c24979f, 0xa7dd04eb, 0xd9b3572d, 0xa7802290, 0x438af2a6, 0x81895441),  3, {SECP256K1_FE_CONST(0xd3779b57, 0x3cb17828, 0xac118cff, 0x74412ab5, 0xb84c86f8, 0xa92f48b8, 0xefcbe4c7, 0x0a675631), SECP256K1_FE_CONST(0xea6f729d, 0xdc884123, 0xf0130aa0, 0x339bda36, 0x2166d034, 0xfe50d9d7, 0x53bf0dde, 0x7721fa3f), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x99a70224, 0xc3062c32, 0x6c45d3c6, 0x46a545e9, 0xb152b75b, 0xee868378, 0x07e47951, 0x9e5b600d, 0x95b6675a, 0x10845b66, 0x37ff96e8, 0xe67f2a75, 0xbbf0f764, 0xc56d26c5, 0x4b2db5eb, 0xb026d7de),  3, {SECP256K1_FE_CONST(0xb74a9552, 0xc5b9b6ed, 0x575d380f, 0xec3df8ed, 0xdb524ed1, 0x80b13607, 0x81e2eec6, 0x7ad06c04), SECP256K1_FE_CONST(0xbb702282, 0x4194fbe4, 0x4a74c4f4, 0xabd01ee3, 0xdac8f4cb, 0x5a0e3a67, 0xd2276039, 0xdd4aac1a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb5902433, 0x3110b310, 0x8625f254, 0x47665c1e, 0xbf10c6a6, 0xbbe9f018, 0xc421f4b0, 0xdcb5a993, 0x43bae2cd, 0xaae9c002, 0xe57ac99a, 0x17926e22, 0x76a66728, 0xf92b11bb, 0x7dc953b9, 0xea6d49b7),  3, {SECP256K1_FE_CONST(0xd5a57c1b, 0x71916606, 0xbfb235f0, 0xce8d880d, 0xe9109a01, 0xb86d58c8, 0x2852b211, 0x0e55ee0f), SECP256K1_FE_CONST(0xca6cf74b, 0x128e1d79, 0x75482bfd, 0xc9e81416, 0x71a5c3e7, 0xe2af854b, 0x23707630, 0x97ba917b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb526749e, 0x35fa04ef, 0x5d20b1d6, 0xcda6f57e, 0x2f3c10c9, 0x85098901, 0xc390da79, 0x31769e34, 0x182093b3, 0xce5883a2, 0x7b834af6, 0x18547fd1, 0x6017cee0, 0x4e9398da, 0x6aaaed2b, 0x87ca0e7c),  0, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x901c52d6, 0xa39718c7, 0x255e94e3, 0x3189cbeb, 0x41f2fa97, 0x95279076, 0xbecd6678, 0x99684c17, 0xf988a838, 0x156cc39f, 0x2182bbc5, 0xf7e4f707, 0x9cf75bfb, 0x58638cff, 0x5b201fd3, 0xcf499fc0),  1, {SECP256K1_FE_CONST(0xa356db31, 0x44b754a3, 0xdafdf2a9, 0x0767b65a, 0xbaea92ca, 0x56c69c3a, 0x31a4ff5b, 0xd7914d9c), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x957d4fd4, 0x4a10f38a, 0x0d0e1e46, 0x2656dd2e, 0x7f2b6b8c, 0x9545ee02, 0x903f28b0, 0x8f9a57e7, 0x3f4bf4de, 0x3731bea3, 0x291627e3, 0x9daa7dac, 0xcdcd4e13, 0xb2418482, 0x488730b7, 0xa7a816b7),  1, {SECP256K1_FE_CONST(0xa761cd3a, 0x58385878, 0x300c6963, 0xe918b545, 0x99eb0254, 0x550f6254, 0xe414628c, 0x2f431bbd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x0a7b6db2, 0x56f01aea, 0x797a0798, 0x5eaf98d6, 0x64486f82, 0x723758bf, 0x1a5f7b00, 0xb74887e1, 0xe07ce7ec, 0x5f24b6da, 0x199329ff, 0x674788c4, 0x1b7312d4, 0xbb63672f, 0x81ebbfd3, 0x6d962235), 15, {SECP256K1_FE_CONST(0x442e15e3, 0xac31958b, 0x7acdb8b9, 0x7977b6d0, 0x533b1ef0, 0x5094f496, 0x126a04d0, 0xc6d6c327), SECP256K1_FE_CONST(0xc565d637, 0x6c8f4fa4, 0xa22ab5d4, 0xe1c87f5d, 0x6f9beb27, 0x7764a77f, 0x8ebe3796, 0xaa82cba5), SECP256K1_FE_CONST(0x2082a3b7, 0x04d3729c, 0x71a73a0c, 0xd745c7ce, 0x7a7c5e26, 0x77c688e2, 0x772806d1, 0xdd1a849f), SECP256K1_FE_CONST(0xc00c8cc3, 0x5ea8122e, 0xf17b0a8e, 0xc69218d1, 0x8cb45a3f, 0x0227a2c5, 0x68fbd9f9, 0xc6d6d141)}},\n+    {SECP256K1_GE_CONST(0x770ed6cb, 0xf6d2156b, 0x362523eb, 0xc2908f68, 0x65ab182c, 0x43468bc8, 0x69d6754e, 0x68dc71a0, 0x2a378713, 0x10223129, 0xbaba56c2, 0x0dc4a1e9, 0x634dba32, 0xa034d21f, 0x3104176b, 0x870c9916), 15, {SECP256K1_FE_CONST(0x092c79ab, 0xbbafd66d, 0x58c56208, 0x7ba5c385, 0x9fed6c1b, 0x5f8005af, 0x0087cedb, 0xec7dc084), SECP256K1_FE_CONST(0x3f5c280a, 0x60802515, 0x16dfd84a, 0x4488df47, 0x96198d5f, 0xbce0be21, 0x1ab0ee7d, 0xa456e73e), SECP256K1_FE_CONST(0x94057b6b, 0xd54b13b2, 0xe2b9d322, 0x687569f5, 0xdd16727d, 0x3d912ba3, 0xeb8aa33d, 0x36c15108), SECP256K1_FE_CONST(0x098360ae, 0xcf93979e, 0x7cd6df39, 0x6e8fe2f3, 0x18fa1da3, 0x9efa707a, 0xeab95cd8, 0xcd5dca2a)}},\n+    {SECP256K1_GE_CONST(0xab01575c, 0x0604c63e, 0xe77d3153, 0x4a5bcfa2, 0x0ce66c9d, 0xf47d6054, 0xb822bfd8, 0x6934f8ec, 0xce488d85, 0xd0875b40, 0x4fb92b6e, 0x8068602a, 0x670ac4f8, 0xd76b78b6, 0xc246b713, 0x595e226b), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4ab21b18, 0x1009aa48, 0xb8ba5eb9, 0xd373919b, 0xcfcb36a6, 0xf34961b2, 0xc859f5a8, 0x6da8ba41), SECP256K1_FE_CONST(0x9a11c401, 0x9a4ba9fc, 0xf4698a71, 0x2d85c8e4, 0x70028e02, 0x545ef049, 0xf9f3083d, 0x187c5b41)}},\n+    {SECP256K1_GE_CONST(0x6084cfdd, 0xf8d9736e, 0xa90100eb, 0xdb43338f, 0x65e2ab43, 0xef35a799, 0x926e6ce3, 0x2a89ae17, 0x753998b5, 0x9eaae7a3, 0xdcab34d9, 0xa15dbc71, 0xe539cdff, 0xdcf05927, 0x0eb27c86, 0xab6b62a4), 12, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x18b1f707, 0x3fca3167, 0x04e1b3b8, 0x8cc8ff5a, 0x702d79bc, 0x756e4dea, 0x2ff948cc, 0xdb43a9f4), SECP256K1_FE_CONST(0xca02e589, 0x89eb16d1, 0x520463d2, 0x435745cf, 0x6e69fa52, 0x6b5c7adc, 0x57cea2b3, 0xf5a6441c)}},\n+    {SECP256K1_GE_CONST(0xc9fbac00, 0x9d8eda5d, 0x25c9aabb, 0x2b6794bc, 0x9a801afd, 0x17adef78, 0x78c65392, 0x04eb0f82, 0x95ed9e51, 0x898b903e, 0xe689e6ed, 0xff2b54bf, 0xed5c2da1, 0x69e2bdd0, 0x415a392e, 0x16b3de2b), 13, {SECP256K1_FE_CONST(0x21a95220, 0x8577e3f0, 0xcc5b4b17, 0xf5e434b2, 0x2bbdbaaa, 0x51cd2659, 0xe37880a6, 0xa25aa7dd), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0xcfd1ca13, 0x2f8d3eae, 0x73a97895, 0x01d2c82a, 0x6f057566, 0x7949fab9, 0x267bc1e8, 0xef9bf5bd), SECP256K1_FE_CONST(0x9cde02aa, 0x3acd2596, 0xdbea4b82, 0xf9f47ad1, 0x994ad567, 0x3c0d4fb2, 0xe8a3dca5, 0xe8e067fb)}},\n+    {SECP256K1_GE_CONST(0x8dcb38d9, 0x0059d4f1, 0x270455af, 0x6f3dd40e, 0x8d671a34, 0xa1fad81d, 0x2470db8a, 0x13b18f76, 0x603ed5be, 0x7bc3e67f, 0x439067da, 0x29949bcb, 0xd3c96c9f, 0x94da4231, 0x3c9c0feb, 0xe5cdf560), 13, {SECP256K1_FE_CONST(0x3ef4008a, 0x8a190a3f, 0x5c97d211, 0x3bb539e1, 0xf4261a78, 0xf7cd85c4, 0xfd254837, 0xeaacd020), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x0fe7af4f, 0xcab80199, 0x37ee0026, 0x47d55d97, 0x575474b3, 0x4b9cc1bb, 0x133f4261, 0x017124a0), SECP256K1_FE_CONST(0x09dcec3b, 0x93c4ab42, 0x91d01dce, 0xccc19525, 0xc801add3, 0x77170c2c, 0x919f5488, 0xf41d6d3e)}},\n+    {SECP256K1_GE_CONST(0xf69dfe44, 0x890d2b09, 0x4b749a56, 0xf680e851, 0x50c47c4c, 0xd51e7796, 0x3fec4e6a, 0x09dcd0a1, 0xfb5d321c, 0x1e243b63, 0x6dfb71f3, 0xcf0e8a01, 0x2e52b22c, 0x905cec6d, 0x2f6ae32a, 0x6a4eb7be),  3, {SECP256K1_FE_CONST(0xa17fd528, 0x7276cbf6, 0xc168dcde, 0xb32aba14, 0xe1aeae2f, 0xe7f5bea5, 0xa87d384e, 0xe8046aac), SECP256K1_FE_CONST(0x637f176a, 0xf2fe854a, 0x968ab19b, 0xee010554, 0x313e3eff, 0xc6ff8cb4, 0xcb538a6d, 0xbaedd954), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x043a0631, 0x871a3f67, 0xac03c5f8, 0x406b69a0, 0xdc14bd5b, 0x23e55f27, 0xa5d4462b, 0x0f0a2d23, 0x247b9bcc, 0x0019091c, 0x31eb4b03, 0xe731a0b5, 0xa9b33f75, 0xad9e5e63, 0x39286573, 0xa6439d88),  3, {SECP256K1_FE_CONST(0xd65add13, 0xad3044d9, 0x2ebcd0e6, 0xd42853d8, 0xe5733ff6, 0x5297f544, 0x09a3ce89, 0xfdaffbdc), SECP256K1_FE_CONST(0x7281ad3c, 0x85de3870, 0x84f64e14, 0x42b37154, 0xeab39453, 0x8b1c0753, 0x4b303ae7, 0x37f3973e), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x8855508a, 0xade16ec5, 0x73d21e6a, 0x485dfd0a, 0x7624085c, 0x1a14b5ec, 0xdd6485de, 0x0c6839a4, 0xe50aaeba, 0xa0ceceec, 0xa1bce62e, 0x5f0fac4b, 0xe78ab03a, 0x7b2deaa6, 0xe5c17e88, 0x98e277e9),  1, {SECP256K1_FE_CONST(0x4e96da73, 0xae14fc85, 0x25eccb2d, 0xf4416924, 0x8a7fd269, 0xa065e065, 0x04d315e6, 0x63666b03), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xc66327bc, 0x5b0b8b90, 0x37adfd63, 0xc2a9f192, 0x2ce2144a, 0xa513b390, 0xd48bc387, 0xae3ebff6, 0x17a1ca89, 0x64eb0b41, 0x162894e6, 0x4fb4112b, 0x638f96ec, 0xe0c6f30d, 0xef7616fe, 0x0e78386a),  1, {SECP256K1_FE_CONST(0x56e8e17e, 0xfaf989d6, 0xa7efb81d, 0x5a602393, 0x6814930e, 0xbc3f6fdf, 0x72ebf472, 0x69ba4c9a), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa9, 0xfffffd6b, 0xc53feaaf, 0x97e7afc6, 0x9f97550f, 0x3c0dbebb, 0x65d986a9, 0x9677cc2b, 0x7f3fc239, 0x98749460),  4, {SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x9d709c02, 0x74604cb6, 0x3b531fea, 0x35932e2e, 0xc965f4bf, 0x5913e577, 0xff31080b, 0x67727a2e, 0xf2b0b821, 0xa24081a9, 0xd0ca84d9, 0x303068cf, 0x7ea32788, 0x05926b0a, 0xb90b9af7, 0x498efbd5),  3, {SECP256K1_FE_CONST(0xb06abefa, 0x192a6498, 0xbce368ff, 0xacc843fb, 0xb39f8117, 0xa56a1870, 0xf57197ef, 0xd9312f6d), SECP256K1_FE_CONST(0x1263d142, 0xaac9cfc5, 0x64c56650, 0x0fa4a62f, 0x38e727fb, 0xb4dbeaf2, 0x6fdf7d05, 0xfd022c71), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xb4955dcb, 0x4daaa784, 0x9b421c14, 0x53ec8945, 0xd685d554, 0xf41103f8, 0x12cbfb2f, 0x54a4539b, 0x354d18e4, 0xb1cee7a3, 0xf98b0651, 0xf5544091, 0xe8a00656, 0x0c74750d, 0xaadf460e, 0xc3f620ea),  3, {SECP256K1_FE_CONST(0x6281a8a7, 0x0a3b5745, 0xb897ce4f, 0x58305fb0, 0xd6a0f8ab, 0xa6c5ba18, 0xed278ce1, 0x50f7911c), SECP256K1_FE_CONST(0x5f95a708, 0x2d2f6d69, 0xf7ff9b74, 0x2b88063c, 0x39a3003b, 0xb03f333c, 0x7e3d7c5e, 0xd861fb04), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x6ad63dfd, 0xcd231967, 0xff2508f4, 0x75896976, 0xf8728e40, 0xdd7a2acc, 0x6b5ced37, 0xcada8291, 0xf93e5181, 0x8f5329b8, 0xd520a9af, 0xd72938e1, 0x2e3f8be6, 0x421d2bce, 0x89d7b14e, 0x25bf5336),  1, {SECP256K1_FE_CONST(0x0f050318, 0x622f79f1, 0x5a2b23d9, 0xf76329b7, 0x8e195f1a, 0x4651aae0, 0x65d58bcd, 0xdfa4d3b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa91b7f2a, 0xb93de821, 0xabeec175, 0x0258e4d4, 0xf5f09831, 0xb0a11dda, 0x47e89ddf, 0x6944d819, 0x22eb9bf6, 0x4a517df2, 0xc27d1c55, 0x1df07609, 0x166fc995, 0xe2b39fee, 0x0473ea46, 0xed14efc1),  1, {SECP256K1_FE_CONST(0x7a01651a, 0x81a7f09e, 0x2733cf34, 0x9e6472a1, 0x18c16780, 0x6f5c880f, 0x534b89a6, 0x52be06a7), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x4218f20a, 0xe6c646b3, 0x63db6860, 0x5822fb14, 0x264ca8d2, 0x587fdd6f, 0xbc750d58, 0x7e76a7ee),  3, {SECP256K1_FE_CONST(0x2c8864a8, 0xc34e87d7, 0x53ee7300, 0x8bbed54a, 0x47b37907, 0x56d0b747, 0x10341b37, 0xf598a5fe), SECP256K1_FE_CONST(0x15908d62, 0x2377bedc, 0x0fecf55f, 0xcc6425c9, 0xde992fcb, 0x01af2628, 0xac40f220, 0x88de01f0), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xa64de96a, 0x6254cefc, 0xffbeaf89, 0x8f2c228a, 0xf6d405f3, 0xbcc6a4cc, 0xe068312a, 0xf7ccf8e1, 0x8f9b3a1b, 0x2d146ea9, 0x54bfc5e2, 0xcdfe861c, 0xcbed8431, 0xc741c5f9, 0xd32f16a3, 0x073ea496),  3, {SECP256K1_FE_CONST(0x4591d33d, 0x1a133a87, 0x94689b1b, 0x0ca445b7, 0x8ada3bce, 0xc2e812b0, 0x8315e2b1, 0x07940ad4), SECP256K1_FE_CONST(0xa763d217, 0x6027d40e, 0x8a8ff34b, 0xd9c639b7, 0x3e2ea045, 0x92274fdc, 0xfa4051c6, 0x6d93a1b6), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x49a0dc06, 0x8c3f117a, 0xefdc842d, 0x3d358153, 0xf677f04c, 0x6dabc9c9, 0x1b09d452, 0xfef27b66, 0x7b944da4, 0x8a175dbc, 0x444ead8d, 0xb82eff66, 0xb081a8aa, 0xe6453fed, 0x2bca9720, 0xb44dd6e5),  3, {SECP256K1_FE_CONST(0x7bf1e2b1, 0x720c1c44, 0x0db64687, 0xf16439fa, 0x41b39833, 0x8095f24e, 0xbeec0cfa, 0x88750dc9), SECP256K1_FE_CONST(0xdc97e26d, 0x3137445d, 0x6c1269b6, 0x1a765501, 0x0c19c36a, 0x2e361066, 0xe31e2bb1, 0x0403470b), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0xd09a4047, 0xf158fe52, 0xf96c661d, 0x02c68657, 0xc4c976ea, 0x96ea85ef, 0x46d6985b, 0xd540756b, 0xe793bfaa, 0xe9300f18, 0xe6f9b55a, 0xae263223, 0x68b61d51, 0xae5022ef, 0xe266c72d, 0x574178bc),  1, {SECP256K1_FE_CONST(0x7e6175fd, 0xfbb9fb4f, 0xaf6e2b92, 0x5ef86c4a, 0x444d819a, 0xaa82dbee, 0x545d3d9b, 0x296375be), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}},\n+    {SECP256K1_GE_CONST(0x34986625, 0x04b73c7c, 0x8cecb6c3, 0x3cd493bd, 0xfc190e0f, 0x87d913d7, 0xff9ad42e, 0x222bfe95, 0x245b3a61, 0xb8d46997, 0xf14f2fea, 0x28748996, 0x91eb3254, 0x2b9907d6, 0x5eb9d21d, 0x42454021),  1, {SECP256K1_FE_CONST(0x7f556282, 0xc3dd9d26, 0x3390d6bb, 0xddada698, 0xab8fd7c7, 0xd1a06498, 0xf42b3043, 0x7c8361ad), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), SECP256K1_FE_CONST(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000)}}\n+};\n+\n+struct ellsq_enc_test {\n+    unsigned char ell64[64];\n+    unsigned char pubkey[33];\n+};\n+\n+/* Set of (ell64, point) test vectors, selected to maximize branch coverage.\n+ * Created using an independent implementation. */\n+static const struct ellsq_enc_test ellsq_enc_tests[] = {\n+    {{0x54,0xca,0xd2,0x27,0xb2,0xc9,0x8d,0x5f,0x7c,0x78,0x8c,0xfc,0x3d,0xaf,0xd6,0x52,0xf5,0x8f,0x69,0xcf,0xef,0x63,0x2b,0x82,0x2b,0x35,0xd0,0xb0,0xe2,0x4f,0xc0,0x3a,0xd2,0x8c,0xa1,0x4b,0x6f,0x62,0xd4,0x53,0x79,0xc5,0x3f,0x70,0xee,0x40,0x5c,0xa9,0x2c,0xe7,0xb6,0xf9,0x70,0x83,0x13,0x05,0xf2,0x7d,0xc4,0x1e,0xb6,0x9d,0xe0,0x6e}, {0x02,0x11,0x62,0x89,0x03,0x32,0x88,0x91,0xae,0x09,0xd1,0x08,0xd8,0x92,0x43,0xe4,0x7e,0x10,0x9f,0xe7,0xb8,0xbb,0x1e,0x2d,0xf1,0xa3,0xae,0x9b,0x0e,0x78,0x08,0x54,0x9c}},\n+    {{0xfb,0xe6,0xce,0xab,0x4c,0x5f,0xdf,0xa5,0xfb,0xee,0x8f,0x3d,0x09,0xa2,0xf7,0x23,0x53,0xe7,0x4e,0x5a,0x9c,0xd4,0xab,0x8e,0x6a,0x34,0xd4,0x95,0x23,0xa7,0xd1,0xa2,0xc4,0x50,0xb7,0x45,0xda,0xb1,0xaf,0xa9,0x95,0x4b,0x3a,0x35,0x75,0xe4,0xe8,0xe2,0xdb,0x3d,0xa5,0xcd,0x4d,0x56,0x48,0xea,0xd0,0x0a,0x60,0xb4,0xcd,0xfe,0x84,0xb3}, {0x02,0xc0,0x4c,0x84,0x85,0xf9,0x8d,0x56,0x6c,0x79,0xbf,0x33,0xa7,0x0c,0xb2,0x32,0x54,0x9e,0x3d,0xe1,0xc3,0xe3,0x01,0xe3,0x57,0x1c,0x83,0x68,0x97,0xf0,0x7c,0x5d,0x12}},\n+    {{0x71,0x7e,0x63,0xd7,0x71,0xdb,0xda,0x67,0x67,0xd5,0x8f,0x26,0xab,0x5f,0x54,0x9b,0xd2,0xd1,0x8a,0xcf,0x59,0xff,0x50,0x77,0x5f,0x4e,0xb5,0x0a,0xc0,0x17,0x4d,0xf1,0x7d,0xd0,0x34,0xc8,0xed,0x08,0x11,0x61,0x5e,0x3e,0xbb,0x36,0xf8,0xf3,0x3e,0x09,0x23,0x8e,0x4d,0xa8,0xf5,0x01,0x9d,0x37,0x00,0x78,0x4f,0x37,0xc1,0x53,0x53,0x94}, {0x02,0x72,0x81,0x15,0x0c,0xeb,0xc3,0xd7,0xb3,0xbb,0xb9,0x92,0xf5,0x81,0xbb,0xcb,0x9e,0x30,0x4f,0x87,0x44,0xf0,0x19,0x98,0xa7,0x1f,0x5d,0xe1,0x14,0xf8,0x22,0x91,0xc4}},\n+    {{0x01,0xf0,0xbf,0xe4,0xf9,0xbd,0xee,0x52,0x5e,0xb7,0x7c,0x8e,0x35,0x1e,0x1f,0x88,0x3f,0xb9,0xcd,0x37,0x7e,0xf7,0xc5,0xbd,0xde,0xe4,0xf6,0x60,0x64,0x43,0x90,0xf5,0x95,0x3e,0x7d,0x2b,0x6c,0xde,0x36,0x90,0x3e,0xa1,0x34,0x4b,0x0d,0x16,0x33,0x5c,0xc5,0x11,0x5d,0xaa,0x97,0x7c,0x3c,0x2b,0xf9,0x31,0xac,0xde,0x2f,0xf5,0x78,0x9a}, {0x02,0x10,0x44,0x9d,0x7e,0xa0,0x62,0x3e,0x80,0xa5,0x87,0x01,0x9f,0xa5,0x11,0xaf,0xd3,0x94,0xb2,0x55,0xb0,0x8f,0x91,0xb5,0xf7,0x48,0x2a,0xe9,0xd1,0xa1,0xa7,0xfb,0x7c}},\n+    {{0x82,0xd5,0x87,0x1e,0x18,0x37,0x66,0xbd,0x22,0xe1,0x13,0xa8,0x52,0x79,0xaa,0x61,0x7e,0x6b,0x9f,0x73,0x52,0x2c,0xd4,0x6b,0x90,0x59,0xba,0x51,0x97,0xfa,0x56,0x44,0xaf,0x90,0x41,0x89,0x30,0x98,0x7d,0xb7,0xab,0x4a,0x84,0x0c,0x72,0x64,0x1b,0x58,0xb3,0x66,0xe5,0x7c,0x92,0x8c,0x98,0x3a,0x47,0x37,0x82,0x00,0x3c,0x36,0x10,0xab}, {0x03,0xc8,0xb2,0x62,0xf9,0x31,0x69,0x43,0x75,0x51,0x48,0x3b,0x8a,0x61,0x19,0x83,0x82,0xe3,0x11,0x41,0xaf,0x61,0xbf,0x36,0x10,0x0b,0xd0,0x68,0x46,0x5d,0xdd,0xa8,0x40}},\n+    {{0xda,0x82,0x53,0xb4,0x3b,0x5a,0xc2,0x3b,0x42,0x36,0x07,0xe9,0x18,0xab,0x5c,0xaa,0x5d,0x7d,0x34,0x3d,0x77,0xa3,0x99,0x6a,0x42,0xeb,0x33,0x2a,0x3b,0x55,0x1d,0x8c,0xda,0x6c,0xb6,0xf9,0x57,0x4c,0xe3,0x60,0x91,0x2c,0xf4,0x5b,0x90,0x9a,0x96,0x2e,0x4d,0xed,0x63,0xae,0x5a,0xac,0xb0,0xab,0x23,0x29,0x45,0xb1,0x01,0xf7,0x2b,0x62}, {0x02,0xe7,0x28,0x34,0x1d,0xf6,0x93,0x48,0x71,0xb3,0x94,0xbb,0x4f,0xb2,0x8b,0xd8,0xd2,0xdf,0x39,0x92,0x55,0xb0,0x30,0x02,0xed,0x6f,0xc3,0x8f,0x28,0xcf,0xbf,0x53,0x56}},\n+    {{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x03,0x1b,0x41,0x2e,0x7a,0x96,0x6d,0x2c,0x24,0x3d,0xbc,0x5b,0x18,0xb7,0xf9,0xba,0xf1,0x85,0xbc,0xfe,0x41,0x38,0x96,0x04,0x79,0x64,0x1a,0xb1,0xe6,0x3b,0x38,0x1e,0x11}},\n+    {{0xdc,0x30,0x98,0xe4,0x00,0x61,0x83,0x30,0xf3,0x8b,0x19,0xe9,0x20,0x0a,0xdf,0x7f,0xfb,0x96,0x84,0x3f,0xa8,0x3c,0x49,0x1c,0xf6,0x7f,0x34,0xa7,0x90,0xbb,0xcf,0xe1,0x23,0xdc,0x30,0x07,0xa4,0xfd,0x13,0x3a,0x39,0x44,0x0b,0x06,0x03,0x1e,0x9e,0x2c,0x38,0x8e,0x41,0x47,0xaf,0x0e,0x82,0xbe,0xda,0x6d,0x56,0x4b,0xf8,0xcc,0x37,0xb1}, {0x02,0x5b,0x74,0x48,0x15,0x22,0xd4,0xc2,0x9f,0x2e,0x6a,0x2f,0x11,0x7f,0x9e,0x39,0xf9,0xab,0x01,0xb1,0xe9,0xf2,0xc3,0x4c,0x68,0xbe,0x8f,0x53,0x1b,0xe0,0x1f,0x6e,0xa7}},\n+    {{0x35,0xd7,0x0a,0x71,0x2c,0xc0,0x85,0x7f,0x8d,0xb1,0xbc,0x55,0x6a,0x6c,0x4e,0xf8,0x66,0x24,0xfd,0x0a,0x47,0x7f,0x96,0x7e,0xed,0xc0,0x32,0xfc,0xda,0xac,0xe7,0x96,0xc6,0x73,0xc5,0x43,0xd0,0x07,0x34,0x32,0x07,0x85,0x5b,0xeb,0xad,0x85,0xe9,0x4b,0xca,0xc7,0x78,0x2b,0x11,0x57,0x9a,0x70,0xdc,0x88,0xe2,0xa4,0x8d,0x9d,0xf2,0xd4}, {0x02,0xdb,0x21,0xb4,0x8f,0xe9,0xf9,0x95,0x08,0x3a,0x1f,0x9c,0x1f,0x3f,0x4b,0x31,0x1d,0x2c,0x43,0xa1,0x28,0xdb,0xb3,0xa4,0xd4,0x78,0x41,0xe4,0xff,0x5d,0xd0,0x2e,0x61}},\n+    {{0x5f,0xb8,0x07,0xce,0x10,0x0c,0x90,0xd2,0x83,0x7c,0xcf,0xc9,0x4d,0x8f,0x8b,0xa5,0xd3,0x5c,0xd3,0xd6,0xfa,0xfc,0xd2,0xf4,0x1f,0x24,0x5b,0x59,0x6e,0x36,0x00,0x57,0xa0,0x47,0xf8,0x31,0xef,0xf3,0x6f,0x2d,0x7c,0x83,0x30,0x36,0xb2,0x70,0x74,0x5a,0x2c,0xa3,0x2c,0x29,0x05,0x03,0x2d,0x0b,0xe0,0xdb,0xa4,0xa5,0x91,0xc9,0xfb,0xd8}, {0x03,0x41,0x58,0x28,0x65,0x43,0x5e,0xe9,0xc8,0xc9,0x27,0xc3,0x49,0xbd,0x3e,0x43,0x7b,0xce,0x2b,0x5c,0xfc,0xd0,0xc4,0x17,0x77,0xc3,0x4c,0x71,0xc6,0x7b,0x14,0x06,0x93}},\n+    {{0x1e,0x76,0x57,0x72,0xbf,0x72,0xde,0xb8,0x81,0x54,0x16,0xbd,0x54,0x45,0xdd,0x75,0x50,0xcd,0x86,0x7a,0xa2,0x5a,0xc6,0x3f,0x6f,0xd9,0xaf,0xd3,0x2f,0x92,0x1c,0xc8,0x8a,0x06,0x1a,0xb5,0xf6,0x98,0x1b,0x55,0x92,0x1b,0x90,0x5b,0x6f,0x4f,0x3d,0xf4,0x82,0x5d,0x79,0x72,0xd6,0x99,0xe3,0xb4,0x21,0x4e,0x40,0x44,0xcf,0xbe,0x65,0x34}, {0x03,0x90,0xd2,0x94,0x30,0x92,0xec,0x7e,0xd8,0xff,0x5a,0xf7,0x04,0x43,0x2d,0x0d,0xbe,0xb0,0x33,0x7c,0xbf,0x58,0x22,0x87,0x18,0x32,0x76,0x38,0x68,0x1f,0x70,0xd7,0xf0}},\n+    {{0x86,0xef,0x92,0xfd,0x28,0x09,0x85,0x4f,0x74,0xf7,0x5a,0xeb,0xbe,0xa1,0x8a,0xee,0xc0,0xee,0xdd,0x4e,0x81,0x92,0xc8,0x8c,0xd7,0xcf,0xf5,0xdf,0xc0,0x8a,0x57,0xdc,0x32,0x73,0xbf,0x6f,0x39,0x2d,0xee,0x48,0x4a,0x72,0x2c,0x3d,0xb0,0x0c,0x0e,0xfb,0x40,0xd5,0x1e,0x8a,0x72,0xfc,0xfb,0x78,0x3f,0xa7,0xeb,0xd4,0x30,0x82,0xdb,0x71}, {0x02,0x31,0x74,0x79,0x29,0x80,0x2d,0x79,0x76,0x02,0x26,0x71,0xb2,0xf7,0x5a,0xc0,0x31,0x18,0x56,0xb3,0x84,0xf4,0xb9,0xa8,0x00,0x0d,0x44,0xa2,0xab,0xc5,0x90,0x3a,0xd4}}\n+};\n+\n+void run_ellsq_tests(void) {\n+    int i = 0;\n+    /* Verify that secp256k1_ellsq_fe_to_ge_var maps everything to curve points for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        secp256k1_fe t;\n+        secp256k1_ge g;\n+        random_field_element_test(&t);\n+        secp256k1_ellsq_fe_to_ge_var(&g, &t);\n+        CHECK(secp256k1_ge_is_valid_var(&g));\n+    }\n+    /* Verify that secp256k1_ellsq_ge_to_fe_var + fe_to_ge_var roundtrips for random inputs. */\n+    for (i = 0; i < 1000*count; i++) {\n+        int j;\n+        secp256k1_ge g;\n+        random_group_element_test(&g);\n+        for (j = 0; j < 4; j++) {\n+            secp256k1_fe f;\n+            if (secp256k1_ellsq_ge_to_fe_var(&f, &g, j)) {\n+                secp256k1_ge g2;\n+                secp256k1_ellsq_fe_to_ge_var(&g2, &f);\n+                ge_equals_ge(&g, &g2);\n+            }\n+        }\n+    }\n+    /* Verify precomputed test cases. */\n+    for (i = 0; i < (int)sizeof(ellsq_tests) / (int)sizeof(ellsq_tests[0]); ++i) {\n+        int j;\n+        const struct ellsq_test *test = ellsq_tests + i;\n+        for (j = 0; j < 4; j++) {\n+            secp256k1_fe f;\n+            int ret;\n+            ret = secp256k1_ellsq_ge_to_fe_var(&f, &test->point, j);\n+            CHECK(ret == ((test->enc_bitmap >> j) & 1));\n+            if (ret) {\n+                secp256k1_ge g;\n+                CHECK(check_fe_equal(&f, &test->encs[j]));\n+                secp256k1_ellsq_fe_to_ge_var(&g, &f);\n+                ge_equals_ge(&test->point, &g);\n+            }\n+        }\n+    }\n+    /* Verify that secp256k1_ellsq_encode + decode roundtrips. */\n+    for (i = 0; i < 1000*count; i++) {\n+        unsigned char rnd32[32];\n+        unsigned char ell64[64];\n+        secp256k1_ge g, g2;\n+        secp256k1_pubkey pubkey, pubkey2;\n+        random_group_element_test(&g);\n+        secp256k1_pubkey_save(&pubkey, &g);\n+        secp256k1_testrand256(rnd32);\n+        secp256k1_ellsq_encode(ctx, ell64, rnd32, &pubkey);\n+        secp256k1_ellsq_decode(ctx, &pubkey2, ell64);\n+        secp256k1_pubkey_load(ctx, &g2, &pubkey2);\n+        ge_equals_ge(&g, &g2);\n+    }\n+    /* Verify decoding of precomputed test cases. */\n+    for (i = 0; i < (int)sizeof(ellsq_enc_tests) / (int)sizeof(ellsq_enc_tests[0]); ++i) {\n+        secp256k1_pubkey pubkey;\n+        unsigned char pk33[33];\n+        size_t size = 33;\n+        secp256k1_ellsq_decode(ctx, &pubkey, ellsq_enc_tests[i].ell64);\n+        secp256k1_ec_pubkey_serialize(ctx, pk33, &size, &pubkey, SECP256K1_EC_COMPRESSED);\n+        CHECK(size == 33);\n+        CHECK(secp256k1_memcmp_var(&pk33, ellsq_enc_tests[i].pubkey, size) == 0);\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "e1003052f4c623092457fe3f4e482c27486db441",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -120,12 +120,11 @@ int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pub\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output_pubkey != NULL);\n     memset(output_pubkey, 0, sizeof(*output_pubkey));\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_pubkey_save(output_pubkey, &pk);\n@@ -137,13 +136,12 @@ int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const u\n     unsigned char pk_expected32[32];\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(internal_pubkey != NULL);\n     ARG_CHECK(tweaked_pubkey32 != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     if (!secp256k1_xonly_pubkey_load(ctx, &pk, internal_pubkey)\n-        || !secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32)) {\n+        || !secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&pk.x);\n@@ -260,7 +258,6 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     int ret;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(keypair != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n@@ -273,7 +270,7 @@ int secp256k1_keypair_xonly_tweak_add(const secp256k1_context* ctx, secp256k1_ke\n     }\n \n     ret &= secp256k1_ec_seckey_tweak_add_helper(&sk, tweak32);\n-    ret &= secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &pk, tweak32);\n+    ret &= secp256k1_ec_pubkey_tweak_add_helper(&pk, tweak32);\n \n     secp256k1_declassify(ctx, &ret, sizeof(ret));\n     if (ret) {"
      },
      {
        "sha": "dd53f9e12aedefaf3b43f654c98a0d52cde8ea05",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -197,19 +197,19 @@ void test_xonly_pubkey_tweak(void) {\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n     ecount = 0;\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(none, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add(sign, &output_pk, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, NULL, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* NULL internal_xonly_pk zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     /* NULL tweak zeroes the output_pk */\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n \n@@ -274,20 +274,20 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(verify, &output_xonly_pk, &pk_parity, &output_pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &output_xonly_pk) == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(none, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_xonly_pubkey_tweak_add_check(sign, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, tweak) == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, NULL, pk_parity, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     /* invalid pk_parity value */\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, 2, &internal_xonly_pk, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, NULL, tweak) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(verify, buf32, pk_parity, &internal_xonly_pk, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     memset(tweak, 1, sizeof(tweak));\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &internal_xonly_pk, NULL, &internal_pk) == 1);\n@@ -306,7 +306,7 @@ void test_xonly_pubkey_tweak_check(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -479,15 +479,15 @@ void test_keypair_add(void) {\n     memset(overflows, 0xFF, 32);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n \n-    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(none, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_keypair_xonly_tweak_add(sign, &keypair, tweak) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, NULL, tweak) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     /* This does not set the keypair to zeroes */\n     CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) != 0);\n "
      },
      {
        "sha": "e7906eb62e0ea10248ad31e8b6faac9a51f7b117",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -40,7 +40,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n     ARG_CHECK(recid >= 0 && recid <= 3);\n@@ -60,7 +60,7 @@ int secp256k1_ecdsa_recoverable_signature_parse_compact(const secp256k1_context*\n int secp256k1_ecdsa_recoverable_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, int *recid, const secp256k1_ecdsa_recoverable_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(recid != NULL);\n@@ -75,7 +75,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     secp256k1_scalar r, s;\n     int recid;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(sigin != NULL);\n \n@@ -84,7 +84,7 @@ int secp256k1_ecdsa_recoverable_signature_convert(const secp256k1_context* ctx,\n     return 1;\n }\n \n-static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n+static int secp256k1_ecdsa_sig_recover(const secp256k1_scalar *sigr, const secp256k1_scalar* sigs, secp256k1_ge *pubkey, const secp256k1_scalar *message, int recid) {\n     unsigned char brx[32];\n     secp256k1_fe fx;\n     secp256k1_ge x;\n@@ -115,7 +115,7 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n     secp256k1_scalar_mul(&u1, &rn, message);\n     secp256k1_scalar_negate(&u1, &u1);\n     secp256k1_scalar_mul(&u2, &rn, sigs);\n-    secp256k1_ecmult(ctx, &qj, &xj, &u2, &u1);\n+    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n     secp256k1_ge_set_gej_var(pubkey, &qj);\n     return !secp256k1_gej_is_infinity(&qj);\n }\n@@ -140,15 +140,14 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     secp256k1_scalar m;\n     int recid;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n     VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msghash32, NULL);\n-    if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n+    if (secp256k1_ecdsa_sig_recover(&r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);\n         return 1;\n     } else {"
      },
      {
        "sha": "2fcd46d206abd8d3258bf300c2c3bc00cfd9779e",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -92,20 +92,20 @@ void test_ecdsa_recovery_api(void) {\n \n     /* Check bad contexts and NULLs for recovery */\n     ecount = 0;\n-    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n \n     /* Check NULLs for conversion */\n     CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);"
      },
      {
        "sha": "3650e7c77b4b2a17eca3d7ba96f0e299b945cefe",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -122,7 +122,7 @@ static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned c\n     secp256k1_scalar_set_b32(e, buf, NULL);\n }\n \n-int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+static int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n@@ -216,7 +216,6 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     int overflow;\n \n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(sig64 != NULL);\n     ARG_CHECK(msg != NULL || msglen == 0);\n     ARG_CHECK(pubkey != NULL);\n@@ -241,7 +240,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);\n     secp256k1_gej_set_ge(&pkj, &pk);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\n+    secp256k1_ecmult(&rj, &pkj, &e, &s);\n \n     secp256k1_ge_set_gej_var(&r, &rj);\n     if (secp256k1_ge_is_infinity(&r)) {"
      },
      {
        "sha": "096dbad8a8a4a466f3c530e7c0fba7bef507e6a6",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -193,22 +193,22 @@ void test_schnorrsig_api(void) {\n \n     ecount = 0;\n     CHECK(secp256k1_schnorrsig_sign(sign, sig, msg, &keypairs[0], NULL) == 1);\n-    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 1);\n-    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 2);\n+    CHECK(secp256k1_schnorrsig_verify(none, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_schnorrsig_verify(sign, sig, msg, sizeof(msg), &pk[0]) == 1);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &pk[0]) == 1);\n-    CHECK(ecount == 2);\n+    CHECK(ecount == 0);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, NULL, msg, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 3);\n+    CHECK(ecount == 1);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, sizeof(msg), &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, NULL, 0, &pk[0]) == 0);\n-    CHECK(ecount == 4);\n+    CHECK(ecount == 2);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), NULL) == 0);\n-    CHECK(ecount == 5);\n+    CHECK(ecount == 3);\n     CHECK(secp256k1_schnorrsig_verify(vrfy, sig, msg, sizeof(msg), &zero_pk) == 0);\n-    CHECK(ecount == 6);\n+    CHECK(ecount == 4);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);"
      },
      {
        "sha": "5b0e2f32c5be5527035b538e1f46faf603c29822",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 11,
        "deletions": 22,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -73,15 +73,13 @@ static const secp256k1_callback default_error_callback = {\n };\n \n struct secp256k1_context_struct {\n-    secp256k1_ecmult_context ecmult_ctx;\n     secp256k1_ecmult_gen_context ecmult_gen_ctx;\n     secp256k1_callback illegal_callback;\n     secp256k1_callback error_callback;\n     int declassify;\n };\n \n static const secp256k1_context secp256k1_context_no_precomp_ = {\n-    { 0 },\n     { 0 },\n     { secp256k1_default_illegal_callback_fn, 0 },\n     { secp256k1_default_error_callback_fn, 0 },\n@@ -103,9 +101,6 @@ size_t secp256k1_context_preallocated_size(unsigned int flags) {\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -115,9 +110,6 @@ size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n     if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n         ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n     }\n-    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n-        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n-    }\n     return ret;\n }\n \n@@ -139,17 +131,13 @@ secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigne\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n-    secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     /* Flags have been checked by secp256k1_context_preallocated_size. */\n     VERIFY_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_CONTEXT);\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n         secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n-    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n-    }\n     ret->declassify = !!(flags & SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY);\n \n     return (secp256k1_context*) ret;\n@@ -176,7 +164,6 @@ secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context*\n     ret = (secp256k1_context*)prealloc;\n     memcpy(ret, ctx, prealloc_size);\n     secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n-    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n@@ -194,7 +181,6 @@ secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n     ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n-        secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n     }\n }\n@@ -458,7 +444,6 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_scalar r, s;\n     secp256k1_scalar m;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(msghash32 != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(pubkey != NULL);\n@@ -467,7 +452,7 @@ int secp256k1_ecdsa_verify(const secp256k1_context* ctx, const secp256k1_ecdsa_s\n     secp256k1_ecdsa_signature_load(ctx, &r, &s, sig);\n     return (!secp256k1_scalar_is_high(&s) &&\n             secp256k1_pubkey_load(ctx, &q, pubkey) &&\n-            secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &r, &s, &q, &m));\n+            secp256k1_ecdsa_sig_verify(&r, &s, &q, &m));\n }\n \n static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len) {\n@@ -685,24 +670,23 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak32);\n }\n \n-static int secp256k1_ec_pubkey_tweak_add_helper(const secp256k1_ecmult_context* ecmult_ctx, secp256k1_ge *p, const unsigned char *tweak32) {\n+static int secp256k1_ec_pubkey_tweak_add_helper(secp256k1_ge *p, const unsigned char *tweak32) {\n     secp256k1_scalar term;\n     int overflow = 0;\n     secp256k1_scalar_set_b32(&term, tweak32, &overflow);\n-    return !overflow && secp256k1_eckey_pubkey_tweak_add(ecmult_ctx, p, &term);\n+    return !overflow && secp256k1_eckey_pubkey_tweak_add(p, &term);\n }\n \n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32) {\n     secp256k1_ge p;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n-    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&ctx->ecmult_ctx, &p, tweak32);\n+    ret = ret && secp256k1_ec_pubkey_tweak_add_helper(&p, tweak32);\n     if (ret) {\n         secp256k1_pubkey_save(pubkey, &p);\n     }\n@@ -740,15 +724,14 @@ int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey\n     int ret = 0;\n     int overflow = 0;\n     VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n     ARG_CHECK(pubkey != NULL);\n     ARG_CHECK(tweak32 != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak32, &overflow);\n     ret = !overflow && secp256k1_pubkey_load(ctx, &p, pubkey);\n     memset(pubkey, 0, sizeof(*pubkey));\n     if (ret) {\n-        if (secp256k1_eckey_pubkey_tweak_mul(&ctx->ecmult_ctx, &p, &factor)) {\n+        if (secp256k1_eckey_pubkey_tweak_mul(&p, &factor)) {\n             secp256k1_pubkey_save(pubkey, &p);\n         } else {\n             ret = 0;\n@@ -771,6 +754,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej Qj;\n     secp256k1_ge Q;\n \n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubnonce != NULL);\n     memset(pubnonce, 0, sizeof(*pubnonce));\n     ARG_CHECK(n >= 1);\n@@ -779,6 +763,7 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n     secp256k1_gej_set_infinity(&Qj);\n \n     for (i = 0; i < n; i++) {\n+        ARG_CHECK(pubnonces[i] != NULL);\n         secp256k1_pubkey_load(ctx, &Q, pubnonces[i]);\n         secp256k1_gej_add_ge(&Qj, &Qj, &Q);\n     }\n@@ -818,3 +803,7 @@ int secp256k1_tagged_sha256(const secp256k1_context* ctx, unsigned char *hash32,\n #ifdef ENABLE_MODULE_SCHNORRSIG\n # include \"modules/schnorrsig/main_impl.h\"\n #endif\n+\n+#ifdef ENABLE_MODULE_ELLSQ\n+# include \"modules/ellsq/main_impl.h\"\n+#endif"
      },
      {
        "sha": "e3319310ca8b1dcfc9f79c4c0b6ed8714a73b4c5",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 207,
        "deletions": 81,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -273,22 +273,22 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sign(sign, &sig, ctmp, ctmp, NULL, NULL) == 1);\n     VG_CHECK(&sig, sizeof(sig));\n     CHECK(ecount2 == 10);\n-    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 0);\n-    CHECK(ecount2 == 11);\n+    CHECK(secp256k1_ecdsa_verify(sign, &sig, ctmp, &pubkey) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ecdsa_verify(vrfy, &sig, ctmp, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 12);\n+    CHECK(secp256k1_ec_pubkey_tweak_add(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_tweak_add(vrfy, &pubkey, ctmp) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n-    CHECK(ecount2 == 13);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 1);\n+    CHECK(ecount2 == 10);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n@@ -298,9 +298,9 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_context_randomize(vrfy, NULL) == 1);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_context_randomize(sign, ctmp) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 14);\n+    CHECK(ecount2 == 11);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -314,8 +314,8 @@ void run_context_tests(int use_prealloc) {\n     CHECK(secp256k1_ecdsa_sig_sign(&both->ecmult_gen_ctx, &sigr, &sigs, &key, &msg, &nonce, NULL));\n \n     /* try verifying */\n-    CHECK(secp256k1_ecdsa_sig_verify(&vrfy->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n-    CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n     if (use_prealloc) {\n@@ -811,12 +811,29 @@ void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\n     uint16_to_signed30(&x, in);\n     nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4] | x.v[5] | x.v[6] | x.v[7] | x.v[8]) != 0;\n     uint16_to_signed30(&m.modulus, mod);\n-    mutate_sign_signed30(&m.modulus);\n \n     /* compute 1/modulus mod 2^30 */\n     m.modulus_inv30 = modinv2p64(m.modulus.v[0]) & 0x3fffffff;\n     CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\n \n+    /* Test secp256k1_jacobi32_maybe_var. */\n+    if (nonzero) {\n+        uint16_t sqr[16], negone[16];\n+        mulmod256(sqr, in, in, mod);\n+        uint16_to_signed30(&x, sqr);\n+        CHECK(secp256k1_jacobi32_maybe_var(&x, &m) == nonzero);\n+        if ((mod[0] & 3) == 3) {\n+            /* If mod % 4 == 3, x and -x have opposite jacobi symbols. */\n+            negone[0] = mod[0] - 1;\n+            for (i = 1; i < 16; ++i) negone[i] = mod[i];\n+            mulmod256(sqr, sqr, negone, mod);\n+            uint16_to_signed30(&x, sqr);\n+            CHECK(secp256k1_jacobi32_maybe_var(&x, &m) == -nonzero);\n+        }\n+    }\n+\n+    uint16_to_signed30(&x, in);\n+    mutate_sign_signed30(&m.modulus);\n     for (vartime = 0; vartime < 2; ++vartime) {\n         /* compute inverse */\n         (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n@@ -884,12 +901,29 @@ void test_modinv64_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\n     uint16_to_signed62(&x, in);\n     nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4]) != 0;\n     uint16_to_signed62(&m.modulus, mod);\n-    mutate_sign_signed62(&m.modulus);\n \n     /* compute 1/modulus mod 2^62 */\n     m.modulus_inv62 = modinv2p64(m.modulus.v[0]) & M62;\n     CHECK(((m.modulus_inv62 * m.modulus.v[0]) & M62) == 1);\n \n+    /* Test secp256k1_jacobi64_maybe_var. */\n+    if (nonzero) {\n+        uint16_t sqr[16], negone[16];\n+        mulmod256(sqr, in, in, mod);\n+        uint16_to_signed62(&x, sqr);\n+        CHECK(secp256k1_jacobi64_maybe_var(&x, &m) == 1);\n+        if ((mod[0] & 3) == 3) {\n+            /* If mod % 4 == 3, x and -x have opposite jacobi symbols. */\n+            negone[0] = mod[0] - 1;\n+            for (i = 1; i < 16; ++i) negone[i] = mod[i];\n+            mulmod256(sqr, sqr, negone, mod);\n+            uint16_to_signed62(&x, sqr);\n+            CHECK(secp256k1_jacobi64_maybe_var(&x, &m) == -1);\n+        }\n+    }\n+\n+    uint16_to_signed62(&x, in);\n+    mutate_sign_signed62(&m.modulus);\n     for (vartime = 0; vartime < 2; ++vartime) {\n         /* compute inverse */\n         (vartime ? secp256k1_modinv64_var : secp256k1_modinv64)(&x, &m);\n@@ -2659,11 +2693,14 @@ void run_sqrt(void) {\n         for (j = 0; j < count; j++) {\n             random_fe(&x);\n             secp256k1_fe_sqr(&s, &x);\n+            CHECK(secp256k1_fe_jacobi_var(&s) == 1);\n             test_sqrt(&s, &x);\n             secp256k1_fe_negate(&t, &s, 1);\n+            CHECK(secp256k1_fe_jacobi_var(&t) == -1);\n             test_sqrt(&t, NULL);\n             secp256k1_fe_mul(&t, &s, &ns);\n             test_sqrt(&t, NULL);\n+\n         }\n     }\n }\n@@ -3416,6 +3453,84 @@ void run_group_decompress(void) {\n \n /***** ECMULT TESTS *****/\n \n+void test_pre_g_table(const secp256k1_ge_storage * pre_g, size_t n) {\n+    /* Tests the pre_g / pre_g_128 tables for consistency.\n+     * For independent verification we take a \"geometric\" approach to verification.\n+     * We check that every entry is on-curve.\n+     * We check that for consecutive entries p and q, that p + gg - q = 0 by checking\n+     *  (1) p, gg, and -q are colinear.\n+     *  (2) p, gg, and -q are all distinct.\n+     * where gg is twice the generator, where the generator is the first table entry.\n+     *\n+     * Checking the table's generators are correct is done in run_ecmult_pre_g.\n+     */\n+    secp256k1_gej g2;\n+    secp256k1_ge p, q, gg;\n+    secp256k1_fe dpx, dpy, dqx, dqy;\n+    size_t i;\n+\n+    CHECK(0 < n);\n+\n+    secp256k1_ge_from_storage(&p, &pre_g[0]);\n+    secp256k1_fe_verify(&p.x);\n+    secp256k1_fe_verify(&p.y);\n+    CHECK(secp256k1_ge_is_valid_var(&p));\n+\n+    secp256k1_gej_set_ge(&g2, &p);\n+    secp256k1_gej_double_var(&g2, &g2, NULL);\n+    secp256k1_ge_set_gej_var(&gg, &g2);\n+    for (i = 1; i < n; ++i) {\n+        secp256k1_fe_negate(&dpx, &p.x, 1); secp256k1_fe_add(&dpx, &gg.x); secp256k1_fe_normalize_weak(&dpx);\n+        secp256k1_fe_negate(&dpy, &p.y, 1); secp256k1_fe_add(&dpy, &gg.y); secp256k1_fe_normalize_weak(&dpy);\n+        /* Check that p is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dpx) || !secp256k1_fe_normalizes_to_zero_var(&dpy));\n+\n+        secp256k1_ge_from_storage(&q, &pre_g[i]);\n+        secp256k1_fe_verify(&q.x);\n+        secp256k1_fe_verify(&q.y);\n+        CHECK(secp256k1_ge_is_valid_var(&q));\n+\n+        secp256k1_fe_negate(&dqx, &q.x, 1); secp256k1_fe_add(&dqx, &gg.x); secp256k1_fe_normalize_weak(&dqx);\n+        dqy = q.y; secp256k1_fe_add(&dqy, &gg.y); secp256k1_fe_normalize_weak(&dqy);\n+        /* Check that -q is not equal to gg */\n+        CHECK(!secp256k1_fe_normalizes_to_zero_var(&dqx) || !secp256k1_fe_normalizes_to_zero_var(&dqy));\n+\n+        /* Check that -q is not equal to p */\n+        CHECK(!secp256k1_fe_equal_var(&dpx, &dqx) || !secp256k1_fe_equal_var(&dpy, &dqy));\n+\n+        /* Check that p, -q and gg are colinear */\n+        secp256k1_fe_mul(&dpx, &dpx, &dqy);\n+        secp256k1_fe_mul(&dpy, &dpy, &dqx);\n+        CHECK(secp256k1_fe_equal_var(&dpx, &dpy));\n+\n+        p = q;\n+    }\n+}\n+\n+void run_ecmult_pre_g(void) {\n+    secp256k1_ge_storage gs;\n+    secp256k1_gej gj;\n+    secp256k1_ge g;\n+    size_t i;\n+\n+    /* Check that the pre_g and pre_g_128 tables are consistent. */\n+    test_pre_g_table(secp256k1_pre_g, ECMULT_TABLE_SIZE(WINDOW_G));\n+    test_pre_g_table(secp256k1_pre_g_128, ECMULT_TABLE_SIZE(WINDOW_G));\n+\n+    /* Check the first entry from the pre_g table. */\n+    secp256k1_ge_to_storage(&gs, &secp256k1_ge_const_g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g[0], sizeof(gs)) == 0);\n+\n+    /* Check the first entry from the pre_g_128 table. */\n+    secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n+    for (i = 0; i < 128; ++i) {\n+      secp256k1_gej_double_var(&gj, &gj, NULL);\n+    }\n+    secp256k1_ge_set_gej(&g, &gj);\n+    secp256k1_ge_to_storage(&gs, &g);\n+    CHECK(secp256k1_memcmp_var(&gs, &secp256k1_pre_g_128[0], sizeof(gs)) == 0);\n+}\n+\n void run_ecmult_chain(void) {\n     /* random starting point A (on the curve) */\n     secp256k1_gej a = SECP256K1_GEJ_CONST(\n@@ -3448,7 +3563,7 @@ void run_ecmult_chain(void) {\n     x = a;\n     for (i = 0; i < 200*count; i++) {\n         /* in each iteration, compute X = xn*X + gn*G; */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &x, &x, &xn, &gn);\n+        secp256k1_ecmult(&x, &x, &xn, &gn);\n         /* also compute ae and ge: the actual accumulated factors for A and G */\n         /* if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G) */\n         secp256k1_scalar_mul(&ae, &ae, &xn);\n@@ -3474,7 +3589,7 @@ void run_ecmult_chain(void) {\n         }\n     }\n     /* redo the computation, but directly with the resulting ae and ge coefficients: */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &x2, &a, &ae, &ge);\n+    secp256k1_ecmult(&x2, &a, &ae, &ge);\n     secp256k1_gej_neg(&x2, &x2);\n     secp256k1_gej_add_var(&x2, &x2, &x, NULL);\n     CHECK(secp256k1_gej_is_infinity(&x2));\n@@ -3492,8 +3607,8 @@ void test_point_times_order(const secp256k1_gej *point) {\n     size_t psize = 65;\n     random_scalar_order_test(&x);\n     secp256k1_scalar_negate(&nx, &x);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n+    secp256k1_ecmult(&res1, point, &x, &x); /* calc res1 = x * point + x * G; */\n+    secp256k1_ecmult(&res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n     secp256k1_ge_set_gej(&res3, &res1);\n@@ -3503,13 +3618,13 @@ void test_point_times_order(const secp256k1_gej *point) {\n     psize = 65;\n     CHECK(secp256k1_eckey_pubkey_serialize(&res3, pub, &psize, 1) == 0);\n     /* check zero/one edge cases */\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &zero);\n+    secp256k1_ecmult(&res1, point, &zero, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &one, &zero);\n+    secp256k1_ecmult(&res1, point, &one, &zero);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_gej(&res3, point);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &res1, point, &zero, &one);\n+    secp256k1_ecmult(&res1, point, &zero, &one);\n     secp256k1_ge_set_gej(&res3, &res1);\n     ge_equals_ge(&res3, &secp256k1_ge_const_g);\n }\n@@ -3568,9 +3683,9 @@ void test_ecmult_target(const secp256k1_scalar* target, int mode) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p2j, &n2);\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &ptj, target);\n     } else if (mode == 1) {\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p1j, &pj, &n1, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &p2j, &pj, &n2, &zero);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptj, &pj, target, &zero);\n+        secp256k1_ecmult(&p1j, &pj, &n1, &zero);\n+        secp256k1_ecmult(&p2j, &pj, &n2, &zero);\n+        secp256k1_ecmult(&ptj, &pj, target, &zero);\n     } else {\n         secp256k1_ecmult_const(&p1j, &p, &n1, 256);\n         secp256k1_ecmult_const(&p2j, &p, &n2, 256);\n@@ -3753,7 +3868,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -3768,32 +3883,32 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         pt[1] = secp256k1_ge_const_g;\n \n         /* only G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        secp256k1_ecmult(&r2, &ptgj, &szero, &sc[0]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_ecmult(&r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3810,7 +3925,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3820,7 +3935,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3833,7 +3948,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -3846,7 +3961,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -3861,7 +3976,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -3879,8 +3994,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n         }\n \n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &r, &sc[0], &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3902,8 +4017,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_ecmult(&r2, &p0j, &rs, &szero);\n+        CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -3916,13 +4031,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -3946,8 +4061,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_scalar_set_int(&t1, (t1i + 1) / 2);\n                 secp256k1_scalar_cond_negate(&t1, t1i & 1);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t0p, &ptgj, &t0, &szero);\n-                secp256k1_ecmult(&ctx->ecmult_ctx, &t1p, &ptgj, &t1, &szero);\n+                secp256k1_ecmult(&t0p, &ptgj, &t0, &szero);\n+                secp256k1_ecmult(&t1p, &ptgj, &t1, &szero);\n \n                 for(s0i = 0; s0i < TOP; s0i++) {\n                     for(s1i = 0; s1i < TOP; s1i++) {\n@@ -3966,8 +4081,8 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_mul(&tmp2, &t1, &sc[1]);\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n-                        secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        secp256k1_ecmult(&expected, &ptgj, &tmp1, &szero);\n+                        CHECK(ecmult_multi(&ctx->error_callback, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -3994,7 +4109,7 @@ void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n     scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    CHECK(!ecmult_multi(&ctx->error_callback, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n }\n \n@@ -4116,15 +4231,15 @@ void test_ecmult_multi_batching(void) {\n \n     /* Get random scalars and group elements and compute result */\n     random_scalar_order(&scG);\n-    secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r2, &szero, &scG);\n+    secp256k1_ecmult(&r2, &r2, &szero, &scG);\n     for(i = 0; i < n_points; i++) {\n         secp256k1_ge ptg;\n         secp256k1_gej ptgj;\n         random_group_element_test(&ptg);\n         secp256k1_gej_set_ge(&ptgj, &ptg);\n         pt[i] = ptg;\n         random_scalar_order(&sc[i]);\n-        secp256k1_ecmult(&ctx->ecmult_ctx, &ptgj, &ptgj, &sc[i], NULL);\n+        secp256k1_ecmult(&ptgj, &ptgj, &sc[i], NULL);\n         secp256k1_gej_add_var(&r2, &r2, &ptgj, NULL);\n     }\n     data.sc = sc;\n@@ -4134,7 +4249,7 @@ void test_ecmult_multi_batching(void) {\n     /* Test with empty scratch space. It should compute the correct result using\n      * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4143,7 +4258,7 @@ void test_ecmult_multi_batching(void) {\n      * ecmult_multi selects strauss which requires more memory. It should\n      * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n     secp256k1_gej_add_var(&r, &r, &r2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&r));\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -4157,7 +4272,7 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n         secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n@@ -5262,22 +5377,24 @@ void test_ecdsa_sign_verify(void) {\n     secp256k1_scalar msg, key;\n     secp256k1_scalar sigr, sigs;\n     int getrec;\n-    /* Initialize recid to suppress a false positive -Wconditional-uninitialized in clang.\n-       VG_UNDEF ensures that valgrind will still treat the variable as uninitialized. */\n-    int recid = -1; VG_UNDEF(&recid, sizeof(recid));\n+    int recid;\n     random_scalar_order_test(&msg);\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n     getrec = secp256k1_testrand_bits(1);\n-    random_sign(&sigr, &sigs, &key, &msg, getrec?&recid:NULL);\n+    /* The specific way in which this conditional is written sidesteps a potential bug in clang.\n+       See the commit messages of the commit that introduced this comment for details. */\n     if (getrec) {\n+        random_sign(&sigr, &sigs, &key, &msg, &recid);\n         CHECK(recid >= 0 && recid < 4);\n+    } else {\n+        random_sign(&sigr, &sigs, &key, &msg, NULL);\n     }\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sigr, &sigs, &pub, &msg));\n }\n \n void run_ecdsa_sign_verify(void) {\n@@ -5955,7 +6072,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &keyj, &sr);\n         secp256k1_ge_set_gej(&key, &keyj);\n         msg = ss;\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with r of zero fails. */\n@@ -5974,7 +6091,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 0);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey_mods_zero, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify( &sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with s of zero fails. */\n@@ -5993,7 +6110,7 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&msg, 0);\n         secp256k1_scalar_set_int(&sr, 1);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Verify signature with message 0 passes. */\n@@ -6021,14 +6138,14 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_int(&sr, 2);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message 1 passes. */\n@@ -6062,15 +6179,15 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n         CHECK(secp256k1_eckey_pubkey_parse(&key2, pubkey2, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 2);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key2, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key2, &msg) == 0);\n     }\n \n     /* Verify signature with message -1 passes. */\n@@ -6096,12 +6213,12 @@ void test_ecdsa_edge_cases(void) {\n         secp256k1_scalar_negate(&msg, &msg);\n         secp256k1_scalar_set_b32(&sr, csr, NULL);\n         CHECK(secp256k1_eckey_pubkey_parse(&key, pubkey, 33));\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_negate(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 1);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 1);\n         secp256k1_scalar_set_int(&ss, 3);\n         secp256k1_scalar_inverse_var(&ss, &ss);\n-        CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sr, &ss, &key, &msg) == 0);\n+        CHECK(secp256k1_ecdsa_sig_verify(&sr, &ss, &key, &msg) == 0);\n     }\n \n     /* Signature where s would be zero. */\n@@ -6347,10 +6464,10 @@ void test_ecdsa_openssl(void) {\n     CHECK(ec_key != NULL);\n     CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n     CHECK(secp256k1_ecdsa_sig_parse(&sigr, &sigs, signature, sigsize));\n-    CHECK(secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg));\n+    CHECK(secp256k1_ecdsa_sig_verify(&sigr, &sigs, &q, &msg));\n     secp256k1_scalar_set_int(&one, 1);\n     secp256k1_scalar_add(&msg2, &msg, &one);\n-    CHECK(!secp256k1_ecdsa_sig_verify(&ctx->ecmult_ctx, &sigr, &sigs, &q, &msg2));\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sigr, &sigs, &q, &msg2));\n \n     random_sign(&sigr, &sigs, &key, &msg, NULL);\n     CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sigr, &sigs));\n@@ -6383,6 +6500,10 @@ void run_ecdsa_openssl(void) {\n # include \"modules/schnorrsig/tests_impl.h\"\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSQ\n+# include \"modules/ellsq/tests_impl.h\"\n+#endif\n+\n void run_secp256k1_memczero_test(void) {\n     unsigned char buf1[6] = {1, 2, 3, 4, 5, 6};\n     unsigned char buf2[sizeof(buf1)];\n@@ -6618,6 +6739,7 @@ int main(int argc, char **argv) {\n     run_group_decompress();\n \n     /* ecmult tests */\n+    run_ecmult_pre_g();\n     run_wnaf();\n     run_point_times_order();\n     run_ecmult_near_split_bound();\n@@ -6669,6 +6791,10 @@ int main(int argc, char **argv) {\n     run_schnorrsig_tests();\n #endif\n \n+#ifdef ENABLE_MODULE_ELLSQ\n+    run_ellsq_tests();\n+#endif\n+\n     /* util tests */\n     run_secp256k1_memczero_test();\n "
      },
      {
        "sha": "4d96dd947b46f8beea95ca5631a7bf1b310e9463",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fffcce1173506c41e90a18f516fd32ee32a8af4c/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "patch": "@@ -163,7 +163,7 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     }\n }\n \n-void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj) {\n+void test_exhaustive_ecmult(const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j, r_log;\n     uint64_t iter = 0;\n     for (r_log = 1; r_log < EXHAUSTIVE_TEST_ORDER; r_log++) {\n@@ -175,7 +175,7 @@ void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *gr\n                 secp256k1_scalar_set_int(&na, i);\n                 secp256k1_scalar_set_int(&ng, j);\n \n-                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                secp256k1_ecmult(&tmp, &groupj[r_log], &na, &ng);\n                 ge_equals_gej(&group[(i * r_log + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n \n                 if (i > 0) {\n@@ -219,7 +219,7 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                     }\n                 }\n@@ -430,7 +430,7 @@ int main(int argc, char** argv) {\n         /* Run the tests */\n         test_exhaustive_endomorphism(group);\n         test_exhaustive_addition(group, groupj);\n-        test_exhaustive_ecmult(ctx, group, groupj);\n+        test_exhaustive_ecmult(group, groupj);\n         test_exhaustive_ecmult_multi(ctx, group);\n         test_exhaustive_sign(ctx, group);\n         test_exhaustive_verify(ctx, group);"
      }
    ]
  },
  {
    "sha": "9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
    "node_id": "C_kwDOABII59oAKDllNDMyZmU2MDdmMzMyZTZiOGZmM2NhNzBlZmRiNWM5YjhlOWY5OTU",
    "commit": {
      "author": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-02T21:44:06Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-06T21:12:47Z"
      },
      "message": "Encode/Decode CPubKey from to/from elligator-squared representation",
      "tree": {
        "sha": "810a200fda3cfcd7bd9c72022f2fe4f58cb2c6d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/810a200fda3cfcd7bd9c72022f2fe4f58cb2c6d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fffcce1173506c41e90a18f516fd32ee32a8af4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fffcce1173506c41e90a18f516fd32ee32a8af4c"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 63,
      "deletions": 2
    },
    "files": [
      {
        "sha": "fca7989d75f9265def3ee3e74575e3bde1434344",
        "filename": "build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libsecp256k1/libsecp256k1.vcxproj?ref=9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "patch": "@@ -12,7 +12,7 @@\n   </ItemGroup>\n   <ItemDefinitionGroup>\n     <ClCompile>\n-      <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;ENABLE_MODULE_EXTRAKEYS;ENABLE_MODULE_SCHNORRSIG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;ENABLE_MODULE_EXTRAKEYS;ENABLE_MODULE_SCHNORRSIG;ENABLE_MODULE_ELLSQ;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n       <AdditionalIncludeDirectories>..\\..\\src\\secp256k1;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n       <DisableSpecificWarnings>4146;4244;4267;4334</DisableSpecificWarnings>\n     </ClCompile>"
      },
      {
        "sha": "0dfe4ffe16e4665acca87555a864f3c5a3616ff6",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "patch": "@@ -1870,7 +1870,7 @@ PKGCONFIG_LIBDIR_TEMP=\"$PKG_CONFIG_LIBDIR\"\n unset PKG_CONFIG_LIBDIR\n PKG_CONFIG_LIBDIR=\"$PKGCONFIG_LIBDIR_TEMP\"\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental --disable-openssl-tests\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental --enable-module-ellsq --disable-openssl-tests\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      },
      {
        "sha": "8798735d166d6ba6f65de80613c92a427f33eed4",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <hash.h>\n #include <secp256k1.h>\n+#include <secp256k1_ellsq.h>\n #include <secp256k1_extrakeys.h>\n #include <secp256k1_recovery.h>\n #include <secp256k1_schnorrsig.h>\n@@ -334,6 +335,33 @@ bool CPubKey::Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChi\n     return true;\n }\n \n+std::optional<EllSqPubKey> CPubKey::EllSqEncode(const std::array<uint8_t, 32>& rnd32) const {\n+    assert(secp256k1_context_verify && \"secp256k1_context_verify must be initialized to use CPubKey.\");\n+\n+    secp256k1_pubkey pubkey;\n+    if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, vch, size())) {\n+        return {};\n+    }\n+\n+    EllSqPubKey encoded_pubkey;\n+    secp256k1_ellsq_encode(secp256k1_context_verify, encoded_pubkey.data(), rnd32.data(), &pubkey);\n+    return encoded_pubkey;\n+}\n+\n+CPubKey::CPubKey(const EllSqPubKey& encoded_pubkey) {\n+    assert(secp256k1_context_verify && \"secp256k1_context_verify must be initialized to use CPubKey.\");\n+    assert(encoded_pubkey.size() == ELLSQ_ENCODED_SIZE && \"Elligator-squared encoded pub keys must be 64 bytes\");\n+\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ellsq_decode(secp256k1_context_verify, &pubkey, encoded_pubkey.data());\n+\n+    size_t sz = COMPRESSED_SIZE;\n+    std::array<uint8_t, COMPRESSED_SIZE> vch_bytes;\n+\n+    secp256k1_ec_pubkey_serialize(secp256k1_context_verify, vch_bytes.data(), &sz, &pubkey, SECP256K1_EC_COMPRESSED);\n+    Set(vch_bytes.begin(), vch_bytes.end());\n+}\n+\n void CExtPubKey::Encode(unsigned char code[BIP32_EXTKEY_SIZE]) const {\n     code[0] = nDepth;\n     memcpy(code+1, vchFingerprint, 4);"
      },
      {
        "sha": "946f28593e6ba6c72ca31d2d736dd55ffabcb154",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "patch": "@@ -12,6 +12,7 @@\n #include <span.h>\n #include <uint256.h>\n \n+#include <array>\n #include <cstring>\n #include <optional>\n #include <vector>\n@@ -28,6 +29,9 @@ class CKeyID : public uint160\n \n typedef uint256 ChainCode;\n \n+constexpr size_t ELLSQ_ENCODED_SIZE = 64;\n+using EllSqPubKey = std::array<uint8_t, ELLSQ_ENCODED_SIZE>;\n+\n /** An encapsulated public key. */\n class CPubKey\n {\n@@ -107,6 +111,10 @@ class CPubKey\n         Set(_vch.begin(), _vch.end());\n     }\n \n+\n+    //! Creates a compressed pubkey from the elligator-squared encoding\n+    explicit CPubKey(const EllSqPubKey& encoded_pubkey);\n+\n     //! Simple read-only vector-like interface to the pubkey data.\n     unsigned int size() const { return GetLen(vch[0]); }\n     const unsigned char* data() const { return vch; }\n@@ -215,6 +223,8 @@ class CPubKey\n \n     //! Derive BIP32 child pubkey.\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n+\n+    std::optional<EllSqPubKey> EllSqEncode(const std::array<uint8_t, 32>& rnd32) const;\n };\n \n class XOnlyPubKey"
      },
      {
        "sha": "da0345a32f2a3d7d0806c422780227df29085f87",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "patch": "@@ -5,6 +5,7 @@\n #include <key.h>\n \n #include <key_io.h>\n+#include <random.h>\n #include <streams.h>\n #include <test/util/setup_common.h>\n #include <uint256.h>\n@@ -344,4 +345,26 @@ BOOST_AUTO_TEST_CASE(bip340_test_vectors)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(key_ellsq) {\n+    for (auto secret: {strSecret1, strSecret2, strSecret1C, strSecret2C}) {\n+        CKey key = DecodeSecret(secret);\n+        BOOST_CHECK(key.IsValid());\n+\n+        std::array<uint8_t, 32> rnd32;\n+        GetRandBytes(rnd32.data(), 32);\n+        auto original_pubkey = key.GetPubKey();\n+        auto ellsq_encoded_pubkey = original_pubkey.EllSqEncode(rnd32);\n+        assert(ellsq_encoded_pubkey.has_value());\n+\n+        CPubKey decoded_pubkey = CPubKey{ellsq_encoded_pubkey.value()};\n+        if(!key.IsCompressed()) {\n+            // The decoding constructor returns a compressed pubkey. If the\n+            // original was uncompressed, we must decompress the decoded one\n+            // to compare.\n+            decoded_pubkey.Decompress();\n+        }\n+        BOOST_CHECK(original_pubkey == decoded_pubkey);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "9a5cebcd1c36013dbd28b522c613fb89ad48abce",
    "node_id": "C_kwDOABII59oAKDlhNWNlYmNkMWMzNjAxM2RiZDI4YjUyMmM2MTNmYjg5YWQ0OGFiY2U",
    "commit": {
      "author": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-03T17:08:51Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-06T21:12:48Z"
      },
      "message": "Bench tests for CPubKey<->EllSq",
      "tree": {
        "sha": "98740ce90b2e9d01ae5890ca0f900d00c5f1f1c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/98740ce90b2e9d01ae5890ca0f900d00c5f1f1c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a5cebcd1c36013dbd28b522c613fb89ad48abce",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a5cebcd1c36013dbd28b522c613fb89ad48abce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9a5cebcd1c36013dbd28b522c613fb89ad48abce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a5cebcd1c36013dbd28b522c613fb89ad48abce/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e432fe607f332e6b8ff3ca70efdb5c9b8e9f995"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 46,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f3d850b85fc1db5cd7fd87ac177850b0b485510e",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a5cebcd1c36013dbd28b522c613fb89ad48abce/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a5cebcd1c36013dbd28b522c613fb89ad48abce/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=9a5cebcd1c36013dbd28b522c613fb89ad48abce",
        "patch": "@@ -22,6 +22,7 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/data.h \\\n   bench/data.cpp \\\n   bench/duplicate_inputs.cpp \\\n+  bench/ellsq.cpp \\\n   bench/examples.cpp \\\n   bench/rollingbloom.cpp \\\n   bench/chacha20.cpp \\"
      },
      {
        "sha": "a34db7a6510486756d6402ad85e133cc689be9a6",
        "filename": "src/bench/ellsq.cpp",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a5cebcd1c36013dbd28b522c613fb89ad48abce/src/bench/ellsq.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a5cebcd1c36013dbd28b522c613fb89ad48abce/src/bench/ellsq.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ellsq.cpp?ref=9a5cebcd1c36013dbd28b522c613fb89ad48abce",
        "patch": "@@ -0,0 +1,45 @@\n+// Copyright (c) 2016-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <pubkey.h>\n+#include <random.h>\n+\n+#include <array>\n+\n+EllSqPubKey GetRandomEllSq() {\n+    EllSqPubKey encoded_pubkey;\n+\n+    // GetRandBytes can only give us up to 32 bytes at a time\n+    GetRandBytes(encoded_pubkey.data(), 32);\n+    GetRandBytes(encoded_pubkey.data() + 32, 32);\n+\n+    return encoded_pubkey;\n+}\n+\n+static void EllSqEncode(benchmark::Bench& bench)\n+{\n+    std::array<uint8_t, 32> rnd32;\n+    GetRandBytes(rnd32.data(), 32);\n+\n+    // Any 64 bytes are a valid encoding for a public key.\n+    EllSqPubKey encoded_pubkey = GetRandomEllSq();\n+    CPubKey pubkey{encoded_pubkey};\n+    bench.batch(1).unit(\"pubkey\").run([&] {\n+        pubkey.EllSqEncode(rnd32);\n+    });\n+}\n+\n+static void EllSqDecode(benchmark::Bench& bench)\n+{\n+    // Any 64 bytes are a valid encoding for a public key.\n+    EllSqPubKey encoded_pubkey = GetRandomEllSq();\n+    bench.batch(1).unit(\"pubkey\").run([&] {\n+        CPubKey pubkey{encoded_pubkey};\n+    });\n+}\n+\n+BENCHMARK(EllSqEncode);\n+BENCHMARK(EllSqDecode);"
      }
    ]
  },
  {
    "sha": "405f64ef4a8b5f04afff438579556b8fa7e75e89",
    "node_id": "C_kwDOABII59oAKDQwNWY2NGVmNGE4YjVmMDRhZmZmNDM4NTc5NTU2YjhmYTdlNzVlODk",
    "commit": {
      "author": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-03T17:10:10Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-19T01:17:22Z"
      },
      "message": "Fuzz tests for CPubKey<->EllSq",
      "tree": {
        "sha": "d584b3c47143dd71021853e7b3613b47f622d885",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d584b3c47143dd71021853e7b3613b47f622d885"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/405f64ef4a8b5f04afff438579556b8fa7e75e89",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/405f64ef4a8b5f04afff438579556b8fa7e75e89",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/405f64ef4a8b5f04afff438579556b8fa7e75e89",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/405f64ef4a8b5f04afff438579556b8fa7e75e89/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9a5cebcd1c36013dbd28b522c613fb89ad48abce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a5cebcd1c36013dbd28b522c613fb89ad48abce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9a5cebcd1c36013dbd28b522c613fb89ad48abce"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 22,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2f505169f3c841804b2deaf92f646930506c34a9",
        "filename": "src/test/fuzz/key.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/405f64ef4a8b5f04afff438579556b8fa7e75e89/src/test/fuzz/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/405f64ef4a8b5f04afff438579556b8fa7e75e89/src/test/fuzz/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/key.cpp?ref=405f64ef4a8b5f04afff438579556b8fa7e75e89",
        "patch": "@@ -19,6 +19,7 @@\n #include <test/fuzz/fuzz.h>\n #include <util/strencodings.h>\n \n+#include <array>\n #include <cassert>\n #include <cstdint>\n #include <numeric>\n@@ -305,4 +306,25 @@ FUZZ_TARGET_INIT(key, initialize_key)\n             assert(key == loaded_key);\n         }\n     }\n+\n+    {\n+        std::array<uint8_t, 32> rnd32;\n+        memcpy(rnd32.data(), &random_uint256, 32);\n+        assert(pubkey.EllSqEncode(rnd32)->size() == ELLSQ_ENCODED_SIZE);\n+    }\n+}\n+\n+FUZZ_TARGET_INIT(ellsq, initialize_key)\n+{\n+    if(buffer.size() < 64) {\n+        return;\n+    }\n+\n+    auto ellsq_bytes = buffer.first(64);\n+    // Any 64 bytes are a valid elligator squared encoding of a pubkey\n+    EllSqPubKey ellsq_pubkey;\n+    std::copy(ellsq_bytes.begin(), ellsq_bytes.end(), ellsq_pubkey.begin());\n+    CPubKey pubkey{ellsq_pubkey};\n+\n+    assert(pubkey.IsFullyValid());\n }"
      }
    ]
  }
]