[
  {
    "sha": "818075adaca9104539f056cdb858e135a49de2ed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MTgwNzVhZGFjYTkxMDQ1MzlmMDU2Y2RiODU4ZTEzNWE0OWRlMmVk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-04T22:10:45Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-15T20:27:45Z"
      },
      "message": "Create new mutex for orphans, no cs_main in PLV::BlockConnected\n\nThis should (marginally) speed up validationinterface queue\ndraining by avoiding a cs_main lock in one client.",
      "tree": {
        "sha": "ed1638525d487775e78951cf35925ec58903611d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed1638525d487775e78951cf35925ec58903611d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/818075adaca9104539f056cdb858e135a49de2ed",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/818075adaca9104539f056cdb858e135a49de2ed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/818075adaca9104539f056cdb858e135a49de2ed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/818075adaca9104539f056cdb858e135a49de2ed/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "df7181952436a90a7f300f2b673321e2ac92ef56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df7181952436a90a7f300f2b673321e2ac92ef56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/df7181952436a90a7f300f2b673321e2ac92ef56"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 22,
      "deletions": 14
    },
    "files": [
      {
        "sha": "d1a89ed91c87259248d9b4a65026763d27a4a9d6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 14,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/818075adaca9104539f056cdb858e135a49de2ed/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/818075adaca9104539f056cdb858e135a49de2ed/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=818075adaca9104539f056cdb858e135a49de2ed",
        "patch": "@@ -51,12 +51,13 @@ struct COrphanTx {\n     NodeId fromPeer;\n     int64_t nTimeExpire;\n };\n-std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);\n-std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(cs_main);\n-void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+static CCriticalSection g_cs_orphans;\n+std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n+void EraseOrphansFor(NodeId peer);\n \n-static size_t vExtraTxnForCompactIt = 0;\n-static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(cs_main);\n+static size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n+static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n \n static const uint64_t RANDOMIZER_ID_ADDRESS_RELAY = 0x3cac0035b5866b90ULL; // SHA256(\"main address relay\")[0:8]\n \n@@ -127,7 +128,7 @@ namespace {\n     int g_outbound_peers_with_protect_from_disconnect = 0;\n \n     /** When our tip was last updated. */\n-    int64_t g_last_tip_update = 0;\n+    std::atomic<int64_t> g_last_tip_update(0);\n \n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n@@ -631,7 +632,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n // mapOrphanTransactions\n //\n \n-void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n     size_t max_extra_txn = gArgs.GetArg(\"-blockreconstructionextratxn\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN);\n     if (max_extra_txn <= 0)\n@@ -642,7 +643,7 @@ void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_RE\n     vExtraTxnForCompactIt = (vExtraTxnForCompactIt + 1) % max_extra_txn;\n }\n \n-bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n     const uint256& hash = tx->GetHash();\n     if (mapOrphanTransactions.count(hash))\n@@ -675,7 +676,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n     return true;\n }\n \n-int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n     std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n     if (it == mapOrphanTransactions.end())\n@@ -695,6 +696,7 @@ int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n \n void EraseOrphansFor(NodeId peer)\n {\n+    LOCK(g_cs_orphans);\n     int nErased = 0;\n     std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n     while (iter != mapOrphanTransactions.end())\n@@ -709,8 +711,10 @@ void EraseOrphansFor(NodeId peer)\n }\n \n \n-unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n {\n+    LOCK(g_cs_orphans);\n+\n     unsigned int nEvicted = 0;\n     static int64_t nNextSweep;\n     int64_t nNow = GetTime();\n@@ -804,7 +808,7 @@ PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &schedu\n }\n \n void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n-    LOCK(cs_main);\n+    LOCK(g_cs_orphans);\n \n     std::vector<uint256> vOrphanErase;\n \n@@ -971,9 +975,13 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 recentRejects->reset();\n             }\n \n+            {\n+                LOCK(g_cs_orphans);\n+                if (mapOrphanTransactions.count(inv.hash)) return true;\n+            }\n+\n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n-                   mapOrphanTransactions.count(inv.hash) ||\n                    pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n                    pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n@@ -2101,7 +2109,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n-        LOCK(cs_main);\n+        LOCK2(cs_main, g_cs_orphans);\n \n         bool fMissingInputs = false;\n         CValidationState state;\n@@ -2324,7 +2332,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         bool fBlockReconstructed = false;\n \n         {\n-        LOCK(cs_main);\n+        LOCK2(cs_main, g_cs_orphans);\n         // If AcceptBlockHeader returned true, it set pindex\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());"
      }
    ]
  },
  {
    "sha": "66aa1d58a158991a8014a91335b5bc9c00062f56",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NmFhMWQ1OGExNTg5OTFhODAxNGE5MTMzNWI1YmM5YzAwMDYyZjU2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-24T16:58:20Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-24T18:08:38Z"
      },
      "message": "Refactor ProcessGetData in anticipation of avoiding cs_main for ABC",
      "tree": {
        "sha": "422b97c1a541a694d980be42b31dd5d6197121ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/422b97c1a541a694d980be42b31dd5d6197121ef"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/66aa1d58a158991a8014a91335b5bc9c00062f56",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66aa1d58a158991a8014a91335b5bc9c00062f56",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/66aa1d58a158991a8014a91335b5bc9c00062f56",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66aa1d58a158991a8014a91335b5bc9c00062f56/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "818075adaca9104539f056cdb858e135a49de2ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/818075adaca9104539f056cdb858e135a49de2ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/818075adaca9104539f056cdb858e135a49de2ed"
      }
    ],
    "stats": {
      "total": 321,
      "additions": 166,
      "deletions": 155
    },
    "files": [
      {
        "sha": "3225d429b93302edfc7efbeac7ceab31d6557c32",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 166,
        "deletions": 155,
        "changes": 321,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66aa1d58a158991a8014a91335b5bc9c00062f56/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66aa1d58a158991a8014a91335b5bc9c00062f56/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=66aa1d58a158991a8014a91335b5bc9c00062f56",
        "patch": "@@ -1038,182 +1038,193 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connma\n     connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensusParams, const CInv& inv, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n-    std::vector<CInv> vNotFound;\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     LOCK(cs_main);\n \n-    while (it != pfrom->vRecvGetData.end()) {\n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            break;\n+    bool send = false;\n+    std::shared_ptr<const CBlock> a_recent_block;\n+    std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n+    bool fWitnessesPresentInARecentCompactBlock;\n+    {\n+        LOCK(cs_most_recent_block);\n+        a_recent_block = most_recent_block;\n+        a_recent_compact_block = most_recent_compact_block;\n+        fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+    }\n \n-        const CInv &inv = *it;\n+    {\n+        BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+        if (mi != mapBlockIndex.end())\n         {\n-            if (interruptMsgProc)\n-                return;\n+            if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                    mi->second->IsValid(BLOCK_VALID_TREE)) {\n+                // If we have the block and all of its parents, but have not yet validated it,\n+                // we might be in the middle of connecting it (ie in the unlock of cs_main\n+                // before ActivateBestChain but after AcceptBlock).\n+                // In this case, we need to run ActivateBestChain prior to checking the relay\n+                // conditions below.\n+                CValidationState dummy;\n+                ActivateBestChain(dummy, Params(), a_recent_block);\n+            }\n+        }\n+    }\n+    BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+    if (mi != mapBlockIndex.end()) {\n+        send = BlockRequestAllowed(mi->second, consensusParams);\n+        if (!send) {\n+            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+        }\n+    }\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    // disconnect node in case we have reached the outbound limit for serving historical blocks\n+    // never disconnect whitelisted nodes\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    {\n+        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n-            it++;\n+        //disconnect node\n+        pfrom->fDisconnect = true;\n+        send = false;\n+    }\n+    // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n+    if (send && !pfrom->fWhitelisted && (\n+            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - mi->second->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n+       )) {\n+        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK)\n+        //disconnect node and prevent it from stalling (would otherwise wait for the missing block)\n+        pfrom->fDisconnect = true;\n+        send = false;\n+    }\n+    // Pruned nodes may have deleted the block, so check whether\n+    // it's available before trying to send.\n+    if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+    {\n+        std::shared_ptr<const CBlock> pblock;\n+        if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+            pblock = a_recent_block;\n+        } else {\n+            // Send block from disk\n+            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+            if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+                assert(!\"cannot load block from disk\");\n+            pblock = pblockRead;\n+        }\n+        if (inv.type == MSG_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_WITNESS_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_FILTERED_BLOCK)\n+        {\n+            bool sendMerkleBlock = false;\n+            CMerkleBlock merkleBlock;\n             {\n-                bool send = false;\n-                BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n-                std::shared_ptr<const CBlock> a_recent_block;\n-                std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n-                bool fWitnessesPresentInARecentCompactBlock;\n-                {\n-                    LOCK(cs_most_recent_block);\n-                    a_recent_block = most_recent_block;\n-                    a_recent_compact_block = most_recent_compact_block;\n-                    fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+                LOCK(pfrom->cs_filter);\n+                if (pfrom->pfilter) {\n+                    sendMerkleBlock = true;\n+                    merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n                 }\n-                if (mi != mapBlockIndex.end())\n-                {\n-                    if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n-                            mi->second->IsValid(BLOCK_VALID_TREE)) {\n-                        // If we have the block and all of its parents, but have not yet validated it,\n-                        // we might be in the middle of connecting it (ie in the unlock of cs_main\n-                        // before ActivateBestChain but after AcceptBlock).\n-                        // In this case, we need to run ActivateBestChain prior to checking the relay\n-                        // conditions below.\n-                        CValidationState dummy;\n-                        ActivateBestChain(dummy, Params(), a_recent_block);\n-                    }\n-                    send = BlockRequestAllowed(mi->second, consensusParams);\n-                    if (!send) {\n-                        LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n-                    }\n+            }\n+            if (sendMerkleBlock) {\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n+                // This avoids hurting performance by pointlessly requiring a round-trip\n+                // Note that there is currently no way for a node to request any single transactions we didn't send here -\n+                // they must either disconnect and retry or request the full block.\n+                // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n+                // however we MUST always provide at least what the remote peer needs\n+                typedef std::pair<unsigned int, uint256> PairType;\n+                for (PairType& pair : merkleBlock.vMatchedTxn)\n+                    connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+            }\n+            // else\n+                // no response\n+        }\n+        else if (inv.type == MSG_CMPCT_BLOCK)\n+        {\n+            // If a peer is asking for old blocks, we're almost guaranteed\n+            // they won't have a useful mempool to match against a compact block,\n+            // and we don't feel like constructing the object for them, so\n+            // instead we respond with the full, non-compact block.\n+            bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n+            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+            if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                } else {\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                 }\n-                // disconnect node in case we have reached the outbound limit for serving historical blocks\n-                // never disconnect whitelisted nodes\n-                if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n-                {\n-                    LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+            } else {\n+                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+            }\n+        }\n \n-                    //disconnect node\n-                    pfrom->fDisconnect = true;\n-                    send = false;\n-                }\n-                // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n-                if (send && !pfrom->fWhitelisted && (\n-                        (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - mi->second->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n-                   )) {\n-                    LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());\n+        // Trigger the peer node to send a getblocks request for the next batch of inventory\n+        if (inv.hash == pfrom->hashContinue)\n+        {\n+            // Bypass PushInventory, this must send even if redundant,\n+            // and we want it right after the last block so they don't\n+            // wait for other stuff first.\n+            std::vector<CInv> vInv;\n+            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            pfrom->hashContinue.SetNull();\n+        }\n+    }\n+}\n \n-                    //disconnect node and prevent it from stalling (would otherwise wait for the missing block)\n-                    pfrom->fDisconnect = true;\n-                    send = false;\n-                }\n-                // Pruned nodes may have deleted the block, so check whether\n-                // it's available before trying to send.\n-                if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n-                {\n-                    std::shared_ptr<const CBlock> pblock;\n-                    if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n-                        pblock = a_recent_block;\n-                    } else {\n-                        // Send block from disk\n-                        std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n-                        if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n-                            assert(!\"cannot load block from disk\");\n-                        pblock = pblockRead;\n-                    }\n-                    if (inv.type == MSG_BLOCK)\n-                        connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n-                    else if (inv.type == MSG_WITNESS_BLOCK)\n-                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n-                    else if (inv.type == MSG_FILTERED_BLOCK)\n-                    {\n-                        bool sendMerkleBlock = false;\n-                        CMerkleBlock merkleBlock;\n-                        {\n-                            LOCK(pfrom->cs_filter);\n-                            if (pfrom->pfilter) {\n-                                sendMerkleBlock = true;\n-                                merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n-                            }\n-                        }\n-                        if (sendMerkleBlock) {\n-                            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n-                            // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n-                            // This avoids hurting performance by pointlessly requiring a round-trip\n-                            // Note that there is currently no way for a node to request any single transactions we didn't send here -\n-                            // they must either disconnect and retry or request the full block.\n-                            // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n-                            // however we MUST always provide at least what the remote peer needs\n-                            typedef std::pair<unsigned int, uint256> PairType;\n-                            for (PairType& pair : merkleBlock.vMatchedTxn)\n-                                connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n-                        }\n-                        // else\n-                            // no response\n-                    }\n-                    else if (inv.type == MSG_CMPCT_BLOCK)\n-                    {\n-                        // If a peer is asking for old blocks, we're almost guaranteed\n-                        // they won't have a useful mempool to match against a compact block,\n-                        // and we don't feel like constructing the object for them, so\n-                        // instead we respond with the full, non-compact block.\n-                        bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n-                        int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-                        if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                            if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n-                                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n-                            } else {\n-                                CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                            }\n-                        } else {\n-                            connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n-                        }\n-                    }\n+void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+{\n+    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n+    std::vector<CInv> vNotFound;\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    {\n+        LOCK(cs_main);\n \n-                    // Trigger the peer node to send a getblocks request for the next batch of inventory\n-                    if (inv.hash == pfrom->hashContinue)\n-                    {\n-                        // Bypass PushInventory, this must send even if redundant,\n-                        // and we want it right after the last block so they don't\n-                        // wait for other stuff first.\n-                        std::vector<CInv> vInv;\n-                        vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n-                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n-                        pfrom->hashContinue.SetNull();\n-                    }\n-                }\n-            }\n-            else if (inv.type == MSG_TX || inv.type == MSG_WITNESS_TX)\n-            {\n-                // Send stream from relay memory\n-                bool push = false;\n-                auto mi = mapRelay.find(inv.hash);\n-                int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n-                if (mi != mapRelay.end()) {\n-                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n+        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {\n+            if (interruptMsgProc)\n+                return;\n+            // Don't bother if send buffer is too full to respond anyway\n+            if (pfrom->fPauseSend)\n+                break;\n+\n+            const CInv &inv = *it;\n+            it++;\n+\n+            // Send stream from relay memory\n+            bool push = false;\n+            auto mi = mapRelay.find(inv.hash);\n+            int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n+            if (mi != mapRelay.end()) {\n+                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n+                push = true;\n+            } else if (pfrom->timeLastMempoolReq) {\n+                auto txinfo = mempool.info(inv.hash);\n+                // To protect privacy, do not answer getdata using the mempool when\n+                // that TX couldn't have been INVed in reply to a MEMPOOL request.\n+                if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n                     push = true;\n-                } else if (pfrom->timeLastMempoolReq) {\n-                    auto txinfo = mempool.info(inv.hash);\n-                    // To protect privacy, do not answer getdata using the mempool when\n-                    // that TX couldn't have been INVed in reply to a MEMPOOL request.\n-                    if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n-                        push = true;\n-                    }\n-                }\n-                if (!push) {\n-                    vNotFound.push_back(inv);\n                 }\n             }\n+            if (!push) {\n+                vNotFound.push_back(inv);\n+            }\n \n             // Track requests for our stuff.\n             GetMainSignals().Inventory(inv.hash);\n+        }\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK)\n-                break;\n+        if (it != pfrom->vRecvGetData.end()) {\n+            const CInv &inv = *it;\n+            it++;\n+            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK) {\n+                ProcessGetBlockData(pfrom, consensusParams, inv, connman, interruptMsgProc);\n+            }\n         }\n-    }\n+    } // release cs_main\n \n     pfrom->vRecvGetData.erase(pfrom->vRecvGetData.begin(), it);\n "
      }
    ]
  },
  {
    "sha": "a7348960389af9d86983e767b4aea2c7778ab726",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNzM0ODk2MDM4OWFmOWQ4Njk4M2U3NjdiNGFlYTJjNzc3OGFiNzI2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-24T16:59:02Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-24T18:20:52Z"
      },
      "message": "Avoid cs_main in net_processing ActivateBestChain calls",
      "tree": {
        "sha": "f8ef8e71b6732f7d335ebc8c3613278dfd3608ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f8ef8e71b6732f7d335ebc8c3613278dfd3608ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a7348960389af9d86983e767b4aea2c7778ab726",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7348960389af9d86983e767b4aea2c7778ab726",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a7348960389af9d86983e767b4aea2c7778ab726",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7348960389af9d86983e767b4aea2c7778ab726/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "66aa1d58a158991a8014a91335b5bc9c00062f56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66aa1d58a158991a8014a91335b5bc9c00062f56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/66aa1d58a158991a8014a91335b5bc9c00062f56"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 19,
      "deletions": 12
    },
    "files": [
      {
        "sha": "76e82a5ef65c360ee37a1d9d64ce35a38f7f5cf7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 12,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a7348960389af9d86983e767b4aea2c7778ab726/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a7348960389af9d86983e767b4aea2c7778ab726/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a7348960389af9d86983e767b4aea2c7778ab726",
        "patch": "@@ -1040,8 +1040,6 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connma\n \n void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensusParams, const CInv& inv, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LOCK(cs_main);\n-\n     bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n@@ -1053,7 +1051,9 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n         fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n     }\n \n+    bool need_activate_chain = false;\n     {\n+        LOCK(cs_main);\n         BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n         if (mi != mapBlockIndex.end())\n         {\n@@ -1064,11 +1064,16 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n                 // before ActivateBestChain but after AcceptBlock).\n                 // In this case, we need to run ActivateBestChain prior to checking the relay\n                 // conditions below.\n-                CValidationState dummy;\n-                ActivateBestChain(dummy, Params(), a_recent_block);\n+                need_activate_chain = true;\n             }\n         }\n+    } // release cs_main before calling ActivateBestChain\n+    if (need_activate_chain) {\n+        CValidationState dummy;\n+        ActivateBestChain(dummy, Params(), a_recent_block);\n     }\n+\n+    LOCK(cs_main);\n     BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n     if (mi != mapBlockIndex.end()) {\n         send = BlockRequestAllowed(mi->second, consensusParams);\n@@ -1177,6 +1182,8 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n \n void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n+    AssertLockNotHeld(cs_main);\n+\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n@@ -1216,15 +1223,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             // Track requests for our stuff.\n             GetMainSignals().Inventory(inv.hash);\n         }\n+    } // release cs_main\n \n-        if (it != pfrom->vRecvGetData.end()) {\n-            const CInv &inv = *it;\n-            it++;\n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK) {\n-                ProcessGetBlockData(pfrom, consensusParams, inv, connman, interruptMsgProc);\n-            }\n+    if (it != pfrom->vRecvGetData.end()) {\n+        const CInv &inv = *it;\n+        it++;\n+        if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK) {\n+            ProcessGetBlockData(pfrom, consensusParams, inv, connman, interruptMsgProc);\n         }\n-    } // release cs_main\n+    }\n \n     pfrom->vRecvGetData.erase(pfrom->vRecvGetData.begin(), it);\n \n@@ -2027,7 +2034,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n             pfrom->vRecvGetData.push_back(inv);\n-            ProcessGetData(pfrom, chainparams.GetConsensus(), connman, interruptMsgProc);\n+            // The message processing loop will go around again (without pausing) and we'll respond then (without cs_main)\n             return true;\n         }\n "
      }
    ]
  },
  {
    "sha": "a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOTliNzZmMjY5NTg4MjljMmI5Y2E0ZmZhNWIxZDgxOTEyYjhhY2M3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-04T23:25:57Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-26T16:54:43Z"
      },
      "message": "Require no cs_main lock for ProcessNewBlock/ActivateBestChain\n\nThis requires the removal of some very liberal (incorrect) cs_mains\nsprinkled in some tests. It adds some chainActive.Tip() races, but\nthe tests are all single-threaded anyway.",
      "tree": {
        "sha": "e8d58aa97befc795ca199e105ae0a5bec5a70535",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8d58aa97befc795ca199e105ae0a5bec5a70535"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a7348960389af9d86983e767b4aea2c7778ab726",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a7348960389af9d86983e767b4aea2c7778ab726",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a7348960389af9d86983e767b4aea2c7778ab726"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 46,
      "deletions": 33
    },
    "files": [
      {
        "sha": "f968869bf5eb8679e62c79c21c359102a47d04e9",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 17,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
        "patch": "@@ -205,7 +205,6 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     entry.nFee = 11;\n     entry.nHeight = 11;\n \n-    LOCK(cs_main);\n     fCheckpointsEnabled = false;\n \n     // Simple block creation, nothing special yet:\n@@ -218,27 +217,32 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     for (unsigned int i = 0; i < sizeof(blockinfo)/sizeof(*blockinfo); ++i)\n     {\n         CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n-        pblock->nVersion = 1;\n-        pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n-        CMutableTransaction txCoinbase(*pblock->vtx[0]);\n-        txCoinbase.nVersion = 1;\n-        txCoinbase.vin[0].scriptSig = CScript();\n-        txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n-        txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n-        txCoinbase.vout.resize(1); // Ignore the (optional) segwit commitment added by CreateNewBlock (as the hardcoded nonces don't account for this)\n-        txCoinbase.vout[0].scriptPubKey = CScript();\n-        pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n-        if (txFirst.size() == 0)\n-            baseheight = chainActive.Height();\n-        if (txFirst.size() < 4)\n-            txFirst.push_back(pblock->vtx[0]);\n-        pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n-        pblock->nNonce = blockinfo[i].nonce;\n+        {\n+            LOCK(cs_main);\n+            pblock->nVersion = 1;\n+            pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n+            CMutableTransaction txCoinbase(*pblock->vtx[0]);\n+            txCoinbase.nVersion = 1;\n+            txCoinbase.vin[0].scriptSig = CScript();\n+            txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n+            txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n+            txCoinbase.vout.resize(1); // Ignore the (optional) segwit commitment added by CreateNewBlock (as the hardcoded nonces don't account for this)\n+            txCoinbase.vout[0].scriptPubKey = CScript();\n+            pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n+            if (txFirst.size() == 0)\n+                baseheight = chainActive.Height();\n+            if (txFirst.size() < 4)\n+                txFirst.push_back(pblock->vtx[0]);\n+            pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n+            pblock->nNonce = blockinfo[i].nonce;\n+        }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n         BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n \n+    LOCK(cs_main);\n+\n     // Just to make sure we can still make simple blocks\n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n "
      },
      {
        "sha": "10acabe0be6d4a7b38f73e86e02c8d180e21f6e6",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
        "patch": "@@ -66,7 +66,6 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n     // Test 1: block with both of those transactions should be rejected.\n     block = CreateAndProcessBlock(spends, scriptPubKey);\n-    LOCK(cs_main);\n     BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n \n     // Test 2: ... and should be rejected if spend1 is in the memory pool\n@@ -190,12 +189,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         spend_tx.vin[0].scriptSig << vchSig;\n     }\n \n-    LOCK(cs_main);\n-\n     // Test that invalidity under a set of flags doesn't preclude validity\n     // under other (eg consensus) flags.\n     // spend_tx is invalid according to DERSIG\n     {\n+        LOCK(cs_main);\n+\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n@@ -213,15 +212,17 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // test later that block validation works fine in the absence of cached\n         // successes.\n         ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\n+    }\n \n-        // And if we produce a block with this tx, it should be valid (DERSIG not\n-        // enabled yet), even though there's no cache entry.\n-        CBlock block;\n+    // And if we produce a block with this tx, it should be valid (DERSIG not\n+    // enabled yet), even though there's no cache entry.\n+    CBlock block;\n \n-        block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n-        BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n-        BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n-    }\n+    block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n+    BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+    BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n+\n+    LOCK(cs_main);\n \n     // Test P2SH: construct a transaction that is valid without P2SH, and\n     // then test validity with P2SH."
      },
      {
        "sha": "71a51c499cf333d13f1151cc505fb80d87c4efa4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
        "patch": "@@ -2559,6 +2559,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     // far from a guarantee. Things in the P2P/RPC will often end up calling\n     // us in the middle of ProcessNewBlock - do not assume pblock is set\n     // sanely for performance or correctness!\n+    AssertLockNotHeld(cs_main);\n \n     CBlockIndex *pindexMostWork = nullptr;\n     CBlockIndex *pindexNewTip = nullptr;\n@@ -3383,6 +3384,8 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool *fNewBlock)\n {\n+    AssertLockNotHeld(cs_main);\n+\n     {\n         CBlockIndex *pindex = nullptr;\n         if (fNewBlock) *fNewBlock = false;"
      },
      {
        "sha": "8e9362c649c07ff064b38bdb56d6f15c0b2af09e",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
        "patch": "@@ -370,15 +370,15 @@ static void AddKey(CWallet& wallet, const CKey& key)\n \n BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n {\n-    LOCK(cs_main);\n-\n     // Cap last block file size, and mine new block in a new block file.\n     CBlockIndex* const nullBlock = nullptr;\n     CBlockIndex* oldTip = chainActive.Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n     CBlockIndex* newTip = chainActive.Tip();\n \n+    LOCK(cs_main);\n+\n     // Verify ScanForWalletTransactions picks up transactions in both the old\n     // and new block files.\n     {\n@@ -447,8 +447,6 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n // than or equal to key birthday.\n BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n {\n-    LOCK(cs_main);\n-\n     // Create two blocks with same timestamp to verify that importwallet rescan\n     // will pick up both blocks, not just the first.\n     const int64_t BLOCK_TIME = chainActive.Tip()->GetBlockTimeMax() + 5;\n@@ -462,6 +460,8 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     SetMockTime(KEY_TIME);\n     coinbaseTxns.emplace_back(*CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n \n+    LOCK(cs_main);\n+\n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n         CWallet wallet;\n@@ -627,10 +627,15 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         BOOST_CHECK(wallet->CreateTransaction({recipient}, wtx, reservekey, fee, changePos, error, dummy));\n         CValidationState state;\n         BOOST_CHECK(wallet->CommitTransaction(wtx, reservekey, nullptr, state));\n+        CMutableTransaction blocktx;\n+        {\n+            LOCK(wallet->cs_wallet);\n+            blocktx = CMutableTransaction(*wallet->mapWallet.at(wtx.GetHash()).tx);\n+        }\n+        CreateAndProcessBlock({CMutableTransaction(blocktx)}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n         LOCK(wallet->cs_wallet);\n         auto it = wallet->mapWallet.find(wtx.GetHash());\n         BOOST_CHECK(it != wallet->mapWallet.end());\n-        CreateAndProcessBlock({CMutableTransaction(*it->second.tx)}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n         it->second.SetMerkleBranch(chainActive.Tip(), 1);\n         return it->second;\n     }\n@@ -641,7 +646,6 @@ class ListCoinsTestingSetup : public TestChain100Setup\n BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n {\n     std::string coinbaseAddress = coinbaseKey.GetPubKey().GetID().ToString();\n-    LOCK2(cs_main, wallet->cs_wallet);\n \n     // Confirm ListCoins initially returns 1 coin grouped under coinbaseKey\n     // address.\n@@ -669,6 +673,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     BOOST_CHECK_EQUAL(available.size(), 2);\n     for (const auto& group : list) {\n         for (const auto& coin : group.second) {\n+            LOCK(wallet->cs_wallet);\n             wallet->LockCoin(COutPoint(coin.tx->GetHash(), coin.i));\n         }\n     }"
      }
    ]
  },
  {
    "sha": "5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YTkzM2NlZmNjNWUwNTk1YTFlYzQ2ZmM1ZWEyODdhYTE2M2VjZDNm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-04T23:31:36Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-26T16:54:49Z"
      },
      "message": "Add an interface to get the queue depth out of CValidationInterface",
      "tree": {
        "sha": "63bcb653e77c838a7e511dcdd6eb1d49cd125c5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/63bcb653e77c838a7e511dcdd6eb1d49cd125c5c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a99b76f26958829c2b9ca4ffa5b1d81912b8acc7"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 14,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7d5ec146103199fc63e61dd0f101132edd4672af",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
        "patch": "@@ -206,3 +206,8 @@ void SingleThreadedSchedulerClient::EmptyQueue() {\n         should_continue = !m_callbacks_pending.empty();\n     }\n }\n+\n+size_t SingleThreadedSchedulerClient::CallbacksPending() {\n+    LOCK(m_cs_callbacks_pending);\n+    return m_callbacks_pending.size();\n+}"
      },
      {
        "sha": "39ecb849b9d92d4468bd1e99d3d753a774d0a96a",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
        "patch": "@@ -108,6 +108,8 @@ class SingleThreadedSchedulerClient {\n     // Processes all remaining queue members on the calling thread, blocking until queue is empty\n     // Must be called after the CScheduler has no remaining processing threads!\n     void EmptyQueue();\n+\n+    size_t CallbacksPending();\n };\n \n #endif"
      },
      {
        "sha": "1ddff4b335bda9c00ee62b22ca2af11306a5ecda",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
        "patch": "@@ -54,6 +54,11 @@ void CMainSignals::FlushBackgroundCallbacks() {\n     }\n }\n \n+size_t CMainSignals::CallbacksPending() {\n+    if (!m_internals) return 0;\n+    return m_internals->m_schedulerClient.CallbacksPending();\n+}\n+\n void CMainSignals::RegisterWithMempoolSignals(CTxMemPool& pool) {\n     pool.NotifyEntryRemoved.connect(boost::bind(&CMainSignals::MempoolEntryRemoved, this, _1, _2));\n }"
      },
      {
        "sha": "164059e3b9eecc3e3888e458c54840ad8465a027",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
        "patch": "@@ -131,6 +131,8 @@ class CMainSignals {\n     /** Call any remaining callbacks on the calling thread */\n     void FlushBackgroundCallbacks();\n \n+    size_t CallbacksPending();\n+\n     /** Register with mempool to call TransactionRemovedFromMempool callbacks */\n     void RegisterWithMempoolSignals(CTxMemPool& pool);\n     /** Unregister with mempool */"
      }
    ]
  },
  {
    "sha": "36137497f1e2b3324ca84550f4f295dcd605d1fa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNjEzNzQ5N2YxZTJiMzMyNGNhODQ1NTBmNGYyOTVkY2Q2MDVkMWZh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-04T23:57:55Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-26T16:54:49Z"
      },
      "message": "Block ActivateBestChain to empty validationinterface queue",
      "tree": {
        "sha": "684bc166f66e54273396034cef46203eff8ca62b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/684bc166f66e54273396034cef46203eff8ca62b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36137497f1e2b3324ca84550f4f295dcd605d1fa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36137497f1e2b3324ca84550f4f295dcd605d1fa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/36137497f1e2b3324ca84550f4f295dcd605d1fa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36137497f1e2b3324ca84550f4f295dcd605d1fa/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5a933cefcc5e0595a1ec46fc5ea287aa163ecd3f"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 16,
      "deletions": 3
    },
    "files": [
      {
        "sha": "6bd228a63a612446776ca670ce9fad2ab2368477",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36137497f1e2b3324ca84550f4f295dcd605d1fa/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36137497f1e2b3324ca84550f4f295dcd605d1fa/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=36137497f1e2b3324ca84550f4f295dcd605d1fa",
        "patch": "@@ -69,9 +69,9 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n         fs::create_directories(pathTemp);\n         gArgs.ForceSetArg(\"-datadir\", pathTemp.string());\n \n-        // Note that because we don't bother running a scheduler thread here,\n-        // callbacks via CValidationInterface are unreliable, but that's OK,\n-        // our unit tests aren't testing multiple parts of the code at once.\n+        // We have to run a scheduler thread to prevent ActivateBestChain\n+        // from blocking due to queue overrun.\n+        threadGroup.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n         GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n \n         mempool.setSanityCheck(1.0);"
      },
      {
        "sha": "23ce6509d5a4c07b4245ce838ceeb829966061a6",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/36137497f1e2b3324ca84550f4f295dcd605d1fa/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/36137497f1e2b3324ca84550f4f295dcd605d1fa/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=36137497f1e2b3324ca84550f4f295dcd605d1fa",
        "patch": "@@ -40,6 +40,7 @@\n #include <validationinterface.h>\n #include <warnings.h>\n \n+#include <future>\n #include <sstream>\n \n #include <boost/algorithm/string/replace.hpp>\n@@ -2566,6 +2567,18 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     int nStopAtHeight = gArgs.GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n     do {\n         boost::this_thread::interruption_point();\n+\n+        if (GetMainSignals().CallbacksPending() > 10) {\n+            // Block until the validation queue drains. This should largely\n+            // never happen in normal operation, however may happen during\n+            // reindex, causing memory blowup  if we run too far ahead.\n+            std::promise<void> promise;\n+            CallFunctionInValidationInterfaceQueue([&promise] {\n+                promise.set_value();\n+            });\n+            promise.get_future().wait();\n+        }\n+\n         if (ShutdownRequested())\n             break;\n "
      }
    ]
  },
  {
    "sha": "97d2b09c124e6e5803f7fd4503348d9710d1260f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5N2QyYjA5YzEyNGU2ZTU4MDNmN2ZkNDUwMzM0OGQ5NzEwZDEyNjBm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-24T17:13:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-12-26T16:56:00Z"
      },
      "message": "Add helper to wait for validation interface queue to catch up",
      "tree": {
        "sha": "03f9de627168be7e5ae8a95b6d345b754496a517",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/03f9de627168be7e5ae8a95b6d345b754496a517"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97d2b09c124e6e5803f7fd4503348d9710d1260f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97d2b09c124e6e5803f7fd4503348d9710d1260f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/97d2b09c124e6e5803f7fd4503348d9710d1260f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97d2b09c124e6e5803f7fd4503348d9710d1260f/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "36137497f1e2b3324ca84550f4f295dcd605d1fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/36137497f1e2b3324ca84550f4f295dcd605d1fa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/36137497f1e2b3324ca84550f4f295dcd605d1fa"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 24,
      "deletions": 11
    },
    "files": [
      {
        "sha": "1c024ce2aea803883fa974a78bf942ced11aa142",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=97d2b09c124e6e5803f7fd4503348d9710d1260f",
        "patch": "@@ -2572,11 +2572,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n             // Block until the validation queue drains. This should largely\n             // never happen in normal operation, however may happen during\n             // reindex, causing memory blowup  if we run too far ahead.\n-            std::promise<void> promise;\n-            CallFunctionInValidationInterfaceQueue([&promise] {\n-                promise.set_value();\n-            });\n-            promise.get_future().wait();\n+            SyncWithValidationInterfaceQueue();\n         }\n \n         if (ShutdownRequested())"
      },
      {
        "sha": "1e13465bf78143f137f946328f5d862779e2e083",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=97d2b09c124e6e5803f7fd4503348d9710d1260f",
        "patch": "@@ -11,9 +11,11 @@\n #include <sync.h>\n #include <txmempool.h>\n #include <util.h>\n+#include <validation.h>\n \n #include <list>\n #include <atomic>\n+#include <future>\n \n #include <boost/signals2/signal.hpp>\n \n@@ -118,6 +120,16 @@ void CallFunctionInValidationInterfaceQueue(std::function<void ()> func) {\n     g_signals.m_internals->m_schedulerClient.AddToProcessQueue(std::move(func));\n }\n \n+void SyncWithValidationInterfaceQueue() {\n+    AssertLockNotHeld(cs_main);\n+    // Block until the validation queue drains\n+    std::promise<void> promise;\n+    CallFunctionInValidationInterfaceQueue([&promise] {\n+        promise.set_value();\n+    });\n+    promise.get_future().wait();\n+}\n+\n void CMainSignals::MempoolEntryRemoved(CTransactionRef ptx, MemPoolRemovalReason reason) {\n     if (reason != MemPoolRemovalReason::BLOCK && reason != MemPoolRemovalReason::CONFLICT) {\n         m_internals->m_schedulerClient.AddToProcessQueue([ptx, this] {"
      },
      {
        "sha": "f416f6678f7b2cb4b8aa88dd8fe437762090c73a",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=97d2b09c124e6e5803f7fd4503348d9710d1260f",
        "patch": "@@ -42,6 +42,16 @@ void UnregisterAllValidationInterfaces();\n  * will result in a deadlock (that DEBUG_LOCKORDER will miss).\n  */\n void CallFunctionInValidationInterfaceQueue(std::function<void ()> func);\n+/**\n+ * This is a synonym for the following, which asserts certain locks are not\n+ * held:\n+ *     std::promise<void> promise;\n+ *     CallFunctionInValidationInterfaceQueue([&promise] {\n+ *         promise.set_value();\n+ *     });\n+ *     promise.get_future().wait();\n+ */\n+void SyncWithValidationInterfaceQueue();\n \n class CValidationInterface {\n protected:"
      },
      {
        "sha": "cf9bb2909fb65c0f1dc80aaf08d958ea6487ee51",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97d2b09c124e6e5803f7fd4503348d9710d1260f/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=97d2b09c124e6e5803f7fd4503348d9710d1260f",
        "patch": "@@ -1292,12 +1292,7 @@ void CWallet::BlockUntilSyncedToCurrentChain() {\n     // ...otherwise put a callback in the validation interface queue and wait\n     // for the queue to drain enough to execute it (indicating we are caught up\n     // at least with the time we entered this function).\n-\n-    std::promise<void> promise;\n-    CallFunctionInValidationInterfaceQueue([&promise] {\n-        promise.set_value();\n-    });\n-    promise.get_future().wait();\n+    SyncWithValidationInterfaceQueue();\n }\n \n "
      }
    ]
  }
]