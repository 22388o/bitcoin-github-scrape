[
  {
    "sha": "eeeef80fb69480147e925d8ab2c75f456ff7b1b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZWVlZjgwZmI2OTQ4MDE0N2U5MjVkOGFiMmM3NWY0NTZmZjdiMWI3",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-07-10T20:20:24Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-07-13T20:14:44Z"
      },
      "message": "qa: Fix some TODOs in p2p_segwit",
      "tree": {
        "sha": "1b1b0026aab64a4f7c8c6e30d9319feac97177f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1b1b0026aab64a4f7c8c6e30d9319feac97177f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eeeef80fb69480147e925d8ab2c75f456ff7b1b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbSQg0AAoJEM4rdWl+aaVIFCYL/3iuLHDFoMr3Jb+elS1Jrlj8\nE5xCfMSL5Am6cq/vi3EscO5PicfHdxaqw4i7g8K0UwvgBB6ESvLvxa9p5BI/Dpzf\ntEFzZ6cqoHixGLlw8+QDCg/pwAFHLPHwayme23Wv1RDu+fA1majfEugnH/9Hm9k9\nFFWtWl7RGqpfjpnHxfWWVrqRSGsykXbEPuVqgKz1cQQ9AHjvbjBowVlOyK/7/bx7\nYDMPpuWBzHNhWG918BvnZ627zz+eTx0zz+n74TjAnePLnv1sLLgjjgXgO0Z98ypL\niCzXor3TwPl5Nb0oyOULcgFIwZjL99grng3PyheK5G/UKr3pf3Bev40jjOUrp4BU\nrYXAbWegnj64oDmV78TMAe5QyhWemJSIdIZ4IKu49fuo+gvOMLU0ixc4oie/tHFg\n+u3W6HZ9YNml2C0c80/hVJkYd1OUbje/FY1CWm5t1+NosYr5/NIhX+jql3IJguor\nKGv2sWYm7qhoL7kmRZgdJitxWv7PinIU7KJjimObUA==\n=kmPq\n-----END PGP SIGNATURE-----",
        "payload": "tree 1b1b0026aab64a4f7c8c6e30d9319feac97177f4\nparent fad42e8c4a9d625146f82bab9a038d945d40ac4f\nauthor MarcoFalke <falke.marco@gmail.com> 1531254024 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1531512884 -0400\n\nqa: Fix some TODOs in p2p_segwit\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeeef80fb69480147e925d8ab2c75f456ff7b1b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eeeef80fb69480147e925d8ab2c75f456ff7b1b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeeef80fb69480147e925d8ab2c75f456ff7b1b7/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fad42e8c4a9d625146f82bab9a038d945d40ac4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fad42e8c4a9d625146f82bab9a038d945d40ac4f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fad42e8c4a9d625146f82bab9a038d945d40ac4f"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 14,
      "deletions": 24
    },
    "files": [
      {
        "sha": "801c4b87a0918d9b8b1f1f0bfdc0c3f74766b303",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 14,
        "deletions": 24,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eeeef80fb69480147e925d8ab2c75f456ff7b1b7/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eeeef80fb69480147e925d8ab2c75f456ff7b1b7/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=eeeef80fb69480147e925d8ab2c75f456ff7b1b7",
        "patch": "@@ -41,6 +41,7 @@\n from test_framework.mininode import (\n     P2PInterface,\n     mininode_lock,\n+    wait_until,\n )\n from test_framework.script import (\n     CScript,\n@@ -221,7 +222,7 @@ def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n         block.solve()\n \n     def run_test(self):\n-        # Setup the p2p connections and start up the network thread.\n+        # Setup the p2p connections\n         # self.test_node sets NODE_WITNESS|NODE_NETWORK\n         self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(), services=NODE_NETWORK | NODE_WITNESS)\n         # self.old_node sets only NODE_NETWORK\n@@ -351,10 +352,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n         test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n-        # TODO: fix synchronization so we can test reject reason\n-        # Right now, bitcoind delays sending reject messages for blocks\n-        # until the future, making synchronization here difficult.\n-        # assert_equal(self.test_node.last_message[\"reject\"].reason, \"unexpected-witness\")\n+        wait_until(lambda: 'reject' in self.test_node.last_message and self.test_node.last_message[\"reject\"].reason ==  b\"unexpected-witness\")\n \n         # But it should not be permanently marked bad...\n         # Resend without witness information.\n@@ -605,9 +603,6 @@ def test_getblocktemplate_before_lockin(self):\n     @subtest\n     def advance_to_segwit_lockin(self):\n         \"\"\"Mine enough blocks to lock in segwit, but don't activate.\"\"\"\n-        # TODO: we could verify that lockin only happens at the right threshold of\n-        # signalling blocks, rather than just at the right period boundary.\n-\n         height = self.nodes[0].getblockcount()\n         # Advance to end of period, and verify lock-in happens at the end\n         self.nodes[0].generate(VB_PERIOD - 1)\n@@ -741,9 +736,6 @@ def test_standardness_v0(self):\n     @subtest\n     def advance_to_segwit_active(self):\n         \"\"\"Mine enough blocks to activate segwit.\"\"\"\n-        # TODO: we could verify that activation only happens at the right threshold\n-        # of signalling blocks, rather than just at the right period boundary.\n-\n         height = self.nodes[0].getblockcount()\n         self.nodes[0].generate(VB_PERIOD - (height % VB_PERIOD) - 2)\n         assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n@@ -1402,30 +1394,28 @@ def test_segwit_versions(self):\n         Future segwit version transactions are non-standard, but valid in blocks.\n         Can run this before and after segwit activation.\"\"\"\n \n-        num_tests = 17  # will test OP_0, OP1, ..., OP_16\n-        if (len(self.utxo) < num_tests):\n+        NUM_SEGWIT_VERSIONS = 17  # will test OP_0, OP1, ..., OP_16\n+        if len(self.utxo) < NUM_SEGWIT_VERSIONS:\n             tx = CTransaction()\n             tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n-            split_value = (self.utxo[0].nValue - 4000) // num_tests\n-            for i in range(num_tests):\n+            split_value = (self.utxo[0].nValue - 4000) // NUM_SEGWIT_VERSIONS\n+            for i in range(NUM_SEGWIT_VERSIONS):\n                 tx.vout.append(CTxOut(split_value, CScript([OP_TRUE])))\n             tx.rehash()\n             block = self.build_next_block()\n             self.update_witness_block_with_transactions(block, [tx])\n             test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n             self.utxo.pop(0)\n-            for i in range(num_tests):\n+            for i in range(NUM_SEGWIT_VERSIONS):\n                 self.utxo.append(UTXO(tx.sha256, i, split_value))\n \n         sync_blocks(self.nodes)\n         temp_utxo = []\n         tx = CTransaction()\n-        count = 0\n         witness_program = CScript([OP_TRUE])\n         witness_hash = sha256(witness_program)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n-            count += 1\n             # First try to spend to a future version segwit script_pubkey.\n             script_pubkey = CScript([CScriptOp(version), witness_hash])\n             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n@@ -1680,19 +1670,19 @@ def test_signature_version_1(self):\n         # Test combinations of signature hashes.\n         # Split the utxo into a lot of outputs.\n         # Randomly choose up to 10 to spend, sign with different hashtypes, and\n-        # output to a random number of outputs.  Repeat num_tests times.\n+        # output to a random number of outputs.  Repeat NUM_SIGHASH_TESTS times.\n         # Ensure that we've tested a situation where we use SIGHASH_SINGLE with\n         # an input index > number of outputs.\n-        num_tests = 500\n+        NUM_SIGHASH_TESTS = 500\n         temp_utxos = []\n         tx = CTransaction()\n         tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n-        split_value = prev_utxo.nValue // num_tests\n-        for i in range(num_tests):\n+        split_value = prev_utxo.nValue // NUM_SIGHASH_TESTS\n+        for i in range(NUM_SIGHASH_TESTS):\n             tx.vout.append(CTxOut(split_value, script_pubkey))\n         tx.wit.vtxinwit.append(CTxInWitness())\n         sign_p2pk_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n-        for i in range(num_tests):\n+        for i in range(NUM_SIGHASH_TESTS):\n             temp_utxos.append(UTXO(tx.sha256, i, split_value))\n \n         block = self.build_next_block()\n@@ -1701,7 +1691,7 @@ def test_signature_version_1(self):\n \n         block = self.build_next_block()\n         used_sighash_single_out_of_bounds = False\n-        for i in range(num_tests):\n+        for i in range(NUM_SIGHASH_TESTS):\n             # Ping regularly to keep the connection alive\n             if (not i % 100):\n                 self.test_node.sync_with_ping()"
      }
    ]
  }
]