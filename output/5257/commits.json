[
  {
    "sha": "11d3b9939c98381d2246a3299a9cab5ced55e49e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMWQzYjk5MzljOTgzODFkMjI0NmEzMjk5YTljYWI1Y2VkNTVlNDll",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-05T18:53:59Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "message": "Do signature-s negation inside the tests\n\nTo avoid the need for libsecp256k1 to expose such functionality.",
      "tree": {
        "sha": "2850672169ed04c051d3d70f65b3d29aadfc8027",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2850672169ed04c051d3d70f65b3d29aadfc8027"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11d3b9939c98381d2246a3299a9cab5ced55e49e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11d3b9939c98381d2246a3299a9cab5ced55e49e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/11d3b9939c98381d2246a3299a9cab5ced55e49e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11d3b9939c98381d2246a3299a9cab5ced55e49e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5406f61373fe93326ab1f546e4da9f4528236cc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5406f61373fe93326ab1f546e4da9f4528236cc7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5406f61373fe93326ab1f546e4da9f4528236cc7"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 52,
      "deletions": 7
    },
    "files": [
      {
        "sha": "3377dce0c1241033852a5107d02524deda0df5c7",
        "filename": "src/ecwrapper.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/ecwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/ecwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.cpp?ref=11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "patch": "@@ -193,7 +193,7 @@ bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size) {\n     return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n }\n \n-bool CECKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS) {\n+bool CECKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) {\n     vchSig.clear();\n     ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n     if (sig == NULL)\n@@ -205,7 +205,7 @@ bool CECKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool\n     BIGNUM *halforder = BN_CTX_get(ctx);\n     EC_GROUP_get_order(group, order, ctx);\n     BN_rshift1(halforder, order);\n-    if (lowS && BN_cmp(sig->s, halforder) > 0) {\n+    if (BN_cmp(sig->s, halforder) > 0) {\n         // enforce low S values, by negating the value (modulo the order) if above order/2.\n         BN_sub(sig->s, order, sig->s);\n     }"
      },
      {
        "sha": "a7847d190c1e8400d2b0e45b529fc102de42f9d3",
        "filename": "src/ecwrapper.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/ecwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/ecwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.h?ref=11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "patch": "@@ -28,7 +28,7 @@ class CECKey {\n     bool SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck=false);\n     void GetPubKey(std::vector<unsigned char>& pubkey, bool fCompressed);\n     bool SetPubKey(const unsigned char* pubkey, size_t size);\n-    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS);\n+    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig);\n     bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n     bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec);\n "
      },
      {
        "sha": "0ca9a681a3baac1a2c66745cc72f114496d47d40",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "patch": "@@ -102,7 +102,7 @@ CPubKey CKey::GetPubKey() const {\n     return result;\n }\n \n-bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lowS) const {\n+bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n     if (!fValid)\n         return false;\n #ifdef USE_SECP256K1\n@@ -119,7 +119,7 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, bool lo\n #else\n     CECKey key;\n     key.SetSecretBytes(vch);\n-    return key.Sign(hash, vchSig, lowS);\n+    return key.Sign(hash, vchSig);\n #endif\n }\n "
      },
      {
        "sha": "0bb05482c9ceb7b41ded3ba599c03de4f0108b28",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "patch": "@@ -122,7 +122,7 @@ class CKey\n     CPubKey GetPubKey() const;\n \n     //! Create a DER-serialized signature.\n-    bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig, bool lowS = true) const;\n+    bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig) const;\n \n     /**\n      * Create a compact signature (65 bytes), which allows reconstructing the used public key."
      },
      {
        "sha": "cff1664a1e9f26491e89f6d3675a79291c475b89",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 1,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "patch": "@@ -95,6 +95,48 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, bo\n     BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, flags, SignatureChecker(BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey)), 0)) == expect, message);\n }\n \n+void static NegateSignatureS(std::vector<unsigned char>& vchSig) {\n+    // Parse the signature.\n+    std::vector<unsigned char> r, s;\n+    r = std::vector<unsigned char>(vchSig.begin() + 4, vchSig.begin() + 4 + vchSig[3]);\n+    s = std::vector<unsigned char>(vchSig.begin() + 6 + vchSig[3], vchSig.begin() + 6 + vchSig[3] + vchSig[5 + vchSig[3]]);\n+    unsigned char hashtype = vchSig.back();\n+\n+    // Really ugly to implement mod-n negation here, but it would be feature creep to expose such functionality from libsecp256k1.\n+    static const unsigned char order[33] = {\n+        0x00,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n+        0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n+        0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41\n+    };\n+    while (s.size() < 33) {\n+        s.insert(s.begin(), 0x00);\n+    }\n+    int carry = 0;\n+    for (int p = 32; p >= 1; p--) {\n+        int n = (int)order[p] - s[p] - carry;\n+        s[p] = (n + 256) & 0xFF;\n+        carry = (n < 0);\n+    }\n+    assert(carry == 0);\n+    if (s.size() > 1 && s[0] == 0 && s[1] < 0x80) {\n+        s.erase(s.begin());\n+    }\n+\n+    // Reconstruct the signature.\n+    vchSig.clear();\n+    vchSig.push_back(0x30);\n+    vchSig.push_back(4 + r.size() + s.size());\n+    vchSig.push_back(0x02);\n+    vchSig.push_back(r.size());\n+    vchSig.insert(vchSig.end(), r.begin(), r.end());\n+    vchSig.push_back(0x02);\n+    vchSig.push_back(s.size());\n+    vchSig.insert(vchSig.end(), s.begin(), s.end());\n+    vchSig.push_back(hashtype);\n+}\n+\n namespace\n {\n const unsigned char vchKey0[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n@@ -194,7 +236,10 @@ class TestBuilder\n         uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType);\n         std::vector<unsigned char> vchSig, r, s;\n         do {\n-            key.Sign(hash, vchSig, lenS <= 32);\n+            key.Sign(hash, vchSig);\n+            if ((lenS == 33) != (vchSig[5 + vchSig[3]] == 33)) {\n+                NegateSignatureS(vchSig);\n+            }\n             r = std::vector<unsigned char>(vchSig.begin() + 4, vchSig.begin() + 4 + vchSig[3]);\n             s = std::vector<unsigned char>(vchSig.begin() + 6 + vchSig[3], vchSig.begin() + 6 + vchSig[3] + vchSig[5 + vchSig[3]]);\n         } while (lenR != r.size() || lenS != s.size());"
      }
    ]
  },
  {
    "sha": "a4d66b1c24c601191bfb13c34bd759767c05b10b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNGQ2NmIxYzI0YzYwMTE5MWJmYjEzYzM0YmQ3NTk3NjdjMDViMTBi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "message": "Squashed 'src/secp256k1/' content from commit ef6f677\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: ef6f677679d7c2a5ba7d3ad85da0456a1d086a3e",
      "tree": {
        "sha": "6107cc68b4826afffa4d93b964b7fd18f6a3a435",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6107cc68b4826afffa4d93b964b7fd18f6a3a435"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a4d66b1c24c601191bfb13c34bd759767c05b10b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4d66b1c24c601191bfb13c34bd759767c05b10b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a4d66b1c24c601191bfb13c34bd759767c05b10b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4d66b1c24c601191bfb13c34bd759767c05b10b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [],
    "stats": {
      "total": 7372,
      "additions": 7372,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1d16cfcc1217ac6828c64760dcd21d70b7906bc2",
        "filename": ".gitignore",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,35 @@\n+bench_inv\n+bench_sign\n+bench_verify\n+tests\n+*.exe\n+*.so\n+*.a\n+!.gitignore\n+\n+Makefile\n+configure\n+.libs/\n+Makefile.in\n+aclocal.m4\n+autom4te.cache/\n+config.log\n+config.status\n+*.tar.gz\n+*.la\n+libtool\n+.deps/\n+.dirstamp\n+src/build-aux/\n+*.lo\n+*.o\n+*~\n+src/libsecp256k1-config.h\n+src/libsecp256k1-config.h.in\n+m4/libtool.m4\n+m4/ltoptions.m4\n+m4/ltsugar.m4\n+m4/ltversion.m4\n+m4/lt~obsolete.m4\n+src/stamp-h1\n+libsecp256k1.pc"
      },
      {
        "sha": "cbafed7a587c2fd0d856b65950f1858406442067",
        "filename": ".travis.yml",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,24 @@\n+language: cpp\n+compiler: gcc\n+install:\n+  - sudo apt-get install -qq libssl-dev\n+  - if [ \"$BIGNUM\" = \"gmp\" -o \"$BIGNUM\" = \"auto\" -o \"$FIELD\" = \"gmp\" ]; then sudo apt-get install -qq libgmp-dev; fi\n+  - if [ \"$FIELD\" = \"64bit_asm\" ]; then sudo apt-get install -qq yasm; fi\n+env:\n+  global:\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  BUILD=check\n+  matrix:\n+    - SCALAR=32bit\n+    - SCALAR=64bit\n+    - FIELD=gmp\n+    - FIELD=gmp       ENDOMORPHISM=yes\n+    - FIELD=64bit_asm\n+    - FIELD=64bit_asm ENDOMORPHISM=yes\n+    - FIELD=64bit\n+    - FIELD=64bit     ENDOMORPHISM=yes\n+    - FIELD=32bit\n+    - FIELD=32bit     ENDOMORPHISM=yes\n+    - BUILD=distcheck\n+before_script: ./autogen.sh\n+script: ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR && make -j2 $BUILD\n+os: linux"
      },
      {
        "sha": "4522a5990e2823f2be0db7efcbc4fca139c08025",
        "filename": "COPYING",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/COPYING",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/COPYING",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/COPYING?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,19 @@\n+Copyright (c) 2013 Pieter Wuille\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
      },
      {
        "sha": "7f16ef40b0225803e9fe5ad0e0a6f03ad3008270",
        "filename": "Makefile.am",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,87 @@\n+ACLOCAL_AMFLAGS = -I m4\n+INCLUDES = $(SECP_INCLUDES)\n+lib_LTLIBRARIES = libsecp256k1.la\n+if USE_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+else\n+COMMON_LIB =\n+endif\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+include_HEADERS = include/secp256k1.h\n+noinst_HEADERS =\n+noinst_HEADERS += src/scalar.h\n+noinst_HEADERS += src/scalar_4x64.h\n+noinst_HEADERS += src/scalar_8x32.h\n+noinst_HEADERS += src/scalar_impl.h\n+noinst_HEADERS += src/scalar_4x64_impl.h\n+noinst_HEADERS += src/scalar_8x32_impl.h\n+noinst_HEADERS += src/group.h\n+noinst_HEADERS += src/group_impl.h\n+noinst_HEADERS += src/num_gmp.h\n+noinst_HEADERS += src/num_gmp_impl.h\n+noinst_HEADERS += src/ecdsa.h\n+noinst_HEADERS += src/ecdsa_impl.h\n+noinst_HEADERS += src/eckey.h\n+noinst_HEADERS += src/eckey_impl.h\n+noinst_HEADERS += src/ecmult.h\n+noinst_HEADERS += src/ecmult_impl.h\n+noinst_HEADERS += src/ecmult_gen.h\n+noinst_HEADERS += src/ecmult_gen_impl.h\n+noinst_HEADERS += src/num.h\n+noinst_HEADERS += src/num_impl.h\n+noinst_HEADERS += src/field_10x26.h\n+noinst_HEADERS += src/field_10x26_impl.h\n+noinst_HEADERS += src/field_5x52.h\n+noinst_HEADERS += src/field_5x52_impl.h\n+noinst_HEADERS += src/field_5x52_int128_impl.h\n+noinst_HEADERS += src/field_5x52_asm_impl.h\n+noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/util.h\n+noinst_HEADERS += src/util_impl.h\n+noinst_HEADERS += src/field_gmp.h\n+noinst_HEADERS += src/field_gmp_impl.h\n+noinst_HEADERS += src/field.h\n+noinst_HEADERS += src/field_impl.h\n+\n+pkgconfigdir = $(libdir)/pkgconfig\n+pkgconfig_DATA = libsecp256k1.pc\n+\n+if USE_ASM\n+libsecp256k1_common_la_SOURCES = src/field_5x52_asm.asm\n+endif\n+\n+libsecp256k1_la_SOURCES = src/secp256k1.c\n+libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(COMMON_LIB) $(SECP_LIBS)\n+\n+\n+noinst_PROGRAMS =\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_verify bench_sign bench_inv\n+bench_verify_SOURCES = src/bench_verify.c\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDFLAGS = -static\n+bench_sign_SOURCES = src/bench_sign.c\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDFLAGS = -static\n+bench_inv_SOURCES = src/bench_inv.c\n+bench_inv_LDADD = $(COMMON_LIB) $(SECP_LIBS)\n+bench_inv_LDFLAGS = -static\n+endif\n+\n+if USE_TESTS\n+noinst_PROGRAMS += tests\n+tests_SOURCES = src/tests.c\n+tests_CPPFLAGS = -DVERIFY $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(COMMON_LIB) $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_LDFLAGS = -static\n+TESTS = tests\n+endif\n+\n+EXTRA_DIST = autogen.sh nasm_lt.sh\n+\n+#x86_64 only\n+if USE_ASM\n+.asm.lo:\n+\t$(LIBTOOL) --mode=compile --tag YASM $(srcdir)/nasm_lt.sh $(YASM) -f $(YASM_BINFMT) $(YAFLAGS) -I$(srcdir) -I. $< -o $@\n+endif"
      },
      {
        "sha": "32750bde9249cb2d3e592316165998383ac525b5",
        "filename": "README.md",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,49 @@\n+libsecp256k1\n+============\n+\n+[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+\n+Optimized C library for EC operations on curve secp256k1.\n+\n+This library is experimental, so use at your own risk.\n+\n+Features:\n+* Low-level field and group operations on secp256k1.\n+* ECDSA signing/verification and key generation.\n+* Adding/multiplying private/public keys.\n+* Serialization/parsing of private keys, public keys, signatures.\n+* Very efficient implementation.\n+\n+Implementation details\n+----------------------\n+\n+* General\n+  * Avoid dynamic memory usage almost everywhere.\n+* Field operations\n+  * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n+    * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n+    * Using 10 26-bit limbs.\n+    * Using GMP.\n+  * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n+* Group operations\n+  * Point addition formula specifically simplified for the curve equation (y^2 = x^3 + 7).\n+  * Use addition between points in Jacobian and affine coordinates where possible.\n+* Point multiplication for verification (a*P + b*G).\n+  * Use wNAF notation for point multiplicands.\n+  * Use a much larger window for multiples of G, using precomputed multiples.\n+  * Use Shamir's trick to do the multiplication with the public key and the generator simultaneously.\n+  * Optionally use secp256k1's efficiently-computable endomorphism to split the multiplicands into 4 half-sized ones first.\n+* Point multiplication for signing\n+  * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n+  * Slice the precomputed table in memory per byte, so memory access to the table becomes uniform.\n+  * Not fully constant-time, but the precomputed tables add and eventually subtract points for which no known scalar (private key) is known, blinding non-constant time effects even from an attacker with control over the private key used.\n+\n+Build steps\n+-----------\n+\n+libsecp256k1 is built using autotools:\n+\n+    $ ./autogen.sh\n+    $ ./configure\n+    $ make\n+    $ sudo make install  # optional"
      },
      {
        "sha": "a300e1c5eb9b1376c82b1f5d557d56be5708546f",
        "filename": "TODO",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/TODO",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/TODO",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/TODO?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,3 @@\n+* Unit tests for fieldelem/groupelem, including ones intended to\n+  trigger fieldelem's boundary cases.\n+* Complete constant-time operations for signing/keygen"
      },
      {
        "sha": "4e7cc05373fcf90aaa10d64f20e6cc7ef1825cd0",
        "filename": "autogen.sh",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/autogen.sh?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,2 @@\n+#!/bin/sh\n+autoreconf -if"
      },
      {
        "sha": "c22669002ceab8f3814c72f2ec02c77e71527048",
        "filename": "configure.ac",
        "status": "added",
        "additions": 336,
        "deletions": 0,
        "changes": 336,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,336 @@\n+AC_PREREQ([2.60])\n+AC_INIT([libsecp256k1],[0.1])\n+AC_CONFIG_AUX_DIR([src/build-aux])\n+AC_CONFIG_MACRO_DIR([m4])\n+AC_CANONICAL_HOST\n+AH_TOP([#ifndef LIBSECP256K1_CONFIG_H])\n+AH_TOP([#define LIBSECP256K1_CONFIG_H])\n+AH_BOTTOM([#endif //LIBSECP256K1_CONFIG_H])\n+AM_INIT_AUTOMAKE([foreign])\n+LT_INIT\n+\n+dnl make the compilation flags quiet unless V=1 is used\n+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n+\n+AC_PROG_CC\n+AC_PROG_CPP\n+AC_PROG_INSTALL\n+AC_PROG_SED\n+PKG_PROG_PKG_CONFIG\n+\n+AC_PATH_TOOL(AR, ar)\n+AC_PATH_TOOL(RANLIB, ranlib)\n+AC_PATH_TOOL(STRIP, strip)\n+\n+AC_PROG_CC_C99\n+if test x\"$ac_cv_prog_cc_c99\" == x\"no\"; then\n+  AC_MSG_ERROR([c99 compiler support required])\n+fi\n+\n+case $host in\n+  *mingw*)\n+     use_pkgconfig=no\n+     ;;\n+   *)\n+     use_pkgconfig=yes\n+     ;;\n+esac\n+\n+case $host_os in\n+  darwin*)\n+     CPPFLAGS=\"$CPPFLAGS -I/opt/local/include\"\n+     LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n+     ;;\n+esac\n+\n+AC_ARG_ENABLE(benchmark,\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    [use_benchmark=$enableval],\n+    [use_benchmark=yes])\n+\n+AC_ARG_ENABLE(tests,\n+    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    [use_tests=$enableval],\n+    [use_tests=yes])\n+\n+AC_ARG_ENABLE(endomorphism,\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    [use_endomorphism=$enableval],\n+    [use_endomorphism=no])\n+\n+AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=gmp|64bit|64bit_asm|32bit|auto],\n+[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+\n+AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|auto],\n+[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+\n+AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n+[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_CHECK_TYPES([__int128])\n+\n+AC_DEFUN([SECP_INT128_CHECK],[\n+has_int128=$ac_cv_type___int128\n+if test x\"$has_int128\" != x\"yes\" && test x\"$set_field\" = x\"64bit\"; then\n+  AC_MSG_ERROR([$set_field field support explicitly requested but is not compatible with this host])\n+fi\n+if test x\"$has_int128\" != x\"yes\" && test x\"$set_scalar\" = x\"64bit\"; then\n+  AC_MSG_ERROR([$set_scalar scalar support explicitly requested but is not compatible with this host])\n+fi\n+])\n+\n+AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n+if test x\"$host_cpu\" == x\"x86_64\"; then\n+  AC_CHECK_PROG(YASM, yasm, yasm)\n+else\n+  if test x\"$set_field\" = x\"64bit_asm\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but is not compatible with this host])\n+  fi\n+fi\n+if test x$YASM = x; then\n+  if test x\"$set_field\" = x\"64bit_asm\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but yasm was not found])\n+  fi\n+  has_64bit_asm=no\n+else\n+  case x\"$host_os\" in\n+  xdarwin*)\n+    YASM_BINFMT=macho64\n+    ;;\n+  x*-gnux32)\n+    YASM_BINFMT=elfx32\n+    ;;\n+  *)\n+    YASM_BINFMT=elf64\n+    ;;\n+  esac\n+  if $YASM -f help | grep -q $YASM_BINFMT; then\n+    has_64bit_asm=yes\n+  else\n+    if test x\"$set_field\" = x\"64bit_asm\"; then\n+      AC_MSG_ERROR([$set_field field support explicitly requested but yasm doesn't support $YASM_BINFMT format])\n+    fi\n+    AC_MSG_WARN([yasm too old for $YASM_BINFMT format])\n+    has_64bit_asm=no\n+  fi\n+fi\n+])\n+\n+AC_DEFUN([SECP_OPENSSL_CHECK],[\n+if test x\"$use_pkgconfig\" = x\"yes\"; then\n+    : #NOP\n+  m4_ifdef([PKG_CHECK_MODULES],[\n+    PKG_CHECK_MODULES([CRYPTO], [libcrypto], [has_libcrypto=yes; AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])],[has_libcrypto=no])\n+    : #NOP\n+  ])\n+else\n+  AC_CHECK_HEADER(openssl/crypto.h,[AC_CHECK_LIB(crypto, main,[has_libcrypto=yes; CRYPTO_LIBS=-lcrypto; AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])]\n+)])\n+  LIBS=\n+fi\n+if test x\"$has_libcrypto\" == x\"yes\" && test x\"$has_openssl_ec\" = x; then\n+  AC_MSG_CHECKING(for EC functions in libcrypto)\n+  AC_TRY_COMPILE([\n+    #include <openssl/ec.h>\n+    #include <openssl/ecdsa.h>\n+    #include <openssl/obj_mac.h>],[\n+    EC_KEY *eckey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    ECDSA_sign(0, NULL, 0, NULL, NULL, eckey);\n+    ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n+    EC_KEY_free(eckey);\n+  ],[has_openssl_ec=yes], [has_openssl_ec=no])\n+  AC_MSG_RESULT([$has_openssl_ec])\n+fi\n+])\n+\n+AC_CHECK_DECL(__builtin_expect,AC_DEFINE(HAVE_BUILTIN_EXPECT,1,[Define this symbol if __builtin_expect is available]),,)\n+\n+AC_DEFUN([SECP_GMP_CHECK],[\n+if test x\"$has_gmp\" != x\"yes\"; then\n+  AC_CHECK_HEADER(gmp.h,[AC_CHECK_LIB(gmp, __gmpz_init,[has_gmp=yes; GMP_LIBS=-lgmp; AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])])])\n+fi\n+if test x\"$set_field\" = x\"gmp\" && test x\"$has_gmp\" != x\"yes\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but libgmp was not found])\n+fi\n+if test x\"$set_bignum\" = x\"gmp\" && test x\"$has_gmp\" != x\"yes\"; then\n+    AC_MSG_ERROR([$set_bignum field support explicitly requested but libgmp was not found])\n+fi\n+])\n+\n+if test x\"$req_field\" = x\"auto\"; then\n+  SECP_64BIT_ASM_CHECK\n+  if test x\"$has_64bit_asm\" = x\"yes\"; then\n+    set_field=64bit_asm\n+  fi\n+\n+  if test x\"$set_field\" = x; then\n+    SECP_INT128_CHECK\n+    if test x\"$has_int128\" = x\"yes\"; then\n+      set_field=64bit\n+    fi\n+  fi\n+\n+  if test x\"$set_field\" = x; then\n+    SECP_GMP_CHECK\n+    if test x\"$has_gmp\" = x\"yes\"; then\n+      set_field=gmp\n+    fi\n+  fi\n+\n+  if test x\"$set_field\" = x; then\n+    set_field=32bit\n+  fi\n+else\n+  set_field=$req_field\n+  case $set_field in\n+  64bit_asm)\n+    SECP_64BIT_ASM_CHECK\n+    ;;\n+  64bit)\n+    SECP_INT128_CHECK\n+    ;;\n+  gmp)\n+    SECP_GMP_CHECK\n+    ;;\n+  32bit)\n+    ;;\n+  *)\n+    AC_MSG_ERROR([invalid field implementation selection])\n+    ;;\n+  esac\n+fi\n+\n+if test x\"$req_scalar\" = x\"auto\"; then\n+  if test x\"$set_scalar\" = x; then\n+    SECP_INT128_CHECK\n+    if test x\"$has_int128\" = x\"yes\"; then\n+      set_scalar=64bit\n+    fi\n+  fi\n+  if test x\"$set_scalar\" = x; then\n+    set_scalar=32bit\n+  fi\n+else\n+  set_scalar=$req_scalar\n+  case $set_scalar in\n+  64bit)\n+    SECP_INT128_CHECK\n+    ;;\n+  32bit)\n+    ;;\n+  *)\n+    AC_MSG_ERROR([invalid scalar implementation selected])\n+    ;;\n+  esac\n+fi\n+\n+if test x\"$req_bignum\" = x\"auto\"; then\n+  SECP_GMP_CHECK\n+  if test x\"$has_gmp\" = x\"yes\"; then\n+    set_bignum=gmp\n+  fi\n+\n+  if test x\"$set_bignum\" = x; then\n+    AC_MSG_ERROR([no working bignum implementation found])\n+  fi\n+else\n+  set_bignum=$req_bignum\n+  case $set_bignum in\n+  gmp)\n+    SECP_GMP_CHECK\n+    ;;\n+  openssl)\n+    SECP_OPENSSL_CHECK\n+    ;;\n+  *)\n+    AC_MSG_ERROR([invalid bignum implementation selection])\n+    ;;\n+  esac\n+fi\n+\n+# select field implementation\n+case $set_field in\n+64bit_asm)\n+  AC_DEFINE(USE_FIELD_5X52_ASM, 1, [Define this symbol to use the assembly version for the 5x52 field implementation])\n+  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+  ;;\n+64bit)\n+  AC_DEFINE(USE_FIELD_5X52_INT128, 1, [Define this symbol to use the __int128 version for the 5x52 field implementation])\n+  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+  ;;\n+gmp)\n+  AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])\n+  AC_DEFINE(USE_FIELD_GMP, 1, [Define this symbol to use the FIELD_GMP implementation])\n+  ;;\n+32bit)\n+  AC_DEFINE(USE_FIELD_10X26, 1, [Define this symbol to use the FIELD_10X26 implementation])\n+  ;;\n+*)\n+  AC_MSG_ERROR([invalid field implementation])\n+  ;;\n+esac\n+\n+# select bignum implementation\n+case $set_bignum in\n+gmp)\n+  AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])\n+  AC_DEFINE(USE_NUM_GMP, 1, [Define this symbol to use the gmp implementation])\n+  AC_DEFINE(USE_FIELD_INV_NUM, 1, [Define this symbol to use the USE_FIELD_INV_NUM implementation])\n+  ;;\n+*)\n+  AC_MSG_ERROR([invalid bignum implementation])\n+  ;;\n+esac\n+\n+#select scalar implementation\n+case $set_scalar in\n+64bit)\n+  AC_DEFINE(USE_SCALAR_4X64, 1, [Define this symbol to use the 4x64 scalar implementation])\n+  ;;\n+32bit)\n+  AC_DEFINE(USE_SCALAR_8X32, 1, [Define this symbol to use the 8x32 scalar implementation])\n+  ;;\n+*)\n+  AC_MSG_ERROR([invalid scalar implementation])\n+  ;;\n+esac\n+\n+if test x\"$use_tests\" = x\"yes\"; then\n+  SECP_OPENSSL_CHECK\n+  if test x\"$has_openssl_ec\" == x\"yes\"; then\n+    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+    case $host in\n+    *mingw*)\n+      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+      ;;\n+    esac\n+\n+  fi\n+fi\n+\n+if test x\"$set_field\" = x\"gmp\" || test x\"$set_bignum\" = x\"gmp\"; then\n+  SECP_LIBS=\"$SECP_LIBS $GMP_LIBS\"\n+fi\n+\n+if test x\"$use_endomorphism\" = x\"yes\"; then\n+  AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism])\n+fi\n+\n+AC_MSG_NOTICE([Using field implementation: $set_field])\n+AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n+AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n+\n+AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n+AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(SECP_INCLUDES)\n+AC_SUBST(SECP_LIBS)\n+AC_SUBST(SECP_TEST_LIBS)\n+AC_SUBST(SECP_TEST_INCLUDES)\n+AC_SUBST(YASM_BINFMT)\n+AM_CONDITIONAL([USE_ASM], [test x\"$set_field\" == x\"64bit_asm\"])\n+AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" != x\"no\"])\n+AC_OUTPUT"
      },
      {
        "sha": "cb5fd3c8894abe8d8b8eda88ccfdf7559117d553",
        "filename": "include/secp256k1.h",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,150 @@\n+#ifndef _SECP256K1_\n+#define _SECP256K1_\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Flags to pass to secp256k1_start. */\n+#define SECP256K1_START_VERIFY (1 << 0)\n+#define SECP256K1_START_SIGN   (1 << 1)\n+\n+/** Initialize the library. This may take some time (10-100 ms).\n+ *  You need to call this before calling any other function.\n+ *  It cannot run in parallel with any other functions, but once\n+ *  secp256k1_start() returns, all other functions are thread-safe.\n+ */\n+void secp256k1_start(unsigned int flags);\n+\n+/** Free all memory associated with this library. After this, no\n+ *  functions can be called anymore, except secp256k1_start()\n+ */\n+void secp256k1_stop(void);\n+\n+/** Verify an ECDSA signature.\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *          -1: invalid public key\n+ *          -2: invalid signature\n+ * Requires starting using SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ecdsa_verify(const unsigned char *msg, int msglen,\n+                           const unsigned char *sig, int siglen,\n+                           const unsigned char *pubkey, int pubkeylen);\n+\n+/** Create an ECDSA signature.\n+ *  Returns: 1: signature created\n+ *           0: nonce invalid, try another one\n+ *  In:      msg:    the message being signed\n+ *           msglen: the length of the message being signed\n+ *           seckey: pointer to a 32-byte secret key (assumed to be valid)\n+ *           nonce:  pointer to a 32-byte nonce (generated with a cryptographic PRNG)\n+ *  Out:     sig:    pointer to a 72-byte array where the signature will be placed.\n+ *           siglen: pointer to an int, which will be updated to the signature length (<=72).\n+ * Requires starting using SECP256K1_START_SIGN.\n+ */\n+int secp256k1_ecdsa_sign(const unsigned char *msg, int msglen,\n+                         unsigned char *sig, int *siglen,\n+                         const unsigned char *seckey,\n+                         const unsigned char *nonce);\n+\n+/** Create a compact ECDSA signature (64 byte + recovery id).\n+ *  Returns: 1: signature created\n+ *           0: nonce invalid, try another one\n+ *  In:      msg:    the message being signed\n+ *           msglen: the length of the message being signed\n+ *           seckey: pointer to a 32-byte secret key (assumed to be valid)\n+ *           nonce:  pointer to a 32-byte nonce (generated with a cryptographic PRNG)\n+ *  Out:     sig:    pointer to a 64-byte array where the signature will be placed.\n+ *           recid:  pointer to an int, which will be updated to contain the recovery id.\n+ * Requires starting using SECP256K1_START_SIGN.\n+ */\n+int secp256k1_ecdsa_sign_compact(const unsigned char *msg, int msglen,\n+                                 unsigned char *sig64,\n+                                 const unsigned char *seckey,\n+                                 const unsigned char *nonce,\n+                                 int *recid);\n+\n+/** Recover an ECDSA public key from a compact signature.\n+ *  Returns: 1: public key succesfully recovered (which guarantees a correct signature).\n+ *           0: otherwise.\n+ *  In:      msg:        the message assumed to be signed\n+ *           msglen:     the length of the message\n+ *           sig64:      signature as 64 byte array\n+ *           compressed: whether to recover a compressed or uncompressed pubkey\n+ *           recid:      the recovery id (as returned by ecdsa_sign_compact)\n+ *  Out:     pubkey:     pointer to a 33 or 65 byte array to put the pubkey.\n+ *           pubkeylen:  pointer to an int that will contain the pubkey length.\n+ * Requires starting using SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ecdsa_recover_compact(const unsigned char *msg, int msglen,\n+                                    const unsigned char *sig64,\n+                                    unsigned char *pubkey, int *pubkeylen,\n+                                    int compressed, int recid);\n+\n+/** Verify an ECDSA secret key.\n+ *  Returns: 1: secret key is valid\n+ *           0: secret key is invalid\n+ *  In:      seckey: pointer to a 32-byte secret key\n+ */\n+int secp256k1_ec_seckey_verify(const unsigned char *seckey);\n+\n+/** Just validate a public key.\n+ *  Returns: 1: valid public key\n+ *           0: invalid public key\n+ */\n+int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen);\n+\n+/** Compute the public key for a secret key.\n+ *  In:     compressed: whether the computed public key should be compressed\n+ *          seckey:     pointer to a 32-byte private key.\n+ *  Out:    pubkey:     pointer to a 33-byte (if compressed) or 65-byte (if uncompressed)\n+ *                      area to store the public key.\n+ *          pubkeylen:  pointer to int that will be updated to contains the pubkey's\n+ *                      length.\n+ *  Returns: 1: secret was valid, public key stores\n+ *           0: secret was invalid, try again.\n+ * Requires starting using SECP256K1_START_SIGN.\n+ */\n+int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed);\n+\n+/** Decompress a public key.\n+ * In/Out: pubkey:    pointer to a 65-byte array to put the decompressed public key.\n+                      It must contain a 33-byte or 65-byte public key already.\n+ *         pubkeylen: pointer to the size of the public key pointed to be pubkey.\n+                      It will be updated to reflect the new size.\n+ * Returns: 0 if the passed public key was invalid, 1 otherwise. If 1 is returned, the\n+            pubkey is replaced with its decompressed version.\n+ */\n+int secp256k1_ec_pubkey_decompress(unsigned char *pubkey, int *pubkeylen);\n+\n+/** Export a private key in DER format. */\n+int secp256k1_ec_privkey_export(const unsigned char *seckey,\n+                                unsigned char *privkey, int *privkeylen,\n+                                int compressed);\n+\n+/** Import a private key in DER format. */\n+int secp256k1_ec_privkey_import(unsigned char *seckey,\n+                                const unsigned char *privkey, int privkeylen);\n+\n+/** Tweak a private key by adding tweak to it. */\n+int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *tweak);\n+\n+/** Tweak a public key by adding tweak times the generator to it.\n+ * Requires starting with SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak);\n+\n+/** Tweak a private key by multiplying it with tweak. */\n+int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *tweak);\n+\n+/** Tweak a public key by multiplying it with tweak.\n+ * Requires starting with SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"
      },
      {
        "sha": "1c72dd00037b5cbef34d24792f809d700049e105",
        "filename": "libsecp256k1.pc.in",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/libsecp256k1.pc.in?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,13 @@\n+prefix=@prefix@\n+exec_prefix=@exec_prefix@\n+libdir=@libdir@\n+includedir=@includedir@\n+\n+Name: libsecp256k1\n+Description: Optimized C library for EC operations on curve secp256k1\n+URL: https://github.com/bitcoin/secp256k1\n+Version: @PACKAGE_VERSION@\n+Cflags: -I${includedir}\n+Libs.private: @SECP_LIBS@\n+Libs: -L${libdir} -lsecp256k1\n+"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "m4/.empty",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/m4/.empty",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/m4/.empty",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/m4/.empty?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b"
      },
      {
        "sha": "6cd73294c0617c5d186926f1a7903afbde11044c",
        "filename": "nasm_lt.sh",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/nasm_lt.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/nasm_lt.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/nasm_lt.sh?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,57 @@\n+#! /bin/sh\n+command=\"\"\n+infile=\"\"\n+o_opt=no\n+pic=no\n+while [ $# -gt 0 ]; do\n+    case \"$1\" in\n+        -DPIC|-fPIC|-fpic|-Kpic|-KPIC)\n+            if [ \"$pic\" != \"yes\" ] ; then\n+                command=\"$command -DPIC\"\n+                pic=yes\n+            fi\n+            ;;\n+        -f|-fbin|-faout|-faoutb|-fcoff|-felf|-felf64|-fas86| \\\n+        -fobj|-fwin32|-fwin64|-frdf|-fieee|-fmacho|-fmacho64)\n+            # it's a file format specifier for nasm.\n+            command=\"$command $1\"\n+            ;;\n+        -f*)\n+            # maybe a code-generation flag for gcc.\n+            ;;\n+        -[Ii]*)\n+            incdir=`echo \"$1\" | sed 's/^-[Ii]//'`\n+            if [ \"x$incdir\" = x -a \"x$2\" != x ] ; then\n+                case \"$2\" in\n+                    -*) ;;\n+                    *) incdir=\"$2\"; shift;;\n+                esac\n+            fi\n+            if [ \"x$incdir\" != x ] ; then\n+                # In the case of NASM, the trailing slash is necessary.\n+                incdir=`echo \"$incdir\" | sed 's%/*$%/%'`\n+                command=\"$command -I$incdir\"\n+            fi\n+            ;;\n+        -o*)\n+            o_opt=yes\n+            command=\"$command $1\"\n+            ;;\n+        *.asm)\n+            infile=$1\n+            command=\"$command $1\"\n+            ;;\n+        *)\n+            command=\"$command $1\"\n+            ;;\n+    esac\n+    shift\n+done\n+if [ \"$o_opt\" != yes ] ; then\n+    # By default, NASM creates an output file\n+    # in the same directory as the input file.\n+    outfile=\"-o `echo $infile | sed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.o\"\n+    command=\"$command $outfile\"\n+fi\n+echo $command\n+exec $command"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "obj/.gitignore",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/obj/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/obj/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/obj/.gitignore?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b"
      },
      {
        "sha": "d4b8777d5ce86e0540088393e3e2dcdae46de718",
        "filename": "src/bench_inv.c",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/bench_inv.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/bench_inv.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_inv.c?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,38 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+\n+#include \"util.h\"\n+#include \"num_impl.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"scalar_impl.h\"\n+\n+int main() {\n+    static const unsigned char init[32] = {\n+        0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n+        0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n+        0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n+        0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n+    };\n+    static const unsigned char fini[32] = {\n+        0xba, 0x28, 0x58, 0xd8, 0xaa, 0x11, 0xd6, 0xf2,\n+        0xfa, 0xce, 0x50, 0xb1, 0x67, 0x19, 0xb1, 0xa6,\n+        0xe0, 0xaa, 0x84, 0x53, 0xf6, 0x80, 0xfc, 0x23,\n+        0x88, 0x3c, 0xd6, 0x74, 0x9f, 0x27, 0x09, 0x03\n+    };\n+    secp256k1_ge_start();\n+    secp256k1_scalar_t base, x;\n+    secp256k1_scalar_set_b32(&base, init, NULL);\n+    secp256k1_scalar_set_b32(&x, init, NULL);\n+    for (int i=0; i<1000000; i++) {\n+        secp256k1_scalar_inverse(&x, &x);\n+        secp256k1_scalar_add(&x, &x, &base);\n+    }\n+    unsigned char res[32];\n+    secp256k1_scalar_get_b32(res, &x);\n+    CHECK(memcmp(res, fini, 32) == 0);\n+    return 0;\n+}"
      },
      {
        "sha": "3d8bfa1edb1ec822bcc78d4fc550a0fb609387dc",
        "filename": "src/bench_sign.c",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,48 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+\n+int main() {\n+    secp256k1_start(SECP256K1_START_SIGN);\n+\n+    unsigned char msg[32];\n+    unsigned char nonce[32];\n+    unsigned char key[32];\n+\n+    for (int i = 0; i < 32; i++) msg[i] = i + 1;\n+    for (int i = 0; i < 32; i++) nonce[i] = i + 33;\n+    for (int i = 0; i < 32; i++) key[i] = i + 65;\n+\n+    unsigned char sig[64];\n+\n+    for (int i=0; i<1000000; i++) {\n+        int recid = 0;\n+        CHECK(secp256k1_ecdsa_sign_compact(msg, 32, sig, key, nonce, &recid));\n+        for (int j = 0; j < 32; j++) {\n+            nonce[j] = key[j];     // Move former key to nonce\n+            msg[j] = sig[j];       // Move former R to message.\n+            key[j] = sig[j + 32];  // Move former S to key.\n+        }\n+    }\n+\n+    static const unsigned char fini[64] = {\n+        0x92, 0x03, 0xef, 0xf1, 0x58, 0x0b, 0x49, 0x8d,\n+        0x22, 0x3d, 0x49, 0x0e, 0xbf, 0x26, 0x50, 0x0e,\n+        0x2d, 0x62, 0x90, 0xd7, 0x82, 0xbd, 0x3d, 0x5c,\n+        0xa9, 0x10, 0xa5, 0x49, 0xb1, 0xd8, 0x8c, 0xc0,\n+        0x5b, 0x5e, 0x9e, 0x68, 0x51, 0x3d, 0xe8, 0xec,\n+        0x82, 0x30, 0x82, 0x88, 0x8c, 0xfd, 0xe7, 0x71,\n+        0x15, 0x92, 0xfc, 0x14, 0x59, 0x78, 0x31, 0xb3,\n+        0xf6, 0x07, 0x91, 0x18, 0x00, 0x8d, 0x4c, 0xb2\n+    };\n+    CHECK(memcmp(sig, fini, 64) == 0);\n+\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "7c2084a4a425b60c8b41a07fe0bd048c467612c5",
        "filename": "src/bench_verify.c",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,42 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+\n+int main() {\n+    secp256k1_start(SECP256K1_START_VERIFY);\n+\n+    unsigned char msg[32];\n+    unsigned char sig[64];\n+\n+    for (int i = 0; i < 32; i++) msg[i] = 1 + i;\n+    for (int i = 0; i < 64; i++) sig[i] = 65 + i;\n+\n+    unsigned char pubkey[33];\n+    for (int i=0; i<1000000; i++) {\n+        int pubkeylen = 33;\n+        CHECK(secp256k1_ecdsa_recover_compact(msg, 32, sig, pubkey, &pubkeylen, 1, i % 2));\n+        for (int j = 0; j < 32; j++) {\n+            sig[j + 32] = msg[j];    // Move former message to S.\n+            msg[j] = sig[j];         // Move former R to message.\n+            sig[j] = pubkey[j + 1];  // Move recovered pubkey X coordinate to R (which must be a valid X coordinate).\n+        }\n+    }\n+\n+    static const unsigned char fini[33] = {\n+        0x02,\n+        0x52, 0x63, 0xae, 0x9a, 0x9d, 0x47, 0x1f, 0x1a,\n+        0xb2, 0x36, 0x65, 0x89, 0x11, 0xe7, 0xcc, 0x86,\n+        0xa3, 0xab, 0x97, 0xb6, 0xf1, 0xaf, 0xfd, 0x8f,\n+        0x9b, 0x38, 0xb6, 0x18, 0x55, 0xe5, 0xc2, 0x43\n+    };\n+    CHECK(memcmp(fini, pubkey, 33) == 0);\n+\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "f74a0e76c92e849b88bbee3ccb9cb6078254c275",
        "filename": "src/ecdsa.h",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,21 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECDSA_\n+#define _SECP256K1_ECDSA_\n+\n+#include \"num.h\"\n+\n+typedef struct {\n+    secp256k1_num_t r, s;\n+} secp256k1_ecdsa_sig_t;\n+\n+int static secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned char *sig, int size);\n+int static secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const secp256k1_ecdsa_sig_t *a);\n+int static secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_num_t *message);\n+int static secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid);\n+int static secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_num_t *message, int recid);\n+void static secp256k1_ecdsa_sig_set_rs(secp256k1_ecdsa_sig_t *sig, const secp256k1_num_t *r, const secp256k1_num_t *s);\n+\n+#endif"
      },
      {
        "sha": "5a8fc4333af66bee05b7b4d48c2802cdbbd5eb07",
        "filename": "src/ecdsa_impl.h",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,180 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECDSA_IMPL_H_\n+#define _SECP256K1_ECDSA_IMPL_H_\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+#include \"group.h\"\n+#include \"ecmult.h\"\n+#include \"ecmult_gen.h\"\n+#include \"ecdsa.h\"\n+\n+int static secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned char *sig, int size) {\n+    if (sig[0] != 0x30) return 0;\n+    int lenr = sig[3];\n+    if (5+lenr >= size) return 0;\n+    int lens = sig[lenr+5];\n+    if (sig[1] != lenr+lens+4) return 0;\n+    if (lenr+lens+6 > size) return 0;\n+    if (sig[2] != 0x02) return 0;\n+    if (lenr == 0) return 0;\n+    if (sig[lenr+4] != 0x02) return 0;\n+    if (lens == 0) return 0;\n+    secp256k1_num_set_bin(&r->r, sig+4, lenr);\n+    secp256k1_num_set_bin(&r->s, sig+6+lenr, lens);\n+    return 1;\n+}\n+\n+int static secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const secp256k1_ecdsa_sig_t *a) {\n+    int lenR = (secp256k1_num_bits(&a->r) + 7)/8;\n+    if (lenR == 0 || secp256k1_num_get_bit(&a->r, lenR*8-1))\n+        lenR++;\n+    int lenS = (secp256k1_num_bits(&a->s) + 7)/8;\n+    if (lenS == 0 || secp256k1_num_get_bit(&a->s, lenS*8-1))\n+        lenS++;\n+    if (*size < 6+lenS+lenR)\n+        return 0;\n+    *size = 6 + lenS + lenR;\n+    sig[0] = 0x30;\n+    sig[1] = 4 + lenS + lenR;\n+    sig[2] = 0x02;\n+    sig[3] = lenR;\n+    secp256k1_num_get_bin(sig+4, lenR, &a->r);\n+    sig[4+lenR] = 0x02;\n+    sig[5+lenR] = lenS;\n+    secp256k1_num_get_bin(sig+lenR+6, lenS, &a->s);\n+    return 1;\n+}\n+\n+int static secp256k1_ecdsa_sig_recompute(secp256k1_num_t *r2, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_num_t *message) {\n+    const secp256k1_ge_consts_t *c = secp256k1_ge_consts;\n+\n+    if (secp256k1_num_is_neg(&sig->r) || secp256k1_num_is_neg(&sig->s))\n+        return 0;\n+    if (secp256k1_num_is_zero(&sig->r) || secp256k1_num_is_zero(&sig->s))\n+        return 0;\n+    if (secp256k1_num_cmp(&sig->r, &c->order) >= 0 || secp256k1_num_cmp(&sig->s, &c->order) >= 0)\n+        return 0;\n+\n+    int ret = 0;\n+    secp256k1_num_t sn, u1, u2;\n+    secp256k1_num_init(&sn);\n+    secp256k1_num_init(&u1);\n+    secp256k1_num_init(&u2);\n+    secp256k1_num_mod_inverse(&sn, &sig->s, &c->order);\n+    secp256k1_num_mod_mul(&u1, &sn, message, &c->order);\n+    secp256k1_num_mod_mul(&u2, &sn, &sig->r, &c->order);\n+    secp256k1_gej_t pubkeyj; secp256k1_gej_set_ge(&pubkeyj, pubkey);\n+    secp256k1_gej_t pr; secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n+    if (!secp256k1_gej_is_infinity(&pr)) {\n+        secp256k1_fe_t xr; secp256k1_gej_get_x_var(&xr, &pr);\n+        secp256k1_fe_normalize(&xr);\n+        unsigned char xrb[32]; secp256k1_fe_get_b32(xrb, &xr);\n+        secp256k1_num_set_bin(r2, xrb, 32);\n+        secp256k1_num_mod(r2, &c->order);\n+        ret = 1;\n+    }\n+    secp256k1_num_free(&sn);\n+    secp256k1_num_free(&u1);\n+    secp256k1_num_free(&u2);\n+    return ret;\n+}\n+\n+int static secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_num_t *message, int recid) {\n+    const secp256k1_ge_consts_t *c = secp256k1_ge_consts;\n+\n+    if (secp256k1_num_is_neg(&sig->r) || secp256k1_num_is_neg(&sig->s))\n+        return 0;\n+    if (secp256k1_num_is_zero(&sig->r) || secp256k1_num_is_zero(&sig->s))\n+        return 0;\n+    if (secp256k1_num_cmp(&sig->r, &c->order) >= 0 || secp256k1_num_cmp(&sig->s, &c->order) >= 0)\n+        return 0;\n+\n+    secp256k1_num_t rx;\n+    secp256k1_num_init(&rx);\n+    secp256k1_num_copy(&rx, &sig->r);\n+    if (recid & 2) {\n+        secp256k1_num_add(&rx, &rx, &c->order);\n+        if (secp256k1_num_cmp(&rx, &secp256k1_fe_consts->p) >= 0)\n+            return 0;\n+    }\n+    unsigned char brx[32];\n+    secp256k1_num_get_bin(brx, 32, &rx);\n+    secp256k1_num_free(&rx);\n+    secp256k1_fe_t fx;\n+    secp256k1_fe_set_b32(&fx, brx);\n+    secp256k1_ge_t x;\n+    if (!secp256k1_ge_set_xo(&x, &fx, recid & 1))\n+        return 0;\n+    secp256k1_gej_t xj;\n+    secp256k1_gej_set_ge(&xj, &x);\n+    secp256k1_num_t rn, u1, u2;\n+    secp256k1_num_init(&rn);\n+    secp256k1_num_init(&u1);\n+    secp256k1_num_init(&u2);\n+    secp256k1_num_mod_inverse(&rn, &sig->r, &c->order);\n+    secp256k1_num_mod_mul(&u1, &rn, message, &c->order);\n+    secp256k1_num_sub(&u1, &c->order, &u1);\n+    secp256k1_num_mod_mul(&u2, &rn, &sig->s, &c->order);\n+    secp256k1_gej_t qj;\n+    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n+    secp256k1_ge_set_gej_var(pubkey, &qj);\n+    secp256k1_num_free(&rn);\n+    secp256k1_num_free(&u1);\n+    secp256k1_num_free(&u2);\n+    return 1;\n+}\n+\n+int static secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_num_t *message) {\n+    secp256k1_num_t r2;\n+    secp256k1_num_init(&r2);\n+    int ret = 0;\n+    ret = secp256k1_ecdsa_sig_recompute(&r2, sig, pubkey, message) && secp256k1_num_cmp(&sig->r, &r2) == 0;\n+    secp256k1_num_free(&r2);\n+    return ret;\n+}\n+\n+int static secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n+    secp256k1_gej_t rp;\n+    secp256k1_ecmult_gen(&rp, nonce);\n+    secp256k1_ge_t r;\n+    secp256k1_ge_set_gej(&r, &rp);\n+    unsigned char b[32];\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_normalize(&r.y);\n+    secp256k1_fe_get_b32(b, &r.x);\n+    int overflow = 0;\n+    secp256k1_scalar_t sigr;\n+    secp256k1_scalar_set_b32(&sigr, b, &overflow);\n+    if (recid)\n+        *recid = (overflow ? 2 : 0) | (secp256k1_fe_is_odd(&r.y) ? 1 : 0);\n+    secp256k1_scalar_t n;\n+    secp256k1_scalar_mul(&n, &sigr, seckey);\n+    secp256k1_scalar_add(&n, &n, message);\n+    secp256k1_scalar_t sigs;\n+    secp256k1_scalar_inverse(&sigs, nonce);\n+    secp256k1_scalar_mul(&sigs, &sigs, &n);\n+    secp256k1_scalar_clear(&n);\n+    secp256k1_gej_clear(&rp);\n+    secp256k1_ge_clear(&r);\n+    if (secp256k1_scalar_is_zero(&sigs))\n+        return 0;\n+    if (secp256k1_scalar_is_high(&sigs)) {\n+        secp256k1_scalar_negate(&sigs, &sigs);\n+        if (recid)\n+            *recid ^= 1;\n+    }\n+    secp256k1_scalar_get_num(&sig->s, &sigs);\n+    secp256k1_scalar_get_num(&sig->r, &sigr);\n+    return 1;\n+}\n+\n+void static secp256k1_ecdsa_sig_set_rs(secp256k1_ecdsa_sig_t *sig, const secp256k1_num_t *r, const secp256k1_num_t *s) {\n+    secp256k1_num_copy(&sig->r, r);\n+    secp256k1_num_copy(&sig->s, s);\n+}\n+\n+#endif"
      },
      {
        "sha": "c5e828feae63ed5c30ee7a8b0e578b82d88d62b5",
        "filename": "src/eckey.h",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,23 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECKEY_\n+#define _SECP256K1_ECKEY_\n+\n+#include \"group.h\"\n+#include \"scalar.h\"\n+#include \"num.h\"\n+\n+int static secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size);\n+void static secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char *pub, int *size, int compressed);\n+\n+int static secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned char *privkey, int privkeylen);\n+int static secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed);\n+\n+int static secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n+int static secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_num_t *tweak);\n+int static secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n+int static secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_num_t *tweak);\n+\n+#endif"
      },
      {
        "sha": "eb26398a6e7c2cbd9a49f6e2929617dc605ac870",
        "filename": "src/eckey_impl.h",
        "status": "added",
        "additions": 188,
        "deletions": 0,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,188 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECKEY_IMPL_H_\n+#define _SECP256K1_ECKEY_IMPL_H_\n+\n+#include \"eckey.h\"\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+#include \"group.h\"\n+#include \"ecmult_gen.h\"\n+\n+int static secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size) {\n+    if (size == 33 && (pub[0] == 0x02 || pub[0] == 0x03)) {\n+        secp256k1_fe_t x;\n+        secp256k1_fe_set_b32(&x, pub+1);\n+        return secp256k1_ge_set_xo(elem, &x, pub[0] == 0x03);\n+    } else if (size == 65 && (pub[0] == 0x04 || pub[0] == 0x06 || pub[0] == 0x07)) {\n+        secp256k1_fe_t x, y;\n+        secp256k1_fe_set_b32(&x, pub+1);\n+        secp256k1_fe_set_b32(&y, pub+33);\n+        secp256k1_ge_set_xy(elem, &x, &y);\n+        if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07))\n+            return 0;\n+        return secp256k1_ge_is_valid(elem);\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+void static secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char *pub, int *size, int compressed) {\n+    secp256k1_fe_normalize(&elem->x);\n+    secp256k1_fe_normalize(&elem->y);\n+    secp256k1_fe_get_b32(&pub[1], &elem->x);\n+    if (compressed) {\n+        *size = 33;\n+        pub[0] = 0x02 | (secp256k1_fe_is_odd(&elem->y) ? 0x01 : 0x00);\n+    } else {\n+        *size = 65;\n+        pub[0] = 0x04;\n+        secp256k1_fe_get_b32(&pub[33], &elem->y);\n+    }\n+}\n+\n+int static secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned char *privkey, int privkeylen) {\n+    const unsigned char *end = privkey + privkeylen;\n+    // sequence header\n+    if (end < privkey+1 || *privkey != 0x30)\n+        return 0;\n+    privkey++;\n+    // sequence length constructor\n+    int lenb = 0;\n+    if (end < privkey+1 || !(*privkey & 0x80))\n+        return 0;\n+    lenb = *privkey & ~0x80; privkey++;\n+    if (lenb < 1 || lenb > 2)\n+        return 0;\n+    if (end < privkey+lenb)\n+        return 0;\n+    // sequence length\n+    int len = 0;\n+    len = privkey[lenb-1] | (lenb > 1 ? privkey[lenb-2] << 8 : 0);\n+    privkey += lenb;\n+    if (end < privkey+len)\n+        return 0;\n+    // sequence element 0: version number (=1)\n+    if (end < privkey+3 || privkey[0] != 0x02 || privkey[1] != 0x01 || privkey[2] != 0x01)\n+        return 0;\n+    privkey += 3;\n+    // sequence element 1: octet string, up to 32 bytes\n+    if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1])\n+        return 0;\n+    int overflow = 0;\n+    unsigned char c[32] = {0};\n+    memcpy(c + 32 - privkey[1], privkey + 2, privkey[1]);\n+    secp256k1_scalar_set_b32(key, c, &overflow);\n+    memset(c, 0, 32);\n+    return !overflow;\n+}\n+\n+int static secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed) {\n+    secp256k1_gej_t rp;\n+    secp256k1_ecmult_gen(&rp, key);\n+    secp256k1_ge_t r;\n+    secp256k1_ge_set_gej(&r, &rp);\n+    if (compressed) {\n+        static const unsigned char begin[] = {\n+            0x30,0x81,0xD3,0x02,0x01,0x01,0x04,0x20\n+        };\n+        static const unsigned char middle[] = {\n+            0xA0,0x81,0x85,0x30,0x81,0x82,0x02,0x01,0x01,0x30,0x2C,0x06,0x07,0x2A,0x86,0x48,\n+            0xCE,0x3D,0x01,0x01,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F,0x30,0x06,0x04,0x01,0x00,0x04,0x01,0x07,0x04,\n+            0x21,0x02,0x79,0xBE,0x66,0x7E,0xF9,0xDC,0xBB,0xAC,0x55,0xA0,0x62,0x95,0xCE,0x87,\n+            0x0B,0x07,0x02,0x9B,0xFC,0xDB,0x2D,0xCE,0x28,0xD9,0x59,0xF2,0x81,0x5B,0x16,0xF8,\n+            0x17,0x98,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,\n+            0x8C,0xD0,0x36,0x41,0x41,0x02,0x01,0x01,0xA1,0x24,0x03,0x22,0x00\n+        };\n+        unsigned char *ptr = privkey;\n+        memcpy(ptr, begin, sizeof(begin)); ptr += sizeof(begin);\n+        secp256k1_scalar_get_b32(ptr, key); ptr += 32;\n+        memcpy(ptr, middle, sizeof(middle)); ptr += sizeof(middle);\n+        int pubkeylen = 0;\n+        secp256k1_eckey_pubkey_serialize(&r, ptr, &pubkeylen, 1); ptr += pubkeylen;\n+        *privkeylen = ptr - privkey;\n+    } else {\n+        static const unsigned char begin[] = {\n+            0x30,0x82,0x01,0x13,0x02,0x01,0x01,0x04,0x20\n+        };\n+        static const unsigned char middle[] = {\n+            0xA0,0x81,0xA5,0x30,0x81,0xA2,0x02,0x01,0x01,0x30,0x2C,0x06,0x07,0x2A,0x86,0x48,\n+            0xCE,0x3D,0x01,0x01,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F,0x30,0x06,0x04,0x01,0x00,0x04,0x01,0x07,0x04,\n+            0x41,0x04,0x79,0xBE,0x66,0x7E,0xF9,0xDC,0xBB,0xAC,0x55,0xA0,0x62,0x95,0xCE,0x87,\n+            0x0B,0x07,0x02,0x9B,0xFC,0xDB,0x2D,0xCE,0x28,0xD9,0x59,0xF2,0x81,0x5B,0x16,0xF8,\n+            0x17,0x98,0x48,0x3A,0xDA,0x77,0x26,0xA3,0xC4,0x65,0x5D,0xA4,0xFB,0xFC,0x0E,0x11,\n+            0x08,0xA8,0xFD,0x17,0xB4,0x48,0xA6,0x85,0x54,0x19,0x9C,0x47,0xD0,0x8F,0xFB,0x10,\n+            0xD4,0xB8,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,\n+            0x8C,0xD0,0x36,0x41,0x41,0x02,0x01,0x01,0xA1,0x44,0x03,0x42,0x00\n+        };\n+        unsigned char *ptr = privkey;\n+        memcpy(ptr, begin, sizeof(begin)); ptr += sizeof(begin);\n+        secp256k1_scalar_get_b32(ptr, key); ptr += 32;\n+        memcpy(ptr, middle, sizeof(middle)); ptr += sizeof(middle);\n+        int pubkeylen = 0;\n+        secp256k1_eckey_pubkey_serialize(&r, ptr, &pubkeylen, 0); ptr += pubkeylen;\n+        *privkeylen = ptr - privkey;\n+    }\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n+    secp256k1_scalar_add(key, key, tweak);\n+    if (secp256k1_scalar_is_zero(key))\n+        return 0;\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_num_t *tweak) {\n+    if (secp256k1_num_cmp(tweak, &secp256k1_ge_consts->order) >= 0)\n+        return 0;\n+\n+    secp256k1_gej_t pt;\n+    secp256k1_gej_set_ge(&pt, key);\n+    secp256k1_num_t one;\n+    secp256k1_num_init(&one);\n+    secp256k1_num_set_int(&one, 1);\n+    secp256k1_ecmult(&pt, &pt, &one, tweak);\n+    secp256k1_num_free(&one);\n+\n+    if (secp256k1_gej_is_infinity(&pt))\n+        return 0;\n+    secp256k1_ge_set_gej(key, &pt);\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n+    if (secp256k1_scalar_is_zero(tweak))\n+        return 0;\n+\n+    secp256k1_scalar_mul(key, key, tweak);\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_num_t *tweak) {\n+    if (secp256k1_num_is_zero(tweak))\n+        return 0;\n+    if (secp256k1_num_cmp(tweak, &secp256k1_ge_consts->order) >= 0)\n+        return 0;\n+\n+    secp256k1_num_t zero;\n+    secp256k1_num_init(&zero);\n+    secp256k1_num_set_int(&zero, 0);\n+    secp256k1_gej_t pt;\n+    secp256k1_gej_set_ge(&pt, key);\n+    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n+    secp256k1_num_free(&zero);\n+    secp256k1_ge_set_gej(key, &pt);\n+    return 1;\n+}\n+\n+#endif"
      },
      {
        "sha": "7d74b5e4620c746e8263396df3f3a1240385ce42",
        "filename": "src/ecmult.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_\n+#define _SECP256K1_ECMULT_\n+\n+#include \"num.h\"\n+#include \"group.h\"\n+\n+static void secp256k1_ecmult_start(void);\n+static void secp256k1_ecmult_stop(void);\n+\n+/** Double multiply: R = na*A + ng*G */\n+static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_num_t *na, const secp256k1_num_t *ng);\n+\n+#endif"
      },
      {
        "sha": "79aa4bf24750c38b6c38772c263bfc24ab0c86aa",
        "filename": "src/ecmult_gen.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_GEN_\n+#define _SECP256K1_ECMULT_GEN_\n+\n+#include \"scalar.h\"\n+#include \"group.h\"\n+\n+static void secp256k1_ecmult_gen_start(void);\n+static void secp256k1_ecmult_gen_stop(void);\n+\n+/** Multiply with the generator: R = a*G */\n+static void secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *a);\n+\n+#endif"
      },
      {
        "sha": "976569ca43239c11f56bea1bd313f1d4f66ca310",
        "filename": "src/ecmult_gen_impl.h",
        "status": "added",
        "additions": 121,
        "deletions": 0,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,121 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_GEN_IMPL_H_\n+#define _SECP256K1_ECMULT_GEN_IMPL_H_\n+\n+#include <assert.h>\n+#include \"scalar.h\"\n+#include \"group.h\"\n+#include \"ecmult_gen.h\"\n+\n+typedef struct {\n+    // For accelerating the computation of a*G:\n+    // To harden against timing attacks, use the following mechanism:\n+    // * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n+    // * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n+    //   * U_i = U * 2^i (for i=0..62)\n+    //   * U_i = U * (1-2^63) (for i=63)\n+    //   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n+    // For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n+    // precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+    // None of the resulting prec group elements have a known scalar, and neither do any of\n+    // the intermediate sums while computing a*G.\n+    // To make memory access uniform, the bytes of prec(i, n_i) are sliced per value of n_i.\n+    unsigned char prec[64][sizeof(secp256k1_ge_t)][16]; // prec[j][k][i] = k'th byte of (16^j * i * G + U_i)\n+} secp256k1_ecmult_gen_consts_t;\n+\n+static const secp256k1_ecmult_gen_consts_t *secp256k1_ecmult_gen_consts = NULL;\n+\n+static void secp256k1_ecmult_gen_start(void) {\n+    if (secp256k1_ecmult_gen_consts != NULL)\n+        return;\n+\n+    // Allocate the precomputation table.\n+    secp256k1_ecmult_gen_consts_t *ret = (secp256k1_ecmult_gen_consts_t*)malloc(sizeof(secp256k1_ecmult_gen_consts_t));\n+\n+    // get the generator\n+    const secp256k1_ge_t *g = &secp256k1_ge_consts->g;\n+    secp256k1_gej_t gj; secp256k1_gej_set_ge(&gj, g);\n+\n+    // Construct a group element with no known corresponding scalar (nothing up my sleeve).\n+    secp256k1_gej_t nums_gej;\n+    {\n+        static const unsigned char nums_b32[32] = \"The scalar for this x is unknown\";\n+        secp256k1_fe_t nums_x;\n+        secp256k1_fe_set_b32(&nums_x, nums_b32);\n+        secp256k1_ge_t nums_ge;\n+        VERIFY_CHECK(secp256k1_ge_set_xo(&nums_ge, &nums_x, 0));\n+        secp256k1_gej_set_ge(&nums_gej, &nums_ge);\n+        // Add G to make the bits in x uniformly distributed.\n+        secp256k1_gej_add_ge_var(&nums_gej, &nums_gej, g);\n+    }\n+\n+    // compute prec.\n+    secp256k1_ge_t prec[1024];\n+    {\n+        secp256k1_gej_t precj[1024]; // Jacobian versions of prec.\n+        int j = 0;\n+        secp256k1_gej_t gbase; gbase = gj; // 16^j * G\n+        secp256k1_gej_t numsbase; numsbase = nums_gej; // 2^j * nums.\n+        for (int j=0; j<64; j++) {\n+            // Set precj[j*16 .. j*16+15] to (numsbase, numsbase + gbase, ..., numsbase + 15*gbase).\n+            precj[j*16] = numsbase;\n+            for (int i=1; i<16; i++) {\n+                secp256k1_gej_add_var(&precj[j*16 + i], &precj[j*16 + i - 1], &gbase);\n+            }\n+            // Multiply gbase by 16.\n+            for (int i=0; i<4; i++) {\n+                secp256k1_gej_double_var(&gbase, &gbase);\n+            }\n+            // Multiply numbase by 2.\n+            secp256k1_gej_double_var(&numsbase, &numsbase);\n+            if (j == 62) {\n+                // In the last iteration, numsbase is (1 - 2^j) * nums instead.\n+                secp256k1_gej_neg(&numsbase, &numsbase);\n+                secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej);\n+            }\n+        }\n+        secp256k1_ge_set_all_gej_var(1024, prec, precj);\n+    }\n+    for (int j=0; j<64; j++) {\n+        for (int i=0; i<16; i++) {\n+            const unsigned char* raw = (const unsigned char*)(&prec[j*16 + i]);\n+            for (int k=0; k<sizeof(secp256k1_ge_t); k++)\n+                ret->prec[j][k][i] = raw[k];\n+        }\n+    }\n+\n+    // Set the global pointer to the precomputation table.\n+    secp256k1_ecmult_gen_consts = ret;\n+}\n+\n+static void secp256k1_ecmult_gen_stop(void) {\n+    if (secp256k1_ecmult_gen_consts == NULL)\n+        return;\n+\n+    secp256k1_ecmult_gen_consts_t *c = (secp256k1_ecmult_gen_consts_t*)secp256k1_ecmult_gen_consts;\n+    secp256k1_ecmult_gen_consts = NULL;\n+    free(c);\n+}\n+\n+void static secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *gn) {\n+    const secp256k1_ecmult_gen_consts_t *c = secp256k1_ecmult_gen_consts;\n+    secp256k1_gej_set_infinity(r);\n+    secp256k1_ge_t add;\n+    int bits;\n+    for (int j=0; j<64; j++) {\n+        bits = secp256k1_scalar_get_bits(gn, j * 4, 4);\n+        for (int k=0; k<sizeof(secp256k1_ge_t); k++)\n+            ((unsigned char*)(&add))[k] = c->prec[j][k][bits];\n+        // Note that the next line uses a variable-time addition function, which\n+        // is fine, as the inputs are blinded (they have no known corresponding\n+        // private key).\n+        secp256k1_gej_add_ge_var(r, r, &add);\n+    }\n+    bits = 0;\n+    secp256k1_ge_clear(&add);\n+}\n+\n+#endif"
      },
      {
        "sha": "c0e4b116b0a5c168a288ce53d55075b3671ada98",
        "filename": "src/ecmult_impl.h",
        "status": "added",
        "additions": 221,
        "deletions": 0,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,221 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_IMPL_H_\n+#define _SECP256K1_ECMULT_IMPL_H_\n+\n+#include <assert.h>\n+#include \"num.h\"\n+#include \"group.h\"\n+#include \"ecmult.h\"\n+\n+// optimal for 128-bit and 256-bit exponents.\n+#define WINDOW_A 5\n+\n+// larger numbers may result in slightly better performance, at the cost of\n+// exponentially larger precomputed tables. WINDOW_G == 14 results in 640 KiB.\n+#define WINDOW_G 14\n+\n+/** Fill a table 'pre' with precomputed odd multiples of a. W determines the size of the table.\n+ *  pre will contains the values [1*a,3*a,5*a,...,(2^(w-1)-1)*a], so it needs place for\n+ *  2^(w-2) entries.\n+ *\n+ *  There are two versions of this function:\n+ *  - secp256k1_ecmult_precomp_wnaf_gej, which operates on group elements in jacobian notation,\n+ *    fast to precompute, but slower to use in later additions.\n+ *  - secp256k1_ecmult_precomp_wnaf_ge, which operates on group elements in affine notations,\n+ *    (much) slower to precompute, but a bit faster to use in later additions.\n+ *  To compute a*P + b*G, we use the jacobian version for P, and the affine version for G, as\n+ *  G is constant, so it only needs to be done once in advance.\n+ */\n+void static secp256k1_ecmult_table_precomp_gej_var(secp256k1_gej_t *pre, const secp256k1_gej_t *a, int w) {\n+    pre[0] = *a;\n+    secp256k1_gej_t d; secp256k1_gej_double_var(&d, &pre[0]);\n+    for (int i=1; i<(1 << (w-2)); i++)\n+        secp256k1_gej_add_var(&pre[i], &d, &pre[i-1]);\n+}\n+\n+void static secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const secp256k1_gej_t *a, int w) {\n+    const int table_size = 1 << (w-2);\n+    secp256k1_gej_t prej[table_size];\n+    prej[0] = *a;\n+    secp256k1_gej_t d; secp256k1_gej_double_var(&d, a);\n+    for (int i=1; i<table_size; i++) {\n+        secp256k1_gej_add_var(&prej[i], &d, &prej[i-1]);\n+    }\n+    secp256k1_ge_set_all_gej_var(table_size, pre, prej);\n+}\n+\n+/** The number of entries a table with precomputed multiples needs to have. */\n+#define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n+\n+/** The following two macro retrieves a particular odd multiple from a table\n+ *  of precomputed multiples. */\n+#define ECMULT_TABLE_GET(r,pre,n,w,neg) do { \\\n+    VERIFY_CHECK(((n) & 1) == 1); \\\n+    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    if ((n) > 0) \\\n+        *(r) = (pre)[((n)-1)/2]; \\\n+    else \\\n+        (neg)((r), &(pre)[(-(n)-1)/2]); \\\n+} while(0)\n+\n+#define ECMULT_TABLE_GET_GEJ(r,pre,n,w) ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_gej_neg)\n+#define ECMULT_TABLE_GET_GE(r,pre,n,w)  ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_ge_neg)\n+\n+typedef struct {\n+    // For accelerating the computation of a*P + b*G:\n+    secp256k1_ge_t pre_g[ECMULT_TABLE_SIZE(WINDOW_G)];    // odd multiples of the generator\n+    secp256k1_ge_t pre_g_128[ECMULT_TABLE_SIZE(WINDOW_G)]; // odd multiples of 2^128*generator\n+} secp256k1_ecmult_consts_t;\n+\n+static const secp256k1_ecmult_consts_t *secp256k1_ecmult_consts = NULL;\n+\n+static void secp256k1_ecmult_start(void) {\n+    if (secp256k1_ecmult_consts != NULL)\n+        return;\n+\n+    // Allocate the precomputation table.\n+    secp256k1_ecmult_consts_t *ret = (secp256k1_ecmult_consts_t*)malloc(sizeof(secp256k1_ecmult_consts_t));\n+\n+    // get the generator\n+    const secp256k1_ge_t *g = &secp256k1_ge_consts->g;\n+    secp256k1_gej_t gj; secp256k1_gej_set_ge(&gj, g);\n+\n+    // calculate 2^128*generator\n+    secp256k1_gej_t g_128j = gj;\n+    for (int i=0; i<128; i++)\n+        secp256k1_gej_double_var(&g_128j, &g_128j);\n+\n+    // precompute the tables with odd multiples\n+    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g, &gj, WINDOW_G);\n+    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g_128, &g_128j, WINDOW_G);\n+\n+    // Set the global pointer to the precomputation table.\n+    secp256k1_ecmult_consts = ret;\n+}\n+\n+static void secp256k1_ecmult_stop(void) {\n+    if (secp256k1_ecmult_consts == NULL)\n+        return;\n+\n+    secp256k1_ecmult_consts_t *c = (secp256k1_ecmult_consts_t*)secp256k1_ecmult_consts;\n+    secp256k1_ecmult_consts = NULL;\n+    free(c);\n+}\n+\n+/** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n+ *  with the following guarantees:\n+ *  - each wnaf[i] is either 0, or an odd integer between -(1<<(w-1) - 1) and (1<<(w-1) - 1)\n+ *  - two non-zero entries in wnaf are separated by at least w-1 zeroes.\n+ *  - the index of the highest non-zero entry in wnaf (=return value-1) is at most bits, where\n+ *    bits is the number of bits necessary to represent the absolute value of the input.\n+ */\n+static int secp256k1_ecmult_wnaf(int *wnaf, const secp256k1_num_t *a, int w) {\n+    int ret = 0;\n+    int zeroes = 0;\n+    secp256k1_num_t x;\n+    secp256k1_num_copy(&x, a);\n+    int sign = 1;\n+    if (secp256k1_num_is_neg(&x)) {\n+        sign = -1;\n+        secp256k1_num_negate(&x);\n+    }\n+    while (!secp256k1_num_is_zero(&x)) {\n+        while (!secp256k1_num_is_odd(&x)) {\n+            zeroes++;\n+            secp256k1_num_shift(&x, 1);\n+        }\n+        int word = secp256k1_num_shift(&x, w);\n+        while (zeroes) {\n+            wnaf[ret++] = 0;\n+            zeroes--;\n+        }\n+        if (word & (1 << (w-1))) {\n+            secp256k1_num_inc(&x);\n+            wnaf[ret++] = sign * (word - (1 << w));\n+        } else {\n+            wnaf[ret++] = sign * word;\n+        }\n+        zeroes = w-1;\n+    }\n+    return ret;\n+}\n+\n+void static secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_num_t *na, const secp256k1_num_t *ng) {\n+    const secp256k1_ecmult_consts_t *c = secp256k1_ecmult_consts;\n+\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_num_t na_1, na_lam;\n+    // split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit)\n+    secp256k1_gej_split_exp_var(&na_1, &na_lam, na);\n+\n+    // build wnaf representation for na_1 and na_lam.\n+    int wnaf_na_1[129];   int bits_na_1   = secp256k1_ecmult_wnaf(wnaf_na_1,   &na_1,   WINDOW_A);\n+    int wnaf_na_lam[129]; int bits_na_lam = secp256k1_ecmult_wnaf(wnaf_na_lam, &na_lam, WINDOW_A);\n+    int bits = bits_na_1;\n+    if (bits_na_lam > bits) bits = bits_na_lam;\n+#else\n+    // build wnaf representation for na.\n+    int wnaf_na[257];     int bits_na     = secp256k1_ecmult_wnaf(wnaf_na,     na,      WINDOW_A);\n+    int bits = bits_na;\n+#endif\n+\n+    // calculate odd multiples of a\n+    secp256k1_gej_t pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ecmult_table_precomp_gej_var(pre_a, a, WINDOW_A);\n+\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_gej_t pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    for (int i=0; i<ECMULT_TABLE_SIZE(WINDOW_A); i++)\n+        secp256k1_gej_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+#endif\n+\n+    // Splitted G factors.\n+    secp256k1_num_t ng_1, ng_128;\n+\n+    // split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit)\n+    secp256k1_num_split(&ng_1, &ng_128, ng, 128);\n+\n+    // Build wnaf representation for ng_1 and ng_128\n+    int wnaf_ng_1[129];   int bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   &ng_1,   WINDOW_G);\n+    int wnaf_ng_128[129]; int bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, &ng_128, WINDOW_G);\n+    if (bits_ng_1 > bits) bits = bits_ng_1;\n+    if (bits_ng_128 > bits) bits = bits_ng_128;\n+\n+    secp256k1_gej_set_infinity(r);\n+    secp256k1_gej_t tmpj;\n+    secp256k1_ge_t tmpa;\n+\n+    for (int i=bits-1; i>=0; i--) {\n+        secp256k1_gej_double_var(r, r);\n+        int n;\n+#ifdef USE_ENDOMORPHISM\n+        if (i < bits_na_1 && (n = wnaf_na_1[i])) {\n+            ECMULT_TABLE_GET_GEJ(&tmpj, pre_a, n, WINDOW_A);\n+            secp256k1_gej_add_var(r, r, &tmpj);\n+        }\n+        if (i < bits_na_lam && (n = wnaf_na_lam[i])) {\n+            ECMULT_TABLE_GET_GEJ(&tmpj, pre_a_lam, n, WINDOW_A);\n+            secp256k1_gej_add_var(r, r, &tmpj);\n+        }\n+#else\n+        if (i < bits_na && (n = wnaf_na[i])) {\n+            ECMULT_TABLE_GET_GEJ(&tmpj, pre_a, n, WINDOW_A);\n+            secp256k1_gej_add_var(r, r, &tmpj);\n+        }\n+#endif\n+        if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g, n, WINDOW_G);\n+            secp256k1_gej_add_ge_var(r, r, &tmpa);\n+        }\n+        if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g_128, n, WINDOW_G);\n+            secp256k1_gej_add_ge_var(r, r, &tmpa);\n+        }\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "067115d0a71adeae25f4a0a87fc0384a9d63ff4a",
        "filename": "src/field.h",
        "status": "added",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,112 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_\n+#define _SECP256K1_FIELD_\n+\n+/** Field element module.\n+ *\n+ *  Field elements can be represented in several ways, but code accessing\n+ *  it (and implementations) need to take certain properaties into account:\n+ *  - Each field element can be normalized or not.\n+ *  - Each field element has a magnitude, which represents how far away\n+ *    its representation is away from normalization. Normalized elements\n+ *    always have a magnitude of 1, but a magnitude of 1 doesn't imply\n+ *    normality.\n+ */\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_FIELD_GMP)\n+#include \"field_gmp.h\"\n+#elif defined(USE_FIELD_10X26)\n+#include \"field_10x26.h\"\n+#elif defined(USE_FIELD_5X52)\n+#include \"field_5x52.h\"\n+#else\n+#error \"Please select field implementation\"\n+#endif\n+\n+typedef struct {\n+    secp256k1_num_t p;\n+} secp256k1_fe_consts_t;\n+\n+static const secp256k1_fe_consts_t *secp256k1_fe_consts = NULL;\n+\n+/** Initialize field element precomputation data. */\n+void static secp256k1_fe_start(void);\n+\n+/** Unload field element precomputation data. */\n+void static secp256k1_fe_stop(void);\n+\n+/** Normalize a field element. */\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r);\n+\n+/** Set a field element equal to a small integer. Resulting field element is normalized. */\n+void static secp256k1_fe_set_int(secp256k1_fe_t *r, int a);\n+\n+/** Verify whether a field element is zero. Requires the input to be normalized. */\n+int  static secp256k1_fe_is_zero(const secp256k1_fe_t *a);\n+\n+/** Check the \"oddness\" of a field element. Requires the input to be normalized. */\n+int  static secp256k1_fe_is_odd(const secp256k1_fe_t *a);\n+\n+/** Compare two field elements. Requires both inputs to be normalized */\n+int  static secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b);\n+\n+/** Set a field element equal to 32-byte big endian value. Resulting field element is normalized. */\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a);\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a);\n+\n+/** Set a field element equal to the additive inverse of another. Takes a maximum magnitude of the input\n+ *  as an argument. The magnitude of the output is one higher. */\n+void static secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m);\n+\n+/** Multiplies the passed field element with a small integer constant. Multiplies the magnitude by that\n+ *  small integer. */\n+void static secp256k1_fe_mul_int(secp256k1_fe_t *r, int a);\n+\n+/** Adds a field element to another. The result has the sum of the inputs' magnitudes as magnitude. */\n+void static secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Sets a field element to be the product of two others. Requires the inputs' magnitudes to be at most 8.\n+ *  The output magnitude is 1 (but not guaranteed to be normalized). */\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b);\n+\n+/** Sets a field element to be the square of another. Requires the input's magnitude to be at most 8.\n+ *  The output magnitude is 1 (but not guaranteed to be normalized). */\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Sets a field element to be the (modular) square root (if any exist) of another. Requires the\n+ *  input's magnitude to be at most 8. The output magnitude is 1 (but not guaranteed to be\n+ *  normalized). Return value indicates whether a square root was found. */\n+int  static secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n+ *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n+void static secp256k1_fe_inv(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Potentially faster version of secp256k1_fe_inv, without constant-time guarantee. */\n+void static secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n+ *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n+ *  outputs must not overlap in memory. */\n+void static secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n+\n+/** Potentially faster version of secp256k1_fe_inv_all, without constant-time guarantee. */\n+void static secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n+\n+\n+/** Convert a field element to a hexadecimal string. */\n+void static secp256k1_fe_get_hex(char *r, int *rlen, const secp256k1_fe_t *a);\n+\n+/** Convert a hexadecimal string to a field element. */\n+void static secp256k1_fe_set_hex(secp256k1_fe_t *r, const char *a, int alen);\n+\n+#endif"
      },
      {
        "sha": "d544139e858d6bba09b53e262a2231674b96a1e4",
        "filename": "src/field_10x26.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_10x26.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_10x26.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_\n+#define _SECP256K1_FIELD_REPR_\n+\n+#include <stdint.h>\n+\n+typedef struct {\n+    // X = sum(i=0..9, elem[i]*2^26) mod n\n+    uint32_t n[10];\n+#ifdef VERIFY\n+    int magnitude;\n+    int normalized;\n+#endif\n+} secp256k1_fe_t;\n+\n+#endif"
      },
      {
        "sha": "a567437feddd851c194f4484347181007b6054a9",
        "filename": "src/field_10x26_impl.h",
        "status": "added",
        "additions": 529,
        "deletions": 0,
        "changes": 529,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n+#define _SECP256K1_FIELD_REPR_IMPL_H_\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"util.h\"\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+void static secp256k1_fe_inner_start(void) {}\n+void static secp256k1_fe_inner_stop(void) {}\n+\n+#ifdef VERIFY\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {\n+    const uint32_t *d = a->n;\n+    int m = a->normalized ? 1 : 2 * a->magnitude, r = 1;\n+    r &= (d[0] <= 0x3FFFFFFUL * m);\n+    r &= (d[1] <= 0x3FFFFFFUL * m);\n+    r &= (d[2] <= 0x3FFFFFFUL * m);\n+    r &= (d[3] <= 0x3FFFFFFUL * m);\n+    r &= (d[4] <= 0x3FFFFFFUL * m);\n+    r &= (d[5] <= 0x3FFFFFFUL * m);\n+    r &= (d[6] <= 0x3FFFFFFUL * m);\n+    r &= (d[7] <= 0x3FFFFFFUL * m);\n+    r &= (d[8] <= 0x3FFFFFFUL * m);\n+    r &= (d[9] <= 0x03FFFFFUL * m);\n+    r &= (a->magnitude >= 0);\n+    if (a->normalized) {\n+        r &= (a->magnitude <= 1);\n+        if (r && (d[9] == 0x03FFFFFUL)) {\n+            uint32_t mid = d[8] & d[7] & d[6] & d[5] & d[4] & d[3] & d[2];\n+            if (mid == 0x3FFFFFFUL) {\n+                r &= ((d[1] + 0x40UL + ((d[0] + 0x3D1UL) >> 26)) <= 0x3FFFFFFUL);\n+            }\n+        }\n+    }\n+    VERIFY_CHECK(r == 1);\n+}\n+#else\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {}\n+#endif\n+\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r) {\n+    uint32_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4],\n+             t5 = r->n[5], t6 = r->n[6], t7 = r->n[7], t8 = r->n[8], t9 = r->n[9];\n+\n+    // Reduce t9 at the start so there will be at most a single carry from the first pass\n+    uint32_t x = t9 >> 22; t9 &= 0x03FFFFFUL;\n+    uint32_t m;\n+\n+    // The first pass ensures the magnitude is 1, ...\n+    t0 += x * 0x3D1UL; t1 += (x << 6);\n+    t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+    t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+    t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL; m = t2;\n+    t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL; m &= t3;\n+    t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL; m &= t4;\n+    t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL; m &= t5;\n+    t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL; m &= t6;\n+    t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL; m &= t7;\n+    t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL; m &= t8;\n+\n+    // ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element)\n+    VERIFY_CHECK(t9 >> 23 == 0);\n+\n+    // At most a single final reduction is needed; check if the value is >= the field characteristic\n+    x = (t9 >> 22) | ((t9 == 0x03FFFFFUL) & (m == 0x3FFFFFFUL)\n+        & ((t1 + 0x40UL + ((t0 + 0x3D1UL) >> 26)) > 0x3FFFFFFUL));\n+\n+    // Apply the final reduction (for constant-time behaviour, we do it always)\n+    t0 += x * 0x3D1UL; t1 += (x << 6);\n+    t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+    t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+    t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL;\n+    t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL;\n+    t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL;\n+    t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL;\n+    t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL;\n+    t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL;\n+    t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL;\n+\n+    // If t9 didn't carry to bit 22 already, then it should have after any final reduction\n+    VERIFY_CHECK(t9 >> 22 == x);\n+\n+    // Mask off the possible multiple of 2^256 from the final reduction\n+    t9 &= 0x03FFFFFUL;\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+    r->n[5] = t5; r->n[6] = t6; r->n[7] = t7; r->n[8] = t8; r->n[9] = t9;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] = a;\n+    r->n[1] = r->n[2] = r->n[3] = r->n[4] = r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+int static inline secp256k1_fe_is_zero(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    const uint32_t *t = a->n;\n+    return (t[0] | t[1] | t[2] | t[3] | t[4] | t[5] | t[6] | t[7] | t[8] | t[9]) == 0;\n+}\n+\n+int static inline secp256k1_fe_is_odd(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    return a->n[0] & 1;\n+}\n+\n+void static inline secp256k1_fe_clear(secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    a->magnitude = 0;\n+    a->normalized = 1;\n+#endif\n+    for (int i=0; i<10; i++) {\n+        a->n[i] = 0;\n+    }\n+}\n+\n+int static inline secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    VERIFY_CHECK(b->normalized);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    const uint32_t *t = a->n, *u = b->n;\n+    return ((t[0]^u[0]) | (t[1]^u[1]) | (t[2]^u[2]) | (t[3]^u[3]) | (t[4]^u[4])\n+          | (t[5]^u[5]) | (t[6]^u[6]) | (t[7]^u[7]) | (t[8]^u[8]) | (t[9]^u[9])) == 0;\n+}\n+\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a) {\n+    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n+    r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n+    for (int i=0; i<32; i++) {\n+        for (int j=0; j<4; j++) {\n+            int limb = (8*i+2*j)/26;\n+            int shift = (8*i+2*j)%26;\n+            r->n[limb] |= (uint32_t)((a[31-i] >> (2*j)) & 0x3) << shift;\n+        }\n+    }\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    for (int i=0; i<32; i++) {\n+        int c = 0;\n+        for (int j=0; j<4; j++) {\n+            int limb = (8*i+2*j)/26;\n+            int shift = (8*i+2*j)%26;\n+            c |= ((a->n[limb] >> shift) & 0x3) << (2 * j);\n+        }\n+        r[31-i] = c;\n+    }\n+}\n+\n+void static inline secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= m);\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] = 0x3FFFC2FUL * 2 * (m + 1) - a->n[0];\n+    r->n[1] = 0x3FFFFBFUL * 2 * (m + 1) - a->n[1];\n+    r->n[2] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[2];\n+    r->n[3] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[3];\n+    r->n[4] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[4];\n+    r->n[5] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[5];\n+    r->n[6] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[6];\n+    r->n[7] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[7];\n+    r->n[8] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[8];\n+    r->n[9] = 0x03FFFFFUL * 2 * (m + 1) - a->n[9];\n+#ifdef VERIFY\n+    r->magnitude = m + 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] *= a;\n+    r->n[1] *= a;\n+    r->n[2] *= a;\n+    r->n[3] *= a;\n+    r->n[4] *= a;\n+    r->n[5] *= a;\n+    r->n[6] *= a;\n+    r->n[7] *= a;\n+    r->n[8] *= a;\n+    r->n[9] *= a;\n+#ifdef VERIFY\n+    r->magnitude *= a;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] += a->n[0];\n+    r->n[1] += a->n[1];\n+    r->n[2] += a->n[2];\n+    r->n[3] += a->n[3];\n+    r->n[4] += a->n[4];\n+    r->n[5] += a->n[5];\n+    r->n[6] += a->n[6];\n+    r->n[7] += a->n[7];\n+    r->n[8] += a->n[8];\n+    r->n[9] += a->n[9];\n+#ifdef VERIFY\n+    r->magnitude += a->magnitude;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_inner(const uint32_t *a, const uint32_t *b, uint32_t *r) {\n+    uint64_t c = (uint64_t)a[0] * b[0];\n+    uint32_t t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[1] +\n+            (uint64_t)a[1] * b[0];\n+    uint32_t t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[2] +\n+            (uint64_t)a[1] * b[1] +\n+            (uint64_t)a[2] * b[0];\n+    uint32_t t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[3] +\n+            (uint64_t)a[1] * b[2] +\n+            (uint64_t)a[2] * b[1] +\n+            (uint64_t)a[3] * b[0];\n+    uint32_t t3 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[4] +\n+            (uint64_t)a[1] * b[3] +\n+            (uint64_t)a[2] * b[2] +\n+            (uint64_t)a[3] * b[1] +\n+            (uint64_t)a[4] * b[0];\n+    uint32_t t4 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[5] +\n+            (uint64_t)a[1] * b[4] +\n+            (uint64_t)a[2] * b[3] +\n+            (uint64_t)a[3] * b[2] +\n+            (uint64_t)a[4] * b[1] +\n+            (uint64_t)a[5] * b[0];\n+    uint32_t t5 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[6] +\n+            (uint64_t)a[1] * b[5] +\n+            (uint64_t)a[2] * b[4] +\n+            (uint64_t)a[3] * b[3] +\n+            (uint64_t)a[4] * b[2] +\n+            (uint64_t)a[5] * b[1] +\n+            (uint64_t)a[6] * b[0];\n+    uint32_t t6 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[7] +\n+            (uint64_t)a[1] * b[6] +\n+            (uint64_t)a[2] * b[5] +\n+            (uint64_t)a[3] * b[4] +\n+            (uint64_t)a[4] * b[3] +\n+            (uint64_t)a[5] * b[2] +\n+            (uint64_t)a[6] * b[1] +\n+            (uint64_t)a[7] * b[0];\n+    uint32_t t7 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[8] +\n+            (uint64_t)a[1] * b[7] +\n+            (uint64_t)a[2] * b[6] +\n+            (uint64_t)a[3] * b[5] +\n+            (uint64_t)a[4] * b[4] +\n+            (uint64_t)a[5] * b[3] +\n+            (uint64_t)a[6] * b[2] +\n+            (uint64_t)a[7] * b[1] +\n+            (uint64_t)a[8] * b[0];\n+    uint32_t t8 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[9] +\n+            (uint64_t)a[1] * b[8] +\n+            (uint64_t)a[2] * b[7] +\n+            (uint64_t)a[3] * b[6] +\n+            (uint64_t)a[4] * b[5] +\n+            (uint64_t)a[5] * b[4] +\n+            (uint64_t)a[6] * b[3] +\n+            (uint64_t)a[7] * b[2] +\n+            (uint64_t)a[8] * b[1] +\n+            (uint64_t)a[9] * b[0];\n+    uint32_t t9 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[1] * b[9] +\n+            (uint64_t)a[2] * b[8] +\n+            (uint64_t)a[3] * b[7] +\n+            (uint64_t)a[4] * b[6] +\n+            (uint64_t)a[5] * b[5] +\n+            (uint64_t)a[6] * b[4] +\n+            (uint64_t)a[7] * b[3] +\n+            (uint64_t)a[8] * b[2] +\n+            (uint64_t)a[9] * b[1];\n+    uint32_t t10 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[2] * b[9] +\n+            (uint64_t)a[3] * b[8] +\n+            (uint64_t)a[4] * b[7] +\n+            (uint64_t)a[5] * b[6] +\n+            (uint64_t)a[6] * b[5] +\n+            (uint64_t)a[7] * b[4] +\n+            (uint64_t)a[8] * b[3] +\n+            (uint64_t)a[9] * b[2];\n+    uint32_t t11 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[3] * b[9] +\n+            (uint64_t)a[4] * b[8] +\n+            (uint64_t)a[5] * b[7] +\n+            (uint64_t)a[6] * b[6] +\n+            (uint64_t)a[7] * b[5] +\n+            (uint64_t)a[8] * b[4] +\n+            (uint64_t)a[9] * b[3];\n+    uint32_t t12 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[4] * b[9] +\n+            (uint64_t)a[5] * b[8] +\n+            (uint64_t)a[6] * b[7] +\n+            (uint64_t)a[7] * b[6] +\n+            (uint64_t)a[8] * b[5] +\n+            (uint64_t)a[9] * b[4];\n+    uint32_t t13 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[5] * b[9] +\n+            (uint64_t)a[6] * b[8] +\n+            (uint64_t)a[7] * b[7] +\n+            (uint64_t)a[8] * b[6] +\n+            (uint64_t)a[9] * b[5];\n+    uint32_t t14 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[6] * b[9] +\n+            (uint64_t)a[7] * b[8] +\n+            (uint64_t)a[8] * b[7] +\n+            (uint64_t)a[9] * b[6];\n+    uint32_t t15 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[7] * b[9] +\n+            (uint64_t)a[8] * b[8] +\n+            (uint64_t)a[9] * b[7];\n+    uint32_t t16 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[8] * b[9] +\n+            (uint64_t)a[9] * b[8];\n+    uint32_t t17 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[9] * b[9];\n+    uint32_t t18 = c & 0x3FFFFFFUL; c = c >> 26;\n+    uint32_t t19 = c;\n+\n+    c = t0 + (uint64_t)t10 * 0x3D10UL;\n+    t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t1 + (uint64_t)t10*0x400UL + (uint64_t)t11 * 0x3D10UL;\n+    t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t2 + (uint64_t)t11*0x400UL + (uint64_t)t12 * 0x3D10UL;\n+    t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t3 + (uint64_t)t12*0x400UL + (uint64_t)t13 * 0x3D10UL;\n+    r[3] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t4 + (uint64_t)t13*0x400UL + (uint64_t)t14 * 0x3D10UL;\n+    r[4] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t5 + (uint64_t)t14*0x400UL + (uint64_t)t15 * 0x3D10UL;\n+    r[5] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t6 + (uint64_t)t15*0x400UL + (uint64_t)t16 * 0x3D10UL;\n+    r[6] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t7 + (uint64_t)t16*0x400UL + (uint64_t)t17 * 0x3D10UL;\n+    r[7] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t8 + (uint64_t)t17*0x400UL + (uint64_t)t18 * 0x3D10UL;\n+    r[8] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t9 + (uint64_t)t18*0x400UL + (uint64_t)t19 * 0x1000003D10ULL;\n+    r[9] = c & 0x03FFFFFUL; c = c >> 22;\n+    uint64_t d = t0 + c * 0x3D1UL;\n+    r[0] = d & 0x3FFFFFFUL; d = d >> 26;\n+    d = d + t1 + c*0x40;\n+    r[1] = d & 0x3FFFFFFUL; d = d >> 26;\n+    r[2] = t2 + d;\n+}\n+\n+void static inline secp256k1_fe_sqr_inner(const uint32_t *a, uint32_t *r) {\n+    uint64_t c = (uint64_t)a[0] * a[0];\n+    uint32_t t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[1];\n+    uint32_t t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[2] +\n+            (uint64_t)a[1] * a[1];\n+    uint32_t t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[3] +\n+            (uint64_t)(a[1]*2) * a[2];\n+    uint32_t t3 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[4] +\n+            (uint64_t)(a[1]*2) * a[3] +\n+            (uint64_t)a[2] * a[2];\n+    uint32_t t4 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[5] +\n+            (uint64_t)(a[1]*2) * a[4] +\n+            (uint64_t)(a[2]*2) * a[3];\n+    uint32_t t5 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[6] +\n+            (uint64_t)(a[1]*2) * a[5] +\n+            (uint64_t)(a[2]*2) * a[4] +\n+            (uint64_t)a[3] * a[3];\n+    uint32_t t6 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[7] +\n+            (uint64_t)(a[1]*2) * a[6] +\n+            (uint64_t)(a[2]*2) * a[5] +\n+            (uint64_t)(a[3]*2) * a[4];\n+    uint32_t t7 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[8] +\n+            (uint64_t)(a[1]*2) * a[7] +\n+            (uint64_t)(a[2]*2) * a[6] +\n+            (uint64_t)(a[3]*2) * a[5] +\n+            (uint64_t)a[4] * a[4];\n+    uint32_t t8 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[9] +\n+            (uint64_t)(a[1]*2) * a[8] +\n+            (uint64_t)(a[2]*2) * a[7] +\n+            (uint64_t)(a[3]*2) * a[6] +\n+            (uint64_t)(a[4]*2) * a[5];\n+    uint32_t t9 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[1]*2) * a[9] +\n+            (uint64_t)(a[2]*2) * a[8] +\n+            (uint64_t)(a[3]*2) * a[7] +\n+            (uint64_t)(a[4]*2) * a[6] +\n+            (uint64_t)a[5] * a[5];\n+    uint32_t t10 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[2]*2) * a[9] +\n+            (uint64_t)(a[3]*2) * a[8] +\n+            (uint64_t)(a[4]*2) * a[7] +\n+            (uint64_t)(a[5]*2) * a[6];\n+    uint32_t t11 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[3]*2) * a[9] +\n+            (uint64_t)(a[4]*2) * a[8] +\n+            (uint64_t)(a[5]*2) * a[7] +\n+            (uint64_t)a[6] * a[6];\n+    uint32_t t12 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[4]*2) * a[9] +\n+            (uint64_t)(a[5]*2) * a[8] +\n+            (uint64_t)(a[6]*2) * a[7];\n+    uint32_t t13 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[5]*2) * a[9] +\n+            (uint64_t)(a[6]*2) * a[8] +\n+            (uint64_t)a[7] * a[7];\n+    uint32_t t14 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[6]*2) * a[9] +\n+            (uint64_t)(a[7]*2) * a[8];\n+    uint32_t t15 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[7]*2) * a[9] +\n+            (uint64_t)a[8] * a[8];\n+    uint32_t t16 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[8]*2) * a[9];\n+    uint32_t t17 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[9] * a[9];\n+    uint32_t t18 = c & 0x3FFFFFFUL; c = c >> 26;\n+    uint32_t t19 = c;\n+\n+    c = t0 + (uint64_t)t10 * 0x3D10UL;\n+    t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t1 + (uint64_t)t10*0x400UL + (uint64_t)t11 * 0x3D10UL;\n+    t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t2 + (uint64_t)t11*0x400UL + (uint64_t)t12 * 0x3D10UL;\n+    t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t3 + (uint64_t)t12*0x400UL + (uint64_t)t13 * 0x3D10UL;\n+    r[3] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t4 + (uint64_t)t13*0x400UL + (uint64_t)t14 * 0x3D10UL;\n+    r[4] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t5 + (uint64_t)t14*0x400UL + (uint64_t)t15 * 0x3D10UL;\n+    r[5] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t6 + (uint64_t)t15*0x400UL + (uint64_t)t16 * 0x3D10UL;\n+    r[6] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t7 + (uint64_t)t16*0x400UL + (uint64_t)t17 * 0x3D10UL;\n+    r[7] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t8 + (uint64_t)t17*0x400UL + (uint64_t)t18 * 0x3D10UL;\n+    r[8] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t9 + (uint64_t)t18*0x400UL + (uint64_t)t19 * 0x1000003D10ULL;\n+    r[9] = c & 0x03FFFFFUL; c = c >> 22;\n+    uint64_t d = t0 + c * 0x3D1UL;\n+    r[0] = d & 0x3FFFFFFUL; d = d >> 26;\n+    d = d + t1 + c*0x40;\n+    r[1] = d & 0x3FFFFFFUL; d = d >> 26;\n+    r[2] = t2 + d;\n+}\n+\n+\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    VERIFY_CHECK(b->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+#endif\n+    secp256k1_fe_sqr_inner(a->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+#endif"
      },
      {
        "sha": "9d5de2cc41e464c3a7d62dcb441bf393d73cc7e6",
        "filename": "src/field_5x52.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_\n+#define _SECP256K1_FIELD_REPR_\n+\n+#include <stdint.h>\n+\n+typedef struct {\n+    // X = sum(i=0..4, elem[i]*2^52) mod n\n+    uint64_t n[5];\n+#ifdef VERIFY\n+    int magnitude;\n+    int normalized;\n+#endif\n+} secp256k1_fe_t;\n+\n+#endif"
      },
      {
        "sha": "5e785f763055eaf695f92116dc3582a0985bf71d",
        "filename": "src/field_5x52_asm.asm",
        "status": "added",
        "additions": 469,
        "deletions": 0,
        "changes": 469,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_asm.asm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_asm.asm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_asm.asm?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,469 @@\n+\t;; Added by Diederik Huys, March 2013\n+\t;;\n+\t;; Provided public procedures:\n+\t;; \tsecp256k1_fe_mul_inner\n+\t;; \tsecp256k1_fe_sqr_inner\n+\t;;\n+\t;; Needed tools: YASM (http://yasm.tortall.net)\n+\t;;\n+\t;; \n+\n+\tBITS 64\n+\n+%ifidn   __OUTPUT_FORMAT__,macho64\n+%define SYM(x) _ %+ x\n+%else\n+%define SYM(x) x\n+%endif\n+\n+\t;;  Procedure ExSetMult\n+\t;;  Register Layout:\n+\t;;  INPUT: \trdi\t= a->n\n+\t;; \t   \trsi  \t= b->n\n+\t;; \t   \trdx  \t= r->a\n+\t;; \n+\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n+\t;; \t\tr9:r8    = c\n+\t;; \t\tr10-r13  = t0-t3\n+\t;; \t\tr14\t = b.n[0] / t4\n+\t;; \t\tr15\t = b.n[1] / t5\n+\t;; \t\trbx\t = b.n[2] / t6\n+\t;; \t\trcx\t = b.n[3] / t7\n+\t;; \t\trbp\t = Constant 0FFFFFFFFFFFFFh / t8\n+\t;; \t\trsi\t = b.n / b.n[4] / t9\n+\n+\tGLOBAL SYM(secp256k1_fe_mul_inner)\n+\tALIGN 32\n+SYM(secp256k1_fe_mul_inner):\n+\tpush rbp\n+\tpush rbx\n+\tpush r12\n+\tpush r13\n+\tpush r14\n+\tpush r15\n+\tpush rdx\n+\tmov r14,[rsi+8*0]\t; preload b.n[0]. This will be the case until\n+\t\t\t\t; b.n[0] is no longer needed, then we reassign\n+\t\t\t\t; r14 to t4\n+\t;; c=a.n[0] * b.n[0]\n+   \tmov rax,[rdi+0*8]\t; load a.n[0]\n+\tmov rbp,0FFFFFFFFFFFFFh\n+\tmul r14\t\t\t; rdx:rax=a.n[0]*b.n[0]\n+\tmov r15,[rsi+1*8]\n+\tmov r10,rbp\t\t; load modulus into target register for t0\n+\tmov r8,rax\n+\tand r10,rax\t\t; only need lower qword of c\n+\tshrd r8,rdx,52\n+\txor r9,r9\t\t; c < 2^64, so we ditch the HO part \n+\n+\t;; c+=a.n[0] * b.n[1] + a.n[1] * b.n[0]\n+\tmov rax,[rdi+0*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul r14\t\t\t\n+\tmov r11,rbp\n+\tmov rbx,[rsi+2*8]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r11,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\t;; c+=a.n[0 1 2] * b.n[2 1 0]\n+\tmov rax,[rdi+0*8]\n+\tmul rbx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul r14\n+\tmov r12,rbp\t\t\n+\tmov rcx,[rsi+3*8]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r12,r8\t\t\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[0 1 2 3] * b.n[3 2 1 0]\n+\tmov rax,[rdi+0*8]\n+\tmul rcx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul rbx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\t\n+\tmov rax,[rdi+3*8]\n+\tmul r14\t\t\t\n+\tmov r13,rbp             \n+\tmov rsi,[rsi+4*8]\t; load b.n[4] and destroy pointer\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r13,r8\n+\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\n+\t;; c+=a.n[0 1 2 3 4] * b.n[4 3 2 1 0]\n+\tmov rax,[rdi+0*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul rbx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+3*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul r14\t\t\t\n+\tmov r14,rbp             ; load modulus into t4 and destroy a.n[0]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r14,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[1 2 3 4] * b.n[4 3 2 1]\n+\tmov rax,[rdi+1*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+3*8]\n+\tmul rbx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul r15\n+\tmov r15,rbp\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tand r15,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[2 3 4] * b.n[4 3 2]\n+\tmov rax,[rdi+2*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+3*8]\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul rbx\n+\tmov rbx,rbp\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tand rbx,r8\t\t\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[3 4] * b.n[4 3]\n+\tmov rax,[rdi+3*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul rcx\n+\tmov rcx,rbp\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rcx,r8\t\t\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[4] * b.n[4]\n+\tmov rax,[rdi+4*8]\n+\tmul rsi\n+\t;; mov rbp,rbp\t\t; modulus already there!\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rbp,r8 \n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\tmov rsi,r8\t\t; load c into t9 and destroy b.n[4]\n+\n+\t;; *******************************************************\n+common_exit_norm:\n+\tmov rdi,01000003D10h\t; load constant\n+\n+\tmov rax,r15\t\t; get t5\n+\tmul rdi\n+\tadd rax,r10    \t\t; +t0\n+\tadc rdx,0\n+\tmov r10,0FFFFFFFFFFFFFh ; modulus. Sadly, we ran out of registers!\n+\tmov r8,rax\t\t; +c\n+\tand r10,rax\n+\tshrd r8,rdx,52\n+\txor r9,r9\n+\n+\tmov rax,rbx\t\t; get t6\n+\tmul rdi\n+\tadd rax,r11\t\t; +t1\n+\tadc rdx,0\n+\tmov r11,0FFFFFFFFFFFFFh ; modulus\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r11,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\n+\tmov rax,rcx    \t\t; get t7\n+\tmul rdi\n+\tadd rax,r12\t\t; +t2\n+\tadc rdx,0\n+\tpop rbx\t\t\t; retrieve pointer to this.n\t\n+\tmov r12,0FFFFFFFFFFFFFh ; modulus\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r12,r8\n+\tmov [rbx+2*8],r12\t; mov into this.n[2]\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\tmov rax,rbp    \t\t; get t8\n+\tmul rdi\n+\tadd rax,r13    \t\t; +t3\n+\tadc rdx,0\n+\tmov r13,0FFFFFFFFFFFFFh ; modulus\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r13,r8\n+\tmov [rbx+3*8],r13\t; -> this.n[3]\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\tmov rax,rsi    \t\t; get t9\n+\tmul rdi\n+\tadd rax,r14    \t\t; +t4\n+\tadc rdx,0\n+\tmov r14,0FFFFFFFFFFFFh\t; !!!\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r14,r8\n+\tmov [rbx+4*8],r14\t; -> this.n[4]\n+\tshrd r8,r9,48\t\t; !!!\n+\txor r9,r9\n+\t\n+\tmov rax,01000003D1h\n+\tmul r8\t\t\n+\tadd rax,r10\n+\tadc rdx,0\n+\tmov r10,0FFFFFFFFFFFFFh ; modulus\n+\tmov r8,rax\n+\tand rax,r10\n+\tshrd r8,rdx,52\n+\tmov [rbx+0*8],rax\t; -> this.n[0]\n+\tadd r8,r11\n+\tmov [rbx+1*8],r8\t; -> this.n[1]\n+\n+\tpop r15\n+\tpop r14\n+\tpop r13\n+\tpop r12\n+\tpop rbx\n+\tpop rbp\n+\tret\n+\n+\t\n+\t;;  PROC ExSetSquare\n+\t;;  Register Layout:\n+\t;;  INPUT: \trdi\t = a.n\n+\t;; \t   \trsi  \t = this.a\n+\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n+\t;; \t\tr9:r8    = c\n+\t;; \t\tr10-r13  = t0-t3\n+\t;; \t\tr14\t = a.n[0] / t4\n+\t;; \t\tr15\t = a.n[1] / t5\n+\t;; \t\trbx\t = a.n[2] / t6\n+\t;; \t\trcx\t = a.n[3] / t7\n+\t;; \t\trbp\t = 0FFFFFFFFFFFFFh / t8\n+\t;; \t\trsi\t = a.n[4] / t9\n+\tGLOBAL SYM(secp256k1_fe_sqr_inner)\n+\tALIGN 32\n+SYM(secp256k1_fe_sqr_inner):\n+\tpush rbp\n+\tpush rbx\n+\tpush r12\n+\tpush r13\n+\tpush r14\n+\tpush r15\n+\tpush rsi\n+\tmov rbp,0FFFFFFFFFFFFFh\n+\t\n+\t;; c=a.n[0] * a.n[0]\n+   \tmov r14,[rdi+0*8]\t; r14=a.n[0]\n+\tmov r10,rbp\t\t; modulus \n+\tmov rax,r14\n+\tmul rax\n+\tmov r15,[rdi+1*8]\t; a.n[1]\n+\tadd r14,r14\t\t; r14=2*a.n[0]\n+\tmov r8,rax\n+\tand r10,rax\t\t; only need lower qword\n+\tshrd r8,rdx,52\n+\txor r9,r9\n+\n+\t;; c+=2*a.n[0] * a.n[1]\n+\tmov rax,r14\t\t; r14=2*a.n[0]\n+\tmul r15\n+\tmov rbx,[rdi+2*8]\t; rbx=a.n[2]\n+\tmov r11,rbp \t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r11,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\t;; c+=2*a.n[0]*a.n[2]+a.n[1]*a.n[1]\n+\tmov rax,r14\n+\tmul rbx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,r15\n+\tmov r12,rbp\t\t; modulus\n+\tmul rax\n+\tmov rcx,[rdi+3*8]\t; rcx=a.n[3]\n+\tadd r15,r15\t\t; r15=a.n[1]*2\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r12,r8\t\t; only need lower dword\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[0]*a.n[3]+2*a.n[1]*a.n[2]\n+\tmov rax,r14\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,r15\t\t; rax=2*a.n[1]\n+\tmov r13,rbp\t\t; modulus\n+\tmul rbx\n+\tmov rsi,[rdi+4*8]\t; rsi=a.n[4]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r13,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[0]*a.n[4]+2*a.n[1]*a.n[3]+a.n[2]*a.n[2]\n+\tmov rax,r14\t\t; last time we need 2*a.n[0]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,r15\n+\tmul rcx\n+\tmov r14,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,rbx\n+\tmul rax\n+\tadd rbx,rbx\t\t; rcx=2*a.n[2]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r14,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[1]*a.n[4]+2*a.n[2]*a.n[3]\n+\tmov rax,r15\t\t; last time we need 2*a.n[1]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,rbx\n+\tmul rcx\n+\tmov r15,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r15,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[2]*a.n[4]+a.n[3]*a.n[3]\n+\tmov rax,rbx\t\t; last time we need 2*a.n[2]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,rcx\t\t; a.n[3]\n+\tmul rax\n+\tmov rbx,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rbx,r8\t\t; only need lower dword\n+\tlea rax,[2*rcx]\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[3]*a.n[4]\n+\tmul rsi\n+\tmov rcx,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rcx,r8\t\t; only need lower dword\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[4]*a.n[4]\n+\tmov rax,rsi\n+\tmul rax\n+\t;; mov rbp,rbp\t\t; modulus is already there!\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rbp,r8 \n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\tmov rsi,r8\n+\n+\t;; *******************************************************\n+\tjmp common_exit_norm\n+\tend\n+\n+\t"
      },
      {
        "sha": "93c6ab6b585466d480e5d74d5579d10655c9c776",
        "filename": "src/field_5x52_asm_impl.h",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_asm_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_asm_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_asm_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,11 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+#define _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+\n+void __attribute__ ((sysv_abi)) secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t *b, uint64_t *r);\n+void __attribute__ ((sysv_abi)) secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r);\n+\n+#endif"
      },
      {
        "sha": "5afabae38d3feed7e9a92b849bc19b2d445c73c1",
        "filename": "src/field_5x52_impl.h",
        "status": "added",
        "additions": 257,
        "deletions": 0,
        "changes": 257,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,257 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n+#define _SECP256K1_FIELD_REPR_IMPL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <assert.h>\n+#include <string.h>\n+#include \"util.h\"\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+#if defined(USE_FIELD_5X52_ASM)\n+#include \"field_5x52_asm_impl.h\"\n+#elif defined(USE_FIELD_5X52_INT128)\n+#include \"field_5x52_int128_impl.h\"\n+#else\n+#error \"Please select field_5x52 implementation\"\n+#endif\n+\n+/** Implements arithmetic modulo FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F,\n+ *  represented as 5 uint64_t's in base 2^52. The values are allowed to contain >52 each. In particular,\n+ *  each FieldElem has a 'magnitude' associated with it. Internally, a magnitude M means each element\n+ *  is at most M*(2^53-1), except the most significant one, which is limited to M*(2^49-1). All operations\n+ *  accept any input with magnitude at most M, and have different rules for propagating magnitude to their\n+ *  output.\n+ */\n+\n+void static secp256k1_fe_inner_start(void) {}\n+void static secp256k1_fe_inner_stop(void) {}\n+\n+#ifdef VERIFY\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {\n+    const uint64_t *d = a->n;\n+    int m = a->normalized ? 1 : 2 * a->magnitude, r = 1;\n+    r &= (d[0] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[1] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[2] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[3] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[4] <= 0x0FFFFFFFFFFFFULL * m);\n+    r &= (a->magnitude >= 0);\n+    if (a->normalized) {\n+        r &= (a->magnitude <= 1);\n+        if (r && (d[4] == 0x0FFFFFFFFFFFFULL) && ((d[3] & d[2] & d[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            r &= (d[0] < 0xFFFFEFFFFFC2FULL);\n+        }\n+    }\n+    VERIFY_CHECK(r == 1);\n+}\n+#else\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {}\n+#endif\n+\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r) {\n+    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];\n+\n+    // Reduce t4 at the start so there will be at most a single carry from the first pass\n+    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;\n+    uint64_t m;\n+\n+    // The first pass ensures the magnitude is 1, ...\n+    t0 += x * 0x1000003D1ULL;\n+    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; m = t1;\n+    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; m &= t2;\n+    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; m &= t3;\n+\n+    // ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element)\n+    VERIFY_CHECK(t4 >> 49 == 0);\n+\n+    // At most a single final reduction is needed; check if the value is >= the field characteristic\n+    x = (t4 >> 48) | ((t4 == 0x0FFFFFFFFFFFFULL) & (m == 0xFFFFFFFFFFFFFULL)\n+        & (t0 >= 0xFFFFEFFFFFC2FULL));\n+\n+    // Apply the final reduction (for constant-time behaviour, we do it always)\n+    t0 += x * 0x1000003D1ULL;\n+    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;\n+    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;\n+    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;\n+\n+    // If t4 didn't carry to bit 48 already, then it should have after any final reduction\n+    VERIFY_CHECK(t4 >> 48 == x);\n+\n+    // Mask off the possible multiple of 2^256 from the final reduction\n+    t4 &= 0x0FFFFFFFFFFFFULL;\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] = a;\n+    r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+int static inline secp256k1_fe_is_zero(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    const uint64_t *t = a->n;\n+    return (t[0] | t[1] | t[2] | t[3] | t[4]) == 0;\n+}\n+\n+int static inline secp256k1_fe_is_odd(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    return a->n[0] & 1;\n+}\n+\n+void static inline secp256k1_fe_clear(secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    a->magnitude = 0;\n+    a->normalized = 1;\n+#endif\n+    for (int i=0; i<5; i++) {\n+        a->n[i] = 0;\n+    }\n+}\n+\n+int static inline secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    VERIFY_CHECK(b->normalized);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    const uint64_t *t = a->n, *u = b->n;\n+    return ((t[0]^u[0]) | (t[1]^u[1]) | (t[2]^u[2]) | (t[3]^u[3]) | (t[4]^u[4])) == 0;\n+}\n+\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a) {\n+    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n+    for (int i=0; i<32; i++) {\n+        for (int j=0; j<2; j++) {\n+            int limb = (8*i+4*j)/52;\n+            int shift = (8*i+4*j)%52;\n+            r->n[limb] |= (uint64_t)((a[31-i] >> (4*j)) & 0xF) << shift;\n+        }\n+    }\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    for (int i=0; i<32; i++) {\n+        int c = 0;\n+        for (int j=0; j<2; j++) {\n+            int limb = (8*i+4*j)/52;\n+            int shift = (8*i+4*j)%52;\n+            c |= ((a->n[limb] >> shift) & 0xF) << (4 * j);\n+        }\n+        r[31-i] = c;\n+    }\n+}\n+\n+void static inline secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= m);\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] = 0xFFFFEFFFFFC2FULL * 2 * (m + 1) - a->n[0];\n+    r->n[1] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[1];\n+    r->n[2] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[2];\n+    r->n[3] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[3];\n+    r->n[4] = 0x0FFFFFFFFFFFFULL * 2 * (m + 1) - a->n[4];\n+#ifdef VERIFY\n+    r->magnitude = m + 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] *= a;\n+    r->n[1] *= a;\n+    r->n[2] *= a;\n+    r->n[3] *= a;\n+    r->n[4] *= a;\n+#ifdef VERIFY\n+    r->magnitude *= a;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] += a->n[0];\n+    r->n[1] += a->n[1];\n+    r->n[2] += a->n[2];\n+    r->n[3] += a->n[3];\n+    r->n[4] += a->n[4];\n+#ifdef VERIFY\n+    r->magnitude += a->magnitude;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    VERIFY_CHECK(b->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+#endif\n+    secp256k1_fe_sqr_inner(a->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+#endif"
      },
      {
        "sha": "23cb134623896a12fa5bf62813968c45c1a54f04",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,105 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+#define _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+\n+#include <stdint.h>\n+\n+void static inline secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t *b, uint64_t *r) {\n+    __int128 c = (__int128)a[0] * b[0];\n+    uint64_t t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0FFFFFFFFFFFFFE0\n+    c = c + (__int128)a[0] * b[1] +\n+            (__int128)a[1] * b[0];\n+    uint64_t t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 20000000000000BF\n+    c = c + (__int128)a[0] * b[2] +\n+            (__int128)a[1] * b[1] +\n+            (__int128)a[2] * b[0];\n+    uint64_t t2 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 30000000000001A0\n+    c = c + (__int128)a[0] * b[3] +\n+            (__int128)a[1] * b[2] +\n+            (__int128)a[2] * b[1] +\n+            (__int128)a[3] * b[0];\n+    uint64_t t3 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 4000000000000280\n+    c = c + (__int128)a[0] * b[4] +\n+            (__int128)a[1] * b[3] +\n+            (__int128)a[2] * b[2] +\n+            (__int128)a[3] * b[1] +\n+            (__int128)a[4] * b[0];\n+    uint64_t t4 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 320000000000037E\n+    c = c + (__int128)a[1] * b[4] +\n+            (__int128)a[2] * b[3] +\n+            (__int128)a[3] * b[2] +\n+            (__int128)a[4] * b[1];\n+    uint64_t t5 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 22000000000002BE\n+    c = c + (__int128)a[2] * b[4] +\n+            (__int128)a[3] * b[3] +\n+            (__int128)a[4] * b[2];\n+    uint64_t t6 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 12000000000001DE\n+    c = c + (__int128)a[3] * b[4] +\n+            (__int128)a[4] * b[3];\n+    uint64_t t7 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 02000000000000FE\n+    c = c + (__int128)a[4] * b[4];\n+    uint64_t t8 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 001000000000001E\n+    uint64_t t9 = c;\n+\n+    c = t0 + (__int128)t5 * 0x1000003D10ULL;\n+    t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t1 + (__int128)t6 * 0x1000003D10ULL;\n+    t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t2 + (__int128)t7 * 0x1000003D10ULL;\n+    r[2] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t3 + (__int128)t8 * 0x1000003D10ULL;\n+    r[3] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t4 + (__int128)t9 * 0x1000003D10ULL;\n+    r[4] = c & 0x0FFFFFFFFFFFFULL; c = c >> 48; // c max 000001000003D110\n+    c = t0 + (__int128)c * 0x1000003D1ULL;\n+    r[0] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 1000008\n+    r[1] = t1 + c;\n+\n+}\n+\n+void static inline secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r) {\n+    __int128 c = (__int128)a[0] * a[0];\n+    uint64_t t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0FFFFFFFFFFFFFE0\n+    c = c + (__int128)(a[0]*2) * a[1];\n+    uint64_t t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 20000000000000BF\n+    c = c + (__int128)(a[0]*2) * a[2] +\n+            (__int128)a[1] * a[1];\n+    uint64_t t2 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 30000000000001A0\n+    c = c + (__int128)(a[0]*2) * a[3] +\n+            (__int128)(a[1]*2) * a[2];\n+    uint64_t t3 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 4000000000000280\n+    c = c + (__int128)(a[0]*2) * a[4] +\n+            (__int128)(a[1]*2) * a[3] +\n+            (__int128)a[2] * a[2];\n+    uint64_t t4 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 320000000000037E\n+    c = c + (__int128)(a[1]*2) * a[4] +\n+            (__int128)(a[2]*2) * a[3];\n+    uint64_t t5 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 22000000000002BE\n+    c = c + (__int128)(a[2]*2) * a[4] +\n+            (__int128)a[3] * a[3];\n+    uint64_t t6 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 12000000000001DE\n+    c = c + (__int128)(a[3]*2) * a[4];\n+    uint64_t t7 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 02000000000000FE\n+    c = c + (__int128)a[4] * a[4];\n+    uint64_t t8 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 001000000000001E\n+    uint64_t t9 = c;\n+    c = t0 + (__int128)t5 * 0x1000003D10ULL;\n+    t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t1 + (__int128)t6 * 0x1000003D10ULL;\n+    t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t2 + (__int128)t7 * 0x1000003D10ULL;\n+    r[2] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t3 + (__int128)t8 * 0x1000003D10ULL;\n+    r[3] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t4 + (__int128)t9 * 0x1000003D10ULL;\n+    r[4] = c & 0x0FFFFFFFFFFFFULL; c = c >> 48; // c max 000001000003D110\n+    c = t0 + (__int128)c * 0x1000003D1ULL;\n+    r[0] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 1000008\n+    r[1] = t1 + c;\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "d51dea0afc479da5399a88fa3e6da6f0e108ca6e",
        "filename": "src/field_gmp.h",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_gmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_gmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_gmp.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,16 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_\n+#define _SECP256K1_FIELD_REPR_\n+\n+#include <gmp.h>\n+\n+#define FIELD_LIMBS ((256 + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS)\n+\n+typedef struct {\n+    mp_limb_t n[FIELD_LIMBS+1];\n+} secp256k1_fe_t;\n+\n+#endif"
      },
      {
        "sha": "d97cfa7341112f092596bc0a5bdaf1da84cb46b1",
        "filename": "src/field_gmp_impl.h",
        "status": "added",
        "additions": 159,
        "deletions": 0,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_gmp_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n+#define _SECP256K1_FIELD_REPR_IMPL_H_\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+static mp_limb_t secp256k1_field_p[FIELD_LIMBS];\n+static mp_limb_t secp256k1_field_pc[(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS];\n+\n+void static secp256k1_fe_inner_start(void) {\n+    for (int i=0; i<(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; i++)\n+        secp256k1_field_pc[i] = 0;\n+    secp256k1_field_pc[0] += 0x3D1UL;\n+    secp256k1_field_pc[32/GMP_NUMB_BITS] += (((mp_limb_t)1) << (32 % GMP_NUMB_BITS));\n+    for (int i=0; i<FIELD_LIMBS; i++) {\n+        secp256k1_field_p[i] = 0;\n+    }\n+    mpn_sub(secp256k1_field_p, secp256k1_field_p, FIELD_LIMBS, secp256k1_field_pc, (33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS);\n+}\n+\n+void static secp256k1_fe_inner_stop(void) {\n+}\n+\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r) {\n+    if (r->n[FIELD_LIMBS] != 0) {\n+#if (GMP_NUMB_BITS >= 40)\n+        mp_limb_t carry = mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x1000003D1ULL * r->n[FIELD_LIMBS]);\n+        mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x1000003D1ULL * carry);\n+#else\n+        mp_limb_t carry = mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x3D1UL * r->n[FIELD_LIMBS]) + \n+                          mpn_add_1(r->n+(32/GMP_NUMB_BITS), r->n+(32/GMP_NUMB_BITS), FIELD_LIMBS-(32/GMP_NUMB_BITS), r->n[FIELD_LIMBS] << (32 % GMP_NUMB_BITS));\n+        mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x3D1UL * carry);\n+        mpn_add_1(r->n+(32/GMP_NUMB_BITS), r->n+(32/GMP_NUMB_BITS), FIELD_LIMBS-(32/GMP_NUMB_BITS), carry << (32%GMP_NUMB_BITS));\n+#endif\n+        r->n[FIELD_LIMBS] = 0;\n+    }\n+    if (mpn_cmp(r->n, secp256k1_field_p, FIELD_LIMBS) >= 0)\n+        mpn_sub(r->n, r->n, FIELD_LIMBS, secp256k1_field_p, FIELD_LIMBS);\n+}\n+\n+void static inline secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] = a;\n+    for (int i=1; i<FIELD_LIMBS+1; i++)\n+        r->n[i] = 0;\n+}\n+\n+void static inline secp256k1_fe_clear(secp256k1_fe_t *r) {\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        r->n[i] = 0;\n+}\n+\n+int static inline secp256k1_fe_is_zero(const secp256k1_fe_t *a) {\n+    int ret = 1;\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        ret &= (a->n[i] == 0);\n+    return ret;\n+}\n+\n+int static inline secp256k1_fe_is_odd(const secp256k1_fe_t *a) {\n+    return a->n[0] & 1;\n+}\n+\n+int static inline secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+    int ret = 1;\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        ret &= (a->n[i] == b->n[i]);\n+    return ret;\n+}\n+\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a) {\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        r->n[i] = 0;\n+    for (int i=0; i<256; i++) {\n+        int limb = i/GMP_NUMB_BITS;\n+        int shift = i%GMP_NUMB_BITS;\n+        r->n[limb] |= (mp_limb_t)((a[31-i/8] >> (i%8)) & 0x1) << shift;\n+    }\n+}\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a) {\n+    for (int i=0; i<32; i++) {\n+        int c = 0;\n+        for (int j=0; j<8; j++) {\n+            int limb = (8*i+j)/GMP_NUMB_BITS;\n+            int shift = (8*i+j)%GMP_NUMB_BITS;\n+            c |= ((a->n[limb] >> shift) & 0x1) << j;\n+        }\n+        r[31-i] = c;\n+    }\n+}\n+\n+void static inline secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m) {\n+    *r = *a;\n+    secp256k1_fe_normalize(r);\n+    for (int i=0; i<FIELD_LIMBS; i++)\n+        r->n[i] = ~(r->n[i]);\n+#if (GMP_NUMB_BITS >= 33)\n+    mpn_sub_1(r->n, r->n, FIELD_LIMBS, 0x1000003D0ULL);\n+#else\n+    mpn_sub_1(r->n, r->n, FIELD_LIMBS, 0x3D0UL);\n+    mpn_sub_1(r->n+(32/GMP_NUMB_BITS), r->n+(32/GMP_NUMB_BITS), FIELD_LIMBS-(32/GMP_NUMB_BITS), 0x1UL << (32%GMP_NUMB_BITS));\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_int(secp256k1_fe_t *r, int a) {\n+    mpn_mul_1(r->n, r->n, FIELD_LIMBS+1, a);\n+}\n+\n+void static inline secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+    mpn_add(r->n, r->n, FIELD_LIMBS+1, a->n, FIELD_LIMBS+1);\n+}\n+\n+void static secp256k1_fe_reduce(secp256k1_fe_t *r, mp_limb_t *tmp) {\n+    // <A1 A2 A3 A4> <B1 B2 B3 B4>\n+    //       B1 B2 B3 B4\n+    // + C * A1 A2 A3 A4\n+    // +  A1 A2 A3 A4\n+\n+#if (GMP_NUMB_BITS >= 33)\n+    mp_limb_t o = mpn_addmul_1(tmp, tmp+FIELD_LIMBS, FIELD_LIMBS, 0x1000003D1ULL);\n+#else\n+    mp_limb_t o = mpn_addmul_1(tmp, tmp+FIELD_LIMBS, FIELD_LIMBS, 0x3D1UL) +\n+                  mpn_addmul_1(tmp+(32/GMP_NUMB_BITS), tmp+FIELD_LIMBS, FIELD_LIMBS-(32/GMP_NUMB_BITS), 0x1UL << (32%GMP_NUMB_BITS));\n+#endif\n+    mp_limb_t q[1+(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS];\n+    q[(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS] = mpn_mul_1(q, secp256k1_field_pc, (33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS, o);\n+#if (GMP_NUMB_BITS <= 32)\n+    mp_limb_t o2 = tmp[2*FIELD_LIMBS-(32/GMP_NUMB_BITS)] << (32%GMP_NUMB_BITS);\n+    q[(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS] += mpn_addmul_1(q, secp256k1_field_pc, (33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS, o2);\n+#endif\n+    r->n[FIELD_LIMBS] = mpn_add(r->n, tmp, FIELD_LIMBS, q, 1+(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS);\n+}\n+\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+    secp256k1_fe_t ac = *a;\n+    secp256k1_fe_t bc = *b;\n+    secp256k1_fe_normalize(&ac);\n+    secp256k1_fe_normalize(&bc);\n+    mp_limb_t tmp[2*FIELD_LIMBS];\n+    mpn_mul_n(tmp, ac.n, bc.n, FIELD_LIMBS);\n+    secp256k1_fe_reduce(r, tmp);\n+}\n+\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+    secp256k1_fe_t ac = *a;\n+    secp256k1_fe_normalize(&ac);\n+    mp_limb_t tmp[2*FIELD_LIMBS];\n+    mpn_sqr(tmp, ac.n, FIELD_LIMBS);\n+    secp256k1_fe_reduce(r, tmp);\n+}\n+\n+#endif"
      },
      {
        "sha": "df6216f3dbe0fefd8b9ac805db4160c7bb0097f6",
        "filename": "src/field_impl.h",
        "status": "added",
        "additions": 289,
        "deletions": 0,
        "changes": 289,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,289 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_IMPL_H_\n+#define _SECP256K1_FIELD_IMPL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"util.h\"\n+\n+#if defined(USE_FIELD_GMP)\n+#include \"field_gmp_impl.h\"\n+#elif defined(USE_FIELD_10X26)\n+#include \"field_10x26_impl.h\"\n+#elif defined(USE_FIELD_5X52)\n+#include \"field_5x52_impl.h\"\n+#else\n+#error \"Please select field implementation\"\n+#endif\n+\n+void static secp256k1_fe_get_hex(char *r, int *rlen, const secp256k1_fe_t *a) {\n+    if (*rlen < 65) {\n+        *rlen = 65;\n+        return;\n+    }\n+    *rlen = 65;\n+    unsigned char tmp[32];\n+    secp256k1_fe_t b = *a;\n+    secp256k1_fe_normalize(&b);\n+    secp256k1_fe_get_b32(tmp, &b);\n+    for (int i=0; i<32; i++) {\n+        static const char *c = \"0123456789ABCDEF\";\n+        r[2*i]   = c[(tmp[i] >> 4) & 0xF];\n+        r[2*i+1] = c[(tmp[i]) & 0xF];\n+    }\n+    r[64] = 0x00;\n+}\n+\n+void static secp256k1_fe_set_hex(secp256k1_fe_t *r, const char *a, int alen) {\n+    unsigned char tmp[32] = {};\n+    static const int cvt[256] = {0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 1, 2, 3, 4, 5, 6,7,8,9,0,0,0,0,0,0,\n+                                 0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0};\n+    for (int i=0; i<32; i++) {\n+        if (alen > i*2)\n+            tmp[32 - alen/2 + i] = (cvt[(unsigned char)a[2*i]] << 4) + cvt[(unsigned char)a[2*i+1]];\n+    }\n+    secp256k1_fe_set_b32(r, tmp);\n+}\n+\n+int static secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+\n+    // The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n+    // { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n+    // 1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n+\n+    secp256k1_fe_t x2;\n+    secp256k1_fe_sqr(&x2, a);\n+    secp256k1_fe_mul(&x2, &x2, a);\n+\n+    secp256k1_fe_t x3;\n+    secp256k1_fe_sqr(&x3, &x2);\n+    secp256k1_fe_mul(&x3, &x3, a);\n+\n+    secp256k1_fe_t x6 = x3;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    secp256k1_fe_mul(&x6, &x6, &x3);\n+\n+    secp256k1_fe_t x9 = x6;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    secp256k1_fe_mul(&x9, &x9, &x3);\n+\n+    secp256k1_fe_t x11 = x9;\n+    for (int j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    secp256k1_fe_mul(&x11, &x11, &x2);\n+\n+    secp256k1_fe_t x22 = x11;\n+    for (int j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    secp256k1_fe_mul(&x22, &x22, &x11);\n+\n+    secp256k1_fe_t x44 = x22;\n+    for (int j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    secp256k1_fe_mul(&x44, &x44, &x22);\n+\n+    secp256k1_fe_t x88 = x44;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    secp256k1_fe_mul(&x88, &x88, &x44);\n+\n+    secp256k1_fe_t x176 = x88;\n+    for (int j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    secp256k1_fe_mul(&x176, &x176, &x88);\n+\n+    secp256k1_fe_t x220 = x176;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    secp256k1_fe_mul(&x220, &x220, &x44);\n+\n+    secp256k1_fe_t x223 = x220;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    secp256k1_fe_mul(&x223, &x223, &x3);\n+\n+    // The final result is then assembled using a sliding window over the blocks.\n+\n+    secp256k1_fe_t t1 = x223;\n+    for (int j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x22);\n+    for (int j=0; j<6; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x2);\n+    secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_sqr(r, &t1);\n+\n+    // Check that a square root was actually calculated\n+\n+    secp256k1_fe_sqr(&t1, r);\n+    secp256k1_fe_negate(&t1, &t1, 1);\n+    secp256k1_fe_add(&t1, a);\n+    secp256k1_fe_normalize(&t1);\n+    return secp256k1_fe_is_zero(&t1);\n+}\n+\n+void static secp256k1_fe_inv(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+\n+    // The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n+    // { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n+    // [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n+\n+    secp256k1_fe_t x2;\n+    secp256k1_fe_sqr(&x2, a);\n+    secp256k1_fe_mul(&x2, &x2, a);\n+\n+    secp256k1_fe_t x3;\n+    secp256k1_fe_sqr(&x3, &x2);\n+    secp256k1_fe_mul(&x3, &x3, a);\n+\n+    secp256k1_fe_t x6 = x3;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    secp256k1_fe_mul(&x6, &x6, &x3);\n+\n+    secp256k1_fe_t x9 = x6;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    secp256k1_fe_mul(&x9, &x9, &x3);\n+\n+    secp256k1_fe_t x11 = x9;\n+    for (int j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    secp256k1_fe_mul(&x11, &x11, &x2);\n+\n+    secp256k1_fe_t x22 = x11;\n+    for (int j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    secp256k1_fe_mul(&x22, &x22, &x11);\n+\n+    secp256k1_fe_t x44 = x22;\n+    for (int j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    secp256k1_fe_mul(&x44, &x44, &x22);\n+\n+    secp256k1_fe_t x88 = x44;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    secp256k1_fe_mul(&x88, &x88, &x44);\n+\n+    secp256k1_fe_t x176 = x88;\n+    for (int j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    secp256k1_fe_mul(&x176, &x176, &x88);\n+\n+    secp256k1_fe_t x220 = x176;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    secp256k1_fe_mul(&x220, &x220, &x44);\n+\n+    secp256k1_fe_t x223 = x220;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    secp256k1_fe_mul(&x223, &x223, &x3);\n+\n+    // The final result is then assembled using a sliding window over the blocks.\n+\n+    secp256k1_fe_t t1 = x223;\n+    for (int j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x22);\n+    for (int j=0; j<5; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, a);\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x2);\n+    for (int j=0; j<2; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(r, &t1, a);\n+}\n+\n+void static secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#if defined(USE_FIELD_INV_BUILTIN)\n+    secp256k1_fe_inv(r, a);\n+#elif defined(USE_FIELD_INV_NUM)\n+    unsigned char b[32];\n+    secp256k1_fe_t c = *a;\n+    secp256k1_fe_normalize(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_t n; \n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_mod_inverse(&n, &n, &secp256k1_fe_consts->p);\n+    secp256k1_num_get_bin(b, 32, &n);\n+    secp256k1_fe_set_b32(r, b);\n+#else\n+#error \"Please select field inverse implementation\"\n+#endif\n+}\n+\n+void static secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n+    if (len < 1)\n+        return;\n+\n+    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n+\n+    r[0] = a[0];\n+\n+    int i = 0;\n+    while (++i < len) {\n+        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n+    }\n+\n+    secp256k1_fe_t u; secp256k1_fe_inv(&u, &r[--i]);\n+\n+    while (i > 0) {\n+        int j = i--;\n+        secp256k1_fe_mul(&r[j], &r[i], &u);\n+        secp256k1_fe_mul(&u, &u, &a[j]);\n+    }\n+\n+    r[0] = u;\n+}\n+\n+void static secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n+    if (len < 1)\n+        return;\n+\n+    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n+\n+    r[0] = a[0];\n+\n+    int i = 0;\n+    while (++i < len) {\n+        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n+    }\n+\n+    secp256k1_fe_t u; secp256k1_fe_inv_var(&u, &r[--i]);\n+\n+    while (i > 0) {\n+        int j = i--;\n+        secp256k1_fe_mul(&r[j], &r[i], &u);\n+        secp256k1_fe_mul(&u, &u, &a[j]);\n+    }\n+\n+    r[0] = u;\n+}\n+\n+void static secp256k1_fe_start(void) {\n+    static const unsigned char secp256k1_fe_consts_p[] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+    if (secp256k1_fe_consts == NULL) {\n+        secp256k1_fe_inner_start();\n+        secp256k1_fe_consts_t *ret = (secp256k1_fe_consts_t*)malloc(sizeof(secp256k1_fe_consts_t));\n+        secp256k1_num_set_bin(&ret->p, secp256k1_fe_consts_p, sizeof(secp256k1_fe_consts_p));\n+        secp256k1_fe_consts = ret;\n+    }\n+}\n+\n+void static secp256k1_fe_stop(void) {\n+    if (secp256k1_fe_consts != NULL) {\n+        secp256k1_fe_consts_t *c = (secp256k1_fe_consts_t*)secp256k1_fe_consts;\n+        free((void*)c);\n+        secp256k1_fe_consts = NULL;\n+        secp256k1_fe_inner_stop();\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "fde1e1365f49ff43b554ce75550ba0bc96db8fdb",
        "filename": "src/group.h",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_GROUP_\n+#define _SECP256K1_GROUP_\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+/** A group element of the secp256k1 curve, in affine coordinates. */\n+typedef struct {\n+    secp256k1_fe_t x;\n+    secp256k1_fe_t y;\n+    int infinity; // whether this represents the point at infinity\n+} secp256k1_ge_t;\n+\n+/** A group element of the secp256k1 curve, in jacobian coordinates. */\n+typedef struct {\n+    secp256k1_fe_t x; // actual X: x/z^2\n+    secp256k1_fe_t y; // actual Y: y/z^3\n+    secp256k1_fe_t z;\n+    int infinity; // whether this represents the point at infinity\n+} secp256k1_gej_t;\n+\n+/** Global constants related to the group */\n+typedef struct {\n+    secp256k1_num_t order; // the order of the curve (= order of its generator)\n+    secp256k1_num_t half_order; // half the order of the curve (= order of its generator)\n+    secp256k1_ge_t g; // the generator point\n+\n+#ifdef USE_ENDOMORPHISM\n+    // constants related to secp256k1's efficiently computable endomorphism\n+    secp256k1_fe_t beta;\n+    secp256k1_num_t lambda, a1b2, b1, a2;\n+#endif\n+} secp256k1_ge_consts_t;\n+\n+static const secp256k1_ge_consts_t *secp256k1_ge_consts = NULL;\n+\n+/** Initialize the group module. */\n+void static secp256k1_ge_start(void);\n+\n+/** De-initialize the group module. */\n+void static secp256k1_ge_stop(void);\n+\n+/** Set a group element equal to the point at infinity */\n+void static secp256k1_ge_set_infinity(secp256k1_ge_t *r);\n+\n+/** Set a group element equal to the point with given X and Y coordinates */\n+void static secp256k1_ge_set_xy(secp256k1_ge_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y);\n+\n+/** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n+ *  for Y. Return value indicates whether the result is valid. */\n+int  static secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd);\n+\n+/** Check whether a group element is the point at infinity. */\n+int  static secp256k1_ge_is_infinity(const secp256k1_ge_t *a);\n+\n+/** Check whether a group element is valid (i.e., on the curve). */\n+int  static secp256k1_ge_is_valid(const secp256k1_ge_t *a);\n+\n+void static secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a);\n+\n+/** Get a hex representation of a point. *rlen will be overwritten with the real length. */\n+void static secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a);\n+\n+/** Set a group element equal to another which is given in jacobian coordinates */\n+void static secp256k1_ge_set_gej(secp256k1_ge_t *r, secp256k1_gej_t *a);\n+\n+/** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n+void static secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], const secp256k1_gej_t a[len]);\n+\n+\n+/** Set a group element (jacobian) equal to the point at infinity. */\n+void static secp256k1_gej_set_infinity(secp256k1_gej_t *r);\n+\n+/** Set a group element (jacobian) equal to the point with given X and Y coordinates. */\n+void static secp256k1_gej_set_xy(secp256k1_gej_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y);\n+\n+/** Set a group element (jacobian) equal to another which is given in affine coordinates. */\n+void static secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a);\n+\n+/** Get the X coordinate of a group element (jacobian). */\n+void static secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a);\n+\n+/** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n+void static secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+\n+/** Check whether a group element is the point at infinity. */\n+int  static secp256k1_gej_is_infinity(const secp256k1_gej_t *a);\n+\n+/** Set r equal to the double of a. */\n+void static secp256k1_gej_double_var(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+\n+/** Set r equal to the sum of a and b. */\n+void static secp256k1_gej_add_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_gej_t *b);\n+\n+/** Set r equal to the sum of a and b (with b given in affine coordinates). This is more efficient\n+    than secp256k1_gej_add. */\n+void static secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_ge_t *b);\n+\n+/** Get a hex representation of a point. *rlen will be overwritten with the real length. */\n+void static secp256k1_gej_get_hex(char *r, int *rlen, const secp256k1_gej_t *a);\n+\n+#ifdef USE_ENDOMORPHISM\n+/** Set r to be equal to lambda times a, where lambda is chosen in a way such that this is very fast. */\n+void static secp256k1_gej_mul_lambda(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+\n+/** Find r1 and r2 such that r1+r2*lambda = a, and r1 and r2 are maximum 128 bits long (given that a is\n+    not more than 256 bits). */\n+void static secp256k1_gej_split_exp_var(secp256k1_num_t *r1, secp256k1_num_t *r2, const secp256k1_num_t *a);\n+#endif\n+\n+/** Clear a secp256k1_gej_t to prevent leaking sensitive information. */\n+void static secp256k1_gej_clear(secp256k1_gej_t *r);\n+\n+/** Clear a secp256k1_ge_t to prevent leaking sensitive information. */\n+void static secp256k1_ge_clear(secp256k1_ge_t *r);\n+\n+\n+#endif"
      },
      {
        "sha": "446ddf9daf8ba9beb1a47f748594223158c90d46",
        "filename": "src/group_impl.h",
        "status": "added",
        "additions": 439,
        "deletions": 0,
        "changes": 439,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_GROUP_IMPL_H_\n+#define _SECP256K1_GROUP_IMPL_H_\n+\n+#include <string.h>\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+#include \"group.h\"\n+\n+void static secp256k1_ge_set_infinity(secp256k1_ge_t *r) {\n+    r->infinity = 1;\n+}\n+\n+void static secp256k1_ge_set_xy(secp256k1_ge_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y) {\n+    r->infinity = 0;\n+    r->x = *x;\n+    r->y = *y;\n+}\n+\n+int static secp256k1_ge_is_infinity(const secp256k1_ge_t *a) {\n+    return a->infinity;\n+}\n+\n+void static secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a) {\n+    r->infinity = a->infinity;\n+    r->x = a->x;\n+    r->y = a->y;\n+    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_negate(&r->y, &r->y, 1);\n+}\n+\n+void static secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a) {\n+    char cx[65]; int lx=65;\n+    char cy[65]; int ly=65;\n+    secp256k1_fe_get_hex(cx, &lx, &a->x);\n+    secp256k1_fe_get_hex(cy, &ly, &a->y);\n+    lx = strlen(cx);\n+    ly = strlen(cy);\n+    int len = lx + ly + 3 + 1;\n+    if (*rlen < len) {\n+        *rlen = len;\n+        return;\n+    }\n+    *rlen = len;\n+    r[0] = '(';\n+    memcpy(r+1, cx, lx);\n+    r[1+lx] = ',';\n+    memcpy(r+2+lx, cy, ly);\n+    r[2+lx+ly] = ')';\n+    r[3+lx+ly] = 0;\n+}\n+\n+void static secp256k1_ge_set_gej(secp256k1_ge_t *r, secp256k1_gej_t *a) {\n+    r->infinity = a->infinity;\n+    secp256k1_fe_inv(&a->z, &a->z);\n+    secp256k1_fe_t z2; secp256k1_fe_sqr(&z2, &a->z);\n+    secp256k1_fe_t z3; secp256k1_fe_mul(&z3, &a->z, &z2);\n+    secp256k1_fe_mul(&a->x, &a->x, &z2);\n+    secp256k1_fe_mul(&a->y, &a->y, &z3);\n+    secp256k1_fe_set_int(&a->z, 1);\n+    r->x = a->x;\n+    r->y = a->y;\n+}\n+\n+void static secp256k1_ge_set_gej_var(secp256k1_ge_t *r, secp256k1_gej_t *a) {\n+    r->infinity = a->infinity;\n+    if (a->infinity) {\n+        return;\n+    }\n+    secp256k1_fe_inv_var(&a->z, &a->z);\n+    secp256k1_fe_t z2; secp256k1_fe_sqr(&z2, &a->z);\n+    secp256k1_fe_t z3; secp256k1_fe_mul(&z3, &a->z, &z2);\n+    secp256k1_fe_mul(&a->x, &a->x, &z2);\n+    secp256k1_fe_mul(&a->y, &a->y, &z3);\n+    secp256k1_fe_set_int(&a->z, 1);\n+    r->x = a->x;\n+    r->y = a->y;\n+}\n+\n+void static secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], const secp256k1_gej_t a[len]) {\n+    int count = 0;\n+    secp256k1_fe_t az[len];\n+    for (int i=0; i<len; i++) {\n+        if (!a[i].infinity) {\n+            az[count++] = a[i].z;\n+        }\n+    }\n+\n+    secp256k1_fe_t azi[count];\n+    secp256k1_fe_inv_all_var(count, azi, az);\n+\n+    count = 0;\n+    for (int i=0; i<len; i++) {\n+        r[i].infinity = a[i].infinity;\n+        if (!a[i].infinity) {\n+            secp256k1_fe_t *zi = &azi[count++];\n+            secp256k1_fe_t zi2; secp256k1_fe_sqr(&zi2, zi);\n+            secp256k1_fe_t zi3; secp256k1_fe_mul(&zi3, &zi2, zi);\n+            secp256k1_fe_mul(&r[i].x, &a[i].x, &zi2);\n+            secp256k1_fe_mul(&r[i].y, &a[i].y, &zi3);\n+        }\n+    }\n+}\n+\n+void static secp256k1_gej_set_infinity(secp256k1_gej_t *r) {\n+    r->infinity = 1;\n+}\n+\n+void static secp256k1_gej_set_xy(secp256k1_gej_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y) {\n+    r->infinity = 0;\n+    r->x = *x;\n+    r->y = *y;\n+    secp256k1_fe_set_int(&r->z, 1);\n+}\n+\n+void static secp256k1_gej_clear(secp256k1_gej_t *r) {\n+    r->infinity = 0;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+    secp256k1_fe_clear(&r->z);\n+}\n+\n+void static secp256k1_ge_clear(secp256k1_ge_t *r) {\n+    r->infinity = 0;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+}\n+\n+int static secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd) {\n+    r->x = *x;\n+    secp256k1_fe_t x2; secp256k1_fe_sqr(&x2, x);\n+    secp256k1_fe_t x3; secp256k1_fe_mul(&x3, x, &x2);\n+    r->infinity = 0;\n+    secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_add(&c, &x3);\n+    if (!secp256k1_fe_sqrt(&r->y, &c))\n+        return 0;\n+    secp256k1_fe_normalize(&r->y);\n+    if (secp256k1_fe_is_odd(&r->y) != odd)\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+    return 1;\n+}\n+\n+void static secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a) {\n+   r->infinity = a->infinity;\n+   r->x = a->x;\n+   r->y = a->y;\n+   secp256k1_fe_set_int(&r->z, 1);\n+}\n+\n+void static secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a) {\n+    secp256k1_fe_t zi2; secp256k1_fe_inv_var(&zi2, &a->z); secp256k1_fe_sqr(&zi2, &zi2);\n+    secp256k1_fe_mul(r, &a->x, &zi2);\n+}\n+\n+void static secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+    r->infinity = a->infinity;\n+    r->x = a->x;\n+    r->y = a->y;\n+    r->z = a->z;\n+    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_negate(&r->y, &r->y, 1);\n+}\n+\n+int static secp256k1_gej_is_infinity(const secp256k1_gej_t *a) {\n+    return a->infinity;\n+}\n+\n+int static secp256k1_gej_is_valid(const secp256k1_gej_t *a) {\n+    if (a->infinity)\n+        return 0;\n+    // y^2 = x^3 + 7\n+    // (Y/Z^3)^2 = (X/Z^2)^3 + 7\n+    // Y^2 / Z^6 = X^3 / Z^6 + 7\n+    // Y^2 = X^3 + 7*Z^6\n+    secp256k1_fe_t y2; secp256k1_fe_sqr(&y2, &a->y);\n+    secp256k1_fe_t x3; secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n+    secp256k1_fe_t z2; secp256k1_fe_sqr(&z2, &a->z);\n+    secp256k1_fe_t z6; secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n+    secp256k1_fe_mul_int(&z6, 7);\n+    secp256k1_fe_add(&x3, &z6);\n+    secp256k1_fe_normalize(&y2);\n+    secp256k1_fe_normalize(&x3);\n+    return secp256k1_fe_equal(&y2, &x3);\n+}\n+\n+int static secp256k1_ge_is_valid(const secp256k1_ge_t *a) {\n+    if (a->infinity)\n+        return 0;\n+    // y^2 = x^3 + 7\n+    secp256k1_fe_t y2; secp256k1_fe_sqr(&y2, &a->y);\n+    secp256k1_fe_t x3; secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n+    secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_add(&x3, &c);\n+    secp256k1_fe_normalize(&y2);\n+    secp256k1_fe_normalize(&x3);\n+    return secp256k1_fe_equal(&y2, &x3);\n+}\n+\n+void static secp256k1_gej_double_var(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+    if (a->infinity) {\n+        r->infinity = 1;\n+        return;\n+    }\n+\n+    secp256k1_fe_t t5 = a->y;\n+    secp256k1_fe_normalize(&t5);\n+    if (secp256k1_fe_is_zero(&t5)) {\n+        r->infinity = 1;\n+        return;\n+    }\n+\n+    secp256k1_fe_t t1,t2,t3,t4;\n+    secp256k1_fe_mul(&r->z, &t5, &a->z);\n+    secp256k1_fe_mul_int(&r->z, 2);       // Z' = 2*Y*Z (2)\n+    secp256k1_fe_sqr(&t1, &a->x);\n+    secp256k1_fe_mul_int(&t1, 3);         // T1 = 3*X^2 (3)\n+    secp256k1_fe_sqr(&t2, &t1);           // T2 = 9*X^4 (1)\n+    secp256k1_fe_sqr(&t3, &t5);\n+    secp256k1_fe_mul_int(&t3, 2);         // T3 = 2*Y^2 (2)\n+    secp256k1_fe_sqr(&t4, &t3);\n+    secp256k1_fe_mul_int(&t4, 2);         // T4 = 8*Y^4 (2)\n+    secp256k1_fe_mul(&t3, &a->x, &t3);    // T3 = 2*X*Y^2 (1)\n+    r->x = t3;\n+    secp256k1_fe_mul_int(&r->x, 4);       // X' = 8*X*Y^2 (4)\n+    secp256k1_fe_negate(&r->x, &r->x, 4); // X' = -8*X*Y^2 (5)\n+    secp256k1_fe_add(&r->x, &t2);         // X' = 9*X^4 - 8*X*Y^2 (6)\n+    secp256k1_fe_negate(&t2, &t2, 1);     // T2 = -9*X^4 (2)\n+    secp256k1_fe_mul_int(&t3, 6);         // T3 = 12*X*Y^2 (6)\n+    secp256k1_fe_add(&t3, &t2);           // T3 = 12*X*Y^2 - 9*X^4 (8)\n+    secp256k1_fe_mul(&r->y, &t1, &t3);    // Y' = 36*X^3*Y^2 - 27*X^6 (1)\n+    secp256k1_fe_negate(&t2, &t4, 2);     // T2 = -8*Y^4 (3)\n+    secp256k1_fe_add(&r->y, &t2);         // Y' = 36*X^3*Y^2 - 27*X^6 - 8*Y^4 (4)\n+    r->infinity = 0;\n+}\n+\n+void static secp256k1_gej_add_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_gej_t *b) {\n+    if (a->infinity) {\n+        *r = *b;\n+        return;\n+    }\n+    if (b->infinity) {\n+        *r = *a;\n+        return;\n+    }\n+    r->infinity = 0;\n+    secp256k1_fe_t z22; secp256k1_fe_sqr(&z22, &b->z);\n+    secp256k1_fe_t z12; secp256k1_fe_sqr(&z12, &a->z);\n+    secp256k1_fe_t u1; secp256k1_fe_mul(&u1, &a->x, &z22);\n+    secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n+    secp256k1_fe_t s1; secp256k1_fe_mul(&s1, &a->y, &z22); secp256k1_fe_mul(&s1, &s1, &b->z);\n+    secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n+    secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_normalize(&u2);\n+    if (secp256k1_fe_equal(&u1, &u2)) {\n+        secp256k1_fe_normalize(&s1);\n+        secp256k1_fe_normalize(&s2);\n+        if (secp256k1_fe_equal(&s1, &s2)) {\n+            secp256k1_gej_double_var(r, a);\n+        } else {\n+            r->infinity = 1;\n+        }\n+        return;\n+    }\n+    secp256k1_fe_t h; secp256k1_fe_negate(&h, &u1, 1); secp256k1_fe_add(&h, &u2);\n+    secp256k1_fe_t i; secp256k1_fe_negate(&i, &s1, 1); secp256k1_fe_add(&i, &s2);\n+    secp256k1_fe_t i2; secp256k1_fe_sqr(&i2, &i);\n+    secp256k1_fe_t h2; secp256k1_fe_sqr(&h2, &h);\n+    secp256k1_fe_t h3; secp256k1_fe_mul(&h3, &h, &h2);\n+    secp256k1_fe_mul(&r->z, &a->z, &b->z); secp256k1_fe_mul(&r->z, &r->z, &h);\n+    secp256k1_fe_t t; secp256k1_fe_mul(&t, &u1, &h2);\n+    r->x = t; secp256k1_fe_mul_int(&r->x, 2); secp256k1_fe_add(&r->x, &h3); secp256k1_fe_negate(&r->x, &r->x, 3); secp256k1_fe_add(&r->x, &i2);\n+    secp256k1_fe_negate(&r->y, &r->x, 5); secp256k1_fe_add(&r->y, &t); secp256k1_fe_mul(&r->y, &r->y, &i);\n+    secp256k1_fe_mul(&h3, &h3, &s1); secp256k1_fe_negate(&h3, &h3, 1);\n+    secp256k1_fe_add(&r->y, &h3);\n+}\n+\n+void static secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_ge_t *b) {\n+    if (a->infinity) {\n+        r->infinity = b->infinity;\n+        r->x = b->x;\n+        r->y = b->y;\n+        secp256k1_fe_set_int(&r->z, 1);\n+        return;\n+    }\n+    if (b->infinity) {\n+        *r = *a;\n+        return;\n+    }\n+    r->infinity = 0;\n+    secp256k1_fe_t z12; secp256k1_fe_sqr(&z12, &a->z);\n+    secp256k1_fe_t u1 = a->x; secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n+    secp256k1_fe_t s1 = a->y; secp256k1_fe_normalize(&s1);\n+    secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n+    secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_normalize(&u2);\n+    if (secp256k1_fe_equal(&u1, &u2)) {\n+        secp256k1_fe_normalize(&s1);\n+        secp256k1_fe_normalize(&s2);\n+        if (secp256k1_fe_equal(&s1, &s2)) {\n+            secp256k1_gej_double_var(r, a);\n+        } else {\n+            r->infinity = 1;\n+        }\n+        return;\n+    }\n+    secp256k1_fe_t h; secp256k1_fe_negate(&h, &u1, 1); secp256k1_fe_add(&h, &u2);\n+    secp256k1_fe_t i; secp256k1_fe_negate(&i, &s1, 1); secp256k1_fe_add(&i, &s2);\n+    secp256k1_fe_t i2; secp256k1_fe_sqr(&i2, &i);\n+    secp256k1_fe_t h2; secp256k1_fe_sqr(&h2, &h);\n+    secp256k1_fe_t h3; secp256k1_fe_mul(&h3, &h, &h2);\n+    r->z = a->z; secp256k1_fe_mul(&r->z, &r->z, &h);\n+    secp256k1_fe_t t; secp256k1_fe_mul(&t, &u1, &h2);\n+    r->x = t; secp256k1_fe_mul_int(&r->x, 2); secp256k1_fe_add(&r->x, &h3); secp256k1_fe_negate(&r->x, &r->x, 3); secp256k1_fe_add(&r->x, &i2);\n+    secp256k1_fe_negate(&r->y, &r->x, 5); secp256k1_fe_add(&r->y, &t); secp256k1_fe_mul(&r->y, &r->y, &i);\n+    secp256k1_fe_mul(&h3, &h3, &s1); secp256k1_fe_negate(&h3, &h3, 1);\n+    secp256k1_fe_add(&r->y, &h3);\n+}\n+\n+void static secp256k1_gej_get_hex(char *r, int *rlen, const secp256k1_gej_t *a) {\n+    secp256k1_gej_t c = *a;\n+    secp256k1_ge_t t; secp256k1_ge_set_gej(&t, &c);\n+    secp256k1_ge_get_hex(r, rlen, &t);\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+void static secp256k1_gej_mul_lambda(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+    const secp256k1_fe_t *beta = &secp256k1_ge_consts->beta;\n+    *r = *a;\n+    secp256k1_fe_mul(&r->x, &r->x, beta);\n+}\n+\n+void static secp256k1_gej_split_exp_var(secp256k1_num_t *r1, secp256k1_num_t *r2, const secp256k1_num_t *a) {\n+    const secp256k1_ge_consts_t *c = secp256k1_ge_consts;\n+    secp256k1_num_t bnc1, bnc2, bnt1, bnt2, bnn2;\n+\n+    secp256k1_num_copy(&bnn2, &c->order);\n+    secp256k1_num_shift(&bnn2, 1);\n+\n+    secp256k1_num_mul(&bnc1, a, &c->a1b2);\n+    secp256k1_num_add(&bnc1, &bnc1, &bnn2);\n+    secp256k1_num_div(&bnc1, &bnc1, &c->order);\n+\n+    secp256k1_num_mul(&bnc2, a, &c->b1);\n+    secp256k1_num_add(&bnc2, &bnc2, &bnn2);\n+    secp256k1_num_div(&bnc2, &bnc2, &c->order);\n+\n+    secp256k1_num_mul(&bnt1, &bnc1, &c->a1b2);\n+    secp256k1_num_mul(&bnt2, &bnc2, &c->a2);\n+    secp256k1_num_add(&bnt1, &bnt1, &bnt2);\n+    secp256k1_num_sub(r1, a, &bnt1);\n+    secp256k1_num_mul(&bnt1, &bnc1, &c->b1);\n+    secp256k1_num_mul(&bnt2, &bnc2, &c->a1b2);\n+    secp256k1_num_sub(r2, &bnt1, &bnt2);\n+}\n+#endif\n+\n+\n+void static secp256k1_ge_start(void) {\n+    static const unsigned char secp256k1_ge_consts_order[] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n+        0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n+        0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n+    };\n+    static const unsigned char secp256k1_ge_consts_g_x[] = {\n+        0x79,0xBE,0x66,0x7E,0xF9,0xDC,0xBB,0xAC,\n+        0x55,0xA0,0x62,0x95,0xCE,0x87,0x0B,0x07,\n+        0x02,0x9B,0xFC,0xDB,0x2D,0xCE,0x28,0xD9,\n+        0x59,0xF2,0x81,0x5B,0x16,0xF8,0x17,0x98\n+    };\n+    static const unsigned char secp256k1_ge_consts_g_y[] = {\n+        0x48,0x3A,0xDA,0x77,0x26,0xA3,0xC4,0x65,\n+        0x5D,0xA4,0xFB,0xFC,0x0E,0x11,0x08,0xA8,\n+        0xFD,0x17,0xB4,0x48,0xA6,0x85,0x54,0x19,\n+        0x9C,0x47,0xD0,0x8F,0xFB,0x10,0xD4,0xB8\n+    };\n+#ifdef USE_ENDOMORPHISM\n+    // properties of secp256k1's efficiently computable endomorphism\n+    static const unsigned char secp256k1_ge_consts_lambda[] = {\n+        0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,\n+        0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n+        0x12,0x2e,0x22,0xea,0x20,0x81,0x66,0x78,\n+        0xdf,0x02,0x96,0x7c,0x1b,0x23,0xbd,0x72\n+    };\n+    static const unsigned char secp256k1_ge_consts_beta[] = {\n+        0x7a,0xe9,0x6a,0x2b,0x65,0x7c,0x07,0x10,\n+        0x6e,0x64,0x47,0x9e,0xac,0x34,0x34,0xe9,\n+        0x9c,0xf0,0x49,0x75,0x12,0xf5,0x89,0x95,\n+        0xc1,0x39,0x6c,0x28,0x71,0x95,0x01,0xee\n+    };\n+    static const unsigned char secp256k1_ge_consts_a1b2[] = {\n+        0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,\n+        0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15\n+    };\n+    static const unsigned char secp256k1_ge_consts_b1[] = {\n+        0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,\n+        0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3\n+    };\n+    static const unsigned char secp256k1_ge_consts_a2[] = {\n+        0x01,\n+        0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,\n+        0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8\n+    };\n+#endif\n+    if (secp256k1_ge_consts == NULL) {\n+        secp256k1_ge_consts_t *ret = (secp256k1_ge_consts_t*)malloc(sizeof(secp256k1_ge_consts_t));\n+        secp256k1_num_set_bin(&ret->order,  secp256k1_ge_consts_order,  sizeof(secp256k1_ge_consts_order));\n+        secp256k1_num_copy(&ret->half_order, &ret->order);\n+        secp256k1_num_shift(&ret->half_order, 1);\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_num_set_bin(&ret->lambda, secp256k1_ge_consts_lambda, sizeof(secp256k1_ge_consts_lambda));\n+        secp256k1_num_set_bin(&ret->a1b2,   secp256k1_ge_consts_a1b2,   sizeof(secp256k1_ge_consts_a1b2));\n+        secp256k1_num_set_bin(&ret->a2,     secp256k1_ge_consts_a2,     sizeof(secp256k1_ge_consts_a2));\n+        secp256k1_num_set_bin(&ret->b1,     secp256k1_ge_consts_b1,     sizeof(secp256k1_ge_consts_b1));\n+        secp256k1_fe_set_b32(&ret->beta, secp256k1_ge_consts_beta);\n+#endif\n+        secp256k1_fe_t g_x, g_y;\n+        secp256k1_fe_set_b32(&g_x, secp256k1_ge_consts_g_x);\n+        secp256k1_fe_set_b32(&g_y, secp256k1_ge_consts_g_y);\n+        secp256k1_ge_set_xy(&ret->g, &g_x, &g_y);\n+        secp256k1_ge_consts = ret;\n+    }\n+}\n+\n+void static secp256k1_ge_stop(void) {\n+    if (secp256k1_ge_consts != NULL) {\n+        secp256k1_ge_consts_t *c = (secp256k1_ge_consts_t*)secp256k1_ge_consts;\n+        free((void*)c);\n+        secp256k1_ge_consts = NULL;\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "90a498eaa2c40ba17b627a4406fc8af6521e2e0b",
        "filename": "src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1.java?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,60 @@\n+package org.bitcoin;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import com.google.common.base.Preconditions;\n+\n+\n+/**\n+ * This class holds native methods to handle ECDSA verification.\n+ * You can find an example library that can be used for this at\n+ * https://github.com/sipa/secp256k1\n+ */\n+public class NativeSecp256k1 {\n+    public static final boolean enabled;\n+    static {\n+        boolean isEnabled = true;\n+        try {\n+            System.loadLibrary(\"javasecp256k1\");\n+        } catch (UnsatisfiedLinkError e) {\n+            isEnabled = false;\n+        }\n+        enabled = isEnabled;\n+    }\n+    \n+    private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n+    /**\n+     * Verifies the given secp256k1 signature in native code.\n+     * Calling when enabled == false is undefined (probably library not loaded)\n+     * \n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param pub The public key which did the signing\n+     */\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+        Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.putInt(signature.length);\n+        byteBuff.putInt(pub.length);\n+        byteBuff.put(signature);\n+        byteBuff.put(pub);\n+        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+    }\n+\n+    /**\n+     * @param byteBuff signature format is byte[32] data,\n+     *        native-endian int signatureLength, native-endian int pubkeyLength,\n+     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n+     * @returns 1 for valid signature, anything else for invalid\n+     */\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+}"
      },
      {
        "sha": "bb4cd707280a68f1377e90f7a9d434e194bfa6db",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,23 @@\n+#include \"org_bitcoin_NativeSecp256k1.h\"\n+#include \"include/secp256k1.h\"\n+\n+JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+{\n+\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\tint sigLen = *((int*)(data + 32));\n+\tint pubLen = *((int*)(data + 32 + 4));\n+\n+\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n+}\n+\n+static void __javasecp256k1_attach(void) __attribute__((constructor));\n+static void __javasecp256k1_detach(void) __attribute__((destructor));\n+\n+static void __javasecp256k1_attach(void) {\n+\tsecp256k1_start(SECP256K1_START_VERIFY);\n+}\n+\n+static void __javasecp256k1_detach(void) {\n+\tsecp256k1_stop();\n+}"
      },
      {
        "sha": "d7fb004fa841ede0fb2e919aa567d092e8fc2d5a",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,21 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+/* Header for class org_bitcoin_NativeSecp256k1 */\n+\n+#ifndef _Included_org_bitcoin_NativeSecp256k1\n+#define _Included_org_bitcoin_NativeSecp256k1\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_verify\n+ * Signature: (Ljava/nio/ByteBuffer;)I\n+ */\n+JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "73176d91cbe91ab740a69807101f066178c1eb6e",
        "filename": "src/num.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_\n+#define _SECP256K1_NUM_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_NUM_GMP)\n+#include \"num_gmp.h\"\n+#else\n+#error \"Please select num implementation\"\n+#endif\n+\n+/** Clear a number to prevent the leak of sensitive data. */\n+void static secp256k1_num_clear(secp256k1_num_t *r);\n+\n+/** Copy a number. */\n+void static secp256k1_num_copy(secp256k1_num_t *r, const secp256k1_num_t *a);\n+\n+/** Convert a number's absolute value to a binary big-endian string.\n+ *  There must be enough place. */\n+void static secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num_t *a);\n+\n+/** Set a number to the value of a binary big-endian string. */\n+void static secp256k1_num_set_bin(secp256k1_num_t *r, const unsigned char *a, unsigned int alen);\n+\n+/** Set a number equal to a (signed) integer. */\n+void static secp256k1_num_set_int(secp256k1_num_t *r, int a);\n+\n+/** Compute a modular inverse. The input must be less than the modulus. */\n+void static secp256k1_num_mod_inverse(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *m);\n+\n+/** Multiply two numbers modulo another. */\n+void static secp256k1_num_mod_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b, const secp256k1_num_t *m);\n+\n+/** Compare the absolute value of two numbers. */\n+int  static secp256k1_num_cmp(const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Test whether two number are equal (including sign). */\n+int  static secp256k1_num_eq(const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Add two (signed) numbers. */\n+void static secp256k1_num_add(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Subtract two (signed) numbers. */\n+void static secp256k1_num_sub(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Multiply two (signed) numbers. */\n+void static secp256k1_num_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Divide two (signed) numbers. */\n+void static secp256k1_num_div(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Replace a number by its remainder modulo m. M's sign is ignored. The result is a number between 0 and m-1,\n+    even if r was negative. */\n+void static secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m);\n+\n+/** Calculate the number of bits in (the absolute value of) a number. */\n+int  static secp256k1_num_bits(const secp256k1_num_t *a);\n+\n+/** Right-shift the passed number by bits bits, and return those bits. */\n+int  static secp256k1_num_shift(secp256k1_num_t *r, int bits);\n+\n+/** Check whether a number is zero. */\n+int  static secp256k1_num_is_zero(const secp256k1_num_t *a);\n+\n+/** Check whether a number is odd. */\n+int  static secp256k1_num_is_odd(const secp256k1_num_t *a);\n+\n+/** Check whether a number is strictly negative. */\n+int  static secp256k1_num_is_neg(const secp256k1_num_t *a);\n+\n+/** Check whether a particular bit is set in a number. */\n+int  static secp256k1_num_get_bit(const secp256k1_num_t *a, int pos);\n+\n+/** Increase a number by 1. */\n+void static secp256k1_num_inc(secp256k1_num_t *r);\n+\n+/** Set a number equal to the value of a hex string (unsigned). */\n+void static secp256k1_num_set_hex(secp256k1_num_t *r, const char *a, int alen);\n+\n+/** Convert (the absolute value of) a number to a hexadecimal string. */\n+void static secp256k1_num_get_hex(char *r, int rlen, const secp256k1_num_t *a);\n+\n+/** Split a number into a low and high part. */\n+void static secp256k1_num_split(secp256k1_num_t *rl, secp256k1_num_t *rh, const secp256k1_num_t *a, int bits);\n+\n+/** Change a number's sign. */\n+void static secp256k1_num_negate(secp256k1_num_t *r);\n+\n+/** Get a bunch of bits from a number. */\n+int  static secp256k1_num_get_bits(const secp256k1_num_t *a, int offset, int count);\n+\n+#endif"
      },
      {
        "sha": "960df860544182f7567405e8e0166341f6b6adb2",
        "filename": "src/num_gmp.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num_gmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num_gmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_REPR_\n+#define _SECP256K1_NUM_REPR_\n+\n+#include <gmp.h>\n+\n+#define NUM_LIMBS ((256+GMP_NUMB_BITS-1)/GMP_NUMB_BITS)\n+\n+typedef struct {\n+    mp_limb_t data[2*NUM_LIMBS];\n+    int neg;\n+    int limbs;\n+} secp256k1_num_t;\n+\n+#endif"
      },
      {
        "sha": "d8442ee03e0902a87cfa534b7a994c983db21f81",
        "filename": "src/num_gmp_impl.h",
        "status": "added",
        "additions": 374,
        "deletions": 0,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,374 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_REPR_IMPL_H_\n+#define _SECP256K1_NUM_REPR_IMPL_H_\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <gmp.h>\n+\n+#include \"util.h\"\n+#include \"num.h\"\n+\n+#ifdef VERIFY\n+void static secp256k1_num_sanity(const secp256k1_num_t *a) {\n+    VERIFY_CHECK(a->limbs == 1 || (a->limbs > 1 && a->data[a->limbs-1] != 0));\n+}\n+#else\n+#define secp256k1_num_sanity(a) do { } while(0)\n+#endif\n+\n+void static secp256k1_num_init(secp256k1_num_t *r) {\n+    r->neg = 0;\n+    r->limbs = 1;\n+    r->data[0] = 0;\n+}\n+\n+void static secp256k1_num_clear(secp256k1_num_t *r) {\n+    memset(r, 0, sizeof(*r));\n+}\n+\n+void static secp256k1_num_free(secp256k1_num_t *r) {\n+}\n+\n+void static secp256k1_num_copy(secp256k1_num_t *r, const secp256k1_num_t *a) {\n+    *r = *a;\n+}\n+\n+int static secp256k1_num_bits(const secp256k1_num_t *a) {\n+    int ret=(a->limbs-1)*GMP_NUMB_BITS;\n+    mp_limb_t x=a->data[a->limbs-1];\n+    while (x) {\n+        x >>= 1;\n+        ret++;\n+    }\n+    return ret;\n+}\n+\n+\n+void static secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num_t *a) {\n+    unsigned char tmp[65];\n+    int len = 0;\n+    if (a->limbs>1 || a->data[0] != 0) {\n+        len = mpn_get_str(tmp, 256, (mp_limb_t*)a->data, a->limbs);\n+    }\n+    int shift = 0;\n+    while (shift < len && tmp[shift] == 0) shift++;\n+    VERIFY_CHECK(len-shift <= rlen);\n+    memset(r, 0, rlen - len + shift);\n+    if (len > shift) {\n+        memcpy(r + rlen - len + shift, tmp + shift, len - shift);\n+    }\n+    memset(tmp, 0, sizeof(tmp));\n+}\n+\n+void static secp256k1_num_set_bin(secp256k1_num_t *r, const unsigned char *a, unsigned int alen) {\n+    VERIFY_CHECK(alen > 0);\n+    VERIFY_CHECK(alen <= 64);\n+    int len = mpn_set_str(r->data, a, alen, 256);\n+    VERIFY_CHECK(len <= NUM_LIMBS*2);\n+    r->limbs = len;\n+    r->neg = 0;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+}\n+\n+void static secp256k1_num_set_int(secp256k1_num_t *r, int a) {\n+    r->limbs = 1;\n+    r->neg = (a < 0);\n+    r->data[0] = (a < 0) ? -a : a;\n+}\n+\n+void static secp256k1_num_add_abs(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    mp_limb_t c = mpn_add(r->data, a->data, a->limbs, b->data, b->limbs);\n+    r->limbs = a->limbs;\n+    if (c != 0) {\n+        VERIFY_CHECK(r->limbs < 2*NUM_LIMBS);\n+        r->data[r->limbs++] = c;\n+    }\n+}\n+\n+void static secp256k1_num_sub_abs(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    mp_limb_t c = mpn_sub(r->data, a->data, a->limbs, b->data, b->limbs);\n+    VERIFY_CHECK(c == 0);\n+    r->limbs = a->limbs;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+}\n+\n+void static secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m) {\n+    secp256k1_num_sanity(r);\n+    secp256k1_num_sanity(m);\n+\n+    if (r->limbs >= m->limbs) {\n+        mp_limb_t t[2*NUM_LIMBS];\n+        mpn_tdiv_qr(t, r->data, 0, r->data, r->limbs, m->data, m->limbs);\n+        memset(t, 0, sizeof(t));\n+        r->limbs = m->limbs;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    }\n+\n+    if (r->neg && (r->limbs > 1 || r->data[0] != 0)) {\n+        secp256k1_num_sub_abs(r, m, r);\n+        r->neg = 0;\n+    }\n+}\n+\n+void static secp256k1_num_mod_inverse(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *m) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(m);\n+\n+    // mpn_gcdext computes: (G,S) = gcdext(U,V), where\n+    // * G = gcd(U,V)\n+    // * G = U*S + V*T\n+    // * U has equal or more limbs than V, and V has no padding\n+    // If we set U to be (a padded version of) a, and V = m:\n+    //   G = a*S + m*T\n+    //   G = a*S mod m\n+    // Assuming G=1:\n+    //   S = 1/a mod m\n+    VERIFY_CHECK(m->limbs <= NUM_LIMBS);\n+    VERIFY_CHECK(m->data[m->limbs-1] != 0);\n+    mp_limb_t g[NUM_LIMBS+1];\n+    mp_limb_t u[NUM_LIMBS+1];\n+    mp_limb_t v[NUM_LIMBS+1];\n+    for (int i=0; i < m->limbs; i++) {\n+        u[i] = (i < a->limbs) ? a->data[i] : 0;\n+        v[i] = m->data[i];\n+    }\n+    mp_size_t sn = NUM_LIMBS+1;\n+    mp_size_t gn = mpn_gcdext(g, r->data, &sn, u, m->limbs, v, m->limbs);\n+    VERIFY_CHECK(gn == 1);\n+    VERIFY_CHECK(g[0] == 1);\n+    r->neg = a->neg ^ m->neg;\n+    if (sn < 0) {\n+        mpn_sub(r->data, m->data, m->limbs, r->data, -sn);\n+        r->limbs = m->limbs;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    } else {\n+        r->limbs = sn;\n+    }\n+    memset(g, 0, sizeof(g));\n+    memset(u, 0, sizeof(u));\n+    memset(v, 0, sizeof(v));\n+}\n+\n+int static secp256k1_num_is_zero(const secp256k1_num_t *a) {\n+    return (a->limbs == 1 && a->data[0] == 0);\n+}\n+\n+int static secp256k1_num_is_odd(const secp256k1_num_t *a) {\n+    return a->data[0] & 1;\n+}\n+\n+int static secp256k1_num_is_neg(const secp256k1_num_t *a) {\n+    return (a->limbs > 1 || a->data[0] != 0) && a->neg;\n+}\n+\n+int static secp256k1_num_cmp(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    if (a->limbs > b->limbs) return 1;\n+    if (a->limbs < b->limbs) return -1;\n+    return mpn_cmp(a->data, b->data, a->limbs);\n+}\n+\n+int static secp256k1_num_eq(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    if (a->limbs > b->limbs) return 0;\n+    if (a->limbs < b->limbs) return 0;\n+    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) return 0;\n+    return mpn_cmp(a->data, b->data, a->limbs) == 0;\n+}\n+\n+void static secp256k1_num_subadd(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b, int bneg) {\n+    if (!(b->neg ^ bneg ^ a->neg)) { // a and b have the same sign\n+        r->neg = a->neg;\n+        if (a->limbs >= b->limbs) {\n+            secp256k1_num_add_abs(r, a, b);\n+        } else {\n+            secp256k1_num_add_abs(r, b, a);\n+        }\n+    } else {\n+        if (secp256k1_num_cmp(a, b) > 0) {\n+            r->neg = a->neg;\n+            secp256k1_num_sub_abs(r, a, b);\n+        } else {\n+            r->neg = b->neg ^ bneg;\n+            secp256k1_num_sub_abs(r, b, a);\n+        }\n+    }\n+}\n+\n+void static secp256k1_num_add(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    secp256k1_num_subadd(r, a, b, 0);\n+}\n+\n+void static secp256k1_num_sub(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    secp256k1_num_subadd(r, a, b, 1);\n+}\n+\n+void static secp256k1_num_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+\n+    mp_limb_t tmp[2*NUM_LIMBS+1];\n+    VERIFY_CHECK(a->limbs + b->limbs <= 2*NUM_LIMBS+1);\n+    if ((a->limbs==1 && a->data[0]==0) || (b->limbs==1 && b->data[0]==0)) {\n+        r->limbs = 1;\n+        r->neg = 0;\n+        r->data[0] = 0;\n+        return;\n+    }\n+    if (a->limbs >= b->limbs)\n+        mpn_mul(tmp, a->data, a->limbs, b->data, b->limbs);\n+    else\n+        mpn_mul(tmp, b->data, b->limbs, a->data, a->limbs);\n+    r->limbs = a->limbs + b->limbs;\n+    if (r->limbs > 1 && tmp[r->limbs - 1]==0) r->limbs--;\n+    VERIFY_CHECK(r->limbs <= 2*NUM_LIMBS);\n+    mpn_copyi(r->data, tmp, r->limbs);\n+    r->neg = a->neg ^ b->neg;\n+    memset(tmp, 0, sizeof(tmp));\n+}\n+\n+void static secp256k1_num_div(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    if (b->limbs > a->limbs) {\n+        r->limbs = 1;\n+        r->data[0] = 0;\n+        r->neg = 0;\n+        return;\n+    }\n+\n+    mp_limb_t quo[2*NUM_LIMBS+1];\n+    mp_limb_t rem[2*NUM_LIMBS+1];\n+    mpn_tdiv_qr(quo, rem, 0, a->data, a->limbs, b->data, b->limbs);\n+    mpn_copyi(r->data, quo, a->limbs - b->limbs + 1);\n+    r->limbs = a->limbs - b->limbs + 1;\n+    while (r->limbs > 1 && r->data[r->limbs - 1]==0) r->limbs--;\n+    r->neg = a->neg ^ b->neg;\n+}\n+\n+void static secp256k1_num_mod_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b, const secp256k1_num_t *m) {\n+    secp256k1_num_mul(r, a, b);\n+    secp256k1_num_mod(r, m);\n+}\n+\n+\n+int static secp256k1_num_shift(secp256k1_num_t *r, int bits) {\n+    VERIFY_CHECK(bits <= GMP_NUMB_BITS);\n+    mp_limb_t ret = mpn_rshift(r->data, r->data, r->limbs, bits);\n+    if (r->limbs>1 && r->data[r->limbs-1]==0) r->limbs--;\n+    ret >>= (GMP_NUMB_BITS - bits);\n+    return ret;\n+}\n+\n+int static secp256k1_num_get_bit(const secp256k1_num_t *a, int pos) {\n+    return (a->limbs*GMP_NUMB_BITS > pos) && ((a->data[pos/GMP_NUMB_BITS] >> (pos % GMP_NUMB_BITS)) & 1);\n+}\n+\n+void static secp256k1_num_inc(secp256k1_num_t *r) {\n+    mp_limb_t ret = mpn_add_1(r->data, r->data, r->limbs, (mp_limb_t)1);\n+    if (ret) {\n+        VERIFY_CHECK(r->limbs < 2*NUM_LIMBS);\n+        r->data[r->limbs++] = ret;\n+    }\n+}\n+\n+void static secp256k1_num_set_hex(secp256k1_num_t *r, const char *a, int alen) {\n+    static const unsigned char cvt[256] = {\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 1, 2, 3, 4, 5, 6,7,8,9,0,0,0,0,0,0,\n+        0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0\n+    };\n+    unsigned char num[257] = {};\n+    for (int i=0; i<alen; i++) {\n+        num[i] = cvt[(unsigned char)a[i]];\n+    }\n+    r->limbs = mpn_set_str(r->data, num, alen, 16);\n+    r->neg = 0;\n+    while (r->limbs > 1 && r->data[r->limbs-1] == 0) r->limbs--;\n+}\n+\n+void static secp256k1_num_get_hex(char *r, int rlen, const secp256k1_num_t *a) {\n+    static const unsigned char cvt[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+    unsigned char *tmp = malloc(257);\n+    mp_size_t len = mpn_get_str(tmp, 16, (mp_limb_t*)a->data, a->limbs);\n+    VERIFY_CHECK(len <= rlen);\n+    for (int i=0; i<len; i++) {\n+        VERIFY_CHECK(rlen-len+i >= 0);\n+        VERIFY_CHECK(rlen-len+i < rlen);\n+        VERIFY_CHECK(tmp[i] >= 0);\n+        VERIFY_CHECK(tmp[i] < 16);\n+        r[rlen-len+i] = cvt[tmp[i]];\n+    }\n+    for (int i=0; i<rlen-len; i++) {\n+        VERIFY_CHECK(i >= 0);\n+        VERIFY_CHECK(i < rlen);\n+        r[i] = cvt[0];\n+    }\n+    free(tmp);\n+}\n+\n+void static secp256k1_num_split(secp256k1_num_t *rl, secp256k1_num_t *rh, const secp256k1_num_t *a, int bits) {\n+    VERIFY_CHECK(bits > 0);\n+    rh->neg = a->neg;\n+    if (bits >= a->limbs * GMP_NUMB_BITS) {\n+        *rl = *a;\n+        rh->limbs = 1;\n+        rh->data[0] = 0;\n+        return;\n+    }\n+    rl->limbs = 0;\n+    rl->neg = a->neg;\n+    int left = bits;\n+    while (left >= GMP_NUMB_BITS) {\n+        rl->data[rl->limbs] = a->data[rl->limbs];\n+        rl->limbs++;\n+        left -= GMP_NUMB_BITS;\n+    }\n+    if (left == 0) {\n+        mpn_copyi(rh->data, a->data + rl->limbs, a->limbs - rl->limbs);\n+        rh->limbs = a->limbs - rl->limbs;\n+    } else {\n+        mpn_rshift(rh->data, a->data + rl->limbs, a->limbs - rl->limbs, left);\n+        rh->limbs = a->limbs - rl->limbs;\n+        while (rh->limbs>1 && rh->data[rh->limbs-1]==0) rh->limbs--;\n+    }\n+    if (left > 0) {\n+        rl->data[rl->limbs] = a->data[rl->limbs] & ((((mp_limb_t)1) << left) - 1);\n+        rl->limbs++;\n+    }\n+    while (rl->limbs>1 && rl->data[rl->limbs-1]==0) rl->limbs--;\n+}\n+\n+void static secp256k1_num_negate(secp256k1_num_t *r) {\n+    r->neg ^= 1;\n+}\n+\n+int static secp256k1_num_get_bits(const secp256k1_num_t *a, int offset, int count) {\n+    int ret = 0;\n+    for (int i = 0; i < count; i++) {\n+        ret |= ((a->data[(offset + i) / GMP_NUMB_BITS] >> ((offset + i) % GMP_NUMB_BITS)) & 1) << i;\n+    }\n+    return ret;\n+}\n+\n+#endif"
      },
      {
        "sha": "a6644fda703ac0e0d32d71baf4a7d714362c4cde",
        "filename": "src/num_impl.h",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/num_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_IMPL_H_\n+#define _SECP256K1_NUM_IMPL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"num.h\"\n+\n+#if defined(USE_NUM_GMP)\n+#include \"num_gmp_impl.h\"\n+#else\n+#error \"Please select num implementation\"\n+#endif\n+\n+#endif"
      },
      {
        "sha": "2579db12b26df0d31e3014c94bbdcfba983aef57",
        "filename": "src/scalar.h",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,61 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_\n+#define _SECP256K1_SCALAR_\n+\n+#include \"num.h\"\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_SCALAR_4X64)\n+#include \"scalar_4x64.h\"\n+#elif defined(USE_SCALAR_8X32)\n+#include \"scalar_8x32.h\"\n+#else\n+#error \"Please select scalar implementation\"\n+#endif\n+\n+/** Clear a scalar to prevent the leak of sensitive data. */\n+void static secp256k1_scalar_clear(secp256k1_scalar_t *r);\n+\n+/** Access bits from a scalar. */\n+int static secp256k1_scalar_get_bits(const secp256k1_scalar_t *a, int offset, int count);\n+\n+/** Set a scalar from a big endian byte array. */\n+void static secp256k1_scalar_set_b32(secp256k1_scalar_t *r, const unsigned char *bin, int *overflow);\n+\n+/** Convert a scalar to a byte array. */\n+void static secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar_t* a);\n+\n+/** Add two scalars together (modulo the group order). */\n+void static secp256k1_scalar_add(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b);\n+\n+/** Multiply two scalars (modulo the group order). */\n+void static secp256k1_scalar_mul(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b);\n+\n+/** Compute the square of a scalar (modulo the group order). */\n+void static secp256k1_scalar_sqr(secp256k1_scalar_t *r, const secp256k1_scalar_t *a);\n+\n+/** Compute the inverse of a scalar (modulo the group order). */\n+void static secp256k1_scalar_inverse(secp256k1_scalar_t *r, const secp256k1_scalar_t *a);\n+\n+/** Compute the complement of a scalar (modulo the group order). */\n+void static secp256k1_scalar_negate(secp256k1_scalar_t *r, const secp256k1_scalar_t *a);\n+\n+/** Check whether a scalar equals zero. */\n+int static secp256k1_scalar_is_zero(const secp256k1_scalar_t *a);\n+\n+/** Check whether a scalar equals one. */\n+int static secp256k1_scalar_is_one(const secp256k1_scalar_t *a);\n+\n+/** Check whether a scalar is higher than the group order divided by 2. */\n+int static secp256k1_scalar_is_high(const secp256k1_scalar_t *a);\n+\n+/** Convert a scalar to a number. */\n+void static secp256k1_scalar_get_num(secp256k1_num_t *r, const secp256k1_scalar_t *a);\n+\n+#endif"
      },
      {
        "sha": "22ebe4fbba6cae37c296e7893687b690dd476071",
        "filename": "src/scalar_4x64.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_4x64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_4x64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef struct {\n+    uint64_t d[4];\n+} secp256k1_scalar_t;\n+\n+#endif"
      },
      {
        "sha": "66f17a2e23d17fd7e791470081515353c46b863f",
        "filename": "src/scalar_4x64_impl.h",
        "status": "added",
        "additions": 357,
        "deletions": 0,
        "changes": 357,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,357 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+typedef unsigned __int128 uint128_t;\n+\n+// Limbs of the secp256k1 order.\n+#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)\n+#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)\n+#define SECP256K1_N_2 ((uint64_t)0xFFFFFFFFFFFFFFFEULL)\n+#define SECP256K1_N_3 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)\n+\n+// Limbs of 2^256 minus the secp256k1 order.\n+#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)\n+#define SECP256K1_N_C_1 (~SECP256K1_N_1)\n+#define SECP256K1_N_C_2 (1)\n+\n+// Limbs of half the secp256k1 order.\n+#define SECP256K1_N_H_0 ((uint64_t)0xDFE92F46681B20A0ULL)\n+#define SECP256K1_N_H_1 ((uint64_t)0x5D576E7357A4501DULL)\n+#define SECP256K1_N_H_2 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)\n+#define SECP256K1_N_H_3 ((uint64_t)0x7FFFFFFFFFFFFFFFULL)\n+\n+void static inline secp256k1_scalar_clear(secp256k1_scalar_t *r) {\n+    r->d[0] = 0;\n+    r->d[1] = 0;\n+    r->d[2] = 0;\n+    r->d[3] = 0;\n+}\n+\n+int static inline secp256k1_scalar_get_bits(const secp256k1_scalar_t *a, int offset, int count) {\n+    VERIFY_CHECK((offset + count - 1) / 64 == offset / 64);\n+    return (a->d[offset / 64] >> (offset % 64)) & ((((uint64_t)1) << count) - 1);\n+}\n+\n+int static inline secp256k1_scalar_check_overflow(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[3] < SECP256K1_N_3); // No need for a > check.\n+    no |= (a->d[2] < SECP256K1_N_2);\n+    yes |= (a->d[2] > SECP256K1_N_2) & ~no;\n+    no |= (a->d[1] < SECP256K1_N_1);\n+    yes |= (a->d[1] > SECP256K1_N_1) & ~no;\n+    yes |= (a->d[0] >= SECP256K1_N_0) & ~no;\n+    return yes;\n+}\n+\n+int static inline secp256k1_scalar_reduce(secp256k1_scalar_t *r, unsigned int overflow) {\n+    VERIFY_CHECK(overflow <= 1);\n+    uint128_t t = (uint128_t)r->d[0] + overflow * SECP256K1_N_C_0;\n+    r->d[0] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)r->d[1] + overflow * SECP256K1_N_C_1;\n+    r->d[1] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)r->d[2] + overflow * SECP256K1_N_C_2;\n+    r->d[2] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint64_t)r->d[3];\n+    r->d[3] = t & 0xFFFFFFFFFFFFFFFFULL;\n+    return overflow;\n+}\n+\n+void static secp256k1_scalar_add(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    uint128_t t = (uint128_t)a->d[0] + b->d[0];\n+    r->d[0] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)a->d[1] + b->d[1];\n+    r->d[1] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)a->d[2] + b->d[2];\n+    r->d[2] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)a->d[3] + b->d[3];\n+    r->d[3] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    secp256k1_scalar_reduce(r, t + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_set_b32(secp256k1_scalar_t *r, const unsigned char *b32, int *overflow) {\n+    r->d[0] = (uint64_t)b32[31] | (uint64_t)b32[30] << 8 | (uint64_t)b32[29] << 16 | (uint64_t)b32[28] << 24 | (uint64_t)b32[27] << 32 | (uint64_t)b32[26] << 40 | (uint64_t)b32[25] << 48 | (uint64_t)b32[24] << 56;\n+    r->d[1] = (uint64_t)b32[23] | (uint64_t)b32[22] << 8 | (uint64_t)b32[21] << 16 | (uint64_t)b32[20] << 24 | (uint64_t)b32[19] << 32 | (uint64_t)b32[18] << 40 | (uint64_t)b32[17] << 48 | (uint64_t)b32[16] << 56;\n+    r->d[2] = (uint64_t)b32[15] | (uint64_t)b32[14] << 8 | (uint64_t)b32[13] << 16 | (uint64_t)b32[12] << 24 | (uint64_t)b32[11] << 32 | (uint64_t)b32[10] << 40 | (uint64_t)b32[9] << 48 | (uint64_t)b32[8] << 56;\n+    r->d[3] = (uint64_t)b32[7] | (uint64_t)b32[6] << 8 | (uint64_t)b32[5] << 16 | (uint64_t)b32[4] << 24 | (uint64_t)b32[3] << 32 | (uint64_t)b32[2] << 40 | (uint64_t)b32[1] << 48 | (uint64_t)b32[0] << 56;\n+    int over = secp256k1_scalar_reduce(r, secp256k1_scalar_check_overflow(r));\n+    if (overflow) {\n+        *overflow = over;\n+    }\n+}\n+\n+void static secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar_t* a) {\n+    bin[0] = a->d[3] >> 56; bin[1] = a->d[3] >> 48; bin[2] = a->d[3] >> 40; bin[3] = a->d[3] >> 32; bin[4] = a->d[3] >> 24; bin[5] = a->d[3] >> 16; bin[6] = a->d[3] >> 8; bin[7] = a->d[3];\n+    bin[8] = a->d[2] >> 56; bin[9] = a->d[2] >> 48; bin[10] = a->d[2] >> 40; bin[11] = a->d[2] >> 32; bin[12] = a->d[2] >> 24; bin[13] = a->d[2] >> 16; bin[14] = a->d[2] >> 8; bin[15] = a->d[2];\n+    bin[16] = a->d[1] >> 56; bin[17] = a->d[1] >> 48; bin[18] = a->d[1] >> 40; bin[19] = a->d[1] >> 32; bin[20] = a->d[1] >> 24; bin[21] = a->d[1] >> 16; bin[22] = a->d[1] >> 8; bin[23] = a->d[1];\n+    bin[24] = a->d[0] >> 56; bin[25] = a->d[0] >> 48; bin[26] = a->d[0] >> 40; bin[27] = a->d[0] >> 32; bin[28] = a->d[0] >> 24; bin[29] = a->d[0] >> 16; bin[30] = a->d[0] >> 8; bin[31] = a->d[0];\n+}\n+\n+int static inline secp256k1_scalar_is_zero(const secp256k1_scalar_t *a) {\n+    return (a->d[0] | a->d[1] | a->d[2] | a->d[3]) == 0;\n+}\n+\n+void static secp256k1_scalar_negate(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    uint64_t nonzero = 0xFFFFFFFFFFFFFFFFULL * (secp256k1_scalar_is_zero(a) == 0);\n+    uint128_t t = (uint128_t)(~a->d[0]) + SECP256K1_N_0 + 1;\n+    r->d[0] = t & nonzero; t >>= 64;\n+    t += (uint128_t)(~a->d[1]) + SECP256K1_N_1;\n+    r->d[1] = t & nonzero; t >>= 64;\n+    t += (uint128_t)(~a->d[2]) + SECP256K1_N_2;\n+    r->d[2] = t & nonzero; t >>= 64;\n+    t += (uint128_t)(~a->d[3]) + SECP256K1_N_3;\n+    r->d[3] = t & nonzero;\n+}\n+\n+int static inline secp256k1_scalar_is_one(const secp256k1_scalar_t *a) {\n+    return ((a->d[0] ^ 1) | a->d[1] | a->d[2] | a->d[3]) == 0;\n+}\n+\n+int static secp256k1_scalar_is_high(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[3] < SECP256K1_N_H_3);\n+    yes |= (a->d[3] > SECP256K1_N_H_3) & ~no;\n+    no |= (a->d[2] < SECP256K1_N_H_2) & ~yes; // No need for a > check.\n+    no |= (a->d[1] < SECP256K1_N_H_1) & ~yes;\n+    yes |= (a->d[1] > SECP256K1_N_H_1) & ~no;\n+    yes |= (a->d[0] > SECP256K1_N_H_0) & ~no;\n+    return yes;\n+}\n+\n+// Inspired by the macros in OpenSSL's crypto/bn/asm/x86_64-gcc.c.\n+\n+/** Add a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd(a,b) { \\\n+    uint64_t tl, th; \\\n+    { \\\n+        uint128_t t = (uint128_t)a * b; \\\n+        th = t >> 64;         /* at most 0xFFFFFFFFFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    c1 += th;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n+}\n+\n+/** Add a*b to the number defined by (c0,c1). c1 must never overflow. */\n+#define muladd_fast(a,b) { \\\n+    uint64_t tl, th; \\\n+    { \\\n+        uint128_t t = (uint128_t)a * b; \\\n+        th = t >> 64;         /* at most 0xFFFFFFFFFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK(c1 >= th); \\\n+}\n+\n+/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd2(a,b) { \\\n+    uint64_t tl, th; \\\n+    { \\\n+        uint128_t t = (uint128_t)a * b; \\\n+        th = t >> 64;               /* at most 0xFFFFFFFFFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    uint64_t th2 = th + th;         /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n+    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n+    uint64_t tl2 = tl + tl;         /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n+    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    c0 += tl2;                      /* overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n+    c1 += th2;                      /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n+}\n+\n+/** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define sumadd(a) { \\\n+    c0 += (a);                  /* overflow is handled on the next line */ \\\n+    int over = (c0 < (a)) ? 1 : 0; \\\n+    c1 += over;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+}\n+\n+/** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n+#define sumadd_fast(a) { \\\n+    c0 += (a);                 /* overflow is handled on the next line */ \\\n+    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+/** Extract the lowest 64 bits of (c0,c1,c2) into n, and left shift the number 64 bits. */\n+#define extract(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = c2; \\\n+    c2 = 0; \\\n+}\n+\n+/** Extract the lowest 64 bits of (c0,c1,c2) into n, and left shift the number 64 bits. c2 is required to be zero. */\n+#define extract_fast(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = 0; \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+void static secp256k1_scalar_reduce_512(secp256k1_scalar_t *r, const uint64_t *l) {\n+    uint64_t n0 = l[4], n1 = l[5], n2 = l[6], n3 = l[7];\n+\n+    // 160 bit accumulator.\n+    uint64_t c0, c1;\n+    uint32_t c2;\n+\n+    // Reduce 512 bits into 385.\n+    // m[0..6] = l[0..3] + n[0..3] * SECP256K1_N_C.\n+    c0 = l[0]; c1 = 0; c2 = 0;\n+    muladd_fast(n0, SECP256K1_N_C_0);\n+    uint64_t m0; extract_fast(m0);\n+    sumadd_fast(l[1]);\n+    muladd(n1, SECP256K1_N_C_0);\n+    muladd(n0, SECP256K1_N_C_1);\n+    uint64_t m1; extract(m1);\n+    sumadd(l[2]);\n+    muladd(n2, SECP256K1_N_C_0);\n+    muladd(n1, SECP256K1_N_C_1);\n+    sumadd(n0);\n+    uint64_t m2; extract(m2);\n+    sumadd(l[3]);\n+    muladd(n3, SECP256K1_N_C_0);\n+    muladd(n2, SECP256K1_N_C_1);\n+    sumadd(n1);\n+    uint64_t m3; extract(m3);\n+    muladd(n3, SECP256K1_N_C_1);\n+    sumadd(n2);\n+    uint64_t m4; extract(m4);\n+    sumadd_fast(n3);\n+    uint64_t m5; extract_fast(m5);\n+    VERIFY_CHECK(c0 <= 1);\n+    uint32_t m6 = c0;\n+\n+    // Reduce 385 bits into 258.\n+    // p[0..4] = m[0..3] + m[4..6] * SECP256K1_N_C.\n+    c0 = m0; c1 = 0; c2 = 0;\n+    muladd_fast(m4, SECP256K1_N_C_0);\n+    uint64_t p0; extract_fast(p0);\n+    sumadd_fast(m1);\n+    muladd(m5, SECP256K1_N_C_0);\n+    muladd(m4, SECP256K1_N_C_1);\n+    uint64_t p1; extract(p1);\n+    sumadd(m2);\n+    muladd(m6, SECP256K1_N_C_0);\n+    muladd(m5, SECP256K1_N_C_1);\n+    sumadd(m4);\n+    uint64_t p2; extract(p2);\n+    sumadd_fast(m3);\n+    muladd_fast(m6, SECP256K1_N_C_1);\n+    sumadd_fast(m5);\n+    uint64_t p3; extract_fast(p3);\n+    uint32_t p4 = c0 + m6;\n+    VERIFY_CHECK(p4 <= 2);\n+\n+    // Reduce 258 bits into 256.\n+    // r[0..3] = p[0..3] + p[4] * SECP256K1_N_C.\n+    uint128_t c = p0 + (uint128_t)SECP256K1_N_C_0 * p4;\n+    r->d[0] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+    c += p1 + (uint128_t)SECP256K1_N_C_1 * p4;\n+    r->d[1] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+    c += p2 + (uint128_t)p4;\n+    r->d[2] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+    c += p3;\n+    r->d[3] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+\n+    // Final reduction of r.\n+    secp256k1_scalar_reduce(r, c + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_mul(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    // 160 bit accumulator.\n+    uint64_t c0 = 0, c1 = 0;\n+    uint32_t c2 = 0;\n+\n+    uint64_t l[8];\n+\n+    // l[0..7] = a[0..3] * b[0..3].\n+    muladd_fast(a->d[0], b->d[0]);\n+    extract_fast(l[0]);\n+    muladd(a->d[0], b->d[1]);\n+    muladd(a->d[1], b->d[0]);\n+    extract(l[1]);\n+    muladd(a->d[0], b->d[2]);\n+    muladd(a->d[1], b->d[1]);\n+    muladd(a->d[2], b->d[0]);\n+    extract(l[2]);\n+    muladd(a->d[0], b->d[3]);\n+    muladd(a->d[1], b->d[2]);\n+    muladd(a->d[2], b->d[1]);\n+    muladd(a->d[3], b->d[0]);\n+    extract(l[3]);\n+    muladd(a->d[1], b->d[3]);\n+    muladd(a->d[2], b->d[2]);\n+    muladd(a->d[3], b->d[1]);\n+    extract(l[4]);\n+    muladd(a->d[2], b->d[3]);\n+    muladd(a->d[3], b->d[2]);\n+    extract(l[5]);\n+    muladd_fast(a->d[3], b->d[3]);\n+    extract_fast(l[6]);\n+    VERIFY_CHECK(c1 <= 0);\n+    l[7] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+void static secp256k1_scalar_sqr(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    // 160 bit accumulator.\n+    uint64_t c0 = 0, c1 = 0;\n+    uint32_t c2 = 0;\n+\n+    uint64_t l[8];\n+\n+    // l[0..7] = a[0..3] * b[0..3].\n+    muladd_fast(a->d[0], a->d[0]);\n+    extract_fast(l[0]);\n+    muladd2(a->d[0], a->d[1]);\n+    extract(l[1]);\n+    muladd2(a->d[0], a->d[2]);\n+    muladd(a->d[1], a->d[1]);\n+    extract(l[2]);\n+    muladd2(a->d[0], a->d[3]);\n+    muladd2(a->d[1], a->d[2]);\n+    extract(l[3]);\n+    muladd2(a->d[1], a->d[3]);\n+    muladd(a->d[2], a->d[2]);\n+    extract(l[4]);\n+    muladd2(a->d[2], a->d[3]);\n+    extract(l[5]);\n+    muladd_fast(a->d[3], a->d[3]);\n+    extract_fast(l[6]);\n+    VERIFY_CHECK(c1 == 0);\n+    l[7] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+#undef sumadd\n+#undef sumadd_fast\n+#undef muladd\n+#undef muladd_fast\n+#undef muladd2\n+#undef extract\n+#undef extract_fast\n+\n+#endif"
      },
      {
        "sha": "da7c63c7883634435a32f82b4e05286f0bd848da",
        "filename": "src/scalar_8x32.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_8x32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_8x32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef struct {\n+    uint32_t d[8];\n+} secp256k1_scalar_t;\n+\n+#endif"
      },
      {
        "sha": "3983edd27e04227f726f6df7e6711f36dd9fbe47",
        "filename": "src/scalar_8x32_impl.h",
        "status": "added",
        "additions": 570,
        "deletions": 0,
        "changes": 570,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,570 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+// Limbs of the secp256k1 order.\n+#define SECP256K1_N_0 ((uint32_t)0xD0364141UL)\n+#define SECP256K1_N_1 ((uint32_t)0xBFD25E8CUL)\n+#define SECP256K1_N_2 ((uint32_t)0xAF48A03BUL)\n+#define SECP256K1_N_3 ((uint32_t)0xBAAEDCE6UL)\n+#define SECP256K1_N_4 ((uint32_t)0xFFFFFFFEUL)\n+#define SECP256K1_N_5 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_6 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_7 ((uint32_t)0xFFFFFFFFUL)\n+\n+// Limbs of 2^256 minus the secp256k1 order.\n+#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)\n+#define SECP256K1_N_C_1 (~SECP256K1_N_1)\n+#define SECP256K1_N_C_2 (~SECP256K1_N_2)\n+#define SECP256K1_N_C_3 (~SECP256K1_N_3)\n+#define SECP256K1_N_C_4 (1)\n+\n+// Limbs of half the secp256k1 order.\n+#define SECP256K1_N_H_0 ((uint32_t)0x681B20A0UL)\n+#define SECP256K1_N_H_1 ((uint32_t)0xDFE92F46UL)\n+#define SECP256K1_N_H_2 ((uint32_t)0x57A4501DUL)\n+#define SECP256K1_N_H_3 ((uint32_t)0x5D576E73UL)\n+#define SECP256K1_N_H_4 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_H_5 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_H_6 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_H_7 ((uint32_t)0x7FFFFFFFUL)\n+\n+void static inline secp256k1_scalar_clear(secp256k1_scalar_t *r) {\n+    r->d[0] = 0;\n+    r->d[1] = 0;\n+    r->d[2] = 0;\n+    r->d[3] = 0;\n+    r->d[4] = 0;\n+    r->d[5] = 0;\n+    r->d[6] = 0;\n+    r->d[7] = 0;\n+}\n+\n+int static inline secp256k1_scalar_get_bits(const secp256k1_scalar_t *a, int offset, int count) {\n+    VERIFY_CHECK((offset + count - 1) / 32 == offset / 32);\n+    return (a->d[offset / 32] >> (offset % 32)) & ((1 << count) - 1);\n+}\n+\n+int static inline secp256k1_scalar_check_overflow(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[7] < SECP256K1_N_7); // No need for a > check.\n+    no |= (a->d[6] < SECP256K1_N_6); // No need for a > check.\n+    no |= (a->d[5] < SECP256K1_N_5); // No need for a > check.\n+    no |= (a->d[4] < SECP256K1_N_4);\n+    yes |= (a->d[4] > SECP256K1_N_4) & ~no;\n+    no |= (a->d[3] < SECP256K1_N_3) & ~yes;\n+    yes |= (a->d[3] > SECP256K1_N_3) & ~no;\n+    no |= (a->d[2] < SECP256K1_N_2) & ~yes;\n+    yes |= (a->d[2] > SECP256K1_N_2) & ~no;\n+    no |= (a->d[1] < SECP256K1_N_1) & ~yes;\n+    yes |= (a->d[1] > SECP256K1_N_1) & ~no;\n+    yes |= (a->d[0] >= SECP256K1_N_0) & ~no;\n+    return yes;\n+}\n+\n+int static inline secp256k1_scalar_reduce(secp256k1_scalar_t *r, uint32_t overflow) {\n+    VERIFY_CHECK(overflow <= 1);\n+    uint64_t t = (uint64_t)r->d[0] + overflow * SECP256K1_N_C_0;\n+    r->d[0] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[1] + overflow * SECP256K1_N_C_1;\n+    r->d[1] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[2] + overflow * SECP256K1_N_C_2;\n+    r->d[2] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[3] + overflow * SECP256K1_N_C_3;\n+    r->d[3] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[4] + overflow * SECP256K1_N_C_4;\n+    r->d[4] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[5];\n+    r->d[5] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[6];\n+    r->d[6] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[7];\n+    r->d[7] = t & 0xFFFFFFFFUL;\n+    return overflow;\n+}\n+\n+void static secp256k1_scalar_add(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    uint64_t t = (uint64_t)a->d[0] + b->d[0];\n+    r->d[0] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[1] + b->d[1];\n+    r->d[1] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[2] + b->d[2];\n+    r->d[2] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[3] + b->d[3];\n+    r->d[3] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[4] + b->d[4];\n+    r->d[4] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[5] + b->d[5];\n+    r->d[5] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[6] + b->d[6];\n+    r->d[6] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[7] + b->d[7];\n+    r->d[7] = t & 0xFFFFFFFFULL; t >>= 32;\n+    secp256k1_scalar_reduce(r, t + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_set_b32(secp256k1_scalar_t *r, const unsigned char *b32, int *overflow) {\n+    r->d[0] = (uint32_t)b32[31] | (uint32_t)b32[30] << 8 | (uint32_t)b32[29] << 16 | (uint32_t)b32[28] << 24;\n+    r->d[1] = (uint32_t)b32[27] | (uint32_t)b32[26] << 8 | (uint32_t)b32[25] << 16 | (uint32_t)b32[24] << 24;\n+    r->d[2] = (uint32_t)b32[23] | (uint32_t)b32[22] << 8 | (uint32_t)b32[21] << 16 | (uint32_t)b32[20] << 24;\n+    r->d[3] = (uint32_t)b32[19] | (uint32_t)b32[18] << 8 | (uint32_t)b32[17] << 16 | (uint32_t)b32[16] << 24;\n+    r->d[4] = (uint32_t)b32[15] | (uint32_t)b32[14] << 8 | (uint32_t)b32[13] << 16 | (uint32_t)b32[12] << 24;\n+    r->d[5] = (uint32_t)b32[11] | (uint32_t)b32[10] << 8 | (uint32_t)b32[9] << 16 | (uint32_t)b32[8] << 24;\n+    r->d[6] = (uint32_t)b32[7] | (uint32_t)b32[6] << 8 | (uint32_t)b32[5] << 16 | (uint32_t)b32[4] << 24;\n+    r->d[7] = (uint32_t)b32[3] | (uint32_t)b32[2] << 8 | (uint32_t)b32[1] << 16 | (uint32_t)b32[0] << 24;\n+    int over = secp256k1_scalar_reduce(r, secp256k1_scalar_check_overflow(r));\n+    if (overflow) {\n+        *overflow = over;\n+    }\n+}\n+\n+void static secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar_t* a) {\n+    bin[0] = a->d[7] >> 24; bin[1] = a->d[7] >> 16; bin[2] = a->d[7] >> 8; bin[3] = a->d[7];\n+    bin[4] = a->d[6] >> 24; bin[5] = a->d[6] >> 16; bin[6] = a->d[6] >> 8; bin[7] = a->d[6];\n+    bin[8] = a->d[5] >> 24; bin[9] = a->d[5] >> 16; bin[10] = a->d[5] >> 8; bin[11] = a->d[5];\n+    bin[12] = a->d[4] >> 24; bin[13] = a->d[4] >> 16; bin[14] = a->d[4] >> 8; bin[15] = a->d[4];\n+    bin[16] = a->d[3] >> 24; bin[17] = a->d[3] >> 16; bin[18] = a->d[3] >> 8; bin[19] = a->d[3];\n+    bin[20] = a->d[2] >> 24; bin[21] = a->d[2] >> 16; bin[22] = a->d[2] >> 8; bin[23] = a->d[2];\n+    bin[24] = a->d[1] >> 24; bin[25] = a->d[1] >> 16; bin[26] = a->d[1] >> 8; bin[27] = a->d[1];\n+    bin[28] = a->d[0] >> 24; bin[29] = a->d[0] >> 16; bin[30] = a->d[0] >> 8; bin[31] = a->d[0];\n+}\n+\n+int static inline secp256k1_scalar_is_zero(const secp256k1_scalar_t *a) {\n+    return (a->d[0] | a->d[1] | a->d[2] | a->d[3] | a->d[4] | a->d[5] | a->d[6] | a->d[7]) == 0;\n+}\n+\n+void static secp256k1_scalar_negate(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    uint32_t nonzero = 0xFFFFFFFFUL * (secp256k1_scalar_is_zero(a) == 0);\n+    uint64_t t = (uint64_t)(~a->d[0]) + SECP256K1_N_0 + 1;\n+    r->d[0] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[1]) + SECP256K1_N_1;\n+    r->d[1] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[2]) + SECP256K1_N_2;\n+    r->d[2] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[3]) + SECP256K1_N_3;\n+    r->d[3] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[4]) + SECP256K1_N_4;\n+    r->d[4] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[5]) + SECP256K1_N_5;\n+    r->d[5] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[6]) + SECP256K1_N_6;\n+    r->d[6] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[7]) + SECP256K1_N_7;\n+    r->d[7] = t & nonzero;\n+}\n+\n+int static inline secp256k1_scalar_is_one(const secp256k1_scalar_t *a) {\n+    return ((a->d[0] ^ 1) | a->d[1] | a->d[2] | a->d[3] | a->d[4] | a->d[5] | a->d[6] | a->d[7]) == 0;\n+}\n+\n+int static secp256k1_scalar_is_high(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[7] < SECP256K1_N_H_7);\n+    yes |= (a->d[7] > SECP256K1_N_H_7) & ~no;\n+    no |= (a->d[6] < SECP256K1_N_H_6) & ~yes; // No need for a > check.\n+    no |= (a->d[5] < SECP256K1_N_H_5) & ~yes; // No need for a > check.\n+    no |= (a->d[4] < SECP256K1_N_H_4) & ~yes; // No need for a > check.\n+    no |= (a->d[3] < SECP256K1_N_H_3) & ~yes;\n+    yes |= (a->d[3] > SECP256K1_N_H_3) & ~no;\n+    no |= (a->d[2] < SECP256K1_N_H_2) & ~yes;\n+    yes |= (a->d[2] > SECP256K1_N_H_2) & ~no;\n+    no |= (a->d[1] < SECP256K1_N_H_1) & ~yes;\n+    yes |= (a->d[1] > SECP256K1_N_H_1) & ~no;\n+    yes |= (a->d[0] > SECP256K1_N_H_0) & ~no;\n+    return yes;\n+}\n+\n+// Inspired by the macros in OpenSSL's crypto/bn/asm/x86_64-gcc.c.\n+\n+/** Add a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd(a,b) { \\\n+    uint32_t tl, th; \\\n+    { \\\n+        uint64_t t = (uint64_t)a * b; \\\n+        th = t >> 32;         /* at most 0xFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    c1 += th;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n+}\n+\n+/** Add a*b to the number defined by (c0,c1). c1 must never overflow. */\n+#define muladd_fast(a,b) { \\\n+    uint32_t tl, th; \\\n+    { \\\n+        uint64_t t = (uint64_t)a * b; \\\n+        th = t >> 32;         /* at most 0xFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK(c1 >= th); \\\n+}\n+\n+/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd2(a,b) { \\\n+    uint32_t tl, th; \\\n+    { \\\n+        uint64_t t = (uint64_t)a * b; \\\n+        th = t >> 32;               /* at most 0xFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    uint32_t th2 = th + th;         /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n+    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n+    uint32_t tl2 = tl + tl;         /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n+    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFF */ \\\n+    c0 += tl2;                      /* overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n+    c1 += th2;                      /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n+}\n+\n+/** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define sumadd(a) { \\\n+    c0 += (a);                  /* overflow is handled on the next line */ \\\n+    int over = (c0 < (a)) ? 1 : 0; \\\n+    c1 += over;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+}\n+\n+/** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n+#define sumadd_fast(a) { \\\n+    c0 += (a);                 /* overflow is handled on the next line */ \\\n+    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+/** Extract the lowest 32 bits of (c0,c1,c2) into n, and left shift the number 32 bits. */\n+#define extract(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = c2; \\\n+    c2 = 0; \\\n+}\n+\n+/** Extract the lowest 32 bits of (c0,c1,c2) into n, and left shift the number 32 bits. c2 is required to be zero. */\n+#define extract_fast(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = 0; \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+void static secp256k1_scalar_reduce_512(secp256k1_scalar_t *r, const uint32_t *l) {\n+    uint32_t n0 = l[8], n1 = l[9], n2 = l[10], n3 = l[11], n4 = l[12], n5 = l[13], n6 = l[14], n7 = l[15];\n+\n+    // 96 bit accumulator.\n+    uint32_t c0, c1, c2;\n+\n+    // Reduce 512 bits into 385.\n+    // m[0..12] = l[0..7] + n[0..7] * SECP256K1_N_C.\n+    c0 = l[0]; c1 = 0; c2 = 0;\n+    muladd_fast(n0, SECP256K1_N_C_0);\n+    uint32_t m0; extract_fast(m0);\n+    sumadd_fast(l[1]);\n+    muladd(n1, SECP256K1_N_C_0);\n+    muladd(n0, SECP256K1_N_C_1);\n+    uint32_t m1; extract(m1);\n+    sumadd(l[2]);\n+    muladd(n2, SECP256K1_N_C_0);\n+    muladd(n1, SECP256K1_N_C_1);\n+    muladd(n0, SECP256K1_N_C_2);\n+    uint32_t m2; extract(m2);\n+    sumadd(l[3]);\n+    muladd(n3, SECP256K1_N_C_0);\n+    muladd(n2, SECP256K1_N_C_1);\n+    muladd(n1, SECP256K1_N_C_2);\n+    muladd(n0, SECP256K1_N_C_3);\n+    uint32_t m3; extract(m3);\n+    sumadd(l[4]);\n+    muladd(n4, SECP256K1_N_C_0);\n+    muladd(n3, SECP256K1_N_C_1);\n+    muladd(n2, SECP256K1_N_C_2);\n+    muladd(n1, SECP256K1_N_C_3);\n+    sumadd(n0);\n+    uint32_t m4; extract(m4);\n+    sumadd(l[5]);\n+    muladd(n5, SECP256K1_N_C_0);\n+    muladd(n4, SECP256K1_N_C_1);\n+    muladd(n3, SECP256K1_N_C_2);\n+    muladd(n2, SECP256K1_N_C_3);\n+    sumadd(n1);\n+    uint32_t m5; extract(m5);\n+    sumadd(l[6]);\n+    muladd(n6, SECP256K1_N_C_0);\n+    muladd(n5, SECP256K1_N_C_1);\n+    muladd(n4, SECP256K1_N_C_2);\n+    muladd(n3, SECP256K1_N_C_3);\n+    sumadd(n2);\n+    uint32_t m6; extract(m6);\n+    sumadd(l[7]);\n+    muladd(n7, SECP256K1_N_C_0);\n+    muladd(n6, SECP256K1_N_C_1);\n+    muladd(n5, SECP256K1_N_C_2);\n+    muladd(n4, SECP256K1_N_C_3);\n+    sumadd(n3);\n+    uint32_t m7; extract(m7);\n+    muladd(n7, SECP256K1_N_C_1);\n+    muladd(n6, SECP256K1_N_C_2);\n+    muladd(n5, SECP256K1_N_C_3);\n+    sumadd(n4);\n+    uint32_t m8; extract(m8);\n+    muladd(n7, SECP256K1_N_C_2);\n+    muladd(n6, SECP256K1_N_C_3);\n+    sumadd(n5);\n+    uint32_t m9; extract(m9);\n+    muladd(n7, SECP256K1_N_C_3);\n+    sumadd(n6);\n+    uint32_t m10; extract(m10);\n+    sumadd_fast(n7);\n+    uint32_t m11; extract_fast(m11);\n+    VERIFY_CHECK(c0 <= 1);\n+    uint32_t m12 = c0;\n+\n+    // Reduce 385 bits into 258.\n+    // p[0..8] = m[0..7] + m[8..12] * SECP256K1_N_C.\n+    c0 = m0; c1 = 0; c2 = 0;\n+    muladd_fast(m8, SECP256K1_N_C_0);\n+    uint32_t p0; extract_fast(p0);\n+    sumadd_fast(m1);\n+    muladd(m9, SECP256K1_N_C_0);\n+    muladd(m8, SECP256K1_N_C_1);\n+    uint32_t p1; extract(p1);\n+    sumadd(m2);\n+    muladd(m10, SECP256K1_N_C_0);\n+    muladd(m9, SECP256K1_N_C_1);\n+    muladd(m8, SECP256K1_N_C_2);\n+    uint32_t p2; extract(p2);\n+    sumadd(m3);\n+    muladd(m11, SECP256K1_N_C_0);\n+    muladd(m10, SECP256K1_N_C_1);\n+    muladd(m9, SECP256K1_N_C_2);\n+    muladd(m8, SECP256K1_N_C_3);\n+    uint32_t p3; extract(p3);\n+    sumadd(m4);\n+    muladd(m12, SECP256K1_N_C_0);\n+    muladd(m11, SECP256K1_N_C_1);\n+    muladd(m10, SECP256K1_N_C_2);\n+    muladd(m9, SECP256K1_N_C_3);\n+    sumadd(m8);\n+    uint32_t p4; extract(p4);\n+    sumadd(m5);\n+    muladd(m12, SECP256K1_N_C_1);\n+    muladd(m11, SECP256K1_N_C_2);\n+    muladd(m10, SECP256K1_N_C_3);\n+    sumadd(m9);\n+    uint32_t p5; extract(p5);\n+    sumadd(m6);\n+    muladd(m12, SECP256K1_N_C_2);\n+    muladd(m11, SECP256K1_N_C_3);\n+    sumadd(m10);\n+    uint32_t p6; extract(p6);\n+    sumadd_fast(m7);\n+    muladd_fast(m12, SECP256K1_N_C_3);\n+    sumadd_fast(m11);\n+    uint32_t p7; extract_fast(p7);\n+    uint32_t p8 = c0 + m12;\n+    VERIFY_CHECK(p8 <= 2);\n+\n+    // Reduce 258 bits into 256.\n+    // r[0..7] = p[0..7] + p[8] * SECP256K1_N_C.\n+    uint64_t c = p0 + (uint64_t)SECP256K1_N_C_0 * p8;\n+    r->d[0] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p1 + (uint64_t)SECP256K1_N_C_1 * p8;\n+    r->d[1] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p2 + (uint64_t)SECP256K1_N_C_2 * p8;\n+    r->d[2] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p3 + (uint64_t)SECP256K1_N_C_3 * p8;\n+    r->d[3] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p4 + (uint64_t)p8;\n+    r->d[4] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p5;\n+    r->d[5] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p6;\n+    r->d[6] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p7;\n+    r->d[7] = c & 0xFFFFFFFFUL; c >>= 32;\n+\n+    // Final reduction of r.\n+    secp256k1_scalar_reduce(r, c + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_mul(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    // 96 bit accumulator.\n+    uint32_t c0 = 0, c1 = 0, c2 = 0;\n+\n+    uint32_t l[16];\n+\n+    // l[0..15] = a[0..7] * b[0..7].\n+    muladd_fast(a->d[0], b->d[0]);\n+    extract_fast(l[0]);\n+    muladd(a->d[0], b->d[1]);\n+    muladd(a->d[1], b->d[0]);\n+    extract(l[1]);\n+    muladd(a->d[0], b->d[2]);\n+    muladd(a->d[1], b->d[1]);\n+    muladd(a->d[2], b->d[0]);\n+    extract(l[2]);\n+    muladd(a->d[0], b->d[3]);\n+    muladd(a->d[1], b->d[2]);\n+    muladd(a->d[2], b->d[1]);\n+    muladd(a->d[3], b->d[0]);\n+    extract(l[3]);\n+    muladd(a->d[0], b->d[4]);\n+    muladd(a->d[1], b->d[3]);\n+    muladd(a->d[2], b->d[2]);\n+    muladd(a->d[3], b->d[1]);\n+    muladd(a->d[4], b->d[0]);\n+    extract(l[4]);\n+    muladd(a->d[0], b->d[5]);\n+    muladd(a->d[1], b->d[4]);\n+    muladd(a->d[2], b->d[3]);\n+    muladd(a->d[3], b->d[2]);\n+    muladd(a->d[4], b->d[1]);\n+    muladd(a->d[5], b->d[0]);\n+    extract(l[5]);\n+    muladd(a->d[0], b->d[6]);\n+    muladd(a->d[1], b->d[5]);\n+    muladd(a->d[2], b->d[4]);\n+    muladd(a->d[3], b->d[3]);\n+    muladd(a->d[4], b->d[2]);\n+    muladd(a->d[5], b->d[1]);\n+    muladd(a->d[6], b->d[0]);\n+    extract(l[6]);\n+    muladd(a->d[0], b->d[7]);\n+    muladd(a->d[1], b->d[6]);\n+    muladd(a->d[2], b->d[5]);\n+    muladd(a->d[3], b->d[4]);\n+    muladd(a->d[4], b->d[3]);\n+    muladd(a->d[5], b->d[2]);\n+    muladd(a->d[6], b->d[1]);\n+    muladd(a->d[7], b->d[0]);\n+    extract(l[7]);\n+    muladd(a->d[1], b->d[7]);\n+    muladd(a->d[2], b->d[6]);\n+    muladd(a->d[3], b->d[5]);\n+    muladd(a->d[4], b->d[4]);\n+    muladd(a->d[5], b->d[3]);\n+    muladd(a->d[6], b->d[2]);\n+    muladd(a->d[7], b->d[1]);\n+    extract(l[8]);\n+    muladd(a->d[2], b->d[7]);\n+    muladd(a->d[3], b->d[6]);\n+    muladd(a->d[4], b->d[5]);\n+    muladd(a->d[5], b->d[4]);\n+    muladd(a->d[6], b->d[3]);\n+    muladd(a->d[7], b->d[2]);\n+    extract(l[9]);\n+    muladd(a->d[3], b->d[7]);\n+    muladd(a->d[4], b->d[6]);\n+    muladd(a->d[5], b->d[5]);\n+    muladd(a->d[6], b->d[4]);\n+    muladd(a->d[7], b->d[3]);\n+    extract(l[10]);\n+    muladd(a->d[4], b->d[7]);\n+    muladd(a->d[5], b->d[6]);\n+    muladd(a->d[6], b->d[5]);\n+    muladd(a->d[7], b->d[4]);\n+    extract(l[11]);\n+    muladd(a->d[5], b->d[7]);\n+    muladd(a->d[6], b->d[6]);\n+    muladd(a->d[7], b->d[5]);\n+    extract(l[12]);\n+    muladd(a->d[6], b->d[7]);\n+    muladd(a->d[7], b->d[6]);\n+    extract(l[13]);\n+    muladd_fast(a->d[7], b->d[7]);\n+    extract_fast(l[14]);\n+    VERIFY_CHECK(c1 == 0);\n+    l[15] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+void static secp256k1_scalar_sqr(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    // 96 bit accumulator.\n+    uint32_t c0 = 0, c1 = 0, c2 = 0;\n+\n+    uint32_t l[16];\n+\n+    // l[0..15] = a[0..7]^2.\n+    muladd_fast(a->d[0], a->d[0]);\n+    extract_fast(l[0]);\n+    muladd2(a->d[0], a->d[1]);\n+    extract(l[1]);\n+    muladd2(a->d[0], a->d[2]);\n+    muladd(a->d[1], a->d[1]);\n+    extract(l[2]);\n+    muladd2(a->d[0], a->d[3]);\n+    muladd2(a->d[1], a->d[2]);\n+    extract(l[3]);\n+    muladd2(a->d[0], a->d[4]);\n+    muladd2(a->d[1], a->d[3]);\n+    muladd(a->d[2], a->d[2]);\n+    extract(l[4]);\n+    muladd2(a->d[0], a->d[5]);\n+    muladd2(a->d[1], a->d[4]);\n+    muladd2(a->d[2], a->d[3]);\n+    extract(l[5]);\n+    muladd2(a->d[0], a->d[6]);\n+    muladd2(a->d[1], a->d[5]);\n+    muladd2(a->d[2], a->d[4]);\n+    muladd(a->d[3], a->d[3]);\n+    extract(l[6]);\n+    muladd2(a->d[0], a->d[7]);\n+    muladd2(a->d[1], a->d[6]);\n+    muladd2(a->d[2], a->d[5]);\n+    muladd2(a->d[3], a->d[4]);\n+    extract(l[7]);\n+    muladd2(a->d[1], a->d[7]);\n+    muladd2(a->d[2], a->d[6]);\n+    muladd2(a->d[3], a->d[5]);\n+    muladd(a->d[4], a->d[4]);\n+    extract(l[8]);\n+    muladd2(a->d[2], a->d[7]);\n+    muladd2(a->d[3], a->d[6]);\n+    muladd2(a->d[4], a->d[5]);\n+    extract(l[9]);\n+    muladd2(a->d[3], a->d[7]);\n+    muladd2(a->d[4], a->d[6]);\n+    muladd(a->d[5], a->d[5]);\n+    extract(l[10]);\n+    muladd2(a->d[4], a->d[7]);\n+    muladd2(a->d[5], a->d[6]);\n+    extract(l[11]);\n+    muladd2(a->d[5], a->d[7]);\n+    muladd(a->d[6], a->d[6]);\n+    extract(l[12]);\n+    muladd2(a->d[6], a->d[7]);\n+    extract(l[13]);\n+    muladd_fast(a->d[7], a->d[7]);\n+    extract_fast(l[14]);\n+    VERIFY_CHECK(c1 == 0);\n+    l[15] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+#undef sumadd\n+#undef sumadd_fast\n+#undef muladd\n+#undef muladd_fast\n+#undef muladd2\n+#undef extract\n+#undef extract_fast\n+\n+#endif"
      },
      {
        "sha": "c52328e42cc017b8ac1c129517b78eaa1550a5ec",
        "filename": "src/scalar_impl.h",
        "status": "added",
        "additions": 182,
        "deletions": 0,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,182 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_IMPL_H_\n+#define _SECP256K1_SCALAR_IMPL_H_\n+\n+#include <string.h>\n+\n+#include \"scalar.h\"\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_SCALAR_4X64)\n+#include \"scalar_4x64_impl.h\"\n+#elif defined(USE_SCALAR_8X32)\n+#include \"scalar_8x32_impl.h\"\n+#else\n+#error \"Please select scalar implementation\"\n+#endif\n+\n+void static secp256k1_scalar_get_num(secp256k1_num_t *r, const secp256k1_scalar_t *a) {\n+    unsigned char c[32];\n+    secp256k1_scalar_get_b32(c, a);\n+    secp256k1_num_set_bin(r, c, 32);\n+}\n+\n+\n+void static secp256k1_scalar_inverse(secp256k1_scalar_t *r, const secp256k1_scalar_t *x) {\n+    // First compute x ^ (2^N - 1) for some values of N.\n+    secp256k1_scalar_t x2, x3, x4, x6, x7, x8, x15, x30, x60, x120, x127;\n+\n+    secp256k1_scalar_sqr(&x2,  x);\n+    secp256k1_scalar_mul(&x2, &x2,  x);\n+\n+    secp256k1_scalar_sqr(&x3, &x2);\n+    secp256k1_scalar_mul(&x3, &x3,  x);\n+\n+    secp256k1_scalar_sqr(&x4, &x3);\n+    secp256k1_scalar_mul(&x4, &x4,  x);\n+\n+    secp256k1_scalar_sqr(&x6, &x4);\n+    secp256k1_scalar_sqr(&x6, &x6);\n+    secp256k1_scalar_mul(&x6, &x6, &x2);\n+\n+    secp256k1_scalar_sqr(&x7, &x6);\n+    secp256k1_scalar_mul(&x7, &x7,  x);\n+\n+    secp256k1_scalar_sqr(&x8, &x7);\n+    secp256k1_scalar_mul(&x8, &x8,  x);\n+\n+    secp256k1_scalar_sqr(&x15, &x8);\n+    for (int i=0; i<6; i++)\n+        secp256k1_scalar_sqr(&x15, &x15);\n+    secp256k1_scalar_mul(&x15, &x15, &x7);\n+\n+    secp256k1_scalar_sqr(&x30, &x15);\n+    for (int i=0; i<14; i++)\n+        secp256k1_scalar_sqr(&x30, &x30);\n+    secp256k1_scalar_mul(&x30, &x30, &x15);\n+\n+    secp256k1_scalar_sqr(&x60, &x30);\n+    for (int i=0; i<29; i++)\n+        secp256k1_scalar_sqr(&x60, &x60);\n+    secp256k1_scalar_mul(&x60, &x60, &x30);\n+\n+    secp256k1_scalar_sqr(&x120, &x60);\n+    for (int i=0; i<59; i++)\n+        secp256k1_scalar_sqr(&x120, &x120);\n+    secp256k1_scalar_mul(&x120, &x120, &x60);\n+\n+    secp256k1_scalar_sqr(&x127, &x120);\n+    for (int i=0; i<6; i++)\n+        secp256k1_scalar_sqr(&x127, &x127);\n+    secp256k1_scalar_mul(&x127, &x127, &x7);\n+\n+    // Then accumulate the final result (t starts at x127).\n+    secp256k1_scalar_t *t = &x127;\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<3; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<5; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<4; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<5; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x4); // 1111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<4; i++) // 000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<10; i++) // 0000000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<9; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x8); // 11111111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<5; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x4); // 1111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<5; i++) // 000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<4; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<8; i++) // 000000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<3; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<6; i++) // 00000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<8; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(r, t, &x6); // 111111\n+}\n+\n+#endif"
      },
      {
        "sha": "3e37648299ab9a5bd91f2b2c2d0915e596977286",
        "filename": "src/secp256k1.c",
        "status": "added",
        "additions": 305,
        "deletions": 0,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"include/secp256k1.h\"\n+\n+#include <assert.h>\n+#include \"util.h\"\n+#include \"num_impl.h\"\n+#include \"field_impl.h\"\n+#include \"scalar_impl.h\"\n+#include \"group_impl.h\"\n+#include \"ecmult_impl.h\"\n+#include \"ecmult_gen_impl.h\"\n+#include \"ecdsa_impl.h\"\n+#include \"eckey_impl.h\"\n+\n+void secp256k1_start(unsigned int flags) {\n+    secp256k1_fe_start();\n+    secp256k1_ge_start();\n+    if (flags & SECP256K1_START_SIGN) {\n+        secp256k1_ecmult_gen_start();\n+    }\n+    if (flags & SECP256K1_START_VERIFY) {\n+        secp256k1_ecmult_start();\n+    }\n+}\n+\n+void secp256k1_stop(void) {\n+    secp256k1_ecmult_stop();\n+    secp256k1_ecmult_gen_stop();\n+    secp256k1_ge_stop();\n+    secp256k1_fe_stop();\n+}\n+\n+int secp256k1_ecdsa_verify(const unsigned char *msg, int msglen, const unsigned char *sig, int siglen, const unsigned char *pubkey, int pubkeylen) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(msg != NULL);\n+    DEBUG_CHECK(msglen <= 32);\n+    DEBUG_CHECK(sig != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+\n+    int ret = -3;\n+    secp256k1_num_t m; \n+    secp256k1_ecdsa_sig_t s;\n+    secp256k1_ge_t q;\n+    secp256k1_num_set_bin(&m, msg, msglen);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen)) {\n+        ret = -1;\n+        goto end;\n+    }\n+    if (!secp256k1_ecdsa_sig_parse(&s, sig, siglen)) {\n+        ret = -2;\n+        goto end;\n+    }\n+    if (!secp256k1_ecdsa_sig_verify(&s, &q, &m)) {\n+        ret = 0;\n+        goto end;\n+    }\n+    ret = 1;\n+end:\n+    return ret;\n+}\n+\n+int secp256k1_ecdsa_sign(const unsigned char *message, int messagelen, unsigned char *signature, int *signaturelen, const unsigned char *seckey, const unsigned char *nonce) {\n+    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(message != NULL);\n+    DEBUG_CHECK(messagelen <= 32);\n+    DEBUG_CHECK(signature != NULL);\n+    DEBUG_CHECK(signaturelen != NULL);\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(nonce != NULL);\n+\n+    secp256k1_scalar_t sec, non, msg;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&non, nonce, &overflow);\n+    {\n+        unsigned char c[32] = {0};\n+        memcpy(c + 32 - messagelen, message, messagelen);\n+        secp256k1_scalar_set_b32(&msg, c, NULL);\n+        memset(c, 0, 32);\n+    }\n+    int ret = !secp256k1_scalar_is_zero(&non) && !overflow;\n+    secp256k1_ecdsa_sig_t sig;\n+    if (ret) {\n+        ret = secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, NULL);\n+    }\n+    if (ret) {\n+        secp256k1_ecdsa_sig_serialize(signature, signaturelen, &sig);\n+    }\n+    secp256k1_scalar_clear(&msg);\n+    secp256k1_scalar_clear(&non);\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ecdsa_sign_compact(const unsigned char *message, int messagelen, unsigned char *sig64, const unsigned char *seckey, const unsigned char *nonce, int *recid) {\n+    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(message != NULL);\n+    DEBUG_CHECK(messagelen <= 32);\n+    DEBUG_CHECK(sig64 != NULL);\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(nonce != NULL);\n+\n+    secp256k1_scalar_t sec, non, msg;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&non, nonce, &overflow);\n+    {\n+        unsigned char c[32] = {0};\n+        memcpy(c + 32 - messagelen, message, messagelen);\n+        secp256k1_scalar_set_b32(&msg, c, NULL);\n+        memset(c, 0, 32);\n+    }\n+    int ret = !secp256k1_scalar_is_zero(&non) && !overflow;\n+    secp256k1_ecdsa_sig_t sig;\n+    if (ret) {\n+        ret = secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, recid);\n+    }\n+    if (ret) {\n+        secp256k1_num_get_bin(sig64, 32, &sig.r);\n+        secp256k1_num_get_bin(sig64 + 32, 32, &sig.s);\n+    }\n+    secp256k1_scalar_clear(&msg);\n+    secp256k1_scalar_clear(&non);\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ecdsa_recover_compact(const unsigned char *msg, int msglen, const unsigned char *sig64, unsigned char *pubkey, int *pubkeylen, int compressed, int recid) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(msg != NULL);\n+    DEBUG_CHECK(msglen <= 32);\n+    DEBUG_CHECK(sig64 != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(pubkeylen != NULL);\n+    DEBUG_CHECK(recid >= 0 && recid <= 3);\n+\n+    int ret = 0;\n+    secp256k1_num_t m; \n+    secp256k1_ecdsa_sig_t sig;\n+    secp256k1_num_set_bin(&sig.r, sig64, 32);\n+    secp256k1_num_set_bin(&sig.s, sig64 + 32, 32);\n+    secp256k1_num_set_bin(&m, msg, msglen);\n+\n+    secp256k1_ge_t q;\n+    if (secp256k1_ecdsa_sig_recover(&sig, &q, &m, recid)) {\n+        secp256k1_eckey_pubkey_serialize(&q, pubkey, pubkeylen, compressed);\n+        ret = 1;\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_verify(const unsigned char *seckey) {\n+    DEBUG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_t sec;\n+    int overflow;\n+    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n+    int ret = !secp256k1_scalar_is_zero(&sec) && !overflow;\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen) {\n+    DEBUG_CHECK(pubkey != NULL);\n+\n+    secp256k1_ge_t q;\n+    return secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen);\n+}\n+\n+int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed) {\n+    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(pubkeylen != NULL);\n+    DEBUG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_t sec;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    secp256k1_gej_t pj;\n+    secp256k1_ecmult_gen(&pj, &sec);\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_ge_t p;\n+    secp256k1_ge_set_gej(&p, &pj);\n+    secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, compressed);\n+    return 1;\n+}\n+\n+int secp256k1_ec_pubkey_decompress(unsigned char *pubkey, int *pubkeylen) {\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(pubkeylen != NULL);\n+\n+    secp256k1_ge_t p;\n+    if (!secp256k1_eckey_pubkey_parse(&p, pubkey, *pubkeylen))\n+        return 0;\n+    secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, 0);\n+    return 1;\n+}\n+\n+int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *tweak) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_scalar_t term;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    secp256k1_scalar_t sec;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+\n+    int ret = secp256k1_eckey_privkey_tweak_add(&sec, &term) && !overflow;\n+    if (ret) {\n+        secp256k1_scalar_get_b32(seckey, &sec);\n+    }\n+\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_num_t term;\n+    secp256k1_num_set_bin(&term, tweak, 32);\n+    secp256k1_ge_t p;\n+    int ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n+    if (ret) {\n+        ret = secp256k1_eckey_pubkey_tweak_add(&p, &term);\n+    }\n+    if (ret) {\n+        int oldlen = pubkeylen;\n+        secp256k1_eckey_pubkey_serialize(&p, pubkey, &pubkeylen, oldlen <= 33);\n+        VERIFY_CHECK(pubkeylen == oldlen);\n+    }\n+\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *tweak) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_scalar_t factor;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n+    secp256k1_scalar_t sec;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    int ret = secp256k1_eckey_privkey_tweak_mul(&sec, &factor) && !overflow;\n+    if (ret) {\n+        secp256k1_scalar_get_b32(seckey, &sec);\n+    }\n+\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_clear(&factor);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_num_t factor;\n+    secp256k1_num_set_bin(&factor, tweak, 32);\n+    secp256k1_ge_t p;\n+    int ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n+    if (ret) {\n+        ret = secp256k1_eckey_pubkey_tweak_mul(&p, &factor);\n+    }\n+    if (ret) {\n+        int oldlen = pubkeylen;\n+        secp256k1_eckey_pubkey_serialize(&p, pubkey, &pubkeylen, oldlen <= 33);\n+        VERIFY_CHECK(pubkeylen == oldlen);\n+    }\n+\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_export(const unsigned char *seckey, unsigned char *privkey, int *privkeylen, int compressed) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(privkey != NULL);\n+    DEBUG_CHECK(privkeylen != NULL);\n+\n+    secp256k1_scalar_t key;\n+    secp256k1_scalar_set_b32(&key, seckey, NULL);\n+    int ret = secp256k1_eckey_privkey_serialize(privkey, privkeylen, &key, compressed);\n+    secp256k1_scalar_clear(&key);\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_import(unsigned char *seckey, const unsigned char *privkey, int privkeylen) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(privkey != NULL);\n+\n+    secp256k1_scalar_t key;\n+    int ret = secp256k1_eckey_privkey_parse(&key, privkey, privkeylen);\n+    if (ret)\n+        secp256k1_scalar_get_b32(seckey, &key);\n+    secp256k1_scalar_clear(&key);\n+    return ret;\n+}"
      },
      {
        "sha": "593380ae7619416a2fe7e125841261630bb956d7",
        "filename": "src/tests.c",
        "status": "added",
        "additions": 899,
        "deletions": 0,
        "changes": 899,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,899 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"util_impl.h\"\n+#include \"secp256k1.c\"\n+\n+#ifdef ENABLE_OPENSSL_TESTS\n+#include \"openssl/bn.h\"\n+#include \"openssl/ec.h\"\n+#include \"openssl/ecdsa.h\"\n+#include \"openssl/obj_mac.h\"\n+#endif\n+\n+static int count = 64;\n+\n+/***** NUM TESTS *****/\n+\n+void random_num_negate(secp256k1_num_t *num) {\n+    if (secp256k1_rand32() & 1)\n+        secp256k1_num_negate(num);\n+}\n+\n+void random_num_order_test(secp256k1_num_t *num) {\n+    do {\n+        unsigned char b32[32];\n+        secp256k1_rand256_test(b32);\n+        secp256k1_num_set_bin(num, b32, 32);\n+        if (secp256k1_num_is_zero(num))\n+            continue;\n+        if (secp256k1_num_cmp(num, &secp256k1_ge_consts->order) >= 0)\n+            continue;\n+        break;\n+    } while(1);\n+}\n+\n+void random_scalar_order_test(secp256k1_scalar_t *num) {\n+    do {\n+        unsigned char b32[32];\n+        secp256k1_rand256_test(b32);\n+        int overflow = 0;\n+        secp256k1_scalar_set_b32(num, b32, &overflow);\n+        if (overflow || secp256k1_scalar_is_zero(num))\n+            continue;\n+        break;\n+    } while(1);\n+}\n+\n+void random_num_order(secp256k1_num_t *num) {\n+    do {\n+        unsigned char b32[32];\n+        secp256k1_rand256(b32);\n+        secp256k1_num_set_bin(num, b32, 32);\n+        if (secp256k1_num_is_zero(num))\n+            continue;\n+        if (secp256k1_num_cmp(num, &secp256k1_ge_consts->order) >= 0)\n+            continue;\n+        break;\n+    } while(1);\n+}\n+\n+void test_num_copy_inc_cmp() {\n+    secp256k1_num_t n1,n2;\n+    random_num_order(&n1);\n+    secp256k1_num_copy(&n2, &n1);\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+    CHECK(secp256k1_num_eq(&n2, &n1));\n+    secp256k1_num_inc(&n2);\n+    CHECK(!secp256k1_num_eq(&n1, &n2));\n+    CHECK(!secp256k1_num_eq(&n2, &n1));\n+}\n+\n+\n+void test_num_get_set_hex() {\n+    secp256k1_num_t n1,n2;\n+    random_num_order_test(&n1);\n+    char c[64];\n+    secp256k1_num_get_hex(c, 64, &n1);\n+    secp256k1_num_set_hex(&n2, c, 64);\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+    for (int i=0; i<64; i++) {\n+        // check whether the lower 4 bits correspond to the last hex character\n+        int low1 = secp256k1_num_shift(&n1, 4);\n+        int lowh = c[63];\n+        int low2 = (lowh>>6)*9+(lowh-'0')&15;\n+        CHECK(low1 == low2);\n+        // shift bits off the hex representation, and compare\n+        memmove(c+1, c, 63);\n+        c[0] = '0';\n+        secp256k1_num_set_hex(&n2, c, 64);\n+        CHECK(secp256k1_num_eq(&n1, &n2));\n+    }\n+}\n+\n+void test_num_get_set_bin() {\n+    secp256k1_num_t n1,n2;\n+    random_num_order_test(&n1);\n+    unsigned char c[32];\n+    secp256k1_num_get_bin(c, 32, &n1);\n+    secp256k1_num_set_bin(&n2, c, 32);\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+    for (int i=0; i<32; i++) {\n+        // check whether the lower 8 bits correspond to the last byte\n+        int low1 = secp256k1_num_shift(&n1, 8);\n+        int low2 = c[31];\n+        CHECK(low1 == low2);\n+        // shift bits off the byte representation, and compare\n+        memmove(c+1, c, 31);\n+        c[0] = 0;\n+        secp256k1_num_set_bin(&n2, c, 32);\n+        CHECK(secp256k1_num_eq(&n1, &n2));\n+    }\n+}\n+\n+void run_num_int() {\n+    secp256k1_num_t n1;\n+    for (int i=-255; i<256; i++) {\n+        unsigned char c1[3] = {};\n+        c1[2] = abs(i);\n+        unsigned char c2[3] = {0x11,0x22,0x33};\n+        secp256k1_num_set_int(&n1, i);\n+        secp256k1_num_get_bin(c2, 3, &n1);\n+        CHECK(memcmp(c1, c2, 3) == 0);\n+    }\n+}\n+\n+void test_num_negate() {\n+    secp256k1_num_t n1;\n+    secp256k1_num_t n2;\n+    random_num_order_test(&n1); // n1 = R\n+    random_num_negate(&n1);\n+    secp256k1_num_copy(&n2, &n1); // n2 = R\n+    secp256k1_num_sub(&n1, &n2, &n1); // n1 = n2-n1 = 0\n+    CHECK(secp256k1_num_is_zero(&n1));\n+    secp256k1_num_copy(&n1, &n2); // n1 = R\n+    secp256k1_num_negate(&n1); // n1 = -R\n+    CHECK(!secp256k1_num_is_zero(&n1));\n+    secp256k1_num_add(&n1, &n2, &n1); // n1 = n2+n1 = 0\n+    CHECK(secp256k1_num_is_zero(&n1));\n+    secp256k1_num_copy(&n1, &n2); // n1 = R\n+    secp256k1_num_negate(&n1); // n1 = -R\n+    CHECK(secp256k1_num_is_neg(&n1) != secp256k1_num_is_neg(&n2));\n+    secp256k1_num_negate(&n1); // n1 = R\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+}\n+\n+void test_num_add_sub() {\n+    int r = secp256k1_rand32();\n+    secp256k1_num_t n1;\n+    secp256k1_num_t n2;\n+    random_num_order_test(&n1); // n1 = R1\n+    if (r & 1) {\n+        random_num_negate(&n1);\n+    }\n+    random_num_order_test(&n2); // n2 = R2\n+    if (r & 2) {\n+        random_num_negate(&n2);\n+    }\n+    secp256k1_num_t n1p2, n2p1, n1m2, n2m1;\n+    secp256k1_num_add(&n1p2, &n1, &n2); // n1p2 = R1 + R2\n+    secp256k1_num_add(&n2p1, &n2, &n1); // n2p1 = R2 + R1\n+    secp256k1_num_sub(&n1m2, &n1, &n2); // n1m2 = R1 - R2\n+    secp256k1_num_sub(&n2m1, &n2, &n1); // n2m1 = R2 - R1\n+    CHECK(secp256k1_num_eq(&n1p2, &n2p1));\n+    CHECK(!secp256k1_num_eq(&n1p2, &n1m2));\n+    secp256k1_num_negate(&n2m1); // n2m1 = -R2 + R1\n+    CHECK(secp256k1_num_eq(&n2m1, &n1m2));\n+    CHECK(!secp256k1_num_eq(&n2m1, &n1));\n+    secp256k1_num_add(&n2m1, &n2m1, &n2); // n2m1 = -R2 + R1 + R2 = R1\n+    CHECK(secp256k1_num_eq(&n2m1, &n1));\n+    CHECK(!secp256k1_num_eq(&n2p1, &n1));\n+    secp256k1_num_sub(&n2p1, &n2p1, &n2); // n2p1 = R2 + R1 - R2 = R1\n+    CHECK(secp256k1_num_eq(&n2p1, &n1));\n+}\n+\n+void run_num_smalltests() {\n+    for (int i=0; i<100*count; i++) {\n+        test_num_copy_inc_cmp();\n+        test_num_get_set_hex();\n+        test_num_get_set_bin();\n+        test_num_negate();\n+        test_num_add_sub();\n+    }\n+    run_num_int();\n+}\n+\n+/***** SCALAR TESTS *****/\n+\n+int secp256k1_scalar_eq(const secp256k1_scalar_t *s1, const secp256k1_scalar_t *s2) {\n+    secp256k1_scalar_t t;\n+    secp256k1_scalar_negate(&t, s2);\n+    secp256k1_scalar_add(&t, &t, s1);\n+    int ret = secp256k1_scalar_is_zero(&t);\n+    return ret;\n+}\n+\n+void scalar_test(void) {\n+    unsigned char c[32];\n+\n+    // Set 's' to a random scalar, with value 'snum'.\n+    secp256k1_rand256_test(c);\n+    secp256k1_scalar_t s;\n+    secp256k1_scalar_set_b32(&s, c, NULL);\n+    secp256k1_num_t snum;\n+    secp256k1_num_set_bin(&snum, c, 32);\n+    secp256k1_num_mod(&snum, &secp256k1_ge_consts->order);\n+\n+    // Set 's1' to a random scalar, with value 's1num'.\n+    secp256k1_rand256_test(c);\n+    secp256k1_scalar_t s1;\n+    secp256k1_scalar_set_b32(&s1, c, NULL);\n+    secp256k1_num_t s1num;\n+    secp256k1_num_set_bin(&s1num, c, 32);\n+    secp256k1_num_mod(&s1num, &secp256k1_ge_consts->order);\n+\n+    // Set 's2' to a random scalar, with value 'snum2', and byte array representation 'c'.\n+    secp256k1_rand256_test(c);\n+    secp256k1_scalar_t s2;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&s2, c, &overflow);\n+    secp256k1_num_t s2num;\n+    secp256k1_num_set_bin(&s2num, c, 32);\n+    secp256k1_num_mod(&s2num, &secp256k1_ge_consts->order);\n+\n+    {\n+        // Test that fetching groups of 4 bits from a scalar and recursing n(i)=16*n(i-1)+p(i) reconstructs it.\n+        secp256k1_num_t n, t, m;\n+        secp256k1_num_set_int(&n, 0);\n+        secp256k1_num_set_int(&m, 16);\n+        for (int i = 0; i < 256; i += 4) {\n+            secp256k1_num_set_int(&t, secp256k1_scalar_get_bits(&s, 256 - 4 - i, 4));\n+            secp256k1_num_mul(&n, &n, &m);\n+            secp256k1_num_add(&n, &n, &t);\n+        }\n+        CHECK(secp256k1_num_eq(&n, &snum));\n+    }\n+\n+    {\n+        // Test that get_b32 returns the same as get_bin on the number.\n+        unsigned char r1[32];\n+        secp256k1_scalar_get_b32(r1, &s2);\n+        unsigned char r2[32];\n+        secp256k1_num_get_bin(r2, 32, &s2num);\n+        CHECK(memcmp(r1, r2, 32) == 0);\n+        // If no overflow occurred when assigning, it should also be equal to the original byte array.\n+        CHECK((memcmp(r1, c, 32) == 0) == (overflow == 0));\n+    }\n+\n+    {\n+        // Test that adding the scalars together is equal to adding their numbers together modulo the order.\n+        secp256k1_num_t rnum;\n+        secp256k1_num_add(&rnum, &snum, &s2num);\n+        secp256k1_num_mod(&rnum, &secp256k1_ge_consts->order);\n+        secp256k1_scalar_t r;\n+        secp256k1_scalar_add(&r, &s, &s2);\n+        secp256k1_num_t r2num;\n+        secp256k1_scalar_get_num(&r2num, &r);\n+        CHECK(secp256k1_num_eq(&rnum, &r2num));\n+    }\n+\n+    {\n+        // Test that multipying the scalars is equal to multiplying their numbers modulo the order.\n+        secp256k1_num_t rnum;\n+        secp256k1_num_mul(&rnum, &snum, &s2num);\n+        secp256k1_num_mod(&rnum, &secp256k1_ge_consts->order);\n+        secp256k1_scalar_t r;\n+        secp256k1_scalar_mul(&r, &s, &s2);\n+        secp256k1_num_t r2num;\n+        secp256k1_scalar_get_num(&r2num, &r);\n+        CHECK(secp256k1_num_eq(&rnum, &r2num));\n+        // The result can only be zero if at least one of the factors was zero.\n+        CHECK(secp256k1_scalar_is_zero(&r) == (secp256k1_scalar_is_zero(&s) || secp256k1_scalar_is_zero(&s2)));\n+        // The results can only be equal to one of the factors if that factor was zero, or the other factor was one.\n+        CHECK(secp256k1_num_eq(&rnum, &snum) == (secp256k1_scalar_is_zero(&s) || secp256k1_scalar_is_one(&s2)));\n+        CHECK(secp256k1_num_eq(&rnum, &s2num) == (secp256k1_scalar_is_zero(&s2) || secp256k1_scalar_is_one(&s)));\n+    }\n+\n+    {\n+        // Check that comparison with zero matches comparison with zero on the number.\n+        CHECK(secp256k1_num_is_zero(&snum) == secp256k1_scalar_is_zero(&s));\n+        // Check that comparison with the half order is equal to testing for high scalar.\n+        CHECK(secp256k1_scalar_is_high(&s) == (secp256k1_num_cmp(&snum, &secp256k1_ge_consts->half_order) > 0));\n+        secp256k1_scalar_t neg;\n+        secp256k1_scalar_negate(&neg, &s);\n+        secp256k1_num_t negnum;\n+        secp256k1_num_sub(&negnum, &secp256k1_ge_consts->order, &snum);\n+        secp256k1_num_mod(&negnum, &secp256k1_ge_consts->order);\n+        // Check that comparison with the half order is equal to testing for high scalar after negation.\n+        CHECK(secp256k1_scalar_is_high(&neg) == (secp256k1_num_cmp(&negnum, &secp256k1_ge_consts->half_order) > 0));\n+        // Negating should change the high property, unless the value was already zero.\n+        CHECK((secp256k1_scalar_is_high(&s) == secp256k1_scalar_is_high(&neg)) == secp256k1_scalar_is_zero(&s));\n+        secp256k1_num_t negnum2;\n+        secp256k1_scalar_get_num(&negnum2, &neg);\n+        // Negating a scalar should be equal to (order - n) mod order on the number.\n+        CHECK(secp256k1_num_eq(&negnum, &negnum2));\n+        secp256k1_scalar_add(&neg, &neg, &s);\n+        // Adding a number to its negation should result in zero.\n+        CHECK(secp256k1_scalar_is_zero(&neg));\n+        secp256k1_scalar_negate(&neg, &neg);\n+        // Negating zero should still result in zero.\n+        CHECK(secp256k1_scalar_is_zero(&neg));\n+    }\n+\n+    {\n+        // Test that scalar inverses are equal to the inverse of their number modulo the order.\n+        if (!secp256k1_scalar_is_zero(&s)) {\n+            secp256k1_scalar_t inv;\n+            secp256k1_scalar_inverse(&inv, &s);\n+            secp256k1_num_t invnum;\n+            secp256k1_num_mod_inverse(&invnum, &snum, &secp256k1_ge_consts->order);\n+            secp256k1_num_t invnum2;\n+            secp256k1_scalar_get_num(&invnum2, &inv);\n+            CHECK(secp256k1_num_eq(&invnum, &invnum2));\n+            secp256k1_scalar_mul(&inv, &inv, &s);\n+            // Multiplying a scalar with its inverse must result in one.\n+            CHECK(secp256k1_scalar_is_one(&inv));\n+            secp256k1_scalar_inverse(&inv, &inv);\n+            // Inverting one must result in one.\n+            CHECK(secp256k1_scalar_is_one(&inv));\n+        }\n+    }\n+\n+    {\n+        // Test commutativity of add.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_add(&r1, &s1, &s2);\n+        secp256k1_scalar_add(&r2, &s2, &s1);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test commutativity of mul.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_mul(&r1, &s1, &s2);\n+        secp256k1_scalar_mul(&r2, &s2, &s1);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test associativity of add.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_add(&r1, &s1, &s2);\n+        secp256k1_scalar_add(&r1, &r1, &s);\n+        secp256k1_scalar_add(&r2, &s2, &s);\n+        secp256k1_scalar_add(&r2, &s1, &r2);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test associativity of mul.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_mul(&r1, &s1, &s2);\n+        secp256k1_scalar_mul(&r1, &r1, &s);\n+        secp256k1_scalar_mul(&r2, &s2, &s);\n+        secp256k1_scalar_mul(&r2, &s1, &r2);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test distributitivity of mul over add.\n+        secp256k1_scalar_t r1, r2, t;\n+        secp256k1_scalar_add(&r1, &s1, &s2);\n+        secp256k1_scalar_mul(&r1, &r1, &s);\n+        secp256k1_scalar_mul(&r2, &s1, &s);\n+        secp256k1_scalar_mul(&t, &s2, &s);\n+        secp256k1_scalar_add(&r2, &r2, &t);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test square.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_sqr(&r1, &s1);\n+        secp256k1_scalar_mul(&r2, &s1, &s1);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+void run_scalar_tests(void) {\n+    for (int i = 0; i < 128 * count; i++) {\n+        scalar_test();\n+    }\n+}\n+\n+/***** FIELD TESTS *****/\n+\n+void random_fe(secp256k1_fe_t *x) {\n+    unsigned char bin[32];\n+    secp256k1_rand256(bin);\n+    secp256k1_fe_set_b32(x, bin);\n+}\n+\n+void random_fe_non_zero(secp256k1_fe_t *nz) {\n+    int tries = 10;\n+    while (--tries >= 0) {\n+        random_fe(nz);\n+        secp256k1_fe_normalize(nz);\n+        if (!secp256k1_fe_is_zero(nz))\n+            break;\n+    }\n+    // Infinitesimal probability of spurious failure here\n+    CHECK(tries >= 0);\n+}\n+\n+void random_fe_non_square(secp256k1_fe_t *ns) {\n+    random_fe_non_zero(ns);\n+    secp256k1_fe_t r;\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n+        secp256k1_fe_negate(ns, ns, 1);\n+    }\n+}\n+\n+int check_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+    secp256k1_fe_t an = *a; secp256k1_fe_normalize(&an);\n+    secp256k1_fe_t bn = *b; secp256k1_fe_normalize(&bn);\n+    return secp256k1_fe_equal(&an, &bn);\n+}\n+\n+int check_fe_inverse(const secp256k1_fe_t *a, const secp256k1_fe_t *ai) {\n+    secp256k1_fe_t x; secp256k1_fe_mul(&x, a, ai);\n+    secp256k1_fe_t one; secp256k1_fe_set_int(&one, 1);\n+    return check_fe_equal(&x, &one);\n+}\n+\n+void run_field_inv() {\n+    secp256k1_fe_t x, xi, xii;\n+    for (int i=0; i<10*count; i++) {\n+        random_fe_non_zero(&x);\n+        secp256k1_fe_inv(&xi, &x);\n+        CHECK(check_fe_inverse(&x, &xi));\n+        secp256k1_fe_inv(&xii, &xi);\n+        CHECK(check_fe_equal(&x, &xii));\n+    }\n+}\n+\n+void run_field_inv_var() {\n+    secp256k1_fe_t x, xi, xii;\n+    for (int i=0; i<10*count; i++) {\n+        random_fe_non_zero(&x);\n+        secp256k1_fe_inv_var(&xi, &x);\n+        CHECK(check_fe_inverse(&x, &xi));\n+        secp256k1_fe_inv_var(&xii, &xi);\n+        CHECK(check_fe_equal(&x, &xii));\n+    }\n+}\n+\n+void run_field_inv_all() {\n+    secp256k1_fe_t x[16], xi[16], xii[16];\n+    // Check it's safe to call for 0 elements\n+    secp256k1_fe_inv_all(0, xi, x);\n+    for (int i=0; i<count; i++) {\n+        size_t len = (secp256k1_rand32() & 15) + 1;\n+        for (int j=0; j<len; j++)\n+            random_fe_non_zero(&x[j]);\n+        secp256k1_fe_inv_all(len, xi, x);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_inverse(&x[j], &xi[j]));\n+        secp256k1_fe_inv_all(len, xii, xi);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_equal(&x[j], &xii[j]));\n+    }\n+}\n+\n+void run_field_inv_all_var() {\n+    secp256k1_fe_t x[16], xi[16], xii[16];\n+    // Check it's safe to call for 0 elements\n+    secp256k1_fe_inv_all_var(0, xi, x);\n+    for (int i=0; i<count; i++) {\n+        size_t len = (secp256k1_rand32() & 15) + 1;\n+        for (int j=0; j<len; j++)\n+            random_fe_non_zero(&x[j]);\n+        secp256k1_fe_inv_all_var(len, xi, x);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_inverse(&x[j], &xi[j]));\n+        secp256k1_fe_inv_all_var(len, xii, xi);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_equal(&x[j], &xii[j]));\n+    }\n+}\n+\n+void run_sqr() {\n+    secp256k1_fe_t x, s;\n+\n+    {\n+        secp256k1_fe_set_int(&x, 1);\n+        secp256k1_fe_negate(&x, &x, 1);\n+\n+        for (int i=1; i<=512; ++i) {\n+            secp256k1_fe_mul_int(&x, 2);\n+            secp256k1_fe_normalize(&x);\n+            secp256k1_fe_sqr(&s, &x);\n+        }\n+    }\n+}\n+\n+void test_sqrt(const secp256k1_fe_t *a, const secp256k1_fe_t *k) {\n+    secp256k1_fe_t r1, r2;\n+    int v = secp256k1_fe_sqrt(&r1, a);\n+    CHECK((v == 0) == (k == NULL));\n+\n+    if (k != NULL) {\n+        // Check that the returned root is +/- the given known answer\n+        secp256k1_fe_negate(&r2, &r1, 1);\n+        secp256k1_fe_add(&r1, k); secp256k1_fe_add(&r2, k);\n+        secp256k1_fe_normalize(&r1); secp256k1_fe_normalize(&r2);\n+        CHECK(secp256k1_fe_is_zero(&r1) || secp256k1_fe_is_zero(&r2));\n+    }\n+}\n+\n+void run_sqrt() {\n+    secp256k1_fe_t ns, x, s, t;\n+\n+    // Check sqrt(0) is 0\n+    secp256k1_fe_set_int(&x, 0);\n+    secp256k1_fe_sqr(&s, &x);\n+    test_sqrt(&s, &x);\n+\n+    // Check sqrt of small squares (and their negatives)\n+    for (int i=1; i<=100; i++) {\n+        secp256k1_fe_set_int(&x, i);\n+        secp256k1_fe_sqr(&s, &x);\n+        test_sqrt(&s, &x);\n+        secp256k1_fe_negate(&t, &s, 1);\n+        test_sqrt(&t, NULL);\n+    }\n+\n+    // Consistency checks for large random values\n+    for (int i=0; i<10; i++) {\n+        random_fe_non_square(&ns);\n+        for (int j=0; j<count; j++) {\n+            random_fe(&x);\n+            secp256k1_fe_sqr(&s, &x);\n+            test_sqrt(&s, &x);\n+            secp256k1_fe_negate(&t, &s, 1);\n+            test_sqrt(&t, NULL);\n+            secp256k1_fe_mul(&t, &s, &ns);\n+            test_sqrt(&t, NULL);\n+        }\n+    }\n+}\n+\n+/***** ECMULT TESTS *****/\n+\n+void run_ecmult_chain() {\n+    // random starting point A (on the curve)\n+    secp256k1_fe_t ax; secp256k1_fe_set_hex(&ax, \"8b30bbe9ae2a990696b22f670709dff3727fd8bc04d3362c6c7bf458e2846004\", 64);\n+    secp256k1_fe_t ay; secp256k1_fe_set_hex(&ay, \"a357ae915c4a65281309edf20504740f0eb3343990216b4f81063cb65f2f7e0f\", 64);\n+    secp256k1_gej_t a; secp256k1_gej_set_xy(&a, &ax, &ay);\n+    // two random initial factors xn and gn\n+    secp256k1_num_t xn;\n+    secp256k1_num_set_hex(&xn, \"84cc5452f7fde1edb4d38a8ce9b1b84ccef31f146e569be9705d357a42985407\", 64);\n+    secp256k1_num_t gn;\n+    secp256k1_num_set_hex(&gn, \"a1e58d22553dcd42b23980625d4c57a96e9323d42b3152e5ca2c3990edc7c9de\", 64);\n+    // two small multipliers to be applied to xn and gn in every iteration:\n+    secp256k1_num_t xf;\n+    secp256k1_num_set_hex(&xf, \"1337\", 4);\n+    secp256k1_num_t gf;\n+    secp256k1_num_set_hex(&gf, \"7113\", 4);\n+    // accumulators with the resulting coefficients to A and G\n+    secp256k1_num_t ae;\n+    secp256k1_num_set_int(&ae, 1);\n+    secp256k1_num_t ge;\n+    secp256k1_num_set_int(&ge, 0);\n+    // the point being computed\n+    secp256k1_gej_t x = a;\n+    const secp256k1_num_t *order = &secp256k1_ge_consts->order;\n+    for (int i=0; i<200*count; i++) {\n+        // in each iteration, compute X = xn*X + gn*G;\n+        secp256k1_ecmult(&x, &x, &xn, &gn);\n+        // also compute ae and ge: the actual accumulated factors for A and G\n+        // if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G)\n+        secp256k1_num_mod_mul(&ae, &ae, &xn, order);\n+        secp256k1_num_mod_mul(&ge, &ge, &xn, order);\n+        secp256k1_num_add(&ge, &ge, &gn);\n+        secp256k1_num_mod(&ge, order);\n+        // modify xn and gn\n+        secp256k1_num_mod_mul(&xn, &xn, &xf, order);\n+        secp256k1_num_mod_mul(&gn, &gn, &gf, order);\n+\n+        // verify\n+        if (i == 19999) {\n+            char res[132]; int resl = 132;\n+            secp256k1_gej_get_hex(res, &resl, &x);\n+            CHECK(strcmp(res, \"(D6E96687F9B10D092A6F35439D86CEBEA4535D0D409F53586440BD74B933E830,B95CBCA2C77DA786539BE8FD53354D2D3B4F566AE658045407ED6015EE1B2A88)\") == 0);\n+        }\n+    }\n+    // redo the computation, but directly with the resulting ae and ge coefficients:\n+    secp256k1_gej_t x2; secp256k1_ecmult(&x2, &a, &ae, &ge);\n+    char res[132]; int resl = 132;\n+    char res2[132]; int resl2 = 132;\n+    secp256k1_gej_get_hex(res, &resl, &x);\n+    secp256k1_gej_get_hex(res2, &resl2, &x2);\n+    CHECK(strcmp(res, res2) == 0);\n+    CHECK(strlen(res) == 131);\n+}\n+\n+void test_point_times_order(const secp256k1_gej_t *point) {\n+    // multiplying a point by the order results in O\n+    const secp256k1_num_t *order = &secp256k1_ge_consts->order;\n+    secp256k1_num_t zero;\n+    secp256k1_num_set_int(&zero, 0);\n+    secp256k1_gej_t res;\n+    secp256k1_ecmult(&res, point, order, order); // calc res = order * point + order * G;\n+    CHECK(secp256k1_gej_is_infinity(&res));\n+}\n+\n+void run_point_times_order() {\n+    secp256k1_fe_t x; secp256k1_fe_set_hex(&x, \"02\", 2);\n+    for (int i=0; i<500; i++) {\n+        secp256k1_ge_t p;\n+        if (secp256k1_ge_set_xo(&p, &x, 1)) {\n+            CHECK(secp256k1_ge_is_valid(&p));\n+            secp256k1_gej_t j;\n+            secp256k1_gej_set_ge(&j, &p);\n+            CHECK(secp256k1_gej_is_valid(&j));\n+            test_point_times_order(&j);\n+        }\n+        secp256k1_fe_sqr(&x, &x);\n+    }\n+    char c[65]; int cl=65;\n+    secp256k1_fe_get_hex(c, &cl, &x);\n+    CHECK(strcmp(c, \"7603CB59B0EF6C63FE6084792A0C378CDB3233A80F8A9A09A877DEAD31B38C45\") == 0);\n+}\n+\n+void test_wnaf(const secp256k1_num_t *number, int w) {\n+    secp256k1_num_t x, two, t;\n+    secp256k1_num_set_int(&x, 0);\n+    secp256k1_num_set_int(&two, 2);\n+    int wnaf[257];\n+    int bits = secp256k1_ecmult_wnaf(wnaf, number, w);\n+    int zeroes = -1;\n+    for (int i=bits-1; i>=0; i--) {\n+        secp256k1_num_mul(&x, &x, &two);\n+        int v = wnaf[i];\n+        if (v) {\n+            CHECK(zeroes == -1 || zeroes >= w-1); // check that distance between non-zero elements is at least w-1\n+            zeroes=0;\n+            CHECK((v & 1) == 1); // check non-zero elements are odd\n+            CHECK(v <= (1 << (w-1)) - 1); // check range below\n+            CHECK(v >= -(1 << (w-1)) - 1); // check range above\n+        } else {\n+            CHECK(zeroes != -1); // check that no unnecessary zero padding exists\n+            zeroes++;\n+        }\n+        secp256k1_num_set_int(&t, v);\n+        secp256k1_num_add(&x, &x, &t);\n+    }\n+    CHECK(secp256k1_num_eq(&x, number)); // check that wnaf represents number\n+}\n+\n+void run_wnaf() {\n+    secp256k1_num_t n;\n+    for (int i=0; i<count; i++) {\n+        random_num_order(&n);\n+        if (i % 1)\n+            secp256k1_num_negate(&n);\n+        test_wnaf(&n, 4+(i%10));\n+    }\n+}\n+\n+void random_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *key, const secp256k1_scalar_t *msg, int *recid) {\n+    secp256k1_scalar_t nonce;\n+    do {\n+        random_scalar_order_test(&nonce);\n+    } while(!secp256k1_ecdsa_sig_sign(sig, key, msg, &nonce, recid));\n+}\n+\n+void test_ecdsa_sign_verify() {\n+    secp256k1_scalar_t msg, key;\n+    random_scalar_order_test(&msg);\n+    random_scalar_order_test(&key);\n+    secp256k1_gej_t pubj; secp256k1_ecmult_gen(&pubj, &key);\n+    secp256k1_ge_t pub; secp256k1_ge_set_gej(&pub, &pubj);\n+    secp256k1_ecdsa_sig_t sig;\n+    random_sign(&sig, &key, &msg, NULL);\n+    secp256k1_num_t msg_num;\n+    secp256k1_scalar_get_num(&msg_num, &msg);\n+    CHECK(secp256k1_ecdsa_sig_verify(&sig, &pub, &msg_num));\n+    secp256k1_num_inc(&msg_num);\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &pub, &msg_num));\n+}\n+\n+void run_ecdsa_sign_verify() {\n+    for (int i=0; i<10*count; i++) {\n+        test_ecdsa_sign_verify();\n+    }\n+}\n+\n+void test_ecdsa_end_to_end() {\n+    unsigned char privkey[32];\n+    unsigned char message[32];\n+\n+    // Generate a random key and message.\n+    {\n+        secp256k1_num_t msg, key;\n+        random_num_order_test(&msg);\n+        random_num_order_test(&key);\n+        secp256k1_num_get_bin(privkey, 32, &key);\n+        secp256k1_num_get_bin(message, 32, &msg);\n+    }\n+\n+    // Construct and verify corresponding public key.\n+    CHECK(secp256k1_ec_seckey_verify(privkey) == 1);\n+    unsigned char pubkey[65]; int pubkeylen = 65;\n+    CHECK(secp256k1_ec_pubkey_create(pubkey, &pubkeylen, privkey, secp256k1_rand32() % 2) == 1);\n+    CHECK(secp256k1_ec_pubkey_verify(pubkey, pubkeylen));\n+\n+    // Verify private key import and export.\n+    unsigned char seckey[300]; int seckeylen = 300;\n+    CHECK(secp256k1_ec_privkey_export(privkey, seckey, &seckeylen, secp256k1_rand32() % 2) == 1);\n+    unsigned char privkey2[32];\n+    CHECK(secp256k1_ec_privkey_import(privkey2, seckey, seckeylen) == 1);\n+    CHECK(memcmp(privkey, privkey2, 32) == 0);\n+\n+    // Optionally tweak the keys using addition.\n+    if (secp256k1_rand32() % 3 == 0) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        int ret1 = secp256k1_ec_privkey_tweak_add(privkey, rnd);\n+        int ret2 = secp256k1_ec_pubkey_tweak_add(pubkey, pubkeylen, rnd);\n+        CHECK(ret1 == ret2);\n+        if (ret1 == 0) return;\n+        unsigned char pubkey2[65]; int pubkeylen2 = 65;\n+        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n+    }\n+\n+    // Optionally tweak the keys using multiplication.\n+    if (secp256k1_rand32() % 3 == 0) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        int ret1 = secp256k1_ec_privkey_tweak_mul(privkey, rnd);\n+        int ret2 = secp256k1_ec_pubkey_tweak_mul(pubkey, pubkeylen, rnd);\n+        CHECK(ret1 == ret2);\n+        if (ret1 == 0) return;\n+        unsigned char pubkey2[65]; int pubkeylen2 = 65;\n+        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n+    }\n+\n+    // Sign.\n+    unsigned char signature[72]; int signaturelen = 72;\n+    while(1) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        if (secp256k1_ecdsa_sign(message, 32, signature, &signaturelen, privkey, rnd) == 1) {\n+            break;\n+        }\n+    }\n+    // Verify.\n+    CHECK(secp256k1_ecdsa_verify(message, 32, signature, signaturelen, pubkey, pubkeylen) == 1);\n+    // Destroy signature and verify again.\n+    signature[signaturelen - 1 - secp256k1_rand32() % 20] += 1 + (secp256k1_rand32() % 255);\n+    CHECK(secp256k1_ecdsa_verify(message, 32, signature, signaturelen, pubkey, pubkeylen) != 1);\n+\n+    // Compact sign.\n+    unsigned char csignature[64]; int recid = 0;\n+    while(1) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        if (secp256k1_ecdsa_sign_compact(message, 32, csignature, privkey, rnd, &recid) == 1) {\n+            break;\n+        }\n+    }\n+    // Recover.\n+    unsigned char recpubkey[65]; int recpubkeylen = 0;\n+    CHECK(secp256k1_ecdsa_recover_compact(message, 32, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) == 1);\n+    CHECK(recpubkeylen == pubkeylen);\n+    CHECK(memcmp(pubkey, recpubkey, pubkeylen) == 0);\n+    // Destroy signature and verify again.\n+    csignature[secp256k1_rand32() % 64] += 1 + (secp256k1_rand32() % 255);\n+    CHECK(secp256k1_ecdsa_recover_compact(message, 32, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) != 1 ||\n+          memcmp(pubkey, recpubkey, pubkeylen) != 0);\n+    CHECK(recpubkeylen == pubkeylen);\n+\n+}\n+\n+void run_ecdsa_end_to_end() {\n+    for (int i=0; i<64*count; i++) {\n+        test_ecdsa_end_to_end();\n+    }\n+}\n+\n+\n+#ifdef ENABLE_OPENSSL_TESTS\n+EC_KEY *get_openssl_key(const secp256k1_scalar_t *key) {\n+    unsigned char privkey[300];\n+    int privkeylen;\n+    int compr = secp256k1_rand32() & 1;\n+    const unsigned char* pbegin = privkey;\n+    EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    CHECK(secp256k1_eckey_privkey_serialize(privkey, &privkeylen, key, compr));\n+    CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n+    CHECK(EC_KEY_check_key(ec_key));\n+    return ec_key;\n+}\n+\n+void test_ecdsa_openssl() {\n+    secp256k1_scalar_t key, msg;\n+    unsigned char message[32];\n+    secp256k1_rand256_test(message);\n+    secp256k1_scalar_set_b32(&msg, message, NULL);\n+    random_scalar_order_test(&key);\n+    secp256k1_gej_t qj;\n+    secp256k1_ecmult_gen(&qj, &key);\n+    secp256k1_ge_t q;\n+    secp256k1_ge_set_gej(&q, &qj);\n+    EC_KEY *ec_key = get_openssl_key(&key);\n+    CHECK(ec_key);\n+    unsigned char signature[80];\n+    unsigned int sigsize = 80;\n+    CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n+    secp256k1_ecdsa_sig_t sig;\n+    CHECK(secp256k1_ecdsa_sig_parse(&sig, signature, sigsize));\n+    secp256k1_num_t msg_num;\n+    secp256k1_scalar_get_num(&msg_num, &msg);\n+    CHECK(secp256k1_ecdsa_sig_verify(&sig, &q, &msg_num));\n+    secp256k1_num_inc(&sig.r);\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &q, &msg_num));\n+\n+    random_sign(&sig, &key, &msg, NULL);\n+    int secp_sigsize = 80;\n+    CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sig));\n+    CHECK(ECDSA_verify(0, message, sizeof(message), signature, secp_sigsize, ec_key) == 1);\n+\n+    EC_KEY_free(ec_key);\n+}\n+\n+void run_ecdsa_openssl() {\n+    for (int i=0; i<10*count; i++) {\n+        test_ecdsa_openssl();\n+    }\n+}\n+#endif\n+\n+int main(int argc, char **argv) {\n+    // find iteration count\n+    if (argc > 1) {\n+        count = strtol(argv[1], NULL, 0);\n+    }\n+\n+    // find random seed\n+    uint64_t seed;\n+    if (argc > 2) {\n+        seed = strtoull(argv[2], NULL, 0);\n+    } else {\n+        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        if (!frand || !fread(&seed, sizeof(seed), 1, frand)) {\n+            seed = time(NULL) * 1337;\n+        }\n+        fclose(frand);\n+    }\n+    secp256k1_rand_seed(seed);\n+\n+    printf(\"test count = %i\\n\", count);\n+    printf(\"random seed = %llu\\n\", (unsigned long long)seed);\n+\n+    // initialize\n+    secp256k1_start(SECP256K1_START_SIGN | SECP256K1_START_VERIFY);\n+\n+    // num tests\n+    run_num_smalltests();\n+\n+    // scalar tests\n+    run_scalar_tests();\n+\n+    // field tests\n+    run_field_inv();\n+    run_field_inv_var();\n+    run_field_inv_all();\n+    run_field_inv_all_var();\n+    run_sqr();\n+    run_sqrt();\n+\n+    // ecmult tests\n+    run_wnaf();\n+    run_point_times_order();\n+    run_ecmult_chain();\n+\n+    // ecdsa tests\n+    run_ecdsa_sign_verify();\n+    run_ecdsa_end_to_end();\n+#ifdef ENABLE_OPENSSL_TESTS\n+    run_ecdsa_openssl();\n+#endif\n+\n+    printf(\"random run = %llu\\n\", (unsigned long long)secp256k1_rand32() + ((unsigned long long)secp256k1_rand32() << 32));\n+\n+    // shutdown\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "0ab3d217738169767e980b07cb20ec3be31bfa6c",
        "filename": "src/util.h",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_UTIL_H_\n+#define _SECP256K1_UTIL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+#define TEST_FAILURE(msg) do { \\\n+    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, msg); \\\n+    abort(); \\\n+} while(0)\n+\n+#ifndef HAVE_BUILTIN_EXPECT\n+#define EXPECT(x,c) __builtin_expect((x),(c))\n+#else\n+#define EXPECT(x,c) (x)\n+#endif\n+\n+#define CHECK(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        TEST_FAILURE(\"test condition failed: \" #cond); \\\n+    } \\\n+} while(0)\n+\n+// Like assert(), but safe to use on expressions with side effects.\n+#ifndef NDEBUG\n+#define DEBUG_CHECK CHECK\n+#else\n+#define DEBUG_CHECK(cond) do { (void)(cond); } while(0)\n+#endif\n+\n+// Like DEBUG_CHECK(), but when VERIFY is defined instead of NDEBUG not defined.\n+#ifdef VERIFY\n+#define VERIFY_CHECK CHECK\n+#else\n+#define VERIFY_CHECK(cond) do { (void)(cond); } while(0)\n+#endif\n+\n+/** Seed the pseudorandom number generator. */\n+static inline void secp256k1_rand_seed(uint64_t v);\n+\n+/** Generate a pseudorandom 32-bit number. */\n+static uint32_t secp256k1_rand32(void);\n+\n+/** Generate a pseudorandom 32-byte array. */\n+static void secp256k1_rand256(unsigned char *b32);\n+\n+/** Generate a pseudorandom 32-byte array with long sequences of zero and one bits. */\n+static void secp256k1_rand256_test(unsigned char *b32);\n+\n+#endif"
      },
      {
        "sha": "482fb31b1a87c7e7d1c88bee6e0c25840be6be25",
        "filename": "src/util_impl.h",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/util_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4d66b1c24c601191bfb13c34bd759767c05b10b/src/util_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util_impl.h?ref=a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_UTIL_IMPL_H_\n+#define _SECP256K1_UTIL_IMPL_H_\n+\n+#include <stdint.h>\n+#include <string.h>\n+\n+#include \"util.h\"\n+\n+static uint32_t secp256k1_Rz = 11, secp256k1_Rw = 11;\n+\n+static inline void secp256k1_rand_seed(uint64_t v) {\n+    secp256k1_Rz = v >> 32;\n+    secp256k1_Rw = v;\n+\n+    if (secp256k1_Rz == 0 || secp256k1_Rz == 0x9068ffffU) {\n+        secp256k1_Rz = 111;\n+    }\n+    if (secp256k1_Rw == 0 || secp256k1_Rw == 0x464fffffU) {\n+        secp256k1_Rw = 111;\n+    }\n+}\n+\n+static inline uint32_t secp256k1_rand32(void) {\n+    secp256k1_Rz = 36969 * (secp256k1_Rz & 0xFFFF) + (secp256k1_Rz >> 16);\n+    secp256k1_Rw = 18000 * (secp256k1_Rw & 0xFFFF) + (secp256k1_Rw >> 16);\n+    return (secp256k1_Rw << 16) + (secp256k1_Rw >> 16) + secp256k1_Rz;\n+}\n+\n+static void secp256k1_rand256(unsigned char *b32) {\n+    for (int i=0; i<8; i++) {\n+        uint32_t r = secp256k1_rand32();\n+        b32[i*4 + 0] = (r >>  0) & 0xFF;\n+        b32[i*4 + 1] = (r >>  8) & 0xFF;\n+        b32[i*4 + 2] = (r >> 16) & 0xFF;\n+        b32[i*4 + 3] = (r >> 24) & 0xFF;\n+    }\n+}\n+\n+static void secp256k1_rand256_test(unsigned char *b32) {\n+    int bits=0;\n+    memset(b32, 0, 32);\n+    while (bits < 256) {\n+        uint32_t ent = secp256k1_rand32();\n+        int now = 1 + ((ent % 64)*((ent >> 6) % 32)+16)/31;\n+        uint32_t val = 1 & (ent >> 11);\n+        while (now > 0 && bits < 256) {\n+            b32[bits / 8] |= val << (bits % 8);\n+            now--;\n+            bits++;\n+        }\n+    }\n+}\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "dc721adcbe29128831cdd68e688f8496674f6a7d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYzcyMWFkY2JlMjkxMjg4MzFjZGQ2OGU2ODhmODQ5NjY3NGY2YTdk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "message": "Delete src/secp256k1 before import",
      "tree": {
        "sha": "b0e0b189958871c1be1ecffe3a232d10a35dfe2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b0e0b189958871c1be1ecffe3a232d10a35dfe2d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc721adcbe29128831cdd68e688f8496674f6a7d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc721adcbe29128831cdd68e688f8496674f6a7d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dc721adcbe29128831cdd68e688f8496674f6a7d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc721adcbe29128831cdd68e688f8496674f6a7d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11d3b9939c98381d2246a3299a9cab5ced55e49e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/11d3b9939c98381d2246a3299a9cab5ced55e49e"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/secp256k1/.empty",
        "status": "removed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/secp256k1/.empty",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11d3b9939c98381d2246a3299a9cab5ced55e49e/src/secp256k1/.empty",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.empty?ref=11d3b9939c98381d2246a3299a9cab5ced55e49e"
      }
    ]
  },
  {
    "sha": "ac0aba4193df1884b203ad29c3a60e257811b553",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYzBhYmE0MTkzZGYxODg0YjIwM2FkMjljM2E2MGUyNTc4MTFiNTUz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:17Z"
      },
      "message": "Merge commit 'a4d66b1c24c601191bfb13c34bd759767c05b10b' as 'src/secp256k1'",
      "tree": {
        "sha": "ab834fcd49af3240514e2f843bfd5c17c4aaf5e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab834fcd49af3240514e2f843bfd5c17c4aaf5e7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ac0aba4193df1884b203ad29c3a60e257811b553",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac0aba4193df1884b203ad29c3a60e257811b553",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ac0aba4193df1884b203ad29c3a60e257811b553",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac0aba4193df1884b203ad29c3a60e257811b553/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc721adcbe29128831cdd68e688f8496674f6a7d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc721adcbe29128831cdd68e688f8496674f6a7d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc721adcbe29128831cdd68e688f8496674f6a7d"
      },
      {
        "sha": "a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4d66b1c24c601191bfb13c34bd759767c05b10b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a4d66b1c24c601191bfb13c34bd759767c05b10b"
      }
    ],
    "stats": {
      "total": 7372,
      "additions": 7372,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1d16cfcc1217ac6828c64760dcd21d70b7906bc2",
        "filename": "src/secp256k1/.gitignore",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,35 @@\n+bench_inv\n+bench_sign\n+bench_verify\n+tests\n+*.exe\n+*.so\n+*.a\n+!.gitignore\n+\n+Makefile\n+configure\n+.libs/\n+Makefile.in\n+aclocal.m4\n+autom4te.cache/\n+config.log\n+config.status\n+*.tar.gz\n+*.la\n+libtool\n+.deps/\n+.dirstamp\n+src/build-aux/\n+*.lo\n+*.o\n+*~\n+src/libsecp256k1-config.h\n+src/libsecp256k1-config.h.in\n+m4/libtool.m4\n+m4/ltoptions.m4\n+m4/ltsugar.m4\n+m4/ltversion.m4\n+m4/lt~obsolete.m4\n+src/stamp-h1\n+libsecp256k1.pc"
      },
      {
        "sha": "cbafed7a587c2fd0d856b65950f1858406442067",
        "filename": "src/secp256k1/.travis.yml",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,24 @@\n+language: cpp\n+compiler: gcc\n+install:\n+  - sudo apt-get install -qq libssl-dev\n+  - if [ \"$BIGNUM\" = \"gmp\" -o \"$BIGNUM\" = \"auto\" -o \"$FIELD\" = \"gmp\" ]; then sudo apt-get install -qq libgmp-dev; fi\n+  - if [ \"$FIELD\" = \"64bit_asm\" ]; then sudo apt-get install -qq yasm; fi\n+env:\n+  global:\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  BUILD=check\n+  matrix:\n+    - SCALAR=32bit\n+    - SCALAR=64bit\n+    - FIELD=gmp\n+    - FIELD=gmp       ENDOMORPHISM=yes\n+    - FIELD=64bit_asm\n+    - FIELD=64bit_asm ENDOMORPHISM=yes\n+    - FIELD=64bit\n+    - FIELD=64bit     ENDOMORPHISM=yes\n+    - FIELD=32bit\n+    - FIELD=32bit     ENDOMORPHISM=yes\n+    - BUILD=distcheck\n+before_script: ./autogen.sh\n+script: ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR && make -j2 $BUILD\n+os: linux"
      },
      {
        "sha": "4522a5990e2823f2be0db7efcbc4fca139c08025",
        "filename": "src/secp256k1/COPYING",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/COPYING",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/COPYING",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/COPYING?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,19 @@\n+Copyright (c) 2013 Pieter Wuille\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
      },
      {
        "sha": "7f16ef40b0225803e9fe5ad0e0a6f03ad3008270",
        "filename": "src/secp256k1/Makefile.am",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,87 @@\n+ACLOCAL_AMFLAGS = -I m4\n+INCLUDES = $(SECP_INCLUDES)\n+lib_LTLIBRARIES = libsecp256k1.la\n+if USE_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+else\n+COMMON_LIB =\n+endif\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+include_HEADERS = include/secp256k1.h\n+noinst_HEADERS =\n+noinst_HEADERS += src/scalar.h\n+noinst_HEADERS += src/scalar_4x64.h\n+noinst_HEADERS += src/scalar_8x32.h\n+noinst_HEADERS += src/scalar_impl.h\n+noinst_HEADERS += src/scalar_4x64_impl.h\n+noinst_HEADERS += src/scalar_8x32_impl.h\n+noinst_HEADERS += src/group.h\n+noinst_HEADERS += src/group_impl.h\n+noinst_HEADERS += src/num_gmp.h\n+noinst_HEADERS += src/num_gmp_impl.h\n+noinst_HEADERS += src/ecdsa.h\n+noinst_HEADERS += src/ecdsa_impl.h\n+noinst_HEADERS += src/eckey.h\n+noinst_HEADERS += src/eckey_impl.h\n+noinst_HEADERS += src/ecmult.h\n+noinst_HEADERS += src/ecmult_impl.h\n+noinst_HEADERS += src/ecmult_gen.h\n+noinst_HEADERS += src/ecmult_gen_impl.h\n+noinst_HEADERS += src/num.h\n+noinst_HEADERS += src/num_impl.h\n+noinst_HEADERS += src/field_10x26.h\n+noinst_HEADERS += src/field_10x26_impl.h\n+noinst_HEADERS += src/field_5x52.h\n+noinst_HEADERS += src/field_5x52_impl.h\n+noinst_HEADERS += src/field_5x52_int128_impl.h\n+noinst_HEADERS += src/field_5x52_asm_impl.h\n+noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/util.h\n+noinst_HEADERS += src/util_impl.h\n+noinst_HEADERS += src/field_gmp.h\n+noinst_HEADERS += src/field_gmp_impl.h\n+noinst_HEADERS += src/field.h\n+noinst_HEADERS += src/field_impl.h\n+\n+pkgconfigdir = $(libdir)/pkgconfig\n+pkgconfig_DATA = libsecp256k1.pc\n+\n+if USE_ASM\n+libsecp256k1_common_la_SOURCES = src/field_5x52_asm.asm\n+endif\n+\n+libsecp256k1_la_SOURCES = src/secp256k1.c\n+libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(COMMON_LIB) $(SECP_LIBS)\n+\n+\n+noinst_PROGRAMS =\n+if USE_BENCHMARK\n+noinst_PROGRAMS += bench_verify bench_sign bench_inv\n+bench_verify_SOURCES = src/bench_verify.c\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDFLAGS = -static\n+bench_sign_SOURCES = src/bench_sign.c\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDFLAGS = -static\n+bench_inv_SOURCES = src/bench_inv.c\n+bench_inv_LDADD = $(COMMON_LIB) $(SECP_LIBS)\n+bench_inv_LDFLAGS = -static\n+endif\n+\n+if USE_TESTS\n+noinst_PROGRAMS += tests\n+tests_SOURCES = src/tests.c\n+tests_CPPFLAGS = -DVERIFY $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(COMMON_LIB) $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_LDFLAGS = -static\n+TESTS = tests\n+endif\n+\n+EXTRA_DIST = autogen.sh nasm_lt.sh\n+\n+#x86_64 only\n+if USE_ASM\n+.asm.lo:\n+\t$(LIBTOOL) --mode=compile --tag YASM $(srcdir)/nasm_lt.sh $(YASM) -f $(YASM_BINFMT) $(YAFLAGS) -I$(srcdir) -I. $< -o $@\n+endif"
      },
      {
        "sha": "32750bde9249cb2d3e592316165998383ac525b5",
        "filename": "src/secp256k1/README.md",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,49 @@\n+libsecp256k1\n+============\n+\n+[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+\n+Optimized C library for EC operations on curve secp256k1.\n+\n+This library is experimental, so use at your own risk.\n+\n+Features:\n+* Low-level field and group operations on secp256k1.\n+* ECDSA signing/verification and key generation.\n+* Adding/multiplying private/public keys.\n+* Serialization/parsing of private keys, public keys, signatures.\n+* Very efficient implementation.\n+\n+Implementation details\n+----------------------\n+\n+* General\n+  * Avoid dynamic memory usage almost everywhere.\n+* Field operations\n+  * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n+    * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n+    * Using 10 26-bit limbs.\n+    * Using GMP.\n+  * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n+* Group operations\n+  * Point addition formula specifically simplified for the curve equation (y^2 = x^3 + 7).\n+  * Use addition between points in Jacobian and affine coordinates where possible.\n+* Point multiplication for verification (a*P + b*G).\n+  * Use wNAF notation for point multiplicands.\n+  * Use a much larger window for multiples of G, using precomputed multiples.\n+  * Use Shamir's trick to do the multiplication with the public key and the generator simultaneously.\n+  * Optionally use secp256k1's efficiently-computable endomorphism to split the multiplicands into 4 half-sized ones first.\n+* Point multiplication for signing\n+  * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n+  * Slice the precomputed table in memory per byte, so memory access to the table becomes uniform.\n+  * Not fully constant-time, but the precomputed tables add and eventually subtract points for which no known scalar (private key) is known, blinding non-constant time effects even from an attacker with control over the private key used.\n+\n+Build steps\n+-----------\n+\n+libsecp256k1 is built using autotools:\n+\n+    $ ./autogen.sh\n+    $ ./configure\n+    $ make\n+    $ sudo make install  # optional"
      },
      {
        "sha": "a300e1c5eb9b1376c82b1f5d557d56be5708546f",
        "filename": "src/secp256k1/TODO",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/TODO",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/TODO",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/TODO?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,3 @@\n+* Unit tests for fieldelem/groupelem, including ones intended to\n+  trigger fieldelem's boundary cases.\n+* Complete constant-time operations for signing/keygen"
      },
      {
        "sha": "4e7cc05373fcf90aaa10d64f20e6cc7ef1825cd0",
        "filename": "src/secp256k1/autogen.sh",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/autogen.sh?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,2 @@\n+#!/bin/sh\n+autoreconf -if"
      },
      {
        "sha": "c22669002ceab8f3814c72f2ec02c77e71527048",
        "filename": "src/secp256k1/configure.ac",
        "status": "added",
        "additions": 336,
        "deletions": 0,
        "changes": 336,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,336 @@\n+AC_PREREQ([2.60])\n+AC_INIT([libsecp256k1],[0.1])\n+AC_CONFIG_AUX_DIR([src/build-aux])\n+AC_CONFIG_MACRO_DIR([m4])\n+AC_CANONICAL_HOST\n+AH_TOP([#ifndef LIBSECP256K1_CONFIG_H])\n+AH_TOP([#define LIBSECP256K1_CONFIG_H])\n+AH_BOTTOM([#endif //LIBSECP256K1_CONFIG_H])\n+AM_INIT_AUTOMAKE([foreign])\n+LT_INIT\n+\n+dnl make the compilation flags quiet unless V=1 is used\n+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n+\n+AC_PROG_CC\n+AC_PROG_CPP\n+AC_PROG_INSTALL\n+AC_PROG_SED\n+PKG_PROG_PKG_CONFIG\n+\n+AC_PATH_TOOL(AR, ar)\n+AC_PATH_TOOL(RANLIB, ranlib)\n+AC_PATH_TOOL(STRIP, strip)\n+\n+AC_PROG_CC_C99\n+if test x\"$ac_cv_prog_cc_c99\" == x\"no\"; then\n+  AC_MSG_ERROR([c99 compiler support required])\n+fi\n+\n+case $host in\n+  *mingw*)\n+     use_pkgconfig=no\n+     ;;\n+   *)\n+     use_pkgconfig=yes\n+     ;;\n+esac\n+\n+case $host_os in\n+  darwin*)\n+     CPPFLAGS=\"$CPPFLAGS -I/opt/local/include\"\n+     LDFLAGS=\"$LDFLAGS -L/opt/local/lib\"\n+     ;;\n+esac\n+\n+AC_ARG_ENABLE(benchmark,\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    [use_benchmark=$enableval],\n+    [use_benchmark=yes])\n+\n+AC_ARG_ENABLE(tests,\n+    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    [use_tests=$enableval],\n+    [use_tests=yes])\n+\n+AC_ARG_ENABLE(endomorphism,\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    [use_endomorphism=$enableval],\n+    [use_endomorphism=no])\n+\n+AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=gmp|64bit|64bit_asm|32bit|auto],\n+[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+\n+AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|auto],\n+[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+\n+AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n+[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_CHECK_TYPES([__int128])\n+\n+AC_DEFUN([SECP_INT128_CHECK],[\n+has_int128=$ac_cv_type___int128\n+if test x\"$has_int128\" != x\"yes\" && test x\"$set_field\" = x\"64bit\"; then\n+  AC_MSG_ERROR([$set_field field support explicitly requested but is not compatible with this host])\n+fi\n+if test x\"$has_int128\" != x\"yes\" && test x\"$set_scalar\" = x\"64bit\"; then\n+  AC_MSG_ERROR([$set_scalar scalar support explicitly requested but is not compatible with this host])\n+fi\n+])\n+\n+AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n+if test x\"$host_cpu\" == x\"x86_64\"; then\n+  AC_CHECK_PROG(YASM, yasm, yasm)\n+else\n+  if test x\"$set_field\" = x\"64bit_asm\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but is not compatible with this host])\n+  fi\n+fi\n+if test x$YASM = x; then\n+  if test x\"$set_field\" = x\"64bit_asm\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but yasm was not found])\n+  fi\n+  has_64bit_asm=no\n+else\n+  case x\"$host_os\" in\n+  xdarwin*)\n+    YASM_BINFMT=macho64\n+    ;;\n+  x*-gnux32)\n+    YASM_BINFMT=elfx32\n+    ;;\n+  *)\n+    YASM_BINFMT=elf64\n+    ;;\n+  esac\n+  if $YASM -f help | grep -q $YASM_BINFMT; then\n+    has_64bit_asm=yes\n+  else\n+    if test x\"$set_field\" = x\"64bit_asm\"; then\n+      AC_MSG_ERROR([$set_field field support explicitly requested but yasm doesn't support $YASM_BINFMT format])\n+    fi\n+    AC_MSG_WARN([yasm too old for $YASM_BINFMT format])\n+    has_64bit_asm=no\n+  fi\n+fi\n+])\n+\n+AC_DEFUN([SECP_OPENSSL_CHECK],[\n+if test x\"$use_pkgconfig\" = x\"yes\"; then\n+    : #NOP\n+  m4_ifdef([PKG_CHECK_MODULES],[\n+    PKG_CHECK_MODULES([CRYPTO], [libcrypto], [has_libcrypto=yes; AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])],[has_libcrypto=no])\n+    : #NOP\n+  ])\n+else\n+  AC_CHECK_HEADER(openssl/crypto.h,[AC_CHECK_LIB(crypto, main,[has_libcrypto=yes; CRYPTO_LIBS=-lcrypto; AC_DEFINE(HAVE_LIBCRYPTO,1,[Define this symbol if libcrypto is installed])]\n+)])\n+  LIBS=\n+fi\n+if test x\"$has_libcrypto\" == x\"yes\" && test x\"$has_openssl_ec\" = x; then\n+  AC_MSG_CHECKING(for EC functions in libcrypto)\n+  AC_TRY_COMPILE([\n+    #include <openssl/ec.h>\n+    #include <openssl/ecdsa.h>\n+    #include <openssl/obj_mac.h>],[\n+    EC_KEY *eckey = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    ECDSA_sign(0, NULL, 0, NULL, NULL, eckey);\n+    ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n+    EC_KEY_free(eckey);\n+  ],[has_openssl_ec=yes], [has_openssl_ec=no])\n+  AC_MSG_RESULT([$has_openssl_ec])\n+fi\n+])\n+\n+AC_CHECK_DECL(__builtin_expect,AC_DEFINE(HAVE_BUILTIN_EXPECT,1,[Define this symbol if __builtin_expect is available]),,)\n+\n+AC_DEFUN([SECP_GMP_CHECK],[\n+if test x\"$has_gmp\" != x\"yes\"; then\n+  AC_CHECK_HEADER(gmp.h,[AC_CHECK_LIB(gmp, __gmpz_init,[has_gmp=yes; GMP_LIBS=-lgmp; AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])])])\n+fi\n+if test x\"$set_field\" = x\"gmp\" && test x\"$has_gmp\" != x\"yes\"; then\n+    AC_MSG_ERROR([$set_field field support explicitly requested but libgmp was not found])\n+fi\n+if test x\"$set_bignum\" = x\"gmp\" && test x\"$has_gmp\" != x\"yes\"; then\n+    AC_MSG_ERROR([$set_bignum field support explicitly requested but libgmp was not found])\n+fi\n+])\n+\n+if test x\"$req_field\" = x\"auto\"; then\n+  SECP_64BIT_ASM_CHECK\n+  if test x\"$has_64bit_asm\" = x\"yes\"; then\n+    set_field=64bit_asm\n+  fi\n+\n+  if test x\"$set_field\" = x; then\n+    SECP_INT128_CHECK\n+    if test x\"$has_int128\" = x\"yes\"; then\n+      set_field=64bit\n+    fi\n+  fi\n+\n+  if test x\"$set_field\" = x; then\n+    SECP_GMP_CHECK\n+    if test x\"$has_gmp\" = x\"yes\"; then\n+      set_field=gmp\n+    fi\n+  fi\n+\n+  if test x\"$set_field\" = x; then\n+    set_field=32bit\n+  fi\n+else\n+  set_field=$req_field\n+  case $set_field in\n+  64bit_asm)\n+    SECP_64BIT_ASM_CHECK\n+    ;;\n+  64bit)\n+    SECP_INT128_CHECK\n+    ;;\n+  gmp)\n+    SECP_GMP_CHECK\n+    ;;\n+  32bit)\n+    ;;\n+  *)\n+    AC_MSG_ERROR([invalid field implementation selection])\n+    ;;\n+  esac\n+fi\n+\n+if test x\"$req_scalar\" = x\"auto\"; then\n+  if test x\"$set_scalar\" = x; then\n+    SECP_INT128_CHECK\n+    if test x\"$has_int128\" = x\"yes\"; then\n+      set_scalar=64bit\n+    fi\n+  fi\n+  if test x\"$set_scalar\" = x; then\n+    set_scalar=32bit\n+  fi\n+else\n+  set_scalar=$req_scalar\n+  case $set_scalar in\n+  64bit)\n+    SECP_INT128_CHECK\n+    ;;\n+  32bit)\n+    ;;\n+  *)\n+    AC_MSG_ERROR([invalid scalar implementation selected])\n+    ;;\n+  esac\n+fi\n+\n+if test x\"$req_bignum\" = x\"auto\"; then\n+  SECP_GMP_CHECK\n+  if test x\"$has_gmp\" = x\"yes\"; then\n+    set_bignum=gmp\n+  fi\n+\n+  if test x\"$set_bignum\" = x; then\n+    AC_MSG_ERROR([no working bignum implementation found])\n+  fi\n+else\n+  set_bignum=$req_bignum\n+  case $set_bignum in\n+  gmp)\n+    SECP_GMP_CHECK\n+    ;;\n+  openssl)\n+    SECP_OPENSSL_CHECK\n+    ;;\n+  *)\n+    AC_MSG_ERROR([invalid bignum implementation selection])\n+    ;;\n+  esac\n+fi\n+\n+# select field implementation\n+case $set_field in\n+64bit_asm)\n+  AC_DEFINE(USE_FIELD_5X52_ASM, 1, [Define this symbol to use the assembly version for the 5x52 field implementation])\n+  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+  ;;\n+64bit)\n+  AC_DEFINE(USE_FIELD_5X52_INT128, 1, [Define this symbol to use the __int128 version for the 5x52 field implementation])\n+  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+  ;;\n+gmp)\n+  AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])\n+  AC_DEFINE(USE_FIELD_GMP, 1, [Define this symbol to use the FIELD_GMP implementation])\n+  ;;\n+32bit)\n+  AC_DEFINE(USE_FIELD_10X26, 1, [Define this symbol to use the FIELD_10X26 implementation])\n+  ;;\n+*)\n+  AC_MSG_ERROR([invalid field implementation])\n+  ;;\n+esac\n+\n+# select bignum implementation\n+case $set_bignum in\n+gmp)\n+  AC_DEFINE(HAVE_LIBGMP,1,[Define this symbol if libgmp is installed])\n+  AC_DEFINE(USE_NUM_GMP, 1, [Define this symbol to use the gmp implementation])\n+  AC_DEFINE(USE_FIELD_INV_NUM, 1, [Define this symbol to use the USE_FIELD_INV_NUM implementation])\n+  ;;\n+*)\n+  AC_MSG_ERROR([invalid bignum implementation])\n+  ;;\n+esac\n+\n+#select scalar implementation\n+case $set_scalar in\n+64bit)\n+  AC_DEFINE(USE_SCALAR_4X64, 1, [Define this symbol to use the 4x64 scalar implementation])\n+  ;;\n+32bit)\n+  AC_DEFINE(USE_SCALAR_8X32, 1, [Define this symbol to use the 8x32 scalar implementation])\n+  ;;\n+*)\n+  AC_MSG_ERROR([invalid scalar implementation])\n+  ;;\n+esac\n+\n+if test x\"$use_tests\" = x\"yes\"; then\n+  SECP_OPENSSL_CHECK\n+  if test x\"$has_openssl_ec\" == x\"yes\"; then\n+    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+    case $host in\n+    *mingw*)\n+      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+      ;;\n+    esac\n+\n+  fi\n+fi\n+\n+if test x\"$set_field\" = x\"gmp\" || test x\"$set_bignum\" = x\"gmp\"; then\n+  SECP_LIBS=\"$SECP_LIBS $GMP_LIBS\"\n+fi\n+\n+if test x\"$use_endomorphism\" = x\"yes\"; then\n+  AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism])\n+fi\n+\n+AC_MSG_NOTICE([Using field implementation: $set_field])\n+AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n+AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n+\n+AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n+AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(SECP_INCLUDES)\n+AC_SUBST(SECP_LIBS)\n+AC_SUBST(SECP_TEST_LIBS)\n+AC_SUBST(SECP_TEST_INCLUDES)\n+AC_SUBST(YASM_BINFMT)\n+AM_CONDITIONAL([USE_ASM], [test x\"$set_field\" == x\"64bit_asm\"])\n+AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" != x\"no\"])\n+AC_OUTPUT"
      },
      {
        "sha": "cb5fd3c8894abe8d8b8eda88ccfdf7559117d553",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "added",
        "additions": 150,
        "deletions": 0,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,150 @@\n+#ifndef _SECP256K1_\n+#define _SECP256K1_\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** Flags to pass to secp256k1_start. */\n+#define SECP256K1_START_VERIFY (1 << 0)\n+#define SECP256K1_START_SIGN   (1 << 1)\n+\n+/** Initialize the library. This may take some time (10-100 ms).\n+ *  You need to call this before calling any other function.\n+ *  It cannot run in parallel with any other functions, but once\n+ *  secp256k1_start() returns, all other functions are thread-safe.\n+ */\n+void secp256k1_start(unsigned int flags);\n+\n+/** Free all memory associated with this library. After this, no\n+ *  functions can be called anymore, except secp256k1_start()\n+ */\n+void secp256k1_stop(void);\n+\n+/** Verify an ECDSA signature.\n+ *  Returns: 1: correct signature\n+ *           0: incorrect signature\n+ *          -1: invalid public key\n+ *          -2: invalid signature\n+ * Requires starting using SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ecdsa_verify(const unsigned char *msg, int msglen,\n+                           const unsigned char *sig, int siglen,\n+                           const unsigned char *pubkey, int pubkeylen);\n+\n+/** Create an ECDSA signature.\n+ *  Returns: 1: signature created\n+ *           0: nonce invalid, try another one\n+ *  In:      msg:    the message being signed\n+ *           msglen: the length of the message being signed\n+ *           seckey: pointer to a 32-byte secret key (assumed to be valid)\n+ *           nonce:  pointer to a 32-byte nonce (generated with a cryptographic PRNG)\n+ *  Out:     sig:    pointer to a 72-byte array where the signature will be placed.\n+ *           siglen: pointer to an int, which will be updated to the signature length (<=72).\n+ * Requires starting using SECP256K1_START_SIGN.\n+ */\n+int secp256k1_ecdsa_sign(const unsigned char *msg, int msglen,\n+                         unsigned char *sig, int *siglen,\n+                         const unsigned char *seckey,\n+                         const unsigned char *nonce);\n+\n+/** Create a compact ECDSA signature (64 byte + recovery id).\n+ *  Returns: 1: signature created\n+ *           0: nonce invalid, try another one\n+ *  In:      msg:    the message being signed\n+ *           msglen: the length of the message being signed\n+ *           seckey: pointer to a 32-byte secret key (assumed to be valid)\n+ *           nonce:  pointer to a 32-byte nonce (generated with a cryptographic PRNG)\n+ *  Out:     sig:    pointer to a 64-byte array where the signature will be placed.\n+ *           recid:  pointer to an int, which will be updated to contain the recovery id.\n+ * Requires starting using SECP256K1_START_SIGN.\n+ */\n+int secp256k1_ecdsa_sign_compact(const unsigned char *msg, int msglen,\n+                                 unsigned char *sig64,\n+                                 const unsigned char *seckey,\n+                                 const unsigned char *nonce,\n+                                 int *recid);\n+\n+/** Recover an ECDSA public key from a compact signature.\n+ *  Returns: 1: public key succesfully recovered (which guarantees a correct signature).\n+ *           0: otherwise.\n+ *  In:      msg:        the message assumed to be signed\n+ *           msglen:     the length of the message\n+ *           sig64:      signature as 64 byte array\n+ *           compressed: whether to recover a compressed or uncompressed pubkey\n+ *           recid:      the recovery id (as returned by ecdsa_sign_compact)\n+ *  Out:     pubkey:     pointer to a 33 or 65 byte array to put the pubkey.\n+ *           pubkeylen:  pointer to an int that will contain the pubkey length.\n+ * Requires starting using SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ecdsa_recover_compact(const unsigned char *msg, int msglen,\n+                                    const unsigned char *sig64,\n+                                    unsigned char *pubkey, int *pubkeylen,\n+                                    int compressed, int recid);\n+\n+/** Verify an ECDSA secret key.\n+ *  Returns: 1: secret key is valid\n+ *           0: secret key is invalid\n+ *  In:      seckey: pointer to a 32-byte secret key\n+ */\n+int secp256k1_ec_seckey_verify(const unsigned char *seckey);\n+\n+/** Just validate a public key.\n+ *  Returns: 1: valid public key\n+ *           0: invalid public key\n+ */\n+int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen);\n+\n+/** Compute the public key for a secret key.\n+ *  In:     compressed: whether the computed public key should be compressed\n+ *          seckey:     pointer to a 32-byte private key.\n+ *  Out:    pubkey:     pointer to a 33-byte (if compressed) or 65-byte (if uncompressed)\n+ *                      area to store the public key.\n+ *          pubkeylen:  pointer to int that will be updated to contains the pubkey's\n+ *                      length.\n+ *  Returns: 1: secret was valid, public key stores\n+ *           0: secret was invalid, try again.\n+ * Requires starting using SECP256K1_START_SIGN.\n+ */\n+int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed);\n+\n+/** Decompress a public key.\n+ * In/Out: pubkey:    pointer to a 65-byte array to put the decompressed public key.\n+                      It must contain a 33-byte or 65-byte public key already.\n+ *         pubkeylen: pointer to the size of the public key pointed to be pubkey.\n+                      It will be updated to reflect the new size.\n+ * Returns: 0 if the passed public key was invalid, 1 otherwise. If 1 is returned, the\n+            pubkey is replaced with its decompressed version.\n+ */\n+int secp256k1_ec_pubkey_decompress(unsigned char *pubkey, int *pubkeylen);\n+\n+/** Export a private key in DER format. */\n+int secp256k1_ec_privkey_export(const unsigned char *seckey,\n+                                unsigned char *privkey, int *privkeylen,\n+                                int compressed);\n+\n+/** Import a private key in DER format. */\n+int secp256k1_ec_privkey_import(unsigned char *seckey,\n+                                const unsigned char *privkey, int privkeylen);\n+\n+/** Tweak a private key by adding tweak to it. */\n+int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *tweak);\n+\n+/** Tweak a public key by adding tweak times the generator to it.\n+ * Requires starting with SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak);\n+\n+/** Tweak a private key by multiplying it with tweak. */\n+int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *tweak);\n+\n+/** Tweak a public key by multiplying it with tweak.\n+ * Requires starting with SECP256K1_START_VERIFY.\n+ */\n+int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"
      },
      {
        "sha": "1c72dd00037b5cbef34d24792f809d700049e105",
        "filename": "src/secp256k1/libsecp256k1.pc.in",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/libsecp256k1.pc.in?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,13 @@\n+prefix=@prefix@\n+exec_prefix=@exec_prefix@\n+libdir=@libdir@\n+includedir=@includedir@\n+\n+Name: libsecp256k1\n+Description: Optimized C library for EC operations on curve secp256k1\n+URL: https://github.com/bitcoin/secp256k1\n+Version: @PACKAGE_VERSION@\n+Cflags: -I${includedir}\n+Libs.private: @SECP_LIBS@\n+Libs: -L${libdir} -lsecp256k1\n+"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/secp256k1/m4/.empty",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/m4/.empty",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/m4/.empty",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/m4/.empty?ref=ac0aba4193df1884b203ad29c3a60e257811b553"
      },
      {
        "sha": "6cd73294c0617c5d186926f1a7903afbde11044c",
        "filename": "src/secp256k1/nasm_lt.sh",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/nasm_lt.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/nasm_lt.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/nasm_lt.sh?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,57 @@\n+#! /bin/sh\n+command=\"\"\n+infile=\"\"\n+o_opt=no\n+pic=no\n+while [ $# -gt 0 ]; do\n+    case \"$1\" in\n+        -DPIC|-fPIC|-fpic|-Kpic|-KPIC)\n+            if [ \"$pic\" != \"yes\" ] ; then\n+                command=\"$command -DPIC\"\n+                pic=yes\n+            fi\n+            ;;\n+        -f|-fbin|-faout|-faoutb|-fcoff|-felf|-felf64|-fas86| \\\n+        -fobj|-fwin32|-fwin64|-frdf|-fieee|-fmacho|-fmacho64)\n+            # it's a file format specifier for nasm.\n+            command=\"$command $1\"\n+            ;;\n+        -f*)\n+            # maybe a code-generation flag for gcc.\n+            ;;\n+        -[Ii]*)\n+            incdir=`echo \"$1\" | sed 's/^-[Ii]//'`\n+            if [ \"x$incdir\" = x -a \"x$2\" != x ] ; then\n+                case \"$2\" in\n+                    -*) ;;\n+                    *) incdir=\"$2\"; shift;;\n+                esac\n+            fi\n+            if [ \"x$incdir\" != x ] ; then\n+                # In the case of NASM, the trailing slash is necessary.\n+                incdir=`echo \"$incdir\" | sed 's%/*$%/%'`\n+                command=\"$command -I$incdir\"\n+            fi\n+            ;;\n+        -o*)\n+            o_opt=yes\n+            command=\"$command $1\"\n+            ;;\n+        *.asm)\n+            infile=$1\n+            command=\"$command $1\"\n+            ;;\n+        *)\n+            command=\"$command $1\"\n+            ;;\n+    esac\n+    shift\n+done\n+if [ \"$o_opt\" != yes ] ; then\n+    # By default, NASM creates an output file\n+    # in the same directory as the input file.\n+    outfile=\"-o `echo $infile | sed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.o\"\n+    command=\"$command $outfile\"\n+fi\n+echo $command\n+exec $command"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/secp256k1/obj/.gitignore",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/obj/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/obj/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/obj/.gitignore?ref=ac0aba4193df1884b203ad29c3a60e257811b553"
      },
      {
        "sha": "d4b8777d5ce86e0540088393e3e2dcdae46de718",
        "filename": "src/secp256k1/src/bench_inv.c",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/bench_inv.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/bench_inv.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_inv.c?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,38 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+\n+#include \"util.h\"\n+#include \"num_impl.h\"\n+#include \"field_impl.h\"\n+#include \"group_impl.h\"\n+#include \"scalar_impl.h\"\n+\n+int main() {\n+    static const unsigned char init[32] = {\n+        0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13,\n+        0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,\n+        0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59,\n+        0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83\n+    };\n+    static const unsigned char fini[32] = {\n+        0xba, 0x28, 0x58, 0xd8, 0xaa, 0x11, 0xd6, 0xf2,\n+        0xfa, 0xce, 0x50, 0xb1, 0x67, 0x19, 0xb1, 0xa6,\n+        0xe0, 0xaa, 0x84, 0x53, 0xf6, 0x80, 0xfc, 0x23,\n+        0x88, 0x3c, 0xd6, 0x74, 0x9f, 0x27, 0x09, 0x03\n+    };\n+    secp256k1_ge_start();\n+    secp256k1_scalar_t base, x;\n+    secp256k1_scalar_set_b32(&base, init, NULL);\n+    secp256k1_scalar_set_b32(&x, init, NULL);\n+    for (int i=0; i<1000000; i++) {\n+        secp256k1_scalar_inverse(&x, &x);\n+        secp256k1_scalar_add(&x, &x, &base);\n+    }\n+    unsigned char res[32];\n+    secp256k1_scalar_get_b32(res, &x);\n+    CHECK(memcmp(res, fini, 32) == 0);\n+    return 0;\n+}"
      },
      {
        "sha": "3d8bfa1edb1ec822bcc78d4fc550a0fb609387dc",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,48 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+\n+int main() {\n+    secp256k1_start(SECP256K1_START_SIGN);\n+\n+    unsigned char msg[32];\n+    unsigned char nonce[32];\n+    unsigned char key[32];\n+\n+    for (int i = 0; i < 32; i++) msg[i] = i + 1;\n+    for (int i = 0; i < 32; i++) nonce[i] = i + 33;\n+    for (int i = 0; i < 32; i++) key[i] = i + 65;\n+\n+    unsigned char sig[64];\n+\n+    for (int i=0; i<1000000; i++) {\n+        int recid = 0;\n+        CHECK(secp256k1_ecdsa_sign_compact(msg, 32, sig, key, nonce, &recid));\n+        for (int j = 0; j < 32; j++) {\n+            nonce[j] = key[j];     // Move former key to nonce\n+            msg[j] = sig[j];       // Move former R to message.\n+            key[j] = sig[j + 32];  // Move former S to key.\n+        }\n+    }\n+\n+    static const unsigned char fini[64] = {\n+        0x92, 0x03, 0xef, 0xf1, 0x58, 0x0b, 0x49, 0x8d,\n+        0x22, 0x3d, 0x49, 0x0e, 0xbf, 0x26, 0x50, 0x0e,\n+        0x2d, 0x62, 0x90, 0xd7, 0x82, 0xbd, 0x3d, 0x5c,\n+        0xa9, 0x10, 0xa5, 0x49, 0xb1, 0xd8, 0x8c, 0xc0,\n+        0x5b, 0x5e, 0x9e, 0x68, 0x51, 0x3d, 0xe8, 0xec,\n+        0x82, 0x30, 0x82, 0x88, 0x8c, 0xfd, 0xe7, 0x71,\n+        0x15, 0x92, 0xfc, 0x14, 0x59, 0x78, 0x31, 0xb3,\n+        0xf6, 0x07, 0x91, 0x18, 0x00, 0x8d, 0x4c, 0xb2\n+    };\n+    CHECK(memcmp(sig, fini, 64) == 0);\n+\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "7c2084a4a425b60c8b41a07fe0bd048c467612c5",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,42 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+\n+int main() {\n+    secp256k1_start(SECP256K1_START_VERIFY);\n+\n+    unsigned char msg[32];\n+    unsigned char sig[64];\n+\n+    for (int i = 0; i < 32; i++) msg[i] = 1 + i;\n+    for (int i = 0; i < 64; i++) sig[i] = 65 + i;\n+\n+    unsigned char pubkey[33];\n+    for (int i=0; i<1000000; i++) {\n+        int pubkeylen = 33;\n+        CHECK(secp256k1_ecdsa_recover_compact(msg, 32, sig, pubkey, &pubkeylen, 1, i % 2));\n+        for (int j = 0; j < 32; j++) {\n+            sig[j + 32] = msg[j];    // Move former message to S.\n+            msg[j] = sig[j];         // Move former R to message.\n+            sig[j] = pubkey[j + 1];  // Move recovered pubkey X coordinate to R (which must be a valid X coordinate).\n+        }\n+    }\n+\n+    static const unsigned char fini[33] = {\n+        0x02,\n+        0x52, 0x63, 0xae, 0x9a, 0x9d, 0x47, 0x1f, 0x1a,\n+        0xb2, 0x36, 0x65, 0x89, 0x11, 0xe7, 0xcc, 0x86,\n+        0xa3, 0xab, 0x97, 0xb6, 0xf1, 0xaf, 0xfd, 0x8f,\n+        0x9b, 0x38, 0xb6, 0x18, 0x55, 0xe5, 0xc2, 0x43\n+    };\n+    CHECK(memcmp(fini, pubkey, 33) == 0);\n+\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "f74a0e76c92e849b88bbee3ccb9cb6078254c275",
        "filename": "src/secp256k1/src/ecdsa.h",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecdsa.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecdsa.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,21 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECDSA_\n+#define _SECP256K1_ECDSA_\n+\n+#include \"num.h\"\n+\n+typedef struct {\n+    secp256k1_num_t r, s;\n+} secp256k1_ecdsa_sig_t;\n+\n+int static secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned char *sig, int size);\n+int static secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const secp256k1_ecdsa_sig_t *a);\n+int static secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_num_t *message);\n+int static secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid);\n+int static secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_num_t *message, int recid);\n+void static secp256k1_ecdsa_sig_set_rs(secp256k1_ecdsa_sig_t *sig, const secp256k1_num_t *r, const secp256k1_num_t *s);\n+\n+#endif"
      },
      {
        "sha": "5a8fc4333af66bee05b7b4d48c2802cdbbd5eb07",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,180 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECDSA_IMPL_H_\n+#define _SECP256K1_ECDSA_IMPL_H_\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+#include \"group.h\"\n+#include \"ecmult.h\"\n+#include \"ecmult_gen.h\"\n+#include \"ecdsa.h\"\n+\n+int static secp256k1_ecdsa_sig_parse(secp256k1_ecdsa_sig_t *r, const unsigned char *sig, int size) {\n+    if (sig[0] != 0x30) return 0;\n+    int lenr = sig[3];\n+    if (5+lenr >= size) return 0;\n+    int lens = sig[lenr+5];\n+    if (sig[1] != lenr+lens+4) return 0;\n+    if (lenr+lens+6 > size) return 0;\n+    if (sig[2] != 0x02) return 0;\n+    if (lenr == 0) return 0;\n+    if (sig[lenr+4] != 0x02) return 0;\n+    if (lens == 0) return 0;\n+    secp256k1_num_set_bin(&r->r, sig+4, lenr);\n+    secp256k1_num_set_bin(&r->s, sig+6+lenr, lens);\n+    return 1;\n+}\n+\n+int static secp256k1_ecdsa_sig_serialize(unsigned char *sig, int *size, const secp256k1_ecdsa_sig_t *a) {\n+    int lenR = (secp256k1_num_bits(&a->r) + 7)/8;\n+    if (lenR == 0 || secp256k1_num_get_bit(&a->r, lenR*8-1))\n+        lenR++;\n+    int lenS = (secp256k1_num_bits(&a->s) + 7)/8;\n+    if (lenS == 0 || secp256k1_num_get_bit(&a->s, lenS*8-1))\n+        lenS++;\n+    if (*size < 6+lenS+lenR)\n+        return 0;\n+    *size = 6 + lenS + lenR;\n+    sig[0] = 0x30;\n+    sig[1] = 4 + lenS + lenR;\n+    sig[2] = 0x02;\n+    sig[3] = lenR;\n+    secp256k1_num_get_bin(sig+4, lenR, &a->r);\n+    sig[4+lenR] = 0x02;\n+    sig[5+lenR] = lenS;\n+    secp256k1_num_get_bin(sig+lenR+6, lenS, &a->s);\n+    return 1;\n+}\n+\n+int static secp256k1_ecdsa_sig_recompute(secp256k1_num_t *r2, const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_num_t *message) {\n+    const secp256k1_ge_consts_t *c = secp256k1_ge_consts;\n+\n+    if (secp256k1_num_is_neg(&sig->r) || secp256k1_num_is_neg(&sig->s))\n+        return 0;\n+    if (secp256k1_num_is_zero(&sig->r) || secp256k1_num_is_zero(&sig->s))\n+        return 0;\n+    if (secp256k1_num_cmp(&sig->r, &c->order) >= 0 || secp256k1_num_cmp(&sig->s, &c->order) >= 0)\n+        return 0;\n+\n+    int ret = 0;\n+    secp256k1_num_t sn, u1, u2;\n+    secp256k1_num_init(&sn);\n+    secp256k1_num_init(&u1);\n+    secp256k1_num_init(&u2);\n+    secp256k1_num_mod_inverse(&sn, &sig->s, &c->order);\n+    secp256k1_num_mod_mul(&u1, &sn, message, &c->order);\n+    secp256k1_num_mod_mul(&u2, &sn, &sig->r, &c->order);\n+    secp256k1_gej_t pubkeyj; secp256k1_gej_set_ge(&pubkeyj, pubkey);\n+    secp256k1_gej_t pr; secp256k1_ecmult(&pr, &pubkeyj, &u2, &u1);\n+    if (!secp256k1_gej_is_infinity(&pr)) {\n+        secp256k1_fe_t xr; secp256k1_gej_get_x_var(&xr, &pr);\n+        secp256k1_fe_normalize(&xr);\n+        unsigned char xrb[32]; secp256k1_fe_get_b32(xrb, &xr);\n+        secp256k1_num_set_bin(r2, xrb, 32);\n+        secp256k1_num_mod(r2, &c->order);\n+        ret = 1;\n+    }\n+    secp256k1_num_free(&sn);\n+    secp256k1_num_free(&u1);\n+    secp256k1_num_free(&u2);\n+    return ret;\n+}\n+\n+int static secp256k1_ecdsa_sig_recover(const secp256k1_ecdsa_sig_t *sig, secp256k1_ge_t *pubkey, const secp256k1_num_t *message, int recid) {\n+    const secp256k1_ge_consts_t *c = secp256k1_ge_consts;\n+\n+    if (secp256k1_num_is_neg(&sig->r) || secp256k1_num_is_neg(&sig->s))\n+        return 0;\n+    if (secp256k1_num_is_zero(&sig->r) || secp256k1_num_is_zero(&sig->s))\n+        return 0;\n+    if (secp256k1_num_cmp(&sig->r, &c->order) >= 0 || secp256k1_num_cmp(&sig->s, &c->order) >= 0)\n+        return 0;\n+\n+    secp256k1_num_t rx;\n+    secp256k1_num_init(&rx);\n+    secp256k1_num_copy(&rx, &sig->r);\n+    if (recid & 2) {\n+        secp256k1_num_add(&rx, &rx, &c->order);\n+        if (secp256k1_num_cmp(&rx, &secp256k1_fe_consts->p) >= 0)\n+            return 0;\n+    }\n+    unsigned char brx[32];\n+    secp256k1_num_get_bin(brx, 32, &rx);\n+    secp256k1_num_free(&rx);\n+    secp256k1_fe_t fx;\n+    secp256k1_fe_set_b32(&fx, brx);\n+    secp256k1_ge_t x;\n+    if (!secp256k1_ge_set_xo(&x, &fx, recid & 1))\n+        return 0;\n+    secp256k1_gej_t xj;\n+    secp256k1_gej_set_ge(&xj, &x);\n+    secp256k1_num_t rn, u1, u2;\n+    secp256k1_num_init(&rn);\n+    secp256k1_num_init(&u1);\n+    secp256k1_num_init(&u2);\n+    secp256k1_num_mod_inverse(&rn, &sig->r, &c->order);\n+    secp256k1_num_mod_mul(&u1, &rn, message, &c->order);\n+    secp256k1_num_sub(&u1, &c->order, &u1);\n+    secp256k1_num_mod_mul(&u2, &rn, &sig->s, &c->order);\n+    secp256k1_gej_t qj;\n+    secp256k1_ecmult(&qj, &xj, &u2, &u1);\n+    secp256k1_ge_set_gej_var(pubkey, &qj);\n+    secp256k1_num_free(&rn);\n+    secp256k1_num_free(&u1);\n+    secp256k1_num_free(&u2);\n+    return 1;\n+}\n+\n+int static secp256k1_ecdsa_sig_verify(const secp256k1_ecdsa_sig_t *sig, const secp256k1_ge_t *pubkey, const secp256k1_num_t *message) {\n+    secp256k1_num_t r2;\n+    secp256k1_num_init(&r2);\n+    int ret = 0;\n+    ret = secp256k1_ecdsa_sig_recompute(&r2, sig, pubkey, message) && secp256k1_num_cmp(&sig->r, &r2) == 0;\n+    secp256k1_num_free(&r2);\n+    return ret;\n+}\n+\n+int static secp256k1_ecdsa_sig_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *seckey, const secp256k1_scalar_t *message, const secp256k1_scalar_t *nonce, int *recid) {\n+    secp256k1_gej_t rp;\n+    secp256k1_ecmult_gen(&rp, nonce);\n+    secp256k1_ge_t r;\n+    secp256k1_ge_set_gej(&r, &rp);\n+    unsigned char b[32];\n+    secp256k1_fe_normalize(&r.x);\n+    secp256k1_fe_normalize(&r.y);\n+    secp256k1_fe_get_b32(b, &r.x);\n+    int overflow = 0;\n+    secp256k1_scalar_t sigr;\n+    secp256k1_scalar_set_b32(&sigr, b, &overflow);\n+    if (recid)\n+        *recid = (overflow ? 2 : 0) | (secp256k1_fe_is_odd(&r.y) ? 1 : 0);\n+    secp256k1_scalar_t n;\n+    secp256k1_scalar_mul(&n, &sigr, seckey);\n+    secp256k1_scalar_add(&n, &n, message);\n+    secp256k1_scalar_t sigs;\n+    secp256k1_scalar_inverse(&sigs, nonce);\n+    secp256k1_scalar_mul(&sigs, &sigs, &n);\n+    secp256k1_scalar_clear(&n);\n+    secp256k1_gej_clear(&rp);\n+    secp256k1_ge_clear(&r);\n+    if (secp256k1_scalar_is_zero(&sigs))\n+        return 0;\n+    if (secp256k1_scalar_is_high(&sigs)) {\n+        secp256k1_scalar_negate(&sigs, &sigs);\n+        if (recid)\n+            *recid ^= 1;\n+    }\n+    secp256k1_scalar_get_num(&sig->s, &sigs);\n+    secp256k1_scalar_get_num(&sig->r, &sigr);\n+    return 1;\n+}\n+\n+void static secp256k1_ecdsa_sig_set_rs(secp256k1_ecdsa_sig_t *sig, const secp256k1_num_t *r, const secp256k1_num_t *s) {\n+    secp256k1_num_copy(&sig->r, r);\n+    secp256k1_num_copy(&sig->s, s);\n+}\n+\n+#endif"
      },
      {
        "sha": "c5e828feae63ed5c30ee7a8b0e578b82d88d62b5",
        "filename": "src/secp256k1/src/eckey.h",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/eckey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/eckey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,23 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECKEY_\n+#define _SECP256K1_ECKEY_\n+\n+#include \"group.h\"\n+#include \"scalar.h\"\n+#include \"num.h\"\n+\n+int static secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size);\n+void static secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char *pub, int *size, int compressed);\n+\n+int static secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned char *privkey, int privkeylen);\n+int static secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed);\n+\n+int static secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n+int static secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_num_t *tweak);\n+int static secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak);\n+int static secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_num_t *tweak);\n+\n+#endif"
      },
      {
        "sha": "eb26398a6e7c2cbd9a49f6e2929617dc605ac870",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "added",
        "additions": 188,
        "deletions": 0,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,188 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECKEY_IMPL_H_\n+#define _SECP256K1_ECKEY_IMPL_H_\n+\n+#include \"eckey.h\"\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+#include \"group.h\"\n+#include \"ecmult_gen.h\"\n+\n+int static secp256k1_eckey_pubkey_parse(secp256k1_ge_t *elem, const unsigned char *pub, int size) {\n+    if (size == 33 && (pub[0] == 0x02 || pub[0] == 0x03)) {\n+        secp256k1_fe_t x;\n+        secp256k1_fe_set_b32(&x, pub+1);\n+        return secp256k1_ge_set_xo(elem, &x, pub[0] == 0x03);\n+    } else if (size == 65 && (pub[0] == 0x04 || pub[0] == 0x06 || pub[0] == 0x07)) {\n+        secp256k1_fe_t x, y;\n+        secp256k1_fe_set_b32(&x, pub+1);\n+        secp256k1_fe_set_b32(&y, pub+33);\n+        secp256k1_ge_set_xy(elem, &x, &y);\n+        if ((pub[0] == 0x06 || pub[0] == 0x07) && secp256k1_fe_is_odd(&y) != (pub[0] == 0x07))\n+            return 0;\n+        return secp256k1_ge_is_valid(elem);\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+void static secp256k1_eckey_pubkey_serialize(secp256k1_ge_t *elem, unsigned char *pub, int *size, int compressed) {\n+    secp256k1_fe_normalize(&elem->x);\n+    secp256k1_fe_normalize(&elem->y);\n+    secp256k1_fe_get_b32(&pub[1], &elem->x);\n+    if (compressed) {\n+        *size = 33;\n+        pub[0] = 0x02 | (secp256k1_fe_is_odd(&elem->y) ? 0x01 : 0x00);\n+    } else {\n+        *size = 65;\n+        pub[0] = 0x04;\n+        secp256k1_fe_get_b32(&pub[33], &elem->y);\n+    }\n+}\n+\n+int static secp256k1_eckey_privkey_parse(secp256k1_scalar_t *key, const unsigned char *privkey, int privkeylen) {\n+    const unsigned char *end = privkey + privkeylen;\n+    // sequence header\n+    if (end < privkey+1 || *privkey != 0x30)\n+        return 0;\n+    privkey++;\n+    // sequence length constructor\n+    int lenb = 0;\n+    if (end < privkey+1 || !(*privkey & 0x80))\n+        return 0;\n+    lenb = *privkey & ~0x80; privkey++;\n+    if (lenb < 1 || lenb > 2)\n+        return 0;\n+    if (end < privkey+lenb)\n+        return 0;\n+    // sequence length\n+    int len = 0;\n+    len = privkey[lenb-1] | (lenb > 1 ? privkey[lenb-2] << 8 : 0);\n+    privkey += lenb;\n+    if (end < privkey+len)\n+        return 0;\n+    // sequence element 0: version number (=1)\n+    if (end < privkey+3 || privkey[0] != 0x02 || privkey[1] != 0x01 || privkey[2] != 0x01)\n+        return 0;\n+    privkey += 3;\n+    // sequence element 1: octet string, up to 32 bytes\n+    if (end < privkey+2 || privkey[0] != 0x04 || privkey[1] > 0x20 || end < privkey+2+privkey[1])\n+        return 0;\n+    int overflow = 0;\n+    unsigned char c[32] = {0};\n+    memcpy(c + 32 - privkey[1], privkey + 2, privkey[1]);\n+    secp256k1_scalar_set_b32(key, c, &overflow);\n+    memset(c, 0, 32);\n+    return !overflow;\n+}\n+\n+int static secp256k1_eckey_privkey_serialize(unsigned char *privkey, int *privkeylen, const secp256k1_scalar_t *key, int compressed) {\n+    secp256k1_gej_t rp;\n+    secp256k1_ecmult_gen(&rp, key);\n+    secp256k1_ge_t r;\n+    secp256k1_ge_set_gej(&r, &rp);\n+    if (compressed) {\n+        static const unsigned char begin[] = {\n+            0x30,0x81,0xD3,0x02,0x01,0x01,0x04,0x20\n+        };\n+        static const unsigned char middle[] = {\n+            0xA0,0x81,0x85,0x30,0x81,0x82,0x02,0x01,0x01,0x30,0x2C,0x06,0x07,0x2A,0x86,0x48,\n+            0xCE,0x3D,0x01,0x01,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F,0x30,0x06,0x04,0x01,0x00,0x04,0x01,0x07,0x04,\n+            0x21,0x02,0x79,0xBE,0x66,0x7E,0xF9,0xDC,0xBB,0xAC,0x55,0xA0,0x62,0x95,0xCE,0x87,\n+            0x0B,0x07,0x02,0x9B,0xFC,0xDB,0x2D,0xCE,0x28,0xD9,0x59,0xF2,0x81,0x5B,0x16,0xF8,\n+            0x17,0x98,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,\n+            0x8C,0xD0,0x36,0x41,0x41,0x02,0x01,0x01,0xA1,0x24,0x03,0x22,0x00\n+        };\n+        unsigned char *ptr = privkey;\n+        memcpy(ptr, begin, sizeof(begin)); ptr += sizeof(begin);\n+        secp256k1_scalar_get_b32(ptr, key); ptr += 32;\n+        memcpy(ptr, middle, sizeof(middle)); ptr += sizeof(middle);\n+        int pubkeylen = 0;\n+        secp256k1_eckey_pubkey_serialize(&r, ptr, &pubkeylen, 1); ptr += pubkeylen;\n+        *privkeylen = ptr - privkey;\n+    } else {\n+        static const unsigned char begin[] = {\n+            0x30,0x82,0x01,0x13,0x02,0x01,0x01,0x04,0x20\n+        };\n+        static const unsigned char middle[] = {\n+            0xA0,0x81,0xA5,0x30,0x81,0xA2,0x02,0x01,0x01,0x30,0x2C,0x06,0x07,0x2A,0x86,0x48,\n+            0xCE,0x3D,0x01,0x01,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F,0x30,0x06,0x04,0x01,0x00,0x04,0x01,0x07,0x04,\n+            0x41,0x04,0x79,0xBE,0x66,0x7E,0xF9,0xDC,0xBB,0xAC,0x55,0xA0,0x62,0x95,0xCE,0x87,\n+            0x0B,0x07,0x02,0x9B,0xFC,0xDB,0x2D,0xCE,0x28,0xD9,0x59,0xF2,0x81,0x5B,0x16,0xF8,\n+            0x17,0x98,0x48,0x3A,0xDA,0x77,0x26,0xA3,0xC4,0x65,0x5D,0xA4,0xFB,0xFC,0x0E,0x11,\n+            0x08,0xA8,0xFD,0x17,0xB4,0x48,0xA6,0x85,0x54,0x19,0x9C,0x47,0xD0,0x8F,0xFB,0x10,\n+            0xD4,0xB8,0x02,0x21,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+            0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,\n+            0x8C,0xD0,0x36,0x41,0x41,0x02,0x01,0x01,0xA1,0x44,0x03,0x42,0x00\n+        };\n+        unsigned char *ptr = privkey;\n+        memcpy(ptr, begin, sizeof(begin)); ptr += sizeof(begin);\n+        secp256k1_scalar_get_b32(ptr, key); ptr += 32;\n+        memcpy(ptr, middle, sizeof(middle)); ptr += sizeof(middle);\n+        int pubkeylen = 0;\n+        secp256k1_eckey_pubkey_serialize(&r, ptr, &pubkeylen, 0); ptr += pubkeylen;\n+        *privkeylen = ptr - privkey;\n+    }\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_privkey_tweak_add(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n+    secp256k1_scalar_add(key, key, tweak);\n+    if (secp256k1_scalar_is_zero(key))\n+        return 0;\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_pubkey_tweak_add(secp256k1_ge_t *key, const secp256k1_num_t *tweak) {\n+    if (secp256k1_num_cmp(tweak, &secp256k1_ge_consts->order) >= 0)\n+        return 0;\n+\n+    secp256k1_gej_t pt;\n+    secp256k1_gej_set_ge(&pt, key);\n+    secp256k1_num_t one;\n+    secp256k1_num_init(&one);\n+    secp256k1_num_set_int(&one, 1);\n+    secp256k1_ecmult(&pt, &pt, &one, tweak);\n+    secp256k1_num_free(&one);\n+\n+    if (secp256k1_gej_is_infinity(&pt))\n+        return 0;\n+    secp256k1_ge_set_gej(key, &pt);\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar_t *key, const secp256k1_scalar_t *tweak) {\n+    if (secp256k1_scalar_is_zero(tweak))\n+        return 0;\n+\n+    secp256k1_scalar_mul(key, key, tweak);\n+    return 1;\n+}\n+\n+int static secp256k1_eckey_pubkey_tweak_mul(secp256k1_ge_t *key, const secp256k1_num_t *tweak) {\n+    if (secp256k1_num_is_zero(tweak))\n+        return 0;\n+    if (secp256k1_num_cmp(tweak, &secp256k1_ge_consts->order) >= 0)\n+        return 0;\n+\n+    secp256k1_num_t zero;\n+    secp256k1_num_init(&zero);\n+    secp256k1_num_set_int(&zero, 0);\n+    secp256k1_gej_t pt;\n+    secp256k1_gej_set_ge(&pt, key);\n+    secp256k1_ecmult(&pt, &pt, tweak, &zero);\n+    secp256k1_num_free(&zero);\n+    secp256k1_ge_set_gej(key, &pt);\n+    return 1;\n+}\n+\n+#endif"
      },
      {
        "sha": "7d74b5e4620c746e8263396df3f3a1240385ce42",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_\n+#define _SECP256K1_ECMULT_\n+\n+#include \"num.h\"\n+#include \"group.h\"\n+\n+static void secp256k1_ecmult_start(void);\n+static void secp256k1_ecmult_stop(void);\n+\n+/** Double multiply: R = na*A + ng*G */\n+static void secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_num_t *na, const secp256k1_num_t *ng);\n+\n+#endif"
      },
      {
        "sha": "79aa4bf24750c38b6c38772c263bfc24ab0c86aa",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_GEN_\n+#define _SECP256K1_ECMULT_GEN_\n+\n+#include \"scalar.h\"\n+#include \"group.h\"\n+\n+static void secp256k1_ecmult_gen_start(void);\n+static void secp256k1_ecmult_gen_stop(void);\n+\n+/** Multiply with the generator: R = a*G */\n+static void secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *a);\n+\n+#endif"
      },
      {
        "sha": "976569ca43239c11f56bea1bd313f1d4f66ca310",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "added",
        "additions": 121,
        "deletions": 0,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,121 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_GEN_IMPL_H_\n+#define _SECP256K1_ECMULT_GEN_IMPL_H_\n+\n+#include <assert.h>\n+#include \"scalar.h\"\n+#include \"group.h\"\n+#include \"ecmult_gen.h\"\n+\n+typedef struct {\n+    // For accelerating the computation of a*G:\n+    // To harden against timing attacks, use the following mechanism:\n+    // * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n+    // * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n+    //   * U_i = U * 2^i (for i=0..62)\n+    //   * U_i = U * (1-2^63) (for i=63)\n+    //   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n+    // For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n+    // precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+    // None of the resulting prec group elements have a known scalar, and neither do any of\n+    // the intermediate sums while computing a*G.\n+    // To make memory access uniform, the bytes of prec(i, n_i) are sliced per value of n_i.\n+    unsigned char prec[64][sizeof(secp256k1_ge_t)][16]; // prec[j][k][i] = k'th byte of (16^j * i * G + U_i)\n+} secp256k1_ecmult_gen_consts_t;\n+\n+static const secp256k1_ecmult_gen_consts_t *secp256k1_ecmult_gen_consts = NULL;\n+\n+static void secp256k1_ecmult_gen_start(void) {\n+    if (secp256k1_ecmult_gen_consts != NULL)\n+        return;\n+\n+    // Allocate the precomputation table.\n+    secp256k1_ecmult_gen_consts_t *ret = (secp256k1_ecmult_gen_consts_t*)malloc(sizeof(secp256k1_ecmult_gen_consts_t));\n+\n+    // get the generator\n+    const secp256k1_ge_t *g = &secp256k1_ge_consts->g;\n+    secp256k1_gej_t gj; secp256k1_gej_set_ge(&gj, g);\n+\n+    // Construct a group element with no known corresponding scalar (nothing up my sleeve).\n+    secp256k1_gej_t nums_gej;\n+    {\n+        static const unsigned char nums_b32[32] = \"The scalar for this x is unknown\";\n+        secp256k1_fe_t nums_x;\n+        secp256k1_fe_set_b32(&nums_x, nums_b32);\n+        secp256k1_ge_t nums_ge;\n+        VERIFY_CHECK(secp256k1_ge_set_xo(&nums_ge, &nums_x, 0));\n+        secp256k1_gej_set_ge(&nums_gej, &nums_ge);\n+        // Add G to make the bits in x uniformly distributed.\n+        secp256k1_gej_add_ge_var(&nums_gej, &nums_gej, g);\n+    }\n+\n+    // compute prec.\n+    secp256k1_ge_t prec[1024];\n+    {\n+        secp256k1_gej_t precj[1024]; // Jacobian versions of prec.\n+        int j = 0;\n+        secp256k1_gej_t gbase; gbase = gj; // 16^j * G\n+        secp256k1_gej_t numsbase; numsbase = nums_gej; // 2^j * nums.\n+        for (int j=0; j<64; j++) {\n+            // Set precj[j*16 .. j*16+15] to (numsbase, numsbase + gbase, ..., numsbase + 15*gbase).\n+            precj[j*16] = numsbase;\n+            for (int i=1; i<16; i++) {\n+                secp256k1_gej_add_var(&precj[j*16 + i], &precj[j*16 + i - 1], &gbase);\n+            }\n+            // Multiply gbase by 16.\n+            for (int i=0; i<4; i++) {\n+                secp256k1_gej_double_var(&gbase, &gbase);\n+            }\n+            // Multiply numbase by 2.\n+            secp256k1_gej_double_var(&numsbase, &numsbase);\n+            if (j == 62) {\n+                // In the last iteration, numsbase is (1 - 2^j) * nums instead.\n+                secp256k1_gej_neg(&numsbase, &numsbase);\n+                secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej);\n+            }\n+        }\n+        secp256k1_ge_set_all_gej_var(1024, prec, precj);\n+    }\n+    for (int j=0; j<64; j++) {\n+        for (int i=0; i<16; i++) {\n+            const unsigned char* raw = (const unsigned char*)(&prec[j*16 + i]);\n+            for (int k=0; k<sizeof(secp256k1_ge_t); k++)\n+                ret->prec[j][k][i] = raw[k];\n+        }\n+    }\n+\n+    // Set the global pointer to the precomputation table.\n+    secp256k1_ecmult_gen_consts = ret;\n+}\n+\n+static void secp256k1_ecmult_gen_stop(void) {\n+    if (secp256k1_ecmult_gen_consts == NULL)\n+        return;\n+\n+    secp256k1_ecmult_gen_consts_t *c = (secp256k1_ecmult_gen_consts_t*)secp256k1_ecmult_gen_consts;\n+    secp256k1_ecmult_gen_consts = NULL;\n+    free(c);\n+}\n+\n+void static secp256k1_ecmult_gen(secp256k1_gej_t *r, const secp256k1_scalar_t *gn) {\n+    const secp256k1_ecmult_gen_consts_t *c = secp256k1_ecmult_gen_consts;\n+    secp256k1_gej_set_infinity(r);\n+    secp256k1_ge_t add;\n+    int bits;\n+    for (int j=0; j<64; j++) {\n+        bits = secp256k1_scalar_get_bits(gn, j * 4, 4);\n+        for (int k=0; k<sizeof(secp256k1_ge_t); k++)\n+            ((unsigned char*)(&add))[k] = c->prec[j][k][bits];\n+        // Note that the next line uses a variable-time addition function, which\n+        // is fine, as the inputs are blinded (they have no known corresponding\n+        // private key).\n+        secp256k1_gej_add_ge_var(r, r, &add);\n+    }\n+    bits = 0;\n+    secp256k1_ge_clear(&add);\n+}\n+\n+#endif"
      },
      {
        "sha": "c0e4b116b0a5c168a288ce53d55075b3671ada98",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "added",
        "additions": 221,
        "deletions": 0,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,221 @@\n+// Copyright (c) 2013-2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_ECMULT_IMPL_H_\n+#define _SECP256K1_ECMULT_IMPL_H_\n+\n+#include <assert.h>\n+#include \"num.h\"\n+#include \"group.h\"\n+#include \"ecmult.h\"\n+\n+// optimal for 128-bit and 256-bit exponents.\n+#define WINDOW_A 5\n+\n+// larger numbers may result in slightly better performance, at the cost of\n+// exponentially larger precomputed tables. WINDOW_G == 14 results in 640 KiB.\n+#define WINDOW_G 14\n+\n+/** Fill a table 'pre' with precomputed odd multiples of a. W determines the size of the table.\n+ *  pre will contains the values [1*a,3*a,5*a,...,(2^(w-1)-1)*a], so it needs place for\n+ *  2^(w-2) entries.\n+ *\n+ *  There are two versions of this function:\n+ *  - secp256k1_ecmult_precomp_wnaf_gej, which operates on group elements in jacobian notation,\n+ *    fast to precompute, but slower to use in later additions.\n+ *  - secp256k1_ecmult_precomp_wnaf_ge, which operates on group elements in affine notations,\n+ *    (much) slower to precompute, but a bit faster to use in later additions.\n+ *  To compute a*P + b*G, we use the jacobian version for P, and the affine version for G, as\n+ *  G is constant, so it only needs to be done once in advance.\n+ */\n+void static secp256k1_ecmult_table_precomp_gej_var(secp256k1_gej_t *pre, const secp256k1_gej_t *a, int w) {\n+    pre[0] = *a;\n+    secp256k1_gej_t d; secp256k1_gej_double_var(&d, &pre[0]);\n+    for (int i=1; i<(1 << (w-2)); i++)\n+        secp256k1_gej_add_var(&pre[i], &d, &pre[i-1]);\n+}\n+\n+void static secp256k1_ecmult_table_precomp_ge_var(secp256k1_ge_t *pre, const secp256k1_gej_t *a, int w) {\n+    const int table_size = 1 << (w-2);\n+    secp256k1_gej_t prej[table_size];\n+    prej[0] = *a;\n+    secp256k1_gej_t d; secp256k1_gej_double_var(&d, a);\n+    for (int i=1; i<table_size; i++) {\n+        secp256k1_gej_add_var(&prej[i], &d, &prej[i-1]);\n+    }\n+    secp256k1_ge_set_all_gej_var(table_size, pre, prej);\n+}\n+\n+/** The number of entries a table with precomputed multiples needs to have. */\n+#define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n+\n+/** The following two macro retrieves a particular odd multiple from a table\n+ *  of precomputed multiples. */\n+#define ECMULT_TABLE_GET(r,pre,n,w,neg) do { \\\n+    VERIFY_CHECK(((n) & 1) == 1); \\\n+    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    if ((n) > 0) \\\n+        *(r) = (pre)[((n)-1)/2]; \\\n+    else \\\n+        (neg)((r), &(pre)[(-(n)-1)/2]); \\\n+} while(0)\n+\n+#define ECMULT_TABLE_GET_GEJ(r,pre,n,w) ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_gej_neg)\n+#define ECMULT_TABLE_GET_GE(r,pre,n,w)  ECMULT_TABLE_GET((r),(pre),(n),(w),secp256k1_ge_neg)\n+\n+typedef struct {\n+    // For accelerating the computation of a*P + b*G:\n+    secp256k1_ge_t pre_g[ECMULT_TABLE_SIZE(WINDOW_G)];    // odd multiples of the generator\n+    secp256k1_ge_t pre_g_128[ECMULT_TABLE_SIZE(WINDOW_G)]; // odd multiples of 2^128*generator\n+} secp256k1_ecmult_consts_t;\n+\n+static const secp256k1_ecmult_consts_t *secp256k1_ecmult_consts = NULL;\n+\n+static void secp256k1_ecmult_start(void) {\n+    if (secp256k1_ecmult_consts != NULL)\n+        return;\n+\n+    // Allocate the precomputation table.\n+    secp256k1_ecmult_consts_t *ret = (secp256k1_ecmult_consts_t*)malloc(sizeof(secp256k1_ecmult_consts_t));\n+\n+    // get the generator\n+    const secp256k1_ge_t *g = &secp256k1_ge_consts->g;\n+    secp256k1_gej_t gj; secp256k1_gej_set_ge(&gj, g);\n+\n+    // calculate 2^128*generator\n+    secp256k1_gej_t g_128j = gj;\n+    for (int i=0; i<128; i++)\n+        secp256k1_gej_double_var(&g_128j, &g_128j);\n+\n+    // precompute the tables with odd multiples\n+    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g, &gj, WINDOW_G);\n+    secp256k1_ecmult_table_precomp_ge_var(ret->pre_g_128, &g_128j, WINDOW_G);\n+\n+    // Set the global pointer to the precomputation table.\n+    secp256k1_ecmult_consts = ret;\n+}\n+\n+static void secp256k1_ecmult_stop(void) {\n+    if (secp256k1_ecmult_consts == NULL)\n+        return;\n+\n+    secp256k1_ecmult_consts_t *c = (secp256k1_ecmult_consts_t*)secp256k1_ecmult_consts;\n+    secp256k1_ecmult_consts = NULL;\n+    free(c);\n+}\n+\n+/** Convert a number to WNAF notation. The number becomes represented by sum(2^i * wnaf[i], i=0..bits),\n+ *  with the following guarantees:\n+ *  - each wnaf[i] is either 0, or an odd integer between -(1<<(w-1) - 1) and (1<<(w-1) - 1)\n+ *  - two non-zero entries in wnaf are separated by at least w-1 zeroes.\n+ *  - the index of the highest non-zero entry in wnaf (=return value-1) is at most bits, where\n+ *    bits is the number of bits necessary to represent the absolute value of the input.\n+ */\n+static int secp256k1_ecmult_wnaf(int *wnaf, const secp256k1_num_t *a, int w) {\n+    int ret = 0;\n+    int zeroes = 0;\n+    secp256k1_num_t x;\n+    secp256k1_num_copy(&x, a);\n+    int sign = 1;\n+    if (secp256k1_num_is_neg(&x)) {\n+        sign = -1;\n+        secp256k1_num_negate(&x);\n+    }\n+    while (!secp256k1_num_is_zero(&x)) {\n+        while (!secp256k1_num_is_odd(&x)) {\n+            zeroes++;\n+            secp256k1_num_shift(&x, 1);\n+        }\n+        int word = secp256k1_num_shift(&x, w);\n+        while (zeroes) {\n+            wnaf[ret++] = 0;\n+            zeroes--;\n+        }\n+        if (word & (1 << (w-1))) {\n+            secp256k1_num_inc(&x);\n+            wnaf[ret++] = sign * (word - (1 << w));\n+        } else {\n+            wnaf[ret++] = sign * word;\n+        }\n+        zeroes = w-1;\n+    }\n+    return ret;\n+}\n+\n+void static secp256k1_ecmult(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_num_t *na, const secp256k1_num_t *ng) {\n+    const secp256k1_ecmult_consts_t *c = secp256k1_ecmult_consts;\n+\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_num_t na_1, na_lam;\n+    // split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit)\n+    secp256k1_gej_split_exp_var(&na_1, &na_lam, na);\n+\n+    // build wnaf representation for na_1 and na_lam.\n+    int wnaf_na_1[129];   int bits_na_1   = secp256k1_ecmult_wnaf(wnaf_na_1,   &na_1,   WINDOW_A);\n+    int wnaf_na_lam[129]; int bits_na_lam = secp256k1_ecmult_wnaf(wnaf_na_lam, &na_lam, WINDOW_A);\n+    int bits = bits_na_1;\n+    if (bits_na_lam > bits) bits = bits_na_lam;\n+#else\n+    // build wnaf representation for na.\n+    int wnaf_na[257];     int bits_na     = secp256k1_ecmult_wnaf(wnaf_na,     na,      WINDOW_A);\n+    int bits = bits_na;\n+#endif\n+\n+    // calculate odd multiples of a\n+    secp256k1_gej_t pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ecmult_table_precomp_gej_var(pre_a, a, WINDOW_A);\n+\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_gej_t pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    for (int i=0; i<ECMULT_TABLE_SIZE(WINDOW_A); i++)\n+        secp256k1_gej_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n+#endif\n+\n+    // Splitted G factors.\n+    secp256k1_num_t ng_1, ng_128;\n+\n+    // split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit)\n+    secp256k1_num_split(&ng_1, &ng_128, ng, 128);\n+\n+    // Build wnaf representation for ng_1 and ng_128\n+    int wnaf_ng_1[129];   int bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   &ng_1,   WINDOW_G);\n+    int wnaf_ng_128[129]; int bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, &ng_128, WINDOW_G);\n+    if (bits_ng_1 > bits) bits = bits_ng_1;\n+    if (bits_ng_128 > bits) bits = bits_ng_128;\n+\n+    secp256k1_gej_set_infinity(r);\n+    secp256k1_gej_t tmpj;\n+    secp256k1_ge_t tmpa;\n+\n+    for (int i=bits-1; i>=0; i--) {\n+        secp256k1_gej_double_var(r, r);\n+        int n;\n+#ifdef USE_ENDOMORPHISM\n+        if (i < bits_na_1 && (n = wnaf_na_1[i])) {\n+            ECMULT_TABLE_GET_GEJ(&tmpj, pre_a, n, WINDOW_A);\n+            secp256k1_gej_add_var(r, r, &tmpj);\n+        }\n+        if (i < bits_na_lam && (n = wnaf_na_lam[i])) {\n+            ECMULT_TABLE_GET_GEJ(&tmpj, pre_a_lam, n, WINDOW_A);\n+            secp256k1_gej_add_var(r, r, &tmpj);\n+        }\n+#else\n+        if (i < bits_na && (n = wnaf_na[i])) {\n+            ECMULT_TABLE_GET_GEJ(&tmpj, pre_a, n, WINDOW_A);\n+            secp256k1_gej_add_var(r, r, &tmpj);\n+        }\n+#endif\n+        if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g, n, WINDOW_G);\n+            secp256k1_gej_add_ge_var(r, r, &tmpa);\n+        }\n+        if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {\n+            ECMULT_TABLE_GET_GE(&tmpa, c->pre_g_128, n, WINDOW_G);\n+            secp256k1_gej_add_ge_var(r, r, &tmpa);\n+        }\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "067115d0a71adeae25f4a0a87fc0384a9d63ff4a",
        "filename": "src/secp256k1/src/field.h",
        "status": "added",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,112 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_\n+#define _SECP256K1_FIELD_\n+\n+/** Field element module.\n+ *\n+ *  Field elements can be represented in several ways, but code accessing\n+ *  it (and implementations) need to take certain properaties into account:\n+ *  - Each field element can be normalized or not.\n+ *  - Each field element has a magnitude, which represents how far away\n+ *    its representation is away from normalization. Normalized elements\n+ *    always have a magnitude of 1, but a magnitude of 1 doesn't imply\n+ *    normality.\n+ */\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_FIELD_GMP)\n+#include \"field_gmp.h\"\n+#elif defined(USE_FIELD_10X26)\n+#include \"field_10x26.h\"\n+#elif defined(USE_FIELD_5X52)\n+#include \"field_5x52.h\"\n+#else\n+#error \"Please select field implementation\"\n+#endif\n+\n+typedef struct {\n+    secp256k1_num_t p;\n+} secp256k1_fe_consts_t;\n+\n+static const secp256k1_fe_consts_t *secp256k1_fe_consts = NULL;\n+\n+/** Initialize field element precomputation data. */\n+void static secp256k1_fe_start(void);\n+\n+/** Unload field element precomputation data. */\n+void static secp256k1_fe_stop(void);\n+\n+/** Normalize a field element. */\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r);\n+\n+/** Set a field element equal to a small integer. Resulting field element is normalized. */\n+void static secp256k1_fe_set_int(secp256k1_fe_t *r, int a);\n+\n+/** Verify whether a field element is zero. Requires the input to be normalized. */\n+int  static secp256k1_fe_is_zero(const secp256k1_fe_t *a);\n+\n+/** Check the \"oddness\" of a field element. Requires the input to be normalized. */\n+int  static secp256k1_fe_is_odd(const secp256k1_fe_t *a);\n+\n+/** Compare two field elements. Requires both inputs to be normalized */\n+int  static secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b);\n+\n+/** Set a field element equal to 32-byte big endian value. Resulting field element is normalized. */\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a);\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a);\n+\n+/** Set a field element equal to the additive inverse of another. Takes a maximum magnitude of the input\n+ *  as an argument. The magnitude of the output is one higher. */\n+void static secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m);\n+\n+/** Multiplies the passed field element with a small integer constant. Multiplies the magnitude by that\n+ *  small integer. */\n+void static secp256k1_fe_mul_int(secp256k1_fe_t *r, int a);\n+\n+/** Adds a field element to another. The result has the sum of the inputs' magnitudes as magnitude. */\n+void static secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Sets a field element to be the product of two others. Requires the inputs' magnitudes to be at most 8.\n+ *  The output magnitude is 1 (but not guaranteed to be normalized). */\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b);\n+\n+/** Sets a field element to be the square of another. Requires the input's magnitude to be at most 8.\n+ *  The output magnitude is 1 (but not guaranteed to be normalized). */\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Sets a field element to be the (modular) square root (if any exist) of another. Requires the\n+ *  input's magnitude to be at most 8. The output magnitude is 1 (but not guaranteed to be\n+ *  normalized). Return value indicates whether a square root was found. */\n+int  static secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n+ *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n+void static secp256k1_fe_inv(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Potentially faster version of secp256k1_fe_inv, without constant-time guarantee. */\n+void static secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a);\n+\n+/** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n+ *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n+ *  outputs must not overlap in memory. */\n+void static secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n+\n+/** Potentially faster version of secp256k1_fe_inv_all, without constant-time guarantee. */\n+void static secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]);\n+\n+\n+/** Convert a field element to a hexadecimal string. */\n+void static secp256k1_fe_get_hex(char *r, int *rlen, const secp256k1_fe_t *a);\n+\n+/** Convert a hexadecimal string to a field element. */\n+void static secp256k1_fe_set_hex(secp256k1_fe_t *r, const char *a, int alen);\n+\n+#endif"
      },
      {
        "sha": "d544139e858d6bba09b53e262a2231674b96a1e4",
        "filename": "src/secp256k1/src/field_10x26.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_10x26.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_10x26.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_\n+#define _SECP256K1_FIELD_REPR_\n+\n+#include <stdint.h>\n+\n+typedef struct {\n+    // X = sum(i=0..9, elem[i]*2^26) mod n\n+    uint32_t n[10];\n+#ifdef VERIFY\n+    int magnitude;\n+    int normalized;\n+#endif\n+} secp256k1_fe_t;\n+\n+#endif"
      },
      {
        "sha": "a567437feddd851c194f4484347181007b6054a9",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "added",
        "additions": 529,
        "deletions": 0,
        "changes": 529,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n+#define _SECP256K1_FIELD_REPR_IMPL_H_\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+#include \"util.h\"\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+void static secp256k1_fe_inner_start(void) {}\n+void static secp256k1_fe_inner_stop(void) {}\n+\n+#ifdef VERIFY\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {\n+    const uint32_t *d = a->n;\n+    int m = a->normalized ? 1 : 2 * a->magnitude, r = 1;\n+    r &= (d[0] <= 0x3FFFFFFUL * m);\n+    r &= (d[1] <= 0x3FFFFFFUL * m);\n+    r &= (d[2] <= 0x3FFFFFFUL * m);\n+    r &= (d[3] <= 0x3FFFFFFUL * m);\n+    r &= (d[4] <= 0x3FFFFFFUL * m);\n+    r &= (d[5] <= 0x3FFFFFFUL * m);\n+    r &= (d[6] <= 0x3FFFFFFUL * m);\n+    r &= (d[7] <= 0x3FFFFFFUL * m);\n+    r &= (d[8] <= 0x3FFFFFFUL * m);\n+    r &= (d[9] <= 0x03FFFFFUL * m);\n+    r &= (a->magnitude >= 0);\n+    if (a->normalized) {\n+        r &= (a->magnitude <= 1);\n+        if (r && (d[9] == 0x03FFFFFUL)) {\n+            uint32_t mid = d[8] & d[7] & d[6] & d[5] & d[4] & d[3] & d[2];\n+            if (mid == 0x3FFFFFFUL) {\n+                r &= ((d[1] + 0x40UL + ((d[0] + 0x3D1UL) >> 26)) <= 0x3FFFFFFUL);\n+            }\n+        }\n+    }\n+    VERIFY_CHECK(r == 1);\n+}\n+#else\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {}\n+#endif\n+\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r) {\n+    uint32_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4],\n+             t5 = r->n[5], t6 = r->n[6], t7 = r->n[7], t8 = r->n[8], t9 = r->n[9];\n+\n+    // Reduce t9 at the start so there will be at most a single carry from the first pass\n+    uint32_t x = t9 >> 22; t9 &= 0x03FFFFFUL;\n+    uint32_t m;\n+\n+    // The first pass ensures the magnitude is 1, ...\n+    t0 += x * 0x3D1UL; t1 += (x << 6);\n+    t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+    t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+    t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL; m = t2;\n+    t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL; m &= t3;\n+    t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL; m &= t4;\n+    t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL; m &= t5;\n+    t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL; m &= t6;\n+    t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL; m &= t7;\n+    t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL; m &= t8;\n+\n+    // ... except for a possible carry at bit 22 of t9 (i.e. bit 256 of the field element)\n+    VERIFY_CHECK(t9 >> 23 == 0);\n+\n+    // At most a single final reduction is needed; check if the value is >= the field characteristic\n+    x = (t9 >> 22) | ((t9 == 0x03FFFFFUL) & (m == 0x3FFFFFFUL)\n+        & ((t1 + 0x40UL + ((t0 + 0x3D1UL) >> 26)) > 0x3FFFFFFUL));\n+\n+    // Apply the final reduction (for constant-time behaviour, we do it always)\n+    t0 += x * 0x3D1UL; t1 += (x << 6);\n+    t1 += (t0 >> 26); t0 &= 0x3FFFFFFUL;\n+    t2 += (t1 >> 26); t1 &= 0x3FFFFFFUL;\n+    t3 += (t2 >> 26); t2 &= 0x3FFFFFFUL;\n+    t4 += (t3 >> 26); t3 &= 0x3FFFFFFUL;\n+    t5 += (t4 >> 26); t4 &= 0x3FFFFFFUL;\n+    t6 += (t5 >> 26); t5 &= 0x3FFFFFFUL;\n+    t7 += (t6 >> 26); t6 &= 0x3FFFFFFUL;\n+    t8 += (t7 >> 26); t7 &= 0x3FFFFFFUL;\n+    t9 += (t8 >> 26); t8 &= 0x3FFFFFFUL;\n+\n+    // If t9 didn't carry to bit 22 already, then it should have after any final reduction\n+    VERIFY_CHECK(t9 >> 22 == x);\n+\n+    // Mask off the possible multiple of 2^256 from the final reduction\n+    t9 &= 0x03FFFFFUL;\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+    r->n[5] = t5; r->n[6] = t6; r->n[7] = t7; r->n[8] = t8; r->n[9] = t9;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] = a;\n+    r->n[1] = r->n[2] = r->n[3] = r->n[4] = r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+int static inline secp256k1_fe_is_zero(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    const uint32_t *t = a->n;\n+    return (t[0] | t[1] | t[2] | t[3] | t[4] | t[5] | t[6] | t[7] | t[8] | t[9]) == 0;\n+}\n+\n+int static inline secp256k1_fe_is_odd(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    return a->n[0] & 1;\n+}\n+\n+void static inline secp256k1_fe_clear(secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    a->magnitude = 0;\n+    a->normalized = 1;\n+#endif\n+    for (int i=0; i<10; i++) {\n+        a->n[i] = 0;\n+    }\n+}\n+\n+int static inline secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    VERIFY_CHECK(b->normalized);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    const uint32_t *t = a->n, *u = b->n;\n+    return ((t[0]^u[0]) | (t[1]^u[1]) | (t[2]^u[2]) | (t[3]^u[3]) | (t[4]^u[4])\n+          | (t[5]^u[5]) | (t[6]^u[6]) | (t[7]^u[7]) | (t[8]^u[8]) | (t[9]^u[9])) == 0;\n+}\n+\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a) {\n+    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n+    r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n+    for (int i=0; i<32; i++) {\n+        for (int j=0; j<4; j++) {\n+            int limb = (8*i+2*j)/26;\n+            int shift = (8*i+2*j)%26;\n+            r->n[limb] |= (uint32_t)((a[31-i] >> (2*j)) & 0x3) << shift;\n+        }\n+    }\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    for (int i=0; i<32; i++) {\n+        int c = 0;\n+        for (int j=0; j<4; j++) {\n+            int limb = (8*i+2*j)/26;\n+            int shift = (8*i+2*j)%26;\n+            c |= ((a->n[limb] >> shift) & 0x3) << (2 * j);\n+        }\n+        r[31-i] = c;\n+    }\n+}\n+\n+void static inline secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= m);\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] = 0x3FFFC2FUL * 2 * (m + 1) - a->n[0];\n+    r->n[1] = 0x3FFFFBFUL * 2 * (m + 1) - a->n[1];\n+    r->n[2] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[2];\n+    r->n[3] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[3];\n+    r->n[4] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[4];\n+    r->n[5] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[5];\n+    r->n[6] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[6];\n+    r->n[7] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[7];\n+    r->n[8] = 0x3FFFFFFUL * 2 * (m + 1) - a->n[8];\n+    r->n[9] = 0x03FFFFFUL * 2 * (m + 1) - a->n[9];\n+#ifdef VERIFY\n+    r->magnitude = m + 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] *= a;\n+    r->n[1] *= a;\n+    r->n[2] *= a;\n+    r->n[3] *= a;\n+    r->n[4] *= a;\n+    r->n[5] *= a;\n+    r->n[6] *= a;\n+    r->n[7] *= a;\n+    r->n[8] *= a;\n+    r->n[9] *= a;\n+#ifdef VERIFY\n+    r->magnitude *= a;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] += a->n[0];\n+    r->n[1] += a->n[1];\n+    r->n[2] += a->n[2];\n+    r->n[3] += a->n[3];\n+    r->n[4] += a->n[4];\n+    r->n[5] += a->n[5];\n+    r->n[6] += a->n[6];\n+    r->n[7] += a->n[7];\n+    r->n[8] += a->n[8];\n+    r->n[9] += a->n[9];\n+#ifdef VERIFY\n+    r->magnitude += a->magnitude;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_inner(const uint32_t *a, const uint32_t *b, uint32_t *r) {\n+    uint64_t c = (uint64_t)a[0] * b[0];\n+    uint32_t t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[1] +\n+            (uint64_t)a[1] * b[0];\n+    uint32_t t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[2] +\n+            (uint64_t)a[1] * b[1] +\n+            (uint64_t)a[2] * b[0];\n+    uint32_t t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[3] +\n+            (uint64_t)a[1] * b[2] +\n+            (uint64_t)a[2] * b[1] +\n+            (uint64_t)a[3] * b[0];\n+    uint32_t t3 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[4] +\n+            (uint64_t)a[1] * b[3] +\n+            (uint64_t)a[2] * b[2] +\n+            (uint64_t)a[3] * b[1] +\n+            (uint64_t)a[4] * b[0];\n+    uint32_t t4 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[5] +\n+            (uint64_t)a[1] * b[4] +\n+            (uint64_t)a[2] * b[3] +\n+            (uint64_t)a[3] * b[2] +\n+            (uint64_t)a[4] * b[1] +\n+            (uint64_t)a[5] * b[0];\n+    uint32_t t5 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[6] +\n+            (uint64_t)a[1] * b[5] +\n+            (uint64_t)a[2] * b[4] +\n+            (uint64_t)a[3] * b[3] +\n+            (uint64_t)a[4] * b[2] +\n+            (uint64_t)a[5] * b[1] +\n+            (uint64_t)a[6] * b[0];\n+    uint32_t t6 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[7] +\n+            (uint64_t)a[1] * b[6] +\n+            (uint64_t)a[2] * b[5] +\n+            (uint64_t)a[3] * b[4] +\n+            (uint64_t)a[4] * b[3] +\n+            (uint64_t)a[5] * b[2] +\n+            (uint64_t)a[6] * b[1] +\n+            (uint64_t)a[7] * b[0];\n+    uint32_t t7 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[8] +\n+            (uint64_t)a[1] * b[7] +\n+            (uint64_t)a[2] * b[6] +\n+            (uint64_t)a[3] * b[5] +\n+            (uint64_t)a[4] * b[4] +\n+            (uint64_t)a[5] * b[3] +\n+            (uint64_t)a[6] * b[2] +\n+            (uint64_t)a[7] * b[1] +\n+            (uint64_t)a[8] * b[0];\n+    uint32_t t8 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[0] * b[9] +\n+            (uint64_t)a[1] * b[8] +\n+            (uint64_t)a[2] * b[7] +\n+            (uint64_t)a[3] * b[6] +\n+            (uint64_t)a[4] * b[5] +\n+            (uint64_t)a[5] * b[4] +\n+            (uint64_t)a[6] * b[3] +\n+            (uint64_t)a[7] * b[2] +\n+            (uint64_t)a[8] * b[1] +\n+            (uint64_t)a[9] * b[0];\n+    uint32_t t9 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[1] * b[9] +\n+            (uint64_t)a[2] * b[8] +\n+            (uint64_t)a[3] * b[7] +\n+            (uint64_t)a[4] * b[6] +\n+            (uint64_t)a[5] * b[5] +\n+            (uint64_t)a[6] * b[4] +\n+            (uint64_t)a[7] * b[3] +\n+            (uint64_t)a[8] * b[2] +\n+            (uint64_t)a[9] * b[1];\n+    uint32_t t10 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[2] * b[9] +\n+            (uint64_t)a[3] * b[8] +\n+            (uint64_t)a[4] * b[7] +\n+            (uint64_t)a[5] * b[6] +\n+            (uint64_t)a[6] * b[5] +\n+            (uint64_t)a[7] * b[4] +\n+            (uint64_t)a[8] * b[3] +\n+            (uint64_t)a[9] * b[2];\n+    uint32_t t11 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[3] * b[9] +\n+            (uint64_t)a[4] * b[8] +\n+            (uint64_t)a[5] * b[7] +\n+            (uint64_t)a[6] * b[6] +\n+            (uint64_t)a[7] * b[5] +\n+            (uint64_t)a[8] * b[4] +\n+            (uint64_t)a[9] * b[3];\n+    uint32_t t12 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[4] * b[9] +\n+            (uint64_t)a[5] * b[8] +\n+            (uint64_t)a[6] * b[7] +\n+            (uint64_t)a[7] * b[6] +\n+            (uint64_t)a[8] * b[5] +\n+            (uint64_t)a[9] * b[4];\n+    uint32_t t13 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[5] * b[9] +\n+            (uint64_t)a[6] * b[8] +\n+            (uint64_t)a[7] * b[7] +\n+            (uint64_t)a[8] * b[6] +\n+            (uint64_t)a[9] * b[5];\n+    uint32_t t14 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[6] * b[9] +\n+            (uint64_t)a[7] * b[8] +\n+            (uint64_t)a[8] * b[7] +\n+            (uint64_t)a[9] * b[6];\n+    uint32_t t15 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[7] * b[9] +\n+            (uint64_t)a[8] * b[8] +\n+            (uint64_t)a[9] * b[7];\n+    uint32_t t16 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[8] * b[9] +\n+            (uint64_t)a[9] * b[8];\n+    uint32_t t17 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[9] * b[9];\n+    uint32_t t18 = c & 0x3FFFFFFUL; c = c >> 26;\n+    uint32_t t19 = c;\n+\n+    c = t0 + (uint64_t)t10 * 0x3D10UL;\n+    t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t1 + (uint64_t)t10*0x400UL + (uint64_t)t11 * 0x3D10UL;\n+    t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t2 + (uint64_t)t11*0x400UL + (uint64_t)t12 * 0x3D10UL;\n+    t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t3 + (uint64_t)t12*0x400UL + (uint64_t)t13 * 0x3D10UL;\n+    r[3] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t4 + (uint64_t)t13*0x400UL + (uint64_t)t14 * 0x3D10UL;\n+    r[4] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t5 + (uint64_t)t14*0x400UL + (uint64_t)t15 * 0x3D10UL;\n+    r[5] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t6 + (uint64_t)t15*0x400UL + (uint64_t)t16 * 0x3D10UL;\n+    r[6] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t7 + (uint64_t)t16*0x400UL + (uint64_t)t17 * 0x3D10UL;\n+    r[7] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t8 + (uint64_t)t17*0x400UL + (uint64_t)t18 * 0x3D10UL;\n+    r[8] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t9 + (uint64_t)t18*0x400UL + (uint64_t)t19 * 0x1000003D10ULL;\n+    r[9] = c & 0x03FFFFFUL; c = c >> 22;\n+    uint64_t d = t0 + c * 0x3D1UL;\n+    r[0] = d & 0x3FFFFFFUL; d = d >> 26;\n+    d = d + t1 + c*0x40;\n+    r[1] = d & 0x3FFFFFFUL; d = d >> 26;\n+    r[2] = t2 + d;\n+}\n+\n+void static inline secp256k1_fe_sqr_inner(const uint32_t *a, uint32_t *r) {\n+    uint64_t c = (uint64_t)a[0] * a[0];\n+    uint32_t t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[1];\n+    uint32_t t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[2] +\n+            (uint64_t)a[1] * a[1];\n+    uint32_t t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[3] +\n+            (uint64_t)(a[1]*2) * a[2];\n+    uint32_t t3 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[4] +\n+            (uint64_t)(a[1]*2) * a[3] +\n+            (uint64_t)a[2] * a[2];\n+    uint32_t t4 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[5] +\n+            (uint64_t)(a[1]*2) * a[4] +\n+            (uint64_t)(a[2]*2) * a[3];\n+    uint32_t t5 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[6] +\n+            (uint64_t)(a[1]*2) * a[5] +\n+            (uint64_t)(a[2]*2) * a[4] +\n+            (uint64_t)a[3] * a[3];\n+    uint32_t t6 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[7] +\n+            (uint64_t)(a[1]*2) * a[6] +\n+            (uint64_t)(a[2]*2) * a[5] +\n+            (uint64_t)(a[3]*2) * a[4];\n+    uint32_t t7 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[8] +\n+            (uint64_t)(a[1]*2) * a[7] +\n+            (uint64_t)(a[2]*2) * a[6] +\n+            (uint64_t)(a[3]*2) * a[5] +\n+            (uint64_t)a[4] * a[4];\n+    uint32_t t8 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[0]*2) * a[9] +\n+            (uint64_t)(a[1]*2) * a[8] +\n+            (uint64_t)(a[2]*2) * a[7] +\n+            (uint64_t)(a[3]*2) * a[6] +\n+            (uint64_t)(a[4]*2) * a[5];\n+    uint32_t t9 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[1]*2) * a[9] +\n+            (uint64_t)(a[2]*2) * a[8] +\n+            (uint64_t)(a[3]*2) * a[7] +\n+            (uint64_t)(a[4]*2) * a[6] +\n+            (uint64_t)a[5] * a[5];\n+    uint32_t t10 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[2]*2) * a[9] +\n+            (uint64_t)(a[3]*2) * a[8] +\n+            (uint64_t)(a[4]*2) * a[7] +\n+            (uint64_t)(a[5]*2) * a[6];\n+    uint32_t t11 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[3]*2) * a[9] +\n+            (uint64_t)(a[4]*2) * a[8] +\n+            (uint64_t)(a[5]*2) * a[7] +\n+            (uint64_t)a[6] * a[6];\n+    uint32_t t12 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[4]*2) * a[9] +\n+            (uint64_t)(a[5]*2) * a[8] +\n+            (uint64_t)(a[6]*2) * a[7];\n+    uint32_t t13 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[5]*2) * a[9] +\n+            (uint64_t)(a[6]*2) * a[8] +\n+            (uint64_t)a[7] * a[7];\n+    uint32_t t14 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[6]*2) * a[9] +\n+            (uint64_t)(a[7]*2) * a[8];\n+    uint32_t t15 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[7]*2) * a[9] +\n+            (uint64_t)a[8] * a[8];\n+    uint32_t t16 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)(a[8]*2) * a[9];\n+    uint32_t t17 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + (uint64_t)a[9] * a[9];\n+    uint32_t t18 = c & 0x3FFFFFFUL; c = c >> 26;\n+    uint32_t t19 = c;\n+\n+    c = t0 + (uint64_t)t10 * 0x3D10UL;\n+    t0 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t1 + (uint64_t)t10*0x400UL + (uint64_t)t11 * 0x3D10UL;\n+    t1 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t2 + (uint64_t)t11*0x400UL + (uint64_t)t12 * 0x3D10UL;\n+    t2 = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t3 + (uint64_t)t12*0x400UL + (uint64_t)t13 * 0x3D10UL;\n+    r[3] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t4 + (uint64_t)t13*0x400UL + (uint64_t)t14 * 0x3D10UL;\n+    r[4] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t5 + (uint64_t)t14*0x400UL + (uint64_t)t15 * 0x3D10UL;\n+    r[5] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t6 + (uint64_t)t15*0x400UL + (uint64_t)t16 * 0x3D10UL;\n+    r[6] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t7 + (uint64_t)t16*0x400UL + (uint64_t)t17 * 0x3D10UL;\n+    r[7] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t8 + (uint64_t)t17*0x400UL + (uint64_t)t18 * 0x3D10UL;\n+    r[8] = c & 0x3FFFFFFUL; c = c >> 26;\n+    c = c + t9 + (uint64_t)t18*0x400UL + (uint64_t)t19 * 0x1000003D10ULL;\n+    r[9] = c & 0x03FFFFFUL; c = c >> 22;\n+    uint64_t d = t0 + c * 0x3D1UL;\n+    r[0] = d & 0x3FFFFFFUL; d = d >> 26;\n+    d = d + t1 + c*0x40;\n+    r[1] = d & 0x3FFFFFFUL; d = d >> 26;\n+    r[2] = t2 + d;\n+}\n+\n+\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    VERIFY_CHECK(b->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+#endif\n+    secp256k1_fe_sqr_inner(a->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+#endif"
      },
      {
        "sha": "9d5de2cc41e464c3a7d62dcb441bf393d73cc7e6",
        "filename": "src/secp256k1/src/field_5x52.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_\n+#define _SECP256K1_FIELD_REPR_\n+\n+#include <stdint.h>\n+\n+typedef struct {\n+    // X = sum(i=0..4, elem[i]*2^52) mod n\n+    uint64_t n[5];\n+#ifdef VERIFY\n+    int magnitude;\n+    int normalized;\n+#endif\n+} secp256k1_fe_t;\n+\n+#endif"
      },
      {
        "sha": "5e785f763055eaf695f92116dc3582a0985bf71d",
        "filename": "src/secp256k1/src/field_5x52_asm.asm",
        "status": "added",
        "additions": 469,
        "deletions": 0,
        "changes": 469,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_asm.asm",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_asm.asm",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_asm.asm?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,469 @@\n+\t;; Added by Diederik Huys, March 2013\n+\t;;\n+\t;; Provided public procedures:\n+\t;; \tsecp256k1_fe_mul_inner\n+\t;; \tsecp256k1_fe_sqr_inner\n+\t;;\n+\t;; Needed tools: YASM (http://yasm.tortall.net)\n+\t;;\n+\t;; \n+\n+\tBITS 64\n+\n+%ifidn   __OUTPUT_FORMAT__,macho64\n+%define SYM(x) _ %+ x\n+%else\n+%define SYM(x) x\n+%endif\n+\n+\t;;  Procedure ExSetMult\n+\t;;  Register Layout:\n+\t;;  INPUT: \trdi\t= a->n\n+\t;; \t   \trsi  \t= b->n\n+\t;; \t   \trdx  \t= r->a\n+\t;; \n+\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n+\t;; \t\tr9:r8    = c\n+\t;; \t\tr10-r13  = t0-t3\n+\t;; \t\tr14\t = b.n[0] / t4\n+\t;; \t\tr15\t = b.n[1] / t5\n+\t;; \t\trbx\t = b.n[2] / t6\n+\t;; \t\trcx\t = b.n[3] / t7\n+\t;; \t\trbp\t = Constant 0FFFFFFFFFFFFFh / t8\n+\t;; \t\trsi\t = b.n / b.n[4] / t9\n+\n+\tGLOBAL SYM(secp256k1_fe_mul_inner)\n+\tALIGN 32\n+SYM(secp256k1_fe_mul_inner):\n+\tpush rbp\n+\tpush rbx\n+\tpush r12\n+\tpush r13\n+\tpush r14\n+\tpush r15\n+\tpush rdx\n+\tmov r14,[rsi+8*0]\t; preload b.n[0]. This will be the case until\n+\t\t\t\t; b.n[0] is no longer needed, then we reassign\n+\t\t\t\t; r14 to t4\n+\t;; c=a.n[0] * b.n[0]\n+   \tmov rax,[rdi+0*8]\t; load a.n[0]\n+\tmov rbp,0FFFFFFFFFFFFFh\n+\tmul r14\t\t\t; rdx:rax=a.n[0]*b.n[0]\n+\tmov r15,[rsi+1*8]\n+\tmov r10,rbp\t\t; load modulus into target register for t0\n+\tmov r8,rax\n+\tand r10,rax\t\t; only need lower qword of c\n+\tshrd r8,rdx,52\n+\txor r9,r9\t\t; c < 2^64, so we ditch the HO part \n+\n+\t;; c+=a.n[0] * b.n[1] + a.n[1] * b.n[0]\n+\tmov rax,[rdi+0*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul r14\t\t\t\n+\tmov r11,rbp\n+\tmov rbx,[rsi+2*8]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r11,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\t;; c+=a.n[0 1 2] * b.n[2 1 0]\n+\tmov rax,[rdi+0*8]\n+\tmul rbx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul r14\n+\tmov r12,rbp\t\t\n+\tmov rcx,[rsi+3*8]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r12,r8\t\t\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[0 1 2 3] * b.n[3 2 1 0]\n+\tmov rax,[rdi+0*8]\n+\tmul rcx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul rbx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\t\n+\tmov rax,[rdi+3*8]\n+\tmul r14\t\t\t\n+\tmov r13,rbp             \n+\tmov rsi,[rsi+4*8]\t; load b.n[4] and destroy pointer\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r13,r8\n+\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\n+\t;; c+=a.n[0 1 2 3 4] * b.n[4 3 2 1 0]\n+\tmov rax,[rdi+0*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+1*8]\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul rbx\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+3*8]\n+\tmul r15\t\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul r14\t\t\t\n+\tmov r14,rbp             ; load modulus into t4 and destroy a.n[0]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r14,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[1 2 3 4] * b.n[4 3 2 1]\n+\tmov rax,[rdi+1*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+2*8]\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+3*8]\n+\tmul rbx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul r15\n+\tmov r15,rbp\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tand r15,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[2 3 4] * b.n[4 3 2]\n+\tmov rax,[rdi+2*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+3*8]\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul rbx\n+\tmov rbx,rbp\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tand rbx,r8\t\t\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[3 4] * b.n[4 3]\n+\tmov rax,[rdi+3*8]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,[rdi+4*8]\n+\tmul rcx\n+\tmov rcx,rbp\t\t\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rcx,r8\t\t\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[4] * b.n[4]\n+\tmov rax,[rdi+4*8]\n+\tmul rsi\n+\t;; mov rbp,rbp\t\t; modulus already there!\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rbp,r8 \n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\tmov rsi,r8\t\t; load c into t9 and destroy b.n[4]\n+\n+\t;; *******************************************************\n+common_exit_norm:\n+\tmov rdi,01000003D10h\t; load constant\n+\n+\tmov rax,r15\t\t; get t5\n+\tmul rdi\n+\tadd rax,r10    \t\t; +t0\n+\tadc rdx,0\n+\tmov r10,0FFFFFFFFFFFFFh ; modulus. Sadly, we ran out of registers!\n+\tmov r8,rax\t\t; +c\n+\tand r10,rax\n+\tshrd r8,rdx,52\n+\txor r9,r9\n+\n+\tmov rax,rbx\t\t; get t6\n+\tmul rdi\n+\tadd rax,r11\t\t; +t1\n+\tadc rdx,0\n+\tmov r11,0FFFFFFFFFFFFFh ; modulus\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r11,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\n+\tmov rax,rcx    \t\t; get t7\n+\tmul rdi\n+\tadd rax,r12\t\t; +t2\n+\tadc rdx,0\n+\tpop rbx\t\t\t; retrieve pointer to this.n\t\n+\tmov r12,0FFFFFFFFFFFFFh ; modulus\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r12,r8\n+\tmov [rbx+2*8],r12\t; mov into this.n[2]\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\tmov rax,rbp    \t\t; get t8\n+\tmul rdi\n+\tadd rax,r13    \t\t; +t3\n+\tadc rdx,0\n+\tmov r13,0FFFFFFFFFFFFFh ; modulus\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r13,r8\n+\tmov [rbx+3*8],r13\t; -> this.n[3]\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\tmov rax,rsi    \t\t; get t9\n+\tmul rdi\n+\tadd rax,r14    \t\t; +t4\n+\tadc rdx,0\n+\tmov r14,0FFFFFFFFFFFFh\t; !!!\n+\tadd r8,rax\t\t; +c\n+\tadc r9,rdx\n+\tand r14,r8\n+\tmov [rbx+4*8],r14\t; -> this.n[4]\n+\tshrd r8,r9,48\t\t; !!!\n+\txor r9,r9\n+\t\n+\tmov rax,01000003D1h\n+\tmul r8\t\t\n+\tadd rax,r10\n+\tadc rdx,0\n+\tmov r10,0FFFFFFFFFFFFFh ; modulus\n+\tmov r8,rax\n+\tand rax,r10\n+\tshrd r8,rdx,52\n+\tmov [rbx+0*8],rax\t; -> this.n[0]\n+\tadd r8,r11\n+\tmov [rbx+1*8],r8\t; -> this.n[1]\n+\n+\tpop r15\n+\tpop r14\n+\tpop r13\n+\tpop r12\n+\tpop rbx\n+\tpop rbp\n+\tret\n+\n+\t\n+\t;;  PROC ExSetSquare\n+\t;;  Register Layout:\n+\t;;  INPUT: \trdi\t = a.n\n+\t;; \t   \trsi  \t = this.a\n+\t;;  INTERNAL:\trdx:rax  = multiplication accumulator\n+\t;; \t\tr9:r8    = c\n+\t;; \t\tr10-r13  = t0-t3\n+\t;; \t\tr14\t = a.n[0] / t4\n+\t;; \t\tr15\t = a.n[1] / t5\n+\t;; \t\trbx\t = a.n[2] / t6\n+\t;; \t\trcx\t = a.n[3] / t7\n+\t;; \t\trbp\t = 0FFFFFFFFFFFFFh / t8\n+\t;; \t\trsi\t = a.n[4] / t9\n+\tGLOBAL SYM(secp256k1_fe_sqr_inner)\n+\tALIGN 32\n+SYM(secp256k1_fe_sqr_inner):\n+\tpush rbp\n+\tpush rbx\n+\tpush r12\n+\tpush r13\n+\tpush r14\n+\tpush r15\n+\tpush rsi\n+\tmov rbp,0FFFFFFFFFFFFFh\n+\t\n+\t;; c=a.n[0] * a.n[0]\n+   \tmov r14,[rdi+0*8]\t; r14=a.n[0]\n+\tmov r10,rbp\t\t; modulus \n+\tmov rax,r14\n+\tmul rax\n+\tmov r15,[rdi+1*8]\t; a.n[1]\n+\tadd r14,r14\t\t; r14=2*a.n[0]\n+\tmov r8,rax\n+\tand r10,rax\t\t; only need lower qword\n+\tshrd r8,rdx,52\n+\txor r9,r9\n+\n+\t;; c+=2*a.n[0] * a.n[1]\n+\tmov rax,r14\t\t; r14=2*a.n[0]\n+\tmul r15\n+\tmov rbx,[rdi+2*8]\t; rbx=a.n[2]\n+\tmov r11,rbp \t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r11,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\n+\t\n+\t;; c+=2*a.n[0]*a.n[2]+a.n[1]*a.n[1]\n+\tmov rax,r14\n+\tmul rbx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,r15\n+\tmov r12,rbp\t\t; modulus\n+\tmul rax\n+\tmov rcx,[rdi+3*8]\t; rcx=a.n[3]\n+\tadd r15,r15\t\t; r15=a.n[1]*2\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r12,r8\t\t; only need lower dword\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[0]*a.n[3]+2*a.n[1]*a.n[2]\n+\tmov rax,r14\n+\tmul rcx\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,r15\t\t; rax=2*a.n[1]\n+\tmov r13,rbp\t\t; modulus\n+\tmul rbx\n+\tmov rsi,[rdi+4*8]\t; rsi=a.n[4]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r13,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[0]*a.n[4]+2*a.n[1]*a.n[3]+a.n[2]*a.n[2]\n+\tmov rax,r14\t\t; last time we need 2*a.n[0]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,r15\n+\tmul rcx\n+\tmov r14,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,rbx\n+\tmul rax\n+\tadd rbx,rbx\t\t; rcx=2*a.n[2]\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r14,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[1]*a.n[4]+2*a.n[2]*a.n[3]\n+\tmov rax,r15\t\t; last time we need 2*a.n[1]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,rbx\n+\tmul rcx\n+\tmov r15,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand r15,r8\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[2]*a.n[4]+a.n[3]*a.n[3]\n+\tmov rax,rbx\t\t; last time we need 2*a.n[2]\n+\tmul rsi\n+\tadd r8,rax\n+\tadc r9,rdx\n+\n+\tmov rax,rcx\t\t; a.n[3]\n+\tmul rax\n+\tmov rbx,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rbx,r8\t\t; only need lower dword\n+\tlea rax,[2*rcx]\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=2*a.n[3]*a.n[4]\n+\tmul rsi\n+\tmov rcx,rbp\t\t; modulus\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rcx,r8\t\t; only need lower dword\n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\t;; c+=a.n[4]*a.n[4]\n+\tmov rax,rsi\n+\tmul rax\n+\t;; mov rbp,rbp\t\t; modulus is already there!\n+\tadd r8,rax\n+\tadc r9,rdx\n+\tand rbp,r8 \n+\tshrd r8,r9,52\n+\txor r9,r9\t\t\n+\n+\tmov rsi,r8\n+\n+\t;; *******************************************************\n+\tjmp common_exit_norm\n+\tend\n+\n+\t"
      },
      {
        "sha": "93c6ab6b585466d480e5d74d5579d10655c9c776",
        "filename": "src/secp256k1/src/field_5x52_asm_impl.h",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_asm_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_asm_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_asm_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,11 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+#define _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+\n+void __attribute__ ((sysv_abi)) secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t *b, uint64_t *r);\n+void __attribute__ ((sysv_abi)) secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r);\n+\n+#endif"
      },
      {
        "sha": "5afabae38d3feed7e9a92b849bc19b2d445c73c1",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "added",
        "additions": 257,
        "deletions": 0,
        "changes": 257,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,257 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n+#define _SECP256K1_FIELD_REPR_IMPL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <assert.h>\n+#include <string.h>\n+#include \"util.h\"\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+#if defined(USE_FIELD_5X52_ASM)\n+#include \"field_5x52_asm_impl.h\"\n+#elif defined(USE_FIELD_5X52_INT128)\n+#include \"field_5x52_int128_impl.h\"\n+#else\n+#error \"Please select field_5x52 implementation\"\n+#endif\n+\n+/** Implements arithmetic modulo FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F,\n+ *  represented as 5 uint64_t's in base 2^52. The values are allowed to contain >52 each. In particular,\n+ *  each FieldElem has a 'magnitude' associated with it. Internally, a magnitude M means each element\n+ *  is at most M*(2^53-1), except the most significant one, which is limited to M*(2^49-1). All operations\n+ *  accept any input with magnitude at most M, and have different rules for propagating magnitude to their\n+ *  output.\n+ */\n+\n+void static secp256k1_fe_inner_start(void) {}\n+void static secp256k1_fe_inner_stop(void) {}\n+\n+#ifdef VERIFY\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {\n+    const uint64_t *d = a->n;\n+    int m = a->normalized ? 1 : 2 * a->magnitude, r = 1;\n+    r &= (d[0] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[1] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[2] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[3] <= 0xFFFFFFFFFFFFFULL * m);\n+    r &= (d[4] <= 0x0FFFFFFFFFFFFULL * m);\n+    r &= (a->magnitude >= 0);\n+    if (a->normalized) {\n+        r &= (a->magnitude <= 1);\n+        if (r && (d[4] == 0x0FFFFFFFFFFFFULL) && ((d[3] & d[2] & d[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            r &= (d[0] < 0xFFFFEFFFFFC2FULL);\n+        }\n+    }\n+    VERIFY_CHECK(r == 1);\n+}\n+#else\n+void static secp256k1_fe_verify(const secp256k1_fe_t *a) {}\n+#endif\n+\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r) {\n+    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];\n+\n+    // Reduce t4 at the start so there will be at most a single carry from the first pass\n+    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;\n+    uint64_t m;\n+\n+    // The first pass ensures the magnitude is 1, ...\n+    t0 += x * 0x1000003D1ULL;\n+    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; m = t1;\n+    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; m &= t2;\n+    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; m &= t3;\n+\n+    // ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element)\n+    VERIFY_CHECK(t4 >> 49 == 0);\n+\n+    // At most a single final reduction is needed; check if the value is >= the field characteristic\n+    x = (t4 >> 48) | ((t4 == 0x0FFFFFFFFFFFFULL) & (m == 0xFFFFFFFFFFFFFULL)\n+        & (t0 >= 0xFFFFEFFFFFC2FULL));\n+\n+    // Apply the final reduction (for constant-time behaviour, we do it always)\n+    t0 += x * 0x1000003D1ULL;\n+    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;\n+    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;\n+    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;\n+    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;\n+\n+    // If t4 didn't carry to bit 48 already, then it should have after any final reduction\n+    VERIFY_CHECK(t4 >> 48 == x);\n+\n+    // Mask off the possible multiple of 2^256 from the final reduction\n+    t4 &= 0x0FFFFFFFFFFFFULL;\n+\n+    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;\n+\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] = a;\n+    r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+int static inline secp256k1_fe_is_zero(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    const uint64_t *t = a->n;\n+    return (t[0] | t[1] | t[2] | t[3] | t[4]) == 0;\n+}\n+\n+int static inline secp256k1_fe_is_odd(const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    return a->n[0] & 1;\n+}\n+\n+void static inline secp256k1_fe_clear(secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    a->magnitude = 0;\n+    a->normalized = 1;\n+#endif\n+    for (int i=0; i<5; i++) {\n+        a->n[i] = 0;\n+    }\n+}\n+\n+int static inline secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    VERIFY_CHECK(b->normalized);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    const uint64_t *t = a->n, *u = b->n;\n+    return ((t[0]^u[0]) | (t[1]^u[1]) | (t[2]^u[2]) | (t[3]^u[3]) | (t[4]^u[4])) == 0;\n+}\n+\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a) {\n+    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n+    for (int i=0; i<32; i++) {\n+        for (int j=0; j<2; j++) {\n+            int limb = (8*i+4*j)/52;\n+            int shift = (8*i+4*j)%52;\n+            r->n[limb] |= (uint64_t)((a[31-i] >> (4*j)) & 0xF) << shift;\n+        }\n+    }\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+    secp256k1_fe_verify(a);\n+#endif\n+    for (int i=0; i<32; i++) {\n+        int c = 0;\n+        for (int j=0; j<2; j++) {\n+            int limb = (8*i+4*j)/52;\n+            int shift = (8*i+4*j)%52;\n+            c |= ((a->n[limb] >> shift) & 0xF) << (4 * j);\n+        }\n+        r[31-i] = c;\n+    }\n+}\n+\n+void static inline secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= m);\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] = 0xFFFFEFFFFFC2FULL * 2 * (m + 1) - a->n[0];\n+    r->n[1] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[1];\n+    r->n[2] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[2];\n+    r->n[3] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[3];\n+    r->n[4] = 0x0FFFFFFFFFFFFULL * 2 * (m + 1) - a->n[4];\n+#ifdef VERIFY\n+    r->magnitude = m + 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] *= a;\n+    r->n[1] *= a;\n+    r->n[2] *= a;\n+    r->n[3] *= a;\n+    r->n[4] *= a;\n+#ifdef VERIFY\n+    r->magnitude *= a;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static inline secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    secp256k1_fe_verify(a);\n+#endif\n+    r->n[0] += a->n[0];\n+    r->n[1] += a->n[1];\n+    r->n[2] += a->n[2];\n+    r->n[3] += a->n[3];\n+    r->n[4] += a->n[4];\n+#ifdef VERIFY\n+    r->magnitude += a->magnitude;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    VERIFY_CHECK(b->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+    secp256k1_fe_verify(b);\n+#endif\n+    secp256k1_fe_mul_inner(a->n, b->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->magnitude <= 8);\n+    secp256k1_fe_verify(a);\n+#endif\n+    secp256k1_fe_sqr_inner(a->n, r->n);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 0;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n+\n+#endif"
      },
      {
        "sha": "23cb134623896a12fa5bf62813968c45c1a54f04",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,105 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+#define _SECP256K1_FIELD_INNER5X52_IMPL_H_\n+\n+#include <stdint.h>\n+\n+void static inline secp256k1_fe_mul_inner(const uint64_t *a, const uint64_t *b, uint64_t *r) {\n+    __int128 c = (__int128)a[0] * b[0];\n+    uint64_t t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0FFFFFFFFFFFFFE0\n+    c = c + (__int128)a[0] * b[1] +\n+            (__int128)a[1] * b[0];\n+    uint64_t t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 20000000000000BF\n+    c = c + (__int128)a[0] * b[2] +\n+            (__int128)a[1] * b[1] +\n+            (__int128)a[2] * b[0];\n+    uint64_t t2 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 30000000000001A0\n+    c = c + (__int128)a[0] * b[3] +\n+            (__int128)a[1] * b[2] +\n+            (__int128)a[2] * b[1] +\n+            (__int128)a[3] * b[0];\n+    uint64_t t3 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 4000000000000280\n+    c = c + (__int128)a[0] * b[4] +\n+            (__int128)a[1] * b[3] +\n+            (__int128)a[2] * b[2] +\n+            (__int128)a[3] * b[1] +\n+            (__int128)a[4] * b[0];\n+    uint64_t t4 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 320000000000037E\n+    c = c + (__int128)a[1] * b[4] +\n+            (__int128)a[2] * b[3] +\n+            (__int128)a[3] * b[2] +\n+            (__int128)a[4] * b[1];\n+    uint64_t t5 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 22000000000002BE\n+    c = c + (__int128)a[2] * b[4] +\n+            (__int128)a[3] * b[3] +\n+            (__int128)a[4] * b[2];\n+    uint64_t t6 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 12000000000001DE\n+    c = c + (__int128)a[3] * b[4] +\n+            (__int128)a[4] * b[3];\n+    uint64_t t7 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 02000000000000FE\n+    c = c + (__int128)a[4] * b[4];\n+    uint64_t t8 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 001000000000001E\n+    uint64_t t9 = c;\n+\n+    c = t0 + (__int128)t5 * 0x1000003D10ULL;\n+    t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t1 + (__int128)t6 * 0x1000003D10ULL;\n+    t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t2 + (__int128)t7 * 0x1000003D10ULL;\n+    r[2] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t3 + (__int128)t8 * 0x1000003D10ULL;\n+    r[3] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t4 + (__int128)t9 * 0x1000003D10ULL;\n+    r[4] = c & 0x0FFFFFFFFFFFFULL; c = c >> 48; // c max 000001000003D110\n+    c = t0 + (__int128)c * 0x1000003D1ULL;\n+    r[0] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 1000008\n+    r[1] = t1 + c;\n+\n+}\n+\n+void static inline secp256k1_fe_sqr_inner(const uint64_t *a, uint64_t *r) {\n+    __int128 c = (__int128)a[0] * a[0];\n+    uint64_t t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0FFFFFFFFFFFFFE0\n+    c = c + (__int128)(a[0]*2) * a[1];\n+    uint64_t t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 20000000000000BF\n+    c = c + (__int128)(a[0]*2) * a[2] +\n+            (__int128)a[1] * a[1];\n+    uint64_t t2 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 30000000000001A0\n+    c = c + (__int128)(a[0]*2) * a[3] +\n+            (__int128)(a[1]*2) * a[2];\n+    uint64_t t3 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 4000000000000280\n+    c = c + (__int128)(a[0]*2) * a[4] +\n+            (__int128)(a[1]*2) * a[3] +\n+            (__int128)a[2] * a[2];\n+    uint64_t t4 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 320000000000037E\n+    c = c + (__int128)(a[1]*2) * a[4] +\n+            (__int128)(a[2]*2) * a[3];\n+    uint64_t t5 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 22000000000002BE\n+    c = c + (__int128)(a[2]*2) * a[4] +\n+            (__int128)a[3] * a[3];\n+    uint64_t t6 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 12000000000001DE\n+    c = c + (__int128)(a[3]*2) * a[4];\n+    uint64_t t7 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 02000000000000FE\n+    c = c + (__int128)a[4] * a[4];\n+    uint64_t t8 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 001000000000001E\n+    uint64_t t9 = c;\n+    c = t0 + (__int128)t5 * 0x1000003D10ULL;\n+    t0 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t1 + (__int128)t6 * 0x1000003D10ULL;\n+    t1 = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t2 + (__int128)t7 * 0x1000003D10ULL;\n+    r[2] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t3 + (__int128)t8 * 0x1000003D10ULL;\n+    r[3] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 0000001000003D10\n+    c = c + t4 + (__int128)t9 * 0x1000003D10ULL;\n+    r[4] = c & 0x0FFFFFFFFFFFFULL; c = c >> 48; // c max 000001000003D110\n+    c = t0 + (__int128)c * 0x1000003D1ULL;\n+    r[0] = c & 0xFFFFFFFFFFFFFULL; c = c >> 52; // c max 1000008\n+    r[1] = t1 + c;\n+\n+}\n+\n+#endif"
      },
      {
        "sha": "d51dea0afc479da5399a88fa3e6da6f0e108ca6e",
        "filename": "src/secp256k1/src/field_gmp.h",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_gmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_gmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_gmp.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,16 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_\n+#define _SECP256K1_FIELD_REPR_\n+\n+#include <gmp.h>\n+\n+#define FIELD_LIMBS ((256 + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS)\n+\n+typedef struct {\n+    mp_limb_t n[FIELD_LIMBS+1];\n+} secp256k1_fe_t;\n+\n+#endif"
      },
      {
        "sha": "d97cfa7341112f092596bc0a5bdaf1da84cb46b1",
        "filename": "src/secp256k1/src/field_gmp_impl.h",
        "status": "added",
        "additions": 159,
        "deletions": 0,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_gmp_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n+#define _SECP256K1_FIELD_REPR_IMPL_H_\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+static mp_limb_t secp256k1_field_p[FIELD_LIMBS];\n+static mp_limb_t secp256k1_field_pc[(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS];\n+\n+void static secp256k1_fe_inner_start(void) {\n+    for (int i=0; i<(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; i++)\n+        secp256k1_field_pc[i] = 0;\n+    secp256k1_field_pc[0] += 0x3D1UL;\n+    secp256k1_field_pc[32/GMP_NUMB_BITS] += (((mp_limb_t)1) << (32 % GMP_NUMB_BITS));\n+    for (int i=0; i<FIELD_LIMBS; i++) {\n+        secp256k1_field_p[i] = 0;\n+    }\n+    mpn_sub(secp256k1_field_p, secp256k1_field_p, FIELD_LIMBS, secp256k1_field_pc, (33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS);\n+}\n+\n+void static secp256k1_fe_inner_stop(void) {\n+}\n+\n+void static secp256k1_fe_normalize(secp256k1_fe_t *r) {\n+    if (r->n[FIELD_LIMBS] != 0) {\n+#if (GMP_NUMB_BITS >= 40)\n+        mp_limb_t carry = mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x1000003D1ULL * r->n[FIELD_LIMBS]);\n+        mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x1000003D1ULL * carry);\n+#else\n+        mp_limb_t carry = mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x3D1UL * r->n[FIELD_LIMBS]) + \n+                          mpn_add_1(r->n+(32/GMP_NUMB_BITS), r->n+(32/GMP_NUMB_BITS), FIELD_LIMBS-(32/GMP_NUMB_BITS), r->n[FIELD_LIMBS] << (32 % GMP_NUMB_BITS));\n+        mpn_add_1(r->n, r->n, FIELD_LIMBS, 0x3D1UL * carry);\n+        mpn_add_1(r->n+(32/GMP_NUMB_BITS), r->n+(32/GMP_NUMB_BITS), FIELD_LIMBS-(32/GMP_NUMB_BITS), carry << (32%GMP_NUMB_BITS));\n+#endif\n+        r->n[FIELD_LIMBS] = 0;\n+    }\n+    if (mpn_cmp(r->n, secp256k1_field_p, FIELD_LIMBS) >= 0)\n+        mpn_sub(r->n, r->n, FIELD_LIMBS, secp256k1_field_p, FIELD_LIMBS);\n+}\n+\n+void static inline secp256k1_fe_set_int(secp256k1_fe_t *r, int a) {\n+    r->n[0] = a;\n+    for (int i=1; i<FIELD_LIMBS+1; i++)\n+        r->n[i] = 0;\n+}\n+\n+void static inline secp256k1_fe_clear(secp256k1_fe_t *r) {\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        r->n[i] = 0;\n+}\n+\n+int static inline secp256k1_fe_is_zero(const secp256k1_fe_t *a) {\n+    int ret = 1;\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        ret &= (a->n[i] == 0);\n+    return ret;\n+}\n+\n+int static inline secp256k1_fe_is_odd(const secp256k1_fe_t *a) {\n+    return a->n[0] & 1;\n+}\n+\n+int static inline secp256k1_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+    int ret = 1;\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        ret &= (a->n[i] == b->n[i]);\n+    return ret;\n+}\n+\n+void static secp256k1_fe_set_b32(secp256k1_fe_t *r, const unsigned char *a) {\n+    for (int i=0; i<FIELD_LIMBS+1; i++)\n+        r->n[i] = 0;\n+    for (int i=0; i<256; i++) {\n+        int limb = i/GMP_NUMB_BITS;\n+        int shift = i%GMP_NUMB_BITS;\n+        r->n[limb] |= (mp_limb_t)((a[31-i/8] >> (i%8)) & 0x1) << shift;\n+    }\n+}\n+\n+/** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n+void static secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe_t *a) {\n+    for (int i=0; i<32; i++) {\n+        int c = 0;\n+        for (int j=0; j<8; j++) {\n+            int limb = (8*i+j)/GMP_NUMB_BITS;\n+            int shift = (8*i+j)%GMP_NUMB_BITS;\n+            c |= ((a->n[limb] >> shift) & 0x1) << j;\n+        }\n+        r[31-i] = c;\n+    }\n+}\n+\n+void static inline secp256k1_fe_negate(secp256k1_fe_t *r, const secp256k1_fe_t *a, int m) {\n+    *r = *a;\n+    secp256k1_fe_normalize(r);\n+    for (int i=0; i<FIELD_LIMBS; i++)\n+        r->n[i] = ~(r->n[i]);\n+#if (GMP_NUMB_BITS >= 33)\n+    mpn_sub_1(r->n, r->n, FIELD_LIMBS, 0x1000003D0ULL);\n+#else\n+    mpn_sub_1(r->n, r->n, FIELD_LIMBS, 0x3D0UL);\n+    mpn_sub_1(r->n+(32/GMP_NUMB_BITS), r->n+(32/GMP_NUMB_BITS), FIELD_LIMBS-(32/GMP_NUMB_BITS), 0x1UL << (32%GMP_NUMB_BITS));\n+#endif\n+}\n+\n+void static inline secp256k1_fe_mul_int(secp256k1_fe_t *r, int a) {\n+    mpn_mul_1(r->n, r->n, FIELD_LIMBS+1, a);\n+}\n+\n+void static inline secp256k1_fe_add(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+    mpn_add(r->n, r->n, FIELD_LIMBS+1, a->n, FIELD_LIMBS+1);\n+}\n+\n+void static secp256k1_fe_reduce(secp256k1_fe_t *r, mp_limb_t *tmp) {\n+    // <A1 A2 A3 A4> <B1 B2 B3 B4>\n+    //       B1 B2 B3 B4\n+    // + C * A1 A2 A3 A4\n+    // +  A1 A2 A3 A4\n+\n+#if (GMP_NUMB_BITS >= 33)\n+    mp_limb_t o = mpn_addmul_1(tmp, tmp+FIELD_LIMBS, FIELD_LIMBS, 0x1000003D1ULL);\n+#else\n+    mp_limb_t o = mpn_addmul_1(tmp, tmp+FIELD_LIMBS, FIELD_LIMBS, 0x3D1UL) +\n+                  mpn_addmul_1(tmp+(32/GMP_NUMB_BITS), tmp+FIELD_LIMBS, FIELD_LIMBS-(32/GMP_NUMB_BITS), 0x1UL << (32%GMP_NUMB_BITS));\n+#endif\n+    mp_limb_t q[1+(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS];\n+    q[(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS] = mpn_mul_1(q, secp256k1_field_pc, (33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS, o);\n+#if (GMP_NUMB_BITS <= 32)\n+    mp_limb_t o2 = tmp[2*FIELD_LIMBS-(32/GMP_NUMB_BITS)] << (32%GMP_NUMB_BITS);\n+    q[(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS] += mpn_addmul_1(q, secp256k1_field_pc, (33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS, o2);\n+#endif\n+    r->n[FIELD_LIMBS] = mpn_add(r->n, tmp, FIELD_LIMBS, q, 1+(33+GMP_NUMB_BITS-1)/GMP_NUMB_BITS);\n+}\n+\n+void static secp256k1_fe_mul(secp256k1_fe_t *r, const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+    secp256k1_fe_t ac = *a;\n+    secp256k1_fe_t bc = *b;\n+    secp256k1_fe_normalize(&ac);\n+    secp256k1_fe_normalize(&bc);\n+    mp_limb_t tmp[2*FIELD_LIMBS];\n+    mpn_mul_n(tmp, ac.n, bc.n, FIELD_LIMBS);\n+    secp256k1_fe_reduce(r, tmp);\n+}\n+\n+void static secp256k1_fe_sqr(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+    secp256k1_fe_t ac = *a;\n+    secp256k1_fe_normalize(&ac);\n+    mp_limb_t tmp[2*FIELD_LIMBS];\n+    mpn_sqr(tmp, ac.n, FIELD_LIMBS);\n+    secp256k1_fe_reduce(r, tmp);\n+}\n+\n+#endif"
      },
      {
        "sha": "df6216f3dbe0fefd8b9ac805db4160c7bb0097f6",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "added",
        "additions": 289,
        "deletions": 0,
        "changes": 289,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,289 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_FIELD_IMPL_H_\n+#define _SECP256K1_FIELD_IMPL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"util.h\"\n+\n+#if defined(USE_FIELD_GMP)\n+#include \"field_gmp_impl.h\"\n+#elif defined(USE_FIELD_10X26)\n+#include \"field_10x26_impl.h\"\n+#elif defined(USE_FIELD_5X52)\n+#include \"field_5x52_impl.h\"\n+#else\n+#error \"Please select field implementation\"\n+#endif\n+\n+void static secp256k1_fe_get_hex(char *r, int *rlen, const secp256k1_fe_t *a) {\n+    if (*rlen < 65) {\n+        *rlen = 65;\n+        return;\n+    }\n+    *rlen = 65;\n+    unsigned char tmp[32];\n+    secp256k1_fe_t b = *a;\n+    secp256k1_fe_normalize(&b);\n+    secp256k1_fe_get_b32(tmp, &b);\n+    for (int i=0; i<32; i++) {\n+        static const char *c = \"0123456789ABCDEF\";\n+        r[2*i]   = c[(tmp[i] >> 4) & 0xF];\n+        r[2*i+1] = c[(tmp[i]) & 0xF];\n+    }\n+    r[64] = 0x00;\n+}\n+\n+void static secp256k1_fe_set_hex(secp256k1_fe_t *r, const char *a, int alen) {\n+    unsigned char tmp[32] = {};\n+    static const int cvt[256] = {0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 1, 2, 3, 4, 5, 6,7,8,9,0,0,0,0,0,0,\n+                                 0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+                                 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0};\n+    for (int i=0; i<32; i++) {\n+        if (alen > i*2)\n+            tmp[32 - alen/2 + i] = (cvt[(unsigned char)a[2*i]] << 4) + cvt[(unsigned char)a[2*i+1]];\n+    }\n+    secp256k1_fe_set_b32(r, tmp);\n+}\n+\n+int static secp256k1_fe_sqrt(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+\n+    // The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in\n+    // { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n+    // 1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n+\n+    secp256k1_fe_t x2;\n+    secp256k1_fe_sqr(&x2, a);\n+    secp256k1_fe_mul(&x2, &x2, a);\n+\n+    secp256k1_fe_t x3;\n+    secp256k1_fe_sqr(&x3, &x2);\n+    secp256k1_fe_mul(&x3, &x3, a);\n+\n+    secp256k1_fe_t x6 = x3;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    secp256k1_fe_mul(&x6, &x6, &x3);\n+\n+    secp256k1_fe_t x9 = x6;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    secp256k1_fe_mul(&x9, &x9, &x3);\n+\n+    secp256k1_fe_t x11 = x9;\n+    for (int j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    secp256k1_fe_mul(&x11, &x11, &x2);\n+\n+    secp256k1_fe_t x22 = x11;\n+    for (int j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    secp256k1_fe_mul(&x22, &x22, &x11);\n+\n+    secp256k1_fe_t x44 = x22;\n+    for (int j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    secp256k1_fe_mul(&x44, &x44, &x22);\n+\n+    secp256k1_fe_t x88 = x44;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    secp256k1_fe_mul(&x88, &x88, &x44);\n+\n+    secp256k1_fe_t x176 = x88;\n+    for (int j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    secp256k1_fe_mul(&x176, &x176, &x88);\n+\n+    secp256k1_fe_t x220 = x176;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    secp256k1_fe_mul(&x220, &x220, &x44);\n+\n+    secp256k1_fe_t x223 = x220;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    secp256k1_fe_mul(&x223, &x223, &x3);\n+\n+    // The final result is then assembled using a sliding window over the blocks.\n+\n+    secp256k1_fe_t t1 = x223;\n+    for (int j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x22);\n+    for (int j=0; j<6; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x2);\n+    secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_sqr(r, &t1);\n+\n+    // Check that a square root was actually calculated\n+\n+    secp256k1_fe_sqr(&t1, r);\n+    secp256k1_fe_negate(&t1, &t1, 1);\n+    secp256k1_fe_add(&t1, a);\n+    secp256k1_fe_normalize(&t1);\n+    return secp256k1_fe_is_zero(&t1);\n+}\n+\n+void static secp256k1_fe_inv(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+\n+    // The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n+    // { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n+    // [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n+\n+    secp256k1_fe_t x2;\n+    secp256k1_fe_sqr(&x2, a);\n+    secp256k1_fe_mul(&x2, &x2, a);\n+\n+    secp256k1_fe_t x3;\n+    secp256k1_fe_sqr(&x3, &x2);\n+    secp256k1_fe_mul(&x3, &x3, a);\n+\n+    secp256k1_fe_t x6 = x3;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x6, &x6);\n+    secp256k1_fe_mul(&x6, &x6, &x3);\n+\n+    secp256k1_fe_t x9 = x6;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x9, &x9);\n+    secp256k1_fe_mul(&x9, &x9, &x3);\n+\n+    secp256k1_fe_t x11 = x9;\n+    for (int j=0; j<2; j++) secp256k1_fe_sqr(&x11, &x11);\n+    secp256k1_fe_mul(&x11, &x11, &x2);\n+\n+    secp256k1_fe_t x22 = x11;\n+    for (int j=0; j<11; j++) secp256k1_fe_sqr(&x22, &x22);\n+    secp256k1_fe_mul(&x22, &x22, &x11);\n+\n+    secp256k1_fe_t x44 = x22;\n+    for (int j=0; j<22; j++) secp256k1_fe_sqr(&x44, &x44);\n+    secp256k1_fe_mul(&x44, &x44, &x22);\n+\n+    secp256k1_fe_t x88 = x44;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x88, &x88);\n+    secp256k1_fe_mul(&x88, &x88, &x44);\n+\n+    secp256k1_fe_t x176 = x88;\n+    for (int j=0; j<88; j++) secp256k1_fe_sqr(&x176, &x176);\n+    secp256k1_fe_mul(&x176, &x176, &x88);\n+\n+    secp256k1_fe_t x220 = x176;\n+    for (int j=0; j<44; j++) secp256k1_fe_sqr(&x220, &x220);\n+    secp256k1_fe_mul(&x220, &x220, &x44);\n+\n+    secp256k1_fe_t x223 = x220;\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&x223, &x223);\n+    secp256k1_fe_mul(&x223, &x223, &x3);\n+\n+    // The final result is then assembled using a sliding window over the blocks.\n+\n+    secp256k1_fe_t t1 = x223;\n+    for (int j=0; j<23; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x22);\n+    for (int j=0; j<5; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, a);\n+    for (int j=0; j<3; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(&t1, &t1, &x2);\n+    for (int j=0; j<2; j++) secp256k1_fe_sqr(&t1, &t1);\n+    secp256k1_fe_mul(r, &t1, a);\n+}\n+\n+void static secp256k1_fe_inv_var(secp256k1_fe_t *r, const secp256k1_fe_t *a) {\n+#if defined(USE_FIELD_INV_BUILTIN)\n+    secp256k1_fe_inv(r, a);\n+#elif defined(USE_FIELD_INV_NUM)\n+    unsigned char b[32];\n+    secp256k1_fe_t c = *a;\n+    secp256k1_fe_normalize(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_t n; \n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_mod_inverse(&n, &n, &secp256k1_fe_consts->p);\n+    secp256k1_num_get_bin(b, 32, &n);\n+    secp256k1_fe_set_b32(r, b);\n+#else\n+#error \"Please select field inverse implementation\"\n+#endif\n+}\n+\n+void static secp256k1_fe_inv_all(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n+    if (len < 1)\n+        return;\n+\n+    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n+\n+    r[0] = a[0];\n+\n+    int i = 0;\n+    while (++i < len) {\n+        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n+    }\n+\n+    secp256k1_fe_t u; secp256k1_fe_inv(&u, &r[--i]);\n+\n+    while (i > 0) {\n+        int j = i--;\n+        secp256k1_fe_mul(&r[j], &r[i], &u);\n+        secp256k1_fe_mul(&u, &u, &a[j]);\n+    }\n+\n+    r[0] = u;\n+}\n+\n+void static secp256k1_fe_inv_all_var(size_t len, secp256k1_fe_t r[len], const secp256k1_fe_t a[len]) {\n+    if (len < 1)\n+        return;\n+\n+    VERIFY_CHECK((r + len <= a) || (a + len <= r));\n+\n+    r[0] = a[0];\n+\n+    int i = 0;\n+    while (++i < len) {\n+        secp256k1_fe_mul(&r[i], &r[i - 1], &a[i]);\n+    }\n+\n+    secp256k1_fe_t u; secp256k1_fe_inv_var(&u, &r[--i]);\n+\n+    while (i > 0) {\n+        int j = i--;\n+        secp256k1_fe_mul(&r[j], &r[i], &u);\n+        secp256k1_fe_mul(&u, &u, &a[j]);\n+    }\n+\n+    r[0] = u;\n+}\n+\n+void static secp256k1_fe_start(void) {\n+    static const unsigned char secp256k1_fe_consts_p[] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+    if (secp256k1_fe_consts == NULL) {\n+        secp256k1_fe_inner_start();\n+        secp256k1_fe_consts_t *ret = (secp256k1_fe_consts_t*)malloc(sizeof(secp256k1_fe_consts_t));\n+        secp256k1_num_set_bin(&ret->p, secp256k1_fe_consts_p, sizeof(secp256k1_fe_consts_p));\n+        secp256k1_fe_consts = ret;\n+    }\n+}\n+\n+void static secp256k1_fe_stop(void) {\n+    if (secp256k1_fe_consts != NULL) {\n+        secp256k1_fe_consts_t *c = (secp256k1_fe_consts_t*)secp256k1_fe_consts;\n+        free((void*)c);\n+        secp256k1_fe_consts = NULL;\n+        secp256k1_fe_inner_stop();\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "fde1e1365f49ff43b554ce75550ba0bc96db8fdb",
        "filename": "src/secp256k1/src/group.h",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_GROUP_\n+#define _SECP256K1_GROUP_\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+\n+/** A group element of the secp256k1 curve, in affine coordinates. */\n+typedef struct {\n+    secp256k1_fe_t x;\n+    secp256k1_fe_t y;\n+    int infinity; // whether this represents the point at infinity\n+} secp256k1_ge_t;\n+\n+/** A group element of the secp256k1 curve, in jacobian coordinates. */\n+typedef struct {\n+    secp256k1_fe_t x; // actual X: x/z^2\n+    secp256k1_fe_t y; // actual Y: y/z^3\n+    secp256k1_fe_t z;\n+    int infinity; // whether this represents the point at infinity\n+} secp256k1_gej_t;\n+\n+/** Global constants related to the group */\n+typedef struct {\n+    secp256k1_num_t order; // the order of the curve (= order of its generator)\n+    secp256k1_num_t half_order; // half the order of the curve (= order of its generator)\n+    secp256k1_ge_t g; // the generator point\n+\n+#ifdef USE_ENDOMORPHISM\n+    // constants related to secp256k1's efficiently computable endomorphism\n+    secp256k1_fe_t beta;\n+    secp256k1_num_t lambda, a1b2, b1, a2;\n+#endif\n+} secp256k1_ge_consts_t;\n+\n+static const secp256k1_ge_consts_t *secp256k1_ge_consts = NULL;\n+\n+/** Initialize the group module. */\n+void static secp256k1_ge_start(void);\n+\n+/** De-initialize the group module. */\n+void static secp256k1_ge_stop(void);\n+\n+/** Set a group element equal to the point at infinity */\n+void static secp256k1_ge_set_infinity(secp256k1_ge_t *r);\n+\n+/** Set a group element equal to the point with given X and Y coordinates */\n+void static secp256k1_ge_set_xy(secp256k1_ge_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y);\n+\n+/** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n+ *  for Y. Return value indicates whether the result is valid. */\n+int  static secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd);\n+\n+/** Check whether a group element is the point at infinity. */\n+int  static secp256k1_ge_is_infinity(const secp256k1_ge_t *a);\n+\n+/** Check whether a group element is valid (i.e., on the curve). */\n+int  static secp256k1_ge_is_valid(const secp256k1_ge_t *a);\n+\n+void static secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a);\n+\n+/** Get a hex representation of a point. *rlen will be overwritten with the real length. */\n+void static secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a);\n+\n+/** Set a group element equal to another which is given in jacobian coordinates */\n+void static secp256k1_ge_set_gej(secp256k1_ge_t *r, secp256k1_gej_t *a);\n+\n+/** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n+void static secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], const secp256k1_gej_t a[len]);\n+\n+\n+/** Set a group element (jacobian) equal to the point at infinity. */\n+void static secp256k1_gej_set_infinity(secp256k1_gej_t *r);\n+\n+/** Set a group element (jacobian) equal to the point with given X and Y coordinates. */\n+void static secp256k1_gej_set_xy(secp256k1_gej_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y);\n+\n+/** Set a group element (jacobian) equal to another which is given in affine coordinates. */\n+void static secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a);\n+\n+/** Get the X coordinate of a group element (jacobian). */\n+void static secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a);\n+\n+/** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n+void static secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+\n+/** Check whether a group element is the point at infinity. */\n+int  static secp256k1_gej_is_infinity(const secp256k1_gej_t *a);\n+\n+/** Set r equal to the double of a. */\n+void static secp256k1_gej_double_var(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+\n+/** Set r equal to the sum of a and b. */\n+void static secp256k1_gej_add_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_gej_t *b);\n+\n+/** Set r equal to the sum of a and b (with b given in affine coordinates). This is more efficient\n+    than secp256k1_gej_add. */\n+void static secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_ge_t *b);\n+\n+/** Get a hex representation of a point. *rlen will be overwritten with the real length. */\n+void static secp256k1_gej_get_hex(char *r, int *rlen, const secp256k1_gej_t *a);\n+\n+#ifdef USE_ENDOMORPHISM\n+/** Set r to be equal to lambda times a, where lambda is chosen in a way such that this is very fast. */\n+void static secp256k1_gej_mul_lambda(secp256k1_gej_t *r, const secp256k1_gej_t *a);\n+\n+/** Find r1 and r2 such that r1+r2*lambda = a, and r1 and r2 are maximum 128 bits long (given that a is\n+    not more than 256 bits). */\n+void static secp256k1_gej_split_exp_var(secp256k1_num_t *r1, secp256k1_num_t *r2, const secp256k1_num_t *a);\n+#endif\n+\n+/** Clear a secp256k1_gej_t to prevent leaking sensitive information. */\n+void static secp256k1_gej_clear(secp256k1_gej_t *r);\n+\n+/** Clear a secp256k1_ge_t to prevent leaking sensitive information. */\n+void static secp256k1_ge_clear(secp256k1_ge_t *r);\n+\n+\n+#endif"
      },
      {
        "sha": "446ddf9daf8ba9beb1a47f748594223158c90d46",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "added",
        "additions": 439,
        "deletions": 0,
        "changes": 439,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,439 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_GROUP_IMPL_H_\n+#define _SECP256K1_GROUP_IMPL_H_\n+\n+#include <string.h>\n+\n+#include \"num.h\"\n+#include \"field.h\"\n+#include \"group.h\"\n+\n+void static secp256k1_ge_set_infinity(secp256k1_ge_t *r) {\n+    r->infinity = 1;\n+}\n+\n+void static secp256k1_ge_set_xy(secp256k1_ge_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y) {\n+    r->infinity = 0;\n+    r->x = *x;\n+    r->y = *y;\n+}\n+\n+int static secp256k1_ge_is_infinity(const secp256k1_ge_t *a) {\n+    return a->infinity;\n+}\n+\n+void static secp256k1_ge_neg(secp256k1_ge_t *r, const secp256k1_ge_t *a) {\n+    r->infinity = a->infinity;\n+    r->x = a->x;\n+    r->y = a->y;\n+    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_negate(&r->y, &r->y, 1);\n+}\n+\n+void static secp256k1_ge_get_hex(char *r, int *rlen, const secp256k1_ge_t *a) {\n+    char cx[65]; int lx=65;\n+    char cy[65]; int ly=65;\n+    secp256k1_fe_get_hex(cx, &lx, &a->x);\n+    secp256k1_fe_get_hex(cy, &ly, &a->y);\n+    lx = strlen(cx);\n+    ly = strlen(cy);\n+    int len = lx + ly + 3 + 1;\n+    if (*rlen < len) {\n+        *rlen = len;\n+        return;\n+    }\n+    *rlen = len;\n+    r[0] = '(';\n+    memcpy(r+1, cx, lx);\n+    r[1+lx] = ',';\n+    memcpy(r+2+lx, cy, ly);\n+    r[2+lx+ly] = ')';\n+    r[3+lx+ly] = 0;\n+}\n+\n+void static secp256k1_ge_set_gej(secp256k1_ge_t *r, secp256k1_gej_t *a) {\n+    r->infinity = a->infinity;\n+    secp256k1_fe_inv(&a->z, &a->z);\n+    secp256k1_fe_t z2; secp256k1_fe_sqr(&z2, &a->z);\n+    secp256k1_fe_t z3; secp256k1_fe_mul(&z3, &a->z, &z2);\n+    secp256k1_fe_mul(&a->x, &a->x, &z2);\n+    secp256k1_fe_mul(&a->y, &a->y, &z3);\n+    secp256k1_fe_set_int(&a->z, 1);\n+    r->x = a->x;\n+    r->y = a->y;\n+}\n+\n+void static secp256k1_ge_set_gej_var(secp256k1_ge_t *r, secp256k1_gej_t *a) {\n+    r->infinity = a->infinity;\n+    if (a->infinity) {\n+        return;\n+    }\n+    secp256k1_fe_inv_var(&a->z, &a->z);\n+    secp256k1_fe_t z2; secp256k1_fe_sqr(&z2, &a->z);\n+    secp256k1_fe_t z3; secp256k1_fe_mul(&z3, &a->z, &z2);\n+    secp256k1_fe_mul(&a->x, &a->x, &z2);\n+    secp256k1_fe_mul(&a->y, &a->y, &z3);\n+    secp256k1_fe_set_int(&a->z, 1);\n+    r->x = a->x;\n+    r->y = a->y;\n+}\n+\n+void static secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge_t r[len], const secp256k1_gej_t a[len]) {\n+    int count = 0;\n+    secp256k1_fe_t az[len];\n+    for (int i=0; i<len; i++) {\n+        if (!a[i].infinity) {\n+            az[count++] = a[i].z;\n+        }\n+    }\n+\n+    secp256k1_fe_t azi[count];\n+    secp256k1_fe_inv_all_var(count, azi, az);\n+\n+    count = 0;\n+    for (int i=0; i<len; i++) {\n+        r[i].infinity = a[i].infinity;\n+        if (!a[i].infinity) {\n+            secp256k1_fe_t *zi = &azi[count++];\n+            secp256k1_fe_t zi2; secp256k1_fe_sqr(&zi2, zi);\n+            secp256k1_fe_t zi3; secp256k1_fe_mul(&zi3, &zi2, zi);\n+            secp256k1_fe_mul(&r[i].x, &a[i].x, &zi2);\n+            secp256k1_fe_mul(&r[i].y, &a[i].y, &zi3);\n+        }\n+    }\n+}\n+\n+void static secp256k1_gej_set_infinity(secp256k1_gej_t *r) {\n+    r->infinity = 1;\n+}\n+\n+void static secp256k1_gej_set_xy(secp256k1_gej_t *r, const secp256k1_fe_t *x, const secp256k1_fe_t *y) {\n+    r->infinity = 0;\n+    r->x = *x;\n+    r->y = *y;\n+    secp256k1_fe_set_int(&r->z, 1);\n+}\n+\n+void static secp256k1_gej_clear(secp256k1_gej_t *r) {\n+    r->infinity = 0;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+    secp256k1_fe_clear(&r->z);\n+}\n+\n+void static secp256k1_ge_clear(secp256k1_ge_t *r) {\n+    r->infinity = 0;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+}\n+\n+int static secp256k1_ge_set_xo(secp256k1_ge_t *r, const secp256k1_fe_t *x, int odd) {\n+    r->x = *x;\n+    secp256k1_fe_t x2; secp256k1_fe_sqr(&x2, x);\n+    secp256k1_fe_t x3; secp256k1_fe_mul(&x3, x, &x2);\n+    r->infinity = 0;\n+    secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_add(&c, &x3);\n+    if (!secp256k1_fe_sqrt(&r->y, &c))\n+        return 0;\n+    secp256k1_fe_normalize(&r->y);\n+    if (secp256k1_fe_is_odd(&r->y) != odd)\n+        secp256k1_fe_negate(&r->y, &r->y, 1);\n+    return 1;\n+}\n+\n+void static secp256k1_gej_set_ge(secp256k1_gej_t *r, const secp256k1_ge_t *a) {\n+   r->infinity = a->infinity;\n+   r->x = a->x;\n+   r->y = a->y;\n+   secp256k1_fe_set_int(&r->z, 1);\n+}\n+\n+void static secp256k1_gej_get_x_var(secp256k1_fe_t *r, const secp256k1_gej_t *a) {\n+    secp256k1_fe_t zi2; secp256k1_fe_inv_var(&zi2, &a->z); secp256k1_fe_sqr(&zi2, &zi2);\n+    secp256k1_fe_mul(r, &a->x, &zi2);\n+}\n+\n+void static secp256k1_gej_neg(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+    r->infinity = a->infinity;\n+    r->x = a->x;\n+    r->y = a->y;\n+    r->z = a->z;\n+    secp256k1_fe_normalize(&r->y);\n+    secp256k1_fe_negate(&r->y, &r->y, 1);\n+}\n+\n+int static secp256k1_gej_is_infinity(const secp256k1_gej_t *a) {\n+    return a->infinity;\n+}\n+\n+int static secp256k1_gej_is_valid(const secp256k1_gej_t *a) {\n+    if (a->infinity)\n+        return 0;\n+    // y^2 = x^3 + 7\n+    // (Y/Z^3)^2 = (X/Z^2)^3 + 7\n+    // Y^2 / Z^6 = X^3 / Z^6 + 7\n+    // Y^2 = X^3 + 7*Z^6\n+    secp256k1_fe_t y2; secp256k1_fe_sqr(&y2, &a->y);\n+    secp256k1_fe_t x3; secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n+    secp256k1_fe_t z2; secp256k1_fe_sqr(&z2, &a->z);\n+    secp256k1_fe_t z6; secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n+    secp256k1_fe_mul_int(&z6, 7);\n+    secp256k1_fe_add(&x3, &z6);\n+    secp256k1_fe_normalize(&y2);\n+    secp256k1_fe_normalize(&x3);\n+    return secp256k1_fe_equal(&y2, &x3);\n+}\n+\n+int static secp256k1_ge_is_valid(const secp256k1_ge_t *a) {\n+    if (a->infinity)\n+        return 0;\n+    // y^2 = x^3 + 7\n+    secp256k1_fe_t y2; secp256k1_fe_sqr(&y2, &a->y);\n+    secp256k1_fe_t x3; secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n+    secp256k1_fe_t c; secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_add(&x3, &c);\n+    secp256k1_fe_normalize(&y2);\n+    secp256k1_fe_normalize(&x3);\n+    return secp256k1_fe_equal(&y2, &x3);\n+}\n+\n+void static secp256k1_gej_double_var(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+    if (a->infinity) {\n+        r->infinity = 1;\n+        return;\n+    }\n+\n+    secp256k1_fe_t t5 = a->y;\n+    secp256k1_fe_normalize(&t5);\n+    if (secp256k1_fe_is_zero(&t5)) {\n+        r->infinity = 1;\n+        return;\n+    }\n+\n+    secp256k1_fe_t t1,t2,t3,t4;\n+    secp256k1_fe_mul(&r->z, &t5, &a->z);\n+    secp256k1_fe_mul_int(&r->z, 2);       // Z' = 2*Y*Z (2)\n+    secp256k1_fe_sqr(&t1, &a->x);\n+    secp256k1_fe_mul_int(&t1, 3);         // T1 = 3*X^2 (3)\n+    secp256k1_fe_sqr(&t2, &t1);           // T2 = 9*X^4 (1)\n+    secp256k1_fe_sqr(&t3, &t5);\n+    secp256k1_fe_mul_int(&t3, 2);         // T3 = 2*Y^2 (2)\n+    secp256k1_fe_sqr(&t4, &t3);\n+    secp256k1_fe_mul_int(&t4, 2);         // T4 = 8*Y^4 (2)\n+    secp256k1_fe_mul(&t3, &a->x, &t3);    // T3 = 2*X*Y^2 (1)\n+    r->x = t3;\n+    secp256k1_fe_mul_int(&r->x, 4);       // X' = 8*X*Y^2 (4)\n+    secp256k1_fe_negate(&r->x, &r->x, 4); // X' = -8*X*Y^2 (5)\n+    secp256k1_fe_add(&r->x, &t2);         // X' = 9*X^4 - 8*X*Y^2 (6)\n+    secp256k1_fe_negate(&t2, &t2, 1);     // T2 = -9*X^4 (2)\n+    secp256k1_fe_mul_int(&t3, 6);         // T3 = 12*X*Y^2 (6)\n+    secp256k1_fe_add(&t3, &t2);           // T3 = 12*X*Y^2 - 9*X^4 (8)\n+    secp256k1_fe_mul(&r->y, &t1, &t3);    // Y' = 36*X^3*Y^2 - 27*X^6 (1)\n+    secp256k1_fe_negate(&t2, &t4, 2);     // T2 = -8*Y^4 (3)\n+    secp256k1_fe_add(&r->y, &t2);         // Y' = 36*X^3*Y^2 - 27*X^6 - 8*Y^4 (4)\n+    r->infinity = 0;\n+}\n+\n+void static secp256k1_gej_add_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_gej_t *b) {\n+    if (a->infinity) {\n+        *r = *b;\n+        return;\n+    }\n+    if (b->infinity) {\n+        *r = *a;\n+        return;\n+    }\n+    r->infinity = 0;\n+    secp256k1_fe_t z22; secp256k1_fe_sqr(&z22, &b->z);\n+    secp256k1_fe_t z12; secp256k1_fe_sqr(&z12, &a->z);\n+    secp256k1_fe_t u1; secp256k1_fe_mul(&u1, &a->x, &z22);\n+    secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n+    secp256k1_fe_t s1; secp256k1_fe_mul(&s1, &a->y, &z22); secp256k1_fe_mul(&s1, &s1, &b->z);\n+    secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n+    secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_normalize(&u2);\n+    if (secp256k1_fe_equal(&u1, &u2)) {\n+        secp256k1_fe_normalize(&s1);\n+        secp256k1_fe_normalize(&s2);\n+        if (secp256k1_fe_equal(&s1, &s2)) {\n+            secp256k1_gej_double_var(r, a);\n+        } else {\n+            r->infinity = 1;\n+        }\n+        return;\n+    }\n+    secp256k1_fe_t h; secp256k1_fe_negate(&h, &u1, 1); secp256k1_fe_add(&h, &u2);\n+    secp256k1_fe_t i; secp256k1_fe_negate(&i, &s1, 1); secp256k1_fe_add(&i, &s2);\n+    secp256k1_fe_t i2; secp256k1_fe_sqr(&i2, &i);\n+    secp256k1_fe_t h2; secp256k1_fe_sqr(&h2, &h);\n+    secp256k1_fe_t h3; secp256k1_fe_mul(&h3, &h, &h2);\n+    secp256k1_fe_mul(&r->z, &a->z, &b->z); secp256k1_fe_mul(&r->z, &r->z, &h);\n+    secp256k1_fe_t t; secp256k1_fe_mul(&t, &u1, &h2);\n+    r->x = t; secp256k1_fe_mul_int(&r->x, 2); secp256k1_fe_add(&r->x, &h3); secp256k1_fe_negate(&r->x, &r->x, 3); secp256k1_fe_add(&r->x, &i2);\n+    secp256k1_fe_negate(&r->y, &r->x, 5); secp256k1_fe_add(&r->y, &t); secp256k1_fe_mul(&r->y, &r->y, &i);\n+    secp256k1_fe_mul(&h3, &h3, &s1); secp256k1_fe_negate(&h3, &h3, 1);\n+    secp256k1_fe_add(&r->y, &h3);\n+}\n+\n+void static secp256k1_gej_add_ge_var(secp256k1_gej_t *r, const secp256k1_gej_t *a, const secp256k1_ge_t *b) {\n+    if (a->infinity) {\n+        r->infinity = b->infinity;\n+        r->x = b->x;\n+        r->y = b->y;\n+        secp256k1_fe_set_int(&r->z, 1);\n+        return;\n+    }\n+    if (b->infinity) {\n+        *r = *a;\n+        return;\n+    }\n+    r->infinity = 0;\n+    secp256k1_fe_t z12; secp256k1_fe_sqr(&z12, &a->z);\n+    secp256k1_fe_t u1 = a->x; secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_t u2; secp256k1_fe_mul(&u2, &b->x, &z12);\n+    secp256k1_fe_t s1 = a->y; secp256k1_fe_normalize(&s1);\n+    secp256k1_fe_t s2; secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);\n+    secp256k1_fe_normalize(&u1);\n+    secp256k1_fe_normalize(&u2);\n+    if (secp256k1_fe_equal(&u1, &u2)) {\n+        secp256k1_fe_normalize(&s1);\n+        secp256k1_fe_normalize(&s2);\n+        if (secp256k1_fe_equal(&s1, &s2)) {\n+            secp256k1_gej_double_var(r, a);\n+        } else {\n+            r->infinity = 1;\n+        }\n+        return;\n+    }\n+    secp256k1_fe_t h; secp256k1_fe_negate(&h, &u1, 1); secp256k1_fe_add(&h, &u2);\n+    secp256k1_fe_t i; secp256k1_fe_negate(&i, &s1, 1); secp256k1_fe_add(&i, &s2);\n+    secp256k1_fe_t i2; secp256k1_fe_sqr(&i2, &i);\n+    secp256k1_fe_t h2; secp256k1_fe_sqr(&h2, &h);\n+    secp256k1_fe_t h3; secp256k1_fe_mul(&h3, &h, &h2);\n+    r->z = a->z; secp256k1_fe_mul(&r->z, &r->z, &h);\n+    secp256k1_fe_t t; secp256k1_fe_mul(&t, &u1, &h2);\n+    r->x = t; secp256k1_fe_mul_int(&r->x, 2); secp256k1_fe_add(&r->x, &h3); secp256k1_fe_negate(&r->x, &r->x, 3); secp256k1_fe_add(&r->x, &i2);\n+    secp256k1_fe_negate(&r->y, &r->x, 5); secp256k1_fe_add(&r->y, &t); secp256k1_fe_mul(&r->y, &r->y, &i);\n+    secp256k1_fe_mul(&h3, &h3, &s1); secp256k1_fe_negate(&h3, &h3, 1);\n+    secp256k1_fe_add(&r->y, &h3);\n+}\n+\n+void static secp256k1_gej_get_hex(char *r, int *rlen, const secp256k1_gej_t *a) {\n+    secp256k1_gej_t c = *a;\n+    secp256k1_ge_t t; secp256k1_ge_set_gej(&t, &c);\n+    secp256k1_ge_get_hex(r, rlen, &t);\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+void static secp256k1_gej_mul_lambda(secp256k1_gej_t *r, const secp256k1_gej_t *a) {\n+    const secp256k1_fe_t *beta = &secp256k1_ge_consts->beta;\n+    *r = *a;\n+    secp256k1_fe_mul(&r->x, &r->x, beta);\n+}\n+\n+void static secp256k1_gej_split_exp_var(secp256k1_num_t *r1, secp256k1_num_t *r2, const secp256k1_num_t *a) {\n+    const secp256k1_ge_consts_t *c = secp256k1_ge_consts;\n+    secp256k1_num_t bnc1, bnc2, bnt1, bnt2, bnn2;\n+\n+    secp256k1_num_copy(&bnn2, &c->order);\n+    secp256k1_num_shift(&bnn2, 1);\n+\n+    secp256k1_num_mul(&bnc1, a, &c->a1b2);\n+    secp256k1_num_add(&bnc1, &bnc1, &bnn2);\n+    secp256k1_num_div(&bnc1, &bnc1, &c->order);\n+\n+    secp256k1_num_mul(&bnc2, a, &c->b1);\n+    secp256k1_num_add(&bnc2, &bnc2, &bnn2);\n+    secp256k1_num_div(&bnc2, &bnc2, &c->order);\n+\n+    secp256k1_num_mul(&bnt1, &bnc1, &c->a1b2);\n+    secp256k1_num_mul(&bnt2, &bnc2, &c->a2);\n+    secp256k1_num_add(&bnt1, &bnt1, &bnt2);\n+    secp256k1_num_sub(r1, a, &bnt1);\n+    secp256k1_num_mul(&bnt1, &bnc1, &c->b1);\n+    secp256k1_num_mul(&bnt2, &bnc2, &c->a1b2);\n+    secp256k1_num_sub(r2, &bnt1, &bnt2);\n+}\n+#endif\n+\n+\n+void static secp256k1_ge_start(void) {\n+    static const unsigned char secp256k1_ge_consts_order[] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n+        0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n+        0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n+    };\n+    static const unsigned char secp256k1_ge_consts_g_x[] = {\n+        0x79,0xBE,0x66,0x7E,0xF9,0xDC,0xBB,0xAC,\n+        0x55,0xA0,0x62,0x95,0xCE,0x87,0x0B,0x07,\n+        0x02,0x9B,0xFC,0xDB,0x2D,0xCE,0x28,0xD9,\n+        0x59,0xF2,0x81,0x5B,0x16,0xF8,0x17,0x98\n+    };\n+    static const unsigned char secp256k1_ge_consts_g_y[] = {\n+        0x48,0x3A,0xDA,0x77,0x26,0xA3,0xC4,0x65,\n+        0x5D,0xA4,0xFB,0xFC,0x0E,0x11,0x08,0xA8,\n+        0xFD,0x17,0xB4,0x48,0xA6,0x85,0x54,0x19,\n+        0x9C,0x47,0xD0,0x8F,0xFB,0x10,0xD4,0xB8\n+    };\n+#ifdef USE_ENDOMORPHISM\n+    // properties of secp256k1's efficiently computable endomorphism\n+    static const unsigned char secp256k1_ge_consts_lambda[] = {\n+        0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,\n+        0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n+        0x12,0x2e,0x22,0xea,0x20,0x81,0x66,0x78,\n+        0xdf,0x02,0x96,0x7c,0x1b,0x23,0xbd,0x72\n+    };\n+    static const unsigned char secp256k1_ge_consts_beta[] = {\n+        0x7a,0xe9,0x6a,0x2b,0x65,0x7c,0x07,0x10,\n+        0x6e,0x64,0x47,0x9e,0xac,0x34,0x34,0xe9,\n+        0x9c,0xf0,0x49,0x75,0x12,0xf5,0x89,0x95,\n+        0xc1,0x39,0x6c,0x28,0x71,0x95,0x01,0xee\n+    };\n+    static const unsigned char secp256k1_ge_consts_a1b2[] = {\n+        0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,\n+        0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15\n+    };\n+    static const unsigned char secp256k1_ge_consts_b1[] = {\n+        0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,\n+        0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3\n+    };\n+    static const unsigned char secp256k1_ge_consts_a2[] = {\n+        0x01,\n+        0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,\n+        0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8\n+    };\n+#endif\n+    if (secp256k1_ge_consts == NULL) {\n+        secp256k1_ge_consts_t *ret = (secp256k1_ge_consts_t*)malloc(sizeof(secp256k1_ge_consts_t));\n+        secp256k1_num_set_bin(&ret->order,  secp256k1_ge_consts_order,  sizeof(secp256k1_ge_consts_order));\n+        secp256k1_num_copy(&ret->half_order, &ret->order);\n+        secp256k1_num_shift(&ret->half_order, 1);\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_num_set_bin(&ret->lambda, secp256k1_ge_consts_lambda, sizeof(secp256k1_ge_consts_lambda));\n+        secp256k1_num_set_bin(&ret->a1b2,   secp256k1_ge_consts_a1b2,   sizeof(secp256k1_ge_consts_a1b2));\n+        secp256k1_num_set_bin(&ret->a2,     secp256k1_ge_consts_a2,     sizeof(secp256k1_ge_consts_a2));\n+        secp256k1_num_set_bin(&ret->b1,     secp256k1_ge_consts_b1,     sizeof(secp256k1_ge_consts_b1));\n+        secp256k1_fe_set_b32(&ret->beta, secp256k1_ge_consts_beta);\n+#endif\n+        secp256k1_fe_t g_x, g_y;\n+        secp256k1_fe_set_b32(&g_x, secp256k1_ge_consts_g_x);\n+        secp256k1_fe_set_b32(&g_y, secp256k1_ge_consts_g_y);\n+        secp256k1_ge_set_xy(&ret->g, &g_x, &g_y);\n+        secp256k1_ge_consts = ret;\n+    }\n+}\n+\n+void static secp256k1_ge_stop(void) {\n+    if (secp256k1_ge_consts != NULL) {\n+        secp256k1_ge_consts_t *c = (secp256k1_ge_consts_t*)secp256k1_ge_consts;\n+        free((void*)c);\n+        secp256k1_ge_consts = NULL;\n+    }\n+}\n+\n+#endif"
      },
      {
        "sha": "90a498eaa2c40ba17b627a4406fc8af6521e2e0b",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,60 @@\n+package org.bitcoin;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import com.google.common.base.Preconditions;\n+\n+\n+/**\n+ * This class holds native methods to handle ECDSA verification.\n+ * You can find an example library that can be used for this at\n+ * https://github.com/sipa/secp256k1\n+ */\n+public class NativeSecp256k1 {\n+    public static final boolean enabled;\n+    static {\n+        boolean isEnabled = true;\n+        try {\n+            System.loadLibrary(\"javasecp256k1\");\n+        } catch (UnsatisfiedLinkError e) {\n+            isEnabled = false;\n+        }\n+        enabled = isEnabled;\n+    }\n+    \n+    private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n+    /**\n+     * Verifies the given secp256k1 signature in native code.\n+     * Calling when enabled == false is undefined (probably library not loaded)\n+     * \n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param pub The public key which did the signing\n+     */\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+        Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.putInt(signature.length);\n+        byteBuff.putInt(pub.length);\n+        byteBuff.put(signature);\n+        byteBuff.put(pub);\n+        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+    }\n+\n+    /**\n+     * @param byteBuff signature format is byte[32] data,\n+     *        native-endian int signatureLength, native-endian int pubkeyLength,\n+     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n+     * @returns 1 for valid signature, anything else for invalid\n+     */\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+}"
      },
      {
        "sha": "bb4cd707280a68f1377e90f7a9d434e194bfa6db",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,23 @@\n+#include \"org_bitcoin_NativeSecp256k1.h\"\n+#include \"include/secp256k1.h\"\n+\n+JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+{\n+\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\tint sigLen = *((int*)(data + 32));\n+\tint pubLen = *((int*)(data + 32 + 4));\n+\n+\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n+}\n+\n+static void __javasecp256k1_attach(void) __attribute__((constructor));\n+static void __javasecp256k1_detach(void) __attribute__((destructor));\n+\n+static void __javasecp256k1_attach(void) {\n+\tsecp256k1_start(SECP256K1_START_VERIFY);\n+}\n+\n+static void __javasecp256k1_detach(void) {\n+\tsecp256k1_stop();\n+}"
      },
      {
        "sha": "d7fb004fa841ede0fb2e919aa567d092e8fc2d5a",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,21 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+/* Header for class org_bitcoin_NativeSecp256k1 */\n+\n+#ifndef _Included_org_bitcoin_NativeSecp256k1\n+#define _Included_org_bitcoin_NativeSecp256k1\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_verify\n+ * Signature: (Ljava/nio/ByteBuffer;)I\n+ */\n+JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "73176d91cbe91ab740a69807101f066178c1eb6e",
        "filename": "src/secp256k1/src/num.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_\n+#define _SECP256K1_NUM_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_NUM_GMP)\n+#include \"num_gmp.h\"\n+#else\n+#error \"Please select num implementation\"\n+#endif\n+\n+/** Clear a number to prevent the leak of sensitive data. */\n+void static secp256k1_num_clear(secp256k1_num_t *r);\n+\n+/** Copy a number. */\n+void static secp256k1_num_copy(secp256k1_num_t *r, const secp256k1_num_t *a);\n+\n+/** Convert a number's absolute value to a binary big-endian string.\n+ *  There must be enough place. */\n+void static secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num_t *a);\n+\n+/** Set a number to the value of a binary big-endian string. */\n+void static secp256k1_num_set_bin(secp256k1_num_t *r, const unsigned char *a, unsigned int alen);\n+\n+/** Set a number equal to a (signed) integer. */\n+void static secp256k1_num_set_int(secp256k1_num_t *r, int a);\n+\n+/** Compute a modular inverse. The input must be less than the modulus. */\n+void static secp256k1_num_mod_inverse(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *m);\n+\n+/** Multiply two numbers modulo another. */\n+void static secp256k1_num_mod_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b, const secp256k1_num_t *m);\n+\n+/** Compare the absolute value of two numbers. */\n+int  static secp256k1_num_cmp(const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Test whether two number are equal (including sign). */\n+int  static secp256k1_num_eq(const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Add two (signed) numbers. */\n+void static secp256k1_num_add(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Subtract two (signed) numbers. */\n+void static secp256k1_num_sub(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Multiply two (signed) numbers. */\n+void static secp256k1_num_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Divide two (signed) numbers. */\n+void static secp256k1_num_div(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b);\n+\n+/** Replace a number by its remainder modulo m. M's sign is ignored. The result is a number between 0 and m-1,\n+    even if r was negative. */\n+void static secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m);\n+\n+/** Calculate the number of bits in (the absolute value of) a number. */\n+int  static secp256k1_num_bits(const secp256k1_num_t *a);\n+\n+/** Right-shift the passed number by bits bits, and return those bits. */\n+int  static secp256k1_num_shift(secp256k1_num_t *r, int bits);\n+\n+/** Check whether a number is zero. */\n+int  static secp256k1_num_is_zero(const secp256k1_num_t *a);\n+\n+/** Check whether a number is odd. */\n+int  static secp256k1_num_is_odd(const secp256k1_num_t *a);\n+\n+/** Check whether a number is strictly negative. */\n+int  static secp256k1_num_is_neg(const secp256k1_num_t *a);\n+\n+/** Check whether a particular bit is set in a number. */\n+int  static secp256k1_num_get_bit(const secp256k1_num_t *a, int pos);\n+\n+/** Increase a number by 1. */\n+void static secp256k1_num_inc(secp256k1_num_t *r);\n+\n+/** Set a number equal to the value of a hex string (unsigned). */\n+void static secp256k1_num_set_hex(secp256k1_num_t *r, const char *a, int alen);\n+\n+/** Convert (the absolute value of) a number to a hexadecimal string. */\n+void static secp256k1_num_get_hex(char *r, int rlen, const secp256k1_num_t *a);\n+\n+/** Split a number into a low and high part. */\n+void static secp256k1_num_split(secp256k1_num_t *rl, secp256k1_num_t *rh, const secp256k1_num_t *a, int bits);\n+\n+/** Change a number's sign. */\n+void static secp256k1_num_negate(secp256k1_num_t *r);\n+\n+/** Get a bunch of bits from a number. */\n+int  static secp256k1_num_get_bits(const secp256k1_num_t *a, int offset, int count);\n+\n+#endif"
      },
      {
        "sha": "960df860544182f7567405e8e0166341f6b6adb2",
        "filename": "src/secp256k1/src/num_gmp.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num_gmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num_gmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_REPR_\n+#define _SECP256K1_NUM_REPR_\n+\n+#include <gmp.h>\n+\n+#define NUM_LIMBS ((256+GMP_NUMB_BITS-1)/GMP_NUMB_BITS)\n+\n+typedef struct {\n+    mp_limb_t data[2*NUM_LIMBS];\n+    int neg;\n+    int limbs;\n+} secp256k1_num_t;\n+\n+#endif"
      },
      {
        "sha": "d8442ee03e0902a87cfa534b7a994c983db21f81",
        "filename": "src/secp256k1/src/num_gmp_impl.h",
        "status": "added",
        "additions": 374,
        "deletions": 0,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,374 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_REPR_IMPL_H_\n+#define _SECP256K1_NUM_REPR_IMPL_H_\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <gmp.h>\n+\n+#include \"util.h\"\n+#include \"num.h\"\n+\n+#ifdef VERIFY\n+void static secp256k1_num_sanity(const secp256k1_num_t *a) {\n+    VERIFY_CHECK(a->limbs == 1 || (a->limbs > 1 && a->data[a->limbs-1] != 0));\n+}\n+#else\n+#define secp256k1_num_sanity(a) do { } while(0)\n+#endif\n+\n+void static secp256k1_num_init(secp256k1_num_t *r) {\n+    r->neg = 0;\n+    r->limbs = 1;\n+    r->data[0] = 0;\n+}\n+\n+void static secp256k1_num_clear(secp256k1_num_t *r) {\n+    memset(r, 0, sizeof(*r));\n+}\n+\n+void static secp256k1_num_free(secp256k1_num_t *r) {\n+}\n+\n+void static secp256k1_num_copy(secp256k1_num_t *r, const secp256k1_num_t *a) {\n+    *r = *a;\n+}\n+\n+int static secp256k1_num_bits(const secp256k1_num_t *a) {\n+    int ret=(a->limbs-1)*GMP_NUMB_BITS;\n+    mp_limb_t x=a->data[a->limbs-1];\n+    while (x) {\n+        x >>= 1;\n+        ret++;\n+    }\n+    return ret;\n+}\n+\n+\n+void static secp256k1_num_get_bin(unsigned char *r, unsigned int rlen, const secp256k1_num_t *a) {\n+    unsigned char tmp[65];\n+    int len = 0;\n+    if (a->limbs>1 || a->data[0] != 0) {\n+        len = mpn_get_str(tmp, 256, (mp_limb_t*)a->data, a->limbs);\n+    }\n+    int shift = 0;\n+    while (shift < len && tmp[shift] == 0) shift++;\n+    VERIFY_CHECK(len-shift <= rlen);\n+    memset(r, 0, rlen - len + shift);\n+    if (len > shift) {\n+        memcpy(r + rlen - len + shift, tmp + shift, len - shift);\n+    }\n+    memset(tmp, 0, sizeof(tmp));\n+}\n+\n+void static secp256k1_num_set_bin(secp256k1_num_t *r, const unsigned char *a, unsigned int alen) {\n+    VERIFY_CHECK(alen > 0);\n+    VERIFY_CHECK(alen <= 64);\n+    int len = mpn_set_str(r->data, a, alen, 256);\n+    VERIFY_CHECK(len <= NUM_LIMBS*2);\n+    r->limbs = len;\n+    r->neg = 0;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+}\n+\n+void static secp256k1_num_set_int(secp256k1_num_t *r, int a) {\n+    r->limbs = 1;\n+    r->neg = (a < 0);\n+    r->data[0] = (a < 0) ? -a : a;\n+}\n+\n+void static secp256k1_num_add_abs(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    mp_limb_t c = mpn_add(r->data, a->data, a->limbs, b->data, b->limbs);\n+    r->limbs = a->limbs;\n+    if (c != 0) {\n+        VERIFY_CHECK(r->limbs < 2*NUM_LIMBS);\n+        r->data[r->limbs++] = c;\n+    }\n+}\n+\n+void static secp256k1_num_sub_abs(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    mp_limb_t c = mpn_sub(r->data, a->data, a->limbs, b->data, b->limbs);\n+    VERIFY_CHECK(c == 0);\n+    r->limbs = a->limbs;\n+    while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+}\n+\n+void static secp256k1_num_mod(secp256k1_num_t *r, const secp256k1_num_t *m) {\n+    secp256k1_num_sanity(r);\n+    secp256k1_num_sanity(m);\n+\n+    if (r->limbs >= m->limbs) {\n+        mp_limb_t t[2*NUM_LIMBS];\n+        mpn_tdiv_qr(t, r->data, 0, r->data, r->limbs, m->data, m->limbs);\n+        memset(t, 0, sizeof(t));\n+        r->limbs = m->limbs;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    }\n+\n+    if (r->neg && (r->limbs > 1 || r->data[0] != 0)) {\n+        secp256k1_num_sub_abs(r, m, r);\n+        r->neg = 0;\n+    }\n+}\n+\n+void static secp256k1_num_mod_inverse(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *m) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(m);\n+\n+    // mpn_gcdext computes: (G,S) = gcdext(U,V), where\n+    // * G = gcd(U,V)\n+    // * G = U*S + V*T\n+    // * U has equal or more limbs than V, and V has no padding\n+    // If we set U to be (a padded version of) a, and V = m:\n+    //   G = a*S + m*T\n+    //   G = a*S mod m\n+    // Assuming G=1:\n+    //   S = 1/a mod m\n+    VERIFY_CHECK(m->limbs <= NUM_LIMBS);\n+    VERIFY_CHECK(m->data[m->limbs-1] != 0);\n+    mp_limb_t g[NUM_LIMBS+1];\n+    mp_limb_t u[NUM_LIMBS+1];\n+    mp_limb_t v[NUM_LIMBS+1];\n+    for (int i=0; i < m->limbs; i++) {\n+        u[i] = (i < a->limbs) ? a->data[i] : 0;\n+        v[i] = m->data[i];\n+    }\n+    mp_size_t sn = NUM_LIMBS+1;\n+    mp_size_t gn = mpn_gcdext(g, r->data, &sn, u, m->limbs, v, m->limbs);\n+    VERIFY_CHECK(gn == 1);\n+    VERIFY_CHECK(g[0] == 1);\n+    r->neg = a->neg ^ m->neg;\n+    if (sn < 0) {\n+        mpn_sub(r->data, m->data, m->limbs, r->data, -sn);\n+        r->limbs = m->limbs;\n+        while (r->limbs > 1 && r->data[r->limbs-1]==0) r->limbs--;\n+    } else {\n+        r->limbs = sn;\n+    }\n+    memset(g, 0, sizeof(g));\n+    memset(u, 0, sizeof(u));\n+    memset(v, 0, sizeof(v));\n+}\n+\n+int static secp256k1_num_is_zero(const secp256k1_num_t *a) {\n+    return (a->limbs == 1 && a->data[0] == 0);\n+}\n+\n+int static secp256k1_num_is_odd(const secp256k1_num_t *a) {\n+    return a->data[0] & 1;\n+}\n+\n+int static secp256k1_num_is_neg(const secp256k1_num_t *a) {\n+    return (a->limbs > 1 || a->data[0] != 0) && a->neg;\n+}\n+\n+int static secp256k1_num_cmp(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    if (a->limbs > b->limbs) return 1;\n+    if (a->limbs < b->limbs) return -1;\n+    return mpn_cmp(a->data, b->data, a->limbs);\n+}\n+\n+int static secp256k1_num_eq(const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    if (a->limbs > b->limbs) return 0;\n+    if (a->limbs < b->limbs) return 0;\n+    if ((a->neg && !secp256k1_num_is_zero(a)) != (b->neg && !secp256k1_num_is_zero(b))) return 0;\n+    return mpn_cmp(a->data, b->data, a->limbs) == 0;\n+}\n+\n+void static secp256k1_num_subadd(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b, int bneg) {\n+    if (!(b->neg ^ bneg ^ a->neg)) { // a and b have the same sign\n+        r->neg = a->neg;\n+        if (a->limbs >= b->limbs) {\n+            secp256k1_num_add_abs(r, a, b);\n+        } else {\n+            secp256k1_num_add_abs(r, b, a);\n+        }\n+    } else {\n+        if (secp256k1_num_cmp(a, b) > 0) {\n+            r->neg = a->neg;\n+            secp256k1_num_sub_abs(r, a, b);\n+        } else {\n+            r->neg = b->neg ^ bneg;\n+            secp256k1_num_sub_abs(r, b, a);\n+        }\n+    }\n+}\n+\n+void static secp256k1_num_add(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    secp256k1_num_subadd(r, a, b, 0);\n+}\n+\n+void static secp256k1_num_sub(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    secp256k1_num_subadd(r, a, b, 1);\n+}\n+\n+void static secp256k1_num_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+\n+    mp_limb_t tmp[2*NUM_LIMBS+1];\n+    VERIFY_CHECK(a->limbs + b->limbs <= 2*NUM_LIMBS+1);\n+    if ((a->limbs==1 && a->data[0]==0) || (b->limbs==1 && b->data[0]==0)) {\n+        r->limbs = 1;\n+        r->neg = 0;\n+        r->data[0] = 0;\n+        return;\n+    }\n+    if (a->limbs >= b->limbs)\n+        mpn_mul(tmp, a->data, a->limbs, b->data, b->limbs);\n+    else\n+        mpn_mul(tmp, b->data, b->limbs, a->data, a->limbs);\n+    r->limbs = a->limbs + b->limbs;\n+    if (r->limbs > 1 && tmp[r->limbs - 1]==0) r->limbs--;\n+    VERIFY_CHECK(r->limbs <= 2*NUM_LIMBS);\n+    mpn_copyi(r->data, tmp, r->limbs);\n+    r->neg = a->neg ^ b->neg;\n+    memset(tmp, 0, sizeof(tmp));\n+}\n+\n+void static secp256k1_num_div(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b) {\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    if (b->limbs > a->limbs) {\n+        r->limbs = 1;\n+        r->data[0] = 0;\n+        r->neg = 0;\n+        return;\n+    }\n+\n+    mp_limb_t quo[2*NUM_LIMBS+1];\n+    mp_limb_t rem[2*NUM_LIMBS+1];\n+    mpn_tdiv_qr(quo, rem, 0, a->data, a->limbs, b->data, b->limbs);\n+    mpn_copyi(r->data, quo, a->limbs - b->limbs + 1);\n+    r->limbs = a->limbs - b->limbs + 1;\n+    while (r->limbs > 1 && r->data[r->limbs - 1]==0) r->limbs--;\n+    r->neg = a->neg ^ b->neg;\n+}\n+\n+void static secp256k1_num_mod_mul(secp256k1_num_t *r, const secp256k1_num_t *a, const secp256k1_num_t *b, const secp256k1_num_t *m) {\n+    secp256k1_num_mul(r, a, b);\n+    secp256k1_num_mod(r, m);\n+}\n+\n+\n+int static secp256k1_num_shift(secp256k1_num_t *r, int bits) {\n+    VERIFY_CHECK(bits <= GMP_NUMB_BITS);\n+    mp_limb_t ret = mpn_rshift(r->data, r->data, r->limbs, bits);\n+    if (r->limbs>1 && r->data[r->limbs-1]==0) r->limbs--;\n+    ret >>= (GMP_NUMB_BITS - bits);\n+    return ret;\n+}\n+\n+int static secp256k1_num_get_bit(const secp256k1_num_t *a, int pos) {\n+    return (a->limbs*GMP_NUMB_BITS > pos) && ((a->data[pos/GMP_NUMB_BITS] >> (pos % GMP_NUMB_BITS)) & 1);\n+}\n+\n+void static secp256k1_num_inc(secp256k1_num_t *r) {\n+    mp_limb_t ret = mpn_add_1(r->data, r->data, r->limbs, (mp_limb_t)1);\n+    if (ret) {\n+        VERIFY_CHECK(r->limbs < 2*NUM_LIMBS);\n+        r->data[r->limbs++] = ret;\n+    }\n+}\n+\n+void static secp256k1_num_set_hex(secp256k1_num_t *r, const char *a, int alen) {\n+    static const unsigned char cvt[256] = {\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 1, 2, 3, 4, 5, 6,7,8,9,0,0,0,0,0,0,\n+        0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0,\n+        0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,0\n+    };\n+    unsigned char num[257] = {};\n+    for (int i=0; i<alen; i++) {\n+        num[i] = cvt[(unsigned char)a[i]];\n+    }\n+    r->limbs = mpn_set_str(r->data, num, alen, 16);\n+    r->neg = 0;\n+    while (r->limbs > 1 && r->data[r->limbs-1] == 0) r->limbs--;\n+}\n+\n+void static secp256k1_num_get_hex(char *r, int rlen, const secp256k1_num_t *a) {\n+    static const unsigned char cvt[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+    unsigned char *tmp = malloc(257);\n+    mp_size_t len = mpn_get_str(tmp, 16, (mp_limb_t*)a->data, a->limbs);\n+    VERIFY_CHECK(len <= rlen);\n+    for (int i=0; i<len; i++) {\n+        VERIFY_CHECK(rlen-len+i >= 0);\n+        VERIFY_CHECK(rlen-len+i < rlen);\n+        VERIFY_CHECK(tmp[i] >= 0);\n+        VERIFY_CHECK(tmp[i] < 16);\n+        r[rlen-len+i] = cvt[tmp[i]];\n+    }\n+    for (int i=0; i<rlen-len; i++) {\n+        VERIFY_CHECK(i >= 0);\n+        VERIFY_CHECK(i < rlen);\n+        r[i] = cvt[0];\n+    }\n+    free(tmp);\n+}\n+\n+void static secp256k1_num_split(secp256k1_num_t *rl, secp256k1_num_t *rh, const secp256k1_num_t *a, int bits) {\n+    VERIFY_CHECK(bits > 0);\n+    rh->neg = a->neg;\n+    if (bits >= a->limbs * GMP_NUMB_BITS) {\n+        *rl = *a;\n+        rh->limbs = 1;\n+        rh->data[0] = 0;\n+        return;\n+    }\n+    rl->limbs = 0;\n+    rl->neg = a->neg;\n+    int left = bits;\n+    while (left >= GMP_NUMB_BITS) {\n+        rl->data[rl->limbs] = a->data[rl->limbs];\n+        rl->limbs++;\n+        left -= GMP_NUMB_BITS;\n+    }\n+    if (left == 0) {\n+        mpn_copyi(rh->data, a->data + rl->limbs, a->limbs - rl->limbs);\n+        rh->limbs = a->limbs - rl->limbs;\n+    } else {\n+        mpn_rshift(rh->data, a->data + rl->limbs, a->limbs - rl->limbs, left);\n+        rh->limbs = a->limbs - rl->limbs;\n+        while (rh->limbs>1 && rh->data[rh->limbs-1]==0) rh->limbs--;\n+    }\n+    if (left > 0) {\n+        rl->data[rl->limbs] = a->data[rl->limbs] & ((((mp_limb_t)1) << left) - 1);\n+        rl->limbs++;\n+    }\n+    while (rl->limbs>1 && rl->data[rl->limbs-1]==0) rl->limbs--;\n+}\n+\n+void static secp256k1_num_negate(secp256k1_num_t *r) {\n+    r->neg ^= 1;\n+}\n+\n+int static secp256k1_num_get_bits(const secp256k1_num_t *a, int offset, int count) {\n+    int ret = 0;\n+    for (int i = 0; i < count; i++) {\n+        ret |= ((a->data[(offset + i) / GMP_NUMB_BITS] >> ((offset + i) % GMP_NUMB_BITS)) & 1) << i;\n+    }\n+    return ret;\n+}\n+\n+#endif"
      },
      {
        "sha": "a6644fda703ac0e0d32d71baf4a7d714362c4cde",
        "filename": "src/secp256k1/src/num_impl.h",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/num_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_NUM_IMPL_H_\n+#define _SECP256K1_NUM_IMPL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include \"num.h\"\n+\n+#if defined(USE_NUM_GMP)\n+#include \"num_gmp_impl.h\"\n+#else\n+#error \"Please select num implementation\"\n+#endif\n+\n+#endif"
      },
      {
        "sha": "2579db12b26df0d31e3014c94bbdcfba983aef57",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,61 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_\n+#define _SECP256K1_SCALAR_\n+\n+#include \"num.h\"\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_SCALAR_4X64)\n+#include \"scalar_4x64.h\"\n+#elif defined(USE_SCALAR_8X32)\n+#include \"scalar_8x32.h\"\n+#else\n+#error \"Please select scalar implementation\"\n+#endif\n+\n+/** Clear a scalar to prevent the leak of sensitive data. */\n+void static secp256k1_scalar_clear(secp256k1_scalar_t *r);\n+\n+/** Access bits from a scalar. */\n+int static secp256k1_scalar_get_bits(const secp256k1_scalar_t *a, int offset, int count);\n+\n+/** Set a scalar from a big endian byte array. */\n+void static secp256k1_scalar_set_b32(secp256k1_scalar_t *r, const unsigned char *bin, int *overflow);\n+\n+/** Convert a scalar to a byte array. */\n+void static secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar_t* a);\n+\n+/** Add two scalars together (modulo the group order). */\n+void static secp256k1_scalar_add(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b);\n+\n+/** Multiply two scalars (modulo the group order). */\n+void static secp256k1_scalar_mul(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b);\n+\n+/** Compute the square of a scalar (modulo the group order). */\n+void static secp256k1_scalar_sqr(secp256k1_scalar_t *r, const secp256k1_scalar_t *a);\n+\n+/** Compute the inverse of a scalar (modulo the group order). */\n+void static secp256k1_scalar_inverse(secp256k1_scalar_t *r, const secp256k1_scalar_t *a);\n+\n+/** Compute the complement of a scalar (modulo the group order). */\n+void static secp256k1_scalar_negate(secp256k1_scalar_t *r, const secp256k1_scalar_t *a);\n+\n+/** Check whether a scalar equals zero. */\n+int static secp256k1_scalar_is_zero(const secp256k1_scalar_t *a);\n+\n+/** Check whether a scalar equals one. */\n+int static secp256k1_scalar_is_one(const secp256k1_scalar_t *a);\n+\n+/** Check whether a scalar is higher than the group order divided by 2. */\n+int static secp256k1_scalar_is_high(const secp256k1_scalar_t *a);\n+\n+/** Convert a scalar to a number. */\n+void static secp256k1_scalar_get_num(secp256k1_num_t *r, const secp256k1_scalar_t *a);\n+\n+#endif"
      },
      {
        "sha": "22ebe4fbba6cae37c296e7893687b690dd476071",
        "filename": "src/secp256k1/src/scalar_4x64.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_4x64.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_4x64.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef struct {\n+    uint64_t d[4];\n+} secp256k1_scalar_t;\n+\n+#endif"
      },
      {
        "sha": "66f17a2e23d17fd7e791470081515353c46b863f",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "added",
        "additions": 357,
        "deletions": 0,
        "changes": 357,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,357 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+typedef unsigned __int128 uint128_t;\n+\n+// Limbs of the secp256k1 order.\n+#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)\n+#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)\n+#define SECP256K1_N_2 ((uint64_t)0xFFFFFFFFFFFFFFFEULL)\n+#define SECP256K1_N_3 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)\n+\n+// Limbs of 2^256 minus the secp256k1 order.\n+#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)\n+#define SECP256K1_N_C_1 (~SECP256K1_N_1)\n+#define SECP256K1_N_C_2 (1)\n+\n+// Limbs of half the secp256k1 order.\n+#define SECP256K1_N_H_0 ((uint64_t)0xDFE92F46681B20A0ULL)\n+#define SECP256K1_N_H_1 ((uint64_t)0x5D576E7357A4501DULL)\n+#define SECP256K1_N_H_2 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)\n+#define SECP256K1_N_H_3 ((uint64_t)0x7FFFFFFFFFFFFFFFULL)\n+\n+void static inline secp256k1_scalar_clear(secp256k1_scalar_t *r) {\n+    r->d[0] = 0;\n+    r->d[1] = 0;\n+    r->d[2] = 0;\n+    r->d[3] = 0;\n+}\n+\n+int static inline secp256k1_scalar_get_bits(const secp256k1_scalar_t *a, int offset, int count) {\n+    VERIFY_CHECK((offset + count - 1) / 64 == offset / 64);\n+    return (a->d[offset / 64] >> (offset % 64)) & ((((uint64_t)1) << count) - 1);\n+}\n+\n+int static inline secp256k1_scalar_check_overflow(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[3] < SECP256K1_N_3); // No need for a > check.\n+    no |= (a->d[2] < SECP256K1_N_2);\n+    yes |= (a->d[2] > SECP256K1_N_2) & ~no;\n+    no |= (a->d[1] < SECP256K1_N_1);\n+    yes |= (a->d[1] > SECP256K1_N_1) & ~no;\n+    yes |= (a->d[0] >= SECP256K1_N_0) & ~no;\n+    return yes;\n+}\n+\n+int static inline secp256k1_scalar_reduce(secp256k1_scalar_t *r, unsigned int overflow) {\n+    VERIFY_CHECK(overflow <= 1);\n+    uint128_t t = (uint128_t)r->d[0] + overflow * SECP256K1_N_C_0;\n+    r->d[0] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)r->d[1] + overflow * SECP256K1_N_C_1;\n+    r->d[1] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)r->d[2] + overflow * SECP256K1_N_C_2;\n+    r->d[2] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint64_t)r->d[3];\n+    r->d[3] = t & 0xFFFFFFFFFFFFFFFFULL;\n+    return overflow;\n+}\n+\n+void static secp256k1_scalar_add(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    uint128_t t = (uint128_t)a->d[0] + b->d[0];\n+    r->d[0] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)a->d[1] + b->d[1];\n+    r->d[1] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)a->d[2] + b->d[2];\n+    r->d[2] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    t += (uint128_t)a->d[3] + b->d[3];\n+    r->d[3] = t & 0xFFFFFFFFFFFFFFFFULL; t >>= 64;\n+    secp256k1_scalar_reduce(r, t + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_set_b32(secp256k1_scalar_t *r, const unsigned char *b32, int *overflow) {\n+    r->d[0] = (uint64_t)b32[31] | (uint64_t)b32[30] << 8 | (uint64_t)b32[29] << 16 | (uint64_t)b32[28] << 24 | (uint64_t)b32[27] << 32 | (uint64_t)b32[26] << 40 | (uint64_t)b32[25] << 48 | (uint64_t)b32[24] << 56;\n+    r->d[1] = (uint64_t)b32[23] | (uint64_t)b32[22] << 8 | (uint64_t)b32[21] << 16 | (uint64_t)b32[20] << 24 | (uint64_t)b32[19] << 32 | (uint64_t)b32[18] << 40 | (uint64_t)b32[17] << 48 | (uint64_t)b32[16] << 56;\n+    r->d[2] = (uint64_t)b32[15] | (uint64_t)b32[14] << 8 | (uint64_t)b32[13] << 16 | (uint64_t)b32[12] << 24 | (uint64_t)b32[11] << 32 | (uint64_t)b32[10] << 40 | (uint64_t)b32[9] << 48 | (uint64_t)b32[8] << 56;\n+    r->d[3] = (uint64_t)b32[7] | (uint64_t)b32[6] << 8 | (uint64_t)b32[5] << 16 | (uint64_t)b32[4] << 24 | (uint64_t)b32[3] << 32 | (uint64_t)b32[2] << 40 | (uint64_t)b32[1] << 48 | (uint64_t)b32[0] << 56;\n+    int over = secp256k1_scalar_reduce(r, secp256k1_scalar_check_overflow(r));\n+    if (overflow) {\n+        *overflow = over;\n+    }\n+}\n+\n+void static secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar_t* a) {\n+    bin[0] = a->d[3] >> 56; bin[1] = a->d[3] >> 48; bin[2] = a->d[3] >> 40; bin[3] = a->d[3] >> 32; bin[4] = a->d[3] >> 24; bin[5] = a->d[3] >> 16; bin[6] = a->d[3] >> 8; bin[7] = a->d[3];\n+    bin[8] = a->d[2] >> 56; bin[9] = a->d[2] >> 48; bin[10] = a->d[2] >> 40; bin[11] = a->d[2] >> 32; bin[12] = a->d[2] >> 24; bin[13] = a->d[2] >> 16; bin[14] = a->d[2] >> 8; bin[15] = a->d[2];\n+    bin[16] = a->d[1] >> 56; bin[17] = a->d[1] >> 48; bin[18] = a->d[1] >> 40; bin[19] = a->d[1] >> 32; bin[20] = a->d[1] >> 24; bin[21] = a->d[1] >> 16; bin[22] = a->d[1] >> 8; bin[23] = a->d[1];\n+    bin[24] = a->d[0] >> 56; bin[25] = a->d[0] >> 48; bin[26] = a->d[0] >> 40; bin[27] = a->d[0] >> 32; bin[28] = a->d[0] >> 24; bin[29] = a->d[0] >> 16; bin[30] = a->d[0] >> 8; bin[31] = a->d[0];\n+}\n+\n+int static inline secp256k1_scalar_is_zero(const secp256k1_scalar_t *a) {\n+    return (a->d[0] | a->d[1] | a->d[2] | a->d[3]) == 0;\n+}\n+\n+void static secp256k1_scalar_negate(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    uint64_t nonzero = 0xFFFFFFFFFFFFFFFFULL * (secp256k1_scalar_is_zero(a) == 0);\n+    uint128_t t = (uint128_t)(~a->d[0]) + SECP256K1_N_0 + 1;\n+    r->d[0] = t & nonzero; t >>= 64;\n+    t += (uint128_t)(~a->d[1]) + SECP256K1_N_1;\n+    r->d[1] = t & nonzero; t >>= 64;\n+    t += (uint128_t)(~a->d[2]) + SECP256K1_N_2;\n+    r->d[2] = t & nonzero; t >>= 64;\n+    t += (uint128_t)(~a->d[3]) + SECP256K1_N_3;\n+    r->d[3] = t & nonzero;\n+}\n+\n+int static inline secp256k1_scalar_is_one(const secp256k1_scalar_t *a) {\n+    return ((a->d[0] ^ 1) | a->d[1] | a->d[2] | a->d[3]) == 0;\n+}\n+\n+int static secp256k1_scalar_is_high(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[3] < SECP256K1_N_H_3);\n+    yes |= (a->d[3] > SECP256K1_N_H_3) & ~no;\n+    no |= (a->d[2] < SECP256K1_N_H_2) & ~yes; // No need for a > check.\n+    no |= (a->d[1] < SECP256K1_N_H_1) & ~yes;\n+    yes |= (a->d[1] > SECP256K1_N_H_1) & ~no;\n+    yes |= (a->d[0] > SECP256K1_N_H_0) & ~no;\n+    return yes;\n+}\n+\n+// Inspired by the macros in OpenSSL's crypto/bn/asm/x86_64-gcc.c.\n+\n+/** Add a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd(a,b) { \\\n+    uint64_t tl, th; \\\n+    { \\\n+        uint128_t t = (uint128_t)a * b; \\\n+        th = t >> 64;         /* at most 0xFFFFFFFFFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    c1 += th;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n+}\n+\n+/** Add a*b to the number defined by (c0,c1). c1 must never overflow. */\n+#define muladd_fast(a,b) { \\\n+    uint64_t tl, th; \\\n+    { \\\n+        uint128_t t = (uint128_t)a * b; \\\n+        th = t >> 64;         /* at most 0xFFFFFFFFFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK(c1 >= th); \\\n+}\n+\n+/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd2(a,b) { \\\n+    uint64_t tl, th; \\\n+    { \\\n+        uint128_t t = (uint128_t)a * b; \\\n+        th = t >> 64;               /* at most 0xFFFFFFFFFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    uint64_t th2 = th + th;         /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n+    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n+    uint64_t tl2 = tl + tl;         /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n+    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    c0 += tl2;                      /* overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n+    c1 += th2;                      /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n+}\n+\n+/** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define sumadd(a) { \\\n+    c0 += (a);                  /* overflow is handled on the next line */ \\\n+    int over = (c0 < (a)) ? 1 : 0; \\\n+    c1 += over;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+}\n+\n+/** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n+#define sumadd_fast(a) { \\\n+    c0 += (a);                 /* overflow is handled on the next line */ \\\n+    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+/** Extract the lowest 64 bits of (c0,c1,c2) into n, and left shift the number 64 bits. */\n+#define extract(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = c2; \\\n+    c2 = 0; \\\n+}\n+\n+/** Extract the lowest 64 bits of (c0,c1,c2) into n, and left shift the number 64 bits. c2 is required to be zero. */\n+#define extract_fast(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = 0; \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+void static secp256k1_scalar_reduce_512(secp256k1_scalar_t *r, const uint64_t *l) {\n+    uint64_t n0 = l[4], n1 = l[5], n2 = l[6], n3 = l[7];\n+\n+    // 160 bit accumulator.\n+    uint64_t c0, c1;\n+    uint32_t c2;\n+\n+    // Reduce 512 bits into 385.\n+    // m[0..6] = l[0..3] + n[0..3] * SECP256K1_N_C.\n+    c0 = l[0]; c1 = 0; c2 = 0;\n+    muladd_fast(n0, SECP256K1_N_C_0);\n+    uint64_t m0; extract_fast(m0);\n+    sumadd_fast(l[1]);\n+    muladd(n1, SECP256K1_N_C_0);\n+    muladd(n0, SECP256K1_N_C_1);\n+    uint64_t m1; extract(m1);\n+    sumadd(l[2]);\n+    muladd(n2, SECP256K1_N_C_0);\n+    muladd(n1, SECP256K1_N_C_1);\n+    sumadd(n0);\n+    uint64_t m2; extract(m2);\n+    sumadd(l[3]);\n+    muladd(n3, SECP256K1_N_C_0);\n+    muladd(n2, SECP256K1_N_C_1);\n+    sumadd(n1);\n+    uint64_t m3; extract(m3);\n+    muladd(n3, SECP256K1_N_C_1);\n+    sumadd(n2);\n+    uint64_t m4; extract(m4);\n+    sumadd_fast(n3);\n+    uint64_t m5; extract_fast(m5);\n+    VERIFY_CHECK(c0 <= 1);\n+    uint32_t m6 = c0;\n+\n+    // Reduce 385 bits into 258.\n+    // p[0..4] = m[0..3] + m[4..6] * SECP256K1_N_C.\n+    c0 = m0; c1 = 0; c2 = 0;\n+    muladd_fast(m4, SECP256K1_N_C_0);\n+    uint64_t p0; extract_fast(p0);\n+    sumadd_fast(m1);\n+    muladd(m5, SECP256K1_N_C_0);\n+    muladd(m4, SECP256K1_N_C_1);\n+    uint64_t p1; extract(p1);\n+    sumadd(m2);\n+    muladd(m6, SECP256K1_N_C_0);\n+    muladd(m5, SECP256K1_N_C_1);\n+    sumadd(m4);\n+    uint64_t p2; extract(p2);\n+    sumadd_fast(m3);\n+    muladd_fast(m6, SECP256K1_N_C_1);\n+    sumadd_fast(m5);\n+    uint64_t p3; extract_fast(p3);\n+    uint32_t p4 = c0 + m6;\n+    VERIFY_CHECK(p4 <= 2);\n+\n+    // Reduce 258 bits into 256.\n+    // r[0..3] = p[0..3] + p[4] * SECP256K1_N_C.\n+    uint128_t c = p0 + (uint128_t)SECP256K1_N_C_0 * p4;\n+    r->d[0] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+    c += p1 + (uint128_t)SECP256K1_N_C_1 * p4;\n+    r->d[1] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+    c += p2 + (uint128_t)p4;\n+    r->d[2] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+    c += p3;\n+    r->d[3] = c & 0xFFFFFFFFFFFFFFFFULL; c >>= 64;\n+\n+    // Final reduction of r.\n+    secp256k1_scalar_reduce(r, c + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_mul(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    // 160 bit accumulator.\n+    uint64_t c0 = 0, c1 = 0;\n+    uint32_t c2 = 0;\n+\n+    uint64_t l[8];\n+\n+    // l[0..7] = a[0..3] * b[0..3].\n+    muladd_fast(a->d[0], b->d[0]);\n+    extract_fast(l[0]);\n+    muladd(a->d[0], b->d[1]);\n+    muladd(a->d[1], b->d[0]);\n+    extract(l[1]);\n+    muladd(a->d[0], b->d[2]);\n+    muladd(a->d[1], b->d[1]);\n+    muladd(a->d[2], b->d[0]);\n+    extract(l[2]);\n+    muladd(a->d[0], b->d[3]);\n+    muladd(a->d[1], b->d[2]);\n+    muladd(a->d[2], b->d[1]);\n+    muladd(a->d[3], b->d[0]);\n+    extract(l[3]);\n+    muladd(a->d[1], b->d[3]);\n+    muladd(a->d[2], b->d[2]);\n+    muladd(a->d[3], b->d[1]);\n+    extract(l[4]);\n+    muladd(a->d[2], b->d[3]);\n+    muladd(a->d[3], b->d[2]);\n+    extract(l[5]);\n+    muladd_fast(a->d[3], b->d[3]);\n+    extract_fast(l[6]);\n+    VERIFY_CHECK(c1 <= 0);\n+    l[7] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+void static secp256k1_scalar_sqr(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    // 160 bit accumulator.\n+    uint64_t c0 = 0, c1 = 0;\n+    uint32_t c2 = 0;\n+\n+    uint64_t l[8];\n+\n+    // l[0..7] = a[0..3] * b[0..3].\n+    muladd_fast(a->d[0], a->d[0]);\n+    extract_fast(l[0]);\n+    muladd2(a->d[0], a->d[1]);\n+    extract(l[1]);\n+    muladd2(a->d[0], a->d[2]);\n+    muladd(a->d[1], a->d[1]);\n+    extract(l[2]);\n+    muladd2(a->d[0], a->d[3]);\n+    muladd2(a->d[1], a->d[2]);\n+    extract(l[3]);\n+    muladd2(a->d[1], a->d[3]);\n+    muladd(a->d[2], a->d[2]);\n+    extract(l[4]);\n+    muladd2(a->d[2], a->d[3]);\n+    extract(l[5]);\n+    muladd_fast(a->d[3], a->d[3]);\n+    extract_fast(l[6]);\n+    VERIFY_CHECK(c1 == 0);\n+    l[7] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+#undef sumadd\n+#undef sumadd_fast\n+#undef muladd\n+#undef muladd_fast\n+#undef muladd2\n+#undef extract\n+#undef extract_fast\n+\n+#endif"
      },
      {
        "sha": "da7c63c7883634435a32f82b4e05286f0bd848da",
        "filename": "src/secp256k1/src/scalar_8x32.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_8x32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_8x32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef struct {\n+    uint32_t d[8];\n+} secp256k1_scalar_t;\n+\n+#endif"
      },
      {
        "sha": "3983edd27e04227f726f6df7e6711f36dd9fbe47",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "added",
        "additions": 570,
        "deletions": 0,
        "changes": 570,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,570 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+// Limbs of the secp256k1 order.\n+#define SECP256K1_N_0 ((uint32_t)0xD0364141UL)\n+#define SECP256K1_N_1 ((uint32_t)0xBFD25E8CUL)\n+#define SECP256K1_N_2 ((uint32_t)0xAF48A03BUL)\n+#define SECP256K1_N_3 ((uint32_t)0xBAAEDCE6UL)\n+#define SECP256K1_N_4 ((uint32_t)0xFFFFFFFEUL)\n+#define SECP256K1_N_5 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_6 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_7 ((uint32_t)0xFFFFFFFFUL)\n+\n+// Limbs of 2^256 minus the secp256k1 order.\n+#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)\n+#define SECP256K1_N_C_1 (~SECP256K1_N_1)\n+#define SECP256K1_N_C_2 (~SECP256K1_N_2)\n+#define SECP256K1_N_C_3 (~SECP256K1_N_3)\n+#define SECP256K1_N_C_4 (1)\n+\n+// Limbs of half the secp256k1 order.\n+#define SECP256K1_N_H_0 ((uint32_t)0x681B20A0UL)\n+#define SECP256K1_N_H_1 ((uint32_t)0xDFE92F46UL)\n+#define SECP256K1_N_H_2 ((uint32_t)0x57A4501DUL)\n+#define SECP256K1_N_H_3 ((uint32_t)0x5D576E73UL)\n+#define SECP256K1_N_H_4 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_H_5 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_H_6 ((uint32_t)0xFFFFFFFFUL)\n+#define SECP256K1_N_H_7 ((uint32_t)0x7FFFFFFFUL)\n+\n+void static inline secp256k1_scalar_clear(secp256k1_scalar_t *r) {\n+    r->d[0] = 0;\n+    r->d[1] = 0;\n+    r->d[2] = 0;\n+    r->d[3] = 0;\n+    r->d[4] = 0;\n+    r->d[5] = 0;\n+    r->d[6] = 0;\n+    r->d[7] = 0;\n+}\n+\n+int static inline secp256k1_scalar_get_bits(const secp256k1_scalar_t *a, int offset, int count) {\n+    VERIFY_CHECK((offset + count - 1) / 32 == offset / 32);\n+    return (a->d[offset / 32] >> (offset % 32)) & ((1 << count) - 1);\n+}\n+\n+int static inline secp256k1_scalar_check_overflow(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[7] < SECP256K1_N_7); // No need for a > check.\n+    no |= (a->d[6] < SECP256K1_N_6); // No need for a > check.\n+    no |= (a->d[5] < SECP256K1_N_5); // No need for a > check.\n+    no |= (a->d[4] < SECP256K1_N_4);\n+    yes |= (a->d[4] > SECP256K1_N_4) & ~no;\n+    no |= (a->d[3] < SECP256K1_N_3) & ~yes;\n+    yes |= (a->d[3] > SECP256K1_N_3) & ~no;\n+    no |= (a->d[2] < SECP256K1_N_2) & ~yes;\n+    yes |= (a->d[2] > SECP256K1_N_2) & ~no;\n+    no |= (a->d[1] < SECP256K1_N_1) & ~yes;\n+    yes |= (a->d[1] > SECP256K1_N_1) & ~no;\n+    yes |= (a->d[0] >= SECP256K1_N_0) & ~no;\n+    return yes;\n+}\n+\n+int static inline secp256k1_scalar_reduce(secp256k1_scalar_t *r, uint32_t overflow) {\n+    VERIFY_CHECK(overflow <= 1);\n+    uint64_t t = (uint64_t)r->d[0] + overflow * SECP256K1_N_C_0;\n+    r->d[0] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[1] + overflow * SECP256K1_N_C_1;\n+    r->d[1] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[2] + overflow * SECP256K1_N_C_2;\n+    r->d[2] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[3] + overflow * SECP256K1_N_C_3;\n+    r->d[3] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[4] + overflow * SECP256K1_N_C_4;\n+    r->d[4] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[5];\n+    r->d[5] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[6];\n+    r->d[6] = t & 0xFFFFFFFFUL; t >>= 32;\n+    t += (uint64_t)r->d[7];\n+    r->d[7] = t & 0xFFFFFFFFUL;\n+    return overflow;\n+}\n+\n+void static secp256k1_scalar_add(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    uint64_t t = (uint64_t)a->d[0] + b->d[0];\n+    r->d[0] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[1] + b->d[1];\n+    r->d[1] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[2] + b->d[2];\n+    r->d[2] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[3] + b->d[3];\n+    r->d[3] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[4] + b->d[4];\n+    r->d[4] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[5] + b->d[5];\n+    r->d[5] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[6] + b->d[6];\n+    r->d[6] = t & 0xFFFFFFFFULL; t >>= 32;\n+    t += (uint64_t)a->d[7] + b->d[7];\n+    r->d[7] = t & 0xFFFFFFFFULL; t >>= 32;\n+    secp256k1_scalar_reduce(r, t + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_set_b32(secp256k1_scalar_t *r, const unsigned char *b32, int *overflow) {\n+    r->d[0] = (uint32_t)b32[31] | (uint32_t)b32[30] << 8 | (uint32_t)b32[29] << 16 | (uint32_t)b32[28] << 24;\n+    r->d[1] = (uint32_t)b32[27] | (uint32_t)b32[26] << 8 | (uint32_t)b32[25] << 16 | (uint32_t)b32[24] << 24;\n+    r->d[2] = (uint32_t)b32[23] | (uint32_t)b32[22] << 8 | (uint32_t)b32[21] << 16 | (uint32_t)b32[20] << 24;\n+    r->d[3] = (uint32_t)b32[19] | (uint32_t)b32[18] << 8 | (uint32_t)b32[17] << 16 | (uint32_t)b32[16] << 24;\n+    r->d[4] = (uint32_t)b32[15] | (uint32_t)b32[14] << 8 | (uint32_t)b32[13] << 16 | (uint32_t)b32[12] << 24;\n+    r->d[5] = (uint32_t)b32[11] | (uint32_t)b32[10] << 8 | (uint32_t)b32[9] << 16 | (uint32_t)b32[8] << 24;\n+    r->d[6] = (uint32_t)b32[7] | (uint32_t)b32[6] << 8 | (uint32_t)b32[5] << 16 | (uint32_t)b32[4] << 24;\n+    r->d[7] = (uint32_t)b32[3] | (uint32_t)b32[2] << 8 | (uint32_t)b32[1] << 16 | (uint32_t)b32[0] << 24;\n+    int over = secp256k1_scalar_reduce(r, secp256k1_scalar_check_overflow(r));\n+    if (overflow) {\n+        *overflow = over;\n+    }\n+}\n+\n+void static secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar_t* a) {\n+    bin[0] = a->d[7] >> 24; bin[1] = a->d[7] >> 16; bin[2] = a->d[7] >> 8; bin[3] = a->d[7];\n+    bin[4] = a->d[6] >> 24; bin[5] = a->d[6] >> 16; bin[6] = a->d[6] >> 8; bin[7] = a->d[6];\n+    bin[8] = a->d[5] >> 24; bin[9] = a->d[5] >> 16; bin[10] = a->d[5] >> 8; bin[11] = a->d[5];\n+    bin[12] = a->d[4] >> 24; bin[13] = a->d[4] >> 16; bin[14] = a->d[4] >> 8; bin[15] = a->d[4];\n+    bin[16] = a->d[3] >> 24; bin[17] = a->d[3] >> 16; bin[18] = a->d[3] >> 8; bin[19] = a->d[3];\n+    bin[20] = a->d[2] >> 24; bin[21] = a->d[2] >> 16; bin[22] = a->d[2] >> 8; bin[23] = a->d[2];\n+    bin[24] = a->d[1] >> 24; bin[25] = a->d[1] >> 16; bin[26] = a->d[1] >> 8; bin[27] = a->d[1];\n+    bin[28] = a->d[0] >> 24; bin[29] = a->d[0] >> 16; bin[30] = a->d[0] >> 8; bin[31] = a->d[0];\n+}\n+\n+int static inline secp256k1_scalar_is_zero(const secp256k1_scalar_t *a) {\n+    return (a->d[0] | a->d[1] | a->d[2] | a->d[3] | a->d[4] | a->d[5] | a->d[6] | a->d[7]) == 0;\n+}\n+\n+void static secp256k1_scalar_negate(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    uint32_t nonzero = 0xFFFFFFFFUL * (secp256k1_scalar_is_zero(a) == 0);\n+    uint64_t t = (uint64_t)(~a->d[0]) + SECP256K1_N_0 + 1;\n+    r->d[0] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[1]) + SECP256K1_N_1;\n+    r->d[1] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[2]) + SECP256K1_N_2;\n+    r->d[2] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[3]) + SECP256K1_N_3;\n+    r->d[3] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[4]) + SECP256K1_N_4;\n+    r->d[4] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[5]) + SECP256K1_N_5;\n+    r->d[5] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[6]) + SECP256K1_N_6;\n+    r->d[6] = t & nonzero; t >>= 32;\n+    t += (uint64_t)(~a->d[7]) + SECP256K1_N_7;\n+    r->d[7] = t & nonzero;\n+}\n+\n+int static inline secp256k1_scalar_is_one(const secp256k1_scalar_t *a) {\n+    return ((a->d[0] ^ 1) | a->d[1] | a->d[2] | a->d[3] | a->d[4] | a->d[5] | a->d[6] | a->d[7]) == 0;\n+}\n+\n+int static secp256k1_scalar_is_high(const secp256k1_scalar_t *a) {\n+    int yes = 0;\n+    int no = 0;\n+    no |= (a->d[7] < SECP256K1_N_H_7);\n+    yes |= (a->d[7] > SECP256K1_N_H_7) & ~no;\n+    no |= (a->d[6] < SECP256K1_N_H_6) & ~yes; // No need for a > check.\n+    no |= (a->d[5] < SECP256K1_N_H_5) & ~yes; // No need for a > check.\n+    no |= (a->d[4] < SECP256K1_N_H_4) & ~yes; // No need for a > check.\n+    no |= (a->d[3] < SECP256K1_N_H_3) & ~yes;\n+    yes |= (a->d[3] > SECP256K1_N_H_3) & ~no;\n+    no |= (a->d[2] < SECP256K1_N_H_2) & ~yes;\n+    yes |= (a->d[2] > SECP256K1_N_H_2) & ~no;\n+    no |= (a->d[1] < SECP256K1_N_H_1) & ~yes;\n+    yes |= (a->d[1] > SECP256K1_N_H_1) & ~no;\n+    yes |= (a->d[0] > SECP256K1_N_H_0) & ~no;\n+    return yes;\n+}\n+\n+// Inspired by the macros in OpenSSL's crypto/bn/asm/x86_64-gcc.c.\n+\n+/** Add a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd(a,b) { \\\n+    uint32_t tl, th; \\\n+    { \\\n+        uint64_t t = (uint64_t)a * b; \\\n+        th = t >> 32;         /* at most 0xFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    c1 += th;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n+}\n+\n+/** Add a*b to the number defined by (c0,c1). c1 must never overflow. */\n+#define muladd_fast(a,b) { \\\n+    uint32_t tl, th; \\\n+    { \\\n+        uint64_t t = (uint64_t)a * b; \\\n+        th = t >> 32;         /* at most 0xFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    c0 += tl;                 /* overflow is handled on the next line */ \\\n+    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n+    VERIFY_CHECK(c1 >= th); \\\n+}\n+\n+/** Add 2*a*b to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define muladd2(a,b) { \\\n+    uint32_t tl, th; \\\n+    { \\\n+        uint64_t t = (uint64_t)a * b; \\\n+        th = t >> 32;               /* at most 0xFFFFFFFE */ \\\n+        tl = t; \\\n+    } \\\n+    uint32_t th2 = th + th;         /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n+    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n+    uint32_t tl2 = tl + tl;         /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n+    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFF */ \\\n+    c0 += tl2;                      /* overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n+    c1 += th2;                      /* overflow is handled on the next line */ \\\n+    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n+}\n+\n+/** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n+#define sumadd(a) { \\\n+    c0 += (a);                  /* overflow is handled on the next line */ \\\n+    int over = (c0 < (a)) ? 1 : 0; \\\n+    c1 += over;                 /* overflow is handled on the next line */ \\\n+    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+}\n+\n+/** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n+#define sumadd_fast(a) { \\\n+    c0 += (a);                 /* overflow is handled on the next line */ \\\n+    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+/** Extract the lowest 32 bits of (c0,c1,c2) into n, and left shift the number 32 bits. */\n+#define extract(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = c2; \\\n+    c2 = 0; \\\n+}\n+\n+/** Extract the lowest 32 bits of (c0,c1,c2) into n, and left shift the number 32 bits. c2 is required to be zero. */\n+#define extract_fast(n) { \\\n+    (n) = c0; \\\n+    c0 = c1; \\\n+    c1 = 0; \\\n+    VERIFY_CHECK(c2 == 0); \\\n+}\n+\n+void static secp256k1_scalar_reduce_512(secp256k1_scalar_t *r, const uint32_t *l) {\n+    uint32_t n0 = l[8], n1 = l[9], n2 = l[10], n3 = l[11], n4 = l[12], n5 = l[13], n6 = l[14], n7 = l[15];\n+\n+    // 96 bit accumulator.\n+    uint32_t c0, c1, c2;\n+\n+    // Reduce 512 bits into 385.\n+    // m[0..12] = l[0..7] + n[0..7] * SECP256K1_N_C.\n+    c0 = l[0]; c1 = 0; c2 = 0;\n+    muladd_fast(n0, SECP256K1_N_C_0);\n+    uint32_t m0; extract_fast(m0);\n+    sumadd_fast(l[1]);\n+    muladd(n1, SECP256K1_N_C_0);\n+    muladd(n0, SECP256K1_N_C_1);\n+    uint32_t m1; extract(m1);\n+    sumadd(l[2]);\n+    muladd(n2, SECP256K1_N_C_0);\n+    muladd(n1, SECP256K1_N_C_1);\n+    muladd(n0, SECP256K1_N_C_2);\n+    uint32_t m2; extract(m2);\n+    sumadd(l[3]);\n+    muladd(n3, SECP256K1_N_C_0);\n+    muladd(n2, SECP256K1_N_C_1);\n+    muladd(n1, SECP256K1_N_C_2);\n+    muladd(n0, SECP256K1_N_C_3);\n+    uint32_t m3; extract(m3);\n+    sumadd(l[4]);\n+    muladd(n4, SECP256K1_N_C_0);\n+    muladd(n3, SECP256K1_N_C_1);\n+    muladd(n2, SECP256K1_N_C_2);\n+    muladd(n1, SECP256K1_N_C_3);\n+    sumadd(n0);\n+    uint32_t m4; extract(m4);\n+    sumadd(l[5]);\n+    muladd(n5, SECP256K1_N_C_0);\n+    muladd(n4, SECP256K1_N_C_1);\n+    muladd(n3, SECP256K1_N_C_2);\n+    muladd(n2, SECP256K1_N_C_3);\n+    sumadd(n1);\n+    uint32_t m5; extract(m5);\n+    sumadd(l[6]);\n+    muladd(n6, SECP256K1_N_C_0);\n+    muladd(n5, SECP256K1_N_C_1);\n+    muladd(n4, SECP256K1_N_C_2);\n+    muladd(n3, SECP256K1_N_C_3);\n+    sumadd(n2);\n+    uint32_t m6; extract(m6);\n+    sumadd(l[7]);\n+    muladd(n7, SECP256K1_N_C_0);\n+    muladd(n6, SECP256K1_N_C_1);\n+    muladd(n5, SECP256K1_N_C_2);\n+    muladd(n4, SECP256K1_N_C_3);\n+    sumadd(n3);\n+    uint32_t m7; extract(m7);\n+    muladd(n7, SECP256K1_N_C_1);\n+    muladd(n6, SECP256K1_N_C_2);\n+    muladd(n5, SECP256K1_N_C_3);\n+    sumadd(n4);\n+    uint32_t m8; extract(m8);\n+    muladd(n7, SECP256K1_N_C_2);\n+    muladd(n6, SECP256K1_N_C_3);\n+    sumadd(n5);\n+    uint32_t m9; extract(m9);\n+    muladd(n7, SECP256K1_N_C_3);\n+    sumadd(n6);\n+    uint32_t m10; extract(m10);\n+    sumadd_fast(n7);\n+    uint32_t m11; extract_fast(m11);\n+    VERIFY_CHECK(c0 <= 1);\n+    uint32_t m12 = c0;\n+\n+    // Reduce 385 bits into 258.\n+    // p[0..8] = m[0..7] + m[8..12] * SECP256K1_N_C.\n+    c0 = m0; c1 = 0; c2 = 0;\n+    muladd_fast(m8, SECP256K1_N_C_0);\n+    uint32_t p0; extract_fast(p0);\n+    sumadd_fast(m1);\n+    muladd(m9, SECP256K1_N_C_0);\n+    muladd(m8, SECP256K1_N_C_1);\n+    uint32_t p1; extract(p1);\n+    sumadd(m2);\n+    muladd(m10, SECP256K1_N_C_0);\n+    muladd(m9, SECP256K1_N_C_1);\n+    muladd(m8, SECP256K1_N_C_2);\n+    uint32_t p2; extract(p2);\n+    sumadd(m3);\n+    muladd(m11, SECP256K1_N_C_0);\n+    muladd(m10, SECP256K1_N_C_1);\n+    muladd(m9, SECP256K1_N_C_2);\n+    muladd(m8, SECP256K1_N_C_3);\n+    uint32_t p3; extract(p3);\n+    sumadd(m4);\n+    muladd(m12, SECP256K1_N_C_0);\n+    muladd(m11, SECP256K1_N_C_1);\n+    muladd(m10, SECP256K1_N_C_2);\n+    muladd(m9, SECP256K1_N_C_3);\n+    sumadd(m8);\n+    uint32_t p4; extract(p4);\n+    sumadd(m5);\n+    muladd(m12, SECP256K1_N_C_1);\n+    muladd(m11, SECP256K1_N_C_2);\n+    muladd(m10, SECP256K1_N_C_3);\n+    sumadd(m9);\n+    uint32_t p5; extract(p5);\n+    sumadd(m6);\n+    muladd(m12, SECP256K1_N_C_2);\n+    muladd(m11, SECP256K1_N_C_3);\n+    sumadd(m10);\n+    uint32_t p6; extract(p6);\n+    sumadd_fast(m7);\n+    muladd_fast(m12, SECP256K1_N_C_3);\n+    sumadd_fast(m11);\n+    uint32_t p7; extract_fast(p7);\n+    uint32_t p8 = c0 + m12;\n+    VERIFY_CHECK(p8 <= 2);\n+\n+    // Reduce 258 bits into 256.\n+    // r[0..7] = p[0..7] + p[8] * SECP256K1_N_C.\n+    uint64_t c = p0 + (uint64_t)SECP256K1_N_C_0 * p8;\n+    r->d[0] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p1 + (uint64_t)SECP256K1_N_C_1 * p8;\n+    r->d[1] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p2 + (uint64_t)SECP256K1_N_C_2 * p8;\n+    r->d[2] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p3 + (uint64_t)SECP256K1_N_C_3 * p8;\n+    r->d[3] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p4 + (uint64_t)p8;\n+    r->d[4] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p5;\n+    r->d[5] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p6;\n+    r->d[6] = c & 0xFFFFFFFFUL; c >>= 32;\n+    c += p7;\n+    r->d[7] = c & 0xFFFFFFFFUL; c >>= 32;\n+\n+    // Final reduction of r.\n+    secp256k1_scalar_reduce(r, c + secp256k1_scalar_check_overflow(r));\n+}\n+\n+void static secp256k1_scalar_mul(secp256k1_scalar_t *r, const secp256k1_scalar_t *a, const secp256k1_scalar_t *b) {\n+    // 96 bit accumulator.\n+    uint32_t c0 = 0, c1 = 0, c2 = 0;\n+\n+    uint32_t l[16];\n+\n+    // l[0..15] = a[0..7] * b[0..7].\n+    muladd_fast(a->d[0], b->d[0]);\n+    extract_fast(l[0]);\n+    muladd(a->d[0], b->d[1]);\n+    muladd(a->d[1], b->d[0]);\n+    extract(l[1]);\n+    muladd(a->d[0], b->d[2]);\n+    muladd(a->d[1], b->d[1]);\n+    muladd(a->d[2], b->d[0]);\n+    extract(l[2]);\n+    muladd(a->d[0], b->d[3]);\n+    muladd(a->d[1], b->d[2]);\n+    muladd(a->d[2], b->d[1]);\n+    muladd(a->d[3], b->d[0]);\n+    extract(l[3]);\n+    muladd(a->d[0], b->d[4]);\n+    muladd(a->d[1], b->d[3]);\n+    muladd(a->d[2], b->d[2]);\n+    muladd(a->d[3], b->d[1]);\n+    muladd(a->d[4], b->d[0]);\n+    extract(l[4]);\n+    muladd(a->d[0], b->d[5]);\n+    muladd(a->d[1], b->d[4]);\n+    muladd(a->d[2], b->d[3]);\n+    muladd(a->d[3], b->d[2]);\n+    muladd(a->d[4], b->d[1]);\n+    muladd(a->d[5], b->d[0]);\n+    extract(l[5]);\n+    muladd(a->d[0], b->d[6]);\n+    muladd(a->d[1], b->d[5]);\n+    muladd(a->d[2], b->d[4]);\n+    muladd(a->d[3], b->d[3]);\n+    muladd(a->d[4], b->d[2]);\n+    muladd(a->d[5], b->d[1]);\n+    muladd(a->d[6], b->d[0]);\n+    extract(l[6]);\n+    muladd(a->d[0], b->d[7]);\n+    muladd(a->d[1], b->d[6]);\n+    muladd(a->d[2], b->d[5]);\n+    muladd(a->d[3], b->d[4]);\n+    muladd(a->d[4], b->d[3]);\n+    muladd(a->d[5], b->d[2]);\n+    muladd(a->d[6], b->d[1]);\n+    muladd(a->d[7], b->d[0]);\n+    extract(l[7]);\n+    muladd(a->d[1], b->d[7]);\n+    muladd(a->d[2], b->d[6]);\n+    muladd(a->d[3], b->d[5]);\n+    muladd(a->d[4], b->d[4]);\n+    muladd(a->d[5], b->d[3]);\n+    muladd(a->d[6], b->d[2]);\n+    muladd(a->d[7], b->d[1]);\n+    extract(l[8]);\n+    muladd(a->d[2], b->d[7]);\n+    muladd(a->d[3], b->d[6]);\n+    muladd(a->d[4], b->d[5]);\n+    muladd(a->d[5], b->d[4]);\n+    muladd(a->d[6], b->d[3]);\n+    muladd(a->d[7], b->d[2]);\n+    extract(l[9]);\n+    muladd(a->d[3], b->d[7]);\n+    muladd(a->d[4], b->d[6]);\n+    muladd(a->d[5], b->d[5]);\n+    muladd(a->d[6], b->d[4]);\n+    muladd(a->d[7], b->d[3]);\n+    extract(l[10]);\n+    muladd(a->d[4], b->d[7]);\n+    muladd(a->d[5], b->d[6]);\n+    muladd(a->d[6], b->d[5]);\n+    muladd(a->d[7], b->d[4]);\n+    extract(l[11]);\n+    muladd(a->d[5], b->d[7]);\n+    muladd(a->d[6], b->d[6]);\n+    muladd(a->d[7], b->d[5]);\n+    extract(l[12]);\n+    muladd(a->d[6], b->d[7]);\n+    muladd(a->d[7], b->d[6]);\n+    extract(l[13]);\n+    muladd_fast(a->d[7], b->d[7]);\n+    extract_fast(l[14]);\n+    VERIFY_CHECK(c1 == 0);\n+    l[15] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+void static secp256k1_scalar_sqr(secp256k1_scalar_t *r, const secp256k1_scalar_t *a) {\n+    // 96 bit accumulator.\n+    uint32_t c0 = 0, c1 = 0, c2 = 0;\n+\n+    uint32_t l[16];\n+\n+    // l[0..15] = a[0..7]^2.\n+    muladd_fast(a->d[0], a->d[0]);\n+    extract_fast(l[0]);\n+    muladd2(a->d[0], a->d[1]);\n+    extract(l[1]);\n+    muladd2(a->d[0], a->d[2]);\n+    muladd(a->d[1], a->d[1]);\n+    extract(l[2]);\n+    muladd2(a->d[0], a->d[3]);\n+    muladd2(a->d[1], a->d[2]);\n+    extract(l[3]);\n+    muladd2(a->d[0], a->d[4]);\n+    muladd2(a->d[1], a->d[3]);\n+    muladd(a->d[2], a->d[2]);\n+    extract(l[4]);\n+    muladd2(a->d[0], a->d[5]);\n+    muladd2(a->d[1], a->d[4]);\n+    muladd2(a->d[2], a->d[3]);\n+    extract(l[5]);\n+    muladd2(a->d[0], a->d[6]);\n+    muladd2(a->d[1], a->d[5]);\n+    muladd2(a->d[2], a->d[4]);\n+    muladd(a->d[3], a->d[3]);\n+    extract(l[6]);\n+    muladd2(a->d[0], a->d[7]);\n+    muladd2(a->d[1], a->d[6]);\n+    muladd2(a->d[2], a->d[5]);\n+    muladd2(a->d[3], a->d[4]);\n+    extract(l[7]);\n+    muladd2(a->d[1], a->d[7]);\n+    muladd2(a->d[2], a->d[6]);\n+    muladd2(a->d[3], a->d[5]);\n+    muladd(a->d[4], a->d[4]);\n+    extract(l[8]);\n+    muladd2(a->d[2], a->d[7]);\n+    muladd2(a->d[3], a->d[6]);\n+    muladd2(a->d[4], a->d[5]);\n+    extract(l[9]);\n+    muladd2(a->d[3], a->d[7]);\n+    muladd2(a->d[4], a->d[6]);\n+    muladd(a->d[5], a->d[5]);\n+    extract(l[10]);\n+    muladd2(a->d[4], a->d[7]);\n+    muladd2(a->d[5], a->d[6]);\n+    extract(l[11]);\n+    muladd2(a->d[5], a->d[7]);\n+    muladd(a->d[6], a->d[6]);\n+    extract(l[12]);\n+    muladd2(a->d[6], a->d[7]);\n+    extract(l[13]);\n+    muladd_fast(a->d[7], a->d[7]);\n+    extract_fast(l[14]);\n+    VERIFY_CHECK(c1 == 0);\n+    l[15] = c0;\n+\n+    secp256k1_scalar_reduce_512(r, l);\n+}\n+\n+#undef sumadd\n+#undef sumadd_fast\n+#undef muladd\n+#undef muladd_fast\n+#undef muladd2\n+#undef extract\n+#undef extract_fast\n+\n+#endif"
      },
      {
        "sha": "c52328e42cc017b8ac1c129517b78eaa1550a5ec",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "added",
        "additions": 182,
        "deletions": 0,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,182 @@\n+// Copyright (c) 2014 Pieter Wuille\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_SCALAR_IMPL_H_\n+#define _SECP256K1_SCALAR_IMPL_H_\n+\n+#include <string.h>\n+\n+#include \"scalar.h\"\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#if defined(USE_SCALAR_4X64)\n+#include \"scalar_4x64_impl.h\"\n+#elif defined(USE_SCALAR_8X32)\n+#include \"scalar_8x32_impl.h\"\n+#else\n+#error \"Please select scalar implementation\"\n+#endif\n+\n+void static secp256k1_scalar_get_num(secp256k1_num_t *r, const secp256k1_scalar_t *a) {\n+    unsigned char c[32];\n+    secp256k1_scalar_get_b32(c, a);\n+    secp256k1_num_set_bin(r, c, 32);\n+}\n+\n+\n+void static secp256k1_scalar_inverse(secp256k1_scalar_t *r, const secp256k1_scalar_t *x) {\n+    // First compute x ^ (2^N - 1) for some values of N.\n+    secp256k1_scalar_t x2, x3, x4, x6, x7, x8, x15, x30, x60, x120, x127;\n+\n+    secp256k1_scalar_sqr(&x2,  x);\n+    secp256k1_scalar_mul(&x2, &x2,  x);\n+\n+    secp256k1_scalar_sqr(&x3, &x2);\n+    secp256k1_scalar_mul(&x3, &x3,  x);\n+\n+    secp256k1_scalar_sqr(&x4, &x3);\n+    secp256k1_scalar_mul(&x4, &x4,  x);\n+\n+    secp256k1_scalar_sqr(&x6, &x4);\n+    secp256k1_scalar_sqr(&x6, &x6);\n+    secp256k1_scalar_mul(&x6, &x6, &x2);\n+\n+    secp256k1_scalar_sqr(&x7, &x6);\n+    secp256k1_scalar_mul(&x7, &x7,  x);\n+\n+    secp256k1_scalar_sqr(&x8, &x7);\n+    secp256k1_scalar_mul(&x8, &x8,  x);\n+\n+    secp256k1_scalar_sqr(&x15, &x8);\n+    for (int i=0; i<6; i++)\n+        secp256k1_scalar_sqr(&x15, &x15);\n+    secp256k1_scalar_mul(&x15, &x15, &x7);\n+\n+    secp256k1_scalar_sqr(&x30, &x15);\n+    for (int i=0; i<14; i++)\n+        secp256k1_scalar_sqr(&x30, &x30);\n+    secp256k1_scalar_mul(&x30, &x30, &x15);\n+\n+    secp256k1_scalar_sqr(&x60, &x30);\n+    for (int i=0; i<29; i++)\n+        secp256k1_scalar_sqr(&x60, &x60);\n+    secp256k1_scalar_mul(&x60, &x60, &x30);\n+\n+    secp256k1_scalar_sqr(&x120, &x60);\n+    for (int i=0; i<59; i++)\n+        secp256k1_scalar_sqr(&x120, &x120);\n+    secp256k1_scalar_mul(&x120, &x120, &x60);\n+\n+    secp256k1_scalar_sqr(&x127, &x120);\n+    for (int i=0; i<6; i++)\n+        secp256k1_scalar_sqr(&x127, &x127);\n+    secp256k1_scalar_mul(&x127, &x127, &x7);\n+\n+    // Then accumulate the final result (t starts at x127).\n+    secp256k1_scalar_t *t = &x127;\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<3; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<5; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<4; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<5; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x4); // 1111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<4; i++) // 000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<10; i++) // 0000000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<4; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x3); // 111\n+    for (int i=0; i<9; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x8); // 11111111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<5; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x4); // 1111\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<5; i++) // 000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<4; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<2; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<8; i++) // 000000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<3; i++) // 0\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, &x2); // 11\n+    for (int i=0; i<3; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<6; i++) // 00000\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(t, t, x); // 1\n+    for (int i=0; i<8; i++) // 00\n+        secp256k1_scalar_sqr(t, t);\n+    secp256k1_scalar_mul(r, t, &x6); // 111111\n+}\n+\n+#endif"
      },
      {
        "sha": "3e37648299ab9a5bd91f2b2c2d0915e596977286",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "added",
        "additions": 305,
        "deletions": 0,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"include/secp256k1.h\"\n+\n+#include <assert.h>\n+#include \"util.h\"\n+#include \"num_impl.h\"\n+#include \"field_impl.h\"\n+#include \"scalar_impl.h\"\n+#include \"group_impl.h\"\n+#include \"ecmult_impl.h\"\n+#include \"ecmult_gen_impl.h\"\n+#include \"ecdsa_impl.h\"\n+#include \"eckey_impl.h\"\n+\n+void secp256k1_start(unsigned int flags) {\n+    secp256k1_fe_start();\n+    secp256k1_ge_start();\n+    if (flags & SECP256K1_START_SIGN) {\n+        secp256k1_ecmult_gen_start();\n+    }\n+    if (flags & SECP256K1_START_VERIFY) {\n+        secp256k1_ecmult_start();\n+    }\n+}\n+\n+void secp256k1_stop(void) {\n+    secp256k1_ecmult_stop();\n+    secp256k1_ecmult_gen_stop();\n+    secp256k1_ge_stop();\n+    secp256k1_fe_stop();\n+}\n+\n+int secp256k1_ecdsa_verify(const unsigned char *msg, int msglen, const unsigned char *sig, int siglen, const unsigned char *pubkey, int pubkeylen) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(msg != NULL);\n+    DEBUG_CHECK(msglen <= 32);\n+    DEBUG_CHECK(sig != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+\n+    int ret = -3;\n+    secp256k1_num_t m; \n+    secp256k1_ecdsa_sig_t s;\n+    secp256k1_ge_t q;\n+    secp256k1_num_set_bin(&m, msg, msglen);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen)) {\n+        ret = -1;\n+        goto end;\n+    }\n+    if (!secp256k1_ecdsa_sig_parse(&s, sig, siglen)) {\n+        ret = -2;\n+        goto end;\n+    }\n+    if (!secp256k1_ecdsa_sig_verify(&s, &q, &m)) {\n+        ret = 0;\n+        goto end;\n+    }\n+    ret = 1;\n+end:\n+    return ret;\n+}\n+\n+int secp256k1_ecdsa_sign(const unsigned char *message, int messagelen, unsigned char *signature, int *signaturelen, const unsigned char *seckey, const unsigned char *nonce) {\n+    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(message != NULL);\n+    DEBUG_CHECK(messagelen <= 32);\n+    DEBUG_CHECK(signature != NULL);\n+    DEBUG_CHECK(signaturelen != NULL);\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(nonce != NULL);\n+\n+    secp256k1_scalar_t sec, non, msg;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&non, nonce, &overflow);\n+    {\n+        unsigned char c[32] = {0};\n+        memcpy(c + 32 - messagelen, message, messagelen);\n+        secp256k1_scalar_set_b32(&msg, c, NULL);\n+        memset(c, 0, 32);\n+    }\n+    int ret = !secp256k1_scalar_is_zero(&non) && !overflow;\n+    secp256k1_ecdsa_sig_t sig;\n+    if (ret) {\n+        ret = secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, NULL);\n+    }\n+    if (ret) {\n+        secp256k1_ecdsa_sig_serialize(signature, signaturelen, &sig);\n+    }\n+    secp256k1_scalar_clear(&msg);\n+    secp256k1_scalar_clear(&non);\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ecdsa_sign_compact(const unsigned char *message, int messagelen, unsigned char *sig64, const unsigned char *seckey, const unsigned char *nonce, int *recid) {\n+    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(message != NULL);\n+    DEBUG_CHECK(messagelen <= 32);\n+    DEBUG_CHECK(sig64 != NULL);\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(nonce != NULL);\n+\n+    secp256k1_scalar_t sec, non, msg;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&non, nonce, &overflow);\n+    {\n+        unsigned char c[32] = {0};\n+        memcpy(c + 32 - messagelen, message, messagelen);\n+        secp256k1_scalar_set_b32(&msg, c, NULL);\n+        memset(c, 0, 32);\n+    }\n+    int ret = !secp256k1_scalar_is_zero(&non) && !overflow;\n+    secp256k1_ecdsa_sig_t sig;\n+    if (ret) {\n+        ret = secp256k1_ecdsa_sig_sign(&sig, &sec, &msg, &non, recid);\n+    }\n+    if (ret) {\n+        secp256k1_num_get_bin(sig64, 32, &sig.r);\n+        secp256k1_num_get_bin(sig64 + 32, 32, &sig.s);\n+    }\n+    secp256k1_scalar_clear(&msg);\n+    secp256k1_scalar_clear(&non);\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ecdsa_recover_compact(const unsigned char *msg, int msglen, const unsigned char *sig64, unsigned char *pubkey, int *pubkeylen, int compressed, int recid) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(msg != NULL);\n+    DEBUG_CHECK(msglen <= 32);\n+    DEBUG_CHECK(sig64 != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(pubkeylen != NULL);\n+    DEBUG_CHECK(recid >= 0 && recid <= 3);\n+\n+    int ret = 0;\n+    secp256k1_num_t m; \n+    secp256k1_ecdsa_sig_t sig;\n+    secp256k1_num_set_bin(&sig.r, sig64, 32);\n+    secp256k1_num_set_bin(&sig.s, sig64 + 32, 32);\n+    secp256k1_num_set_bin(&m, msg, msglen);\n+\n+    secp256k1_ge_t q;\n+    if (secp256k1_ecdsa_sig_recover(&sig, &q, &m, recid)) {\n+        secp256k1_eckey_pubkey_serialize(&q, pubkey, pubkeylen, compressed);\n+        ret = 1;\n+    }\n+    return ret;\n+}\n+\n+int secp256k1_ec_seckey_verify(const unsigned char *seckey) {\n+    DEBUG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_t sec;\n+    int overflow;\n+    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n+    int ret = !secp256k1_scalar_is_zero(&sec) && !overflow;\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_verify(const unsigned char *pubkey, int pubkeylen) {\n+    DEBUG_CHECK(pubkey != NULL);\n+\n+    secp256k1_ge_t q;\n+    return secp256k1_eckey_pubkey_parse(&q, pubkey, pubkeylen);\n+}\n+\n+int secp256k1_ec_pubkey_create(unsigned char *pubkey, int *pubkeylen, const unsigned char *seckey, int compressed) {\n+    DEBUG_CHECK(secp256k1_ecmult_gen_consts != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(pubkeylen != NULL);\n+    DEBUG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_t sec;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    secp256k1_gej_t pj;\n+    secp256k1_ecmult_gen(&pj, &sec);\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_ge_t p;\n+    secp256k1_ge_set_gej(&p, &pj);\n+    secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, compressed);\n+    return 1;\n+}\n+\n+int secp256k1_ec_pubkey_decompress(unsigned char *pubkey, int *pubkeylen) {\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(pubkeylen != NULL);\n+\n+    secp256k1_ge_t p;\n+    if (!secp256k1_eckey_pubkey_parse(&p, pubkey, *pubkeylen))\n+        return 0;\n+    secp256k1_eckey_pubkey_serialize(&p, pubkey, pubkeylen, 0);\n+    return 1;\n+}\n+\n+int secp256k1_ec_privkey_tweak_add(unsigned char *seckey, const unsigned char *tweak) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_scalar_t term;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&term, tweak, &overflow);\n+    secp256k1_scalar_t sec;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+\n+    int ret = secp256k1_eckey_privkey_tweak_add(&sec, &term) && !overflow;\n+    if (ret) {\n+        secp256k1_scalar_get_b32(seckey, &sec);\n+    }\n+\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_clear(&term);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_tweak_add(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_num_t term;\n+    secp256k1_num_set_bin(&term, tweak, 32);\n+    secp256k1_ge_t p;\n+    int ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n+    if (ret) {\n+        ret = secp256k1_eckey_pubkey_tweak_add(&p, &term);\n+    }\n+    if (ret) {\n+        int oldlen = pubkeylen;\n+        secp256k1_eckey_pubkey_serialize(&p, pubkey, &pubkeylen, oldlen <= 33);\n+        VERIFY_CHECK(pubkeylen == oldlen);\n+    }\n+\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_tweak_mul(unsigned char *seckey, const unsigned char *tweak) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_scalar_t factor;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n+    secp256k1_scalar_t sec;\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    int ret = secp256k1_eckey_privkey_tweak_mul(&sec, &factor) && !overflow;\n+    if (ret) {\n+        secp256k1_scalar_get_b32(seckey, &sec);\n+    }\n+\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_clear(&factor);\n+    return ret;\n+}\n+\n+int secp256k1_ec_pubkey_tweak_mul(unsigned char *pubkey, int pubkeylen, const unsigned char *tweak) {\n+    DEBUG_CHECK(secp256k1_ecmult_consts != NULL);\n+    DEBUG_CHECK(pubkey != NULL);\n+    DEBUG_CHECK(tweak != NULL);\n+\n+    secp256k1_num_t factor;\n+    secp256k1_num_set_bin(&factor, tweak, 32);\n+    secp256k1_ge_t p;\n+    int ret = secp256k1_eckey_pubkey_parse(&p, pubkey, pubkeylen);\n+    if (ret) {\n+        ret = secp256k1_eckey_pubkey_tweak_mul(&p, &factor);\n+    }\n+    if (ret) {\n+        int oldlen = pubkeylen;\n+        secp256k1_eckey_pubkey_serialize(&p, pubkey, &pubkeylen, oldlen <= 33);\n+        VERIFY_CHECK(pubkeylen == oldlen);\n+    }\n+\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_export(const unsigned char *seckey, unsigned char *privkey, int *privkeylen, int compressed) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(privkey != NULL);\n+    DEBUG_CHECK(privkeylen != NULL);\n+\n+    secp256k1_scalar_t key;\n+    secp256k1_scalar_set_b32(&key, seckey, NULL);\n+    int ret = secp256k1_eckey_privkey_serialize(privkey, privkeylen, &key, compressed);\n+    secp256k1_scalar_clear(&key);\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_import(unsigned char *seckey, const unsigned char *privkey, int privkeylen) {\n+    DEBUG_CHECK(seckey != NULL);\n+    DEBUG_CHECK(privkey != NULL);\n+\n+    secp256k1_scalar_t key;\n+    int ret = secp256k1_eckey_privkey_parse(&key, privkey, privkeylen);\n+    if (ret)\n+        secp256k1_scalar_get_b32(seckey, &key);\n+    secp256k1_scalar_clear(&key);\n+    return ret;\n+}"
      },
      {
        "sha": "593380ae7619416a2fe7e125841261630bb956d7",
        "filename": "src/secp256k1/src/tests.c",
        "status": "added",
        "additions": 899,
        "deletions": 0,
        "changes": 899,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,899 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"util_impl.h\"\n+#include \"secp256k1.c\"\n+\n+#ifdef ENABLE_OPENSSL_TESTS\n+#include \"openssl/bn.h\"\n+#include \"openssl/ec.h\"\n+#include \"openssl/ecdsa.h\"\n+#include \"openssl/obj_mac.h\"\n+#endif\n+\n+static int count = 64;\n+\n+/***** NUM TESTS *****/\n+\n+void random_num_negate(secp256k1_num_t *num) {\n+    if (secp256k1_rand32() & 1)\n+        secp256k1_num_negate(num);\n+}\n+\n+void random_num_order_test(secp256k1_num_t *num) {\n+    do {\n+        unsigned char b32[32];\n+        secp256k1_rand256_test(b32);\n+        secp256k1_num_set_bin(num, b32, 32);\n+        if (secp256k1_num_is_zero(num))\n+            continue;\n+        if (secp256k1_num_cmp(num, &secp256k1_ge_consts->order) >= 0)\n+            continue;\n+        break;\n+    } while(1);\n+}\n+\n+void random_scalar_order_test(secp256k1_scalar_t *num) {\n+    do {\n+        unsigned char b32[32];\n+        secp256k1_rand256_test(b32);\n+        int overflow = 0;\n+        secp256k1_scalar_set_b32(num, b32, &overflow);\n+        if (overflow || secp256k1_scalar_is_zero(num))\n+            continue;\n+        break;\n+    } while(1);\n+}\n+\n+void random_num_order(secp256k1_num_t *num) {\n+    do {\n+        unsigned char b32[32];\n+        secp256k1_rand256(b32);\n+        secp256k1_num_set_bin(num, b32, 32);\n+        if (secp256k1_num_is_zero(num))\n+            continue;\n+        if (secp256k1_num_cmp(num, &secp256k1_ge_consts->order) >= 0)\n+            continue;\n+        break;\n+    } while(1);\n+}\n+\n+void test_num_copy_inc_cmp() {\n+    secp256k1_num_t n1,n2;\n+    random_num_order(&n1);\n+    secp256k1_num_copy(&n2, &n1);\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+    CHECK(secp256k1_num_eq(&n2, &n1));\n+    secp256k1_num_inc(&n2);\n+    CHECK(!secp256k1_num_eq(&n1, &n2));\n+    CHECK(!secp256k1_num_eq(&n2, &n1));\n+}\n+\n+\n+void test_num_get_set_hex() {\n+    secp256k1_num_t n1,n2;\n+    random_num_order_test(&n1);\n+    char c[64];\n+    secp256k1_num_get_hex(c, 64, &n1);\n+    secp256k1_num_set_hex(&n2, c, 64);\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+    for (int i=0; i<64; i++) {\n+        // check whether the lower 4 bits correspond to the last hex character\n+        int low1 = secp256k1_num_shift(&n1, 4);\n+        int lowh = c[63];\n+        int low2 = (lowh>>6)*9+(lowh-'0')&15;\n+        CHECK(low1 == low2);\n+        // shift bits off the hex representation, and compare\n+        memmove(c+1, c, 63);\n+        c[0] = '0';\n+        secp256k1_num_set_hex(&n2, c, 64);\n+        CHECK(secp256k1_num_eq(&n1, &n2));\n+    }\n+}\n+\n+void test_num_get_set_bin() {\n+    secp256k1_num_t n1,n2;\n+    random_num_order_test(&n1);\n+    unsigned char c[32];\n+    secp256k1_num_get_bin(c, 32, &n1);\n+    secp256k1_num_set_bin(&n2, c, 32);\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+    for (int i=0; i<32; i++) {\n+        // check whether the lower 8 bits correspond to the last byte\n+        int low1 = secp256k1_num_shift(&n1, 8);\n+        int low2 = c[31];\n+        CHECK(low1 == low2);\n+        // shift bits off the byte representation, and compare\n+        memmove(c+1, c, 31);\n+        c[0] = 0;\n+        secp256k1_num_set_bin(&n2, c, 32);\n+        CHECK(secp256k1_num_eq(&n1, &n2));\n+    }\n+}\n+\n+void run_num_int() {\n+    secp256k1_num_t n1;\n+    for (int i=-255; i<256; i++) {\n+        unsigned char c1[3] = {};\n+        c1[2] = abs(i);\n+        unsigned char c2[3] = {0x11,0x22,0x33};\n+        secp256k1_num_set_int(&n1, i);\n+        secp256k1_num_get_bin(c2, 3, &n1);\n+        CHECK(memcmp(c1, c2, 3) == 0);\n+    }\n+}\n+\n+void test_num_negate() {\n+    secp256k1_num_t n1;\n+    secp256k1_num_t n2;\n+    random_num_order_test(&n1); // n1 = R\n+    random_num_negate(&n1);\n+    secp256k1_num_copy(&n2, &n1); // n2 = R\n+    secp256k1_num_sub(&n1, &n2, &n1); // n1 = n2-n1 = 0\n+    CHECK(secp256k1_num_is_zero(&n1));\n+    secp256k1_num_copy(&n1, &n2); // n1 = R\n+    secp256k1_num_negate(&n1); // n1 = -R\n+    CHECK(!secp256k1_num_is_zero(&n1));\n+    secp256k1_num_add(&n1, &n2, &n1); // n1 = n2+n1 = 0\n+    CHECK(secp256k1_num_is_zero(&n1));\n+    secp256k1_num_copy(&n1, &n2); // n1 = R\n+    secp256k1_num_negate(&n1); // n1 = -R\n+    CHECK(secp256k1_num_is_neg(&n1) != secp256k1_num_is_neg(&n2));\n+    secp256k1_num_negate(&n1); // n1 = R\n+    CHECK(secp256k1_num_eq(&n1, &n2));\n+}\n+\n+void test_num_add_sub() {\n+    int r = secp256k1_rand32();\n+    secp256k1_num_t n1;\n+    secp256k1_num_t n2;\n+    random_num_order_test(&n1); // n1 = R1\n+    if (r & 1) {\n+        random_num_negate(&n1);\n+    }\n+    random_num_order_test(&n2); // n2 = R2\n+    if (r & 2) {\n+        random_num_negate(&n2);\n+    }\n+    secp256k1_num_t n1p2, n2p1, n1m2, n2m1;\n+    secp256k1_num_add(&n1p2, &n1, &n2); // n1p2 = R1 + R2\n+    secp256k1_num_add(&n2p1, &n2, &n1); // n2p1 = R2 + R1\n+    secp256k1_num_sub(&n1m2, &n1, &n2); // n1m2 = R1 - R2\n+    secp256k1_num_sub(&n2m1, &n2, &n1); // n2m1 = R2 - R1\n+    CHECK(secp256k1_num_eq(&n1p2, &n2p1));\n+    CHECK(!secp256k1_num_eq(&n1p2, &n1m2));\n+    secp256k1_num_negate(&n2m1); // n2m1 = -R2 + R1\n+    CHECK(secp256k1_num_eq(&n2m1, &n1m2));\n+    CHECK(!secp256k1_num_eq(&n2m1, &n1));\n+    secp256k1_num_add(&n2m1, &n2m1, &n2); // n2m1 = -R2 + R1 + R2 = R1\n+    CHECK(secp256k1_num_eq(&n2m1, &n1));\n+    CHECK(!secp256k1_num_eq(&n2p1, &n1));\n+    secp256k1_num_sub(&n2p1, &n2p1, &n2); // n2p1 = R2 + R1 - R2 = R1\n+    CHECK(secp256k1_num_eq(&n2p1, &n1));\n+}\n+\n+void run_num_smalltests() {\n+    for (int i=0; i<100*count; i++) {\n+        test_num_copy_inc_cmp();\n+        test_num_get_set_hex();\n+        test_num_get_set_bin();\n+        test_num_negate();\n+        test_num_add_sub();\n+    }\n+    run_num_int();\n+}\n+\n+/***** SCALAR TESTS *****/\n+\n+int secp256k1_scalar_eq(const secp256k1_scalar_t *s1, const secp256k1_scalar_t *s2) {\n+    secp256k1_scalar_t t;\n+    secp256k1_scalar_negate(&t, s2);\n+    secp256k1_scalar_add(&t, &t, s1);\n+    int ret = secp256k1_scalar_is_zero(&t);\n+    return ret;\n+}\n+\n+void scalar_test(void) {\n+    unsigned char c[32];\n+\n+    // Set 's' to a random scalar, with value 'snum'.\n+    secp256k1_rand256_test(c);\n+    secp256k1_scalar_t s;\n+    secp256k1_scalar_set_b32(&s, c, NULL);\n+    secp256k1_num_t snum;\n+    secp256k1_num_set_bin(&snum, c, 32);\n+    secp256k1_num_mod(&snum, &secp256k1_ge_consts->order);\n+\n+    // Set 's1' to a random scalar, with value 's1num'.\n+    secp256k1_rand256_test(c);\n+    secp256k1_scalar_t s1;\n+    secp256k1_scalar_set_b32(&s1, c, NULL);\n+    secp256k1_num_t s1num;\n+    secp256k1_num_set_bin(&s1num, c, 32);\n+    secp256k1_num_mod(&s1num, &secp256k1_ge_consts->order);\n+\n+    // Set 's2' to a random scalar, with value 'snum2', and byte array representation 'c'.\n+    secp256k1_rand256_test(c);\n+    secp256k1_scalar_t s2;\n+    int overflow = 0;\n+    secp256k1_scalar_set_b32(&s2, c, &overflow);\n+    secp256k1_num_t s2num;\n+    secp256k1_num_set_bin(&s2num, c, 32);\n+    secp256k1_num_mod(&s2num, &secp256k1_ge_consts->order);\n+\n+    {\n+        // Test that fetching groups of 4 bits from a scalar and recursing n(i)=16*n(i-1)+p(i) reconstructs it.\n+        secp256k1_num_t n, t, m;\n+        secp256k1_num_set_int(&n, 0);\n+        secp256k1_num_set_int(&m, 16);\n+        for (int i = 0; i < 256; i += 4) {\n+            secp256k1_num_set_int(&t, secp256k1_scalar_get_bits(&s, 256 - 4 - i, 4));\n+            secp256k1_num_mul(&n, &n, &m);\n+            secp256k1_num_add(&n, &n, &t);\n+        }\n+        CHECK(secp256k1_num_eq(&n, &snum));\n+    }\n+\n+    {\n+        // Test that get_b32 returns the same as get_bin on the number.\n+        unsigned char r1[32];\n+        secp256k1_scalar_get_b32(r1, &s2);\n+        unsigned char r2[32];\n+        secp256k1_num_get_bin(r2, 32, &s2num);\n+        CHECK(memcmp(r1, r2, 32) == 0);\n+        // If no overflow occurred when assigning, it should also be equal to the original byte array.\n+        CHECK((memcmp(r1, c, 32) == 0) == (overflow == 0));\n+    }\n+\n+    {\n+        // Test that adding the scalars together is equal to adding their numbers together modulo the order.\n+        secp256k1_num_t rnum;\n+        secp256k1_num_add(&rnum, &snum, &s2num);\n+        secp256k1_num_mod(&rnum, &secp256k1_ge_consts->order);\n+        secp256k1_scalar_t r;\n+        secp256k1_scalar_add(&r, &s, &s2);\n+        secp256k1_num_t r2num;\n+        secp256k1_scalar_get_num(&r2num, &r);\n+        CHECK(secp256k1_num_eq(&rnum, &r2num));\n+    }\n+\n+    {\n+        // Test that multipying the scalars is equal to multiplying their numbers modulo the order.\n+        secp256k1_num_t rnum;\n+        secp256k1_num_mul(&rnum, &snum, &s2num);\n+        secp256k1_num_mod(&rnum, &secp256k1_ge_consts->order);\n+        secp256k1_scalar_t r;\n+        secp256k1_scalar_mul(&r, &s, &s2);\n+        secp256k1_num_t r2num;\n+        secp256k1_scalar_get_num(&r2num, &r);\n+        CHECK(secp256k1_num_eq(&rnum, &r2num));\n+        // The result can only be zero if at least one of the factors was zero.\n+        CHECK(secp256k1_scalar_is_zero(&r) == (secp256k1_scalar_is_zero(&s) || secp256k1_scalar_is_zero(&s2)));\n+        // The results can only be equal to one of the factors if that factor was zero, or the other factor was one.\n+        CHECK(secp256k1_num_eq(&rnum, &snum) == (secp256k1_scalar_is_zero(&s) || secp256k1_scalar_is_one(&s2)));\n+        CHECK(secp256k1_num_eq(&rnum, &s2num) == (secp256k1_scalar_is_zero(&s2) || secp256k1_scalar_is_one(&s)));\n+    }\n+\n+    {\n+        // Check that comparison with zero matches comparison with zero on the number.\n+        CHECK(secp256k1_num_is_zero(&snum) == secp256k1_scalar_is_zero(&s));\n+        // Check that comparison with the half order is equal to testing for high scalar.\n+        CHECK(secp256k1_scalar_is_high(&s) == (secp256k1_num_cmp(&snum, &secp256k1_ge_consts->half_order) > 0));\n+        secp256k1_scalar_t neg;\n+        secp256k1_scalar_negate(&neg, &s);\n+        secp256k1_num_t negnum;\n+        secp256k1_num_sub(&negnum, &secp256k1_ge_consts->order, &snum);\n+        secp256k1_num_mod(&negnum, &secp256k1_ge_consts->order);\n+        // Check that comparison with the half order is equal to testing for high scalar after negation.\n+        CHECK(secp256k1_scalar_is_high(&neg) == (secp256k1_num_cmp(&negnum, &secp256k1_ge_consts->half_order) > 0));\n+        // Negating should change the high property, unless the value was already zero.\n+        CHECK((secp256k1_scalar_is_high(&s) == secp256k1_scalar_is_high(&neg)) == secp256k1_scalar_is_zero(&s));\n+        secp256k1_num_t negnum2;\n+        secp256k1_scalar_get_num(&negnum2, &neg);\n+        // Negating a scalar should be equal to (order - n) mod order on the number.\n+        CHECK(secp256k1_num_eq(&negnum, &negnum2));\n+        secp256k1_scalar_add(&neg, &neg, &s);\n+        // Adding a number to its negation should result in zero.\n+        CHECK(secp256k1_scalar_is_zero(&neg));\n+        secp256k1_scalar_negate(&neg, &neg);\n+        // Negating zero should still result in zero.\n+        CHECK(secp256k1_scalar_is_zero(&neg));\n+    }\n+\n+    {\n+        // Test that scalar inverses are equal to the inverse of their number modulo the order.\n+        if (!secp256k1_scalar_is_zero(&s)) {\n+            secp256k1_scalar_t inv;\n+            secp256k1_scalar_inverse(&inv, &s);\n+            secp256k1_num_t invnum;\n+            secp256k1_num_mod_inverse(&invnum, &snum, &secp256k1_ge_consts->order);\n+            secp256k1_num_t invnum2;\n+            secp256k1_scalar_get_num(&invnum2, &inv);\n+            CHECK(secp256k1_num_eq(&invnum, &invnum2));\n+            secp256k1_scalar_mul(&inv, &inv, &s);\n+            // Multiplying a scalar with its inverse must result in one.\n+            CHECK(secp256k1_scalar_is_one(&inv));\n+            secp256k1_scalar_inverse(&inv, &inv);\n+            // Inverting one must result in one.\n+            CHECK(secp256k1_scalar_is_one(&inv));\n+        }\n+    }\n+\n+    {\n+        // Test commutativity of add.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_add(&r1, &s1, &s2);\n+        secp256k1_scalar_add(&r2, &s2, &s1);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test commutativity of mul.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_mul(&r1, &s1, &s2);\n+        secp256k1_scalar_mul(&r2, &s2, &s1);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test associativity of add.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_add(&r1, &s1, &s2);\n+        secp256k1_scalar_add(&r1, &r1, &s);\n+        secp256k1_scalar_add(&r2, &s2, &s);\n+        secp256k1_scalar_add(&r2, &s1, &r2);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test associativity of mul.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_mul(&r1, &s1, &s2);\n+        secp256k1_scalar_mul(&r1, &r1, &s);\n+        secp256k1_scalar_mul(&r2, &s2, &s);\n+        secp256k1_scalar_mul(&r2, &s1, &r2);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test distributitivity of mul over add.\n+        secp256k1_scalar_t r1, r2, t;\n+        secp256k1_scalar_add(&r1, &s1, &s2);\n+        secp256k1_scalar_mul(&r1, &r1, &s);\n+        secp256k1_scalar_mul(&r2, &s1, &s);\n+        secp256k1_scalar_mul(&t, &s2, &s);\n+        secp256k1_scalar_add(&r2, &r2, &t);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+\n+    {\n+        // Test square.\n+        secp256k1_scalar_t r1, r2;\n+        secp256k1_scalar_sqr(&r1, &s1);\n+        secp256k1_scalar_mul(&r2, &s1, &s1);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+void run_scalar_tests(void) {\n+    for (int i = 0; i < 128 * count; i++) {\n+        scalar_test();\n+    }\n+}\n+\n+/***** FIELD TESTS *****/\n+\n+void random_fe(secp256k1_fe_t *x) {\n+    unsigned char bin[32];\n+    secp256k1_rand256(bin);\n+    secp256k1_fe_set_b32(x, bin);\n+}\n+\n+void random_fe_non_zero(secp256k1_fe_t *nz) {\n+    int tries = 10;\n+    while (--tries >= 0) {\n+        random_fe(nz);\n+        secp256k1_fe_normalize(nz);\n+        if (!secp256k1_fe_is_zero(nz))\n+            break;\n+    }\n+    // Infinitesimal probability of spurious failure here\n+    CHECK(tries >= 0);\n+}\n+\n+void random_fe_non_square(secp256k1_fe_t *ns) {\n+    random_fe_non_zero(ns);\n+    secp256k1_fe_t r;\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n+        secp256k1_fe_negate(ns, ns, 1);\n+    }\n+}\n+\n+int check_fe_equal(const secp256k1_fe_t *a, const secp256k1_fe_t *b) {\n+    secp256k1_fe_t an = *a; secp256k1_fe_normalize(&an);\n+    secp256k1_fe_t bn = *b; secp256k1_fe_normalize(&bn);\n+    return secp256k1_fe_equal(&an, &bn);\n+}\n+\n+int check_fe_inverse(const secp256k1_fe_t *a, const secp256k1_fe_t *ai) {\n+    secp256k1_fe_t x; secp256k1_fe_mul(&x, a, ai);\n+    secp256k1_fe_t one; secp256k1_fe_set_int(&one, 1);\n+    return check_fe_equal(&x, &one);\n+}\n+\n+void run_field_inv() {\n+    secp256k1_fe_t x, xi, xii;\n+    for (int i=0; i<10*count; i++) {\n+        random_fe_non_zero(&x);\n+        secp256k1_fe_inv(&xi, &x);\n+        CHECK(check_fe_inverse(&x, &xi));\n+        secp256k1_fe_inv(&xii, &xi);\n+        CHECK(check_fe_equal(&x, &xii));\n+    }\n+}\n+\n+void run_field_inv_var() {\n+    secp256k1_fe_t x, xi, xii;\n+    for (int i=0; i<10*count; i++) {\n+        random_fe_non_zero(&x);\n+        secp256k1_fe_inv_var(&xi, &x);\n+        CHECK(check_fe_inverse(&x, &xi));\n+        secp256k1_fe_inv_var(&xii, &xi);\n+        CHECK(check_fe_equal(&x, &xii));\n+    }\n+}\n+\n+void run_field_inv_all() {\n+    secp256k1_fe_t x[16], xi[16], xii[16];\n+    // Check it's safe to call for 0 elements\n+    secp256k1_fe_inv_all(0, xi, x);\n+    for (int i=0; i<count; i++) {\n+        size_t len = (secp256k1_rand32() & 15) + 1;\n+        for (int j=0; j<len; j++)\n+            random_fe_non_zero(&x[j]);\n+        secp256k1_fe_inv_all(len, xi, x);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_inverse(&x[j], &xi[j]));\n+        secp256k1_fe_inv_all(len, xii, xi);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_equal(&x[j], &xii[j]));\n+    }\n+}\n+\n+void run_field_inv_all_var() {\n+    secp256k1_fe_t x[16], xi[16], xii[16];\n+    // Check it's safe to call for 0 elements\n+    secp256k1_fe_inv_all_var(0, xi, x);\n+    for (int i=0; i<count; i++) {\n+        size_t len = (secp256k1_rand32() & 15) + 1;\n+        for (int j=0; j<len; j++)\n+            random_fe_non_zero(&x[j]);\n+        secp256k1_fe_inv_all_var(len, xi, x);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_inverse(&x[j], &xi[j]));\n+        secp256k1_fe_inv_all_var(len, xii, xi);\n+        for (int j=0; j<len; j++)\n+            CHECK(check_fe_equal(&x[j], &xii[j]));\n+    }\n+}\n+\n+void run_sqr() {\n+    secp256k1_fe_t x, s;\n+\n+    {\n+        secp256k1_fe_set_int(&x, 1);\n+        secp256k1_fe_negate(&x, &x, 1);\n+\n+        for (int i=1; i<=512; ++i) {\n+            secp256k1_fe_mul_int(&x, 2);\n+            secp256k1_fe_normalize(&x);\n+            secp256k1_fe_sqr(&s, &x);\n+        }\n+    }\n+}\n+\n+void test_sqrt(const secp256k1_fe_t *a, const secp256k1_fe_t *k) {\n+    secp256k1_fe_t r1, r2;\n+    int v = secp256k1_fe_sqrt(&r1, a);\n+    CHECK((v == 0) == (k == NULL));\n+\n+    if (k != NULL) {\n+        // Check that the returned root is +/- the given known answer\n+        secp256k1_fe_negate(&r2, &r1, 1);\n+        secp256k1_fe_add(&r1, k); secp256k1_fe_add(&r2, k);\n+        secp256k1_fe_normalize(&r1); secp256k1_fe_normalize(&r2);\n+        CHECK(secp256k1_fe_is_zero(&r1) || secp256k1_fe_is_zero(&r2));\n+    }\n+}\n+\n+void run_sqrt() {\n+    secp256k1_fe_t ns, x, s, t;\n+\n+    // Check sqrt(0) is 0\n+    secp256k1_fe_set_int(&x, 0);\n+    secp256k1_fe_sqr(&s, &x);\n+    test_sqrt(&s, &x);\n+\n+    // Check sqrt of small squares (and their negatives)\n+    for (int i=1; i<=100; i++) {\n+        secp256k1_fe_set_int(&x, i);\n+        secp256k1_fe_sqr(&s, &x);\n+        test_sqrt(&s, &x);\n+        secp256k1_fe_negate(&t, &s, 1);\n+        test_sqrt(&t, NULL);\n+    }\n+\n+    // Consistency checks for large random values\n+    for (int i=0; i<10; i++) {\n+        random_fe_non_square(&ns);\n+        for (int j=0; j<count; j++) {\n+            random_fe(&x);\n+            secp256k1_fe_sqr(&s, &x);\n+            test_sqrt(&s, &x);\n+            secp256k1_fe_negate(&t, &s, 1);\n+            test_sqrt(&t, NULL);\n+            secp256k1_fe_mul(&t, &s, &ns);\n+            test_sqrt(&t, NULL);\n+        }\n+    }\n+}\n+\n+/***** ECMULT TESTS *****/\n+\n+void run_ecmult_chain() {\n+    // random starting point A (on the curve)\n+    secp256k1_fe_t ax; secp256k1_fe_set_hex(&ax, \"8b30bbe9ae2a990696b22f670709dff3727fd8bc04d3362c6c7bf458e2846004\", 64);\n+    secp256k1_fe_t ay; secp256k1_fe_set_hex(&ay, \"a357ae915c4a65281309edf20504740f0eb3343990216b4f81063cb65f2f7e0f\", 64);\n+    secp256k1_gej_t a; secp256k1_gej_set_xy(&a, &ax, &ay);\n+    // two random initial factors xn and gn\n+    secp256k1_num_t xn;\n+    secp256k1_num_set_hex(&xn, \"84cc5452f7fde1edb4d38a8ce9b1b84ccef31f146e569be9705d357a42985407\", 64);\n+    secp256k1_num_t gn;\n+    secp256k1_num_set_hex(&gn, \"a1e58d22553dcd42b23980625d4c57a96e9323d42b3152e5ca2c3990edc7c9de\", 64);\n+    // two small multipliers to be applied to xn and gn in every iteration:\n+    secp256k1_num_t xf;\n+    secp256k1_num_set_hex(&xf, \"1337\", 4);\n+    secp256k1_num_t gf;\n+    secp256k1_num_set_hex(&gf, \"7113\", 4);\n+    // accumulators with the resulting coefficients to A and G\n+    secp256k1_num_t ae;\n+    secp256k1_num_set_int(&ae, 1);\n+    secp256k1_num_t ge;\n+    secp256k1_num_set_int(&ge, 0);\n+    // the point being computed\n+    secp256k1_gej_t x = a;\n+    const secp256k1_num_t *order = &secp256k1_ge_consts->order;\n+    for (int i=0; i<200*count; i++) {\n+        // in each iteration, compute X = xn*X + gn*G;\n+        secp256k1_ecmult(&x, &x, &xn, &gn);\n+        // also compute ae and ge: the actual accumulated factors for A and G\n+        // if X was (ae*A+ge*G), xn*X + gn*G results in (xn*ae*A + (xn*ge+gn)*G)\n+        secp256k1_num_mod_mul(&ae, &ae, &xn, order);\n+        secp256k1_num_mod_mul(&ge, &ge, &xn, order);\n+        secp256k1_num_add(&ge, &ge, &gn);\n+        secp256k1_num_mod(&ge, order);\n+        // modify xn and gn\n+        secp256k1_num_mod_mul(&xn, &xn, &xf, order);\n+        secp256k1_num_mod_mul(&gn, &gn, &gf, order);\n+\n+        // verify\n+        if (i == 19999) {\n+            char res[132]; int resl = 132;\n+            secp256k1_gej_get_hex(res, &resl, &x);\n+            CHECK(strcmp(res, \"(D6E96687F9B10D092A6F35439D86CEBEA4535D0D409F53586440BD74B933E830,B95CBCA2C77DA786539BE8FD53354D2D3B4F566AE658045407ED6015EE1B2A88)\") == 0);\n+        }\n+    }\n+    // redo the computation, but directly with the resulting ae and ge coefficients:\n+    secp256k1_gej_t x2; secp256k1_ecmult(&x2, &a, &ae, &ge);\n+    char res[132]; int resl = 132;\n+    char res2[132]; int resl2 = 132;\n+    secp256k1_gej_get_hex(res, &resl, &x);\n+    secp256k1_gej_get_hex(res2, &resl2, &x2);\n+    CHECK(strcmp(res, res2) == 0);\n+    CHECK(strlen(res) == 131);\n+}\n+\n+void test_point_times_order(const secp256k1_gej_t *point) {\n+    // multiplying a point by the order results in O\n+    const secp256k1_num_t *order = &secp256k1_ge_consts->order;\n+    secp256k1_num_t zero;\n+    secp256k1_num_set_int(&zero, 0);\n+    secp256k1_gej_t res;\n+    secp256k1_ecmult(&res, point, order, order); // calc res = order * point + order * G;\n+    CHECK(secp256k1_gej_is_infinity(&res));\n+}\n+\n+void run_point_times_order() {\n+    secp256k1_fe_t x; secp256k1_fe_set_hex(&x, \"02\", 2);\n+    for (int i=0; i<500; i++) {\n+        secp256k1_ge_t p;\n+        if (secp256k1_ge_set_xo(&p, &x, 1)) {\n+            CHECK(secp256k1_ge_is_valid(&p));\n+            secp256k1_gej_t j;\n+            secp256k1_gej_set_ge(&j, &p);\n+            CHECK(secp256k1_gej_is_valid(&j));\n+            test_point_times_order(&j);\n+        }\n+        secp256k1_fe_sqr(&x, &x);\n+    }\n+    char c[65]; int cl=65;\n+    secp256k1_fe_get_hex(c, &cl, &x);\n+    CHECK(strcmp(c, \"7603CB59B0EF6C63FE6084792A0C378CDB3233A80F8A9A09A877DEAD31B38C45\") == 0);\n+}\n+\n+void test_wnaf(const secp256k1_num_t *number, int w) {\n+    secp256k1_num_t x, two, t;\n+    secp256k1_num_set_int(&x, 0);\n+    secp256k1_num_set_int(&two, 2);\n+    int wnaf[257];\n+    int bits = secp256k1_ecmult_wnaf(wnaf, number, w);\n+    int zeroes = -1;\n+    for (int i=bits-1; i>=0; i--) {\n+        secp256k1_num_mul(&x, &x, &two);\n+        int v = wnaf[i];\n+        if (v) {\n+            CHECK(zeroes == -1 || zeroes >= w-1); // check that distance between non-zero elements is at least w-1\n+            zeroes=0;\n+            CHECK((v & 1) == 1); // check non-zero elements are odd\n+            CHECK(v <= (1 << (w-1)) - 1); // check range below\n+            CHECK(v >= -(1 << (w-1)) - 1); // check range above\n+        } else {\n+            CHECK(zeroes != -1); // check that no unnecessary zero padding exists\n+            zeroes++;\n+        }\n+        secp256k1_num_set_int(&t, v);\n+        secp256k1_num_add(&x, &x, &t);\n+    }\n+    CHECK(secp256k1_num_eq(&x, number)); // check that wnaf represents number\n+}\n+\n+void run_wnaf() {\n+    secp256k1_num_t n;\n+    for (int i=0; i<count; i++) {\n+        random_num_order(&n);\n+        if (i % 1)\n+            secp256k1_num_negate(&n);\n+        test_wnaf(&n, 4+(i%10));\n+    }\n+}\n+\n+void random_sign(secp256k1_ecdsa_sig_t *sig, const secp256k1_scalar_t *key, const secp256k1_scalar_t *msg, int *recid) {\n+    secp256k1_scalar_t nonce;\n+    do {\n+        random_scalar_order_test(&nonce);\n+    } while(!secp256k1_ecdsa_sig_sign(sig, key, msg, &nonce, recid));\n+}\n+\n+void test_ecdsa_sign_verify() {\n+    secp256k1_scalar_t msg, key;\n+    random_scalar_order_test(&msg);\n+    random_scalar_order_test(&key);\n+    secp256k1_gej_t pubj; secp256k1_ecmult_gen(&pubj, &key);\n+    secp256k1_ge_t pub; secp256k1_ge_set_gej(&pub, &pubj);\n+    secp256k1_ecdsa_sig_t sig;\n+    random_sign(&sig, &key, &msg, NULL);\n+    secp256k1_num_t msg_num;\n+    secp256k1_scalar_get_num(&msg_num, &msg);\n+    CHECK(secp256k1_ecdsa_sig_verify(&sig, &pub, &msg_num));\n+    secp256k1_num_inc(&msg_num);\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &pub, &msg_num));\n+}\n+\n+void run_ecdsa_sign_verify() {\n+    for (int i=0; i<10*count; i++) {\n+        test_ecdsa_sign_verify();\n+    }\n+}\n+\n+void test_ecdsa_end_to_end() {\n+    unsigned char privkey[32];\n+    unsigned char message[32];\n+\n+    // Generate a random key and message.\n+    {\n+        secp256k1_num_t msg, key;\n+        random_num_order_test(&msg);\n+        random_num_order_test(&key);\n+        secp256k1_num_get_bin(privkey, 32, &key);\n+        secp256k1_num_get_bin(message, 32, &msg);\n+    }\n+\n+    // Construct and verify corresponding public key.\n+    CHECK(secp256k1_ec_seckey_verify(privkey) == 1);\n+    unsigned char pubkey[65]; int pubkeylen = 65;\n+    CHECK(secp256k1_ec_pubkey_create(pubkey, &pubkeylen, privkey, secp256k1_rand32() % 2) == 1);\n+    CHECK(secp256k1_ec_pubkey_verify(pubkey, pubkeylen));\n+\n+    // Verify private key import and export.\n+    unsigned char seckey[300]; int seckeylen = 300;\n+    CHECK(secp256k1_ec_privkey_export(privkey, seckey, &seckeylen, secp256k1_rand32() % 2) == 1);\n+    unsigned char privkey2[32];\n+    CHECK(secp256k1_ec_privkey_import(privkey2, seckey, seckeylen) == 1);\n+    CHECK(memcmp(privkey, privkey2, 32) == 0);\n+\n+    // Optionally tweak the keys using addition.\n+    if (secp256k1_rand32() % 3 == 0) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        int ret1 = secp256k1_ec_privkey_tweak_add(privkey, rnd);\n+        int ret2 = secp256k1_ec_pubkey_tweak_add(pubkey, pubkeylen, rnd);\n+        CHECK(ret1 == ret2);\n+        if (ret1 == 0) return;\n+        unsigned char pubkey2[65]; int pubkeylen2 = 65;\n+        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n+    }\n+\n+    // Optionally tweak the keys using multiplication.\n+    if (secp256k1_rand32() % 3 == 0) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        int ret1 = secp256k1_ec_privkey_tweak_mul(privkey, rnd);\n+        int ret2 = secp256k1_ec_pubkey_tweak_mul(pubkey, pubkeylen, rnd);\n+        CHECK(ret1 == ret2);\n+        if (ret1 == 0) return;\n+        unsigned char pubkey2[65]; int pubkeylen2 = 65;\n+        CHECK(secp256k1_ec_pubkey_create(pubkey2, &pubkeylen2, privkey, pubkeylen == 33) == 1);\n+        CHECK(memcmp(pubkey, pubkey2, pubkeylen) == 0);\n+    }\n+\n+    // Sign.\n+    unsigned char signature[72]; int signaturelen = 72;\n+    while(1) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        if (secp256k1_ecdsa_sign(message, 32, signature, &signaturelen, privkey, rnd) == 1) {\n+            break;\n+        }\n+    }\n+    // Verify.\n+    CHECK(secp256k1_ecdsa_verify(message, 32, signature, signaturelen, pubkey, pubkeylen) == 1);\n+    // Destroy signature and verify again.\n+    signature[signaturelen - 1 - secp256k1_rand32() % 20] += 1 + (secp256k1_rand32() % 255);\n+    CHECK(secp256k1_ecdsa_verify(message, 32, signature, signaturelen, pubkey, pubkeylen) != 1);\n+\n+    // Compact sign.\n+    unsigned char csignature[64]; int recid = 0;\n+    while(1) {\n+        unsigned char rnd[32];\n+        secp256k1_rand256_test(rnd);\n+        if (secp256k1_ecdsa_sign_compact(message, 32, csignature, privkey, rnd, &recid) == 1) {\n+            break;\n+        }\n+    }\n+    // Recover.\n+    unsigned char recpubkey[65]; int recpubkeylen = 0;\n+    CHECK(secp256k1_ecdsa_recover_compact(message, 32, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) == 1);\n+    CHECK(recpubkeylen == pubkeylen);\n+    CHECK(memcmp(pubkey, recpubkey, pubkeylen) == 0);\n+    // Destroy signature and verify again.\n+    csignature[secp256k1_rand32() % 64] += 1 + (secp256k1_rand32() % 255);\n+    CHECK(secp256k1_ecdsa_recover_compact(message, 32, csignature, recpubkey, &recpubkeylen, pubkeylen == 33, recid) != 1 ||\n+          memcmp(pubkey, recpubkey, pubkeylen) != 0);\n+    CHECK(recpubkeylen == pubkeylen);\n+\n+}\n+\n+void run_ecdsa_end_to_end() {\n+    for (int i=0; i<64*count; i++) {\n+        test_ecdsa_end_to_end();\n+    }\n+}\n+\n+\n+#ifdef ENABLE_OPENSSL_TESTS\n+EC_KEY *get_openssl_key(const secp256k1_scalar_t *key) {\n+    unsigned char privkey[300];\n+    int privkeylen;\n+    int compr = secp256k1_rand32() & 1;\n+    const unsigned char* pbegin = privkey;\n+    EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n+    CHECK(secp256k1_eckey_privkey_serialize(privkey, &privkeylen, key, compr));\n+    CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n+    CHECK(EC_KEY_check_key(ec_key));\n+    return ec_key;\n+}\n+\n+void test_ecdsa_openssl() {\n+    secp256k1_scalar_t key, msg;\n+    unsigned char message[32];\n+    secp256k1_rand256_test(message);\n+    secp256k1_scalar_set_b32(&msg, message, NULL);\n+    random_scalar_order_test(&key);\n+    secp256k1_gej_t qj;\n+    secp256k1_ecmult_gen(&qj, &key);\n+    secp256k1_ge_t q;\n+    secp256k1_ge_set_gej(&q, &qj);\n+    EC_KEY *ec_key = get_openssl_key(&key);\n+    CHECK(ec_key);\n+    unsigned char signature[80];\n+    unsigned int sigsize = 80;\n+    CHECK(ECDSA_sign(0, message, sizeof(message), signature, &sigsize, ec_key));\n+    secp256k1_ecdsa_sig_t sig;\n+    CHECK(secp256k1_ecdsa_sig_parse(&sig, signature, sigsize));\n+    secp256k1_num_t msg_num;\n+    secp256k1_scalar_get_num(&msg_num, &msg);\n+    CHECK(secp256k1_ecdsa_sig_verify(&sig, &q, &msg_num));\n+    secp256k1_num_inc(&sig.r);\n+    CHECK(!secp256k1_ecdsa_sig_verify(&sig, &q, &msg_num));\n+\n+    random_sign(&sig, &key, &msg, NULL);\n+    int secp_sigsize = 80;\n+    CHECK(secp256k1_ecdsa_sig_serialize(signature, &secp_sigsize, &sig));\n+    CHECK(ECDSA_verify(0, message, sizeof(message), signature, secp_sigsize, ec_key) == 1);\n+\n+    EC_KEY_free(ec_key);\n+}\n+\n+void run_ecdsa_openssl() {\n+    for (int i=0; i<10*count; i++) {\n+        test_ecdsa_openssl();\n+    }\n+}\n+#endif\n+\n+int main(int argc, char **argv) {\n+    // find iteration count\n+    if (argc > 1) {\n+        count = strtol(argv[1], NULL, 0);\n+    }\n+\n+    // find random seed\n+    uint64_t seed;\n+    if (argc > 2) {\n+        seed = strtoull(argv[2], NULL, 0);\n+    } else {\n+        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        if (!frand || !fread(&seed, sizeof(seed), 1, frand)) {\n+            seed = time(NULL) * 1337;\n+        }\n+        fclose(frand);\n+    }\n+    secp256k1_rand_seed(seed);\n+\n+    printf(\"test count = %i\\n\", count);\n+    printf(\"random seed = %llu\\n\", (unsigned long long)seed);\n+\n+    // initialize\n+    secp256k1_start(SECP256K1_START_SIGN | SECP256K1_START_VERIFY);\n+\n+    // num tests\n+    run_num_smalltests();\n+\n+    // scalar tests\n+    run_scalar_tests();\n+\n+    // field tests\n+    run_field_inv();\n+    run_field_inv_var();\n+    run_field_inv_all();\n+    run_field_inv_all_var();\n+    run_sqr();\n+    run_sqrt();\n+\n+    // ecmult tests\n+    run_wnaf();\n+    run_point_times_order();\n+    run_ecmult_chain();\n+\n+    // ecdsa tests\n+    run_ecdsa_sign_verify();\n+    run_ecdsa_end_to_end();\n+#ifdef ENABLE_OPENSSL_TESTS\n+    run_ecdsa_openssl();\n+#endif\n+\n+    printf(\"random run = %llu\\n\", (unsigned long long)secp256k1_rand32() + ((unsigned long long)secp256k1_rand32() << 32));\n+\n+    // shutdown\n+    secp256k1_stop();\n+    return 0;\n+}"
      },
      {
        "sha": "0ab3d217738169767e980b07cb20ec3be31bfa6c",
        "filename": "src/secp256k1/src/util.h",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_UTIL_H_\n+#define _SECP256K1_UTIL_H_\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+#define TEST_FAILURE(msg) do { \\\n+    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, msg); \\\n+    abort(); \\\n+} while(0)\n+\n+#ifndef HAVE_BUILTIN_EXPECT\n+#define EXPECT(x,c) __builtin_expect((x),(c))\n+#else\n+#define EXPECT(x,c) (x)\n+#endif\n+\n+#define CHECK(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        TEST_FAILURE(\"test condition failed: \" #cond); \\\n+    } \\\n+} while(0)\n+\n+// Like assert(), but safe to use on expressions with side effects.\n+#ifndef NDEBUG\n+#define DEBUG_CHECK CHECK\n+#else\n+#define DEBUG_CHECK(cond) do { (void)(cond); } while(0)\n+#endif\n+\n+// Like DEBUG_CHECK(), but when VERIFY is defined instead of NDEBUG not defined.\n+#ifdef VERIFY\n+#define VERIFY_CHECK CHECK\n+#else\n+#define VERIFY_CHECK(cond) do { (void)(cond); } while(0)\n+#endif\n+\n+/** Seed the pseudorandom number generator. */\n+static inline void secp256k1_rand_seed(uint64_t v);\n+\n+/** Generate a pseudorandom 32-bit number. */\n+static uint32_t secp256k1_rand32(void);\n+\n+/** Generate a pseudorandom 32-byte array. */\n+static void secp256k1_rand256(unsigned char *b32);\n+\n+/** Generate a pseudorandom 32-byte array with long sequences of zero and one bits. */\n+static void secp256k1_rand256_test(unsigned char *b32);\n+\n+#endif"
      },
      {
        "sha": "482fb31b1a87c7e7d1c88bee6e0c25840be6be25",
        "filename": "src/secp256k1/src/util_impl.h",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/util_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac0aba4193df1884b203ad29c3a60e257811b553/src/secp256k1/src/util_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util_impl.h?ref=ac0aba4193df1884b203ad29c3a60e257811b553",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2013 Pieter Wuille\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _SECP256K1_UTIL_IMPL_H_\n+#define _SECP256K1_UTIL_IMPL_H_\n+\n+#include <stdint.h>\n+#include <string.h>\n+\n+#include \"util.h\"\n+\n+static uint32_t secp256k1_Rz = 11, secp256k1_Rw = 11;\n+\n+static inline void secp256k1_rand_seed(uint64_t v) {\n+    secp256k1_Rz = v >> 32;\n+    secp256k1_Rw = v;\n+\n+    if (secp256k1_Rz == 0 || secp256k1_Rz == 0x9068ffffU) {\n+        secp256k1_Rz = 111;\n+    }\n+    if (secp256k1_Rw == 0 || secp256k1_Rw == 0x464fffffU) {\n+        secp256k1_Rw = 111;\n+    }\n+}\n+\n+static inline uint32_t secp256k1_rand32(void) {\n+    secp256k1_Rz = 36969 * (secp256k1_Rz & 0xFFFF) + (secp256k1_Rz >> 16);\n+    secp256k1_Rw = 18000 * (secp256k1_Rw & 0xFFFF) + (secp256k1_Rw >> 16);\n+    return (secp256k1_Rw << 16) + (secp256k1_Rw >> 16) + secp256k1_Rz;\n+}\n+\n+static void secp256k1_rand256(unsigned char *b32) {\n+    for (int i=0; i<8; i++) {\n+        uint32_t r = secp256k1_rand32();\n+        b32[i*4 + 0] = (r >>  0) & 0xFF;\n+        b32[i*4 + 1] = (r >>  8) & 0xFF;\n+        b32[i*4 + 2] = (r >> 16) & 0xFF;\n+        b32[i*4 + 3] = (r >> 24) & 0xFF;\n+    }\n+}\n+\n+static void secp256k1_rand256_test(unsigned char *b32) {\n+    int bits=0;\n+    memset(b32, 0, 32);\n+    while (bits < 256) {\n+        uint32_t ent = secp256k1_rand32();\n+        int now = 1 + ((ent % 64)*((ent >> 6) % 32)+16)/31;\n+        uint32_t val = 1 & (ent >> 11);\n+        while (now > 0 && bits < 256) {\n+            b32[bits / 8] |= val << (bits % 8);\n+            now--;\n+            bits++;\n+        }\n+    }\n+}\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NzQzZmUxMGJkNTZiZGI1MGFkNzVlZDJlNzQyNTY0ZmIwZTEzYzNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-05T15:58:37Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:40Z"
      },
      "message": "Always build and link libsecp256k1",
      "tree": {
        "sha": "75e87d1d1431db5c80cf8f43e6ce0d0c2d598b65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/75e87d1d1431db5c80cf8f43e6ce0d0c2d598b65"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ac0aba4193df1884b203ad29c3a60e257811b553",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac0aba4193df1884b203ad29c3a60e257811b553",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac0aba4193df1884b203ad29c3a60e257811b553"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 22,
      "deletions": 35
    },
    "files": [
      {
        "sha": "89b856e664e2ea20925793ba7596c3dae2554581",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "patch": "@@ -800,7 +800,6 @@ AC_SUBST(CLIENT_VERSION_BUILD, _CLIENT_VERSION_BUILD)\n AC_SUBST(CLIENT_VERSION_IS_RELEASE, _CLIENT_VERSION_IS_RELEASE)\n AC_SUBST(COPYRIGHT_YEAR, _COPYRIGHT_YEAR)\n \n-\n AC_SUBST(RELDFLAGS)\n AC_SUBST(LIBTOOL_LDFLAGS)\n AC_SUBST(USE_UPNP)\n@@ -816,6 +815,16 @@ AC_SUBST(MINIUPNPC_LIBS)\n AC_CONFIG_FILES([Makefile src/Makefile share/setup.nsi share/qt/Info.plist src/test/buildenv.py])\n AC_CONFIG_FILES([qa/pull-tester/run-bitcoind-for-test.sh],[chmod +x qa/pull-tester/run-bitcoind-for-test.sh])\n AC_CONFIG_FILES([qa/pull-tester/tests-config.sh],[chmod +x qa/pull-tester/tests-config.sh])\n+\n+dnl boost's m4 checks do something really nasty: they export these vars. As a\n+dnl result, they leak into secp256k1's configure and crazy things happen.\n+dnl Until this is fixed upstream and we've synced, we'll just un-export them.\n+export -n CPPFLAGS\n+export -n LIBS\n+export -n LDFLAGS\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic\"\n+AC_CONFIG_SUBDIRS([src/secp256k1])\n+\n AC_OUTPUT\n \n dnl Taken from https://wiki.debian.org/RpathIssue"
      },
      {
        "sha": "70e649bf20c053f0332c0ae90c011cbe21bf3fd2",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 9,
        "deletions": 21,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "patch": "@@ -1,9 +1,5 @@\n AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS)\n \n-if USE_LIBSECP256K1\n-secp256k1/libsecp256k1.la: $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n-\t@$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n-endif\n \n if EMBEDDED_LEVELDB\n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/include\n@@ -23,9 +19,7 @@ endif\n BITCOIN_CONFIG_INCLUDES=-I$(builddir)/config\n BITCOIN_INCLUDES=-I$(builddir) -I$(builddir)/obj $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\n \n-if USE_LIBSECP256K1\n BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n-endif\n \n LIBBITCOIN_SERVER=libbitcoin_server.a\n LIBBITCOIN_WALLET=libbitcoin_wallet.a\n@@ -35,6 +29,10 @@ LIBBITCOIN_UTIL=libbitcoin_util.a\n LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\n LIBBITCOIN_UNIVALUE=univalue/libbitcoin_univalue.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n+LIBSECP256K1=secp256k1/libsecp256k1.la\n+\n+$(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n+\t@$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n \n # Make is not made aware of per-object dependencies to avoid limiting building parallelization\n # But to build the less dependent modules first, we manually select their order here:\n@@ -278,11 +276,8 @@ bitcoind_LDADD = \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n-  $(LIBMEMENV)\n-\n-if USE_LIBSECP256K1\n-  bitcoind_LDADD += secp256k1/libsecp256k1.la\n-endif\n+  $(LIBMEMENV) \\\n+  $(LIBSECP256K1)\n \n if ENABLE_WALLET\n bitcoind_LDADD += libbitcoin_wallet.a\n@@ -309,9 +304,6 @@ bitcoin_cli_LDADD = \\\n bitcoin_cli_SOURCES = \\\n   bitcoin-cli.cpp\n \n-if USE_LIBSECP256K1\n-  bitcoin_cli_LDADD += secp256k1/libsecp256k1.la\n-endif\n bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES)\n #\n \n@@ -320,13 +312,9 @@ bitcoin_tx_LDADD = \\\n   $(LIBBITCOIN_UNIVALUE) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n-  $(LIBBITCOIN_CRYPTO)\n-\n-if USE_LIBSECP256K1\n-  bitcoin_tx_LDADD += secp256k1/libsecp256k1.la\n-endif\n-\n-  bitcoin_tx_LDADD += $(BOOST_LIBS) \\\n+  $(LIBBITCOIN_CRYPTO) \\\n+  $(LIBSECP256K1) \\\n+  $(BOOST_LIBS) \\\n   $(CRYPTO_LIBS)\n \n bitcoin_tx_SOURCES = bitcoin-tx.cpp"
      },
      {
        "sha": "fac214bdcaa09a3bd69977bd70ad8ed292357192",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "patch": "@@ -360,10 +360,7 @@ if ENABLE_WALLET\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n-if USE_LIBSECP256K1\n-  qt_bitcoin_qt_LDADD += secp256k1/libsecp256k1.la\n-endif\n+  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS)\n qt_bitcoin_qt_LIBTOOLFLAGS = --tag CXX\n "
      },
      {
        "sha": "622411ca686db3a2402508c5764bebcd7af19607",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "patch": "@@ -32,10 +32,7 @@ qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) \\\n   $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n-  $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n-if USE_LIBSECP256K1\n-  qt_test_test_bitcoin_qt_LDADD += secp256k1/libsecp256k1.la\n-endif\n+  $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS)\n \n CLEAN_BITCOIN_QT_TEST = $(TEST_QT_MOC_CPP) qt/test/*.gcda qt/test/*.gcno"
      },
      {
        "sha": "da5c746cc21d3594f38303e4ffd89fe30736cc2d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "patch": "@@ -80,15 +80,11 @@ endif\n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS)\n test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB)\n+  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n \n-if USE_LIBSECP256K1\n-  test_test_bitcoin_LDADD += secp256k1/libsecp256k1.la\n-endif\n-\n test_test_bitcoin_LDADD += $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS)\n "
      }
    ]
  },
  {
    "sha": "35e31ddd035bf6e8af04493c9f12ecf86350160f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNWUzMWRkZDAzNWJmNmU4YWYwNDQ5M2M5ZjEyZWNmODYzNTAxNjBm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-05T17:43:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:04:40Z"
      },
      "message": "Do not use EC code in global constructors",
      "tree": {
        "sha": "8bdfeef342912e9c2a7a471a0efd9a48687183ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8bdfeef342912e9c2a7a471a0efd9a48687183ac"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35e31ddd035bf6e8af04493c9f12ecf86350160f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35e31ddd035bf6e8af04493c9f12ecf86350160f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/35e31ddd035bf6e8af04493c9f12ecf86350160f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35e31ddd035bf6e8af04493c9f12ecf86350160f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7743fe10bd56bdb50ad75ed2e742564fb0e13c3b"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "59e67ac7ba2fde32ec2d73f24bc464f95d0b3a37",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35e31ddd035bf6e8af04493c9f12ecf86350160f/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35e31ddd035bf6e8af04493c9f12ecf86350160f/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=35e31ddd035bf6e8af04493c9f12ecf86350160f",
        "patch": "@@ -172,7 +172,6 @@ struct KeyData\n     }\n };\n \n-const KeyData keys;\n \n class TestBuilder\n {\n@@ -314,6 +313,8 @@ class TestBuilder\n \n BOOST_AUTO_TEST_CASE(script_build)\n {\n+    const KeyData keys;\n+\n     std::vector<TestBuilder> good;\n     std::vector<TestBuilder> bad;\n "
      }
    ]
  },
  {
    "sha": "42fb098e9ed216d300ea1bb912fbde7755e7676e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MmZiMDk4ZTllZDIxNmQzMDBlYTFiYjkxMmZiZGU3NzU1ZTc2NzZl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-05T17:47:06Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:30Z"
      },
      "message": "Use libsecp256k1 in key.cpp",
      "tree": {
        "sha": "e6bde55608d97a9afe5e9f0e991ad030ab5d322f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e6bde55608d97a9afe5e9f0e991ad030ab5d322f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/42fb098e9ed216d300ea1bb912fbde7755e7676e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42fb098e9ed216d300ea1bb912fbde7755e7676e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/42fb098e9ed216d300ea1bb912fbde7755e7676e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42fb098e9ed216d300ea1bb912fbde7755e7676e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "35e31ddd035bf6e8af04493c9f12ecf86350160f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35e31ddd035bf6e8af04493c9f12ecf86350160f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/35e31ddd035bf6e8af04493c9f12ecf86350160f"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 6,
      "deletions": 65
    },
    "files": [
      {
        "sha": "76256b864ce9cef6c019aa39a46e4ff33491ff28",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 65,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42fb098e9ed216d300ea1bb912fbde7755e7676e/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42fb098e9ed216d300ea1bb912fbde7755e7676e/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=42fb098e9ed216d300ea1bb912fbde7755e7676e",
        "patch": "@@ -9,29 +9,23 @@\n #include \"pubkey.h\"\n #include \"random.h\"\n \n-#ifdef USE_SECP256K1\n #include <secp256k1.h>\n-#else\n #include \"ecwrapper.h\"\n-#endif\n \n //! anonymous namespace\n namespace {\n \n-#ifdef USE_SECP256K1\n-#include <secp256k1.h>\n class CSecp256k1Init {\n public:\n     CSecp256k1Init() {\n-        secp256k1_start();\n+        secp256k1_start(SECP256K1_START_SIGN);\n     }\n     ~CSecp256k1Init() {\n         secp256k1_stop();\n     }\n };\n static CSecp256k1Init instance_of_csecp256k1;\n \n-#endif\n } // anon namespace\n \n bool CKey::Check(const unsigned char *vch) {\n@@ -47,15 +41,8 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n }\n \n bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n-#ifdef USE_SECP256K1\n-    if (!secp256k1_ecdsa_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n-        return false;\n-#else\n-    CECKey key;\n-    if (!key.SetPrivKey(&privkey[0], privkey.size()))\n+    if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n-    key.GetSecretBytes(vch);\n-#endif\n     fCompressed = fCompressedIn;\n     fValid = true;\n     return true;\n@@ -65,47 +52,28 @@ CPrivKey CKey::GetPrivKey() const {\n     assert(fValid);\n     CPrivKey privkey;\n     int privkeylen, ret;\n-#ifdef USE_SECP256K1\n     privkey.resize(279);\n     privkeylen = 279;\n-    ret = secp256k1_ecdsa_privkey_export(begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n+    ret = secp256k1_ec_privkey_export(begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n     assert(ret);\n     privkey.resize(privkeylen);\n-#else\n-    CECKey key;\n-    key.SetSecretBytes(vch);\n-    privkeylen = key.GetPrivKeySize(fCompressed);\n-    assert(privkeylen);\n-    privkey.resize(privkeylen);\n-    ret = key.GetPrivKey(&privkey[0], fCompressed);\n-    assert(ret == (int)privkey.size());\n-#endif\n     return privkey;\n }\n \n CPubKey CKey::GetPubKey() const {\n     assert(fValid);\n     CPubKey result;\n-#ifdef USE_SECP256K1\n     int clen = 65;\n-    int ret = secp256k1_ecdsa_pubkey_create((unsigned char*)result.begin(), &clen, begin(), fCompressed);\n+    int ret = secp256k1_ec_pubkey_create((unsigned char*)result.begin(), &clen, begin(), fCompressed);\n     assert((int)result.size() == clen);\n     assert(ret);\n-#else\n-    std::vector<unsigned char> pubkey;\n-    CECKey key;\n-    key.SetSecretBytes(vch);\n-    key.GetPubKey(pubkey, fCompressed);\n-    result.Set(pubkey.begin(), pubkey.end());\n-#endif\n     assert(result.IsValid());\n     return result;\n }\n \n bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n     if (!fValid)\n         return false;\n-#ifdef USE_SECP256K1\n     vchSig.resize(72);\n     int nSigLen = 72;\n     CKey nonce;\n@@ -116,46 +84,27 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n     } while(true);\n     vchSig.resize(nSigLen);\n     return true;\n-#else\n-    CECKey key;\n-    key.SetSecretBytes(vch);\n-    return key.Sign(hash, vchSig);\n-#endif\n }\n \n bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n     if (!fValid)\n         return false;\n     vchSig.resize(65);\n     int rec = -1;\n-#ifdef USE_SECP256K1\n     CKey nonce;\n     do {\n         nonce.MakeNewKey(true);\n         if (secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, 32, &vchSig[1], begin(), nonce.begin(), &rec))\n             break;\n     } while(true);\n-#else\n-    CECKey key;\n-    key.SetSecretBytes(vch);\n-    if (!key.SignCompact(hash, &vchSig[1], rec))\n-        return false;\n-#endif\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n     return true;\n }\n \n bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n-#ifdef USE_SECP256K1\n-    if (!secp256k1_ecdsa_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n-        return false;\n-#else\n-    CECKey key;\n-    if (!key.SetPrivKey(&privkey[0], privkey.size(), fSkipCheck))\n+    if (!secp256k1_ec_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n         return false;\n-    key.GetSecretBytes(vch);\n-#endif\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n \n@@ -182,12 +131,8 @@ bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild\n         BIP32Hash(cc, nChild, 0, begin(), out);\n     }\n     memcpy(ccChild, out+32, 32);\n-#ifdef USE_SECP256K1\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n-    bool ret = secp256k1_ecdsa_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n-#else\n-    bool ret = CECKey::TweakSecret((unsigned char*)keyChild.begin(), begin(), out);\n-#endif\n+    bool ret = secp256k1_ec_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n     UnlockObject(out);\n     keyChild.fCompressed = true;\n     keyChild.fValid = ret;\n@@ -245,9 +190,5 @@ void CExtKey::Decode(const unsigned char code[74]) {\n }\n \n bool ECC_InitSanityCheck() {\n-#ifdef USE_SECP256K1\n-    return true;\n-#else\n     return CECKey::SanityCheck();\n-#endif\n }"
      }
    ]
  },
  {
    "sha": "29a97ec60ab6d57d69f45ab593301d47312965d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOWE5N2VjNjBhYjZkNTdkNjlmNDVhYjU5MzMwMWQ0NzMxMjk2NWQ0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-05T19:48:11Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:34Z"
      },
      "message": "Don't use bashisms in configure",
      "tree": {
        "sha": "2cea0854dd0185e4663807541f31cc9326df068f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2cea0854dd0185e4663807541f31cc9326df068f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/29a97ec60ab6d57d69f45ab593301d47312965d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29a97ec60ab6d57d69f45ab593301d47312965d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/29a97ec60ab6d57d69f45ab593301d47312965d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29a97ec60ab6d57d69f45ab593301d47312965d4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "42fb098e9ed216d300ea1bb912fbde7755e7676e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42fb098e9ed216d300ea1bb912fbde7755e7676e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/42fb098e9ed216d300ea1bb912fbde7755e7676e"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 2,
      "deletions": 3
    },
    "files": [
      {
        "sha": "6fdcc22b473d0efc3481cacc286d961b626c1957",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29a97ec60ab6d57d69f45ab593301d47312965d4/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29a97ec60ab6d57d69f45ab593301d47312965d4/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=29a97ec60ab6d57d69f45ab593301d47312965d4",
        "patch": "@@ -819,9 +819,8 @@ AC_CONFIG_FILES([qa/pull-tester/tests-config.sh],[chmod +x qa/pull-tester/tests-\n dnl boost's m4 checks do something really nasty: they export these vars. As a\n dnl result, they leak into secp256k1's configure and crazy things happen.\n dnl Until this is fixed upstream and we've synced, we'll just un-export them.\n-export -n CPPFLAGS\n-export -n LIBS\n-export -n LDFLAGS\n+unset CPPFLAGS\n+unset LDFLAGS\n ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n "
      }
    ]
  },
  {
    "sha": "594b207d86a914396f972b4784b6c7ddb4709fdc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OTRiMjA3ZDg2YTkxNDM5NmY5NzJiNDc4NGI2YzdkZGI0NzA5ZmRj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-06T00:59:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:34Z"
      },
      "message": "depends: add gmp package",
      "tree": {
        "sha": "5ee78eee31081badd6f78bfcad42714ea6b51881",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ee78eee31081badd6f78bfcad42714ea6b51881"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/594b207d86a914396f972b4784b6c7ddb4709fdc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/594b207d86a914396f972b4784b6c7ddb4709fdc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/594b207d86a914396f972b4784b6c7ddb4709fdc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/594b207d86a914396f972b4784b6c7ddb4709fdc/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29a97ec60ab6d57d69f45ab593301d47312965d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29a97ec60ab6d57d69f45ab593301d47312965d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29a97ec60ab6d57d69f45ab593301d47312965d4"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 81,
      "deletions": 1
    },
    "files": [
      {
        "sha": "bcbf50ceaede69f70a3f28092207605d4bc55009",
        "filename": "depends/packages/gmp.mk",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/packages/gmp.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/packages/gmp.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/gmp.mk?ref=594b207d86a914396f972b4784b6c7ddb4709fdc",
        "patch": "@@ -0,0 +1,30 @@\n+package=gmp\n+$(package)_version=6.0.0a\n+$(package)_download_path=https://gmplib.org/download/gmp\n+$(package)_file_name=$(package)-$($(package)_version).tar.bz2\n+$(package)_sha256_hash=7f8e9a804b9c6d07164cf754207be838ece1219425d64e28cfa3e70d5c759aaf\n+$(package)_patches=arm_gmp_build_fix.patch darwin_gmp_build_fix.patch\n+\n+define $(package)_preprocess_cmds\n+  patch -p1 < $($(package)_patch_dir)/arm_gmp_build_fix.patch && \\\n+  patch -p1 < $($(package)_patch_dir)/darwin_gmp_build_fix.patch\n+endef\n+\n+define $(package)_set_vars\n+  $(package)_config_opts=--disable-shared CC_FOR_BUILD=$(build_CC)\n+  $(package)_config_opts_x86_64_darwin=--with-pic\n+  $(package)_config_opts_x86_64_linux=--with-pic\n+  $(package)_config_opts_arm_linux=--with-pic\n+endef\n+\n+define $(package)_config_cmds\n+  $($(package)_autoconf)\n+endef\n+\n+define $(package)_build_cmds\n+  $(MAKE)\n+endef\n+\n+define $(package)_stage_cmds\n+  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n+endef"
      },
      {
        "sha": "0e1fbeffaae4f21a1520d0a57d864b6282bcc851",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=594b207d86a914396f972b4784b6c7ddb4709fdc",
        "patch": "@@ -1,4 +1,4 @@\n-packages:=boost openssl\n+packages:=boost openssl gmp\n native_packages := native_ccache native_comparisontool\n \n qt_native_packages = native_protobuf"
      },
      {
        "sha": "666cf58cf69c34c39014be8a7b220922c0f52192",
        "filename": "depends/patches/gmp/arm_gmp_build_fix.patch",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/patches/gmp/arm_gmp_build_fix.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/patches/gmp/arm_gmp_build_fix.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/gmp/arm_gmp_build_fix.patch?ref=594b207d86a914396f972b4784b6c7ddb4709fdc",
        "patch": "@@ -0,0 +1,21 @@\n+\n+# HG changeset patch\n+# User Torbjorn Granlund <tege@gmplib.org>\n+# Date 1396602422 -7200\n+# Node ID 676e2d0f0e4dd301a7066079d2c9326c25c34a40\n+# Parent  0194a75b56b21a9196626430af86c5bd9110c42d\n+Conditionalise ARM asm on !__thumb__.\n+\n+diff -r 0194a75b56b2 -r 676e2d0f0e4d mpn/generic/div_qr_1n_pi1.c\n+--- a/mpn/generic/div_qr_1n_pi1.c\tThu Apr 03 23:58:51 2014 +0200\n++++ b/mpn/generic/div_qr_1n_pi1.c\tFri Apr 04 11:07:02 2014 +0200\n+@@ -130,7 +130,7 @@\n+ \t     \"%2\" ((UDItype)(a0)), \"r\" ((UDItype)(b0)) __CLOBBER_CC)\n+ #endif\n+ \n+-#if defined (__arm__) && W_TYPE_SIZE == 32\n++#if defined (__arm__) && !defined (__thumb__) && W_TYPE_SIZE == 32\n+ #define add_mssaaaa(m, sh, sl, ah, al, bh, bl)\t\t\t\t\\\n+   __asm__ (  \"adds\t%2, %5, %6\\n\\t\"\t\t\t\t\t\\\n+ \t     \"adcs\t%1, %3, %4\\n\\t\"\t\t\t\t\t\\\n+"
      },
      {
        "sha": "b9cfd80e778ae4a7d09795ce3780065b993f519b",
        "filename": "depends/patches/gmp/darwin_gmp_build_fix.patch",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/patches/gmp/darwin_gmp_build_fix.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/594b207d86a914396f972b4784b6c7ddb4709fdc/depends/patches/gmp/darwin_gmp_build_fix.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/gmp/darwin_gmp_build_fix.patch?ref=594b207d86a914396f972b4784b6c7ddb4709fdc",
        "patch": "@@ -0,0 +1,29 @@\n+\n+# HG changeset patch\n+# User Torbjorn Granlund <tege@gmplib.org>\n+# Date 1396470504 -7200\n+# Node ID 1fab0adc5ff7d9ecddcbda96f407da58347bb49c\n+# Parent  db645603dcdb41afcf78b19b551ecd5a01c3841c\n+Workaround for Darwin assembler quirk.\n+\n+diff -r db645603dcdb -r 1fab0adc5ff7 mpn/x86_64/k8/redc_1.asm\n+--- a/mpn/x86_64/k8/redc_1.asm\tMon Mar 31 23:04:32 2014 +0200\n++++ b/mpn/x86_64/k8/redc_1.asm\tWed Apr 02 22:28:24 2014 +0200\n+@@ -114,7 +114,7 @@\n+ \n+ \tJUMPTABSECT\n+ \tALIGN(8)\n+-L(tab):\tJMPENT(\tL(0m4), L(tab))\n++L(tab):\tJMPENT(\tL(0), L(tab))\n+ \tJMPENT(\tL(1), L(tab))\n+ \tJMPENT(\tL(2), L(tab))\n+ \tJMPENT(\tL(3), L(tab))\n+@@ -397,6 +397,7 @@\n+ \n+ \n+ \tALIGN(16)\n++L(0):\n+ L(0m4):\n+ L(lo0):\tmov\t(mp,nneg,8), %rax\n+ \tmov\tnneg, i\n+"
      }
    ]
  },
  {
    "sha": "c64b808d4571b42c28f51ac1250aa3be23a2f713",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjRiODA4ZDQ1NzFiNDJjMjhmNTFhYzEyNTBhYTNiZTIzYTJmNzEz",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-06T01:00:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:34Z"
      },
      "message": "depends: quit exporting in config.site",
      "tree": {
        "sha": "c51a9f7d359741f32daaeb57be9e0aaded6d17d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c51a9f7d359741f32daaeb57be9e0aaded6d17d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c64b808d4571b42c28f51ac1250aa3be23a2f713",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c64b808d4571b42c28f51ac1250aa3be23a2f713",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c64b808d4571b42c28f51ac1250aa3be23a2f713",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c64b808d4571b42c28f51ac1250aa3be23a2f713/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "594b207d86a914396f972b4784b6c7ddb4709fdc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/594b207d86a914396f972b4784b6c7ddb4709fdc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/594b207d86a914396f972b4784b6c7ddb4709fdc"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 21,
      "deletions": 16
    },
    "files": [
      {
        "sha": "873f66018d118ccbb6fcc6204b10e0be38400e7b",
        "filename": "depends/config.site.in",
        "status": "modified",
        "additions": 21,
        "deletions": 16,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c64b808d4571b42c28f51ac1250aa3be23a2f713/depends/config.site.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c64b808d4571b42c28f51ac1250aa3be23a2f713/depends/config.site.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.site.in?ref=c64b808d4571b42c28f51ac1250aa3be23a2f713",
        "patch": "@@ -48,32 +48,37 @@ if test x@host_os@ = xmingw32; then\n   fi\n fi\n \n-export PATH=$prefix/native/bin:$PATH\n-export PKG_CONFIG=\"`which pkg-config` --static\"\n+PATH=$prefix/native/bin:$PATH\n+PKG_CONFIG=\"`which pkg-config` --static\"\n+\n+# These two need to remain exported because pkg-config does not see them\n+# otherwise. That means they must be unexported at the end of configure.ac to\n+# avoid ruining the cache. Sigh.\n+\n export PKG_CONFIG_LIBDIR=$prefix/lib/pkgconfig\n export PKG_CONFIG_PATH=$prefix/share/pkgconfig\n \n-export CPPFLAGS=\"-I$prefix/include/ $CPPFLAGS\"\n-export LDFLAGS=\"-L$prefix/lib $LDFLAGS\"\n+CPPFLAGS=\"-I$prefix/include/ $CPPFLAGS\"\n+LDFLAGS=\"-L$prefix/lib $LDFLAGS\"\n \n-export CC=\"@CC@\"\n-export CXX=\"@CXX@\"\n-export OBJC=\"${CC}\"\n-export OBJCXX=\"${CXX}\"\n-export CCACHE=$prefix/native/bin/ccache\n+CC=\"@CC@\"\n+CXX=\"@CXX@\"\n+OBJC=\"${CC}\"\n+OBJCXX=\"${CXX}\"\n+CCACHE=$prefix/native/bin/ccache\n \n if test -n \"@AR@\"; then\n-  export AR=@AR@\n+  AR=@AR@\n   ac_cv_path_ac_pt_AR=${AR}\n fi\n \n if test -n \"@RANLIB@\"; then\n-  export RANLIB=@RANLIB@\n+  RANLIB=@RANLIB@\n   ac_cv_path_ac_pt_RANLIB=${RANLIB}\n fi\n \n if test -n \"@NM@\"; then\n-  export NM=@NM@\n+  NM=@NM@\n   ac_cv_path_ac_pt_NM=${NM}\n fi\n \n@@ -82,14 +87,14 @@ if test -n \"@debug@\"; then\n fi\n \n if test -n \"@CFLAGS@\"; then\n-  export CFLAGS=\"@CFLAGS@ $CFLAGS\"\n+  CFLAGS=\"@CFLAGS@ $CFLAGS\"\n fi\n if test -n \"@CXXFLAGS@\"; then\n-  export CXXFLAGS=\"@CXXFLAGS@ $CXXFLAGS\"\n+  CXXFLAGS=\"@CXXFLAGS@ $CXXFLAGS\"\n fi\n if test -n \"@CPPFLAGS@\"; then\n-  export CPPFLAGS=\"@CPPFLAGS@ $CPPFLAGS\"\n+  CPPFLAGS=\"@CPPFLAGS@ $CPPFLAGS\"\n fi\n if test -n \"@LDFLAGS@\"; then\n-  export LDFLAGS=\"@LDFLAGS@ $LDFLAGS\"\n+  LDFLAGS=\"@LDFLAGS@ $LDFLAGS\"\n fi"
      }
    ]
  },
  {
    "sha": "e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMWFjMGY4NGZhMDA5YjhmYWEzY2UyYTdlMmMzMWIzNWU4M2RmNzIw",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-06T01:01:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:34Z"
      },
      "message": "build: fixup configure to not export anything",
      "tree": {
        "sha": "5edf972f592338f637391c354f01a2c6105f9aba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5edf972f592338f637391c354f01a2c6105f9aba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c64b808d4571b42c28f51ac1250aa3be23a2f713",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c64b808d4571b42c28f51ac1250aa3be23a2f713",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c64b808d4571b42c28f51ac1250aa3be23a2f713"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 18,
      "deletions": 2
    },
    "files": [
      {
        "sha": "4904dd72cacdb0a1de27a766ccdc222b197ee0b1",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
        "patch": "@@ -255,15 +255,13 @@ case $host in\n          qt5_prefix=`$BREW --prefix qt5 2>/dev/null`\n          if test x$openssl_prefix != x; then\n            PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n-           export PKG_CONFIG_PATH\n          fi\n          if test x$bdb_prefix != x; then\n            CPPFLAGS=\"$CPPFLAGS -I$bdb_prefix/include\"\n            LIBS=\"$LIBS -L$bdb_prefix/lib\"\n          fi\n          if test x$qt5_prefix != x; then\n            PKG_CONFIG_PATH=\"$qt5_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n-           export PKG_CONFIG_PATH\n          fi\n        fi\n      else\n@@ -819,8 +817,26 @@ AC_CONFIG_FILES([qa/pull-tester/tests-config.sh],[chmod +x qa/pull-tester/tests-\n dnl boost's m4 checks do something really nasty: they export these vars. As a\n dnl result, they leak into secp256k1's configure and crazy things happen.\n dnl Until this is fixed upstream and we've synced, we'll just un-export them.\n+CPPFLAGS_TEMP=\"$CPPFLAGS\"\n unset CPPFLAGS\n+CPPFLAGS=\"$CPPFLAGS_TEMP\"\n+\n+LDFLAGS_TEMP=\"$LDFLAGS\"\n unset LDFLAGS\n+LDFLAGS=\"$LDFLAGS_TEMP\"\n+\n+LIBS_TEMP=\"$LIBS\"\n+unset LIBS\n+LIBS=\"$LIBS_TEMP\"\n+\n+PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\"\n+unset PKG_CONFIG_PATH\n+PKG_CONFIG_PATH=\"$PKGCONFIG_PATH_TEMP\"\n+\n+PKGCONFIG_LIBDIR_TEMP=\"$PKG_CONFIG_LIBDIR\"\n+unset PKG_CONFIG_LIBDIR\n+PKG_CONFIG_LIBDIR=\"$PKGCONFIG_LIBDIR_TEMP\"\n+\n ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n "
      }
    ]
  },
  {
    "sha": "ee832650daee70048e085f2e558ac4444ab5c061",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTgzMjY1MGRhZWU3MDA0OGUwODVmMmU1NThhYzQ0NDRhYjVjMDYx",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-06T01:56:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:34Z"
      },
      "message": "build: secp256k1 as a subdir, since it's required",
      "tree": {
        "sha": "61214c466589c370bda417f2806933fa551f35f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61214c466589c370bda417f2806933fa551f35f9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee832650daee70048e085f2e558ac4444ab5c061",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee832650daee70048e085f2e558ac4444ab5c061",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee832650daee70048e085f2e558ac4444ab5c061",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee832650daee70048e085f2e558ac4444ab5c061/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e1ac0f84fa009b8faa3ce2a7e2c31b35e83df720"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 7,
      "deletions": 3
    },
    "files": [
      {
        "sha": "076278360a6f0857a54216c7ab124e9a2a45bd44",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee832650daee70048e085f2e558ac4444ab5c061/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee832650daee70048e085f2e558ac4444ab5c061/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ee832650daee70048e085f2e558ac4444ab5c061",
        "patch": "@@ -1,3 +1,4 @@\n+DIST_SUBDIRS = secp256k1\n AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS)\n \n \n@@ -32,7 +33,7 @@ LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n \n $(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n-\t@$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n+\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n \n # Make is not made aware of per-object dependencies to avoid limiting building parallelization\n # But to build the less dependent modules first, we manually select their order here:\n@@ -331,11 +332,11 @@ CLEANFILES = leveldb/libleveldb.a leveldb/libmemenv.a *.gcda *.gcno\n \n DISTCLEANFILES = obj/build.h\n \n-EXTRA_DIST = leveldb secp256k1\n+EXTRA_DIST = leveldb\n \n clean-local:\n \t-$(MAKE) -C leveldb clean\n-\t-$(MAKE) -C secp256k1 clean 2>/dev/null\n+\t-$(MAKE) -C secp256k1 clean\n \trm -f leveldb/*/*.gcno leveldb/helpers/memenv/*.gcno\n \t-rm -f config.h\n "
      },
      {
        "sha": "79509c9a3edc3fae3b2587e567e0751082706d46",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee832650daee70048e085f2e558ac4444ab5c061/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee832650daee70048e085f2e558ac4444ab5c061/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=ee832650daee70048e085f2e558ac4444ab5c061",
        "patch": "@@ -104,6 +104,9 @@ bitcoin_test_check: $(TEST_BINARY) FORCE\n bitcoin_test_clean : FORCE\n \trm -f $(CLEAN_BITCOIN_TEST) $(test_test_bitcoin_OBJECTS) $(TEST_BINARY)\n \n+check-local:\n+\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n+\n %.json.h: %.json\n \t@$(MKDIR_P) $(@D)\n \t@echo \"namespace json_tests{\" > $@"
      }
    ]
  },
  {
    "sha": "25863020bc137e818e02364859049dc874c4b7ae",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTg2MzAyMGJjMTM3ZTgxOGUwMjM2NDg1OTA0OWRjODc0YzRiN2Fl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-06T20:40:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:08:35Z"
      },
      "message": "revert part of 9eda1620b\n\nThis probably would've broken native OSX builds",
      "tree": {
        "sha": "97c25f95588051dcd93411bedcc09b01d7016af1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97c25f95588051dcd93411bedcc09b01d7016af1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25863020bc137e818e02364859049dc874c4b7ae",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25863020bc137e818e02364859049dc874c4b7ae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/25863020bc137e818e02364859049dc874c4b7ae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25863020bc137e818e02364859049dc874c4b7ae/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ee832650daee70048e085f2e558ac4444ab5c061",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee832650daee70048e085f2e558ac4444ab5c061",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ee832650daee70048e085f2e558ac4444ab5c061"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c0489f5be7d64e2351aa1399041db33b6709976b",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25863020bc137e818e02364859049dc874c4b7ae/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25863020bc137e818e02364859049dc874c4b7ae/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=25863020bc137e818e02364859049dc874c4b7ae",
        "patch": "@@ -255,13 +255,15 @@ case $host in\n          qt5_prefix=`$BREW --prefix qt5 2>/dev/null`\n          if test x$openssl_prefix != x; then\n            PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n+           export PKG_CONFIG_PATH\n          fi\n          if test x$bdb_prefix != x; then\n            CPPFLAGS=\"$CPPFLAGS -I$bdb_prefix/include\"\n            LIBS=\"$LIBS -L$bdb_prefix/lib\"\n          fi\n          if test x$qt5_prefix != x; then\n            PKG_CONFIG_PATH=\"$qt5_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n+           export PKG_CONFIG_PATH\n          fi\n        fi\n      else"
      }
    ]
  },
  {
    "sha": "ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYzg2OWVkZTBhNGM1ZGRjMDYxNjBkMWY2NzYzMzBjMDA4ZTViZjVm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-26T08:23:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:29:00Z"
      },
      "message": "Split up crypto/sha2",
      "tree": {
        "sha": "543713018aff75d3538ccd5b54978ce819dbaec7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/543713018aff75d3538ccd5b54978ce819dbaec7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25863020bc137e818e02364859049dc874c4b7ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25863020bc137e818e02364859049dc874c4b7ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25863020bc137e818e02364859049dc874c4b7ae"
      }
    ],
    "stats": {
      "total": 605,
      "additions": 327,
      "deletions": 278
    },
    "files": [
      {
        "sha": "b83dee5e33c54358532e942acc07cbccc973c805",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -194,10 +194,14 @@ libbitcoin_wallet_a_SOURCES = \\\n crypto_libbitcoin_crypto_a_CPPFLAGS = $(BITCOIN_CONFIG_INCLUDES)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/sha1.cpp \\\n-  crypto/sha2.cpp \\\n+  crypto/sha256.cpp \\\n+  crypto/sha512.cpp \\\n+  crypto/hmac_sha512.cpp \\\n   crypto/ripemd160.cpp \\\n   crypto/common.h \\\n-  crypto/sha2.h \\\n+  crypto/sha256.h \\\n+  crypto/sha512.h \\\n+  crypto/hmac_sha512.h \\\n   crypto/sha1.h \\\n   crypto/ripemd160.h\n "
      },
      {
        "sha": "940a93277c0339a0dca9578d5b3d7667f4f1c156",
        "filename": "src/crypto/hmac_sha512.cpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/hmac_sha512.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/hmac_sha512.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha512.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/hmac_sha512.h\"\n+\n+#include <string.h>\n+\n+CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen)\n+{\n+    unsigned char rkey[128];\n+    if (keylen <= 128) {\n+        memcpy(rkey, key, keylen);\n+        memset(rkey + keylen, 0, 128 - keylen);\n+    } else {\n+        CSHA512().Write(key, keylen).Finalize(rkey);\n+        memset(rkey + 64, 0, 64);\n+    }\n+\n+    for (int n = 0; n < 128; n++)\n+        rkey[n] ^= 0x5c;\n+    outer.Write(rkey, 128);\n+\n+    for (int n = 0; n < 128; n++)\n+        rkey[n] ^= 0x5c ^ 0x36;\n+    inner.Write(rkey, 128);\n+}\n+\n+void CHMAC_SHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    unsigned char temp[64];\n+    inner.Finalize(temp);\n+    outer.Write(temp, 64).Finalize(hash);\n+}"
      },
      {
        "sha": "8c65785104a1dd5d446aa29bcc0151701c75c044",
        "filename": "src/crypto/hmac_sha512.h",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/hmac_sha512.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/hmac_sha512.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha512.h?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -0,0 +1,32 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_HMAC_SHA512_H\n+#define BITCOIN_HMAC_SHA512_H\n+\n+#include \"crypto/sha512.h\"\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for HMAC-SHA-512. */\n+class CHMAC_SHA512\n+{\n+private:\n+    CSHA512 outer;\n+    CSHA512 inner;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 64;\n+\n+    CHMAC_SHA512(const unsigned char* key, size_t keylen);\n+    CHMAC_SHA512& Write(const unsigned char* data, size_t len)\n+    {\n+        inner.Write(data, len);\n+        return *this;\n+    }\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+};\n+\n+#endif // BITCOIN_HMAC_SHA512_H"
      },
      {
        "sha": "329c6675ab0618f920a739cd1011720504a6499d",
        "filename": "src/crypto/sha2.h",
        "status": "removed",
        "additions": 0,
        "deletions": 64,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25863020bc137e818e02364859049dc874c4b7ae/src/crypto/sha2.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25863020bc137e818e02364859049dc874c4b7ae/src/crypto/sha2.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha2.h?ref=25863020bc137e818e02364859049dc874c4b7ae",
        "patch": "@@ -1,64 +0,0 @@\n-// Copyright (c) 2014 The Bitcoin developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_CRYPTO_SHA2_H\n-#define BITCOIN_CRYPTO_SHA2_H\n-\n-#include <stdint.h>\n-#include <stdlib.h>\n-\n-/** A hasher class for SHA-256. */\n-class CSHA256\n-{\n-private:\n-    uint32_t s[8];\n-    unsigned char buf[64];\n-    size_t bytes;\n-\n-public:\n-    static const size_t OUTPUT_SIZE = 32;\n-\n-    CSHA256();\n-    CSHA256& Write(const unsigned char* data, size_t len);\n-    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n-    CSHA256& Reset();\n-};\n-\n-/** A hasher class for SHA-512. */\n-class CSHA512\n-{\n-private:\n-    uint64_t s[8];\n-    unsigned char buf[128];\n-    size_t bytes;\n-\n-public:\n-    static const size_t OUTPUT_SIZE = 64;\n-\n-    CSHA512();\n-    CSHA512& Write(const unsigned char* data, size_t len);\n-    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n-    CSHA512& Reset();\n-};\n-\n-/** A hasher class for HMAC-SHA-512. */\n-class CHMAC_SHA512\n-{\n-private:\n-    CSHA512 outer;\n-    CSHA512 inner;\n-\n-public:\n-    static const size_t OUTPUT_SIZE = 64;\n-\n-    CHMAC_SHA512(const unsigned char* key, size_t keylen);\n-    CHMAC_SHA512& Write(const unsigned char* data, size_t len)\n-    {\n-        inner.Write(data, len);\n-        return *this;\n-    }\n-    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n-};\n-\n-#endif // BITCOIN_CRYPTO_SHA2_H"
      },
      {
        "sha": "8410e5930543089ad11aab5a9047560e60ad16d5",
        "filename": "src/crypto/sha256.cpp",
        "status": "added",
        "additions": 189,
        "deletions": 0,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -0,0 +1,189 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/sha256.h\"\n+\n+#include \"crypto/common.h\"\n+\n+#include <string.h>\n+\n+// Internal implementation code.\n+namespace\n+{\n+/// Internal SHA-256 implementation.\n+namespace sha256\n+{\n+uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }\n+uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }\n+uint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }\n+uint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }\n+uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }\n+uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n+\n+/** One round of SHA-256. */\n+void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t& d, uint32_t e, uint32_t f, uint32_t g, uint32_t& h, uint32_t k, uint32_t w)\n+{\n+    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n+    uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n+    d += t1;\n+    h = t1 + t2;\n+}\n+\n+/** Initialize SHA-256 state. */\n+void inline Initialize(uint32_t* s)\n+{\n+    s[0] = 0x6a09e667ul;\n+    s[1] = 0xbb67ae85ul;\n+    s[2] = 0x3c6ef372ul;\n+    s[3] = 0xa54ff53aul;\n+    s[4] = 0x510e527ful;\n+    s[5] = 0x9b05688cul;\n+    s[6] = 0x1f83d9abul;\n+    s[7] = 0x5be0cd19ul;\n+}\n+\n+/** Perform one SHA-256 transformation, processing a 64-byte chunk. */\n+void Transform(uint32_t* s, const unsigned char* chunk)\n+{\n+    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n+    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0));\n+    Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4));\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = ReadBE32(chunk + 8));\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = ReadBE32(chunk + 12));\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = ReadBE32(chunk + 16));\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = ReadBE32(chunk + 20));\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = ReadBE32(chunk + 24));\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = ReadBE32(chunk + 28));\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = ReadBE32(chunk + 32));\n+    Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = ReadBE32(chunk + 36));\n+    Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n+    Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n+    Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n+    Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n+    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n+    Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n+\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1(w0) + w11 + sigma0(w3));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1(w1) + w12 + sigma0(w4));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1(w2) + w13 + sigma0(w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1(w3) + w14 + sigma0(w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1(w4) + w15 + sigma0(w7));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1(w5) + w0 + sigma0(w8));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1(w6) + w1 + sigma0(w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1(w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1(w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1(w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1(w0) + w11 + sigma0(w3));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1(w1) + w12 + sigma0(w4));\n+    Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1(w2) + w13 + sigma0(w5));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1(w3) + w14 + sigma0(w6));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1(w4) + w15 + sigma0(w7));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1(w5) + w0 + sigma0(w8));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1(w6) + w1 + sigma0(w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1(w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1(w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1(w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1(w0) + w11 + sigma0(w3));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1(w1) + w12 + sigma0(w4));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1(w2) + w13 + sigma0(w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1(w3) + w14 + sigma0(w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1(w4) + w15 + sigma0(w7));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1(w5) + w0 + sigma0(w8));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1(w6) + w1 + sigma0(w9));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1(w7) + w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1(w8) + w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1(w9) + w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0));\n+\n+    s[0] += a;\n+    s[1] += b;\n+    s[2] += c;\n+    s[3] += d;\n+    s[4] += e;\n+    s[5] += f;\n+    s[6] += g;\n+    s[7] += h;\n+}\n+\n+} // namespace sha256\n+} // namespace\n+\n+\n+////// SHA-256\n+\n+CSHA256::CSHA256() : bytes(0)\n+{\n+    sha256::Initialize(s);\n+}\n+\n+CSHA256& CSHA256::Write(const unsigned char* data, size_t len)\n+{\n+    const unsigned char* end = data + len;\n+    size_t bufsize = bytes % 64;\n+    if (bufsize && bufsize + len >= 64) {\n+        // Fill the buffer, and process it.\n+        memcpy(buf + bufsize, data, 64 - bufsize);\n+        bytes += 64 - bufsize;\n+        data += 64 - bufsize;\n+        sha256::Transform(s, buf);\n+        bufsize = 0;\n+    }\n+    while (end >= data + 64) {\n+        // Process full chunks directly from the source.\n+        sha256::Transform(s, data);\n+        bytes += 64;\n+        data += 64;\n+    }\n+    if (end > data) {\n+        // Fill the buffer with what remains.\n+        memcpy(buf + bufsize, data, end - data);\n+        bytes += end - data;\n+    }\n+    return *this;\n+}\n+\n+void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    static const unsigned char pad[64] = {0x80};\n+    unsigned char sizedesc[8];\n+    WriteBE64(sizedesc, bytes << 3);\n+    Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n+    Write(sizedesc, 8);\n+    WriteBE32(hash, s[0]);\n+    WriteBE32(hash + 4, s[1]);\n+    WriteBE32(hash + 8, s[2]);\n+    WriteBE32(hash + 12, s[3]);\n+    WriteBE32(hash + 16, s[4]);\n+    WriteBE32(hash + 20, s[5]);\n+    WriteBE32(hash + 24, s[6]);\n+    WriteBE32(hash + 28, s[7]);\n+}\n+\n+CSHA256& CSHA256::Reset()\n+{\n+    bytes = 0;\n+    sha256::Initialize(s);\n+    return *this;\n+}"
      },
      {
        "sha": "a57dce02273c27c201d9880531ff7fe18563b2f3",
        "filename": "src/crypto/sha256.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.h?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SHA256_H\n+#define BITCOIN_SHA256_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for SHA-256. */\n+class CSHA256\n+{\n+private:\n+    uint32_t s[8];\n+    unsigned char buf[64];\n+    size_t bytes;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 32;\n+\n+    CSHA256();\n+    CSHA256& Write(const unsigned char* data, size_t len);\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    CSHA256& Reset();\n+};\n+\n+#endif // BITCOIN_SHA256_H"
      },
      {
        "sha": "22c3103bed1052350ad312ce1a1a5d13703d8899",
        "filename": "src/crypto/sha512.cpp",
        "status": "renamed",
        "additions": 3,
        "deletions": 207,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha512.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha512.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha512.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"crypto/sha2.h\"\n+#include \"crypto/sha512.h\"\n \n #include \"crypto/common.h\"\n \n@@ -11,124 +11,6 @@\n // Internal implementation code.\n namespace\n {\n-/// Internal SHA-256 implementation.\n-namespace sha256\n-{\n-uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }\n-uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }\n-uint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }\n-uint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }\n-uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }\n-uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n-\n-/** One round of SHA-256. */\n-void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t& d, uint32_t e, uint32_t f, uint32_t g, uint32_t& h, uint32_t k, uint32_t w)\n-{\n-    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n-    uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n-    d += t1;\n-    h = t1 + t2;\n-}\n-\n-/** Initialize SHA-256 state. */\n-void inline Initialize(uint32_t* s)\n-{\n-    s[0] = 0x6a09e667ul;\n-    s[1] = 0xbb67ae85ul;\n-    s[2] = 0x3c6ef372ul;\n-    s[3] = 0xa54ff53aul;\n-    s[4] = 0x510e527ful;\n-    s[5] = 0x9b05688cul;\n-    s[6] = 0x1f83d9abul;\n-    s[7] = 0x5be0cd19ul;\n-}\n-\n-/** Perform one SHA-256 transformation, processing a 64-byte chunk. */\n-void Transform(uint32_t* s, const unsigned char* chunk)\n-{\n-    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n-    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n-\n-    Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = ReadBE32(chunk + 0));\n-    Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = ReadBE32(chunk + 4));\n-    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = ReadBE32(chunk + 8));\n-    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = ReadBE32(chunk + 12));\n-    Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = ReadBE32(chunk + 16));\n-    Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = ReadBE32(chunk + 20));\n-    Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = ReadBE32(chunk + 24));\n-    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = ReadBE32(chunk + 28));\n-    Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = ReadBE32(chunk + 32));\n-    Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = ReadBE32(chunk + 36));\n-    Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n-    Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n-    Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n-    Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n-    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n-    Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n-\n-    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1));\n-    Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2));\n-    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1(w0) + w11 + sigma0(w3));\n-    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1(w1) + w12 + sigma0(w4));\n-    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1(w2) + w13 + sigma0(w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1(w3) + w14 + sigma0(w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1(w4) + w15 + sigma0(w7));\n-    Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1(w5) + w0 + sigma0(w8));\n-    Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1(w6) + w1 + sigma0(w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1(w7) + w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1(w8) + w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1(w9) + w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1));\n-    Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2));\n-    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1(w0) + w11 + sigma0(w3));\n-    Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1(w1) + w12 + sigma0(w4));\n-    Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1(w2) + w13 + sigma0(w5));\n-    Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1(w3) + w14 + sigma0(w6));\n-    Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1(w4) + w15 + sigma0(w7));\n-    Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1(w5) + w0 + sigma0(w8));\n-    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1(w6) + w1 + sigma0(w9));\n-    Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1(w7) + w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1(w8) + w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1(w9) + w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0));\n-\n-    Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1));\n-    Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2));\n-    Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1(w0) + w11 + sigma0(w3));\n-    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1(w1) + w12 + sigma0(w4));\n-    Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1(w2) + w13 + sigma0(w5));\n-    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1(w3) + w14 + sigma0(w6));\n-    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1(w4) + w15 + sigma0(w7));\n-    Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1(w5) + w0 + sigma0(w8));\n-    Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1(w6) + w1 + sigma0(w9));\n-    Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1(w7) + w2 + sigma0(w10));\n-    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1(w8) + w3 + sigma0(w11));\n-    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1(w9) + w4 + sigma0(w12));\n-    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));\n-    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0));\n-\n-    s[0] += a;\n-    s[1] += b;\n-    s[2] += c;\n-    s[3] += d;\n-    s[4] += e;\n-    s[5] += f;\n-    s[6] += g;\n-    s[7] += h;\n-}\n-\n-} // namespace sha256\n-\n /// Internal SHA-512 implementation.\n namespace sha512\n {\n@@ -249,8 +131,8 @@ void Transform(uint64_t* s, const unsigned char* chunk)\n     Round(f, g, h, a, b, c, d, e, 0x431d67c49c100d4cull, w11 += sigma1(w9) + w4 + sigma0(w12));\n     Round(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6ull, w12 += sigma1(w10) + w5 + sigma0(w13));\n     Round(d, e, f, g, h, a, b, c, 0x597f299cfc657e2aull, w13 += sigma1(w11) + w6 + sigma0(w14));\n-    Round(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faecull, w14 += sigma1(w12) + w7 + sigma0(w15));\n-    Round(b, c, d, e, f, g, h, a, 0x6c44198c4a475817ull, w15 += sigma1(w13) + w8 + sigma0(w0));\n+    Round(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faecull, w14 + sigma1(w12) + w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x6c44198c4a475817ull, w15 + sigma1(w13) + w8 + sigma0(w0));\n \n     s[0] += a;\n     s[1] += b;\n@@ -267,63 +149,6 @@ void Transform(uint64_t* s, const unsigned char* chunk)\n } // namespace\n \n \n-////// SHA-256\n-\n-CSHA256::CSHA256() : bytes(0)\n-{\n-    sha256::Initialize(s);\n-}\n-\n-CSHA256& CSHA256::Write(const unsigned char* data, size_t len)\n-{\n-    const unsigned char* end = data + len;\n-    size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n-        // Fill the buffer, and process it.\n-        memcpy(buf + bufsize, data, 64 - bufsize);\n-        bytes += 64 - bufsize;\n-        data += 64 - bufsize;\n-        sha256::Transform(s, buf);\n-        bufsize = 0;\n-    }\n-    while (end >= data + 64) {\n-        // Process full chunks directly from the source.\n-        sha256::Transform(s, data);\n-        bytes += 64;\n-        data += 64;\n-    }\n-    if (end > data) {\n-        // Fill the buffer with what remains.\n-        memcpy(buf + bufsize, data, end - data);\n-        bytes += end - data;\n-    }\n-    return *this;\n-}\n-\n-void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n-    static const unsigned char pad[64] = {0x80};\n-    unsigned char sizedesc[8];\n-    WriteBE64(sizedesc, bytes << 3);\n-    Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n-    Write(sizedesc, 8);\n-    WriteBE32(hash, s[0]);\n-    WriteBE32(hash + 4, s[1]);\n-    WriteBE32(hash + 8, s[2]);\n-    WriteBE32(hash + 12, s[3]);\n-    WriteBE32(hash + 16, s[4]);\n-    WriteBE32(hash + 20, s[5]);\n-    WriteBE32(hash + 24, s[6]);\n-    WriteBE32(hash + 28, s[7]);\n-}\n-\n-CSHA256& CSHA256::Reset()\n-{\n-    bytes = 0;\n-    sha256::Initialize(s);\n-    return *this;\n-}\n-\n ////// SHA-512\n \n CSHA512::CSHA512() : bytes(0)\n@@ -380,32 +205,3 @@ CSHA512& CSHA512::Reset()\n     sha512::Initialize(s);\n     return *this;\n }\n-\n-////// HMAC-SHA-512\n-\n-CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen)\n-{\n-    unsigned char rkey[128];\n-    if (keylen <= 128) {\n-        memcpy(rkey, key, keylen);\n-        memset(rkey + keylen, 0, 128 - keylen);\n-    } else {\n-        CSHA512().Write(key, keylen).Finalize(rkey);\n-        memset(rkey + 64, 0, 64);\n-    }\n-\n-    for (int n = 0; n < 128; n++)\n-        rkey[n] ^= 0x5c;\n-    outer.Write(rkey, 128);\n-\n-    for (int n = 0; n < 128; n++)\n-        rkey[n] ^= 0x5c ^ 0x36;\n-    inner.Write(rkey, 128);\n-}\n-\n-void CHMAC_SHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n-    unsigned char temp[64];\n-    inner.Finalize(temp);\n-    outer.Write(temp, 64).Finalize(hash);\n-}",
        "previous_filename": "src/crypto/sha2.cpp"
      },
      {
        "sha": "4d1345e50bbfe1d70a2e98e6f222fbeba2ab25a2",
        "filename": "src/crypto/sha512.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha512.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/crypto/sha512.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha512.h?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SHA512_H\n+#define BITCOIN_SHA512_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for SHA-512. */\n+class CSHA512\n+{\n+private:\n+    uint64_t s[8];\n+    unsigned char buf[128];\n+    size_t bytes;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 64;\n+\n+    CSHA512();\n+    CSHA512& Write(const unsigned char* data, size_t len);\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    CSHA512& Reset();\n+};\n+\n+#endif // BITCOIN_SHA512_H"
      },
      {
        "sha": "9eda1722e44e6ef66bd05251ea12222d099c7dd1",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -1,4 +1,5 @@\n #include \"hash.h\"\n+#include \"crypto/hmac_sha512.h\"\n \n inline uint32_t ROTL32(uint32_t x, int8_t r)\n {"
      },
      {
        "sha": "5a34cdc5c3c89be91134dcc7f6474d5a456698f8",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -7,7 +7,7 @@\n #define BITCOIN_HASH_H\n \n #include \"crypto/ripemd160.h\"\n-#include \"crypto/sha2.h\"\n+#include \"crypto/sha256.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"version.h\""
      },
      {
        "sha": "9b3cf8f01911de9c972ffd4e175f608f8fea882c",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -4,7 +4,7 @@\n \n #include \"key.h\"\n \n-#include \"crypto/sha2.h\"\n+#include \"crypto/hmac_sha512.h\"\n #include \"eccryptoverify.h\"\n #include \"pubkey.h\"\n #include \"random.h\""
      },
      {
        "sha": "91979ff4dc87071e7f509872130ae14bfcd562e9",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -4,7 +4,6 @@\n \n #include \"pubkey.h\"\n \n-#include \"crypto/sha2.h\"\n #include \"eccryptoverify.h\"\n \n #ifdef USE_SECP256K1"
      },
      {
        "sha": "d777316e9b76877342c421b5d7683f25cd418ad8",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -8,7 +8,7 @@\n #include \"core/transaction.h\"\n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n-#include \"crypto/sha2.h\"\n+#include \"crypto/sha256.h\"\n #include \"eccryptoverify.h\"\n #include \"pubkey.h\"\n #include \"script/script.h\""
      },
      {
        "sha": "b3783133d56aac66abf4df60af26804866013f6b",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac869ede0a4c5ddc06160d1f676330c008e5bf5f/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "patch": "@@ -4,7 +4,9 @@\n \n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n-#include \"crypto/sha2.h\"\n+#include \"crypto/sha256.h\"\n+#include \"crypto/sha512.h\"\n+#include \"crypto/hmac_sha512.h\"\n #include \"random.h\"\n #include \"utilstrencodings.h\"\n "
      }
    ]
  },
  {
    "sha": "db040b6cba9554f5d146b1b3bf9166a939aa78b5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjA0MGI2Y2JhOTU1NGY1ZDE0NmIxYjNiZjkxNjZhOTM5YWE3OGI1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-26T08:38:13Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:29:00Z"
      },
      "message": "Add HMAC-SHA256",
      "tree": {
        "sha": "6bd397d60b52d7a4c5c96a45e673ee2f008e234a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6bd397d60b52d7a4c5c96a45e673ee2f008e234a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db040b6cba9554f5d146b1b3bf9166a939aa78b5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db040b6cba9554f5d146b1b3bf9166a939aa78b5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db040b6cba9554f5d146b1b3bf9166a939aa78b5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db040b6cba9554f5d146b1b3bf9166a939aa78b5/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac869ede0a4c5ddc06160d1f676330c008e5bf5f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac869ede0a4c5ddc06160d1f676330c008e5bf5f"
      }
    ],
    "stats": {
      "total": 111,
      "additions": 111,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c84f053fce57d7157a1ea85a038126087a9a0374",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=db040b6cba9554f5d146b1b3bf9166a939aa78b5",
        "patch": "@@ -196,11 +196,13 @@ crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/sha1.cpp \\\n   crypto/sha256.cpp \\\n   crypto/sha512.cpp \\\n+  crypto/hmac_sha256.cpp \\\n   crypto/hmac_sha512.cpp \\\n   crypto/ripemd160.cpp \\\n   crypto/common.h \\\n   crypto/sha256.h \\\n   crypto/sha512.h \\\n+  crypto/hmac_sha256.h \\\n   crypto/hmac_sha512.h \\\n   crypto/sha1.h \\\n   crypto/ripemd160.h"
      },
      {
        "sha": "435896538bf7ab344a88e244afe548571412b4d9",
        "filename": "src/crypto/hmac_sha256.cpp",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/crypto/hmac_sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/crypto/hmac_sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha256.cpp?ref=db040b6cba9554f5d146b1b3bf9166a939aa78b5",
        "patch": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/hmac_sha256.h\"\n+\n+#include <string.h>\n+\n+CHMAC_SHA256::CHMAC_SHA256(const unsigned char* key, size_t keylen)\n+{\n+    unsigned char rkey[64];\n+    if (keylen <= 64) {\n+        memcpy(rkey, key, keylen);\n+        memset(rkey + keylen, 0, 64 - keylen);\n+    } else {\n+        CSHA256().Write(key, keylen).Finalize(rkey);\n+        memset(rkey + 32, 0, 32);\n+    }\n+\n+    for (int n = 0; n < 64; n++)\n+        rkey[n] ^= 0x5c;\n+    outer.Write(rkey, 64);\n+\n+    for (int n = 0; n < 64; n++)\n+        rkey[n] ^= 0x5c ^ 0x36;\n+    inner.Write(rkey, 64);\n+}\n+\n+void CHMAC_SHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n+{\n+    unsigned char temp[32];\n+    inner.Finalize(temp);\n+    outer.Write(temp, 32).Finalize(hash);\n+}"
      },
      {
        "sha": "4ceac709444a1d22e5b8156c4ca413c7d439fd5f",
        "filename": "src/crypto/hmac_sha256.h",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/crypto/hmac_sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/crypto/hmac_sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha256.h?ref=db040b6cba9554f5d146b1b3bf9166a939aa78b5",
        "patch": "@@ -0,0 +1,32 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_HMAC_SHA256_H\n+#define BITCOIN_HMAC_SHA256_H\n+\n+#include \"crypto/sha256.h\"\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for HMAC-SHA-512. */\n+class CHMAC_SHA256\n+{\n+private:\n+    CSHA256 outer;\n+    CSHA256 inner;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 32;\n+\n+    CHMAC_SHA256(const unsigned char* key, size_t keylen);\n+    CHMAC_SHA256& Write(const unsigned char* data, size_t len)\n+    {\n+        inner.Write(data, len);\n+        return *this;\n+    }\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+};\n+\n+#endif // BITCOIN_SHA256_H"
      },
      {
        "sha": "466b38fca96e12a1d335ee750b12b9f10c72fb8e",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db040b6cba9554f5d146b1b3bf9166a939aa78b5/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=db040b6cba9554f5d146b1b3bf9166a939aa78b5",
        "patch": "@@ -6,6 +6,7 @@\n #include \"crypto/sha1.h\"\n #include \"crypto/sha256.h\"\n #include \"crypto/sha512.h\"\n+#include \"crypto/hmac_sha256.h\"\n #include \"crypto/hmac_sha512.h\"\n #include \"random.h\"\n #include \"utilstrencodings.h\"\n@@ -50,6 +51,11 @@ void TestSHA256(const std::string &in, const std::string &hexout) { TestVector(C\n void TestSHA512(const std::string &in, const std::string &hexout) { TestVector(CSHA512(), in, ParseHex(hexout));}\n void TestRIPEMD160(const std::string &in, const std::string &hexout) { TestVector(CRIPEMD160(), in, ParseHex(hexout));}\n \n+void TestHMACSHA256(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    TestVector(CHMAC_SHA256(&key[0], key.size()), ParseHex(hexin), ParseHex(hexout));\n+}\n+\n void TestHMACSHA512(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     TestVector(CHMAC_SHA512(&key[0], key.size()), ParseHex(hexin), ParseHex(hexout));\n@@ -160,6 +166,43 @@ BOOST_AUTO_TEST_CASE(sha512_testvectors) {\n                \"37de8c3ef5459d76a52cedc02dc499a3c9ed9dedbfb3281afd9653b8a112fafc\");\n }\n \n+BOOST_AUTO_TEST_CASE(hmac_sha256_testvectors) {\n+    // test cases 1, 2, 3, 4, 6 and 7 of RFC 4231\n+    TestHMACSHA256(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                   \"4869205468657265\",\n+                   \"b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7\");\n+    TestHMACSHA256(\"4a656665\",\n+                   \"7768617420646f2079612077616e7420666f72206e6f7468696e673f\",\n+                   \"5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843\");\n+    TestHMACSHA256(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n+                   \"dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\"\n+                   \"dddddddddddddddddddddddddddddddddddd\",\n+                   \"773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe\");\n+    TestHMACSHA256(\"0102030405060708090a0b0c0d0e0f10111213141516171819\",\n+                   \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n+                   \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\",\n+                   \"82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b\");\n+    TestHMACSHA256(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaa\",\n+                   \"54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a\"\n+                   \"65204b6579202d2048617368204b6579204669727374\",\n+                   \"60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54\");\n+    TestHMACSHA256(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaa\",\n+                   \"5468697320697320612074657374207573696e672061206c6172676572207468\"\n+                   \"616e20626c6f636b2d73697a65206b657920616e642061206c61726765722074\"\n+                   \"68616e20626c6f636b2d73697a6520646174612e20546865206b6579206e6565\"\n+                   \"647320746f20626520686173686564206265666f7265206265696e6720757365\"\n+                   \"642062792074686520484d414320616c676f726974686d2e\",\n+                   \"9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2\");\n+}\n+\n BOOST_AUTO_TEST_CASE(hmac_sha512_testvectors) {\n     // test cases 1, 2, 3, 4, 6 and 7 of RFC 4231\n     TestHMACSHA512(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\","
      }
    ]
  },
  {
    "sha": "9031be743fb4efde18001e44a3dc8e194688e04c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDMxYmU3NDNmYjRlZmRlMTgwMDFlNDRhM2RjOGUxOTQ2ODhlMDRj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-10-26T09:28:22Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:29:01Z"
      },
      "message": "Add the RFC6979 PRNG",
      "tree": {
        "sha": "b119b10a6ed19a5457cd3339a20ccd116680c153",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b119b10a6ed19a5457cd3339a20ccd116680c153"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9031be743fb4efde18001e44a3dc8e194688e04c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9031be743fb4efde18001e44a3dc8e194688e04c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9031be743fb4efde18001e44a3dc8e194688e04c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9031be743fb4efde18001e44a3dc8e194688e04c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db040b6cba9554f5d146b1b3bf9166a939aa78b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db040b6cba9554f5d146b1b3bf9166a939aa78b5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db040b6cba9554f5d146b1b3bf9166a939aa78b5"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 121,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9f441e84105972e5af56f2d035aceb3e6d5f88d7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9031be743fb4efde18001e44a3dc8e194688e04c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9031be743fb4efde18001e44a3dc8e194688e04c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9031be743fb4efde18001e44a3dc8e194688e04c",
        "patch": "@@ -197,12 +197,14 @@ crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/sha256.cpp \\\n   crypto/sha512.cpp \\\n   crypto/hmac_sha256.cpp \\\n+  crypto/rfc6979_hmac_sha256.cpp \\\n   crypto/hmac_sha512.cpp \\\n   crypto/ripemd160.cpp \\\n   crypto/common.h \\\n   crypto/sha256.h \\\n   crypto/sha512.h \\\n   crypto/hmac_sha256.h \\\n+  crypto/rfc6979_hmac_sha256.h \\\n   crypto/hmac_sha512.h \\\n   crypto/sha1.h \\\n   crypto/ripemd160.h"
      },
      {
        "sha": "3f935abfea3fecec9f39870765d4e13c6340436e",
        "filename": "src/crypto/rfc6979_hmac_sha256.cpp",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9031be743fb4efde18001e44a3dc8e194688e04c/src/crypto/rfc6979_hmac_sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9031be743fb4efde18001e44a3dc8e194688e04c/src/crypto/rfc6979_hmac_sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/rfc6979_hmac_sha256.cpp?ref=9031be743fb4efde18001e44a3dc8e194688e04c",
        "patch": "@@ -0,0 +1,47 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/rfc6979_hmac_sha256.h\"\n+\n+#include <string.h>\n+\n+#include <algorithm>\n+\n+static const unsigned char zero[1] = {0x00};\n+static const unsigned char one[1] = {0x01};\n+\n+RFC6979_HMAC_SHA256::RFC6979_HMAC_SHA256(const unsigned char* key, size_t keylen, const unsigned char* msg, size_t msglen) : retry(false)\n+{\n+    memset(V, 0x01, sizeof(V));\n+    memset(K, 0x00, sizeof(K));\n+\n+    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Write(zero, sizeof(zero)).Write(key, keylen).Write(msg, msglen).Finalize(K);\n+    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n+    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Write(one, sizeof(one)).Write(key, keylen).Write(msg, msglen).Finalize(K);\n+    CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n+}\n+\n+RFC6979_HMAC_SHA256::~RFC6979_HMAC_SHA256()\n+{\n+    memset(V, 0x01, sizeof(V));\n+    memset(K, 0x00, sizeof(K));\n+}\n+\n+void RFC6979_HMAC_SHA256::Generate(unsigned char* output, size_t outputlen)\n+{\n+    if (retry) {\n+        CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Write(zero, sizeof(zero)).Finalize(K);\n+        CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n+    }\n+\n+    while (outputlen > 0) {\n+        CHMAC_SHA256(K, sizeof(K)).Write(V, sizeof(V)).Finalize(V);\n+        size_t len = std::min(outputlen, sizeof(V));\n+        memcpy(output, V, len);\n+        output += len;\n+        outputlen -= len;\n+    }\n+\n+    retry = true;\n+}"
      },
      {
        "sha": "e67ddcf8fe570a0fa9cb3b2626dd05164291bc28",
        "filename": "src/crypto/rfc6979_hmac_sha256.h",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9031be743fb4efde18001e44a3dc8e194688e04c/src/crypto/rfc6979_hmac_sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9031be743fb4efde18001e44a3dc8e194688e04c/src/crypto/rfc6979_hmac_sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/rfc6979_hmac_sha256.h?ref=9031be743fb4efde18001e44a3dc8e194688e04c",
        "patch": "@@ -0,0 +1,36 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RFC6979_HMAC_SHA256_H\n+#define BITCOIN_RFC6979_HMAC_SHA256_H\n+\n+#include \"crypto/hmac_sha256.h\"\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** The RFC 6979 PRNG using HMAC-SHA256. */\n+class RFC6979_HMAC_SHA256\n+{\n+private:\n+    unsigned char V[CHMAC_SHA256::OUTPUT_SIZE];\n+    unsigned char K[CHMAC_SHA256::OUTPUT_SIZE];\n+    bool retry;\n+\n+public:\n+    /**\n+     * Construct a new RFC6979 PRNG, using the given key and message.\n+     * The message is assumed to be already hashed.\n+     */\n+    RFC6979_HMAC_SHA256(const unsigned char* key, size_t keylen, const unsigned char* msg, size_t msglen);\n+\n+    /**\n+     * Generate a byte array.\n+     */\n+    void Generate(unsigned char* output, size_t outputlen);\n+\n+    ~RFC6979_HMAC_SHA256();\n+};\n+\n+#endif // BITCOIN_RFC6979_HMAC_SHA256_H"
      },
      {
        "sha": "26708f5071a37b8dacb1568e137ab725ab6f1312",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9031be743fb4efde18001e44a3dc8e194688e04c/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9031be743fb4efde18001e44a3dc8e194688e04c/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=9031be743fb4efde18001e44a3dc8e194688e04c",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"crypto/rfc6979_hmac_sha256.h\"\n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n #include \"crypto/sha256.h\"\n@@ -13,6 +14,7 @@\n \n #include <vector>\n \n+#include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n \n BOOST_AUTO_TEST_SUITE(crypto_tests)\n@@ -246,4 +248,38 @@ BOOST_AUTO_TEST_CASE(hmac_sha512_testvectors) {\n                    \"b6022cac3c4982b10d5eeb55c3e4de15134676fb6de0446065c97440fa8c6a58\");\n }\n \n+void TestRFC6979(const std::string& hexkey, const std::string& hexmsg, const std::vector<std::string>& hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    std::vector<unsigned char> msg = ParseHex(hexmsg);\n+    RFC6979_HMAC_SHA256 rng(&key[0], key.size(), &msg[0], msg.size());\n+\n+    for (unsigned int i = 0; i < hexout.size(); i++) {\n+        std::vector<unsigned char> out = ParseHex(hexout[i]);\n+        std::vector<unsigned char> gen;\n+        gen.resize(out.size());\n+        rng.Generate(&gen[0], gen.size());\n+        BOOST_CHECK(out == gen);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(rfc6979_hmac_sha256)\n+{\n+    TestRFC6979(\n+        \"0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f00\",\n+        \"4bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a\",\n+        boost::assign::list_of\n+            (\"4fe29525b2086809159acdf0506efb86b0ec932c7ba44256ab321e421e67e9fb\")\n+            (\"2bf0fff1d3c378a22dc5de1d856522325c65b504491a0cbd01cb8f3aa67ffd4a\")\n+            (\"f528b410cb541f77000d7afb6c5b53c5c471eab43e466d9ac5190c39c82fd82e\"));\n+\n+    TestRFC6979(\n+        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n+        \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n+        boost::assign::list_of\n+            (\"9c236c165b82ae0cd590659e100b6bab3036e7ba8b06749baf6981e16f1a2b95\")\n+            (\"df471061625bc0ea14b682feee2c9c02f235da04204c1d62a1536c6e17aed7a9\")\n+            (\"7597887cbd76321f32e30440679a22cf7f8d9d2eac390e581fea091ce202ba94\"));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "b307558319d9d19ad496305165bc250a7a345c6a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMzA3NTU4MzE5ZDlkMTlhZDQ5NjMwNTE2NWJjMjUwYTdhMzQ1YzZh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-06T14:54:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-10T13:30:02Z"
      },
      "message": "Deterministic signing",
      "tree": {
        "sha": "8c2e2951276c81dc50ca7a804262c093882d9ad7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c2e2951276c81dc50ca7a804262c093882d9ad7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b307558319d9d19ad496305165bc250a7a345c6a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b307558319d9d19ad496305165bc250a7a345c6a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b307558319d9d19ad496305165bc250a7a345c6a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b307558319d9d19ad496305165bc250a7a345c6a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9031be743fb4efde18001e44a3dc8e194688e04c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9031be743fb4efde18001e44a3dc8e194688e04c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9031be743fb4efde18001e44a3dc8e194688e04c"
      }
    ],
    "stats": {
      "total": 135,
      "additions": 113,
      "deletions": 22
    },
    "files": [
      {
        "sha": "64ad0be077d058a0161f1d5048b089d33b3e7119",
        "filename": "src/ecwrapper.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 7,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b307558319d9d19ad496305165bc250a7a345c6a/src/ecwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b307558319d9d19ad496305165bc250a7a345c6a/src/ecwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.cpp?ref=b307558319d9d19ad496305165bc250a7a345c6a",
        "patch": "@@ -193,13 +193,44 @@ bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size) {\n     return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n }\n \n-bool CECKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) {\n-    vchSig.clear();\n-    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-    if (sig == NULL)\n+bool CECKey::SignSetup(const uint256& k, BIGNUM* kinv, BIGNUM* r, BN_CTX *ctx) {\n+    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n+    BN_CTX_start(ctx);\n+    BIGNUM *order = BN_CTX_get(ctx);\n+    EC_GROUP_get_order(group, order, ctx);\n+    BIGNUM *knum = BN_CTX_get(ctx);\n+    int ret = (BN_bin2bn((unsigned char*)&k, 32, knum) != NULL);\n+    assert(ret);\n+    if (BN_cmp(knum, order) >= 0 || BN_is_zero(knum)) {\n+        BN_CTX_end(ctx);\n         return false;\n+    }\n+    ret = (BN_mod_inverse(kinv, knum, order, ctx) != NULL);\n+    assert(ret);\n+    EC_POINT* p = EC_POINT_new(group);\n+    assert(p != NULL);\n+    ret = EC_POINT_mul(group, p, knum, NULL, NULL, ctx);\n+    assert(ret);\n+    ret = EC_POINT_get_affine_coordinates_GFp(group, p, r, NULL, ctx);\n+    assert(ret);\n+    EC_POINT_free(p);\n+    BN_CTX_end(ctx);\n+    return true;\n+}\n+\n+bool CECKey::Sign(const uint256 &hash, const uint256 &nonce, std::vector<unsigned char>& vchSig) {\n     BN_CTX *ctx = BN_CTX_new();\n     BN_CTX_start(ctx);\n+    BIGNUM* kinv = BN_CTX_get(ctx);\n+    BIGNUM* r = BN_CTX_get(ctx);\n+    if (!SignSetup(nonce, kinv, r, ctx)) {\n+        BN_CTX_end(ctx);\n+        BN_CTX_free(ctx);\n+        return false;\n+    }\n+    vchSig.clear();\n+    ECDSA_SIG *sig = ECDSA_do_sign_ex((unsigned char*)&hash, sizeof(hash), kinv, r, pkey);\n+    assert(sig != NULL);\n     const EC_GROUP *group = EC_KEY_get0_group(pkey);\n     BIGNUM *order = BN_CTX_get(ctx);\n     BIGNUM *halforder = BN_CTX_get(ctx);\n@@ -227,11 +258,21 @@ bool CECKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSi\n     return true;\n }\n \n-bool CECKey::SignCompact(const uint256 &hash, unsigned char *p64, int &rec) {\n+bool CECKey::SignCompact(const uint256 &hash, const uint256 &nonce, unsigned char *p64, int &rec) {\n     bool fOk = false;\n-    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n-    if (sig==NULL)\n+    BN_CTX *ctx = BN_CTX_new();\n+    BN_CTX_start(ctx);\n+    BIGNUM* kinv = BN_CTX_get(ctx);\n+    BIGNUM* r = BN_CTX_get(ctx);\n+    if (!SignSetup(nonce, kinv, r, ctx)) {\n+        BN_CTX_end(ctx);\n+        BN_CTX_free(ctx);\n         return false;\n+    }\n+    ECDSA_SIG *sig = ECDSA_do_sign_ex((unsigned char*)&hash, sizeof(hash), kinv, r, pkey);\n+    assert(sig != NULL);\n+    BN_CTX_end(ctx);\n+    BN_CTX_free(ctx);\n     memset(p64, 0, 64);\n     int nBitsR = BN_num_bits(sig->r);\n     int nBitsS = BN_num_bits(sig->s);"
      },
      {
        "sha": "ba93ebfeb61cda75e12075e6968d9271ec8c5232",
        "filename": "src/ecwrapper.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b307558319d9d19ad496305165bc250a7a345c6a/src/ecwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b307558319d9d19ad496305165bc250a7a345c6a/src/ecwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.h?ref=b307558319d9d19ad496305165bc250a7a345c6a",
        "patch": "@@ -8,6 +8,7 @@\n #include <cstddef>\n #include <vector>\n \n+#include <openssl/bn.h>\n #include <openssl/ec.h>\n \n class uint256;\n@@ -17,6 +18,8 @@ class CECKey {\n private:\n     EC_KEY *pkey;\n \n+    bool SignSetup(const uint256& k, BIGNUM* kinv, BIGNUM* r, BN_CTX *ctx);\n+\n public:\n     CECKey();\n     ~CECKey();\n@@ -28,9 +31,9 @@ class CECKey {\n     bool SetPrivKey(const unsigned char* privkey, size_t size, bool fSkipCheck=false);\n     void GetPubKey(std::vector<unsigned char>& pubkey, bool fCompressed);\n     bool SetPubKey(const unsigned char* pubkey, size_t size);\n-    bool Sign(const uint256 &hash, std::vector<unsigned char>& vchSig);\n+    bool Sign(const uint256 &hash, const uint256 &nonce, std::vector<unsigned char>& vchSig);\n     bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n-    bool SignCompact(const uint256 &hash, unsigned char *p64, int &rec);\n+    bool SignCompact(const uint256 &hash, const uint256 &nonce, unsigned char *p64, int &rec);\n \n     // reconstruct public key from a compact signature\n     // This is only slightly more CPU intensive than just verifying it."
      },
      {
        "sha": "3589f525e421730755e2b53b50bd3efec8840064",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 10,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b307558319d9d19ad496305165bc250a7a345c6a/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b307558319d9d19ad496305165bc250a7a345c6a/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=b307558319d9d19ad496305165bc250a7a345c6a",
        "patch": "@@ -5,6 +5,7 @@\n #include \"key.h\"\n \n #include \"crypto/hmac_sha512.h\"\n+#include \"crypto/rfc6979_hmac_sha256.h\"\n #include \"eccryptoverify.h\"\n #include \"pubkey.h\"\n #include \"random.h\"\n@@ -71,18 +72,28 @@ CPubKey CKey::GetPubKey() const {\n     return result;\n }\n \n-bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n+bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_t iter) const {\n     if (!fValid)\n         return false;\n-    vchSig.resize(72);\n-    int nSigLen = 72;\n-    CKey nonce;\n+    RFC6979_HMAC_SHA256 prng(begin(), 32, (unsigned char*)&hash, 32);\n     do {\n-        nonce.MakeNewKey(true);\n-        if (secp256k1_ecdsa_sign((const unsigned char*)&hash, 32, (unsigned char*)&vchSig[0], &nSigLen, begin(), nonce.begin()))\n+        uint256 nonce;\n+        prng.Generate((unsigned char*)&nonce, 32);\n+        nonce += iter;\n+#ifdef USE_SECP256K1\n+        vchSig.resize(72);\n+        int nSigLen = 72;\n+        int ret = secp256k1_ecdsa_sign((const unsigned char*)&hash, 32, (unsigned char*)&vchSig[0], &nSigLen, begin(), (unsigned char*)&nonce);\n+        vchSig.resize(nSigLen);\n+#else\n+        CECKey key;\n+        key.SetSecretBytes(vch);\n+        int ret = key.Sign(hash, nonce, vchSig);\n+#endif\n+        nonce = 0;\n+        if (ret)\n             break;\n     } while(true);\n-    vchSig.resize(nSigLen);\n     return true;\n }\n \n@@ -91,10 +102,19 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n         return false;\n     vchSig.resize(65);\n     int rec = -1;\n-    CKey nonce;\n+    RFC6979_HMAC_SHA256 prng(begin(), 32, (unsigned char*)&hash, 32);\n     do {\n-        nonce.MakeNewKey(true);\n-        if (secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, 32, &vchSig[1], begin(), nonce.begin(), &rec))\n+        uint256 nonce;\n+        prng.Generate((unsigned char*)&nonce, 32);\n+#ifdef USE_SECP256K1\n+        int ret = secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, 32, &vchSig[1], begin(), (unsigned char*)&nonce, &rec);\n+#else\n+        CECKey key;\n+        key.SetSecretBytes(vch);\n+        int ret = key.SignCompact(hash, nonce, &vchSig[1], rec);\n+#endif\n+        nonce = 0;\n+        if (ret)\n             break;\n     } while(true);\n     assert(rec != -1);"
      },
      {
        "sha": "19dbb8c21baae3654c413bfa15721e6c55226708",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b307558319d9d19ad496305165bc250a7a345c6a/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b307558319d9d19ad496305165bc250a7a345c6a/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=b307558319d9d19ad496305165bc250a7a345c6a",
        "patch": "@@ -121,8 +121,11 @@ class CKey\n      */\n     CPubKey GetPubKey() const;\n \n-    //! Create a DER-serialized signature.\n-    bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig) const;\n+    /**\n+     * Create a DER-serialized signature.\n+     * The iter parameter tweaks the determinsitic nonce, and is only for testing.\n+     */\n+    bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig, uint32_t iter = 0) const;\n \n     /**\n      * Create a compact signature (65 bytes), which allows reconstructing the used public key."
      },
      {
        "sha": "47089368379d2945f30d9d29127f93ad955a7b6d",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b307558319d9d19ad496305165bc250a7a345c6a/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b307558319d9d19ad496305165bc250a7a345c6a/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=b307558319d9d19ad496305165bc250a7a345c6a",
        "patch": "@@ -8,6 +8,7 @@\n #include \"script/script.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n \n #include <string>\n #include <vector>\n@@ -142,6 +143,28 @@ BOOST_AUTO_TEST_CASE(key_test1)\n         BOOST_CHECK(rkey1C == pubkey1C);\n         BOOST_CHECK(rkey2C == pubkey2C);\n     }\n+\n+    // test deterministic signing\n+\n+    std::vector<unsigned char> detsig, detsigc;\n+    string strMsg = \"Very deterministic message\";\n+    uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());\n+    BOOST_CHECK(key1.Sign(hashMsg, detsig));\n+    BOOST_CHECK(key1C.Sign(hashMsg, detsigc));\n+    BOOST_CHECK(detsig == detsigc);\n+    BOOST_CHECK(detsig == ParseHex(\"304402205dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d022014ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n+    BOOST_CHECK(key2.Sign(hashMsg, detsig));\n+    BOOST_CHECK(key2C.Sign(hashMsg, detsigc));\n+    BOOST_CHECK(detsig == detsigc);\n+    BOOST_CHECK(detsig == ParseHex(\"3044022052d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd5022061d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n+    BOOST_CHECK(key1.SignCompact(hashMsg, detsig));\n+    BOOST_CHECK(key1C.SignCompact(hashMsg, detsigc));\n+    BOOST_CHECK(detsig == ParseHex(\"1c5dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d14ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n+    BOOST_CHECK(detsigc == ParseHex(\"205dbbddda71772d95ce91cd2d14b592cfbc1dd0aabd6a394b6c2d377bbe59d31d14ddda21494a4e221f0824f0b8b924c43fa43c0ad57dccdaa11f81a6bd4582f6\"));\n+    BOOST_CHECK(key2.SignCompact(hashMsg, detsig));\n+    BOOST_CHECK(key2C.SignCompact(hashMsg, detsigc));\n+    BOOST_CHECK(detsig == ParseHex(\"1c52d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd561d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n+    BOOST_CHECK(detsigc == ParseHex(\"2052d8a32079c11e79db95af63bb9600c5b04f21a9ca33dc129c2bfa8ac9dc1cd561d8ae5e0f6c1a16bde3719c64c2fd70e404b6428ab9a69566962e8771b5944d\"));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c9dce6b3960793b1e276268f9207017faaf912ae",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b307558319d9d19ad496305165bc250a7a345c6a/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b307558319d9d19ad496305165bc250a7a345c6a/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=b307558319d9d19ad496305165bc250a7a345c6a",
        "patch": "@@ -234,8 +234,9 @@ class TestBuilder\n     {\n         uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType);\n         std::vector<unsigned char> vchSig, r, s;\n+        uint32_t iter = 0;\n         do {\n-            key.Sign(hash, vchSig);\n+            key.Sign(hash, vchSig, iter++);\n             if ((lenS == 33) != (vchSig[5 + vchSig[3]] == 33)) {\n                 NegateSignatureS(vchSig);\n             }"
      }
    ]
  }
]