[
  {
    "sha": "b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzdiNmUyMzQ1N2RjYmYxNjBhM2Q1ODZlY2E5ZGY3YThkMGJiMzUx",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2018-04-18T17:05:05Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jimpo@coinbase.com",
        "date": "2018-04-18T17:05:05Z"
      },
      "message": "MOVEONLY: Move logging code from util.{h,cpp} to new files.",
      "tree": {
        "sha": "15e0702a6abd7ceed82d652029b6654b7c6f6fae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15e0702a6abd7ceed82d652029b6654b7c6f6fae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3a8a4dc4a130c6d1eeff3fb8e6d9688dda2f8d25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a8a4dc4a130c6d1eeff3fb8e6d9688dda2f8d25",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3a8a4dc4a130c6d1eeff3fb8e6d9688dda2f8d25"
      }
    ],
    "stats": {
      "total": 789,
      "additions": 412,
      "deletions": 377
    },
    "files": [
      {
        "sha": "521687eb45b27c47d0b2781707d88dc69f810e04",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
        "patch": "@@ -113,6 +113,7 @@ BITCOIN_CORE_H = \\\n   keystore.h \\\n   dbwrapper.h \\\n   limitedmap.h \\\n+  logging.h \\\n   memusage.h \\\n   merkleblock.h \\\n   miner.h \\\n@@ -364,6 +365,7 @@ libbitcoin_util_a_SOURCES = \\\n   fs.cpp \\\n   interfaces/handler.cpp \\\n   interfaces/node.cpp \\\n+  logging.cpp \\\n   random.cpp \\\n   rpc/protocol.cpp \\\n   rpc/util.cpp \\"
      },
      {
        "sha": "e4815823216ca95713ef4570a48a7e6f08f4852e",
        "filename": "src/logging.cpp",
        "status": "added",
        "additions": 283,
        "deletions": 0,
        "changes": 283,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
        "patch": "@@ -0,0 +1,283 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <logging.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <list>\n+#include <mutex>\n+\n+const char * const DEFAULT_DEBUGLOGFILE = \"debug.log\";\n+\n+bool fPrintToConsole = false;\n+bool fPrintToDebugLog = true;\n+\n+bool fLogTimestamps = DEFAULT_LOGTIMESTAMPS;\n+bool fLogTimeMicros = DEFAULT_LOGTIMEMICROS;\n+bool fLogIPs = DEFAULT_LOGIPS;\n+std::atomic<bool> fReopenDebugLog(false);\n+\n+/** Log categories bitfield. */\n+std::atomic<uint32_t> logCategories(0);\n+/**\n+ * LogPrintf() has been broken a couple of times now\n+ * by well-meaning people adding mutexes in the most straightforward way.\n+ * It breaks because it may be called by global destructors during shutdown.\n+ * Since the order of destruction of static/global objects is undefined,\n+ * defining a mutex as a global object doesn't work (the mutex gets\n+ * destroyed, and then some later destructor calls OutputDebugStringF,\n+ * maybe indirectly, and you get a core dump at shutdown trying to lock\n+ * the mutex).\n+ */\n+\n+static std::once_flag debugPrintInitFlag;\n+\n+/**\n+ * We use std::call_once() to make sure mutexDebugLog and\n+ * vMsgsBeforeOpenLog are initialized in a thread-safe manner.\n+ *\n+ * NOTE: fileout, mutexDebugLog and sometimes vMsgsBeforeOpenLog\n+ * are leaked on exit. This is ugly, but will be cleaned up by\n+ * the OS/libc. When the shutdown sequence is fully audited and\n+ * tested, explicit destruction of these objects can be implemented.\n+ */\n+static FILE* fileout = nullptr;\n+static std::mutex* mutexDebugLog = nullptr;\n+static std::list<std::string>* vMsgsBeforeOpenLog;\n+\n+static int FileWriteStr(const std::string &str, FILE *fp)\n+{\n+    return fwrite(str.data(), 1, str.size(), fp);\n+}\n+\n+static void DebugPrintInit()\n+{\n+    assert(mutexDebugLog == nullptr);\n+    mutexDebugLog = new std::mutex();\n+    vMsgsBeforeOpenLog = new std::list<std::string>;\n+}\n+\n+fs::path GetDebugLogPath()\n+{\n+    fs::path logfile(gArgs.GetArg(\"-debuglogfile\", DEFAULT_DEBUGLOGFILE));\n+    return AbsPathForConfigVal(logfile);\n+}\n+\n+bool OpenDebugLog()\n+{\n+    std::call_once(debugPrintInitFlag, &DebugPrintInit);\n+    std::lock_guard<std::mutex> scoped_lock(*mutexDebugLog);\n+\n+    assert(fileout == nullptr);\n+    assert(vMsgsBeforeOpenLog);\n+    fs::path pathDebug = GetDebugLogPath();\n+\n+    fileout = fsbridge::fopen(pathDebug, \"a\");\n+    if (!fileout) {\n+        return false;\n+    }\n+\n+    setbuf(fileout, nullptr); // unbuffered\n+    // dump buffered messages from before we opened the log\n+    while (!vMsgsBeforeOpenLog->empty()) {\n+        FileWriteStr(vMsgsBeforeOpenLog->front(), fileout);\n+        vMsgsBeforeOpenLog->pop_front();\n+    }\n+\n+    delete vMsgsBeforeOpenLog;\n+    vMsgsBeforeOpenLog = nullptr;\n+    return true;\n+}\n+\n+struct CLogCategoryDesc\n+{\n+    uint32_t flag;\n+    std::string category;\n+};\n+\n+const CLogCategoryDesc LogCategories[] =\n+{\n+    {BCLog::NONE, \"0\"},\n+    {BCLog::NONE, \"none\"},\n+    {BCLog::NET, \"net\"},\n+    {BCLog::TOR, \"tor\"},\n+    {BCLog::MEMPOOL, \"mempool\"},\n+    {BCLog::HTTP, \"http\"},\n+    {BCLog::BENCH, \"bench\"},\n+    {BCLog::ZMQ, \"zmq\"},\n+    {BCLog::DB, \"db\"},\n+    {BCLog::RPC, \"rpc\"},\n+    {BCLog::ESTIMATEFEE, \"estimatefee\"},\n+    {BCLog::ADDRMAN, \"addrman\"},\n+    {BCLog::SELECTCOINS, \"selectcoins\"},\n+    {BCLog::REINDEX, \"reindex\"},\n+    {BCLog::CMPCTBLOCK, \"cmpctblock\"},\n+    {BCLog::RAND, \"rand\"},\n+    {BCLog::PRUNE, \"prune\"},\n+    {BCLog::PROXY, \"proxy\"},\n+    {BCLog::MEMPOOLREJ, \"mempoolrej\"},\n+    {BCLog::LIBEVENT, \"libevent\"},\n+    {BCLog::COINDB, \"coindb\"},\n+    {BCLog::QT, \"qt\"},\n+    {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::ALL, \"1\"},\n+    {BCLog::ALL, \"all\"},\n+};\n+\n+bool GetLogCategory(uint32_t *f, const std::string *str)\n+{\n+    if (f && str) {\n+        if (*str == \"\") {\n+            *f = BCLog::ALL;\n+            return true;\n+        }\n+        for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n+            if (LogCategories[i].category == *str) {\n+                *f = LogCategories[i].flag;\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+std::string ListLogCategories()\n+{\n+    std::string ret;\n+    int outcount = 0;\n+    for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n+        // Omit the special cases.\n+        if (LogCategories[i].flag != BCLog::NONE && LogCategories[i].flag != BCLog::ALL) {\n+            if (outcount != 0) ret += \", \";\n+            ret += LogCategories[i].category;\n+            outcount++;\n+        }\n+    }\n+    return ret;\n+}\n+\n+std::vector<CLogCategoryActive> ListActiveLogCategories()\n+{\n+    std::vector<CLogCategoryActive> ret;\n+    for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n+        // Omit the special cases.\n+        if (LogCategories[i].flag != BCLog::NONE && LogCategories[i].flag != BCLog::ALL) {\n+            CLogCategoryActive catActive;\n+            catActive.category = LogCategories[i].category;\n+            catActive.active = LogAcceptCategory(LogCategories[i].flag);\n+            ret.push_back(catActive);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/**\n+ * fStartedNewLine is a state variable held by the calling context that will\n+ * suppress printing of the timestamp when multiple calls are made that don't\n+ * end in a newline. Initialize it to true, and hold it, in the calling context.\n+ */\n+static std::string LogTimestampStr(const std::string &str, std::atomic_bool *fStartedNewLine)\n+{\n+    std::string strStamped;\n+\n+    if (!fLogTimestamps)\n+        return str;\n+\n+    if (*fStartedNewLine) {\n+        int64_t nTimeMicros = GetTimeMicros();\n+        strStamped = FormatISO8601DateTime(nTimeMicros/1000000);\n+        if (fLogTimeMicros) {\n+            strStamped.pop_back();\n+            strStamped += strprintf(\".%06dZ\", nTimeMicros%1000000);\n+        }\n+        int64_t mocktime = GetMockTime();\n+        if (mocktime) {\n+            strStamped += \" (mocktime: \" + FormatISO8601DateTime(mocktime) + \")\";\n+        }\n+        strStamped += ' ' + str;\n+    } else\n+        strStamped = str;\n+\n+    if (!str.empty() && str[str.size()-1] == '\\n')\n+        *fStartedNewLine = true;\n+    else\n+        *fStartedNewLine = false;\n+\n+    return strStamped;\n+}\n+\n+int LogPrintStr(const std::string &str)\n+{\n+    int ret = 0; // Returns total number of characters written\n+    static std::atomic_bool fStartedNewLine(true);\n+\n+    std::string strTimestamped = LogTimestampStr(str, &fStartedNewLine);\n+\n+    if (fPrintToConsole) {\n+        // print to console\n+        ret = fwrite(strTimestamped.data(), 1, strTimestamped.size(), stdout);\n+        fflush(stdout);\n+    }\n+    if (fPrintToDebugLog) {\n+        std::call_once(debugPrintInitFlag, &DebugPrintInit);\n+        std::lock_guard<std::mutex> scoped_lock(*mutexDebugLog);\n+\n+        // buffer if we haven't opened the log yet\n+        if (fileout == nullptr) {\n+            assert(vMsgsBeforeOpenLog);\n+            ret = strTimestamped.length();\n+            vMsgsBeforeOpenLog->push_back(strTimestamped);\n+        }\n+        else\n+        {\n+            // reopen the log file, if requested\n+            if (fReopenDebugLog) {\n+                fReopenDebugLog = false;\n+                fs::path pathDebug = GetDebugLogPath();\n+                if (fsbridge::freopen(pathDebug,\"a\",fileout) != nullptr)\n+                    setbuf(fileout, nullptr); // unbuffered\n+            }\n+\n+            ret = FileWriteStr(strTimestamped, fileout);\n+        }\n+    }\n+    return ret;\n+}\n+\n+void ShrinkDebugFile()\n+{\n+    // Amount of debug.log to save at end when shrinking (must fit in memory)\n+    constexpr size_t RECENT_DEBUG_HISTORY_SIZE = 10 * 1000000;\n+    // Scroll debug.log if it's getting too big\n+    fs::path pathLog = GetDebugLogPath();\n+    FILE* file = fsbridge::fopen(pathLog, \"r\");\n+\n+    // Special files (e.g. device nodes) may not have a size.\n+    size_t log_size = 0;\n+    try {\n+        log_size = fs::file_size(pathLog);\n+    } catch (boost::filesystem::filesystem_error &) {}\n+\n+    // If debug.log file is more than 10% bigger the RECENT_DEBUG_HISTORY_SIZE\n+    // trim it down by saving only the last RECENT_DEBUG_HISTORY_SIZE bytes\n+    if (file && log_size > 11 * (RECENT_DEBUG_HISTORY_SIZE / 10))\n+    {\n+        // Restart the file with some of the end\n+        std::vector<char> vch(RECENT_DEBUG_HISTORY_SIZE, 0);\n+        fseek(file, -((long)vch.size()), SEEK_END);\n+        int nBytes = fread(vch.data(), 1, vch.size(), file);\n+        fclose(file);\n+\n+        file = fsbridge::fopen(pathLog, \"w\");\n+        if (file)\n+        {\n+            fwrite(vch.data(), 1, nBytes, file);\n+            fclose(file);\n+        }\n+    }\n+    else if (file != nullptr)\n+        fclose(file);\n+}"
      },
      {
        "sha": "4053f75acf5dea7cc5b132d4e6ca8c594e9d1b15",
        "filename": "src/logging.h",
        "status": "added",
        "additions": 125,
        "deletions": 0,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
        "patch": "@@ -0,0 +1,125 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_LOGGING_H\n+#define BITCOIN_LOGGING_H\n+\n+#include <fs.h>\n+#include <tinyformat.h>\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <string>\n+#include <vector>\n+\n+static const bool DEFAULT_LOGTIMEMICROS = false;\n+static const bool DEFAULT_LOGIPS        = false;\n+static const bool DEFAULT_LOGTIMESTAMPS = true;\n+extern const char * const DEFAULT_DEBUGLOGFILE;\n+\n+extern bool fPrintToConsole;\n+extern bool fPrintToDebugLog;\n+\n+extern bool fLogTimestamps;\n+extern bool fLogTimeMicros;\n+extern bool fLogIPs;\n+extern std::atomic<bool> fReopenDebugLog;\n+\n+extern std::atomic<uint32_t> logCategories;\n+\n+struct CLogCategoryActive\n+{\n+    std::string category;\n+    bool active;\n+};\n+\n+namespace BCLog {\n+    enum LogFlags : uint32_t {\n+        NONE        = 0,\n+        NET         = (1 <<  0),\n+        TOR         = (1 <<  1),\n+        MEMPOOL     = (1 <<  2),\n+        HTTP        = (1 <<  3),\n+        BENCH       = (1 <<  4),\n+        ZMQ         = (1 <<  5),\n+        DB          = (1 <<  6),\n+        RPC         = (1 <<  7),\n+        ESTIMATEFEE = (1 <<  8),\n+        ADDRMAN     = (1 <<  9),\n+        SELECTCOINS = (1 << 10),\n+        REINDEX     = (1 << 11),\n+        CMPCTBLOCK  = (1 << 12),\n+        RAND        = (1 << 13),\n+        PRUNE       = (1 << 14),\n+        PROXY       = (1 << 15),\n+        MEMPOOLREJ  = (1 << 16),\n+        LIBEVENT    = (1 << 17),\n+        COINDB      = (1 << 18),\n+        QT          = (1 << 19),\n+        LEVELDB     = (1 << 20),\n+        ALL         = ~(uint32_t)0,\n+    };\n+}\n+/** Return true if log accepts specified category */\n+static inline bool LogAcceptCategory(uint32_t category)\n+{\n+    return (logCategories.load(std::memory_order_relaxed) & category) != 0;\n+}\n+\n+/** Returns a string with the log categories. */\n+std::string ListLogCategories();\n+\n+/** Returns a vector of the active log categories. */\n+std::vector<CLogCategoryActive> ListActiveLogCategories();\n+\n+/** Return true if str parses as a log category and set the flags in f */\n+bool GetLogCategory(uint32_t *f, const std::string *str);\n+\n+/** Send a string to the log output */\n+int LogPrintStr(const std::string &str);\n+\n+/** Get format string from VA_ARGS for error reporting */\n+template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }\n+\n+static inline void MarkUsed() {}\n+template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)\n+{\n+    (void)t;\n+    MarkUsed(args...);\n+}\n+\n+// Be conservative when using LogPrintf/error or other things which\n+// unconditionally log to debug.log! It should not be the case that an inbound\n+// peer can fill up a user's disk with debug.log entries.\n+\n+#ifdef USE_COVERAGE\n+#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#else\n+#define LogPrintf(...) do { \\\n+    if (fPrintToConsole || fPrintToDebugLog) { \\\n+        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \\\n+        try { \\\n+            _log_msg_ = tfm::format(__VA_ARGS__); \\\n+        } catch (tinyformat::format_error &fmterr) { \\\n+            /* Original format string will have newline so don't add one here */ \\\n+            _log_msg_ = \"Error \\\"\" + std::string(fmterr.what()) + \"\\\" while formatting log message: \" + FormatStringFromLogArgs(__VA_ARGS__); \\\n+        } \\\n+        LogPrintStr(_log_msg_); \\\n+    } \\\n+} while(0)\n+\n+#define LogPrint(category, ...) do { \\\n+    if (LogAcceptCategory((category))) { \\\n+        LogPrintf(__VA_ARGS__); \\\n+    } \\\n+} while(0)\n+#endif\n+\n+fs::path GetDebugLogPath();\n+bool OpenDebugLog();\n+void ShrinkDebugFile();\n+\n+#endif // BITCOIN_LOGGING_H"
      },
      {
        "sha": "4fb027b731989cfeffcdbbdd9eedbdfb087258b9",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 270,
        "changes": 270,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
        "patch": "@@ -84,21 +84,11 @@ const int64_t nStartupTime = GetTime();\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n-const char * const DEFAULT_DEBUGLOGFILE = \"debug.log\";\n \n ArgsManager gArgs;\n-bool fPrintToConsole = false;\n-bool fPrintToDebugLog = true;\n \n-bool fLogTimestamps = DEFAULT_LOGTIMESTAMPS;\n-bool fLogTimeMicros = DEFAULT_LOGTIMEMICROS;\n-bool fLogIPs = DEFAULT_LOGIPS;\n-std::atomic<bool> fReopenDebugLog(false);\n CTranslationInterface translationInterface;\n \n-/** Log categories bitfield. */\n-std::atomic<uint32_t> logCategories(0);\n-\n /** Init OpenSSL library multithreading support */\n static std::unique_ptr<CCriticalSection[]> ppmutexOpenSSL;\n void locking_callback(int mode, int i, const char* file, int line) NO_THREAD_SAFETY_ANALYSIS\n@@ -147,231 +137,6 @@ class CInit\n }\n instance_of_cinit;\n \n-/**\n- * LogPrintf() has been broken a couple of times now\n- * by well-meaning people adding mutexes in the most straightforward way.\n- * It breaks because it may be called by global destructors during shutdown.\n- * Since the order of destruction of static/global objects is undefined,\n- * defining a mutex as a global object doesn't work (the mutex gets\n- * destroyed, and then some later destructor calls OutputDebugStringF,\n- * maybe indirectly, and you get a core dump at shutdown trying to lock\n- * the mutex).\n- */\n-\n-static std::once_flag debugPrintInitFlag;\n-\n-/**\n- * We use std::call_once() to make sure mutexDebugLog and\n- * vMsgsBeforeOpenLog are initialized in a thread-safe manner.\n- *\n- * NOTE: fileout, mutexDebugLog and sometimes vMsgsBeforeOpenLog\n- * are leaked on exit. This is ugly, but will be cleaned up by\n- * the OS/libc. When the shutdown sequence is fully audited and\n- * tested, explicit destruction of these objects can be implemented.\n- */\n-static FILE* fileout = nullptr;\n-static std::mutex* mutexDebugLog = nullptr;\n-static std::list<std::string>* vMsgsBeforeOpenLog;\n-\n-static int FileWriteStr(const std::string &str, FILE *fp)\n-{\n-    return fwrite(str.data(), 1, str.size(), fp);\n-}\n-\n-static void DebugPrintInit()\n-{\n-    assert(mutexDebugLog == nullptr);\n-    mutexDebugLog = new std::mutex();\n-    vMsgsBeforeOpenLog = new std::list<std::string>;\n-}\n-\n-fs::path GetDebugLogPath()\n-{\n-    fs::path logfile(gArgs.GetArg(\"-debuglogfile\", DEFAULT_DEBUGLOGFILE));\n-    return AbsPathForConfigVal(logfile);\n-}\n-\n-bool OpenDebugLog()\n-{\n-    std::call_once(debugPrintInitFlag, &DebugPrintInit);\n-    std::lock_guard<std::mutex> scoped_lock(*mutexDebugLog);\n-\n-    assert(fileout == nullptr);\n-    assert(vMsgsBeforeOpenLog);\n-    fs::path pathDebug = GetDebugLogPath();\n-\n-    fileout = fsbridge::fopen(pathDebug, \"a\");\n-    if (!fileout) {\n-        return false;\n-    }\n-\n-    setbuf(fileout, nullptr); // unbuffered\n-    // dump buffered messages from before we opened the log\n-    while (!vMsgsBeforeOpenLog->empty()) {\n-        FileWriteStr(vMsgsBeforeOpenLog->front(), fileout);\n-        vMsgsBeforeOpenLog->pop_front();\n-    }\n-\n-    delete vMsgsBeforeOpenLog;\n-    vMsgsBeforeOpenLog = nullptr;\n-    return true;\n-}\n-\n-struct CLogCategoryDesc\n-{\n-    uint32_t flag;\n-    std::string category;\n-};\n-\n-const CLogCategoryDesc LogCategories[] =\n-{\n-    {BCLog::NONE, \"0\"},\n-    {BCLog::NONE, \"none\"},\n-    {BCLog::NET, \"net\"},\n-    {BCLog::TOR, \"tor\"},\n-    {BCLog::MEMPOOL, \"mempool\"},\n-    {BCLog::HTTP, \"http\"},\n-    {BCLog::BENCH, \"bench\"},\n-    {BCLog::ZMQ, \"zmq\"},\n-    {BCLog::DB, \"db\"},\n-    {BCLog::RPC, \"rpc\"},\n-    {BCLog::ESTIMATEFEE, \"estimatefee\"},\n-    {BCLog::ADDRMAN, \"addrman\"},\n-    {BCLog::SELECTCOINS, \"selectcoins\"},\n-    {BCLog::REINDEX, \"reindex\"},\n-    {BCLog::CMPCTBLOCK, \"cmpctblock\"},\n-    {BCLog::RAND, \"rand\"},\n-    {BCLog::PRUNE, \"prune\"},\n-    {BCLog::PROXY, \"proxy\"},\n-    {BCLog::MEMPOOLREJ, \"mempoolrej\"},\n-    {BCLog::LIBEVENT, \"libevent\"},\n-    {BCLog::COINDB, \"coindb\"},\n-    {BCLog::QT, \"qt\"},\n-    {BCLog::LEVELDB, \"leveldb\"},\n-    {BCLog::ALL, \"1\"},\n-    {BCLog::ALL, \"all\"},\n-};\n-\n-bool GetLogCategory(uint32_t *f, const std::string *str)\n-{\n-    if (f && str) {\n-        if (*str == \"\") {\n-            *f = BCLog::ALL;\n-            return true;\n-        }\n-        for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n-            if (LogCategories[i].category == *str) {\n-                *f = LogCategories[i].flag;\n-                return true;\n-            }\n-        }\n-    }\n-    return false;\n-}\n-\n-std::string ListLogCategories()\n-{\n-    std::string ret;\n-    int outcount = 0;\n-    for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n-        // Omit the special cases.\n-        if (LogCategories[i].flag != BCLog::NONE && LogCategories[i].flag != BCLog::ALL) {\n-            if (outcount != 0) ret += \", \";\n-            ret += LogCategories[i].category;\n-            outcount++;\n-        }\n-    }\n-    return ret;\n-}\n-\n-std::vector<CLogCategoryActive> ListActiveLogCategories()\n-{\n-    std::vector<CLogCategoryActive> ret;\n-    for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n-        // Omit the special cases.\n-        if (LogCategories[i].flag != BCLog::NONE && LogCategories[i].flag != BCLog::ALL) {\n-            CLogCategoryActive catActive;\n-            catActive.category = LogCategories[i].category;\n-            catActive.active = LogAcceptCategory(LogCategories[i].flag);\n-            ret.push_back(catActive);\n-        }\n-    }\n-    return ret;\n-}\n-\n-/**\n- * fStartedNewLine is a state variable held by the calling context that will\n- * suppress printing of the timestamp when multiple calls are made that don't\n- * end in a newline. Initialize it to true, and hold it, in the calling context.\n- */\n-static std::string LogTimestampStr(const std::string &str, std::atomic_bool *fStartedNewLine)\n-{\n-    std::string strStamped;\n-\n-    if (!fLogTimestamps)\n-        return str;\n-\n-    if (*fStartedNewLine) {\n-        int64_t nTimeMicros = GetTimeMicros();\n-        strStamped = FormatISO8601DateTime(nTimeMicros/1000000);\n-        if (fLogTimeMicros) {\n-            strStamped.pop_back();\n-            strStamped += strprintf(\".%06dZ\", nTimeMicros%1000000);\n-        }\n-        int64_t mocktime = GetMockTime();\n-        if (mocktime) {\n-            strStamped += \" (mocktime: \" + FormatISO8601DateTime(mocktime) + \")\";\n-        }\n-        strStamped += ' ' + str;\n-    } else\n-        strStamped = str;\n-\n-    if (!str.empty() && str[str.size()-1] == '\\n')\n-        *fStartedNewLine = true;\n-    else\n-        *fStartedNewLine = false;\n-\n-    return strStamped;\n-}\n-\n-int LogPrintStr(const std::string &str)\n-{\n-    int ret = 0; // Returns total number of characters written\n-    static std::atomic_bool fStartedNewLine(true);\n-\n-    std::string strTimestamped = LogTimestampStr(str, &fStartedNewLine);\n-\n-    if (fPrintToConsole) {\n-        // print to console\n-        ret = fwrite(strTimestamped.data(), 1, strTimestamped.size(), stdout);\n-        fflush(stdout);\n-    }\n-    if (fPrintToDebugLog) {\n-        std::call_once(debugPrintInitFlag, &DebugPrintInit);\n-        std::lock_guard<std::mutex> scoped_lock(*mutexDebugLog);\n-\n-        // buffer if we haven't opened the log yet\n-        if (fileout == nullptr) {\n-            assert(vMsgsBeforeOpenLog);\n-            ret = strTimestamped.length();\n-            vMsgsBeforeOpenLog->push_back(strTimestamped);\n-        }\n-        else\n-        {\n-            // reopen the log file, if requested\n-            if (fReopenDebugLog) {\n-                fReopenDebugLog = false;\n-                fs::path pathDebug = GetDebugLogPath();\n-                if (fsbridge::freopen(pathDebug,\"a\",fileout) != nullptr)\n-                    setbuf(fileout, nullptr); // unbuffered\n-            }\n-\n-            ret = FileWriteStr(strTimestamped, fileout);\n-        }\n-    }\n-    return ret;\n-}\n-\n /** A map that contains all the currently held directory locks. After\n  * successful locking, these will be held here until the global destructor\n  * cleans them up and thus automatically unlocks them, or ReleaseDirectoryLocks\n@@ -1117,41 +882,6 @@ void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length) {\n #endif\n }\n \n-void ShrinkDebugFile()\n-{\n-    // Amount of debug.log to save at end when shrinking (must fit in memory)\n-    constexpr size_t RECENT_DEBUG_HISTORY_SIZE = 10 * 1000000;\n-    // Scroll debug.log if it's getting too big\n-    fs::path pathLog = GetDebugLogPath();\n-    FILE* file = fsbridge::fopen(pathLog, \"r\");\n-\n-    // Special files (e.g. device nodes) may not have a size.\n-    size_t log_size = 0;\n-    try {\n-        log_size = fs::file_size(pathLog);\n-    } catch (boost::filesystem::filesystem_error &) {}\n-\n-    // If debug.log file is more than 10% bigger the RECENT_DEBUG_HISTORY_SIZE\n-    // trim it down by saving only the last RECENT_DEBUG_HISTORY_SIZE bytes\n-    if (file && log_size > 11 * (RECENT_DEBUG_HISTORY_SIZE / 10))\n-    {\n-        // Restart the file with some of the end\n-        std::vector<char> vch(RECENT_DEBUG_HISTORY_SIZE, 0);\n-        fseek(file, -((long)vch.size()), SEEK_END);\n-        int nBytes = fread(vch.data(), 1, vch.size(), file);\n-        fclose(file);\n-\n-        file = fsbridge::fopen(pathLog, \"w\");\n-        if (file)\n-        {\n-            fwrite(vch.data(), 1, nBytes, file);\n-            fclose(file);\n-        }\n-    }\n-    else if (file != nullptr)\n-        fclose(file);\n-}\n-\n #ifdef WIN32\n fs::path GetSpecialFolderPath(int nFolder, bool fCreate)\n {"
      },
      {
        "sha": "6e742f8b91f3104e297bc1a190571fdc1a470745",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 107,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77b6e23457dcbf160a3d586eca9df7a8d0bb351/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=b77b6e23457dcbf160a3d586eca9df7a8d0bb351",
        "patch": "@@ -5,7 +5,7 @@\n \n /**\n  * Server/client environment: argument handling, config file parsing,\n- * logging, thread wrappers, startup time\n+ * thread wrappers, startup time\n  */\n #ifndef BITCOIN_UTIL_H\n #define BITCOIN_UTIL_H\n@@ -16,6 +16,7 @@\n \n #include <compat.h>\n #include <fs.h>\n+#include <logging.h>\n #include <sync.h>\n #include <tinyformat.h>\n #include <utiltime.h>\n@@ -36,11 +37,6 @@\n // Application startup time (used for uptime calculation)\n int64_t GetStartupTime();\n \n-static const bool DEFAULT_LOGTIMEMICROS = false;\n-static const bool DEFAULT_LOGIPS        = false;\n-static const bool DEFAULT_LOGTIMESTAMPS = true;\n-extern const char * const DEFAULT_DEBUGLOGFILE;\n-\n /** Signals for translation. */\n class CTranslationInterface\n {\n@@ -49,20 +45,11 @@ class CTranslationInterface\n     boost::signals2::signal<std::string (const char* psz)> Translate;\n };\n \n-extern bool fPrintToConsole;\n-extern bool fPrintToDebugLog;\n-\n-extern bool fLogTimestamps;\n-extern bool fLogTimeMicros;\n-extern bool fLogIPs;\n-extern std::atomic<bool> fReopenDebugLog;\n extern CTranslationInterface translationInterface;\n \n extern const char * const BITCOIN_CONF_FILENAME;\n extern const char * const BITCOIN_PID_FILENAME;\n \n-extern std::atomic<uint32_t> logCategories;\n-\n /**\n  * Translation function: Call Translate signal on UI interface, which returns a boost::optional result.\n  * If no translation slot is registered, nothing is returned, and simply return the input.\n@@ -76,95 +63,6 @@ inline std::string _(const char* psz)\n void SetupEnvironment();\n bool SetupNetworking();\n \n-struct CLogCategoryActive\n-{\n-    std::string category;\n-    bool active;\n-};\n-\n-namespace BCLog {\n-    enum LogFlags : uint32_t {\n-        NONE        = 0,\n-        NET         = (1 <<  0),\n-        TOR         = (1 <<  1),\n-        MEMPOOL     = (1 <<  2),\n-        HTTP        = (1 <<  3),\n-        BENCH       = (1 <<  4),\n-        ZMQ         = (1 <<  5),\n-        DB          = (1 <<  6),\n-        RPC         = (1 <<  7),\n-        ESTIMATEFEE = (1 <<  8),\n-        ADDRMAN     = (1 <<  9),\n-        SELECTCOINS = (1 << 10),\n-        REINDEX     = (1 << 11),\n-        CMPCTBLOCK  = (1 << 12),\n-        RAND        = (1 << 13),\n-        PRUNE       = (1 << 14),\n-        PROXY       = (1 << 15),\n-        MEMPOOLREJ  = (1 << 16),\n-        LIBEVENT    = (1 << 17),\n-        COINDB      = (1 << 18),\n-        QT          = (1 << 19),\n-        LEVELDB     = (1 << 20),\n-        ALL         = ~(uint32_t)0,\n-    };\n-}\n-/** Return true if log accepts specified category */\n-static inline bool LogAcceptCategory(uint32_t category)\n-{\n-    return (logCategories.load(std::memory_order_relaxed) & category) != 0;\n-}\n-\n-/** Returns a string with the log categories. */\n-std::string ListLogCategories();\n-\n-/** Returns a vector of the active log categories. */\n-std::vector<CLogCategoryActive> ListActiveLogCategories();\n-\n-/** Return true if str parses as a log category and set the flags in f */\n-bool GetLogCategory(uint32_t *f, const std::string *str);\n-\n-/** Send a string to the log output */\n-int LogPrintStr(const std::string &str);\n-\n-/** Get format string from VA_ARGS for error reporting */\n-template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }\n-\n-static inline void MarkUsed() {}\n-template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)\n-{\n-    (void)t;\n-    MarkUsed(args...);\n-}\n-\n-// Be conservative when using LogPrintf/error or other things which\n-// unconditionally log to debug.log! It should not be the case that an inbound\n-// peer can fill up a user's disk with debug.log entries.\n-\n-#ifdef USE_COVERAGE\n-#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n-#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)\n-#else\n-#define LogPrintf(...) do { \\\n-    if (fPrintToConsole || fPrintToDebugLog) { \\\n-        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \\\n-        try { \\\n-            _log_msg_ = tfm::format(__VA_ARGS__); \\\n-        } catch (tinyformat::format_error &fmterr) { \\\n-            /* Original format string will have newline so don't add one here */ \\\n-            _log_msg_ = \"Error \\\"\" + std::string(fmterr.what()) + \"\\\" while formatting log message: \" + FormatStringFromLogArgs(__VA_ARGS__); \\\n-        } \\\n-        LogPrintStr(_log_msg_); \\\n-    } \\\n-} while(0)\n-\n-#define LogPrint(category, ...) do { \\\n-    if (LogAcceptCategory((category))) { \\\n-        LogPrintf(__VA_ARGS__); \\\n-    } \\\n-} while(0)\n-#endif\n-\n template<typename... Args>\n bool error(const char* fmt, const Args&... args)\n {\n@@ -199,9 +97,6 @@ void CreatePidFile(const fs::path &path, pid_t pid);\n #ifdef WIN32\n fs::path GetSpecialFolderPath(int nFolder, bool fCreate = true);\n #endif\n-fs::path GetDebugLogPath();\n-bool OpenDebugLog();\n-void ShrinkDebugFile();\n void runCommand(const std::string& strCommand);\n \n /**"
      }
    ]
  }
]