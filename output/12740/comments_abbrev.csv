laanwj,2018-03-29T20:52:20Z,"utACK https://github.com/bitcoin/bitcoin/pull/12740/commits/a7c45bce9264f4a8fa48f2e7ecaf102971fc026f , good to finally get rid of the FLATDATA eyesore",https://github.com/bitcoin/bitcoin/pull/12740#issuecomment-377368563,377368563,
eklitzke,2018-03-21T01:02:01Z,"nit: since these are inline, the static specifier is ignored",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r175966073,175966073,src/serialize.h
sipa,2018-03-21T01:16:33Z,"Really?\n\nMy understanding was that a non-`static` `inline` function will still be emitted in non-inlined form in the object file, as the compiler can't know there are no non-inlinable calls from other translation units.\n\nMaking it static guarantees no calls from other translation units are possible, and thus permits the compliler to not emit any code as long as all calls within the current",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r175967491,175967491,src/serialize.h
dcousens,2018-03-21T03:13:34Z,why not `reinterpret_cast`? ,https://github.com/bitcoin/bitcoin/pull/12740#discussion_r175976876,175976876,src/serialize.h
sipa,2018-03-21T03:21:28Z,"For primitive types there is no distinction between c-style-cast, reinterpret_cast, static_cast.",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r175977468,175977468,src/serialize.h
ryanofsky,2018-03-21T19:14:47Z,That's my understanding too.,https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176206723,176206723,src/serialize.h
sipa,2018-03-21T20:48:06Z,"It seems my understanding is correct for C, but not for modern C++. `inline` in C++ is not just a hint that the function is preferably inlined, but also automatically implies the function may violate ODR.\n\nThanks, this is very interesting.",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176232912,176232912,src/serialize.h
sipa,2018-03-21T21:14:36Z,Fixed.,https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176240445,176240445,src/serialize.h
ryanofsky,2018-03-21T21:27:21Z,"> It seems my understanding is correct for C, but not for modern C++. inline in C++ is not just a hint that the function is preferably inlined, but also automatically implies the function may violate ODR.\n\nReally confused. What is the reason for removing static and thinking it is ignored? What version of modern c++ is this assuming? I can't follow the logic here.",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176243957,176243957,src/serialize.h
sipa,2018-03-21T21:33:26Z,"Reading more on: http://en.cppreference.com/w/cpp/language/inline\n\nSemantically, `static` (or anonymous namespace) in combination with `inline` is not meaningless. It still indicates that different translation units may have different definitions. Without `static` it is (in theory) undefined to have multiple translation units with a different definition.\n\nHowever, non-`static` `inline` fun",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176245584,176245584,src/serialize.h
ryanofsky,2018-03-21T21:59:27Z,"> This means that the reason why I was using static here (being worried about having multiple emitted copies of a non-inlined version of the function) doesn't apply.\n\nI'd still think you'd want to specify `static` to tell the compiler that the function won't be accessed from a different translation unit and that exporting a symbol isn't necessary. It doesn't seem like it can be true that no sy",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176252159,176252159,src/serialize.h
sipa,2018-03-21T22:20:45Z,"@ryanofsky That's what I'm seeing at `-O0` (when inlining is disabled). With `-O1` or higher, no symbol is emitted with either `inline` or `static inline` when all call sites are inlinable.\n\nAlso, when compiling with `g++`, with multiple object files where the call sites are not inlinable, each object gets indeed a symbol, but they're turned into a single symbol in the final executable. When c",https://github.com/bitcoin/bitcoin/pull/12740#discussion_r176257268,176257268,src/serialize.h
