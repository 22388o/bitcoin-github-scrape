[
  {
    "sha": "fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
    "node_id": "C_kwDOABII59oAKGZhYzgzM2IxZmQ4ZGZjM2RiMmI4M2JiMTBmODNiZGIwOGVjZjY2ODk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-04T14:00:05Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-24T10:32:13Z"
      },
      "message": "Use spans of std::byte in serialize\n\nThis switches .read() and .write() to take spans of bytes.",
      "tree": {
        "sha": "cdb6816c160d27c12f9dfb1093b66986607638ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cdb6816c160d27c12f9dfb1093b66986607638ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgYkwv/Q9W3G/zQfE9fzR64SWwIA3h0euK0UZwsrMnUDtw9rvN25juidKPuD+X2\nhpq7I5lAJKzk489xdGHm0feINXu0LRbCL2QnuRIs9Gs9mL/MkMSU69Pihpw/NxOP\n9nu69ZKCneww974XJ7l1GMpD/p3BK+VMc/ScWkyX7pdvtpL3TKGYzKkUvaZjjC8D\nrlkLNHP17qydQKkWCEanP5307hlf+jC3tNVYumcGj5UNMjkx9AaaLzV6LI6NcvYZ\ndstPRuLjDyXKk9u2V9ufzjxmAfXjBldCIkYYHPN4q9Z8d6LaGkU8JDZ0CuvpYpil\nk9vxMEhjssBCwxQ1m6UrjUb/HL7Qe94/qBGUiAlXtedEuhApZo4dVuVWDVZjmm/7\nYke0IMWUmUGJsX3pLbrATo2ZGtvltLmRw7Ho54NNXna4MC+0Ps2+lD+ZYinEB0rT\nE5Wue2JCtYVAwejImSIMUqkhSf8H4n8BtZ/FbSXWss8HY1e7jR96azb2XaiLgIN2\n5BaYL3BL\n=DiX3\n-----END PGP SIGNATURE-----",
        "payload": "tree cdb6816c160d27c12f9dfb1093b66986607638ba\nparent 9394964f6b9d1cf1220a4eca17ba18dc49ae876d\nauthor MarcoFalke <falke.marco@gmail.com> 1636034405 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637749933 +0100\n\nUse spans of std::byte in serialize\n\nThis switches .read() and .write() to take spans of bytes.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9394964f6b9d1cf1220a4eca17ba18dc49ae876d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9394964f6b9d1cf1220a4eca17ba18dc49ae876d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9394964f6b9d1cf1220a4eca17ba18dc49ae876d"
      }
    ],
    "stats": {
      "total": 376,
      "additions": 196,
      "deletions": 180
    },
    "files": [
      {
        "sha": "52e5cb743fbdcd1ffa2af185042306bff2cdc503",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -17,8 +17,8 @@\n static void DeserializeBlockTest(benchmark::Bench& bench)\n {\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n-    char a = '\\0';\n-    stream.write(&a, 1); // Prevent compaction\n+    std::byte a{0};\n+    stream.write({&a, 1}); // Prevent compaction\n \n     bench.unit(\"block\").run([&] {\n         CBlock block;\n@@ -31,8 +31,8 @@ static void DeserializeBlockTest(benchmark::Bench& bench)\n static void DeserializeAndCheckBlockTest(benchmark::Bench& bench)\n {\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n-    char a = '\\0';\n-    stream.write(&a, 1); // Prevent compaction\n+    std::byte a{0};\n+    stream.write({&a, 1}); // Prevent compaction\n \n     ArgsManager bench_args;\n     const auto chainParams = CreateChainParams(bench_args, CBaseChainParams::MAIN);"
      },
      {
        "sha": "4771e07b3ad65638a5a9bf84b391339c64cb6ea0",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -23,8 +23,8 @@ struct TestBlockAndIndex {\n     TestBlockAndIndex()\n     {\n         CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n-        char a = '\\0';\n-        stream.write(&a, 1); // Prevent compaction\n+        std::byte a{0};\n+        stream.write({&a, 1}); // Prevent compaction\n \n         stream >> block;\n "
      },
      {
        "sha": "fc5f9c2a6cb9f45f6765710ef49425649e2ce5d1",
        "filename": "src/common/bloom.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/common/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/common/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/common/bloom.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -61,7 +61,7 @@ void CBloomFilter::insert(const COutPoint& outpoint)\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n-    insert(stream);\n+    insert(MakeUCharSpan(stream));\n }\n \n bool CBloomFilter::contains(Span<const unsigned char> vKey) const\n@@ -82,7 +82,7 @@ bool CBloomFilter::contains(const COutPoint& outpoint) const\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n-    return contains(stream);\n+    return contains(MakeUCharSpan(stream));\n }\n \n bool CBloomFilter::IsWithinSizeConstraints() const"
      },
      {
        "sha": "2dede5b4fda84a4e60cf77f30907a0f0c50abafb",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -147,7 +147,7 @@ class CDBIterator\n     template<typename K> bool GetKey(K& key) {\n         leveldb::Slice slKey = piter->key();\n         try {\n-            CDataStream ssKey(MakeUCharSpan(slKey), SER_DISK, CLIENT_VERSION);\n+            CDataStream ssKey{MakeByteSpan(slKey), SER_DISK, CLIENT_VERSION};\n             ssKey >> key;\n         } catch (const std::exception&) {\n             return false;\n@@ -158,7 +158,7 @@ class CDBIterator\n     template<typename V> bool GetValue(V& value) {\n         leveldb::Slice slValue = piter->value();\n         try {\n-            CDataStream ssValue(MakeUCharSpan(slValue), SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue{MakeByteSpan(slValue), SER_DISK, CLIENT_VERSION};\n             ssValue.Xor(dbwrapper_private::GetObfuscateKey(parent));\n             ssValue >> value;\n         } catch (const std::exception&) {\n@@ -244,7 +244,7 @@ class CDBWrapper\n             dbwrapper_private::HandleError(status);\n         }\n         try {\n-            CDataStream ssValue(MakeUCharSpan(strValue), SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue{MakeByteSpan(strValue), SER_DISK, CLIENT_VERSION};\n             ssValue.Xor(obfuscate_key);\n             ssValue >> value;\n         } catch (const std::exception&) {"
      },
      {
        "sha": "9f582842c1f816445c9b590951705ee69bbea1b3",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -111,8 +111,9 @@ class CHashWriter\n     int GetType() const { return nType; }\n     int GetVersion() const { return nVersion; }\n \n-    void write(const char *pch, size_t size) {\n-        ctx.Write((const unsigned char*)pch, size);\n+    void write(Span<const std::byte> src)\n+    {\n+        ctx.Write(UCharCast(src.data()), src.size());\n     }\n \n     /** Compute the double-SHA256 hash of all data written to this object.\n@@ -162,18 +163,18 @@ class CHashVerifier : public CHashWriter\n public:\n     explicit CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n \n-    void read(char* pch, size_t nSize)\n+    void read(Span<std::byte> dst)\n     {\n-        source->read(pch, nSize);\n-        this->write(pch, nSize);\n+        source->read(dst);\n+        this->write(dst);\n     }\n \n     void ignore(size_t nSize)\n     {\n-        char data[1024];\n+        std::byte data[1024];\n         while (nSize > 0) {\n             size_t now = std::min<size_t>(nSize, 1024);\n-            read(data, now);\n+            read({data, now});\n             nSize -= now;\n         }\n     }"
      },
      {
        "sha": "3dc694c4e0bb7236ef2d772ca12168962359cf40",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -3121,11 +3121,11 @@ void CaptureMessage(const CAddress& addr, const std::string& msg_type, const Spa\n     CAutoFile f(fsbridge::fopen(path, \"ab\"), SER_DISK, CLIENT_VERSION);\n \n     ser_writedata64(f, now.count());\n-    f.write(msg_type.data(), msg_type.length());\n+    f.write(MakeByteSpan(msg_type));\n     for (auto i = msg_type.length(); i < CMessageHeader::COMMAND_SIZE; ++i) {\n         f << uint8_t{'\\0'};\n     }\n     uint32_t size = data.size();\n     ser_writedata32(f, size);\n-    f.write((const char*)data.data(), data.size());\n+    f.write(AsBytes(data));\n }"
      },
      {
        "sha": "4a8526ca30a9636ec33cce6fbd41f2e5408789ea",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -435,7 +435,7 @@ bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, c\n         }\n \n         block.resize(blk_size); // Zeroing of memory is intentional here\n-        filein.read((char*)block.data(), blk_size);\n+        filein.read(MakeWriteableByteSpan(block));\n     } catch (const std::exception& e) {\n         return error(\"%s: Read from block file failed: %s for %s\", __func__, e.what(), pos.ToString());\n     }"
      },
      {
        "sha": "51535048be0356189b5d7d7fe45c2f011154385b",
        "filename": "src/psbt.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -384,7 +384,7 @@ bool DecodeBase64PSBT(PartiallySignedTransaction& psbt, const std::string& base6\n \n bool DecodeRawPSBT(PartiallySignedTransaction& psbt, const std::string& tx_data, std::string& error)\n {\n-    CDataStream ss_data(MakeUCharSpan(tx_data), SER_NETWORK, PROTOCOL_VERSION);\n+    CDataStream ss_data(MakeByteSpan(tx_data), SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ss_data >> psbt;\n         if (!ss_data.empty()) {"
      },
      {
        "sha": "d1cf07a0ee824f98898796457ee4ef314e5e185e",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -136,14 +136,14 @@ class CPubKey\n     {\n         unsigned int len = size();\n         ::WriteCompactSize(s, len);\n-        s.write((char*)vch, len);\n+        s.write({BytePtr(vch), len});\n     }\n     template <typename Stream>\n     void Unserialize(Stream& s)\n     {\n         const unsigned int len(::ReadCompactSize(s));\n         if (len <= SIZE) {\n-            s.read((char*)vch, len);\n+            s.read({BytePtr(vch), len});\n             if (len != size()) {\n                 Invalidate();\n             }"
      },
      {
        "sha": "2775ff9afc787a80c8cf0926e1967057446e4872",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -22,20 +22,23 @@ class TxInputStream\n     m_remaining(txToLen)\n     {}\n \n-    void read(char* pch, size_t nSize)\n+    void read(Span<std::byte> dst)\n     {\n-        if (nSize > m_remaining)\n+        if (dst.size() > m_remaining) {\n             throw std::ios_base::failure(std::string(__func__) + \": end of data\");\n+        }\n \n-        if (pch == nullptr)\n+        if (dst.data() == nullptr) {\n             throw std::ios_base::failure(std::string(__func__) + \": bad destination buffer\");\n+        }\n \n-        if (m_data == nullptr)\n+        if (m_data == nullptr) {\n             throw std::ios_base::failure(std::string(__func__) + \": bad source buffer\");\n+        }\n \n-        memcpy(pch, m_data, nSize);\n-        m_remaining -= nSize;\n-        m_data += nSize;\n+        memcpy(dst.data(), m_data, dst.size());\n+        m_remaining -= dst.size();\n+        m_data += dst.size();\n     }\n \n     template<typename T>"
      },
      {
        "sha": "9c14edd926b6ef4c92433ca394aa7aa5cbbca16b",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -1303,12 +1303,12 @@ class CTransactionSignatureSerializer\n         it = itBegin;\n         while (scriptCode.GetOp(it, opcode)) {\n             if (opcode == OP_CODESEPARATOR) {\n-                s.write((char*)&itBegin[0], it-itBegin-1);\n+                s.write({BytePtr(&itBegin[0]), size_t(it - itBegin - 1)});\n                 itBegin = it;\n             }\n         }\n         if (itBegin != scriptCode.end())\n-            s.write((char*)&itBegin[0], it-itBegin);\n+            s.write({BytePtr(&itBegin[0]), size_t(it - itBegin)});\n     }\n \n     /** Serialize an input of txTo */"
      },
      {
        "sha": "6c1965c9a67dad64fea9887638e73dd4aefa5132",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 36,
        "deletions": 38,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -47,87 +47,85 @@ static const unsigned int MAX_VECTOR_ALLOCATE = 5000000;\n struct deserialize_type {};\n constexpr deserialize_type deserialize {};\n \n-//! Safely convert odd char pointer types to standard ones.\n-inline char* CharCast(char* c) { return c; }\n-inline char* CharCast(unsigned char* c) { return (char*)c; }\n-inline const char* CharCast(const char* c) { return c; }\n-inline const char* CharCast(const unsigned char* c) { return (const char*)c; }\n+//! Safely convert a data pointer to a std::byte data pointer.\n+inline std::byte* BytePtr(void* data) { return reinterpret_cast<std::byte*>(data); }\n+inline const std::byte* BytePtr(const void* data) { return reinterpret_cast<const std::byte*>(data); }\n \n /*\n  * Lowest-level serialization and conversion.\n  * @note Sizes of these types are verified in the tests\n  */\n template<typename Stream> inline void ser_writedata8(Stream &s, uint8_t obj)\n {\n-    s.write((char*)&obj, 1);\n+    s.write({BytePtr(&obj), 1});\n }\n template<typename Stream> inline void ser_writedata16(Stream &s, uint16_t obj)\n {\n     obj = htole16(obj);\n-    s.write((char*)&obj, 2);\n+    s.write({BytePtr(&obj), 2});\n }\n template<typename Stream> inline void ser_writedata16be(Stream &s, uint16_t obj)\n {\n     obj = htobe16(obj);\n-    s.write((char*)&obj, 2);\n+    s.write({BytePtr(&obj), 2});\n }\n template<typename Stream> inline void ser_writedata32(Stream &s, uint32_t obj)\n {\n     obj = htole32(obj);\n-    s.write((char*)&obj, 4);\n+    s.write({BytePtr(&obj), 4});\n }\n template<typename Stream> inline void ser_writedata32be(Stream &s, uint32_t obj)\n {\n     obj = htobe32(obj);\n-    s.write((char*)&obj, 4);\n+    s.write({BytePtr(&obj), 4});\n }\n template<typename Stream> inline void ser_writedata64(Stream &s, uint64_t obj)\n {\n     obj = htole64(obj);\n-    s.write((char*)&obj, 8);\n+    s.write({BytePtr(&obj), 8});\n }\n template<typename Stream> inline uint8_t ser_readdata8(Stream &s)\n {\n     uint8_t obj;\n-    s.read((char*)&obj, 1);\n+    s.read({BytePtr(&obj), 1});\n     return obj;\n }\n template<typename Stream> inline uint16_t ser_readdata16(Stream &s)\n {\n     uint16_t obj;\n-    s.read((char*)&obj, 2);\n+    s.read({BytePtr(&obj), 2});\n     return le16toh(obj);\n }\n template<typename Stream> inline uint16_t ser_readdata16be(Stream &s)\n {\n     uint16_t obj;\n-    s.read((char*)&obj, 2);\n+    s.read({BytePtr(&obj), 2});\n     return be16toh(obj);\n }\n template<typename Stream> inline uint32_t ser_readdata32(Stream &s)\n {\n     uint32_t obj;\n-    s.read((char*)&obj, 4);\n+    s.read({BytePtr(&obj), 4});\n     return le32toh(obj);\n }\n template<typename Stream> inline uint32_t ser_readdata32be(Stream &s)\n {\n     uint32_t obj;\n-    s.read((char*)&obj, 4);\n+    s.read({BytePtr(&obj), 4});\n     return be32toh(obj);\n }\n template<typename Stream> inline uint64_t ser_readdata64(Stream &s)\n {\n     uint64_t obj;\n-    s.read((char*)&obj, 8);\n+    s.read({BytePtr(&obj), 8});\n     return le64toh(obj);\n }\n \n \n /////////////////////////////////////////////////////////////////\n //\n // Templates for serializing to anything that looks like a stream,\n-// i.e. anything that supports .read(char*, size_t) and .write(char*, size_t)\n+// i.e. anything that supports .read(Span<std::byte>) and .write(Span<const std::byte>)\n //\n \n class CSizeComputer;\n@@ -206,10 +204,10 @@ template<typename Stream> inline void Serialize(Stream& s, int32_t a ) { ser_wri\n template<typename Stream> inline void Serialize(Stream& s, uint32_t a) { ser_writedata32(s, a); }\n template<typename Stream> inline void Serialize(Stream& s, int64_t a ) { ser_writedata64(s, a); }\n template<typename Stream> inline void Serialize(Stream& s, uint64_t a) { ser_writedata64(s, a); }\n-template<typename Stream, int N> inline void Serialize(Stream& s, const char (&a)[N]) { s.write(a, N); }\n-template<typename Stream, int N> inline void Serialize(Stream& s, const unsigned char (&a)[N]) { s.write(CharCast(a), N); }\n-template<typename Stream> inline void Serialize(Stream& s, const Span<const unsigned char>& span) { s.write(CharCast(span.data()), span.size()); }\n-template<typename Stream> inline void Serialize(Stream& s, const Span<unsigned char>& span) { s.write(CharCast(span.data()), span.size()); }\n+template<typename Stream, int N> inline void Serialize(Stream& s, const char (&a)[N]) { s.write(MakeByteSpan(a)); }\n+template<typename Stream, int N> inline void Serialize(Stream& s, const unsigned char (&a)[N]) { s.write(MakeByteSpan(a)); }\n+template<typename Stream> inline void Serialize(Stream& s, const Span<const unsigned char>& span) { s.write(AsBytes(span)); }\n+template<typename Stream> inline void Serialize(Stream& s, const Span<unsigned char>& span) { s.write(AsBytes(span)); }\n \n #ifndef CHAR_EQUALS_INT8\n template<typename Stream> inline void Unserialize(Stream& s, char& a    ) { a = ser_readdata8(s); } // TODO Get rid of bare char\n@@ -222,9 +220,9 @@ template<typename Stream> inline void Unserialize(Stream& s, int32_t& a ) { a =\n template<typename Stream> inline void Unserialize(Stream& s, uint32_t& a) { a = ser_readdata32(s); }\n template<typename Stream> inline void Unserialize(Stream& s, int64_t& a ) { a = ser_readdata64(s); }\n template<typename Stream> inline void Unserialize(Stream& s, uint64_t& a) { a = ser_readdata64(s); }\n-template<typename Stream, int N> inline void Unserialize(Stream& s, char (&a)[N]) { s.read(a, N); }\n-template<typename Stream, int N> inline void Unserialize(Stream& s, unsigned char (&a)[N]) { s.read(CharCast(a), N); }\n-template<typename Stream> inline void Unserialize(Stream& s, Span<unsigned char>& span) { s.read(CharCast(span.data()), span.size()); }\n+template<typename Stream, int N> inline void Unserialize(Stream& s, char (&a)[N]) { s.read(MakeWriteableByteSpan(a)); }\n+template<typename Stream, int N> inline void Unserialize(Stream& s, unsigned char (&a)[N]) { s.read(MakeWriteableByteSpan(a)); }\n+template<typename Stream> inline void Unserialize(Stream& s, Span<unsigned char>& span) { s.read(AsWriteableBytes(span)); }\n \n template <typename Stream> inline void Serialize(Stream& s, bool a) { uint8_t f = a; ser_writedata8(s, f); }\n template <typename Stream> inline void Unserialize(Stream& s, bool& a) { uint8_t f = ser_readdata8(s); a = f; }\n@@ -479,10 +477,10 @@ struct CustomUintFormatter\n         if (v < 0 || v > MAX) throw std::ios_base::failure(\"CustomUintFormatter value out of range\");\n         if (BigEndian) {\n             uint64_t raw = htobe64(v);\n-            s.write(((const char*)&raw) + 8 - Bytes, Bytes);\n+            s.write({BytePtr(&raw) + 8 - Bytes, Bytes});\n         } else {\n             uint64_t raw = htole64(v);\n-            s.write((const char*)&raw, Bytes);\n+            s.write({BytePtr(&raw), Bytes});\n         }\n     }\n \n@@ -492,10 +490,10 @@ struct CustomUintFormatter\n         static_assert(std::numeric_limits<U>::max() >= MAX && std::numeric_limits<U>::min() <= 0, \"Assigned type too small\");\n         uint64_t raw = 0;\n         if (BigEndian) {\n-            s.read(((char*)&raw) + 8 - Bytes, Bytes);\n+            s.read({BytePtr(&raw) + 8 - Bytes, Bytes});\n             v = static_cast<I>(be64toh(raw));\n         } else {\n-            s.read((char*)&raw, Bytes);\n+            s.read({BytePtr(&raw), Bytes});\n             v = static_cast<I>(le64toh(raw));\n         }\n     }\n@@ -538,7 +536,7 @@ struct LimitedStringFormatter\n             throw std::ios_base::failure(\"String length limit exceeded\");\n         }\n         v.resize(size);\n-        if (size != 0) s.read((char*)v.data(), size);\n+        if (size != 0) s.read(MakeWriteableByteSpan(v));\n     }\n \n     template<typename Stream>\n@@ -702,7 +700,7 @@ void Serialize(Stream& os, const std::basic_string<C>& str)\n {\n     WriteCompactSize(os, str.size());\n     if (!str.empty())\n-        os.write((char*)str.data(), str.size() * sizeof(C));\n+        os.write(MakeByteSpan(str));\n }\n \n template<typename Stream, typename C>\n@@ -711,7 +709,7 @@ void Unserialize(Stream& is, std::basic_string<C>& str)\n     unsigned int nSize = ReadCompactSize(is);\n     str.resize(nSize);\n     if (nSize != 0)\n-        is.read((char*)str.data(), nSize * sizeof(C));\n+        is.read(MakeWriteableByteSpan(str));\n }\n \n \n@@ -724,7 +722,7 @@ void Serialize_impl(Stream& os, const prevector<N, T>& v, const unsigned char&)\n {\n     WriteCompactSize(os, v.size());\n     if (!v.empty())\n-        os.write((char*)v.data(), v.size() * sizeof(T));\n+        os.write(MakeByteSpan(v));\n }\n \n template<typename Stream, unsigned int N, typename T, typename V>\n@@ -751,7 +749,7 @@ void Unserialize_impl(Stream& is, prevector<N, T>& v, const unsigned char&)\n     {\n         unsigned int blk = std::min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n         v.resize_uninitialized(i + blk);\n-        is.read((char*)&v[i], blk * sizeof(T));\n+        is.read({BytePtr(&v[i]), blk * sizeof(T)});\n         i += blk;\n     }\n }\n@@ -778,7 +776,7 @@ void Serialize_impl(Stream& os, const std::vector<T, A>& v, const unsigned char&\n {\n     WriteCompactSize(os, v.size());\n     if (!v.empty())\n-        os.write((char*)v.data(), v.size() * sizeof(T));\n+        os.write(MakeByteSpan(v));\n }\n \n template<typename Stream, typename T, typename A>\n@@ -817,7 +815,7 @@ void Unserialize_impl(Stream& is, std::vector<T, A>& v, const unsigned char&)\n     {\n         unsigned int blk = std::min(nSize - i, (unsigned int)(1 + 4999999 / sizeof(T)));\n         v.resize(i + blk);\n-        is.read((char*)&v[i], blk * sizeof(T));\n+        is.read({BytePtr(&v[i]), blk * sizeof(T)});\n         i += blk;\n     }\n }\n@@ -982,9 +980,9 @@ class CSizeComputer\n public:\n     explicit CSizeComputer(int nVersionIn) : nSize(0), nVersion(nVersionIn) {}\n \n-    void write(const char *psz, size_t _nSize)\n+    void write(Span<const std::byte> src)\n     {\n-        this->nSize += _nSize;\n+        this->nSize += src.size();\n     }\n \n     /** Pretend _nSize bytes are written, without specifying them. */"
      },
      {
        "sha": "57cbdc41ce88516a73bd03127f1743a4193099d3",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 45,
        "deletions": 39,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -49,14 +49,14 @@ class OverrideStream\n         return (*this);\n     }\n \n-    void write(const char* pch, size_t nSize)\n+    void write(Span<const std::byte> src)\n     {\n-        stream->write(pch, nSize);\n+        stream->write(src);\n     }\n \n-    void read(char* pch, size_t nSize)\n+    void read(Span<std::byte> dst)\n     {\n-        stream->read(pch, nSize);\n+        stream->read(dst);\n     }\n \n     int GetVersion() const { return nVersion; }\n@@ -94,17 +94,17 @@ class CVectorWriter\n     {\n         ::SerializeMany(*this, std::forward<Args>(args)...);\n     }\n-    void write(const char* pch, size_t nSize)\n+    void write(Span<const std::byte> src)\n     {\n         assert(nPos <= vchData.size());\n-        size_t nOverwrite = std::min(nSize, vchData.size() - nPos);\n+        size_t nOverwrite = std::min(src.size(), vchData.size() - nPos);\n         if (nOverwrite) {\n-            memcpy(vchData.data() + nPos, reinterpret_cast<const unsigned char*>(pch), nOverwrite);\n+            memcpy(vchData.data() + nPos, src.data(), nOverwrite);\n         }\n-        if (nOverwrite < nSize) {\n-            vchData.insert(vchData.end(), reinterpret_cast<const unsigned char*>(pch) + nOverwrite, reinterpret_cast<const unsigned char*>(pch) + nSize);\n+        if (nOverwrite < src.size()) {\n+            vchData.insert(vchData.end(), UCharCast(src.data()) + nOverwrite, UCharCast(src.end()));\n         }\n-        nPos += nSize;\n+        nPos += src.size();\n     }\n     template<typename T>\n     CVectorWriter& operator<<(const T& obj)\n@@ -180,18 +180,18 @@ class VectorReader\n     size_t size() const { return m_data.size() - m_pos; }\n     bool empty() const { return m_data.size() == m_pos; }\n \n-    void read(char* dst, size_t n)\n+    void read(Span<std::byte> dst)\n     {\n-        if (n == 0) {\n+        if (dst.size() == 0) {\n             return;\n         }\n \n         // Read from the beginning of the buffer\n-        size_t pos_next = m_pos + n;\n+        size_t pos_next = m_pos + dst.size();\n         if (pos_next > m_data.size()) {\n             throw std::ios_base::failure(\"VectorReader::read(): end of data\");\n         }\n-        memcpy(dst, m_data.data() + m_pos, n);\n+        memcpy(dst.data(), m_data.data() + m_pos, dst.size());\n         m_pos = pos_next;\n     }\n };\n@@ -226,6 +226,7 @@ class CDataStream\n         : nType{nTypeIn},\n           nVersion{nVersionIn} {}\n \n+    explicit CDataStream(Span<const uint8_t> sp, int type, int version) : CDataStream{AsBytes(sp), type, version} {}\n     explicit CDataStream(Span<const value_type> sp, int nTypeIn, int nVersionIn)\n         : vch(sp.data(), sp.data() + sp.size()),\n           nType{nTypeIn},\n@@ -241,7 +242,7 @@ class CDataStream\n \n     std::string str() const\n     {\n-        return (std::string(begin(), end()));\n+        return std::string{UCharCast(data()), UCharCast(data() + size())};\n     }\n \n \n@@ -362,16 +363,16 @@ class CDataStream\n     void SetVersion(int n)       { nVersion = n; }\n     int GetVersion() const       { return nVersion; }\n \n-    void read(char* pch, size_t nSize)\n+    void read(Span<value_type> dst)\n     {\n-        if (nSize == 0) return;\n+        if (dst.size() == 0) return;\n \n         // Read from the beginning of the buffer\n-        unsigned int nReadPosNext = nReadPos + nSize;\n+        unsigned int nReadPosNext = nReadPos + dst.size();\n         if (nReadPosNext > vch.size()) {\n             throw std::ios_base::failure(\"CDataStream::read(): end of data\");\n         }\n-        memcpy(pch, &vch[nReadPos], nSize);\n+        memcpy(dst.data(), &vch[nReadPos], dst.size());\n         if (nReadPosNext == vch.size())\n         {\n             nReadPos = 0;\n@@ -399,18 +400,18 @@ class CDataStream\n         nReadPos = nReadPosNext;\n     }\n \n-    void write(const char* pch, size_t nSize)\n+    void write(Span<const value_type> src)\n     {\n         // Write to the end of the buffer\n-        vch.insert(vch.end(), pch, pch + nSize);\n+        vch.insert(vch.end(), src.data(), src.end());\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s) const\n     {\n         // Special case: stream << stream concatenates like stream += stream\n         if (!vch.empty())\n-            s.write((char*)vch.data(), vch.size() * sizeof(value_type));\n+            s.write(MakeByteSpan(vch));\n     }\n \n     template<typename T>\n@@ -441,7 +442,7 @@ class CDataStream\n         }\n \n         for (size_type i = 0, j = 0; i != size(); i++) {\n-            vch[i] ^= key[j++];\n+            vch[i] ^= std::byte{key[j++]};\n \n             // This potentially acts on very many bytes of data, so it's\n             // important that we calculate `j`, i.e. the `key` index in this\n@@ -614,12 +615,13 @@ class CAutoFile\n     int GetType() const          { return nType; }\n     int GetVersion() const       { return nVersion; }\n \n-    void read(char* pch, size_t nSize)\n+    void read(Span<std::byte> dst)\n     {\n         if (!file)\n             throw std::ios_base::failure(\"CAutoFile::read: file handle is nullptr\");\n-        if (fread(pch, 1, nSize, file) != nSize)\n+        if (fread(dst.data(), 1, dst.size(), file) != dst.size()) {\n             throw std::ios_base::failure(feof(file) ? \"CAutoFile::read: end of file\" : \"CAutoFile::read: fread failed\");\n+        }\n     }\n \n     void ignore(size_t nSize)\n@@ -635,12 +637,13 @@ class CAutoFile\n         }\n     }\n \n-    void write(const char* pch, size_t nSize)\n+    void write(Span<const std::byte> src)\n     {\n         if (!file)\n             throw std::ios_base::failure(\"CAutoFile::write: file handle is nullptr\");\n-        if (fwrite(pch, 1, nSize, file) != nSize)\n+        if (fwrite(src.data(), 1, src.size(), file) != src.size()) {\n             throw std::ios_base::failure(\"CAutoFile::write: write failed\");\n+        }\n     }\n \n     template<typename T>\n@@ -681,7 +684,7 @@ class CBufferedFile\n     uint64_t nReadPos;    //!< how many bytes have been read from this\n     uint64_t nReadLimit;  //!< up to which position we're allowed to read\n     uint64_t nRewind;     //!< how many bytes we guarantee to rewind\n-    std::vector<char> vchBuf; //!< the buffer\n+    std::vector<std::byte> vchBuf; //!< the buffer\n \n protected:\n     //! read data from the source to fill the buffer\n@@ -702,8 +705,8 @@ class CBufferedFile\n     }\n \n public:\n-    CBufferedFile(FILE *fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn) :\n-        nType(nTypeIn), nVersion(nVersionIn), nSrcPos(0), nReadPos(0), nReadLimit(std::numeric_limits<uint64_t>::max()), nRewind(nRewindIn), vchBuf(nBufSize, 0)\n+    CBufferedFile(FILE* fileIn, uint64_t nBufSize, uint64_t nRewindIn, int nTypeIn, int nVersionIn)\n+        : nType(nTypeIn), nVersion(nVersionIn), nSrcPos(0), nReadPos(0), nReadLimit(std::numeric_limits<uint64_t>::max()), nRewind(nRewindIn), vchBuf(nBufSize, std::byte{0})\n     {\n         if (nRewindIn >= nBufSize)\n             throw std::ios_base::failure(\"Rewind limit must be less than buffer size\");\n@@ -736,22 +739,23 @@ class CBufferedFile\n     }\n \n     //! read a number of bytes\n-    void read(char *pch, size_t nSize) {\n-        if (nSize + nReadPos > nReadLimit)\n+    void read(Span<std::byte> dst)\n+    {\n+        if (dst.size() + nReadPos > nReadLimit) {\n             throw std::ios_base::failure(\"Read attempted past buffer limit\");\n-        while (nSize > 0) {\n+        }\n+        while (dst.size() > 0) {\n             if (nReadPos == nSrcPos)\n                 Fill();\n             unsigned int pos = nReadPos % vchBuf.size();\n-            size_t nNow = nSize;\n+            size_t nNow = dst.size();\n             if (nNow + pos > vchBuf.size())\n                 nNow = vchBuf.size() - pos;\n             if (nNow + nReadPos > nSrcPos)\n                 nNow = nSrcPos - nReadPos;\n-            memcpy(pch, &vchBuf[pos], nNow);\n+            memcpy(dst.data(), &vchBuf[pos], nNow);\n             nReadPos += nNow;\n-            pch += nNow;\n-            nSize -= nNow;\n+            dst = dst.subspan(nNow);\n         }\n     }\n \n@@ -794,12 +798,14 @@ class CBufferedFile\n     }\n \n     //! search for a given byte in the stream, and remain positioned on it\n-    void FindByte(char ch) {\n+    void FindByte(uint8_t ch)\n+    {\n         while (true) {\n             if (nReadPos == nSrcPos)\n                 Fill();\n-            if (vchBuf[nReadPos % vchBuf.size()] == ch)\n+            if (vchBuf[nReadPos % vchBuf.size()] == std::byte{ch}) {\n                 break;\n+            }\n             nReadPos++;\n         }\n     }"
      },
      {
        "sha": "d5785f85d5c17cb9874601a81ac370072c3c4ae3",
        "filename": "src/support/allocators/zeroafterfree.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/support/allocators/zeroafterfree.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/support/allocators/zeroafterfree.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/zeroafterfree.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -41,6 +41,6 @@ struct zero_after_free_allocator : public std::allocator<T> {\n };\n \n /** Byte-vector that clears its contents before deletion. */\n-using SerializeData = std::vector<uint8_t, zero_after_free_allocator<uint8_t>>;\n+using SerializeData = std::vector<std::byte, zero_after_free_allocator<std::byte>>;\n \n #endif // BITCOIN_SUPPORT_ALLOCATORS_ZEROAFTERFREE_H"
      },
      {
        "sha": "f66036af2e28078b8787aa59bbb500924ff48aa7",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -43,8 +43,9 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n     stream << filter;\n \n     std::vector<uint8_t> expected = ParseHex(\"03614e9b050000000000000001\");\n+    auto result{MakeUCharSpan(stream)};\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n+    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n \n     BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"Bloom filter doesn't contain just-inserted object!\");\n }\n@@ -69,8 +70,9 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n     stream << filter;\n \n     std::vector<uint8_t> expected = ParseHex(\"03ce4299050000000100008001\");\n+    auto result{MakeUCharSpan(stream)};\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n+    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n }\n \n BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n@@ -89,8 +91,9 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_key)\n     stream << filter;\n \n     std::vector<unsigned char> expected = ParseHex(\"038fc16b080000000000000001\");\n+    auto result{MakeUCharSpan(stream)};\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(stream.begin(), stream.end(), expected.begin(), expected.end());\n+    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n }\n \n BOOST_AUTO_TEST_CASE(bloom_match)\n@@ -341,8 +344,9 @@ BOOST_AUTO_TEST_CASE(merkle_block_3_and_serialize)\n     merkleStream << merkleBlock;\n \n     std::vector<uint8_t> expected = ParseHex(\"0100000079cda856b143d9db2c1caff01d1aecc8630d30625d10e8b4b8b0000000000000b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f196367291b4d4c86041b8fa45d630100000001b50cc069d6a3e33e3ff84a5c41d9d3febe7c770fdcc96b2c3ff60abe184f19630101\");\n+    auto result{MakeUCharSpan(merkleStream)};\n \n-    BOOST_CHECK_EQUAL_COLLECTIONS(expected.begin(), expected.end(), merkleStream.begin(), merkleStream.end());\n+    BOOST_CHECK_EQUAL_COLLECTIONS(expected.begin(), expected.end(), result.begin(), result.end());\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_4)"
      },
      {
        "sha": "3b410930ed876392f54775e111dcdffbf710f191",
        "filename": "src/test/fuzz/autofile.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/fuzz/autofile.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/fuzz/autofile.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/autofile.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -23,16 +23,16 @@ FUZZ_TARGET(autofile)\n         CallOneOf(\n             fuzzed_data_provider,\n             [&] {\n-                std::array<uint8_t, 4096> arr{};\n+                std::array<std::byte, 4096> arr{};\n                 try {\n-                    auto_file.read((char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                    auto_file.read({arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096)});\n                 } catch (const std::ios_base::failure&) {\n                 }\n             },\n             [&] {\n-                const std::array<uint8_t, 4096> arr{};\n+                const std::array<std::byte, 4096> arr{};\n                 try {\n-                    auto_file.write((const char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                    auto_file.write({arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096)});\n                 } catch (const std::ios_base::failure&) {\n                 }\n             },"
      },
      {
        "sha": "a8c3318629443e4c7d111da51f2000a0e97aeee0",
        "filename": "src/test/fuzz/buffered_file.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/fuzz/buffered_file.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/fuzz/buffered_file.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/buffered_file.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -33,9 +33,9 @@ FUZZ_TARGET(buffered_file)\n             CallOneOf(\n                 fuzzed_data_provider,\n                 [&] {\n-                    std::array<uint8_t, 4096> arr{};\n+                    std::array<std::byte, 4096> arr{};\n                     try {\n-                        opt_buffered_file->read((char*)arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096));\n+                        opt_buffered_file->read({arr.data(), fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096)});\n                     } catch (const std::ios_base::failure&) {\n                     }\n                 },\n@@ -53,7 +53,7 @@ FUZZ_TARGET(buffered_file)\n                         return;\n                     }\n                     try {\n-                        opt_buffered_file->FindByte(fuzzed_data_provider.ConsumeIntegral<char>());\n+                        opt_buffered_file->FindByte(fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n                     } catch (const std::ios_base::failure&) {\n                     }\n                 },"
      },
      {
        "sha": "f00ee5cda00ca65525488e565af55aa47b395d92",
        "filename": "src/test/fuzz/rpc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/fuzz/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/fuzz/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/rpc.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -266,7 +266,7 @@ std::string ConsumeScalarRPCArgument(FuzzedDataProvider& fuzzed_data_provider)\n             }\n             CDataStream data_stream{SER_NETWORK, PROTOCOL_VERSION};\n             data_stream << *opt_psbt;\n-            r = EncodeBase64({data_stream.begin(), data_stream.end()});\n+            r = EncodeBase64(data_stream);\n         },\n         [&] {\n             // base58 encoded key"
      },
      {
        "sha": "d0fa8e3b10bb8654ec04a202002ac4eddc150059",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -155,10 +155,10 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n     if (libconsensus_flags == flags) {\n         int expectedSuccessCode = expect ? 1 : 0;\n         if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), txCredit.vout[0].nValue, stream.data(), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);\n+            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), txCredit.vout[0].nValue, UCharCast(stream.data()), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);\n         } else {\n-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), 0, stream.data(), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);\n-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);\n+            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), 0, UCharCast(stream.data()), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);\n+            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), 0, libconsensus_flags, nullptr) == expectedSuccessCode, message);\n         }\n     }\n #endif\n@@ -1520,7 +1520,7 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_returns_true)\n     stream << spendTx;\n \n     bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size(), nIn, libconsensus_flags, &err);\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);\n     BOOST_CHECK_EQUAL(result, 1);\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_OK);\n }\n@@ -1543,7 +1543,7 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_index_err)\n     stream << spendTx;\n \n     bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size(), nIn, libconsensus_flags, &err);\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);\n     BOOST_CHECK_EQUAL(result, 0);\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_INDEX);\n }\n@@ -1566,7 +1566,7 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_size)\n     stream << spendTx;\n \n     bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size() * 2, nIn, libconsensus_flags, &err);\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size() * 2, nIn, libconsensus_flags, &err);\n     BOOST_CHECK_EQUAL(result, 0);\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n }\n@@ -1589,7 +1589,7 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_serialization)\n     stream << 0xffffffff;\n \n     bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size(), nIn, libconsensus_flags, &err);\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);\n     BOOST_CHECK_EQUAL(result, 0);\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_DESERIALIZE);\n }\n@@ -1612,7 +1612,7 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_amount_required_err)\n     stream << spendTx;\n \n     bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size(), nIn, libconsensus_flags, &err);\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);\n     BOOST_CHECK_EQUAL(result, 0);\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);\n }\n@@ -1635,7 +1635,7 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     stream << spendTx;\n \n     bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), stream.data(), stream.size(), nIn, libconsensus_flags, &err);\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), UCharCast(stream.data()), stream.size(), nIn, libconsensus_flags, &err);\n     BOOST_CHECK_EQUAL(result, 0);\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }"
      },
      {
        "sha": "bd8869d0b91b49427b20c40d1d925ab341c26a7f",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 23,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -186,76 +186,78 @@ BOOST_AUTO_TEST_CASE(noncanonical)\n     std::vector<char>::size_type n;\n \n     // zero encoded with three bytes:\n-    ss.write(\"\\xfd\\x00\\x00\", 3);\n+    ss.write(MakeByteSpan(\"\\xfd\\x00\\x00\").first(3));\n     BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0xfc encoded with three bytes:\n-    ss.write(\"\\xfd\\xfc\\x00\", 3);\n+    ss.write(MakeByteSpan(\"\\xfd\\xfc\\x00\").first(3));\n     BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0xfd encoded with three bytes is OK:\n-    ss.write(\"\\xfd\\xfd\\x00\", 3);\n+    ss.write(MakeByteSpan(\"\\xfd\\xfd\\x00\").first(3));\n     n = ReadCompactSize(ss);\n     BOOST_CHECK(n == 0xfd);\n \n     // zero encoded with five bytes:\n-    ss.write(\"\\xfe\\x00\\x00\\x00\\x00\", 5);\n+    ss.write(MakeByteSpan(\"\\xfe\\x00\\x00\\x00\\x00\").first(5));\n     BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0xffff encoded with five bytes:\n-    ss.write(\"\\xfe\\xff\\xff\\x00\\x00\", 5);\n+    ss.write(MakeByteSpan(\"\\xfe\\xff\\xff\\x00\\x00\").first(5));\n     BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // zero encoded with nine bytes:\n-    ss.write(\"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 9);\n+    ss.write(MakeByteSpan(\"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\").first(9));\n     BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n \n     // 0x01ffffff encoded with nine bytes:\n-    ss.write(\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\\x00\", 9);\n+    ss.write(MakeByteSpan(\"\\xff\\xff\\xff\\xff\\x01\\x00\\x00\\x00\\x00\").first(9));\n     BOOST_CHECK_EXCEPTION(ReadCompactSize(ss), std::ios_base::failure, isCanonicalException);\n }\n \n BOOST_AUTO_TEST_CASE(insert_delete)\n {\n+    constexpr auto B2I{[](std::byte b) { return std::to_integer<uint8_t>(b); }};\n+\n     // Test inserting/deleting bytes.\n     CDataStream ss(SER_DISK, 0);\n     BOOST_CHECK_EQUAL(ss.size(), 0U);\n \n-    ss.write(\"\\x00\\x01\\x02\\xff\", 4);\n+    ss.write(MakeByteSpan(\"\\x00\\x01\\x02\\xff\").first(4));\n     BOOST_CHECK_EQUAL(ss.size(), 4U);\n \n-    char c = (char)11;\n+    uint8_t c{11};\n \n     // Inserting at beginning/end/middle:\n-    ss.insert(ss.begin(), c);\n+    ss.insert(ss.begin(), std::byte{c});\n     BOOST_CHECK_EQUAL(ss.size(), 5U);\n-    BOOST_CHECK_EQUAL(ss[0], c);\n-    BOOST_CHECK_EQUAL(ss[1], 0);\n+    BOOST_CHECK_EQUAL(B2I(ss[0]), c);\n+    BOOST_CHECK_EQUAL(B2I(ss[1]), 0);\n \n-    ss.insert(ss.end(), c);\n+    ss.insert(ss.end(), std::byte{c});\n     BOOST_CHECK_EQUAL(ss.size(), 6U);\n-    BOOST_CHECK_EQUAL(ss[4], 0xff);\n-    BOOST_CHECK_EQUAL(ss[5], c);\n+    BOOST_CHECK_EQUAL(B2I(ss[4]), 0xff);\n+    BOOST_CHECK_EQUAL(B2I(ss[5]), c);\n \n-    ss.insert(ss.begin()+2, c);\n+    ss.insert(ss.begin() + 2, std::byte{c});\n     BOOST_CHECK_EQUAL(ss.size(), 7U);\n-    BOOST_CHECK_EQUAL(ss[2], c);\n+    BOOST_CHECK_EQUAL(B2I(ss[2]), c);\n \n     // Delete at beginning/end/middle\n     ss.erase(ss.begin());\n     BOOST_CHECK_EQUAL(ss.size(), 6U);\n-    BOOST_CHECK_EQUAL(ss[0], 0);\n+    BOOST_CHECK_EQUAL(B2I(ss[0]), 0);\n \n     ss.erase(ss.begin()+ss.size()-1);\n     BOOST_CHECK_EQUAL(ss.size(), 5U);\n-    BOOST_CHECK_EQUAL(ss[4], 0xff);\n+    BOOST_CHECK_EQUAL(B2I(ss[4]), 0xff);\n \n     ss.erase(ss.begin()+1);\n     BOOST_CHECK_EQUAL(ss.size(), 4U);\n-    BOOST_CHECK_EQUAL(ss[0], 0);\n-    BOOST_CHECK_EQUAL(ss[1], 1);\n-    BOOST_CHECK_EQUAL(ss[2], 2);\n-    BOOST_CHECK_EQUAL(ss[3], 0xff);\n+    BOOST_CHECK_EQUAL(B2I(ss[0]), 0);\n+    BOOST_CHECK_EQUAL(B2I(ss[1]), 1);\n+    BOOST_CHECK_EQUAL(B2I(ss[2]), 2);\n+    BOOST_CHECK_EQUAL(B2I(ss[3]), 0xff);\n }\n \n BOOST_AUTO_TEST_CASE(class_methods)"
      },
      {
        "sha": "4f8c04a0357df766c89668b0f90f5c933da12345",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -160,7 +160,7 @@ BOOST_AUTO_TEST_CASE(bitstream_reader_writer)\n \n BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n {\n-    std::vector<uint8_t> in;\n+    std::vector<std::byte> in;\n     std::vector<char> expected_xor;\n     std::vector<unsigned char> key;\n     CDataStream ds(in, 0, 0);\n@@ -174,8 +174,8 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n             std::string(expected_xor.begin(), expected_xor.end()),\n             ds.str());\n \n-    in.push_back('\\x0f');\n-    in.push_back('\\xf0');\n+    in.push_back(std::byte{0x0f});\n+    in.push_back(std::byte{0xf0});\n     expected_xor.push_back('\\xf0');\n     expected_xor.push_back('\\x0f');\n \n@@ -195,8 +195,8 @@ BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n \n     in.clear();\n     expected_xor.clear();\n-    in.push_back('\\xf0');\n-    in.push_back('\\x0f');\n+    in.push_back(std::byte{0xf0});\n+    in.push_back(std::byte{0x0f});\n     expected_xor.push_back('\\x0f');\n     expected_xor.push_back('\\x00');\n "
      },
      {
        "sha": "5fa4e147553c129895cd67630d053800c3719924",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_UINT256_H\n #define BITCOIN_UINT256_H\n \n+#include <span.h>\n+\n #include <assert.h>\n #include <cstring>\n #include <stdint.h>\n@@ -96,13 +98,13 @@ class base_blob\n     template<typename Stream>\n     void Serialize(Stream& s) const\n     {\n-        s.write((char*)m_data, sizeof(m_data));\n+        s.write(MakeByteSpan(m_data));\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream& s)\n     {\n-        s.read((char*)m_data, sizeof(m_data));\n+        s.read(MakeWriteableByteSpan(m_data));\n     }\n };\n "
      },
      {
        "sha": "bd9cd01f133a0240de6275f2cdc4b094f5d3ea1b",
        "filename": "src/wallet/bdb.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/wallet/bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/wallet/bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -680,10 +680,10 @@ bool BerkeleyBatch::ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool&\n     // Convert to streams\n     ssKey.SetType(SER_DISK);\n     ssKey.clear();\n-    ssKey.write((char*)datKey.get_data(), datKey.get_size());\n+    ssKey.write({BytePtr(datKey.get_data()), datKey.get_size()});\n     ssValue.SetType(SER_DISK);\n     ssValue.clear();\n-    ssValue.write((char*)datValue.get_data(), datValue.get_size());\n+    ssValue.write({BytePtr(datValue.get_data()), datValue.get_size()});\n     return true;\n }\n \n@@ -755,7 +755,7 @@ bool BerkeleyBatch::ReadKey(CDataStream&& key, CDataStream& value)\n     SafeDbt datValue;\n     int ret = pdb->get(activeTxn, datKey, datValue, 0);\n     if (ret == 0 && datValue.get_data() != nullptr) {\n-        value.write((char*)datValue.get_data(), datValue.get_size());\n+        value.write({BytePtr(datValue.get_data()), datValue.get_size()});\n         return true;\n     }\n     return false;"
      },
      {
        "sha": "d76e5b34f1b950d0be7ea78ec08e22045b149fcc",
        "filename": "src/wallet/dump.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/wallet/dump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/wallet/dump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/dump.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -46,12 +46,12 @@ bool DumpWallet(CWallet& wallet, bilingual_str& error)\n     // Write out a magic string with version\n     std::string line = strprintf(\"%s,%u\\n\", DUMP_MAGIC, DUMP_VERSION);\n     dump_file.write(line.data(), line.size());\n-    hasher.write(line.data(), line.size());\n+    hasher.write(MakeByteSpan(line));\n \n     // Write out the file format\n     line = strprintf(\"%s,%s\\n\", \"format\", db.Format());\n     dump_file.write(line.data(), line.size());\n-    hasher.write(line.data(), line.size());\n+    hasher.write(MakeByteSpan(line));\n \n     if (ret) {\n \n@@ -72,7 +72,7 @@ bool DumpWallet(CWallet& wallet, bilingual_str& error)\n             std::string value_str = HexStr(ss_value);\n             line = strprintf(\"%s,%s\\n\", key_str, value_str);\n             dump_file.write(line.data(), line.size());\n-            hasher.write(line.data(), line.size());\n+            hasher.write(MakeByteSpan(line));\n         }\n     }\n \n@@ -149,7 +149,7 @@ bool CreateFromDump(const std::string& name, const fs::path& wallet_path, biling\n         return false;\n     }\n     std::string magic_hasher_line = strprintf(\"%s,%s\\n\", magic_key, version_value);\n-    hasher.write(magic_hasher_line.data(), magic_hasher_line.size());\n+    hasher.write(MakeByteSpan(magic_hasher_line));\n \n     // Get the stored file format\n     std::string format_key;\n@@ -180,7 +180,7 @@ bool CreateFromDump(const std::string& name, const fs::path& wallet_path, biling\n         warnings.push_back(strprintf(_(\"Warning: Dumpfile wallet format \\\"%s\\\" does not match command line specified format \\\"%s\\\".\"), format_value, file_format));\n     }\n     std::string format_hasher_line = strprintf(\"%s,%s\\n\", format_key, format_value);\n-    hasher.write(format_hasher_line.data(), format_hasher_line.size());\n+    hasher.write(MakeByteSpan(format_hasher_line));\n \n     DatabaseOptions options;\n     DatabaseStatus status;\n@@ -219,7 +219,7 @@ bool CreateFromDump(const std::string& name, const fs::path& wallet_path, biling\n             }\n \n             std::string line = strprintf(\"%s,%s\\n\", key, value);\n-            hasher.write(line.data(), line.size());\n+            hasher.write(MakeByteSpan(line));\n \n             if (key.empty() || value.empty()) {\n                 continue;"
      },
      {
        "sha": "c0d07f47862df24471b6df32b6c02cd85d5ecf54",
        "filename": "src/wallet/sqlite.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/wallet/sqlite.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689/src/wallet/sqlite.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/sqlite.cpp?ref=fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "patch": "@@ -394,9 +394,9 @@ bool SQLiteBatch::ReadKey(CDataStream&& key, CDataStream& value)\n         return false;\n     }\n     // Leftmost column in result is index 0\n-    const char* data = reinterpret_cast<const char*>(sqlite3_column_blob(m_read_stmt, 0));\n-    int data_size = sqlite3_column_bytes(m_read_stmt, 0);\n-    value.write(data, data_size);\n+    const std::byte* data{BytePtr(sqlite3_column_blob(m_read_stmt, 0))};\n+    size_t data_size(sqlite3_column_bytes(m_read_stmt, 0));\n+    value.write({data, data_size});\n \n     sqlite3_clear_bindings(m_read_stmt);\n     sqlite3_reset(m_read_stmt);\n@@ -511,12 +511,12 @@ bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& compl\n     }\n \n     // Leftmost column in result is index 0\n-    const char* key_data = reinterpret_cast<const char*>(sqlite3_column_blob(m_cursor_stmt, 0));\n-    int key_data_size = sqlite3_column_bytes(m_cursor_stmt, 0);\n-    key.write(key_data, key_data_size);\n-    const char* value_data = reinterpret_cast<const char*>(sqlite3_column_blob(m_cursor_stmt, 1));\n-    int value_data_size = sqlite3_column_bytes(m_cursor_stmt, 1);\n-    value.write(value_data, value_data_size);\n+    const std::byte* key_data{BytePtr(sqlite3_column_blob(m_cursor_stmt, 0))};\n+    size_t key_data_size(sqlite3_column_bytes(m_cursor_stmt, 0));\n+    key.write({key_data, key_data_size});\n+    const std::byte* value_data{BytePtr(sqlite3_column_blob(m_cursor_stmt, 1))};\n+    size_t value_data_size(sqlite3_column_bytes(m_cursor_stmt, 1));\n+    value.write({value_data, value_data_size});\n     return true;\n }\n "
      }
    ]
  },
  {
    "sha": "facf8c332cacec39ff52db6f821e51c1bd7f92c7",
    "node_id": "C_kwDOABII59oAKGZhY2Y4YzMzMmNhY2VjMzlmZjUyZGI2ZjgyMWU1MWMxYmQ3ZjkyYzc",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-04T13:58:39Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-11-24T10:32:16Z"
      },
      "message": "Remove unused char serialize",
      "tree": {
        "sha": "4dd64a24c9a1f1aa54332f570ef5972d891db899",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4dd64a24c9a1f1aa54332f570ef5972d891db899"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/facf8c332cacec39ff52db6f821e51c1bd7f92c7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiMBwwAySUI2bvJu7Qz8WEMZc1iNJW1ISYBM47XGFREYSykKkBsaTRhhXwMhv6R\n5XNYSay4vdROGZQQZ1SWj46BQc0/UDmOB5Jp0lsjURwjJRzrRZyfLNJmgcQfcWSp\nhoiXq0lmVAquXNlu8nHBPV+xCx0HrSA6WP6ww/cd3vsFH7AKW8Cuu6984peGR53P\nQ+9chDakHsK2XZK4f6jnlLKHVrJa7YQqbijM+BB98/Ldx8+sS5GlmeqZz4VTuLIt\nsMZA6FFIwmr7wSXbNXxgsUNaAkWYA1CUZTproEAVdpL9AHW1dSf6WgcnMhDsA743\nWYdMy/3xN7caTZpq2AHEkiO7mW4gFtHaj1a6evI+LrUC7YOmrLrFtfjAozku+JcF\nCRzbLmlTIwJfhQ8iIg628ReoQq1cN+pFbGMGXvZVjS3xkdphck+NYxRrD7abJSIO\n0thkMU0FtL148BV75D7CXrzS2NVsjcoY1Z/fAiUuQnjgDuuvRT8u1lGQGMwJet1v\nxUfotLTe\n=5KZP\n-----END PGP SIGNATURE-----",
        "payload": "tree 4dd64a24c9a1f1aa54332f570ef5972d891db899\nparent fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689\nauthor MarcoFalke <falke.marco@gmail.com> 1636034319 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1637749936 +0100\n\nRemove unused char serialize\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/facf8c332cacec39ff52db6f821e51c1bd7f92c7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/facf8c332cacec39ff52db6f821e51c1bd7f92c7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/facf8c332cacec39ff52db6f821e51c1bd7f92c7/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fac833b1fd8dfc3db2b83bb10f83bdb08ecf6689"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 6,
      "deletions": 13
    },
    "files": [
      {
        "sha": "eeb1abcd38735eb12b994785ec3c2a73161a472a",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=facf8c332cacec39ff52db6f821e51c1bd7f92c7",
        "patch": "@@ -194,7 +194,7 @@ template<typename X> const X& ReadWriteAsHelper(const X& x) { return x; }\n     FORMATTER_METHODS(cls, obj)\n \n #ifndef CHAR_EQUALS_INT8\n-template<typename Stream> inline void Serialize(Stream& s, char a    ) { ser_writedata8(s, a); } // TODO Get rid of bare char\n+template <typename Stream> void Serialize(Stream&, char) = delete; // char serialization forbidden. Use uint8_t or int8_t\n #endif\n template<typename Stream> inline void Serialize(Stream& s, int8_t a  ) { ser_writedata8(s, a); }\n template<typename Stream> inline void Serialize(Stream& s, uint8_t a ) { ser_writedata8(s, a); }\n@@ -210,7 +210,7 @@ template<typename Stream> inline void Serialize(Stream& s, const Span<const unsi\n template<typename Stream> inline void Serialize(Stream& s, const Span<unsigned char>& span) { s.write(AsBytes(span)); }\n \n #ifndef CHAR_EQUALS_INT8\n-template<typename Stream> inline void Unserialize(Stream& s, char& a    ) { a = ser_readdata8(s); } // TODO Get rid of bare char\n+template <typename Stream> void Unserialize(Stream&, char) = delete; // char serialization forbidden. Use uint8_t or int8_t\n #endif\n template<typename Stream> inline void Unserialize(Stream& s, int8_t& a  ) { a = ser_readdata8(s); }\n template<typename Stream> inline void Unserialize(Stream& s, uint8_t& a ) { a = ser_readdata8(s); }"
      },
      {
        "sha": "5f898fa03a339b5a6c9481f1849ee3d041645442",
        "filename": "src/test/fuzz/integer.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/test/fuzz/integer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/test/fuzz/integer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/integer.cpp?ref=facf8c332cacec39ff52db6f821e51c1bd7f92c7",
        "patch": "@@ -209,11 +209,6 @@ FUZZ_TARGET_INIT(integer, initialize_integer)\n         stream >> deserialized_i8;\n         assert(i8 == deserialized_i8 && stream.empty());\n \n-        char deserialized_ch;\n-        stream << ch;\n-        stream >> deserialized_ch;\n-        assert(ch == deserialized_ch && stream.empty());\n-\n         bool deserialized_b;\n         stream << b;\n         stream >> deserialized_b;"
      },
      {
        "sha": "82013586d3ab16145764457f91215d220e6b271b",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=facf8c332cacec39ff52db6f821e51c1bd7f92c7",
        "patch": "@@ -337,7 +337,6 @@ void WriteToStream(FuzzedDataProvider& fuzzed_data_provider, Stream& stream) noe\n             CallOneOf(\n                 fuzzed_data_provider,\n                 WRITE_TO_STREAM_CASE(bool, fuzzed_data_provider.ConsumeBool()),\n-                WRITE_TO_STREAM_CASE(char, fuzzed_data_provider.ConsumeIntegral<char>()),\n                 WRITE_TO_STREAM_CASE(int8_t, fuzzed_data_provider.ConsumeIntegral<int8_t>()),\n                 WRITE_TO_STREAM_CASE(uint8_t, fuzzed_data_provider.ConsumeIntegral<uint8_t>()),\n                 WRITE_TO_STREAM_CASE(int16_t, fuzzed_data_provider.ConsumeIntegral<int16_t>()),\n@@ -347,7 +346,7 @@ void WriteToStream(FuzzedDataProvider& fuzzed_data_provider, Stream& stream) noe\n                 WRITE_TO_STREAM_CASE(int64_t, fuzzed_data_provider.ConsumeIntegral<int64_t>()),\n                 WRITE_TO_STREAM_CASE(uint64_t, fuzzed_data_provider.ConsumeIntegral<uint64_t>()),\n                 WRITE_TO_STREAM_CASE(std::string, fuzzed_data_provider.ConsumeRandomLengthString(32)),\n-                WRITE_TO_STREAM_CASE(std::vector<char>, ConsumeRandomLengthIntegralVector<char>(fuzzed_data_provider)));\n+                WRITE_TO_STREAM_CASE(std::vector<uint8_t>, ConsumeRandomLengthIntegralVector<uint8_t>(fuzzed_data_provider)));\n         } catch (const std::ios_base::failure&) {\n             break;\n         }\n@@ -367,7 +366,6 @@ void ReadFromStream(FuzzedDataProvider& fuzzed_data_provider, Stream& stream) no\n             CallOneOf(\n                 fuzzed_data_provider,\n                 READ_FROM_STREAM_CASE(bool),\n-                READ_FROM_STREAM_CASE(char),\n                 READ_FROM_STREAM_CASE(int8_t),\n                 READ_FROM_STREAM_CASE(uint8_t),\n                 READ_FROM_STREAM_CASE(int16_t),\n@@ -377,7 +375,7 @@ void ReadFromStream(FuzzedDataProvider& fuzzed_data_provider, Stream& stream) no\n                 READ_FROM_STREAM_CASE(int64_t),\n                 READ_FROM_STREAM_CASE(uint64_t),\n                 READ_FROM_STREAM_CASE(std::string),\n-                READ_FROM_STREAM_CASE(std::vector<char>));\n+                READ_FROM_STREAM_CASE(std::vector<uint8_t>));\n         } catch (const std::ios_base::failure&) {\n             break;\n         }"
      },
      {
        "sha": "94ba593f94c88af0270820d63d05360371cbf3c5",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/facf8c332cacec39ff52db6f821e51c1bd7f92c7/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=facf8c332cacec39ff52db6f821e51c1bd7f92c7",
        "patch": "@@ -61,7 +61,7 @@ class CSerializeMethodsTestMany : public CSerializeMethodsTestSingle\n \n BOOST_AUTO_TEST_CASE(sizes)\n {\n-    BOOST_CHECK_EQUAL(sizeof(char), GetSerializeSize(char(0), 0));\n+    BOOST_CHECK_EQUAL(sizeof(unsigned char), GetSerializeSize((unsigned char)0, 0));\n     BOOST_CHECK_EQUAL(sizeof(int8_t), GetSerializeSize(int8_t(0), 0));\n     BOOST_CHECK_EQUAL(sizeof(uint8_t), GetSerializeSize(uint8_t(0), 0));\n     BOOST_CHECK_EQUAL(sizeof(int16_t), GetSerializeSize(int16_t(0), 0));\n@@ -74,7 +74,7 @@ BOOST_AUTO_TEST_CASE(sizes)\n     BOOST_CHECK_EQUAL(sizeof(uint8_t), GetSerializeSize(bool(0), 0));\n \n     // Sanity-check GetSerializeSize and c++ type matching\n-    BOOST_CHECK_EQUAL(GetSerializeSize(char(0), 0), 1U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize((unsigned char)0, 0), 1U);\n     BOOST_CHECK_EQUAL(GetSerializeSize(int8_t(0), 0), 1U);\n     BOOST_CHECK_EQUAL(GetSerializeSize(uint8_t(0), 0), 1U);\n     BOOST_CHECK_EQUAL(GetSerializeSize(int16_t(0), 0), 2U);"
      }
    ]
  }
]