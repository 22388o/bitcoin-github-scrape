[
  {
    "sha": "e50c33ea27564a32a1d40e112a5547f0003093af",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNTBjMzNlYTI3NTY0YTMyYTFkNDBlMTEyYTU1NDdmMDAwMzA5M2Fm",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-04-11T20:03:22Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-05-04T05:04:47Z"
      },
      "message": "devtools: add script to verify scriptable changes",
      "tree": {
        "sha": "c04268680c055dbadb21a16fe1235f52d5f8d6cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c04268680c055dbadb21a16fe1235f52d5f8d6cf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e50c33ea27564a32a1d40e112a5547f0003093af",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e50c33ea27564a32a1d40e112a5547f0003093af",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e50c33ea27564a32a1d40e112a5547f0003093af",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e50c33ea27564a32a1d40e112a5547f0003093af/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c924011f535c46b3bc02bef8b7e2a8ad559d78d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c924011f535c46b3bc02bef8b7e2a8ad559d78d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c924011f535c46b3bc02bef8b7e2a8ad559d78d"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 40,
      "deletions": 0
    },
    "files": [
      {
        "sha": "97bb475e4babf692a556b98db8f50caef7104f41",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e50c33ea27564a32a1d40e112a5547f0003093af/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e50c33ea27564a32a1d40e112a5547f0003093af/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=e50c33ea27564a32a1d40e112a5547f0003093af",
        "patch": "@@ -43,6 +43,7 @@ install:\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n before_script:\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n     - unset CC; unset CXX\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n     - mkdir -p depends/SDKs depends/sdk-sources"
      },
      {
        "sha": "add4bb4883d41b495109672df6d44ebe9691e1d1",
        "filename": "contrib/devtools/commit-script-check.sh",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e50c33ea27564a32a1d40e112a5547f0003093af/contrib/devtools/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e50c33ea27564a32a1d40e112a5547f0003093af/contrib/devtools/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/commit-script-check.sh?ref=e50c33ea27564a32a1d40e112a5547f0003093af",
        "patch": "@@ -0,0 +1,39 @@\n+#!/bin/sh\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# This simple script checks for commits beginning with: scripted-diff:\n+# If found, looks for a script between the lines -BEGIN VERIFY SCRIPT- and\n+# -END VERIFY SCRIPT-. If no ending is found, it reads until the end of the\n+# commit message.\n+\n+# The resulting script should exactly transform the previous commit into the current\n+# one. Any remaining diff signals an error.\n+\n+if test \"x$1\" = \"x\"; then\n+    echo \"Usage: $0 <commit>...\"\n+    exit 1\n+fi\n+\n+RET=0\n+PREV_BRANCH=`git name-rev --name-only HEAD`\n+PREV_HEAD=`git rev-parse HEAD`\n+for i in `git rev-list --reverse $1`; do\n+    git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\" || continue\n+    git checkout --quiet $i^ || exit\n+    SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n+    if test \"x$SCRIPT\" = \"x\"; then\n+        echo \"Error: missing script for: $i\"\n+        echo \"Failed\"\n+        RET=1\n+    else\n+        echo \"Running script for: $i\"\n+        echo \"$SCRIPT\"\n+        eval \"$SCRIPT\"\n+        git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+    fi\n+    git reset --quiet --hard HEAD\n+done\n+git checkout --quiet $PREV_BRANCH 2>/dev/null || git checkout --quiet $PREV_HEAD\n+exit $RET"
      }
    ]
  },
  {
    "sha": "9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZmYwYTUxMTY0ZjBlN2FhMGNlNTQyNGFhMzhkZGJkZGQzNTdmYTJj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-04-11T16:13:55Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-05-04T05:04:47Z"
      },
      "message": "scripted-diff: net: Use accessor rather than node's id directly\n\n-BEGIN VERIFY SCRIPT-\nsed -i \"s/\\(node\\|to\\|from\\)->id/\\1->GetId()/\" src/net.cpp src/net_processing.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "c2feb571123cf57d05b9c440e4a6969932efa005",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2feb571123cf57d05b9c440e4a6969932efa005"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e50c33ea27564a32a1d40e112a5547f0003093af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e50c33ea27564a32a1d40e112a5547f0003093af",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e50c33ea27564a32a1d40e112a5547f0003093af"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 55,
      "deletions": 55
    },
    "files": [
      {
        "sha": "380b181ae0abe9e68c59c7966b1fa5a7699dd6a7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
        "patch": "@@ -946,7 +946,7 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            NodeEvictionCandidate candidate = {node->id, node->nTimeConnected, node->nMinPingUsecTime,\n+            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                (node->nServices & nRelevantServices) == nRelevantServices,\n                                                node->fRelayTxes, node->pfilter != NULL, node->addr, node->nKeyedNetGroup};\n@@ -1372,7 +1372,7 @@ void CConnman::ThreadSocketHandler()\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n+                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n@@ -1392,7 +1392,7 @@ void CConnman::ThreadSocketHandler()\n                 }\n                 else if (!pnode->fSuccessfullyConnected)\n                 {\n-                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->id);\n+                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n             }\n@@ -2485,7 +2485,7 @@ bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(cs_vNodes);\n     for(CNode* pnode : vNodes) {\n-        if (id == pnode->id) {\n+        if (id == pnode->GetId()) {\n             pnode->fDisconnect = true;\n             return true;\n         }\n@@ -2742,7 +2742,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n     size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n     std::vector<unsigned char> serializedHeader;\n     serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n@@ -2780,7 +2780,7 @@ bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n     CNode* found = nullptr;\n     LOCK(cs_vNodes);\n     for (auto&& pnode : vNodes) {\n-        if(pnode->id == id) {\n+        if(pnode->GetId() == id) {\n             found = pnode;\n             break;\n         }"
      },
      {
        "sha": "fb83d5ec8f5aad98af7a0dde1f927b7a334366ed",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 49,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
        "patch": "@@ -815,7 +815,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n             LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n-                    hashBlock.ToString(), pnode->id);\n+                    hashBlock.ToString(), pnode->GetId());\n             connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n             state.pindexBestHeaderSent = pindex;\n         }\n@@ -950,7 +950,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n \n     auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n         if (pnode->nVersion >= CADDR_TIME_VERSION) {\n-            uint64_t hashKey = CSipHasher(hasher).Write(pnode->id).Finalize();\n+            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n                      std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);\n@@ -1176,7 +1176,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n-            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId());\n             return;\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n@@ -1189,7 +1189,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n \n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (IsArgSet(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -1268,7 +1268,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n-            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, nServices, pfrom->nServicesExpected);\n+            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n@@ -1278,7 +1278,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, nVersion);\n+            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n@@ -1380,7 +1380,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                   cleanSubVer, pfrom->nVersion,\n-                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->id,\n+                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                   remoteAddr);\n \n         int64_t nTimeOffset = nTime - GetTime();\n@@ -1562,7 +1562,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 return true;\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n@@ -1577,14 +1577,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n-                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n             else\n             {\n                 pfrom->AddInventoryKnown(inv);\n                 if (fBlocksOnly) {\n-                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n                     pfrom->AskFor(inv);\n                 }\n@@ -1610,10 +1610,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n-        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());\n \n         if (vInv.size() > 0) {\n-            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());\n         }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n@@ -1653,7 +1653,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n+        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n@@ -1703,7 +1703,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1715,7 +1715,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->id, MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n@@ -1740,7 +1740,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n         if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n-            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1765,7 +1765,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -1795,7 +1795,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n         {\n-            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1828,7 +1828,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->nLastTXTime = GetTime();\n \n             LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->id,\n+                pfrom->GetId(),\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n@@ -1948,10 +1948,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // case.\n                 int nDoS = 0;\n                 if (!state.IsInvalid(nDoS) || nDoS == 0) {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->id);\n+                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n                 } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->id, FormatStateMessage(state));\n+                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n                 }\n             }\n         }\n@@ -1963,7 +1963,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (state.IsInvalid(nDoS))\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->id,\n+                pfrom->GetId(),\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n@@ -2000,7 +2000,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n-                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                 return true;\n             }\n         }\n@@ -2079,7 +2079,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n-                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->id);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n@@ -2184,7 +2184,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n-                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n+                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n                 return true;\n             }\n \n@@ -2193,7 +2193,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n-                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n                 // Might have collided, fall back to getdata now :(\n@@ -2281,7 +2281,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n                     pindexBestHeader->nHeight,\n-                    pfrom->id, nodestate->nUnconnectingHeaders);\n+                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n             // we can use this peer to download.\n@@ -2319,7 +2319,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n         }\n         nodestate->nUnconnectingHeaders = 0;\n \n@@ -2330,7 +2330,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n-            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n@@ -2370,7 +2370,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                     MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->id);\n+                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n                 }\n                 if (vGetData.size() > 1) {\n                     LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n@@ -2393,7 +2393,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n-        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n         // Process all blocks from whitelisted peers, even if not requested,\n         // unless we're still syncing with the network.\n@@ -2425,14 +2425,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Making nodes which are behind NAT and can only make outgoing connections ignore\n         // the getaddr message mitigates the attack.\n         if (!pfrom->fInbound) {\n-            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n         if (pfrom->fSentAddr) {\n-            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n         pfrom->fSentAddr = true;\n@@ -2533,7 +2533,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!(sProblem.empty())) {\n             LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->id,\n+                pfrom->GetId(),\n                 sProblem,\n                 pfrom->nPingNonceSent,\n                 nonce,\n@@ -2610,7 +2610,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(pfrom->cs_feeFilter);\n                 pfrom->minFeeFilter = newFeeFilter;\n             }\n-            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n     }\n \n@@ -2621,7 +2621,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     else {\n         // Ignore unknown commands for extensibility\n-        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n+        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n     }\n \n \n@@ -2701,7 +2701,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     msg.SetVersion(pfrom->GetRecvVersion());\n     // Scan for message start\n     if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n-        LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->id);\n+        LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());\n         pfrom->fDisconnect = true;\n         return false;\n     }\n@@ -2710,7 +2710,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     CMessageHeader& hdr = msg.hdr;\n     if (!hdr.IsValid(chainparams.MessageStart()))\n     {\n-        LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n+        LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());\n         return fMoreWork;\n     }\n     std::string strCommand = hdr.GetCommand();\n@@ -2770,7 +2770,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     }\n \n     if (!fRet) {\n-        LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->id);\n+        LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n     }\n \n     LOCK(cs_main);\n@@ -2899,7 +2899,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n-                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n+                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n@@ -2929,7 +2929,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n-            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;\n@@ -2984,7 +2984,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->id);\n+                            vHeaders.front().GetHash().ToString(), pto->GetId());\n \n                     int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n@@ -3014,10 +3014,10 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n                                 vHeaders.front().GetHash().ToString(),\n-                                vHeaders.back().GetHash().ToString(), pto->id);\n+                                vHeaders.back().GetHash().ToString(), pto->GetId());\n                     } else {\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n-                                vHeaders.front().GetHash().ToString(), pto->id);\n+                                vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n@@ -3046,7 +3046,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     if (!PeerHasHeader(&state, pindex)) {\n                         pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n                         LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n-                            pto->id, hashToAnnounce.ToString());\n+                            pto->GetId(), hashToAnnounce.ToString());\n                     }\n                 }\n             }\n@@ -3193,7 +3193,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n-            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n             pto->fDisconnect = true;\n             return true;\n         }\n@@ -3206,7 +3206,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n             if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->id);\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }\n@@ -3225,7 +3225,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->id);\n+                    pindex->nHeight, pto->GetId());\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n@@ -3243,7 +3243,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n             {\n-                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      }
    ]
  },
  {
    "sha": "0f3471f3ad349374556e671f27de0824dbe57dd6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZjM0NzFmM2FkMzQ5Mzc0NTU2ZTY3MWYyN2RlMDgyNGRiZTU3ZGQ2",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-04-11T16:11:27Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2017-05-04T05:04:47Z"
      },
      "message": "net: make CNode's id private",
      "tree": {
        "sha": "8c11368c0799e9abe0b6f064b2fd10b9308c4a8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c11368c0799e9abe0b6f064b2fd10b9308c4a8c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0f3471f3ad349374556e671f27de0824dbe57dd6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f3471f3ad349374556e671f27de0824dbe57dd6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0f3471f3ad349374556e671f27de0824dbe57dd6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f3471f3ad349374556e671f27de0824dbe57dd6/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ff0a51164f0e7aa0ce5424aa38ddbddd357fa2c"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "c7b1a1e1081469c4cf3f0d61e4d2b9972310d83c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f3471f3ad349374556e671f27de0824dbe57dd6/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f3471f3ad349374556e671f27de0824dbe57dd6/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=0f3471f3ad349374556e671f27de0824dbe57dd6",
        "patch": "@@ -2623,10 +2623,10 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     nTimeConnected(GetSystemTimeInSeconds()),\n     addr(addrIn),\n     fInbound(fInboundIn),\n-    id(idIn),\n     nKeyedNetGroup(nKeyedNetGroupIn),\n     addrKnown(5000, 0.001),\n     filterInventoryKnown(50000, 0.000001),\n+    id(idIn),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),\n     nMyStartingHeight(nMyStartingHeightIn),"
      },
      {
        "sha": "8b0ebc0ffecf1a03893201ac03d521577f20f0cc",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f3471f3ad349374556e671f27de0824dbe57dd6/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f3471f3ad349374556e671f27de0824dbe57dd6/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=0f3471f3ad349374556e671f27de0824dbe57dd6",
        "patch": "@@ -611,7 +611,6 @@ class CNode\n     CCriticalSection cs_filter;\n     CBloomFilter* pfilter;\n     std::atomic<int> nRefCount;\n-    const NodeId id;\n \n     const uint64_t nKeyedNetGroup;\n     std::atomic_bool fPauseRecv;\n@@ -682,6 +681,7 @@ class CNode\n private:\n     CNode(const CNode&);\n     void operator=(const CNode&);\n+    const NodeId id;\n \n \n     const uint64_t nLocalHostNonce;"
      }
    ]
  }
]