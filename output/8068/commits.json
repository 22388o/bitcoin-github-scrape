[
  {
    "sha": "96806c39f4ef395975c0cd7d654dcb71c4790be2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjgwNmMzOWY0ZWYzOTU5NzVjMGNkN2Q2NTRkY2I3MWM0NzkwYmUy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-18T16:16:36Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Stop trimming when mapTx is empty",
      "tree": {
        "sha": "0f5570a2bb4d8de5e5b20b79653b6d10f366b84a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f5570a2bb4d8de5e5b20b79653b6d10f366b84a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96806c39f4ef395975c0cd7d654dcb71c4790be2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96806c39f4ef395975c0cd7d654dcb71c4790be2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/96806c39f4ef395975c0cd7d654dcb71c4790be2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96806c39f4ef395975c0cd7d654dcb71c4790be2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a072d1a83787e786d074a4b5871b0b961781f7c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a072d1a83787e786d074a4b5871b0b961781f7c6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a072d1a83787e786d074a4b5871b0b961781f7c6"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "18c54b08bc2d32ff734f71f2791892048ae9b6ca",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96806c39f4ef395975c0cd7d654dcb71c4790be2/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96806c39f4ef395975c0cd7d654dcb71c4790be2/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=96806c39f4ef395975c0cd7d654dcb71c4790be2",
        "patch": "@@ -1075,7 +1075,7 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe\n \n     unsigned nTxnRemoved = 0;\n     CFeeRate maxFeeRateRemoved(0);\n-    while (DynamicMemoryUsage() > sizelimit) {\n+    while (!mapTx.empty() && DynamicMemoryUsage() > sizelimit) {\n         indexed_transaction_set::index<descendant_score>::type::iterator it = mapTx.get<descendant_score>().begin();\n \n         // We set the new mempool min fee to the feerate of the removed set, plus the"
      }
    ]
  },
  {
    "sha": "7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YzI5ZWM5NDQ5MGEyZmIwYjVmOWFlYzU2Yzg5ZDBhOWE1OGVlYzc5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-11T01:52:32Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "If AcceptBlockHeader returns true, pindex will be set.\n\nAssert this instead of checking (and then dref'ing later anyway)\nto make sure no one thinks they can change that postcondition of\nAcceptBlockHeader..",
      "tree": {
        "sha": "7a39b8d4cb964bbf6eabc5090cc29f90091e0001",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a39b8d4cb964bbf6eabc5090cc29f90091e0001"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "96806c39f4ef395975c0cd7d654dcb71c4790be2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96806c39f4ef395975c0cd7d654dcb71c4790be2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/96806c39f4ef395975c0cd7d654dcb71c4790be2"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "378d2c70227e39d8499ce28960af25a8a80b7e00",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
        "patch": "@@ -5218,10 +5218,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n         }\n \n-        if (pindexLast)\n-            UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+        assert(pindexLast);\n+        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n \n-        if (nCount == MAX_HEADERS_RESULTS && pindexLast && hasNewHeaders) {\n+        if (nCount == MAX_HEADERS_RESULTS && hasNewHeaders) {\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead."
      }
    ]
  },
  {
    "sha": "cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYmRhNzFjZjA0ZWY2ZjJhYmU2ZWFhNTZjMzE0MGE2ZjVjZmY0ZmVi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-08T23:12:52Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Move context-required checks from CheckBlockHeader to Contextual...",
      "tree": {
        "sha": "bec04ea0ac3712a16c1fbe62e6ebea745ad91c92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bec04ea0ac3712a16c1fbe62e6ebea745ad91c92"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7c29ec94490a2fb0b5f9aec56c89d0a9a58eec79"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 17,
      "deletions": 17
    },
    "files": [
      {
        "sha": "7d267bef7d98447ed7b824e3a660c070cdc0afc2",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
        "patch": "@@ -2241,7 +2241,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     int64_t nTimeStart = GetTimeMicros();\n \n     // Check it again in case a previous version let a bad block in\n-    if (!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime(), !fJustCheck, !fJustCheck))\n+    if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck))\n         return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));\n \n     // verify that the view's current state corresponds to the previous block\n@@ -3258,20 +3258,16 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n     return true;\n }\n \n-bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, int64_t nAdjustedTime, bool fCheckPOW)\n+bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW)\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n         return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n \n-    // Check timestamp\n-    if (block.GetBlockTime() > nAdjustedTime + 2 * 60 * 60)\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n-\n     return true;\n }\n \n-bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, int64_t nAdjustedTime, bool fCheckPOW, bool fCheckMerkleRoot)\n+bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     // These are checks that are independent of context.\n \n@@ -3280,7 +3276,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Check that the header is valid (particularly PoW).  This is mostly\n     // redundant with the call in AcceptBlockHeader.\n-    if (!CheckBlockHeader(block, state, consensusParams, nAdjustedTime, fCheckPOW))\n+    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))\n         return false;\n \n     // Check the merkle root.\n@@ -3346,7 +3342,7 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex * const pindexPrev)\n+bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex * const pindexPrev, int64_t nAdjustedTime)\n {\n     // Check proof of work\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n@@ -3356,6 +3352,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp\n+    if (block.GetBlockTime() > nAdjustedTime + 2 * 60 * 60)\n+        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+\n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     for (int32_t version = 2; version < 5; ++version) // check for version 2, 3 and 4 upgrades\n         if (block.nVersion < version && IsSuperMajority(version, pindexPrev, consensusParams.nMajorityRejectBlockOutdated, consensusParams))\n@@ -3420,7 +3420,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n             return true;\n         }\n \n-        if (!CheckBlockHeader(block, state, chainparams.GetConsensus(), GetAdjustedTime()))\n+        if (!CheckBlockHeader(block, state, chainparams.GetConsensus()))\n             return error(\"%s: Consensus::CheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n         // Get prev block index\n@@ -3436,7 +3436,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n         if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash))\n             return error(\"%s: CheckIndexAgainstCheckpoint(): %s\", __func__, state.GetRejectReason().c_str());\n \n-        if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev))\n+        if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n     }\n     if (pindex == NULL)\n@@ -3569,9 +3569,9 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n     indexDummy.nHeight = pindexPrev->nHeight + 1;\n \n     // NOTE: CheckBlockHeader is called by CheckBlock\n-    if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev))\n+    if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))\n         return error(\"%s: Consensus::ContextualCheckBlockHeader: %s\", __func__, FormatStateMessage(state));\n-    if (!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime(), fCheckPOW, fCheckMerkleRoot))\n+    if (!CheckBlock(block, state, chainparams.GetConsensus(), fCheckPOW, fCheckMerkleRoot))\n         return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));\n     if (!ContextualCheckBlock(block, state, pindexPrev))\n         return error(\"%s: Consensus::ContextualCheckBlock: %s\", __func__, FormatStateMessage(state));\n@@ -3916,7 +3916,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n             return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         // check level 1: verify block validity\n-        if (nCheckLevel >= 1 && !CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime()))\n+        if (nCheckLevel >= 1 && !CheckBlock(block, state, chainparams.GetConsensus()))\n             return error(\"%s: *** found bad block at %d, hash=%s (%s)\\n\", __func__, \n                          pindex->nHeight, pindex->GetBlockHash().ToString(), FormatStateMessage(state));\n         // check level 2: verify undo validity"
      },
      {
        "sha": "56e81ec29cd7a3025272d2ff368b421b4f111973",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
        "patch": "@@ -425,13 +425,13 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus\n /** Functions for validating blocks and updating the block tree */\n \n /** Context-independent validity checks */\n-bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, int64_t nAdjustedTime, bool fCheckPOW = true);\n-bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, int64_t nAdjustedTime, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n+bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true);\n+bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n /** Context-dependent validity checks.\n  *  By \"context\", we mean only the previous block headers, but not the UTXO\n  *  set; UTXO-related validity checks are done in ConnectBlock(). */\n-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex* pindexPrev);\n+bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex* pindexPrev, int64_t nAdjustedTime);\n bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIndex *pindexPrev);\n \n /** Apply the effects of this block (with given index) on the UTXO set represented by coins."
      }
    ]
  },
  {
    "sha": "5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjQ5ZGFjYTVhOGM0ZWJkYzZjOWEzMDkwYWYwZTFiZGRkY2ZiYTFi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-05-18T20:11:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Add COMPACTSIZE wrapper similar to VARINT for serialization",
      "tree": {
        "sha": "e96db6dfe756393dde1cd4fde99c50b89ad295f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e96db6dfe756393dde1cd4fde99c50b89ad295f5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cbda71cf04ef6f2abe6eaa56c3140a6f5cff4feb"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 23,
      "deletions": 0
    },
    "files": [
      {
        "sha": "378ed39074ea36f12069a3f1d3295a32736bc874",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
        "patch": "@@ -373,6 +373,7 @@ I ReadVarInt(Stream& is)\n \n #define FLATDATA(obj) REF(CFlatData((char*)&(obj), (char*)&(obj) + sizeof(obj)))\n #define VARINT(obj) REF(WrapVarInt(REF(obj)))\n+#define COMPACTSIZE(obj) REF(CCompactSize(REF(obj)))\n #define LIMITED_STRING(obj,n) REF(LimitedString< n >(REF(obj)))\n \n /** \n@@ -443,6 +444,28 @@ class CVarInt\n     }\n };\n \n+class CCompactSize\n+{\n+protected:\n+    uint64_t &n;\n+public:\n+    CCompactSize(uint64_t& nIn) : n(nIn) { }\n+\n+    unsigned int GetSerializeSize(int, int) const {\n+        return GetSizeOfCompactSize(n);\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int, int) const {\n+        WriteCompactSize<Stream>(s, n);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int, int) {\n+        n = ReadCompactSize<Stream>(s);\n+    }\n+};\n+\n template<size_t Limit>\n class LimitedString\n {"
      }
    ]
  },
  {
    "sha": "85ad31ede7bc338079c8ae643542fde7ad83ce55",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NWFkMzFlZGU3YmMzMzgwNzljOGFlNjQzNTQyZmRlN2FkODNjZTU1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-15T19:23:57Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Add partial-block block encodings API",
      "tree": {
        "sha": "50015c61de325693c433611358205b913860b539",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/50015c61de325693c433611358205b913860b539"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85ad31ede7bc338079c8ae643542fde7ad83ce55",
      "comment_count": 3,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85ad31ede7bc338079c8ae643542fde7ad83ce55",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/85ad31ede7bc338079c8ae643542fde7ad83ce55",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85ad31ede7bc338079c8ae643542fde7ad83ce55/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5249daca5a8c4ebdc6c9a3090af0e1bdddcfba1b"
      }
    ],
    "stats": {
      "total": 365,
      "additions": 365,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e3eaacdb4c983153611f428041217e18ed8707a1",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85ad31ede7bc338079c8ae643542fde7ad83ce55/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85ad31ede7bc338079c8ae643542fde7ad83ce55/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=85ad31ede7bc338079c8ae643542fde7ad83ce55",
        "patch": "@@ -74,6 +74,7 @@ BITCOIN_CORE_H = \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\\n+  blockencodings.h \\\n   chain.h \\\n   chainparams.h \\\n   chainparamsbase.h \\\n@@ -163,6 +164,7 @@ libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n   addrman.cpp \\\n   bloom.cpp \\\n+  blockencodings.cpp \\\n   chain.cpp \\\n   checkpoints.cpp \\\n   httprpc.cpp \\"
      },
      {
        "sha": "c6b79f4201c55b2448e8f4790176d47e78ef5a80",
        "filename": "src/blockencodings.cpp",
        "status": "added",
        "additions": 158,
        "deletions": 0,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85ad31ede7bc338079c8ae643542fde7ad83ce55/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85ad31ede7bc338079c8ae643542fde7ad83ce55/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=85ad31ede7bc338079c8ae643542fde7ad83ce55",
        "patch": "@@ -0,0 +1,158 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION))\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.BlockTxCount());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1; //index is a uint16_t, so cant overflow here\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // Bucket selection is a simple Binomial distribution. If we assume blocks of\n+        // 10,000 transactions, allowing up to 12 elements per bucket should only fail\n+        // once every ~1.3 million blocks and once every 74,000 blocks in a worst-case\n+        // 16,000-transaction block.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 12)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    std::vector<bool> have_txn(txn_available.size());\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!have_txn[idit->second]) {\n+                txn_available[idit->second] = it->GetSharedTx();\n+                have_txn[idit->second]  = true;\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                txn_available[idit->second].reset();\n+            }\n+        }\n+        // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n+        // the performance win of an early exit here is too good to pass up and worth\n+        // the extra risk.\n+        if (mempool_count == shorttxids.size())\n+            break;\n+    }\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txn_available.size());\n+    return txn_available[index] ? true : false;\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txn_available.size());\n+\n+    size_t tx_missing_offset = 0;\n+    for (size_t i = 0; i < txn_available.size(); i++) {\n+        if (!txn_available[i]) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+        } else\n+            block.vtx[i] = *txn_available[i];\n+    }\n+    if (vtx_missing.size() != tx_missing_offset)\n+        return READ_STATUS_INVALID;\n+\n+    CValidationState state;\n+    if (!CheckBlock(block, state, Params().GetConsensus())) {\n+        // TODO: We really want to just check merkle tree manually here,\n+        // but that is expensive, and CheckBlock caches a block's\n+        // \"checked-status\" (in the CBlock?). CBlock should be able to\n+        // check its own merkle root and cache that check.\n+        if (state.CorruptionPossible())\n+            return READ_STATUS_FAILED; // Possible Short ID collision\n+        return READ_STATUS_INVALID;\n+    }\n+\n+    return READ_STATUS_OK;\n+}"
      },
      {
        "sha": "adc60c85d0ecfb6c812c87e7caa0375f105ca0f8",
        "filename": "src/blockencodings.h",
        "status": "added",
        "additions": 205,
        "deletions": 0,
        "changes": 205,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85ad31ede7bc338079c8ae643542fde7ad83ce55/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85ad31ede7bc338079c8ae643542fde7ad83ce55/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=85ad31ede7bc338079c8ae643542fde7ad83ce55",
        "patch": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+// Dumb helper to handle CTransaction compression at serialize-time\n+struct TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+class BlockTransactionsRequest {\n+public:\n+    // A BlockTransactionsRequest message\n+    uint256 blockhash;\n+    std::vector<uint16_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    if (index > std::numeric_limits<uint16_t>::max())\n+                        throw std::ios_base::failure(\"index overflowed 16 bits\");\n+                    indexes[i] = index;\n+                }\n+            }\n+\n+            uint16_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint16_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 16 bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint64_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(COMPACTSIZE(index));\n+            }\n+        }\n+    }\n+};\n+\n+class BlockTransactions {\n+public:\n+    // A BlockTransactions message\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t txn_size = (uint64_t)txn.size();\n+        READWRITE(COMPACTSIZE(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+// Dumb serialization/storage-helper for CBlockHeaderAndShortTxIDs and PartiallyDownlaodedBlock\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        uint64_t idx = index;\n+        READWRITE(COMPACTSIZE(idx));\n+        if (idx > std::numeric_limits<uint16_t>::max())\n+            throw std::ios_base::failure(\"index overflowed 16-bits\");\n+        index = idx;\n+        READWRITE(REF(TransactionCompressor(tx)));\n+    }\n+};\n+\n+typedef enum ReadStatus_t\n+{\n+    READ_STATUS_OK,\n+    READ_STATUS_INVALID, // Invalid object, peer is sending bogus crap\n+    READ_STATUS_FAILED, // Failed to process object\n+} ReadStatus;\n+\n+class CBlockHeaderAndShortTxIDs {\n+private:\n+    mutable uint64_t shorttxidk0, shorttxidk1;\n+    uint64_t nonce;\n+\n+    void FillShortTxIDSelector() const;\n+\n+    friend class PartiallyDownloadedBlock;\n+\n+    static const int SHORTTXIDS_LENGTH = 6;\n+protected:\n+    std::vector<uint64_t> shorttxids;\n+    std::vector<PrefilledTransaction> prefilledtxn;\n+\n+public:\n+    CBlockHeader header;\n+\n+    // Dummy for deserialization\n+    CBlockHeaderAndShortTxIDs() {}\n+\n+    CBlockHeaderAndShortTxIDs(const CBlock& block);\n+\n+    uint64_t GetShortID(const uint256& txhash) const;\n+\n+    size_t BlockTxCount() const { return shorttxids.size() + prefilledtxn.size(); }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(header);\n+        READWRITE(nonce);\n+\n+        uint64_t shorttxids_size = (uint64_t)shorttxids.size();\n+        READWRITE(COMPACTSIZE(shorttxids_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (shorttxids.size() < shorttxids_size) {\n+                shorttxids.resize(std::min((uint64_t)(1000 + shorttxids.size()), shorttxids_size));\n+                for (; i < shorttxids.size(); i++) {\n+                    uint32_t lsb = 0; uint16_t msb = 0;\n+                    READWRITE(lsb);\n+                    READWRITE(msb);\n+                    shorttxids[i] = (uint64_t(msb) << 32) | uint64_t(lsb);\n+                    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids serialization assumes 6-byte shorttxids\");\n+                }\n+            }\n+        } else {\n+            for (size_t i = 0; i < shorttxids.size(); i++) {\n+                uint32_t lsb = shorttxids[i] & 0xffffffff;\n+                uint16_t msb = (shorttxids[i] >> 32) & 0xffff;\n+                READWRITE(lsb);\n+                READWRITE(msb);\n+            }\n+        }\n+\n+        READWRITE(prefilledtxn);\n+\n+        if (ser_action.ForRead())\n+            FillShortTxIDSelector();\n+    }\n+};\n+\n+class PartiallyDownloadedBlock {\n+protected:\n+    std::vector<std::shared_ptr<const CTransaction> > txn_available;\n+    CTxMemPool* pool;\n+public:\n+    CBlockHeader header;\n+    PartiallyDownloadedBlock(CTxMemPool* poolIn) : pool(poolIn) {}\n+\n+    ReadStatus InitData(const CBlockHeaderAndShortTxIDs& cmpctblock);\n+    bool IsTxAvailable(size_t index) const;\n+    ReadStatus FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const;\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNGY4ZjE0YWRjNzlmNzFlYjNjZmQzYThkNmRiZmU5ODc4ZDFlM2Y2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-26T00:04:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Add TestMemPoolEntryHelper::FromTx version for CTransaction",
      "tree": {
        "sha": "fb02f4cc670a389ad47495fdc4c94c73776eeba7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb02f4cc670a389ad47495fdc4c94c73776eeba7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "85ad31ede7bc338079c8ae643542fde7ad83ce55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85ad31ede7bc338079c8ae643542fde7ad83ce55",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/85ad31ede7bc338079c8ae643542fde7ad83ce55"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 6,
      "deletions": 1
    },
    "files": [
      {
        "sha": "199670918830f97149158059410845e137ae586d",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
        "patch": "@@ -126,7 +126,11 @@ TestChain100Setup::~TestChain100Setup()\n \n CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(CMutableTransaction &tx, CTxMemPool *pool) {\n     CTransaction txn(tx);\n-    bool hasNoDependencies = pool ? pool->HasNoInputsOf(tx) : hadNoDependencies;\n+    return FromTx(txn, pool);\n+}\n+\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(CTransaction &txn, CTxMemPool *pool) {\n+    bool hasNoDependencies = pool ? pool->HasNoInputsOf(txn) : hadNoDependencies;\n     // Hack to assume either its completely dependent on other mempool txs or not at all\n     CAmount inChainValue = hasNoDependencies ? txn.GetValueOut() : 0;\n "
      },
      {
        "sha": "78b87e7109b7d6f747a5dafc52aae9d2e9581c9c",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
        "patch": "@@ -78,6 +78,7 @@ struct TestMemPoolEntryHelper\n         hadNoDependencies(false), spendsCoinbase(false), sigOpCount(1) { }\n     \n     CTxMemPoolEntry FromTx(CMutableTransaction &tx, CTxMemPool *pool = NULL);\n+    CTxMemPoolEntry FromTx(CTransaction &tx, CTxMemPool *pool = NULL);\n \n     // Change the default value\n     TestMemPoolEntryHelper &Fee(CAmount _fee) { nFee = _fee; return *this; }"
      }
    ]
  },
  {
    "sha": "e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2IyMjIyMTQ0YTBkZWY3ZmE2MTgyMmJkZDExZmI3ZTZiZGM3MGVj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-25T22:51:08Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Add some blockencodings tests",
      "tree": {
        "sha": "224e9a38f77202d1cf89b80de4d049f5b0644234",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/224e9a38f77202d1cf89b80de4d049f5b0644234"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4f8f14adc79f71eb3cfd3a8d6dbfe9878d1e3f6"
      }
    ],
    "stats": {
      "total": 316,
      "additions": 316,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c8918eb53f82fe3c5da8f9d84de4acb174a6c195",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
        "patch": "@@ -45,6 +45,7 @@ BITCOIN_TESTS =\\\n   test/base58_tests.cpp \\\n   test/base64_tests.cpp \\\n   test/bip32_tests.cpp \\\n+  test/blockencodings_tests.cpp \\\n   test/bloom_tests.cpp \\\n   test/Checkpoints_tests.cpp \\\n   test/coins_tests.cpp \\"
      },
      {
        "sha": "3884bf3fe37c336d3cfab337fe96bed1c08c2b27",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "added",
        "additions": 315,
        "deletions": 0,
        "changes": 315,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
        "patch": "@@ -0,0 +1,315 @@\n+// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/merkle.h\"\n+#include \"chainparams.h\"\n+#include \"random.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+struct RegtestingSetup : public TestingSetup {\n+    RegtestingSetup() : TestingSetup(CBaseChainParams::REGTEST) {}\n+};\n+\n+BOOST_FIXTURE_TEST_SUITE(blockencodings_tests, RegtestingSetup)\n+\n+static CBlock BuildBlockTestCase() {\n+    CBlock block;\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig.resize(10);\n+    tx.vout.resize(1);\n+    tx.vout[0].nValue = 42;\n+\n+    block.vtx.resize(3);\n+    block.vtx[0] = tx;\n+    block.nVersion = 42;\n+    block.hashPrevBlock = GetRandHash();\n+    block.nBits = 0x207fffff;\n+\n+    tx.vin[0].prevout.hash = GetRandHash();\n+    tx.vin[0].prevout.n = 0;\n+    block.vtx[1] = tx;\n+\n+    tx.vin.resize(10);\n+    for (size_t i = 0; i < tx.vin.size(); i++) {\n+        tx.vin[i].prevout.hash = GetRandHash();\n+        tx.vin[i].prevout.n = 0;\n+    }\n+    block.vtx[2] = tx;\n+\n+    bool mutated;\n+    block.hashMerkleRoot = BlockMerkleRoot(block, &mutated);\n+    assert(!mutated);\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus())) ++block.nNonce;\n+    return block;\n+}\n+\n+// Number of shared use_counts we expect for a tx we havent touched\n+// == 2 (mempool + our copy from the GetSharedTx call)\n+#define SHARED_TX_OFFSET 2\n+\n+BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+    TestMemPoolEntryHelper entry;\n+    CBlock block(BuildBlockTestCase());\n+\n+    pool.addUnchecked(block.vtx[2].GetHash(), entry.FromTx(block.vtx[2]));\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+\n+    // Do a simple ShortTxIDs RT\n+    {\n+        CBlockHeaderAndShortTxIDs shortIDs(block);\n+\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+        stream << shortIDs;\n+\n+        CBlockHeaderAndShortTxIDs shortIDs2;\n+        stream >> shortIDs2;\n+\n+        PartiallyDownloadedBlock partialBlock(&pool);\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        BOOST_CHECK( partialBlock.IsTxAvailable(0));\n+        BOOST_CHECK(!partialBlock.IsTxAvailable(1));\n+        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n+\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+\n+        std::list<CTransaction> removed;\n+        pool.removeRecursive(block.vtx[2], removed);\n+        BOOST_CHECK_EQUAL(removed.size(), 1);\n+\n+        CBlock block2;\n+        std::vector<CTransaction> vtx_missing;\n+        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_INVALID); // No transactions\n+\n+        vtx_missing.push_back(block.vtx[2]); // Wrong transaction\n+        partialBlock.FillBlock(block2, vtx_missing); // Current implementation doesn't check txn here, but don't require that\n+        bool mutated;\n+        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n+\n+        vtx_missing[0] = block.vtx[1];\n+        CBlock block3;\n+        BOOST_CHECK(partialBlock.FillBlock(block3, vtx_missing) == READ_STATUS_OK);\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n+        BOOST_CHECK(!mutated);\n+    }\n+}\n+\n+class TestHeaderAndShortIDs {\n+    // Utility to encode custom CBlockHeaderAndShortTxIDs\n+public:\n+    CBlockHeader header;\n+    uint64_t nonce;\n+    std::vector<uint64_t> shorttxids;\n+    std::vector<PrefilledTransaction> prefilledtxn;\n+\n+    TestHeaderAndShortIDs(const CBlockHeaderAndShortTxIDs& orig) {\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+        stream << orig;\n+        stream >> *this;\n+    }\n+    TestHeaderAndShortIDs(const CBlock& block) :\n+        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block)) {}\n+\n+    uint64_t GetShortID(const uint256& txhash) const {\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+        stream << *this;\n+        CBlockHeaderAndShortTxIDs base;\n+        stream >> base;\n+        return base.GetShortID(txhash);\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(header);\n+        READWRITE(nonce);\n+        size_t shorttxids_size = shorttxids.size();\n+        READWRITE(VARINT(shorttxids_size));\n+        shorttxids.resize(shorttxids_size);\n+        for (size_t i = 0; i < shorttxids.size(); i++) {\n+            uint32_t lsb = shorttxids[i] & 0xffffffff;\n+            uint16_t msb = (shorttxids[i] >> 32) & 0xffff;\n+            READWRITE(lsb);\n+            READWRITE(msb);\n+            shorttxids[i] = (uint64_t(msb) << 32) | uint64_t(lsb);\n+        }\n+        READWRITE(prefilledtxn);\n+    }\n+};\n+\n+BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+    TestMemPoolEntryHelper entry;\n+    CBlock block(BuildBlockTestCase());\n+\n+    pool.addUnchecked(block.vtx[2].GetHash(), entry.FromTx(block.vtx[2]));\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+\n+    // Test with pre-forwarding tx 1, but not coinbase\n+    {\n+        TestHeaderAndShortIDs shortIDs(block);\n+        shortIDs.prefilledtxn.resize(1);\n+        shortIDs.prefilledtxn[0] = {1, block.vtx[1]};\n+        shortIDs.shorttxids.resize(2);\n+        shortIDs.shorttxids[0] = shortIDs.GetShortID(block.vtx[0].GetHash());\n+        shortIDs.shorttxids[1] = shortIDs.GetShortID(block.vtx[2].GetHash());\n+\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+        stream << shortIDs;\n+\n+        CBlockHeaderAndShortTxIDs shortIDs2;\n+        stream >> shortIDs2;\n+\n+        PartiallyDownloadedBlock partialBlock(&pool);\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        BOOST_CHECK(!partialBlock.IsTxAvailable(0));\n+        BOOST_CHECK( partialBlock.IsTxAvailable(1));\n+        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n+\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+\n+        CBlock block2;\n+        std::vector<CTransaction> vtx_missing;\n+        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_INVALID); // No transactions\n+\n+        vtx_missing.push_back(block.vtx[1]); // Wrong transaction\n+        partialBlock.FillBlock(block2, vtx_missing); // Current implementation doesn't check txn here, but don't require that\n+        bool mutated;\n+        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n+\n+        vtx_missing[0] = block.vtx[0];\n+        CBlock block3;\n+        BOOST_CHECK(partialBlock.FillBlock(block3, vtx_missing) == READ_STATUS_OK);\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n+        BOOST_CHECK(!mutated);\n+\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+    }\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+    TestMemPoolEntryHelper entry;\n+    CBlock block(BuildBlockTestCase());\n+\n+    pool.addUnchecked(block.vtx[1].GetHash(), entry.FromTx(block.vtx[1]));\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+\n+    // Test with pre-forwarding coinbase + tx 2 with tx 1 in mempool\n+    {\n+        TestHeaderAndShortIDs shortIDs(block);\n+        shortIDs.prefilledtxn.resize(2);\n+        shortIDs.prefilledtxn[0] = {0, block.vtx[0]};\n+        shortIDs.prefilledtxn[1] = {1, block.vtx[2]}; // id == 1 as it is 1 after index 1\n+        shortIDs.shorttxids.resize(1);\n+        shortIDs.shorttxids[0] = shortIDs.GetShortID(block.vtx[1].GetHash());\n+\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+        stream << shortIDs;\n+\n+        CBlockHeaderAndShortTxIDs shortIDs2;\n+        stream >> shortIDs2;\n+\n+        PartiallyDownloadedBlock partialBlock(&pool);\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        BOOST_CHECK( partialBlock.IsTxAvailable(0));\n+        BOOST_CHECK( partialBlock.IsTxAvailable(1));\n+        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n+\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+\n+        CBlock block2;\n+        std::vector<CTransaction> vtx_missing;\n+        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n+        bool mutated;\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n+        BOOST_CHECK(!mutated);\n+\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+    }\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1].GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+    CMutableTransaction coinbase;\n+    coinbase.vin.resize(1);\n+    coinbase.vin[0].scriptSig.resize(10);\n+    coinbase.vout.resize(1);\n+    coinbase.vout[0].nValue = 42;\n+\n+    CBlock block;\n+    block.vtx.resize(1);\n+    block.vtx[0] = coinbase;\n+    block.nVersion = 42;\n+    block.hashPrevBlock = GetRandHash();\n+    block.nBits = 0x207fffff;\n+\n+    bool mutated;\n+    block.hashMerkleRoot = BlockMerkleRoot(block, &mutated);\n+    assert(!mutated);\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus())) ++block.nNonce;\n+\n+    // Test simple header round-trip with only coinbase\n+    {\n+        CBlockHeaderAndShortTxIDs shortIDs(block);\n+\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+        stream << shortIDs;\n+\n+        CBlockHeaderAndShortTxIDs shortIDs2;\n+        stream >> shortIDs2;\n+\n+        PartiallyDownloadedBlock partialBlock(&pool);\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2) == READ_STATUS_OK);\n+        BOOST_CHECK(partialBlock.IsTxAvailable(0));\n+\n+        CBlock block2;\n+        std::vector<CTransaction> vtx_missing;\n+        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n+        bool mutated;\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n+        BOOST_CHECK(!mutated);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(TransactionsRequestSerializationTest) {\n+    BlockTransactionsRequest req1;\n+    req1.blockhash = GetRandHash();\n+    req1.indexes.resize(4);\n+    req1.indexes[0] = 0;\n+    req1.indexes[1] = 1;\n+    req1.indexes[2] = 3;\n+    req1.indexes[3] = 4;\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << req1;\n+\n+    BlockTransactionsRequest req2;\n+    stream >> req2;\n+\n+    BOOST_CHECK_EQUAL(req1.blockhash.ToString(), req2.blockhash.ToString());\n+    BOOST_CHECK_EQUAL(req1.indexes.size(), req2.indexes.size());\n+    BOOST_CHECK_EQUAL(req1.indexes[0], req2.indexes[0]);\n+    BOOST_CHECK_EQUAL(req1.indexes[1], req2.indexes[1]);\n+    BOOST_CHECK_EQUAL(req1.indexes[2], req2.indexes[2]);\n+    BOOST_CHECK_EQUAL(req1.indexes[3], req2.indexes[3]);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "00c40784fe737ca67122fdec6538c450d2a516f3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGM0MDc4NGZlNzM3Y2E2NzEyMmZkZWM2NTM4YzQ1MGQyYTUxNmYz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-06T08:26:52Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:57Z"
      },
      "message": "Add protocol messages for short-ids blocks",
      "tree": {
        "sha": "f0a723ceaa2e8fc91077067efd4482573bb03aff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0a723ceaa2e8fc91077067efd4482573bb03aff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00c40784fe737ca67122fdec6538c450d2a516f3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00c40784fe737ca67122fdec6538c450d2a516f3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00c40784fe737ca67122fdec6538c450d2a516f3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00c40784fe737ca67122fdec6538c450d2a516f3/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3b2222144a0def7fa61822bdd11fb7e6bdc70ec"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 44,
      "deletions": 5
    },
    "files": [
      {
        "sha": "2f90fb764cfbca7a0df077769bb75085f4d34787",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00c40784fe737ca67122fdec6538c450d2a516f3/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00c40784fe737ca67122fdec6538c450d2a516f3/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=00c40784fe737ca67122fdec6538c450d2a516f3",
        "patch": "@@ -35,14 +35,19 @@ const char *FILTERCLEAR=\"filterclear\";\n const char *REJECT=\"reject\";\n const char *SENDHEADERS=\"sendheaders\";\n const char *FEEFILTER=\"feefilter\";\n+const char *SENDCMPCT=\"sendcmpct\";\n+const char *CMPCTBLOCK=\"cmpctblock\";\n+const char *GETBLOCKTXN=\"getblocktxn\";\n+const char *BLOCKTXN=\"blocktxn\";\n };\n \n static const char* ppszTypeName[] =\n {\n     \"ERROR\", // Should never occur\n     NetMsgType::TX,\n     NetMsgType::BLOCK,\n-    \"filtered block\" // Should never occur\n+    \"filtered block\", // Should never occur\n+    \"compact block\" // Should never occur\n };\n \n /** All known message types. Keep this in the same order as the list of\n@@ -70,7 +75,11 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::FILTERCLEAR,\n     NetMsgType::REJECT,\n     NetMsgType::SENDHEADERS,\n-    NetMsgType::FEEFILTER\n+    NetMsgType::FEEFILTER,\n+    NetMsgType::SENDCMPCT,\n+    NetMsgType::CMPCTBLOCK,\n+    NetMsgType::GETBLOCKTXN,\n+    NetMsgType::BLOCKTXN,\n };\n const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n "
      },
      {
        "sha": "a72813e959c64ea2ca3eac3cfe643bc99ad2a8e5",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 29,
        "deletions": 2,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00c40784fe737ca67122fdec6538c450d2a516f3/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00c40784fe737ca67122fdec6538c450d2a516f3/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=00c40784fe737ca67122fdec6538c450d2a516f3",
        "patch": "@@ -217,6 +217,32 @@ extern const char *SENDHEADERS;\n  * @since protocol version 70013 as described by BIP133\n  */\n extern const char *FEEFILTER;\n+/**\n+ * Contains a 1-byte bool and 8-byte LE version number.\n+ * Indicates that a node is willing to provide blocks via \"cmpctblock\" messages.\n+ * May indicate that a node prefers to receive new block announcements via a\n+ * \"cmpctblock\" message rather than an \"inv\", depending on message contents.\n+ * @since protocol version 70014 as described by BIP 152\n+ */\n+extern const char *SENDCMPCT;\n+/**\n+ * Contains a CBlockHeaderAndShortTxIDs object - providing a header and\n+ * list of \"short txids\".\n+ * @since protocol version 70014 as described by BIP 152\n+ */\n+extern const char *CMPCTBLOCK;\n+/**\n+ * Contains a BlockTransactionsRequest\n+ * Peer should respond with \"blocktxn\" message.\n+ * @since protocol version 70014 as described by BIP 152\n+ */\n+extern const char *GETBLOCKTXN;\n+/**\n+ * Contains a BlockTransactions.\n+ * Sent in response to a \"getblocktxn\" message.\n+ * @since protocol version 70014 as described by BIP 152\n+ */\n+extern const char *BLOCKTXN;\n };\n \n /* Get a vector of all valid message types (see above) */\n@@ -315,9 +341,10 @@ class CInv\n enum {\n     MSG_TX = 1,\n     MSG_BLOCK,\n-    // Nodes may always request a MSG_FILTERED_BLOCK in a getdata, however,\n-    // MSG_FILTERED_BLOCK should not appear in any invs except as a part of getdata.\n+    // Nodes may always request a MSG_FILTERED_BLOCK/MSG_CMPCT_BLOCK in a getdata, however,\n+    // MSG_FILTERED_BLOCK/MSG_CMPCT_BLOCK should not appear in any invs except as a part of getdata.\n     MSG_FILTERED_BLOCK,\n+    MSG_CMPCT_BLOCK,\n };\n \n #endif // BITCOIN_PROTOCOL_H"
      },
      {
        "sha": "68ccd6d378323c240eafc6bc2165b28a94ce5f9b",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00c40784fe737ca67122fdec6538c450d2a516f3/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00c40784fe737ca67122fdec6538c450d2a516f3/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=00c40784fe737ca67122fdec6538c450d2a516f3",
        "patch": "@@ -9,7 +9,7 @@\n  * network protocol versioning\n  */\n \n-static const int PROTOCOL_VERSION = 70013;\n+static const int PROTOCOL_VERSION = 70014;\n \n //! initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;\n@@ -39,4 +39,7 @@ static const int SENDHEADERS_VERSION = 70012;\n //! \"feefilter\" tells peers to filter invs to you by fee starts with this version\n static const int FEEFILTER_VERSION = 70013;\n \n+//! shord-id-based block download starts with this version\n+static const int SHORT_IDS_BLOCKS_VERSION = 70014;\n+\n #endif // BITCOIN_VERSION_H"
      }
    ]
  },
  {
    "sha": "9c837d5468063917009aef8569ce6ce9ddd340d2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YzgzN2Q1NDY4MDYzOTE3MDA5YWVmODU2OWNlNmNlOWRkZDM0MGQy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-11T08:00:17Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:34:58Z"
      },
      "message": "Add sender-side protocol implementation for CMPCTBLOCK stuff",
      "tree": {
        "sha": "935370a1ac9367b167fe91a95650062c696b53a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/935370a1ac9367b167fe91a95650062c696b53a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c837d5468063917009aef8569ce6ce9ddd340d2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c837d5468063917009aef8569ce6ce9ddd340d2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c837d5468063917009aef8569ce6ce9ddd340d2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c837d5468063917009aef8569ce6ce9ddd340d2/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00c40784fe737ca67122fdec6538c450d2a516f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00c40784fe737ca67122fdec6538c450d2a516f3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00c40784fe737ca67122fdec6538c450d2a516f3"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 95,
      "deletions": 15
    },
    "files": [
      {
        "sha": "911c0a648b999cda392f97a4449dcb550b73ddde",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 15,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c837d5468063917009aef8569ce6ce9ddd340d2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c837d5468063917009aef8569ce6ce9ddd340d2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9c837d5468063917009aef8569ce6ce9ddd340d2",
        "patch": "@@ -274,6 +274,10 @@ struct CNodeState {\n     bool fPreferredDownload;\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n     bool fPreferHeaders;\n+    //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n+    bool fPreferHeaderAndIDs;\n+    //! Whether this peer will send us cmpctblocks if we request them\n+    bool fProvidesHeaderAndIDs;\n \n     CNodeState() {\n         fCurrentlyConnected = false;\n@@ -290,6 +294,8 @@ struct CNodeState {\n         nBlocksInFlightValidHeaders = 0;\n         fPreferredDownload = false;\n         fPreferHeaders = false;\n+        fPreferHeaderAndIDs = false;\n+        fProvidesHeaderAndIDs = false;\n     }\n };\n \n@@ -4454,7 +4460,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             boost::this_thread::interruption_point();\n             it++;\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK)\n+            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK)\n             {\n                 bool send = false;\n                 BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n@@ -4496,7 +4502,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n                         pfrom->PushMessage(NetMsgType::BLOCK, block);\n-                    else // MSG_FILTERED_BLOCK)\n+                    else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         LOCK(pfrom->cs_filter);\n                         if (pfrom->pfilter)\n@@ -4516,6 +4522,18 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // else\n                             // no response\n                     }\n+                    else if (inv.type == MSG_CMPCT_BLOCK)\n+                    {\n+                        // If a peer is asking for old blocks, we're almost guaranteed\n+                        // they wont have a useful mempool to match against a compact block,\n+                        // and we dont feel like constructing the object for them, so\n+                        // instead we respond with the full, non-compact block.\n+                        if (mi->second->nHeight >= chainActive.Height() - 10) {\n+                            CBlockHeaderAndShortTxIDs cmpctblock(block);\n+                            pfrom->PushMessage(NetMsgType::CMPCTBLOCK, cmpctblock);\n+                        } else\n+                            pfrom->PushMessage(NetMsgType::BLOCK, block);\n+                    }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n                     if (inv.hash == pfrom->hashContinue)\n@@ -4839,6 +4857,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n+    else if (strCommand == NetMsgType::SENDCMPCT)\n+    {\n+        bool fAnnounceUsingCMPCTBLOCK = false;\n+        uint64_t nCMPCTBLOCKVersion = 1;\n+        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n+        if (nCMPCTBLOCKVersion == 1) {\n+            LOCK(cs_main);\n+            State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n+            State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+        }\n+    }\n+\n \n     else if (strCommand == NetMsgType::INV)\n     {\n@@ -4982,6 +5012,39 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::GETBLOCKTXN)\n+    {\n+        BlockTransactionsRequest req;\n+        vRecv >> req;\n+\n+        BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n+        if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n+            Misbehaving(pfrom->GetId(), 100);\n+            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+            return true;\n+        }\n+\n+        if (it->second->nHeight < chainActive.Height() - 10) {\n+            LogPrint(\"net\", \"Peer %d sent us a getblocktxn for a block > 10 deep\", pfrom->id);\n+            return true;\n+        }\n+\n+        CBlock block;\n+        assert(ReadBlockFromDisk(block, it->second, chainparams.GetConsensus()));\n+\n+        BlockTransactions resp(req);\n+        for (size_t i = 0; i < req.indexes.size(); i++) {\n+            if (req.indexes[i] >= block.vtx.size()) {\n+                Misbehaving(pfrom->GetId(), 100);\n+                LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->id);\n+                return true;\n+            }\n+            resp.txn[i] = block.vtx[req.indexes[i]];\n+        }\n+        pfrom->PushMessage(NetMsgType::BLOCKTXN, resp);\n+    }\n+\n+\n     else if (strCommand == NetMsgType::GETHEADERS)\n     {\n         CBlockLocator locator;\n@@ -5824,7 +5887,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n+                                pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n             ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n \n@@ -5876,6 +5941,33 @@ bool SendMessages(CNode* pto)\n                     }\n                 }\n             }\n+            if (!fRevertToInv && !vHeaders.empty()) {\n+                if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n+                    // We only send up to 1 block as header-and-ids, as otherwise\n+                    // probably means we're doing an initial-ish-sync or they're slow\n+                    LogPrint(\"net\", \"%s sending header-and-ids %s to peer %d\\n\", __func__,\n+                            vHeaders.front().GetHash().ToString(), pto->id);\n+                    //TODO: Shouldn't need to reload block from disk, but requires refactor\n+                    CBlock block;\n+                    assert(ReadBlockFromDisk(block, pBestIndex, consensusParams));\n+                    CBlockHeaderAndShortTxIDs cmpctblock(block);\n+                    pto->PushMessage(NetMsgType::CMPCTBLOCK, cmpctblock);\n+                    state.pindexBestHeaderSent = pBestIndex;\n+                } else if (state.fPreferHeaders) {\n+                    if (vHeaders.size() > 1) {\n+                        LogPrint(\"net\", \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n+                                vHeaders.size(),\n+                                vHeaders.front().GetHash().ToString(),\n+                                vHeaders.back().GetHash().ToString(), pto->id);\n+                    } else {\n+                        LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n+                                vHeaders.front().GetHash().ToString(), pto->id);\n+                    }\n+                    pto->PushMessage(NetMsgType::HEADERS, vHeaders);\n+                    state.pindexBestHeaderSent = pBestIndex;\n+                } else\n+                    fRevertToInv = true;\n+            }\n             if (fRevertToInv) {\n                 // If falling back to using an inv, just try to inv the tip.\n                 // The last entry in vBlockHashesToAnnounce was our tip at some point\n@@ -5901,18 +5993,6 @@ bool SendMessages(CNode* pto)\n                             pto->id, hashToAnnounce.ToString());\n                     }\n                 }\n-            } else if (!vHeaders.empty()) {\n-                if (vHeaders.size() > 1) {\n-                    LogPrint(\"net\", \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n-                            vHeaders.size(),\n-                            vHeaders.front().GetHash().ToString(),\n-                            vHeaders.back().GetHash().ToString(), pto->id);\n-                } else {\n-                    LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->id);\n-                }\n-                pto->PushMessage(NetMsgType::HEADERS, vHeaders);\n-                state.pindexBestHeaderSent = pBestIndex;\n             }\n             pto->vBlockHashesToAnnounce.clear();\n         }"
      }
    ]
  },
  {
    "sha": "d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMjVjZDNlYzRlODk2MWM1ZjM2YzI5YTY1Mzk1ZjUyZDBkYjI5NGM1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-15T00:45:49Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Add receiver-side protocol implementation for CMPCTBLOCK stuff",
      "tree": {
        "sha": "18f3fb45a7e2f243e992e99f6d3290c7d92823bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/18f3fb45a7e2f243e992e99f6d3290c7d92823bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d25cd3ec4e8961c5f36c29a65395f52d0db294c5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c837d5468063917009aef8569ce6ce9ddd340d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c837d5468063917009aef8569ce6ce9ddd340d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c837d5468063917009aef8569ce6ce9ddd340d2"
      }
    ],
    "stats": {
      "total": 215,
      "additions": 207,
      "deletions": 8
    },
    "files": [
      {
        "sha": "26b215f94cc54bd5e09c5b1f54f0aa38d9157ec9",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 207,
        "deletions": 8,
        "changes": 215,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d25cd3ec4e8961c5f36c29a65395f52d0db294c5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d25cd3ec4e8961c5f36c29a65395f52d0db294c5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
        "patch": "@@ -7,6 +7,7 @@\n \n #include \"addrman.h\"\n #include \"arith_uint256.h\"\n+#include \"blockencodings.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n@@ -197,8 +198,9 @@ namespace {\n     /** Blocks that are in flight, and that are in the queue to be downloaded. Protected by cs_main. */\n     struct QueuedBlock {\n         uint256 hash;\n-        CBlockIndex* pindex;     //!< Optional.\n-        bool fValidatedHeaders;  //!< Whether this block has validated headers at the time of request.\n+        CBlockIndex* pindex;                                     //!< Optional.\n+        bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n+        std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n@@ -364,6 +366,7 @@ void FinalizeNode(NodeId nodeid) {\n \n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n+// Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n@@ -387,25 +390,37 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// returns false, still setting pit, if the block was already in flight from the same peer\n+// pit will only be valid as long as the same cs_main lock is being held\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n+    // Short-circuit most stuff in case its from the same node\n+    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n+        *pit = &itInFlight->second.second;\n+        return false;\n+    }\n+\n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n-    QueuedBlock newentry = {hash, pindex, pindex != NULL};\n-    list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(), newentry);\n+    list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n+            {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n     state->nBlocksInFlight++;\n-    state->nBlocksInFlightValidHeaders += newentry.fValidatedHeaders;\n+    state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->nDownloadingSince = GetTimeMicros();\n     }\n     if (state->nBlocksInFlightValidHeaders == 1 && pindex != NULL) {\n         nPeersWithValidatedDownloads++;\n     }\n-    mapBlocksInFlight[hash] = std::make_pair(nodeid, it);\n+    itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n+    if (pit)\n+        *pit = &itInFlight->second.second;\n+    return true;\n }\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n@@ -4783,6 +4798,16 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // nodes)\n             pfrom->PushMessage(NetMsgType::SENDHEADERS);\n         }\n+        if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n+            // Tell our peer we are willing to provide version-1 cmpctblocks\n+            // However, we do not request new block announcements using\n+            // cmpctblock messages.\n+            // We send this to non-NODE NETWORK peers as well, because\n+            // they may wish to request compact blocks from us\n+            bool fAnnounceUsingCMPCTBLOCK = false;\n+            uint64_t nCMPCTBLOCKVersion = 1;\n+            pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+        }\n     }\n \n \n@@ -4915,7 +4940,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     CNodeState *nodestate = State(pfrom->GetId());\n                     if (CanDirectFetch(chainparams.GetConsensus()) &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                        vToFetch.push_back(inv);\n+                        if (nodestate->fProvidesHeaderAndIDs)\n+                            vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n+                        else\n+                            vToFetch.push_back(inv);\n                         // Mark block as in flight already, even though the actual \"getdata\" message only goes out\n                         // later (within the same cs_main lock, though).\n                         MarkBlockAsInFlight(pfrom->GetId(), inv.hash, chainparams.GetConsensus());\n@@ -5232,6 +5260,174 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+        bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+\n+        if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n+            return true;\n+\n+        if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n+                pindex->nTx != 0) { // We had this block at some point, but pruned it\n+            if (fAlreadyInFlight) {\n+                // We requested this block for some reason, but our mempool will probably be useless\n+                // so we just grab the block via normal getdata\n+                std::vector<CInv> vInv(1);\n+                vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                return true;\n+            }\n+        }\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // We want to be a bit conservative just to be extra careful about DoS\n+        // possibilities in compact block processing...\n+        if (pindex->nHeight <= chainActive.Height() + 2) {\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                    if (!(*queuedBlockIt)->partialBlock)\n+                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n+                    else {\n+                        // The block was already in flight using compact blocks from the same peer\n+                        LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\\n\");\n+                        return true;\n+                    }\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, the block is now in-flight, so just request it\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    return true;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    // Dirty hack to jump to BLOCKTXN code (TODO: move message handling into their own functions)\n+                    BlockTransactions txn;\n+                    txn.blockhash = cmpctblock.header.GetHash();\n+                    CDataStream blockTxnMsg(SER_NETWORK, PROTOCOL_VERSION);\n+                    blockTxnMsg << txn;\n+                    return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams);\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+        } else {\n+            if (fAlreadyInFlight) {\n+                // We requested this block, but its far into the future, so our\n+                // mempool will probably be useless - request the block normally\n+                std::vector<CInv> vInv(1);\n+                vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                return true;\n+            } else {\n+                // If this was an announce-cmpctblock, we want the same treatment as a header message\n+                // Dirty hack to process as if it were just a headers message (TODO: move message handling into their own functions)\n+                std::vector<CBlock> headers;\n+                headers.push_back(cmpctblock.header);\n+                CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+                vHeadersMsg << headers;\n+                return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+            }\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        LOCK(cs_main);\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);\n+        if (status == READ_STATUS_INVALID) {\n+            MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n+            Misbehaving(pfrom->GetId(), 100);\n+            LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->id);\n+            return true;\n+        } else if (status == READ_STATUS_FAILED) {\n+            // Might have collided, fall back to getdata now :(\n+            std::vector<CInv> invs;\n+            invs.push_back(CInv(MSG_BLOCK, resp.blockhash));\n+            pfrom->PushMessage(NetMsgType::GETDATA, invs);\n+        } else {\n+            CValidationState state;\n+            ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                if (nDoS > 0) {\n+                    LOCK(cs_main);\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                }\n+            }\n+        }\n+    }\n+\n+\n     else if (strCommand == NetMsgType::HEADERS && !fImporting && !fReindex) // Ignore headers received while importing\n     {\n         std::vector<CBlockHeader> headers;\n@@ -5334,6 +5530,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n+                    if (nodestate->fProvidesHeaderAndIDs && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n+                    }\n                     pfrom->PushMessage(NetMsgType::GETDATA, vGetData);\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjdmOGVlZGUwYzllMGFiOWNjMmI1ZTQzZTM5Y2ZlM2UxMzQwZGQ2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-05-06T18:50:24Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Add ability to fetch CNode by NodeId",
      "tree": {
        "sha": "5881ee45f21ce4ca0c23d86350fabbdba855a140",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5881ee45f21ce4ca0c23d86350fabbdba855a140"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d25cd3ec4e8961c5f36c29a65395f52d0db294c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d25cd3ec4e8961c5f36c29a65395f52d0db294c5"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 13,
      "deletions": 2
    },
    "files": [
      {
        "sha": "336163a89624ddf9420f240448f5b5540dfdff23",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
        "patch": "@@ -368,6 +368,16 @@ CNode* FindNode(const CService& addr)\n     return NULL;\n }\n \n+//TODO: This is used in only one place in main, and should be removed\n+CNode* FindNode(const NodeId nodeid)\n+{\n+    LOCK(cs_vNodes);\n+    BOOST_FOREACH(CNode* pnode, vNodes)\n+        if (pnode->GetId() == nodeid)\n+            return (pnode);\n+    return NULL;\n+}\n+\n CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n {\n     if (pszDest == NULL) {"
      },
      {
        "sha": "aa9b2c11a3c22965906b5633c0c6d3b0ecc5fecd",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
        "patch": "@@ -80,12 +80,15 @@ static const unsigned int DEFAULT_MISBEHAVING_BANTIME = 60 * 60 * 24;  // Defaul\n unsigned int ReceiveFloodSize();\n unsigned int SendBufferSize();\n \n+typedef int NodeId;\n+\n void AddOneShot(const std::string& strDest);\n void AddressCurrentlyConnected(const CService& addr);\n CNode* FindNode(const CNetAddr& ip);\n CNode* FindNode(const CSubNet& subNet);\n CNode* FindNode(const std::string& addrName);\n CNode* FindNode(const CService& ip);\n+CNode* FindNode(const NodeId id); //TODO: Remove this\n bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\n void MapPort(bool fUseUPnP);\n unsigned short GetListenPort();\n@@ -94,8 +97,6 @@ void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler);\n bool StopNode();\n void SocketSendData(CNode *pnode);\n \n-typedef int NodeId;\n-\n struct CombinerAll\n {\n     typedef bool result_type;"
      }
    ]
  },
  {
    "sha": "2f34a2e476ae9d0585c67e275d238e44119c56cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjM0YTJlNDc2YWU5ZDA1ODVjNjdlMjc1ZDIzOGU0NDExOWM1NmNm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-05-06T22:33:46Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Get our \"best three\" peers to announce blocks using cmpctblocks",
      "tree": {
        "sha": "9b83e60a95afe539715ed3140f522e501f8b48b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b83e60a95afe539715ed3140f522e501f8b48b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f34a2e476ae9d0585c67e275d238e44119c56cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f34a2e476ae9d0585c67e275d238e44119c56cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f34a2e476ae9d0585c67e275d238e44119c56cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f34a2e476ae9d0585c67e275d238e44119c56cf/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/927f8eede0c9e0ab9cc2b5e43e39cfe3e1340dd6"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 29,
      "deletions": 0
    },
    "files": [
      {
        "sha": "60a33f9c2f97edc9b23fff0adaa77c3d398988ca",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f34a2e476ae9d0585c67e275d238e44119c56cf/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f34a2e476ae9d0585c67e275d238e44119c56cf/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2f34a2e476ae9d0585c67e275d238e44119c56cf",
        "patch": "@@ -204,6 +204,9 @@ namespace {\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n+    /** Stack of nodes which we have set to announce using compact blocks */\n+    list<NodeId> lNodesAnnouncingHeaderAndIDs;\n+\n     /** Number of preferable block download peers. */\n     int nPreferredDownload = 0;\n \n@@ -456,6 +459,28 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n+void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom) {\n+    if (nodestate->fProvidesHeaderAndIDs) {\n+        BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n+            if (nodeid == pfrom->GetId())\n+                return;\n+        bool fAnnounceUsingCMPCTBLOCK = false;\n+        uint64_t nCMPCTBLOCKVersion = 1;\n+        if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n+            // As per BIP152, we only get 3 of our peers to announce\n+            // blocks using compact encodings.\n+            CNode* pnodeStop = FindNode(lNodesAnnouncingHeaderAndIDs.front());\n+            if (pnodeStop) {\n+                pnodeStop->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+                lNodesAnnouncingHeaderAndIDs.pop_front();\n+            }\n+        }\n+        fAnnounceUsingCMPCTBLOCK = true;\n+        pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+        lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n+    }\n+}\n+\n // Requires cs_main\n bool CanDirectFetch(const Consensus::Params &consensusParams)\n {\n@@ -5531,6 +5556,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 }\n                 if (vGetData.size() > 0) {\n                     if (nodestate->fProvidesHeaderAndIDs && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                        // We seem to be rather well-synced, so it appears pfrom was the first to provide us\n+                        // with this block! Let's get them to announce using compact blocks in the future.\n+                        MaybeSetPeerAsAnnouncingHeaderAndIDs(nodestate, pfrom);\n+                        // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n                     pfrom->PushMessage(NetMsgType::GETDATA, vGetData);"
      }
    ]
  },
  {
    "sha": "56ba5167272bc5afa8629ad93f16ed5135490bf5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NmJhNTE2NzI3MmJjNWFmYTg2MjlhZDkzZjE2ZWQ1MTM1NDkwYmY1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-08T22:43:50Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Add reconstruction debug logging",
      "tree": {
        "sha": "3ca486c300465d1736c6e969099181d25096be85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ca486c300465d1736c6e969099181d25096be85"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56ba5167272bc5afa8629ad93f16ed5135490bf5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56ba5167272bc5afa8629ad93f16ed5135490bf5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/56ba5167272bc5afa8629ad93f16ed5135490bf5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56ba5167272bc5afa8629ad93f16ed5135490bf5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f34a2e476ae9d0585c67e275d238e44119c56cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f34a2e476ae9d0585c67e275d238e44119c56cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f34a2e476ae9d0585c67e275d238e44119c56cf"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 16,
      "deletions": 1
    },
    "files": [
      {
        "sha": "204de45c29fe7b03b252074f74c5920574714850",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56ba5167272bc5afa8629ad93f16ed5135490bf5/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56ba5167272bc5afa8629ad93f16ed5135490bf5/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=56ba5167272bc5afa8629ad93f16ed5135490bf5",
        "patch": "@@ -11,6 +11,7 @@\n #include \"streams.h\"\n #include \"txmempool.h\"\n #include \"main.h\"\n+#include \"util.h\"\n \n #include <unordered_map>\n \n@@ -72,6 +73,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n         }\n         txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n     }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n \n     // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n     // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n@@ -103,11 +105,15 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n             if (!have_txn[idit->second]) {\n                 txn_available[idit->second] = it->GetSharedTx();\n                 have_txn[idit->second]  = true;\n+                mempool_count++;\n             } else {\n                 // If we find two mempool txn that match the short id, just request it.\n                 // This should be rare enough that the extra bandwidth doesn't matter,\n                 // but eating a round-trip due to FillBlock failure would be annoying\n-                txn_available[idit->second].reset();\n+                if (txn_available[idit->second]) {\n+                    txn_available[idit->second].reset();\n+                    mempool_count--;\n+                }\n             }\n         }\n         // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n@@ -117,6 +123,8 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n             break;\n     }\n \n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n     return READ_STATUS_OK;\n }\n \n@@ -154,5 +162,11 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         return READ_STATUS_INVALID;\n     }\n \n+    LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, vtx_missing.size());\n+    if (vtx_missing.size() < 5) {\n+        for(const CTransaction& tx : vtx_missing)\n+            LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+    }\n+\n     return READ_STATUS_OK;\n }"
      },
      {
        "sha": "b980e9e28660fb1d5a4bae68dfc04761db8af0a0",
        "filename": "src/blockencodings.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56ba5167272bc5afa8629ad93f16ed5135490bf5/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56ba5167272bc5afa8629ad93f16ed5135490bf5/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=56ba5167272bc5afa8629ad93f16ed5135490bf5",
        "patch": "@@ -192,6 +192,7 @@ class CBlockHeaderAndShortTxIDs {\n class PartiallyDownloadedBlock {\n protected:\n     std::vector<std::shared_ptr<const CTransaction> > txn_available;\n+    size_t prefilled_count = 0, mempool_count = 0;\n     CTxMemPool* pool;\n public:\n     CBlockHeader header;"
      }
    ]
  },
  {
    "sha": "678ee9793f6279c07b57c22c3cce983ab1e069d0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NzhlZTk3OTNmNjI3OWMwN2I1N2MyMmMzY2NlOTgzYWIxZTA2OWQw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-06T08:15:21Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Add BIP 152 to implemented BIPs list",
      "tree": {
        "sha": "ea560720e6b7539ec1efda08a71dd27a016dd747",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ea560720e6b7539ec1efda08a71dd27a016dd747"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/678ee9793f6279c07b57c22c3cce983ab1e069d0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/678ee9793f6279c07b57c22c3cce983ab1e069d0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/678ee9793f6279c07b57c22c3cce983ab1e069d0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/678ee9793f6279c07b57c22c3cce983ab1e069d0/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56ba5167272bc5afa8629ad93f16ed5135490bf5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56ba5167272bc5afa8629ad93f16ed5135490bf5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56ba5167272bc5afa8629ad93f16ed5135490bf5"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "62bde20d944f4ea010341f31e80a1e279f976ede",
        "filename": "doc/bips.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/678ee9793f6279c07b57c22c3cce983ab1e069d0/doc/bips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/678ee9793f6279c07b57c22c3cce983ab1e069d0/doc/bips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bips.md?ref=678ee9793f6279c07b57c22c3cce983ab1e069d0",
        "patch": "@@ -26,3 +26,4 @@ BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.13.0**):\n * [`BIP 125`](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki): Opt-in full replace-by-fee signaling honoured in mempool and mining as of **v0.12.0** ([PR 6871](https://github.com/bitcoin/bitcoin/pull/6871)).\n * [`BIP 130`](https://github.com/bitcoin/bips/blob/master/bip-0130.mediawiki): direct headers announcement is negotiated with peer versions `>=70012` as of **v0.12.0** ([PR 6494](https://github.com/bitcoin/bitcoin/pull/6494)).\n * [`BIP 133`](https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki): feefilter messages are respected and sent for peer versions `>=70013` as of **v0.13.0** ([PR 7542](https://github.com/bitcoin/bitcoin/pull/7542)).\n+* [`BIP 152`](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki): Compact block transfer and related optimizations are used as of **v0.13.0** ([PR 8068](https://github.com/bitcoin/bitcoin/pull/8068))."
      }
    ]
  },
  {
    "sha": "811902649d6aaddd886cb39b83aa69adf7b441bd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MTE5MDI2NDlkNmFhZGRkODg2Y2IzOWI4M2FhNjlhZGY3YjQ0MWJk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-15T06:59:03Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Provide a flat list of txid/terators to txn in CTxMemPool",
      "tree": {
        "sha": "86410076db666aa134ff738b98d5ef260763ab3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/86410076db666aa134ff738b98d5ef260763ab3d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/811902649d6aaddd886cb39b83aa69adf7b441bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/811902649d6aaddd886cb39b83aa69adf7b441bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/811902649d6aaddd886cb39b83aa69adf7b441bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/811902649d6aaddd886cb39b83aa69adf7b441bd/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "678ee9793f6279c07b57c22c3cce983ab1e069d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/678ee9793f6279c07b57c22c3cce983ab1e069d0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/678ee9793f6279c07b57c22c3cce983ab1e069d0"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 18,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ead28546de56a495c9bb999d38ceccd47491c2a4",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/811902649d6aaddd886cb39b83aa69adf7b441bd/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/811902649d6aaddd886cb39b83aa69adf7b441bd/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=811902649d6aaddd886cb39b83aa69adf7b441bd",
        "patch": "@@ -438,6 +438,9 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     totalTxSize += entry.GetTxSize();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n \n+    vTxHashes.emplace_back(hash, newit);\n+    newit->vTxHashesIdx = vTxHashes.size() - 1;\n+\n     return true;\n }\n \n@@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n     BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n         mapNextTx.erase(txin.prevout);\n \n+    if (vTxHashes.size() > 1) {\n+        vTxHashes[it->vTxHashesIdx] = std::move(vTxHashes.back());\n+        vTxHashes[it->vTxHashesIdx].second->vTxHashesIdx = it->vTxHashesIdx;\n+        vTxHashes.pop_back();\n+        if (vTxHashes.size() * 2 < vTxHashes.capacity())\n+            vTxHashes.shrink_to_fit();\n+    } else\n+        vTxHashes.clear();\n+\n     totalTxSize -= it->GetTxSize();\n     cachedInnerUsage -= it->DynamicMemoryUsage();\n     cachedInnerUsage -= memusage::DynamicUsage(mapLinks[it].parents) + memusage::DynamicUsage(mapLinks[it].children);\n@@ -965,7 +977,7 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n     // Estimate the overhead of mapTx to be 15 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n }\n \n void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants) {"
      },
      {
        "sha": "d6d0d72ff5874160d3e627cfe45eab5d71a7ca05",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/811902649d6aaddd886cb39b83aa69adf7b441bd/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/811902649d6aaddd886cb39b83aa69adf7b441bd/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=811902649d6aaddd886cb39b83aa69adf7b441bd",
        "patch": "@@ -150,6 +150,8 @@ class CTxMemPoolEntry\n     uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; }\n     CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; }\n     unsigned int GetSigOpCountWithAncestors() const { return nSigOpCountWithAncestors; }\n+\n+    mutable size_t vTxHashesIdx; //!< Index in mempool's vTxHashes\n };\n \n // Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.\n@@ -457,7 +459,10 @@ class CTxMemPool\n \n     mutable CCriticalSection cs;\n     indexed_transaction_set mapTx;\n+\n     typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n+    std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx hashes/entries in mapTx, in random order\n+\n     struct CompareIteratorByHash {\n         bool operator()(const txiter &a, const txiter &b) const {\n             return a->GetTx().GetHash() < b->GetTx().GetHash();"
      }
    ]
  },
  {
    "sha": "0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZDRjYjQ4ZWYxYjkxNjY3OWQ5ZmFkOWYyNDdhMjk3Yzg1YzdmZWRm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-19T08:31:52Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Use vTxHashes to optimize InitData significantly",
      "tree": {
        "sha": "784ef3d7d9846b744f6f02378b8f4c57b685ef0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/784ef3d7d9846b744f6f02378b8f4c57b685ef0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d4cb48ef1b916679d9fad9f247a297c85c7fedf/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "811902649d6aaddd886cb39b83aa69adf7b441bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/811902649d6aaddd886cb39b83aa69adf7b441bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/811902649d6aaddd886cb39b83aa69adf7b441bd"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 5,
      "deletions": 3
    },
    "files": [
      {
        "sha": "9a0805e40050dc6074d0cd0696f5f6de26fbdf2a",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d4cb48ef1b916679d9fad9f247a297c85c7fedf/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d4cb48ef1b916679d9fad9f247a297c85c7fedf/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
        "patch": "@@ -99,11 +99,13 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n \n     std::vector<bool> have_txn(txn_available.size());\n     LOCK(pool->cs);\n-    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n-        std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+    const std::vector<std::pair<uint256, CTxMemPool::txiter> >& vTxHashes = pool->vTxHashes;\n+    for (size_t i = 0; i < vTxHashes.size(); i++) {\n+        uint64_t shortid = cmpctblock.GetShortID(vTxHashes[i].first);\n+        std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n         if (idit != shorttxids.end()) {\n             if (!have_txn[idit->second]) {\n-                txn_available[idit->second] = it->GetSharedTx();\n+                txn_available[idit->second] = vTxHashes[i].second->GetSharedTx();\n                 have_txn[idit->second]  = true;\n                 mempool_count++;\n             } else {"
      }
    ]
  },
  {
    "sha": "ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjY2QwNmI5NGY2OWMzZTc3NThjMzVhYzRiY2QzNmQwZTk0NTBlMTU4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-17T23:36:23Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-20T06:06:55Z"
      },
      "message": "Elaborate bucket size math",
      "tree": {
        "sha": "73158f8515144a523d87c00e6c797aac6ec589c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73158f8515144a523d87c00e6c797aac6ec589c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d4cb48ef1b916679d9fad9f247a297c85c7fedf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0d4cb48ef1b916679d9fad9f247a297c85c7fedf"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 10,
      "deletions": 4
    },
    "files": [
      {
        "sha": "7fd6a9cf52d81f247acb7f0c25f457c60b4e9819",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
        "patch": "@@ -85,10 +85,16 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n         while (txn_available[i + index_offset])\n             index_offset++;\n         shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n-        // Bucket selection is a simple Binomial distribution. If we assume blocks of\n-        // 10,000 transactions, allowing up to 12 elements per bucket should only fail\n-        // once every ~1.3 million blocks and once every 74,000 blocks in a worst-case\n-        // 16,000-transaction block.\n+        // To determine the chance that the number of entries in a bucket exceeds N,\n+        // we use the fact that the number of elements in a single bucket is\n+        // binomially distributed (with n = the number of shorttxids S, and p =\n+        // 1 / the number of buckets), that in the worst case the number of buckets is\n+        // equal to S (due to std::unordered_map having a default load factor of 1.0),\n+        // and that the chance for any bucket to exceed N elements is at most\n+        // buckets * (the chance that any given bucket is above N elements).\n+        // Thus: P(max_elements_per_bucket > N) <= S * (1 - cdf(binomial(n=S,p=1/S), N)).\n+        // If we assume blocks of up to 16000, allowing 12 elements per bucket should\n+        // only fail once per ~1 million block transfers (per peer and connection).\n         if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 12)\n             return READ_STATUS_FAILED;\n     }"
      }
    ]
  },
  {
    "sha": "48efec82f3a18364c019577495914fcebb425e35",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OGVmZWM4MmYzYTE4MzY0YzAxOTU3NzQ5NTkxNGZjZWJiNDI1ZTM1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-21T23:09:46Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-06-21T23:09:46Z"
      },
      "message": "Fix some minor compact block issues that came up in review",
      "tree": {
        "sha": "b405d515289c303a5ffda3b490f2f0283e244c61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b405d515289c303a5ffda3b490f2f0283e244c61"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48efec82f3a18364c019577495914fcebb425e35",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48efec82f3a18364c019577495914fcebb425e35",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/48efec82f3a18364c019577495914fcebb425e35",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48efec82f3a18364c019577495914fcebb425e35/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ccd06b94f69c3e7758c35ac4bcd36d0e9450e158"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "f5b1410114c7f25d1711da034622eacdebfc750c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48efec82f3a18364c019577495914fcebb425e35/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48efec82f3a18364c019577495914fcebb425e35/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=48efec82f3a18364c019577495914fcebb425e35",
        "patch": "@@ -4613,7 +4613,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             // Track requests for our stuff.\n             GetMainSignals().Inventory(inv.hash);\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK)\n+            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK)\n                 break;\n         }\n     }\n@@ -5077,8 +5077,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n-        if (it->second->nHeight < chainActive.Height() - 10) {\n-            LogPrint(\"net\", \"Peer %d sent us a getblocktxn for a block > 10 deep\", pfrom->id);\n+        if (it->second->nHeight < chainActive.Height() - 15) {\n+            LogPrint(\"net\", \"Peer %d sent us a getblocktxn for a block > 15 deep\", pfrom->id);\n             return true;\n         }\n "
      }
    ]
  }
]