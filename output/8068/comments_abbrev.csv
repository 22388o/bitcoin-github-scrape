paveljanik,2016-05-18T05:52:34Z,"`test/test_bitcoin` failures in travis are strange. Can't reproduce locally. Hmm, we should probably include `src/test-suite.log` in the travis output in such cases.\n\n... just a second after I wrote this, I see this failure in my logs:\n\n```\nRunning 200 test cases...\ntest/net_tests.cpp:92: error in ""caddrdb_read"": check addrman1.size() == 3 failed\ntest/net_tests.cpp:102: error in ""caddrdb_re",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-219931715,219931715,
gmaxwell,2016-05-18T09:47:36Z,Needs rebase to remove the siphash commits from the top. :)\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-219977952,219977952,
TheBlueMatt,2016-05-18T20:23:26Z,Rebased and fixed @paveljanik's clang compile-warning.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220146640,220146640,
TheBlueMatt,2016-05-18T20:23:49Z,Also removed the varint stuff...turns out it wasnt as big a gain as I thought.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220146749,220146749,
dcousens,2016-05-19T01:43:39Z,concept ACK\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220206517,220206517,
arowser,2016-05-25T08:43:26Z,Can one of the admins verify this patch?\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-221510368,221510368,
sipa,2016-05-26T13:00:33Z,"Thinking more about this (and seeing more pull requests touching the mempool), I think having the mempool store its CTransaction objects using shared_ptr's would make sense.\n- During erasing from the mempool, we return the deleted entries upwards (for signalling to wallets etc). This requires expensive copying that could be avoided with shared_ptr (alternatively, see #8099)\n- During transaction ",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-221863723,221863723,
NicolasDorier,2016-05-29T00:59:54Z,"Will test that during next week, I need to use it for one of my project\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222336764,222336764,
gmaxwell,2016-05-30T16:06:32Z,This should update the implemented BIPs list.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222521282,222521282,
sipa,2016-06-01T01:35:49Z,"Here is a rebase on top of #8126, using shared_ptr's for partial block transactions: https://github.com/sipa/bitcoin/commits/compactblocks\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222869545,222869545,
sipa,2016-06-01T13:27:23Z,"Ok, some comments after looking through the code and working to rebase:\n- `CBlockHeaderAndShortTxIDs::FillShortTxIDSelector` should use `htole64` before serializing the nonce (endianness correctness)\n- `PartiallyDownloadedBlock::InitData`'s `have_txn` can use a `vector<bool>` (which is bitpacked internally) instead of manual bit logic (nit)\n- The code in `ProcessMessage` to add a peer as a dire",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222991558,222991558,
gmaxwell,2016-06-01T17:16:33Z,It would be nice if the getpeerinfo showed the sendcmpct status (maybe hex for the version?).\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223062347,223062347,
luke-jr,2016-06-01T17:39:06Z,"> (maybe hex for the version?)\n\nHow to display numbers is a client-side thing, and I'm not sure it makes sense to bloat up bitcoin-cli with this kind of logic?\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223068790,223068790,
dcousens,2016-06-02T02:58:36Z,> (maybe hex for the version?)\n\nWorth nothing this issue has [come up before](https://github.com/bitcoin/bitcoin/pull/7774) and was added as `versionHex`.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223183123,223183123,
gmaxwell,2016-06-04T17:48:03Z,@TheBlueMatt when you continue this you should probably continue from Pieter's rebase.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223768784,223768784,
TheBlueMatt,2016-06-06T08:18:55Z,"Rebased on latest master (Pieter's is an insignificant change here, I'll just rebase when it gets merged), and addressed all the comments I saw above, though I didnt add cmpctblock status to getpeerinfo since its already there (in the form of message size info) and I dont want to be bikeshedded for getpeerinfo api....\n\nNote for LogPrints in network processing, I tried to use the rule ""LogPrint(""",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223895608,223895608,
sipa,2016-06-06T12:00:45Z,From Travis:\n\n```\nEXCEPTION: St12out_of_range       \nCInv::GetCommand(): type=4 unknown type       \nbitcoin in ProcessMessages()\n```\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223939085,223939085,
NicolasDorier,2016-06-08T09:14:24Z,"Code Review ACK (except small nits about typo and one question about recursive lock, as you are calling ProcessMessage recursively)\n\nI'll compile and test it myself. (my tests will be in C# though)\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224533796,224533796,
TheBlueMatt,2016-06-09T00:07:22Z,Rebased. Had to throw in a fix for CheckBlockHeader requiring context instead of using ContextualCheckBlockHeader so that blockencodings.cpp was insane to fix a bug (though it still is...who's idea was it to have a flag in CBlock about a block being checked by a function in main?)\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224767800,224767800,
TheBlueMatt,2016-06-09T01:50:17Z,"To clarify: the bug was that the merkle root check would result in a DoS ban, but could happen due to conflicting short IDs. The solution was to check merkle root in blockencodings.cpp to keep all the ""maybe-short-id-collision"" checks in one place. In order to avoid checking the merkle tree twice (which is incredibly expensive), I had to call CheckBlock, which required three #includes (including m",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224781229,224781229,
JeremyRubin,2016-06-09T21:43:06Z,"Some thoughts on the overall design and implementation. I think points 1, ~~2~~, and 7 are the most immediate.\n1. Can I suggest adding code to disable this mode when you have a max block size (and hence number of transactions) that makes the failure rate untenable? Or code that expands the number of bits used in the hash to keep mean-time-to-failure constant.\n2.  ~~Perhaps having sendcmpct have ",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225035887,225035887,
gmaxwell,2016-06-09T23:10:42Z,> Can I suggest adding code to disable this mode when you have a max block size (and hence number of transactions) that makes the failure rate untenable? Or code that expands the number of bits used in the hash to keep mean-time-to-failure constant.\n\nThis is already designed targeting several times the maximum size permitted in the protocol. Also the size of the block does not weigh that strongl,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225053543,225053543,
JeremyRubin,2016-06-11T01:48:20Z,"> This is already designed targeting several times the maximum size permitted in the protocol. Also the size of the block does not weigh that strongly in the result (mempool size dominates), and the implementation deals fairly gracefully with small numbers of collisions.\n\nYes, mempool size should dominate. This seems like a completely-other issue. Mining nodes who keep large mempools will run in",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225330119,225330119,
gmaxwell,2016-06-11T04:52:27Z,> This seems like a completely-other issue. Mining nodes who keep large mempools will run into large collision frequencies and this will be less useful.\n\nThis isn't the case. The numbers here are sized for their targets assuming a mempool roughly 10 times what we see with the current maximum.  There is little reason to run with multiple days worth of mempool in any case (transactions will expire,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225336886,225336886,
sipa,2016-06-11T13:17:42Z,"@JeremyRubin @gmaxwell The number 0.17ms you're citing is not actually relevant in this discussion.\n\nFor the receiver, the reconstruction time is likely dominated by iterating over the mempool (the memory accesses needed per mempool entry are way slower than the SipHash calculation), so being able to use a preconstructred mempool index with shortids would likely very significantly reduce it. Unf",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225361053,225361053,
gmaxwell,2016-06-12T23:15:40Z,"ACK (+/- various in-flight nits). Beyond reviewing the spec and code, I've had a network of hosts running this (and earlier versions) for over a month with good results, public testing looks good, and and four the last week I've had a network running a modified version with 16-bit IDs to test all the collision corner cases. That network has reliably stayed in sync (except for one bug I encountered",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225466329,225466329,
TheBlueMatt,2016-06-13T04:41:13Z,"I believe I either responded to all code comments or fixed them.\n\nAlso added a few commits to optimize PartiallyDownloadedBlock::InitData. Just iterating over the mempool costs quite a bit of CPU time, which would near being a DoS-issue if it werent for the fact that you have to do a disconnect/reconnect cycle to trigger the code again. By limiting its worst-case runtime in the case that someone",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225488055,225488055,
JeremyRubin,2016-06-13T15:21:54Z,@sipa thanks for the clarification.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225614170,225614170,
instagibbs,2016-06-13T17:10:47Z,slightly tested ACK\n\nI've been running versions of this for smoothly about a month and compiling stats/graphing the results. \n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225646123,225646123,
TheBlueMatt,2016-06-14T00:14:56Z,"The travis failure seems to be a travis issue, not a real failure\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225746202,225746202,
btcdrak,2016-06-14T09:19:15Z,@TheBlueMatt Travis passed now.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225825656,225825656,
NicolasDorier,2016-06-14T15:43:44Z,@TheBlueMatt can you consider to cherry pick https://github.com/NicolasDorier/bitcoin/commit/5a156ebc6f402f60c2e5faa880e3cdc2c6bb5b32 ?\n\nPrefilledTransaction.index becomes an absolute index instead of a differential one. Differential index should only be used on wire.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225923963,225923963,
NicolasDorier,2016-06-16T19:53:39Z,Reply getdata MSG_CMPCT_BLOCK to MSG_BLOCK inv : https://github.com/NicolasDorier/bitcoin/commit/83cc735bfa803e1e7eee02e458127e8d94c24534\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226594840,226594840,
JeremyRubin,2016-06-17T14:00:06Z,"I have a concern with how the block reconstruction mechanism interacts with any mempool policy -- first seen, replace by fee, or opt-in replace by fee. I am worried that mempool policies can be used to greatly increase reconstruction failure rates.\n\nSuppose a new block is found by a miner, containing a bunch of transactions. A malicious node is close to the miner and is able to see the block fir",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226776252,226776252,
gmaxwell,2016-06-17T16:17:18Z,"@JeremyRubin Being able to use more than just the currently active mempool was part of the motivation in switching to use sharedptr rather than the manual rc used earlier. Before making a getblocktxn it could go and check the relaypool, orphanpool, or even a not yet existing pool of rejected transactions. But that would be a further optimization that I don't think is necessary to shove in the very",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226813548,226813548,
laanwj,2016-06-18T14:57:21Z,"Summary from last Thursday's meeting: this will get an extra week to be ready for merge\* (thus exception from the feature freeze). Next meeting we should decide whether this is along far enough to merge. If so it will still make it into 0.13. If not, it will be merged after 0.13 is branched, and will thus roll forward to 0.14.\n\n\* This doesn't mean that there cannot be improvements or small fix",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226946706,226946706,
TheBlueMatt,2016-06-18T19:38:08Z,"@JeremyRubin Indeed, sadly this is inherit in any similar optimizations :(.  As @gmaxwell points out we can limit the impact by broadening the scope of what we look at during reconstruction, but we will never be able to fully solve this problem. Still, the goal of this work is to reduce bandwidth during relay on the P2P network, not neccessarily improve relay times, as other solutions are better t",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226961099,226961099,
JeremyRubin,2016-06-19T02:40:59Z,"@TheBlueMatt @gmaxwell, thanks for your responses.\n\nI agree that this seems like a fundamental problem with such optimizations. @TheBlueMatt, it might help to clarify the BIP to emphasize that the latency reduction side effect is easily attacked, relying on the decreased latency would be a DOS vector waiting to happen.\n\nI do not think that looking at more caches is a great solution as the prob",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226976048,226976048,
TheBlueMatt,2016-06-19T08:35:37Z,"@laanwj thanks for the update.\n\nUpdates: Pulled in #8220, which is required. Various small code updates in a few places, nothing that changes behavior, except for sync logic:\nPulled out the fix that removes the DoS penalty for non-conencting header messages. Still think thats a really useful change, but it could be replaced with a return or something now since the compact block stuff doesnt rel",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226986053,226986053,
TheBlueMatt,2016-06-20T04:31:24Z,"I have no idea why the travis tests failed here, and the error message seems to indicate its a bug in Travis or so?\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227048409,227048409,
TheBlueMatt,2016-06-20T06:03:34Z,Fixed a few missing \ns in compact block log prints.\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227056841,227056841,
sipa,2016-06-21T17:29:21Z,"Tested ACK ccd06b94f69c3e7758c35ac4bcd36d0e9450e158\n\nThe block fetching logic is getting complicated, and is due for refactoring so that more logic can be shared for the decision logic about what to answer in response to inv/headers/cmpctblock, but that can be done later.\n\nFurthermore, it has been running on production systems with very good results for a while.\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227512441,227512441,
NicolasDorier,2016-06-21T21:55:48Z,"tested ACK ccd06b9 (https://github.com/MetacoSA/NBitcoin/blob/aeb5f56542765997fb6d22de3f11490c279d67ab/NBitcoin.Tests/cmpctblock_tests.cs)\nI also played manually with 1 bit shortids, to see how it handled collision and it worked fine.\n\nnits: SHORTTXIDS_LENGTH is unused and my comment on https://github.com/bitcoin/bitcoin/pull/8068/files#diff-7ec3c68a81efff79b6ca22ac1f1eabbaR5080\n\nEDIT: my nit",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227584577,227584577,
sipa,2016-06-22T11:05:34Z,ReACK 48efec82f3a18364c019577495914fcebb425e35\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227711872,227711872,
btcdrak,2016-06-22T11:09:27Z,"ACK 48efec8, running node for three weeks using and abusing the connections.\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227712590,227712590,
laanwj,2016-06-22T11:48:22Z,casually-tested ACK https://github.com/bitcoin/bitcoin/commit/48efec82f3a18364c019577495914fcebb425e35\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227719950,227719950,
instagibbs,2016-06-22T12:04:19Z,nit: cmpctblock debug option not in help text in init.cpp\n,https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-227722867,227722867,
rebroad,2016-08-24T04:47:39Z,"I hope this is the right place to ask this, but how does this functionality differ from XThin? I notice that various other forks of Bitcoin Core include XThin functionality and these nodes do appear currently to be nodes that are relaying blocks faster than most other nodes. Would it not be worthwhile for Bitcore Core to include the ability to talk XThin also (in addition to compact blocks) thereb",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-241956384,241956384,
TheBlueMatt,2016-08-25T01:10:16Z,"@rebroad This has been answered a few times in other forums, but generally you mmight want to read the various comments at https://www.reddit.com/r/Bitcoin/comments/4hm1nq/bitcoindev_mailing_list_matt_corallo_proposes_new/d2qr24v. As to why not include both, last I checked the Xthin patch touched a ton of code, so would almost certainly conflict (since the various forks that have it forked off of ",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-242254543,242254543,
rebroad,2016-08-26T13:45:56Z,"@TheBlueMatt I'll give it a go... I'm also writing some patches that can cause my node to crawl around the network favouring the nodes that deliver blocks quicker (disconnecting the least node each time a block is received). Anyway, the XThin code does look pretty messy and it is a headache merging it in with Compact Blocks and SegWit, but I'm slowly working through it - I might give up before I'm",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-242739641,242739641,
laanwj,2016-08-26T15:35:09Z,"NACK on merging XTHIN code into Bitcoin Core, this will unnecessarily complicate the handling code. One 'compact blocks' implementation ought to be enough.\n",https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-242769581,242769581,
paveljanik,2016-05-18T05:41:59Z,clang warns about `lsb` and `msb` used uninitialized.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r63647803,63647803,src/blockencodings.h
NicolasDorier,2016-06-04T06:19:04Z,No need for taking lock on pool->cs ?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65798257,65798257,src/blockencodings.cpp
NicolasDorier,2016-06-04T08:08:15Z,"If you intend to do it later, it's better removing it from the PR. Just for curiosity, if it is later included, the goal will be to use sendcmpct's version to decide the type of serialization of the transactions ?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799356,65799356,src/blockencodings.h
NicolasDorier,2016-06-04T08:47:46Z,`fAnnounceUsingCMPCTBLOCK` is the way with which the remote node prefer to receive block notifications.\n\nIt gives no information about whether the remote node itself provide or not header and IDs.\nImho it should be fixed to:\n\n`State(pfrom->GetId())->fProvidesHeaderAndIDs = pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION && pfrom->nServices & NODE_NETWORK;`\n\nMoved when we the node receive the VE,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799753,65799753,src/main.cpp
NicolasDorier,2016-06-04T12:56:50Z,"nit: constant would be nice, 3 is reused on https://github.com/bitcoin/bitcoin/pull/8068/files#diff-7ec3c68a81efff79b6ca22ac1f1eabbaR5499\n\nActually I think that this whole code about unsubscribing from CMPCTBLOCK of other node and registering to this node is duplicated below.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65802242,65802242,src/main.cpp
NicolasDorier,2016-06-04T14:32:29Z,typo: indicies\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65803246,65803246,src/main.cpp
TheBlueMatt,2016-06-06T07:45:33Z,"Not sure what you're asking? There is no explicit lock on cs here, but ReleaseTxLock does LOCK(cs) itself.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848221,65848221,src/blockencodings.cpp
TheBlueMatt,2016-06-06T07:46:09Z,"Yes, use the version field in cmpctblock is the upgrade mechanism here.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848308,65848308,src/blockencodings.h
TheBlueMatt,2016-06-06T08:07:05Z,"Yup, they were just inverted, fixed.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65850726,65850726,src/main.cpp
NicolasDorier,2016-06-06T16:50:42Z,"ok, it responds to my question thanks.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65925840,65925840,src/blockencodings.cpp
NicolasDorier,2016-06-08T08:18:30Z,nit: You can early return here instead of using a boolean.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66210588,66210588,src/main.cpp
NicolasDorier,2016-06-08T08:32:00Z,Are locks recursive ?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66212626,66212626,src/main.cpp
NicolasDorier,2016-06-08T08:35:39Z,"nit: typo rquset, also should add a space after '//'\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66213351,66213351,src/main.cpp
NicolasDorier,2016-06-08T09:11:28Z,"nit: typo ""didnt"" and ""Its""\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66219767,66219767,src/main.cpp
TheBlueMatt,2016-06-08T09:52:14Z,Yes. Otherwise we'd have ~infinity deadlocks.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66226140,66226140,src/main.cpp
sdaftuar,2016-06-09T19:47:10Z,Won't this put us in an infinite loop if our peer has a broken implementation?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66508975,66508975,src/main.cpp
TheBlueMatt,2016-06-09T22:48:14Z,"Yes, but do we care? I'm not sure how to fix this without adding a bunch more per-node state, but I'm sure there are other infinite loops somewhere in the protocol if people are broken in the right way. \n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66535697,66535697,src/main.cpp
sdaftuar,2016-06-10T01:31:05Z,"Well my guess is that this isn't a theoretical problem, but an actual one -- I just started grepping the debug logs on one of my nodes, and I'm seeing roughly 1 message/day of the form ""ERROR: AcceptBlockHeader: prev block not found"".  I didn't check in depth, but I believe that corresponds to the condition that the handling of getheaders messages is broken, which would mean the infinite loop beha",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66549905,66549905,src/main.cpp
instagibbs,2016-06-10T14:14:52Z,What is the reasoning for uint16 here? Local space savings? ( I know this practically isn't a big deal due to realistic near future blocksizes but still)\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66619669,66619669,src/blockencodings.h
btcdrak,2016-06-10T18:37:03Z,Can't we just apply a small ban score each time?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66661338,66661338,src/main.cpp
gmaxwell,2016-06-10T18:43:47Z,"Though it doesn't have to be done now,  it would be good to simply mark both txn that collide in the compact block as missing instead of immediately falling back.  I've been testing in this way, and finding that even with 16-bit short IDs a super-majority of blocks are successfully reconstructed with only a relatively small number of gettxn. \n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66662351,66662351,src/blockencodings.cpp
TheBlueMatt,2016-06-10T18:49:39Z,"Dunno, easier to be careful about using the ""right"" types so that any assumptions you might make later about range of a value dont blow up in your face...probably no real reason for this, but...it just is\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663232,66663232,src/blockencodings.h
TheBlueMatt,2016-06-10T18:54:06Z,"Well the point of this was also to ensure that peers can enable us to do headers-sync without them needing to keep lots of state about where our blockchain is. The fact that headers messages /must/ connect seems rather insane to me from a protocol-design perspective (also because its not written that way in the BIP). \n\nWithin that context, the only state you could add to fix this is to try to tr",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663860,66663860,src/main.cpp
TheBlueMatt,2016-06-10T18:55:59Z,Added a //TODO note so that someone who goes through and cleans up all the optimizations later can track them.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66664155,66664155,src/blockencodings.cpp
sipa,2016-06-12T22:04:22Z,"Using `std::make_shared(cmpctblock.prefilledtxn[i].tx)` is slightly more efficient, as it allocates the reference counter and the CTransaction in a single malloc, while the normal std::shared_ptr constructor needs two separate ones.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728455,66728455,src/blockencodings.cpp
sipa,2016-06-12T22:10:24Z,"I'd rather say ""// Future transaction compression standards could be implemented here"" rather than TODO, as there is no actionable change you could make right now.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728565,66728565,src/blockencodings.h
sipa,2016-06-12T22:58:14Z,"Is it necessary that we treat a non-connecting header as an inv? If the peer is not tracking any headers tree and just relaying headers, requesting anything from them won't do us any good anyway, and that seems to be the only use case for this?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729306,66729306,src/main.cpp
sipa,2016-06-12T23:11:59Z,What is the reason for this? I think we should check early and dosban peers who getdata a CMPCT_BLOCK that was not recently inved.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729475,66729475,src/main.cpp
sipa,2016-06-12T23:28:10Z,I don't think this test should be here. The block below (that builds vHeaders) can skip things from vBlockHashesToAnnounce.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729707,66729707,src/main.cpp
sipa,2016-06-12T23:29:38Z,"... continued. This if block could be replaced by the if inside of it, and making it reset vHeaders. No code movement for the normal headers inv is necessary in that case.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729737,66729737,src/main.cpp
sipa,2016-06-12T23:33:21Z,s/COMPRBLOCK/CMPCTBLOCK/\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729795,66729795,src/main.cpp
sipa,2016-06-12T23:46:53Z,An auto type may be worth it here.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729990,66729990,src/main.cpp
TheBlueMatt,2016-06-12T23:47:09Z,"The current code requires that you track the state of each of your peer's headers chain or risk getting DoS banned (which is not mentioned in the spec, and is something which we actually do not fully do currently without races - resulting in these prints appearing occasionally in debug.log). I'd say its a pretty non-trivial bug.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729997,66729997,src/main.cpp
sipa,2016-06-12T23:49:12Z,"Sorry if I'm not clear. I suggest changing it so that we don't DoS in that case, but also don't respond with a getheaders. Or rather, I'm wondering whether that suffices for your use case.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730022,66730022,src/main.cpp
sipa,2016-06-12T23:52:19Z,"That's pretty unintuitive behaviour, and I don't think it's necessary to put that much decision logic in this function. I think it could just return a `QueuedBlock*` always, and then the caller can then insert a new partialBlock if needed.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730069,66730069,src/main.cpp
TheBlueMatt,2016-06-12T23:53:43Z,I tend to prefer not auto-typing when I'm gonna actually use some part of the type (ie I'd like to ensure there be a compiler error if  I'm accessing a variable and it changes type).\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730088,66730088,src/main.cpp
sipa,2016-06-13T00:24:20Z,"Perhaps this part can be factored out into a separate function, that can be called from the codepath for CMPCTBLOCKs that don't have any missing txn?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730648,66730648,src/main.cpp
TheBlueMatt,2016-06-13T02:53:23Z,"There is no DoS score involved in a request for which we did not send an inv (ie something which is buried in our chain), only for those which request something with !BLOCK_HAVE_DATA. For those, we definitely wont even send a CMPCTBLOCK, because its covered by the surrounding if statement. \n\nAs for not sending the compact block if the block is >= 10 deep, yes, I can add an if statement and simpl",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735226,66735226,src/main.cpp
TheBlueMatt,2016-06-13T03:11:22Z,"For now I swapped in the same call-headers-msg code from CMPCTBLOCK handling into the CMPCTBLOCK code  call ::BLOCKTXN handling. Its a dirty hack to serialize and then immediately deserialize a message, but its a short message so it doesnt cost much, and I'm assuming the network stack will be (properly) rewritten soonish anyway, so then it can be called like the individual function it should be.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735956,66735956,src/main.cpp
TheBlueMatt,2016-06-13T04:24:18Z,I don't immediately see how to resolve this in the way you're suggesting.  Because I want to share the code in the first if (!fRevertToInv) block I need to change the definition of fRevertToInv (or the condition for that block) slightly.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66738999,66738999,src/main.cpp
TheBlueMatt,2016-06-13T04:25:43Z,"I think this may be possible by bending over backwards to change fRevertToInv in the right way between the !fRevertToInv and fRevertToInv conditionals, but I think that just makes the already hard-to-read code even worse, which is not worth saving a tiny bit of code movement to me.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739056,66739056,src/main.cpp
TheBlueMatt,2016-06-13T04:33:33Z,"Differing philosophy, I guess...Indeed, this already isnt an issue for the CMPCTBLOCK handling, but I really don't like the idea that our peer might notify us that they have some blocks available and we will simply ignore them because they aren't keeping track of our chainstate. Can we use hashLastUnknownBlock to track if we hit the infinite-loop condition without adding additional state here?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739275,66739275,src/main.cpp
sipa,2016-06-13T14:55:52Z,I don't think the xor helps at all. Groups of short ids that were close together (and thus had a high chance of ending up in the same bucket) remain close together.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806224,66806224,src/blockencodings.cpp
sipa,2016-06-13T14:59:21Z,"Thinking more about this, I think it is fine. Assuming the peer responds with a headers chain that indeed matches the locator we send, the same condition won't trigger again.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806934,66806934,src/main.cpp
sipa,2016-06-13T15:00:30Z,A better suggestion than what I said before: just replace this whole block with `stream << header << nonce`.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66807276,66807276,src/blockencodings.cpp
sipa,2016-06-13T15:06:22Z,Why is this moved?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66808314,66808314,src/main.cpp
sipa,2016-06-13T15:22:32Z,I mean like here: https://github.com/sipa/bitcoin/commit/526a02c114a5f34fef053d3550438ebb9e741b42\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66811617,66811617,src/main.cpp
TheBlueMatt,2016-06-13T17:43:07Z,"LOL, I must've been really tired when I thought that one through....anyway, I'll do the bucket-count thing.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835159,66835159,src/blockencodings.cpp
TheBlueMatt,2016-06-13T17:43:17Z,"Heh, good point.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835192,66835192,src/blockencodings.cpp
TheBlueMatt,2016-06-13T17:46:02Z,I believe that was exactly Suhas' concern - that a peer might respond to a headers request with a chain that was disconnected from our locator.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835600,66835600,src/main.cpp
TheBlueMatt,2016-06-13T17:46:33Z,To prevent yet more includes and the crazy-looking GetAdjustedTime call from within the GetBlock stuff. See https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224781229\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835690,66835690,src/main.cpp
sipa,2016-06-13T21:08:41Z,Fair enough.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66868501,66868501,src/main.cpp
NicolasDorier,2016-06-13T21:12:30Z,"nit of some incoherences: \n1. ushort were used in PrefilledTransaction to represent an index but here it is uint. \n2. PrefilledTransaction->index represent a differential index, but BlockTransactionsRequest->indexes represent absolute indexes (because the translation from diff to absolute is done during seria/deseria)\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869150,66869150,src/blockencodings.h
sipa,2016-06-13T21:12:30Z,"What would work is multiplying by a random odd 64-bit integer, but I agree - bucket counting sounds better. You could do a chi-square test.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869151,66869151,src/blockencodings.cpp
NicolasDorier,2016-06-13T21:29:27Z,"maybe should check\n\n```\nif(index > std::numeric_limits<uint32_t>::max())\n                    throw std::ios_base::failure(""indexes overflowed 32-bits"");\n```\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66871970,66871970,src/blockencodings.h
sipa,2016-06-14T16:39:50Z,Ping? I think the code I linked above is simpler and easier to read.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67007859,67007859,src/main.cpp
sipa,2016-06-14T17:47:56Z,"How accurate was your simulation? If I approximate the chance as buckets*P[binomial(n,1.0/buckets)], where n<=buckets (due to max_load_factor=1.0 by default for unordered_map), this would randomly fail about once every 9000 transmissions for n=10000 buckets=10000.\n\nAccording to this approximation, if we want the random failure chance to be less than once in a billion, you need:\n- `> 10` for up ",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67020645,67020645,src/blockencodings.cpp
sdaftuar,2016-06-14T18:36:55Z,"Yes, I just looked at the first example of ""prev block not found"" in the debug log of one my long-running listening nodes, and it's a peer that fails to send connecting headers on initial startup:\n\n```\n2016-05-30 12:50:07 Added connection to [redacted] peer=963241\n2016-05-30 12:50:07 received: version (102 bytes) peer=963241\n2016-05-30 12:50:07 send version message: version 70012, blocks=4140",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67030264,67030264,src/main.cpp
TheBlueMatt,2016-06-14T19:42:45Z,"This requires fPreferHeaders in order for fPreferHeaderAndIDs to work, which I was deliberately trying to avoid.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67042310,67042310,src/main.cpp
sdaftuar,2016-06-16T01:11:43Z,"I think there's an off by one here.  If shorttxids.size() == 0, and prefilledtxn.size() == 1, then sending a compact block with prefilledtxn[0].index = 1 would pass this check, but cause an out-of-bounds memory access below.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273405,67273405,src/blockencodings.cpp
sdaftuar,2016-06-16T01:16:41Z,"comment nit: i was convinced there were all kinds of potential for overflows until I found the sanity check on the prefilledtxn index values that is done in deserialization (which also explained why you have this uint16_t max check, which was inexplicable from looking at the surrounding code).  Adding a short comment explaining the logic would be helpful to future code readers.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273833,67273833,src/blockencodings.cpp
sdaftuar,2016-06-16T01:16:53Z,nit: this could be shortened using `cmpctblock.BlockTxCount()`\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273846,67273846,src/blockencodings.cpp
sdaftuar,2016-06-16T01:23:09Z,Agree with @sipa about making this a `vector<bool>`!\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67274625,67274625,src/blockencodings.cpp
sdaftuar,2016-06-16T02:02:32Z,"I think HAVE_DATA is the wrong check if we are a pruning node.  We should do `if (pindex->nTx > 0)` instead.\n\nOn further thought, `pindex->nTx > 0` isn't right either, if there are any scenarios where a pruning node might re-request (via cmpctblock) a previously validated block in order to reorg to the chain that block is on.  I think elsewhere in the code, we catch this case by checking to see ",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277374,67277374,src/main.cpp
sdaftuar,2016-06-16T02:12:19Z,"Again, here we should instead check if `pindex->pprev->nTx > 0`, so that this will work in the pruning case (it probably doesn't actually matter much in this specific case, but I think it's better to not use HAVE_DATA to minimize future errors).\n\nAlso, I think before we try to work on reconstructing the block and potentially requesting it, we should have a check that either we requested this CMP",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277972,67277972,src/main.cpp
sdaftuar,2016-06-16T02:29:25Z,"We should clear the block as no longer being in flight.  Otherwise we're relying on the `Misbehaving()` to cause a disconnect, which would eventually clear the state -- but this seems error prone, eg if the node happens to be whitelisted.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67279075,67279075,src/main.cpp
TheBlueMatt,2016-06-16T20:00:16Z,I really dont like doing a malloc() for such a small buffer :/\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67413739,67413739,src/blockencodings.cpp
sipa,2016-06-16T20:03:41Z,You're already doing a malloc for each shortid in the unordered_map above.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67414301,67414301,src/blockencodings.cpp
TheBlueMatt,2016-06-16T20:30:57Z,"True, but I didnt want to implement my own unordered_map...a vector<bool> is easy :p\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67418447,67418447,src/blockencodings.cpp
sipa,2016-06-16T23:00:33Z,"Use `vTxHashes[it->vTxHashesIdx] = std::move(vTxHashes[vTxHashes.size() - 1])` or `std::swap(vTxHashes[it->vTxHashesIdx], vTxHashes[vTxHashes.size() - 1])` to avoid needing std::shared_ptr copy (which needs an atomic operation to increment the refcount).\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67439082,67439082,src/txmempool.cpp
sipa,2016-06-16T23:06:25Z,"If not for this find, we wouldn't need a wtxid index in the mempool... as long we don't build `vTxHashes` asynchronously, it could be done by storing a `CTxMemPool::txiter` in `vTxHashes` instead of a `std::shared_ptr<const CTransaction>`.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67439622,67439622,src/txmempool.cpp
TheBlueMatt,2016-06-17T00:57:40Z,"I avoided doing that since I didnt want to look up iterator invalidation in boost's multi index map, will do that now.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67448620,67448620,src/txmempool.cpp
sdaftuar,2016-06-17T02:27:52Z,"Further thought: just drop this condition, and always process the CMPCTBLOCK.  We don't need the parents of this block to have arrived to correctly reconstruct and process the CMPCTBLOCK (just like we are able to process full blocks out of order).  This fixes the sync bug that is popping up in the RPC tests.\n\nThen you can also get rid of the code in the else{} down below, where you invoke the HE",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67453756,67453756,src/main.cpp
sipa,2016-06-17T04:19:00Z,They are never invalidated until you delete the item itself.\nhttp://www.boost.org/doc/libs/1_60_0/libs/multi_index/doc/tutorial/indices.html#guarantees\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67459055,67459055,src/txmempool.cpp
TheBlueMatt,2016-06-17T05:17:07Z,"Yes, I found that out after looking it up :)\n\nOn June 16, 2016 9:19:08 PM PDT, Pieter Wuille notifications@github.com wrote:\n\n> > @@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n> >      BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n> >          mapNextTx.erase(txin.prevout);\n> > -    if (vTxHashes.size() > 1) {\n> > -        vTxHashes[it->vTxHashesIdx] = vTxHashes[vTxH",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67461680,67461680,src/txmempool.cpp
sipa,2016-06-17T05:39:40Z,An alternative for the cast is marking vTxHashes as mutable\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67462719,67462719,src/txmempool.cpp
sipa,2016-06-17T16:07:43Z,"If BLOCK_HAVE_DATA is set, there is no need to process the CMPCTBLOCK, regardless of pruning, no?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67535136,67535136,src/main.cpp
sipa,2016-06-17T16:20:18Z,"1) Agree, just drop this condition. We can deal with discontinuous blocks just fine (maybe we should check that we're not too far ahead of the main chain, though EDIT: CanDirectFetch already does that).\n\n2) I agree we also need direct fetching logic in response to CMPCTBLOCK, but it's less needed than for HEADERS, as CMPCTBLOCK are usually just sent as a single tip. Also, I really want that dire",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67536925,67536925,src/main.cpp
sdaftuar,2016-06-17T19:05:44Z,"Oops, I meant I think we need a cs_main lock here (deleted other comment).\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67560230,67560230,src/main.cpp
NicolasDorier,2016-06-19T20:31:05Z,This variable is not very useful anymore.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67623323,67623323,src/main.cpp
NicolasDorier,2016-06-19T20:43:03Z,"I don't think this is a good idea.\nBut if you insist doing that, I think you should not use ' - 10'.\n\nImagine the following event:\n- This peer send a cmpct_blocks at block tip - 10\n- New block discovered\n- Remote peer respond with GETBLOCKTXN\n- This peer will not respond to it causing a timeout for the remote peer\n\nI think you should ideally remove this condition, which is not a DDOS vect",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67623486,67623486,src/main.cpp
sipa,2016-06-20T15:15:23Z,"I agree, the max depth for responding to getblocktxn should be higher than for responding to a getdata cmpctblock.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67707840,67707840,src/main.cpp
sipa,2016-06-20T15:18:40Z,Below is a line that stops the getdata processing loop when we have processed sending a block. I think MSG_CMPCT_BLOCK should be included in that line.\n\n(github app does not allow me to comment on the line itself)\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67708460,67708460,src/main.cpp
instagibbs,2016-06-20T19:12:27Z,"Why not just put them in the front of the queue to avoid ""eviction""? \n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67748651,67748651,src/main.cpp
TheBlueMatt,2016-06-21T19:54:49Z,"Ehh, I prefer to make it clear that its a bool instead of using false and getting some crazy C magic where you never know what type you end up with :p\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67939725,67939725,src/main.cpp
instagibbs,2016-06-21T19:58:55Z,"I think he means it will always be false at 474, and true at 479?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67940359,67940359,src/main.cpp
TheBlueMatt,2016-06-21T20:03:54Z,Will fix in PR #2.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67941211,67941211,src/main.cpp
TheBlueMatt,2016-06-21T20:15:36Z,"Yea, I mean its intended to be a constant, just to force type since I feel better serializing variables and not in-code constants. Maybe (ok, definitely) I'm just crazy :p.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67943050,67943050,src/main.cpp
TheBlueMatt,2016-06-21T20:27:06Z,See #8235\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67945037,67945037,src/main.cpp
NicolasDorier,2016-06-21T21:40:26Z,unused\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67957224,67957224,src/blockencodings.h
instagibbs,2016-06-21T21:54:01Z,it's used in 2 static_asserts?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67959354,67959354,src/blockencodings.h
NicolasDorier,2016-06-21T22:50:31Z,"yes, but not in actual code\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67966965,67966965,src/blockencodings.h
TheBlueMatt,2016-06-21T23:10:06Z,Fixed\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67969186,67969186,src/main.cpp
TheBlueMatt,2016-06-21T23:10:18Z,"Added a temporary fix here, will add more in #8235.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67969222,67969222,src/main.cpp
TheBlueMatt,2016-06-21T23:20:05Z,"Yes, it is intended to exist purely for assertions. If you just look at the code you might assume you can change the encoding and it'll continue to work fine, but this is not true. So instead we add a constant and static_assert.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67970268,67970268,src/blockencodings.h
TheBlueMatt,2016-06-21T23:58:22Z,"where the static_asserts are right beside all of the points in the code you'd have to change, that is.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67974257,67974257,src/blockencodings.h
fanquake,2016-06-22T11:17:59Z,Does this need to be removed?\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r68035462,68035462,src/net.h
fanquake,2016-06-22T11:19:02Z,nit s/shord/short\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r68035572,68035572,src/version.h
sipa,2016-06-22T11:20:11Z,"Yes, there is a (slightly) longer description in net.cpp.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r68035701,68035701,src/net.h
Roasbeef,2016-08-24T21:42:29Z,It was moved to `ContextualCheckBlockHeader`. \n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r76144682,76144682,src/main.cpp
rebroad,2016-09-11T06:55:56Z,"Are you assuming AcceptBlockHeader returned true at this point in the code? If so, surely the return statement above is in the wrong place.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r78288938,78288938,src/main.cpp
TheBlueMatt,2016-09-12T13:21:23Z,"AcceptBlockHeader will either set state invalid or return true. At some point it might also set state.IsError, though it doesnt currently, in which case assert(NULL) isnt all that bad an outcome.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r78370407,78370407,src/main.cpp
rebroad,2016-09-12T17:49:15Z,"I'm confused, why getdata it if it's already in flight?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r78420276,78420276,src/main.cpp
rebroad,2016-09-12T17:50:58Z,"Still confused - ""in-flight"" means it's already been requested, doesn't it? Perhaps it can be clarified somewhere what the term means?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r78420607,78420607,src/main.cpp
rebroad,2016-11-01T05:15:02Z,"This practice of using function names that then are not used for what their name implies make me quite uncomfortable about the reliability of the code. I would far prefer to see MarkBlockAsInFlight called only just before or just after the block is in flight, i.e. after the PushMessage of GETDATA. For readability more than anything else.\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r85876425,85876425,src/main.cpp
rebroad,2016-11-01T05:24:00Z,Still confused by this. I guess this isn't the place to seek clarification....\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r85876894,85876894,src/main.cpp
rebroad,2016-11-01T07:26:43Z,would `if (pindex->nTx > 0)` be better since we'd also have nothing to do here if we received a compact block for a block that we've already pruned.\n,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r85884845,85884845,src/main.cpp
rebroad,2016-11-01T08:04:02Z,"fAlreadyInFlight is a confusing variable name since it will be true if we requested the block and false if we did not, therefore fRequested would be a more suitable variable name, wouldn't it?\n\nOr is the intention to ask if it's been requested from another peer?\n\nDoes it matter if it was requested from this peer, or another peer?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r85887822,85887822,src/main.cpp
rebroad,2016-11-01T08:15:43Z,"I'm realising that the variable fAlreadyInFlight isn't meaning whether it's in fight, but perhaps is supposed to refer to whether the block was requested or not...?\n",https://github.com/bitcoin/bitcoin/pull/8068#discussion_r85888692,85888692,src/main.cpp
rebroad,2021-09-02T15:56:38Z,Why not start at index 1 instead of 0 (since isn't this always the prefilled tx)?,https://github.com/bitcoin/bitcoin/pull/8068#discussion_r701220230,701220230,src/main.cpp
