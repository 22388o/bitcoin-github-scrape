[
  {
    "sha": "b37bcbc04e72e0c34724e910e46e5d91696b68a7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMzdiY2JjMDRlNzJlMGMzNDcyNGU5MTBlNDZlNWQ5MTY5NmI2OGE3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-19T07:03:16Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-27T18:18:52Z"
      },
      "message": "Make CBlockIndex*es in net_processing const",
      "tree": {
        "sha": "eccd2b22a29efd07c6969089e4d168b669472c4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eccd2b22a29efd07c6969089e4d168b669472c4f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b37bcbc04e72e0c34724e910e46e5d91696b68a7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b37bcbc04e72e0c34724e910e46e5d91696b68a7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b37bcbc04e72e0c34724e910e46e5d91696b68a7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b37bcbc04e72e0c34724e910e46e5d91696b68a7/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7aa700424cbda387536373d8dfec88aee43f950e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7aa700424cbda387536373d8dfec88aee43f950e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7aa700424cbda387536373d8dfec88aee43f950e"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 29,
      "deletions": 27
    },
    "files": [
      {
        "sha": "0e7851d63b13c38cae3dd5887c9493b2a9ae99fd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b37bcbc04e72e0c34724e910e46e5d91696b68a7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b37bcbc04e72e0c34724e910e46e5d91696b68a7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b37bcbc04e72e0c34724e910e46e5d91696b68a7",
        "patch": "@@ -101,7 +101,7 @@ namespace {\n     /** Blocks that are in flight, and that are in the queue to be downloaded. Protected by cs_main. */\n     struct QueuedBlock {\n         uint256 hash;\n-        CBlockIndex* pindex;                                     //!< Optional.\n+        const CBlockIndex* pindex;                               //!< Optional.\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n@@ -156,13 +156,13 @@ struct CNodeState {\n     //! List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n-    CBlockIndex *pindexBestKnownBlock;\n+    const CBlockIndex *pindexBestKnownBlock;\n     //! The hash of the last unknown block this peer has announced.\n     uint256 hashLastUnknownBlock;\n     //! The last full block we both have.\n-    CBlockIndex *pindexLastCommonBlock;\n+    const CBlockIndex *pindexLastCommonBlock;\n     //! The best header we have sent our peer.\n-    CBlockIndex *pindexBestHeaderSent;\n+    const CBlockIndex *pindexBestHeaderSent;\n     //! Length of current-streak of unconnecting headers announcements\n     int nUnconnectingHeaders;\n     //! Whether we've started headers synchronization with this peer.\n@@ -331,7 +331,7 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n@@ -432,7 +432,7 @@ bool CanDirectFetch(const Consensus::Params &consensusParams)\n }\n \n // Requires cs_main\n-bool PeerHasHeader(CNodeState *state, CBlockIndex *pindex)\n+bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n {\n     if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n         return true;\n@@ -443,7 +443,7 @@ bool PeerHasHeader(CNodeState *state, CBlockIndex *pindex)\n \n /** Find the last common ancestor two blocks have.\n  *  Both pa and pb must be non-NULL. */\n-CBlockIndex* LastCommonAncestor(CBlockIndex* pa, CBlockIndex* pb) {\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n     if (pa->nHeight > pb->nHeight) {\n         pa = pa->GetAncestor(pb->nHeight);\n     } else if (pb->nHeight > pa->nHeight) {\n@@ -462,7 +462,7 @@ CBlockIndex* LastCommonAncestor(CBlockIndex* pa, CBlockIndex* pb) {\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n+void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n     if (count == 0)\n         return;\n \n@@ -490,8 +490,8 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n     if (state->pindexLastCommonBlock == state->pindexBestKnownBlock)\n         return;\n \n-    std::vector<CBlockIndex*> vToFetch;\n-    CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n+    std::vector<const CBlockIndex*> vToFetch;\n+    const CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n     // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n     // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n     // download that next block if the window were 1 larger.\n@@ -514,7 +514,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n         // are not yet downloaded and not in flight to vBlocks. In the mean time, update\n         // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n         // already part of our chain (and therefore don't need it even if pruned).\n-        BOOST_FOREACH(CBlockIndex* pindex, vToFetch) {\n+        BOOST_FOREACH(const CBlockIndex* pindex, vToFetch) {\n             if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n                 // We consider the chain that this peer is on invalid.\n                 return;\n@@ -1047,7 +1047,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n-uint32_t GetFetchFlags(CNode* pfrom, CBlockIndex* pprev, const Consensus::Params& chainparams) {\n+uint32_t GetFetchFlags(CNode* pfrom, const CBlockIndex* pprev, const Consensus::Params& chainparams) {\n     uint32_t nFetchFlags = 0;\n     if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n@@ -1452,7 +1452,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         LOCK(cs_main);\n \n         // Find the last block the caller has in the main chain\n-        CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);\n+        const CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);\n \n         // Send the rest of the chain\n         if (pindex)\n@@ -1548,7 +1548,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         CNodeState *nodestate = State(pfrom->GetId());\n-        CBlockIndex* pindex = NULL;\n+        const CBlockIndex* pindex = NULL;\n         if (locator.IsNull())\n         {\n             // If locator is null, return the hashStop block\n@@ -1768,7 +1768,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n         }\n \n-        CBlockIndex *pindex = NULL;\n+        const CBlockIndex *pindex = NULL;\n         CValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n             int nDoS;\n@@ -2026,7 +2026,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n-        CBlockIndex *pindexLast = NULL;\n+        const CBlockIndex *pindexLast = NULL;\n         {\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n@@ -2103,8 +2103,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n-            vector<CBlockIndex *> vToFetch;\n-            CBlockIndex *pindexWalk = pindexLast;\n+            vector<const CBlockIndex *> vToFetch;\n+            const CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n@@ -2126,7 +2126,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             } else {\n                 vector<CInv> vGetData;\n                 // Download as much as possible, from earliest to latest.\n-                BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vToFetch) {\n+                BOOST_REVERSE_FOREACH(const CBlockIndex *pindex, vToFetch) {\n                     if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         // Can't download any more from this peer\n                         break;\n@@ -2717,7 +2717,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             bool fRevertToInv = ((!state.fPreferHeaders &&\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n-            CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n             ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n@@ -2728,7 +2728,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n                     BlockMap::iterator mi = mapBlockIndex.find(hash);\n                     assert(mi != mapBlockIndex.end());\n-                    CBlockIndex *pindex = mi->second;\n+                    const CBlockIndex *pindex = mi->second;\n                     if (chainActive[pindex->nHeight] != pindex) {\n                         // Bail out if we reorged away from this block\n                         fRevertToInv = true;\n@@ -2805,7 +2805,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();\n                     BlockMap::iterator mi = mapBlockIndex.find(hashToAnnounce);\n                     assert(mi != mapBlockIndex.end());\n-                    CBlockIndex *pindex = mi->second;\n+                    const CBlockIndex *pindex = mi->second;\n \n                     // Warn if we're announcing a block that is not on the main chain.\n                     // This should be very rare and could be optimized out.\n@@ -2990,10 +2990,10 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         //\n         vector<CInv> vGetData;\n         if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            vector<CBlockIndex*> vToDownload;\n+            vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n-            BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n+            BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);"
      },
      {
        "sha": "c720be272632bf49d25290c29c7d10a83d441f5d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b37bcbc04e72e0c34724e910e46e5d91696b68a7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b37bcbc04e72e0c34724e910e46e5d91696b68a7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b37bcbc04e72e0c34724e910e46e5d91696b68a7",
        "patch": "@@ -3029,12 +3029,14 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n }\n \n // Exposed wrapper for AcceptBlockHeader\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex)\n {\n     {\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n-            if (!AcceptBlockHeader(header, state, chainparams, ppindex)) {\n+            // cast away the ppindex-returns-const CBlockIndex - we're just assigning it to a CBlockIndex*\n+            // that we own and is updated non-const anyway\n+            if (!AcceptBlockHeader(header, state, chainparams, const_cast<CBlockIndex**>(ppindex))) {\n                 return false;\n             }\n         }"
      },
      {
        "sha": "035766d4d8b2c3e4132a82ff8a397937b962d7cb",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b37bcbc04e72e0c34724e910e46e5d91696b68a7/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b37bcbc04e72e0c34724e910e46e5d91696b68a7/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=b37bcbc04e72e0c34724e910e46e5d91696b68a7",
        "patch": "@@ -243,7 +243,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n  * @param[in]  chainparams The params for the chain we want to connect to\n  * @param[out] ppindex If set, the pointer will be set to point to the last new block index object for the given headers\n  */\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex=NULL);\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=NULL);\n \n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);"
      }
    ]
  },
  {
    "sha": "c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMjE0ZDEyMGEzNjNhMDViYTlhZmRjY2ZmNmI0YmRhNmUyOWFlN2M0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-24T19:34:20Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-27T18:18:52Z"
      },
      "message": "Split CNode::cs_vSend: message processing and message sending\n\ncs_vSend is used for two purposes - to lock the datastructures used\nto queue messages to place on the wire and to only call\nSendMessages once at a time per-node. I believe SendMessages used\nto access some of the vSendMsg stuff, but it doesn't anymore, so\nthese locks do not need to be on the same mutex, and also make\ndeadlocking much more likely.",
      "tree": {
        "sha": "8de10442fefbf1b6c2188ccbcd39cf7c990760c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8de10442fefbf1b6c2188ccbcd39cf7c990760c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c214d120a363a05ba9afdccff6b4bda6e29ae7c4/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b37bcbc04e72e0c34724e910e46e5d91696b68a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b37bcbc04e72e0c34724e910e46e5d91696b68a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b37bcbc04e72e0c34724e910e46e5d91696b68a7"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 11,
      "deletions": 13
    },
    "files": [
      {
        "sha": "2593c63757402df176553576e7b22d0157db61cf",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 13,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c214d120a363a05ba9afdccff6b4bda6e29ae7c4/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c214d120a363a05ba9afdccff6b4bda6e29ae7c4/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
        "patch": "@@ -1160,12 +1160,10 @@ void CConnman::ThreadSocketHandler()\n                 // * We wait for data to be received (and disconnect after timeout).\n                 // * We process a message in the buffer (message handler thread).\n                 {\n-                    TRY_LOCK(pnode->cs_vSend, lockSend);\n-                    if (lockSend) {\n-                        if (!pnode->vSendMsg.empty()) {\n-                            FD_SET(pnode->hSocket, &fdsetSend);\n-                            continue;\n-                        }\n+                    LOCK(pnode->cs_vSend);\n+                    if (!pnode->vSendMsg.empty()) {\n+                        FD_SET(pnode->hSocket, &fdsetSend);\n+                        continue;\n                     }\n                 }\n                 {\n@@ -1275,12 +1273,10 @@ void CConnman::ThreadSocketHandler()\n                 continue;\n             if (FD_ISSET(pnode->hSocket, &fdsetSend))\n             {\n-                TRY_LOCK(pnode->cs_vSend, lockSend);\n-                if (lockSend) {\n-                    size_t nBytes = SocketSendData(pnode);\n-                    if (nBytes)\n-                        RecordBytesSent(nBytes);\n-                }\n+                LOCK(pnode->cs_vSend);\n+                size_t nBytes = SocketSendData(pnode);\n+                if (nBytes)\n+                    RecordBytesSent(nBytes);\n             }\n \n             //\n@@ -1865,7 +1861,7 @@ void CConnman::ThreadMessageHandler()\n \n             // Send messages\n             {\n-                TRY_LOCK(pnode->cs_vSend, lockSend);\n+                TRY_LOCK(pnode->cs_sendProcessing, lockSend);\n                 if (lockSend)\n                     GetNodeSignals().SendMessages(pnode, *this);\n             }"
      },
      {
        "sha": "30dfb61b1ae3bcc9857171137a929c551f200719",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c214d120a363a05ba9afdccff6b4bda6e29ae7c4/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c214d120a363a05ba9afdccff6b4bda6e29ae7c4/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
        "patch": "@@ -589,6 +589,8 @@ class CNode\n     std::deque<std::vector<unsigned char>> vSendMsg;\n     CCriticalSection cs_vSend;\n \n+    CCriticalSection cs_sendProcessing;\n+\n     std::deque<CInv> vRecvGetData;\n     std::deque<CNetMessage> vRecvMsg;\n     CCriticalSection cs_vRecvMsg;"
      }
    ]
  },
  {
    "sha": "0a15834e125d28bcaee977909c6c10624f7c8298",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTE1ODM0ZTEyNWQyOGJjYWVlOTc3OTA5YzZjMTA2MjRmN2M4Mjk4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-23T20:07:07Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-29T20:14:45Z"
      },
      "message": "Move mapNodeState into an encapsulation class",
      "tree": {
        "sha": "6d7f7850bb201c152acf04a635581525aa0000c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d7f7850bb201c152acf04a635581525aa0000c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a15834e125d28bcaee977909c6c10624f7c8298",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a15834e125d28bcaee977909c6c10624f7c8298",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a15834e125d28bcaee977909c6c10624f7c8298",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a15834e125d28bcaee977909c6c10624f7c8298/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c214d120a363a05ba9afdccff6b4bda6e29ae7c4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c214d120a363a05ba9afdccff6b4bda6e29ae7c4"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 35,
      "deletions": 22
    },
    "files": [
      {
        "sha": "1d495a49a82ab4f69a16587a7a169bad0e05f5fb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 22,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a15834e125d28bcaee977909c6c10624f7c8298/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a15834e125d28bcaee977909c6c10624f7c8298/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0a15834e125d28bcaee977909c6c10624f7c8298",
        "patch": "@@ -220,15 +220,41 @@ struct CNodeState {\n     }\n };\n \n-/** Map maintaining per-node state. Requires cs_main. */\n-map<NodeId, CNodeState> mapNodeState;\n+class NodeStateStorage {\n+    /** Map maintaining per-node state. Requires cs_main. */\n+    map<NodeId, CNodeState> mapNodeState;\n+\n+public:\n+    CNodeState *GetNodeState(NodeId nodeid) {\n+        AssertLockHeld(cs_main);\n+        map<NodeId, CNodeState>::iterator it = mapNodeState.find(nodeid);\n+        if (it == mapNodeState.end())\n+            return NULL;\n+        return &it->second;\n+    }\n+\n+    void AddStateForNode(NodeId nodeid, const CAddress& addr, const std::string& addrName) {\n+        LOCK(cs_main);\n+        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, addrName));\n+    }\n+\n+    void RemoveStateForNode(NodeId nodeid) {\n+        LOCK(cs_main);\n+\n+        mapNodeState.erase(nodeid);\n+\n+        if (mapNodeState.empty()) {\n+            // Do a consistency check after the last peer is removed.\n+            assert(mapBlocksInFlight.empty());\n+            assert(nPreferredDownload == 0);\n+            assert(nPeersWithValidatedDownloads == 0);\n+        }\n+    }\n+} nodeStateStorage;\n \n // Requires cs_main.\n-CNodeState *State(NodeId pnode) {\n-    map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n-    if (it == mapNodeState.end())\n-        return NULL;\n-    return &it->second;\n+static CNodeState *State(NodeId pnode) {\n+    return nodeStateStorage.GetNodeState(pnode);\n }\n \n void UpdatePreferredDownload(CNode* node, CNodeState* state)\n@@ -262,13 +288,7 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n }\n \n void InitializeNode(CNode *pnode, CConnman& connman) {\n-    CAddress addr = pnode->addr;\n-    std::string addrName = pnode->addrName;\n-    NodeId nodeid = pnode->GetId();\n-    {\n-        LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName)));\n-    }\n+    nodeStateStorage.AddStateForNode(pnode->GetId(), pnode->addr, pnode->addrName);\n     if(!pnode->fInbound)\n         PushNodeVersion(pnode, connman, GetTime());\n }\n@@ -293,14 +313,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n \n-    mapNodeState.erase(nodeid);\n-\n-    if (mapNodeState.empty()) {\n-        // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n-        assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n-    }\n+    nodeStateStorage.RemoveStateForNode(nodeid);\n }\n \n // Requires cs_main."
      }
    ]
  },
  {
    "sha": "56c439208058f34ab2bc32b47798c70328e6ba36",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NmM0MzkyMDgwNThmMzRhYjJiYzMyYjQ3Nzk4YzcwMzI4ZTZiYTM2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-29T20:13:10Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-01-01T04:10:08Z"
      },
      "message": "Give CNodeState its own lock (and accessor class for RAII access)",
      "tree": {
        "sha": "d6fba7e426c71c3995598bff8ae0d42d61e8ca3a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6fba7e426c71c3995598bff8ae0d42d61e8ca3a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56c439208058f34ab2bc32b47798c70328e6ba36",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c439208058f34ab2bc32b47798c70328e6ba36",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/56c439208058f34ab2bc32b47798c70328e6ba36",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c439208058f34ab2bc32b47798c70328e6ba36/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0a15834e125d28bcaee977909c6c10624f7c8298",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a15834e125d28bcaee977909c6c10624f7c8298",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a15834e125d28bcaee977909c6c10624f7c8298"
      }
    ],
    "stats": {
      "total": 188,
      "additions": 116,
      "deletions": 72
    },
    "files": [
      {
        "sha": "404eb385f1aef19643128fe86118b4a7dc441457",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 72,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56c439208058f34ab2bc32b47798c70328e6ba36/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56c439208058f34ab2bc32b47798c70328e6ba36/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=56c439208058f34ab2bc32b47798c70328e6ba36",
        "patch": "@@ -143,6 +143,9 @@ struct CBlockReject {\n  * and we're no longer holding the node's locks.\n  */\n struct CNodeState {\n+    //! Lock protecting this object\n+    CCriticalSection cs;\n+\n     //! The peer's address\n     const CService address;\n     //! Whether we have a fully established connection.\n@@ -220,28 +223,65 @@ struct CNodeState {\n     }\n };\n \n+/** Provides locked access to a CNodeState */\n+class CNodeStateAccessor {\n+private:\n+    std::shared_ptr<CNodeState> pstate;\n+\n+    CNodeStateAccessor() : pstate() { }\n+    CNodeStateAccessor(std::shared_ptr<CNodeState>&& pstateIn) : pstate(std::move(pstateIn)) { ENTER_CRITICAL_SECTION(pstate->cs); }\n+    friend class NodeStateStorage;\n+\n+public:\n+    ~CNodeStateAccessor() { if (pstate) LEAVE_CRITICAL_SECTION(pstate->cs); }\n+\n+    CNodeStateAccessor(const CNodeStateAccessor&) =delete;\n+    CNodeStateAccessor& operator= (const CNodeStateAccessor&) =delete;\n+\n+    CNodeStateAccessor(CNodeStateAccessor&& o) { pstate = o.pstate; o.pstate = NULL; }\n+\n+    explicit operator bool() const { return (bool)pstate; }\n+\n+    CNodeState* operator->() { return &(*pstate); }\n+    const CNodeState* operator->() const { return &(*pstate); }\n+};\n+\n class NodeStateStorage {\n     /** Map maintaining per-node state. Requires cs_main. */\n-    map<NodeId, CNodeState> mapNodeState;\n+    map<NodeId, std::shared_ptr<CNodeState> > mapNodeState;\n+    CCriticalSection cs_mapNodeState;\n \n public:\n-    CNodeState *GetNodeState(NodeId nodeid) {\n-        AssertLockHeld(cs_main);\n-        map<NodeId, CNodeState>::iterator it = mapNodeState.find(nodeid);\n-        if (it == mapNodeState.end())\n-            return NULL;\n-        return &it->second;\n+    CNodeStateAccessor GetNodeState(NodeId nodeid) {\n+        AssertLockHeld(cs_main); // TODO: Remove State reliance on cs_main\n+\n+        std::shared_ptr<CNodeState> pstate;\n+        {\n+            LOCK(cs_mapNodeState);\n+            auto it = mapNodeState.find(nodeid);\n+            if (it == mapNodeState.end())\n+                return CNodeStateAccessor();\n+            pstate = it->second;\n+        }\n+        return CNodeStateAccessor(std::move(pstate));\n     }\n \n     void AddStateForNode(NodeId nodeid, const CAddress& addr, const std::string& addrName) {\n-        LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, addrName));\n+        LOCK(cs_main); // TODO: Remove State reliance on cs_main\n+        LOCK(cs_mapNodeState);\n+        mapNodeState.emplace_hint(mapNodeState.end(), nodeid, std::make_shared<CNodeState>(addr, addrName));\n     }\n \n     void RemoveStateForNode(NodeId nodeid) {\n-        LOCK(cs_main);\n+        LOCK(cs_main); // TODO: Remove State reliance on cs_main\n+        LOCK(cs_mapNodeState);\n+\n+        auto it = mapNodeState.find(nodeid);\n+        if (it == mapNodeState.end())\n+            return;\n \n-        mapNodeState.erase(nodeid);\n+        assert(it->second.use_count() == 1);\n+        mapNodeState.erase(it);\n \n         if (mapNodeState.empty()) {\n             // Do a consistency check after the last peer is removed.\n@@ -253,11 +293,11 @@ class NodeStateStorage {\n } nodeStateStorage;\n \n // Requires cs_main.\n-static CNodeState *State(NodeId pnode) {\n+static CNodeStateAccessor State(NodeId pnode) {\n     return nodeStateStorage.GetNodeState(pnode);\n }\n \n-void UpdatePreferredDownload(CNode* node, CNodeState* state)\n+void UpdatePreferredDownload(CNode* node, CNodeStateAccessor& state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n \n@@ -296,22 +336,25 @@ void InitializeNode(CNode *pnode, CConnman& connman) {\n void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n     LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n \n-    if (state->fSyncStarted)\n-        nSyncStarted--;\n+    {\n+        CNodeStateAccessor state = State(nodeid);\n \n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n-        fUpdateConnectionTime = true;\n-    }\n+        if (state->fSyncStarted)\n+            nSyncStarted--;\n+\n+        if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n+            fUpdateConnectionTime = true;\n+        }\n \n-    BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight) {\n+            mapBlocksInFlight.erase(entry.hash);\n+        }\n+        EraseOrphansFor(nodeid);\n+        nPreferredDownload -= state->fPreferredDownload;\n+        nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n+        assert(nPeersWithValidatedDownloads >= 0);\n     }\n-    EraseOrphansFor(nodeid);\n-    nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n \n     nodeStateStorage.RemoveStateForNode(nodeid);\n }\n@@ -322,7 +365,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n bool MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n+        CNodeStateAccessor state = State(itInFlight->second.first);\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n         if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n             // Last validated block on the queue was received.\n@@ -345,8 +388,8 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    CNodeStateAccessor state = State(nodeid);\n+    assert(state);\n \n     // Short-circuit most stuff in case its from the same node\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n@@ -377,8 +420,8 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n void ProcessBlockAvailability(NodeId nodeid) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    CNodeStateAccessor state = State(nodeid);\n+    assert(state);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n         BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n@@ -392,8 +435,8 @@ void ProcessBlockAvailability(NodeId nodeid) {\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    CNodeStateAccessor state = State(nodeid);\n+    assert(state);\n \n     ProcessBlockAvailability(nodeid);\n \n@@ -408,7 +451,7 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n-void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom, CConnman& connman) {\n+void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeStateAccessor& nodestate, CNode* pfrom, CConnman& connman) {\n     if (!nodestate->fSupportsDesiredCmpctVersion) {\n         // Never ask from peers who can't provide witnesses.\n         return;\n@@ -445,7 +488,7 @@ bool CanDirectFetch(const Consensus::Params &consensusParams)\n }\n \n // Requires cs_main\n-bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n+bool PeerHasHeader(CNodeStateAccessor& state, const CBlockIndex *pindex)\n {\n     if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n         return true;\n@@ -480,8 +523,8 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n         return;\n \n     vBlocks.reserve(vBlocks.size() + count);\n-    CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    CNodeStateAccessor state = State(nodeid);\n+    assert(state);\n \n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n@@ -565,8 +608,8 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n-    if (state == NULL)\n+    CNodeStateAccessor state = State(nodeid);\n+    if (!state)\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n@@ -706,8 +749,8 @@ void Misbehaving(NodeId pnode, int howmuch)\n     if (howmuch == 0)\n         return;\n \n-    CNodeState *state = State(pnode);\n-    if (state == NULL)\n+    CNodeStateAccessor state = State(pnode);\n+    if (!state)\n         return;\n \n     state->nMisbehavior += howmuch;\n@@ -1184,7 +1227,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Potentially mark this peer as a preferred download peer.\n         {\n         LOCK(cs_main);\n-        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n+        CNodeStateAccessor nodestate = State(pfrom->GetId());\n+        UpdatePreferredDownload(pfrom, nodestate);\n         }\n \n         // Change version\n@@ -1560,7 +1604,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeStateAccessor nodestate = State(pfrom->GetId());\n         const CBlockIndex* pindex = NULL;\n         if (locator.IsNull())\n         {\n@@ -1827,7 +1871,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n             return true;\n \n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeStateAccessor nodestate = State(pfrom->GetId());\n \n         if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n             // Don't bother trying to process compact blocks from v1 peers\n@@ -2042,7 +2086,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         const CBlockIndex *pindexLast = NULL;\n         {\n         LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeStateAccessor nodestate = State(pfrom->GetId());\n \n         // If this looks like it could be a block announcement (nCount <\n         // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n@@ -2095,7 +2139,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         {\n         LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n+        CNodeStateAccessor nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n             LogPrint(\"net\", \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n         }\n@@ -2624,14 +2668,14 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         if (!lockMain)\n             return true;\n \n-        CNodeState &state = *State(pto->GetId());\n+        CNodeStateAccessor state = State(pto->GetId());\n \n-        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n+        BOOST_FOREACH(const CBlockReject& reject, state->rejects)\n             connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n-        state.rejects.clear();\n+        state->rejects.clear();\n \n-        if (state.fShouldBan) {\n-            state.fShouldBan = false;\n+        if (state->fShouldBan) {\n+            state->fShouldBan = false;\n             if (pto->fWhitelisted)\n                 LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n             else {\n@@ -2685,11 +2729,11 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         // Start block sync\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n-        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        bool fFetch = state->fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n+        if (!state->fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n-                state.fSyncStarted = true;\n+                state->fSyncStarted = true;\n                 nSyncStarted++;\n                 const CBlockIndex *pindexStart = pindexBestHeader;\n                 /* If possible, start at the block preceding the currently\n@@ -2727,8 +2771,8 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = ((!state.fPreferHeaders &&\n-                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n+            bool fRevertToInv = ((!state->fPreferHeaders &&\n+                                 (!state->fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n             ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n@@ -2766,9 +2810,9 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     if (fFoundStartingHeader) {\n                         // add this to the headers message\n                         vHeaders.push_back(pindex->GetBlockHeader());\n-                    } else if (PeerHasHeader(&state, pindex)) {\n+                    } else if (PeerHasHeader(state, pindex)) {\n                         continue; // keep looking for the first new block\n-                    } else if (pindex->pprev == NULL || PeerHasHeader(&state, pindex->pprev)) {\n+                    } else if (pindex->pprev == NULL || PeerHasHeader(state, pindex->pprev)) {\n                         // Peer doesn't have this header but they do have the prior one.\n                         // Start sending headers.\n                         fFoundStartingHeader = true;\n@@ -2782,7 +2826,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 }\n             }\n             if (!fRevertToInv && !vHeaders.empty()) {\n-                if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n+                if (vHeaders.size() == 1 && state->fPreferHeaderAndIDs) {\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n                     LogPrint(\"net\", \"%s sending header-and-ids %s to peer %d\\n\", __func__,\n@@ -2791,11 +2835,11 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     CBlock block;\n                     bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                     assert(ret);\n-                    CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                    int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+                    CBlockHeaderAndShortTxIDs cmpctblock(block, state->fWantsCmpctWitness);\n+                    int nSendFlags = state->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                     connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                    state.pindexBestHeaderSent = pBestIndex;\n-                } else if (state.fPreferHeaders) {\n+                    state->pindexBestHeaderSent = pBestIndex;\n+                } else if (state->fPreferHeaders) {\n                     if (vHeaders.size() > 1) {\n                         LogPrint(\"net\", \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n@@ -2806,7 +2850,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                                 vHeaders.front().GetHash().ToString(), pto->id);\n                     }\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n-                    state.pindexBestHeaderSent = pBestIndex;\n+                    state->pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n             }\n@@ -2829,7 +2873,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     }\n \n                     // If the peer's chain has this block, don't inv it back.\n-                    if (!PeerHasHeader(&state, pindex)) {\n+                    if (!PeerHasHeader(state, pindex)) {\n                         pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n                         LogPrint(\"net\", \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n                             pto->id, hashToAnnounce.ToString());\n@@ -2975,7 +3019,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n \n         // Detect whether we're stalling\n         nNow = GetTimeMicros();\n-        if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+        if (state->nStallingSince && state->nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n@@ -2988,10 +3032,10 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         // We compensate for other peers to prevent killing off peers due to our own downstream link\n         // being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes\n         // to unreasonably increase our timeout.\n-        if (state.vBlocksInFlight.size() > 0) {\n-            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n-            if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n+        if (state->vBlocksInFlight.size() > 0) {\n+            QueuedBlock &queuedBlock = state->vBlocksInFlight.front();\n+            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state->nBlocksInFlightValidHeaders > 0);\n+            if (nNow > state->nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n                 LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->id);\n                 pto->fDisconnect = true;\n                 return true;\n@@ -3002,18 +3046,18 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state->nBlocksInFlight, vToDownload, staller, consensusParams);\n             BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n                 LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->id);\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n+            if (state->nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n                     LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);"
      }
    ]
  },
  {
    "sha": "470911c75a8e51368acc6fbbbd11e3015450371b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NzA5MTFjNzVhOGU1MTM2OGFjYzZmYmJiZDExZTMwMTU0NTAzNzFi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-28T13:25:11Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-01-01T04:10:09Z"
      },
      "message": "Let shared_ptrs cleanup CNodeStates\n\nThis removes reliance on net in net_processing for maintaining the\nrefcount == 0 invariant when calling FinalizeNode\n\nThis also removes a few asserts which used to be checked when there\nwere no more CNodeStates remaining, which we can no longer check for.\n\nThese should be pretty rarely checked anyway, so probably didn't\nserve much use.",
      "tree": {
        "sha": "32a8618801507890a89d2774c93a9e9a04cf6a60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32a8618801507890a89d2774c93a9e9a04cf6a60"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/470911c75a8e51368acc6fbbbd11e3015450371b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/470911c75a8e51368acc6fbbbd11e3015450371b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/470911c75a8e51368acc6fbbbd11e3015450371b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/470911c75a8e51368acc6fbbbd11e3015450371b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "56c439208058f34ab2bc32b47798c70328e6ba36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56c439208058f34ab2bc32b47798c70328e6ba36",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56c439208058f34ab2bc32b47798c70328e6ba36"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 0,
      "deletions": 8
    },
    "files": [
      {
        "sha": "d517f5a5ad24d93ba4bfd2351faae568c6608c99",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/470911c75a8e51368acc6fbbbd11e3015450371b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/470911c75a8e51368acc6fbbbd11e3015450371b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=470911c75a8e51368acc6fbbbd11e3015450371b",
        "patch": "@@ -280,15 +280,7 @@ class NodeStateStorage {\n         if (it == mapNodeState.end())\n             return;\n \n-        assert(it->second.use_count() == 1);\n         mapNodeState.erase(it);\n-\n-        if (mapNodeState.empty()) {\n-            // Do a consistency check after the last peer is removed.\n-            assert(mapBlocksInFlight.empty());\n-            assert(nPreferredDownload == 0);\n-            assert(nPeersWithValidatedDownloads == 0);\n-        }\n     }\n } nodeStateStorage;\n "
      }
    ]
  },
  {
    "sha": "c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNDEwZDkzMDNiY2VmMWNiM2ZkMTFlMWM0OTg5ZmFhNzIwZjIwYzBi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-24T01:46:43Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-01-01T04:10:09Z"
      },
      "message": "Add a few AssertLockHelds for cs_main in net_processing",
      "tree": {
        "sha": "d6a469d24cdfc9eb636ee07f784a36ed77037fd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6a469d24cdfc9eb636ee07f784a36ed77037fd2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c410d9303bcef1cb3fd11e1c4989faa720f20c0b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "470911c75a8e51368acc6fbbbd11e3015450371b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/470911c75a8e51368acc6fbbbd11e3015450371b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/470911c75a8e51368acc6fbbbd11e3015450371b"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 14,
      "deletions": 0
    },
    "files": [
      {
        "sha": "392f0aca187438b6770acdcb343b0a9d9a40b546",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c410d9303bcef1cb3fd11e1c4989faa720f20c0b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c410d9303bcef1cb3fd11e1c4989faa720f20c0b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
        "patch": "@@ -356,6 +356,8 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n // Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    AssertLockHeld(cs_main);\n+\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeStateAccessor state = State(itInFlight->second.first);\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n@@ -380,6 +382,8 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n+    AssertLockHeld(cs_main);\n+\n     CNodeStateAccessor state = State(nodeid);\n     assert(state);\n \n@@ -412,6 +416,8 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n void ProcessBlockAvailability(NodeId nodeid) {\n+    AssertLockHeld(cs_main);\n+\n     CNodeStateAccessor state = State(nodeid);\n     assert(state);\n \n@@ -427,6 +433,8 @@ void ProcessBlockAvailability(NodeId nodeid) {\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n+    AssertLockHeld(cs_main);\n+\n     CNodeStateAccessor state = State(nodeid);\n     assert(state);\n \n@@ -444,6 +452,8 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n }\n \n void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeStateAccessor& nodestate, CNode* pfrom, CConnman& connman) {\n+    AssertLockHeld(cs_main);\n+\n     if (!nodestate->fSupportsDesiredCmpctVersion) {\n         // Never ask from peers who can't provide witnesses.\n         return;\n@@ -476,6 +486,8 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeStateAccessor& nodestate, C\n // Requires cs_main\n bool CanDirectFetch(const Consensus::Params &consensusParams)\n {\n+    AssertLockHeld(cs_main);\n+\n     return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n@@ -511,6 +523,8 @@ const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex*\n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n+    AssertLockHeld(cs_main);\n+\n     if (count == 0)\n         return;\n "
      }
    ]
  },
  {
    "sha": "f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMWMwYWUwOTk5ZWUwNzhlNzc0NjNkYzRkZmM0ZjI1ZDY5Yzg2Y2Yy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-24T02:15:55Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-01-01T04:10:09Z"
      },
      "message": "Optimize State() calls in ::SENDCMPCT processing",
      "tree": {
        "sha": "bf71f174099955e002f7dc72da0dba89f34fbd14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf71f174099955e002f7dc72da0dba89f34fbd14"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c410d9303bcef1cb3fd11e1c4989faa720f20c0b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c410d9303bcef1cb3fd11e1c4989faa720f20c0b"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 9,
      "deletions": 8
    },
    "files": [
      {
        "sha": "f5cd1b6c1af4ebb9395d1349a992a7b9fee0589e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
        "patch": "@@ -1396,18 +1396,19 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n         if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n             LOCK(cs_main);\n+            CNodeStateAccessor nodestate = State(pfrom->GetId());\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n-            if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {\n-                State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n-                State(pfrom->GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+            if (!nodestate->fProvidesHeaderAndIDs) {\n+                nodestate->fProvidesHeaderAndIDs = true;\n+                nodestate->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n             }\n-            if (State(pfrom->GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n-                State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n-            if (!State(pfrom->GetId())->fSupportsDesiredCmpctVersion) {\n+            if (nodestate->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n+                nodestate->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            if (!nodestate->fSupportsDesiredCmpctVersion) {\n                 if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n+                    nodestate->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n                 else\n-                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n+                    nodestate->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n             }\n         }\n     }"
      }
    ]
  },
  {
    "sha": "e195459b2ca5c52d2c4dda5ace28b4b6ee082a79",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTk1NDU5YjJjYTVjNTJkMmM0ZGRhNWFjZTI4YjRiNmVlMDgyYTc5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-12-24T02:26:56Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-01-01T04:10:09Z"
      },
      "message": "Remove cs_main lock requirements for Misbehaving()",
      "tree": {
        "sha": "daa64cc22c6f605d0b158ab7a0669aea0d21e1ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/daa64cc22c6f605d0b158ab7a0669aea0d21e1ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e195459b2ca5c52d2c4dda5ace28b4b6ee082a79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e195459b2ca5c52d2c4dda5ace28b4b6ee082a79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e195459b2ca5c52d2c4dda5ace28b4b6ee082a79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e195459b2ca5c52d2c4dda5ace28b4b6ee082a79/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f1c0ae0999ee078e77463dc4dfc4f25d69c86cf2"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 1,
      "deletions": 16
    },
    "files": [
      {
        "sha": "00b4c906adc3b06b8f7ca63d174350bfdd296ff5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 16,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e195459b2ca5c52d2c4dda5ace28b4b6ee082a79/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e195459b2ca5c52d2c4dda5ace28b4b6ee082a79/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e195459b2ca5c52d2c4dda5ace28b4b6ee082a79",
        "patch": "@@ -247,14 +247,12 @@ class CNodeStateAccessor {\n };\n \n class NodeStateStorage {\n-    /** Map maintaining per-node state. Requires cs_main. */\n+    /** Map maintaining per-node state. */\n     map<NodeId, std::shared_ptr<CNodeState> > mapNodeState;\n     CCriticalSection cs_mapNodeState;\n \n public:\n     CNodeStateAccessor GetNodeState(NodeId nodeid) {\n-        AssertLockHeld(cs_main); // TODO: Remove State reliance on cs_main\n-\n         std::shared_ptr<CNodeState> pstate;\n         {\n             LOCK(cs_mapNodeState);\n@@ -267,13 +265,11 @@ class NodeStateStorage {\n     }\n \n     void AddStateForNode(NodeId nodeid, const CAddress& addr, const std::string& addrName) {\n-        LOCK(cs_main); // TODO: Remove State reliance on cs_main\n         LOCK(cs_mapNodeState);\n         mapNodeState.emplace_hint(mapNodeState.end(), nodeid, std::make_shared<CNodeState>(addr, addrName));\n     }\n \n     void RemoveStateForNode(NodeId nodeid) {\n-        LOCK(cs_main); // TODO: Remove State reliance on cs_main\n         LOCK(cs_mapNodeState);\n \n         auto it = mapNodeState.find(nodeid);\n@@ -284,7 +280,6 @@ class NodeStateStorage {\n     }\n } nodeStateStorage;\n \n-// Requires cs_main.\n static CNodeStateAccessor State(NodeId pnode) {\n     return nodeStateStorage.GetNodeState(pnode);\n }\n@@ -491,7 +486,6 @@ bool CanDirectFetch(const Consensus::Params &consensusParams)\n     return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n-// Requires cs_main\n bool PeerHasHeader(CNodeStateAccessor& state, const CBlockIndex *pindex)\n {\n     if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n@@ -613,7 +607,6 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n } // anon namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n-    LOCK(cs_main);\n     CNodeStateAccessor state = State(nodeid);\n     if (!state)\n         return false;\n@@ -749,7 +742,6 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n     return nEvicted;\n }\n \n-// Requires cs_main.\n void Misbehaving(NodeId pnode, int howmuch)\n {\n     if (howmuch == 0)\n@@ -1134,7 +1126,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                strCommand == NetMsgType::FILTERADD))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n             return false;\n         } else {\n@@ -1150,7 +1141,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (pfrom->nVersion != 0)\n         {\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\")));\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n         }\n@@ -1296,7 +1286,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     else if (pfrom->nVersion == 0)\n     {\n         // Must have a version message before anything else\n-        LOCK(cs_main);\n         Misbehaving(pfrom->GetId(), 1);\n         return false;\n     }\n@@ -1347,7 +1336,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         if (vAddr.size() > 1000)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"message addr size() = %u\", vAddr.size());\n         }\n@@ -1395,7 +1383,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n         if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n-            LOCK(cs_main);\n             CNodeStateAccessor nodestate = State(pfrom->GetId());\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n             if (!nodestate->fProvidesHeaderAndIDs) {\n@@ -1420,7 +1407,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"message inv size() = %u\", vInv.size());\n         }\n@@ -1491,7 +1477,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 20);\n             return error(\"message getdata size() = %u\", vInv.size());\n         }"
      }
    ]
  }
]