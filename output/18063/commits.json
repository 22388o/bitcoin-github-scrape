[
  {
    "sha": "057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTdjOGI0Y2U4NGM4MWUwMDhkNTNiOTBlY2RkZmE2ZDRmNThjZDlh",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-01-21T20:44:01Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-02-11T01:20:51Z"
      },
      "message": "Change UpdateForDescendants to use Epochs",
      "tree": {
        "sha": "457c4b0ef0912c9e0ba3eff1c8d90f0a1cb627ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/457c4b0ef0912c9e0ba3eff1c8d90f0a1cb627ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd5a02692853f7240a4fdc593d7d0123d7916e45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd5a02692853f7240a4fdc593d7d0123d7916e45",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd5a02692853f7240a4fdc593d7d0123d7916e45"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 58,
      "deletions": 35
    },
    "files": [
      {
        "sha": "6b16c4cf18e140cd83e4cc06d11d223eaebdcf02",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 34,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
        "patch": "@@ -57,48 +57,70 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const std::set<uint256>& exclude)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    const CTxMemPool::setEntries& direct_children = GetMemPoolChildren(update_it);\n+    // set up the update_cache to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction)\n+    vecEntries update_cache;\n+    update_cache.reserve(direct_children.size());\n+    // mark every direct_child as visited so that we don't accidentally re-add them\n+    // to the cache in the grandchild is child case\n+    for (const txiter direct_child : direct_children) {\n+        update_cache.emplace_back(direct_child);\n+        visited(direct_child);\n+    }\n+    // already_traversed index keeps track of the elements that we've\n+    // already expanded. If index is < already_traversed, we've walked it.\n+    // If index is >= already_traversed, we need to walk it.\n+    // If already_traversed >= update_cache.size(), we're finished.\n+    for (size_t already_traversed = 0; already_traversed < update_cache.size(); /* modified in loop body */) {\n+        // rotate the back() to behind already_traversed\n+        const txiter child_it = update_cache.back();\n+        std::swap(update_cache[already_traversed++], update_cache.back());\n+\n+        // N.B. grand_children may also be children\n+        const CTxMemPool::setEntries& grand_children = GetMemPoolChildren(child_it);\n+        for (const txiter grand_child_it : grand_children) {\n+            if (visited(grand_child_it)) continue;\n+            // Schedule for later processing\n+            update_cache.emplace_back(grand_child_it);\n+            // if it exists in the cache, unschedule and use cached descendants\n+            cacheMap::iterator cached_great_grand_children = cache.find(grand_child_it);\n+            if (cached_great_grand_children != cache.end()) {\n+                std::swap(update_cache[already_traversed++], update_cache.back());\n+                for (const txiter great_grand_child : cached_great_grand_children->second) {\n+                    if (visited(great_grand_child)) continue;\n+                    update_cache.emplace_back(great_grand_child);\n+                    // place on the back and then swap into the already_traversed index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this)\n+                    std::swap(update_cache[already_traversed++], update_cache.back());\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n             }\n         }\n     }\n-    // setAllDescendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int64_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (txiter cit : setAllDescendants) {\n-        if (!setExclude.count(cit->GetTx().GetHash())) {\n-            modifySize += cit->GetTxSize();\n-            modifyFee += cit->GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(cit);\n-            // Update ancestor state for each descendant\n-            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n+\n+    // update_cache now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    for (txiter child_it : update_cache) {\n+        const CTxMemPoolEntry& child = *child_it;\n+        if (!exclude.count(child.GetTx().GetHash())) {\n+            modify_size += child.GetTxSize();\n+            modify_fee += child.GetModifiedFee();\n+            modify_count++;\n+            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n         }\n     }\n-    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n+    mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n+    // share the cache (if there is one)\n+    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n }\n-\n // vHashesToUpdate is the set of transaction hashes from a disconnected block\n // which has been re-added to the mempool.\n // for each entry, look for descendants that are outside vHashesToUpdate, and"
      },
      {
        "sha": "c2890cbe0ba72491c6fde37ddab1b159abff1f58",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
        "patch": "@@ -530,12 +530,13 @@ class CTxMemPool\n         }\n     };\n     typedef std::set<txiter, CompareIteratorByHash> setEntries;\n+    typedef std::vector<txiter> vecEntries;\n \n     const setEntries & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n-    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n+    typedef std::map<txiter, vecEntries, CompareIteratorByHash> cacheMap;\n \n     struct TxLinks {\n         setEntries parents;"
      }
    ]
  },
  {
    "sha": "a2cae4270711f85582aa184d156d5beb119db129",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMmNhZTQyNzA3MTFmODU1ODJhYTE4NGQxNTZkNWJlYjExOWRiMTI5",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-01-21T21:19:52Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-02-11T01:22:13Z"
      },
      "message": "Remove CacheMap from mempool UpdateForDescendants. CacheMap was an optimization to limit re-traversal in UpdateForDescendants. But because we know that descendants limit limits the total number of descendants, this actually doesn't help that much. There are some common cases where having a CacheMap might be faster, but an adversary can trivially construct a worst-case example that causes equal behavior with or without a cachemap. For example, a transaction with N/2 children which each have N/2 outputs that get spent by N/2 grandchildren will cause the parent to iterate over N^2 entries with or without CacheMap. Post Epochs, UpdateForDescendants is sufficiently cheap such that the cachemap is just extra memory overhead.",
      "tree": {
        "sha": "30cf87220315e639b070a551de1e930b464869c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30cf87220315e639b070a551de1e930b464869c1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a2cae4270711f85582aa184d156d5beb119db129",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2cae4270711f85582aa184d156d5beb119db129",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a2cae4270711f85582aa184d156d5beb119db129",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2cae4270711f85582aa184d156d5beb119db129/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/057c8b4ce84c81e008d53b90ecddfa6d4f58cd9a"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 15,
      "deletions": 38
    },
    "files": [
      {
        "sha": "64b850f025269877fc64b1b8b61275b6e707973e",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 36,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2cae4270711f85582aa184d156d5beb119db129/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2cae4270711f85582aa184d156d5beb119db129/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=a2cae4270711f85582aa184d156d5beb119db129",
        "patch": "@@ -57,58 +57,44 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const std::set<uint256>& exclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, const std::set<uint256>& exclude)\n {\n     const auto epoch = GetFreshEpoch();\n     const CTxMemPool::setEntries& direct_children = GetMemPoolChildren(update_it);\n-    // set up the update_cache to contain all of our transaction's children (note --\n+    // set up the stage to contain all of our transaction's children (note --\n     // already de-duplicated in case multiple outputs of ours are spent in one\n     // transaction)\n-    vecEntries update_cache;\n-    update_cache.reserve(direct_children.size());\n+    vecEntries stage;\n+    stage.reserve(direct_children.size());\n     // mark every direct_child as visited so that we don't accidentally re-add them\n     // to the cache in the grandchild is child case\n     for (const txiter direct_child : direct_children) {\n-        update_cache.emplace_back(direct_child);\n+        stage.emplace_back(direct_child);\n         visited(direct_child);\n     }\n     // already_traversed index keeps track of the elements that we've\n     // already expanded. If index is < already_traversed, we've walked it.\n     // If index is >= already_traversed, we need to walk it.\n-    // If already_traversed >= update_cache.size(), we're finished.\n-    for (size_t already_traversed = 0; already_traversed < update_cache.size(); /* modified in loop body */) {\n+    // If already_traversed >= stage.size(), we're finished.\n+    for (size_t already_traversed = 0; already_traversed < stage.size(); /* modified in loop body */) {\n         // rotate the back() to behind already_traversed\n-        const txiter child_it = update_cache.back();\n-        std::swap(update_cache[already_traversed++], update_cache.back());\n+        const txiter child_it = stage.back();\n+        std::swap(stage[already_traversed++], stage.back());\n \n         // N.B. grand_children may also be children\n         const CTxMemPool::setEntries& grand_children = GetMemPoolChildren(child_it);\n         for (const txiter grand_child_it : grand_children) {\n             if (visited(grand_child_it)) continue;\n-            // Schedule for later processing\n-            update_cache.emplace_back(grand_child_it);\n-            // if it exists in the cache, unschedule and use cached descendants\n-            cacheMap::iterator cached_great_grand_children = cache.find(grand_child_it);\n-            if (cached_great_grand_children != cache.end()) {\n-                std::swap(update_cache[already_traversed++], update_cache.back());\n-                for (const txiter great_grand_child : cached_great_grand_children->second) {\n-                    if (visited(great_grand_child)) continue;\n-                    update_cache.emplace_back(great_grand_child);\n-                    // place on the back and then swap into the already_traversed index\n-                    // so we don't walk it ourselves (whoever put the grand\n-                    // child in the cache must have already traversed this)\n-                    std::swap(update_cache[already_traversed++], update_cache.back());\n-                }\n-            }\n+            stage.emplace_back(grand_child_it);\n         }\n     }\n \n-    // update_cache now contains all in-mempool descendants of update_it,\n+    // stage now contains all in-mempool descendants of update_it,\n     // compute updates now.\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n-    for (txiter child_it : update_cache) {\n+    for (txiter child_it : stage) {\n         const CTxMemPoolEntry& child = *child_it;\n         if (!exclude.count(child.GetTx().GetHash())) {\n             modify_size += child.GetTxSize();\n@@ -118,8 +104,6 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n         }\n     }\n     mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n-    // share the cache (if there is one)\n-    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n }\n // vHashesToUpdate is the set of transaction hashes from a disconnected block\n // which has been re-added to the mempool.\n@@ -129,20 +113,15 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate)\n {\n     AssertLockHeld(cs);\n-    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n-    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n-    // descendants when we come across a previously seen entry.\n-    cacheMap mapMemPoolDescendantsToUpdate;\n \n     // Use a set for lookups into vHashesToUpdate (these entries are already\n     // accounted for in the state of their ancestors)\n     std::set<uint256> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n \n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n-    // This maximizes the benefit of the descendant cache and guarantees that\n-    // setMemPoolChildren will be updated, an assumption made in\n-    // UpdateForDescendants.\n+    // This guarantees that setMemPoolChildren will be up to date, an assumption\n+    // made in UpdateForDescendants.\n     for (const uint256 &hash : reverse_iterate(vHashesToUpdate)) {\n         // calculate children from mapNextTx\n         txiter it = mapTx.find(hash);\n@@ -167,7 +146,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n                 }\n             }\n         } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded);\n+        UpdateForDescendants(it, setAlreadyIncluded);\n     }\n }\n "
      },
      {
        "sha": "03ba5dd5d75d5ac9c9940860fb602d95e3f44d2d",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2cae4270711f85582aa184d156d5beb119db129/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2cae4270711f85582aa184d156d5beb119db129/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=a2cae4270711f85582aa184d156d5beb119db129",
        "patch": "@@ -536,7 +536,6 @@ class CTxMemPool\n     const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n-    typedef std::map<txiter, vecEntries, CompareIteratorByHash> cacheMap;\n \n     struct TxLinks {\n         setEntries parents;\n@@ -718,7 +717,6 @@ class CTxMemPool\n      *  same transaction again, if encountered in another transaction chain.\n      */\n     void UpdateForDescendants(txiter updateIt,\n-            cacheMap &cachedDescendants,\n             const std::set<uint256> &setExclude) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Update ancestors of hash to add/remove it as a descendant transaction. */\n     void UpdateAncestorsOf(bool add, txiter hash, setEntries &setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);"
      }
    ]
  }
]