[
  {
    "sha": "39415a4213653d374b508081ec5e59492f9def0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTQxNWE0MjEzNjUzZDM3NGI1MDgwODFlYzVlNTk0OTJmOWRlZjBj",
    "commit": {
      "author": {
        "name": "sinetek",
        "email": "pitwuu@gmail.com",
        "date": "2014-11-11T08:03:13Z"
      },
      "committer": {
        "name": "sinetek",
        "email": "pitwuu@gmail.com",
        "date": "2014-11-11T09:53:03Z"
      },
      "message": "Removing external dependency on boost::signals2",
      "tree": {
        "sha": "cecf85dcc4a6f05a7529b69cc6af7bd0d7ceadbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cecf85dcc4a6f05a7529b69cc6af7bd0d7ceadbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39415a4213653d374b508081ec5e59492f9def0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39415a4213653d374b508081ec5e59492f9def0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39415a4213653d374b508081ec5e59492f9def0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39415a4213653d374b508081ec5e59492f9def0c/comments",
    "author": {
      "login": "sinetek",
      "id": 5908875,
      "node_id": "MDQ6VXNlcjU5MDg4NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5908875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sinetek",
      "html_url": "https://github.com/sinetek",
      "followers_url": "https://api.github.com/users/sinetek/followers",
      "following_url": "https://api.github.com/users/sinetek/following{/other_user}",
      "gists_url": "https://api.github.com/users/sinetek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sinetek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sinetek/subscriptions",
      "organizations_url": "https://api.github.com/users/sinetek/orgs",
      "repos_url": "https://api.github.com/users/sinetek/repos",
      "events_url": "https://api.github.com/users/sinetek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sinetek/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sinetek",
      "id": 5908875,
      "node_id": "MDQ6VXNlcjU5MDg4NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5908875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sinetek",
      "html_url": "https://github.com/sinetek",
      "followers_url": "https://api.github.com/users/sinetek/followers",
      "following_url": "https://api.github.com/users/sinetek/following{/other_user}",
      "gists_url": "https://api.github.com/users/sinetek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sinetek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sinetek/subscriptions",
      "organizations_url": "https://api.github.com/users/sinetek/orgs",
      "repos_url": "https://api.github.com/users/sinetek/repos",
      "events_url": "https://api.github.com/users/sinetek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sinetek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d064f7f3ee1b80c7e9ca1f149cae8aca4a071230",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d064f7f3ee1b80c7e9ca1f149cae8aca4a071230",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d064f7f3ee1b80c7e9ca1f149cae8aca4a071230"
      }
    ],
    "stats": {
      "total": 3207,
      "additions": 3030,
      "deletions": 177
    },
    "files": [
      {
        "sha": "782777a3f0e10d83aa707d75c49d1de809ec9343",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -124,8 +124,10 @@ BITCOIN_CORE_H = \\\n   uint256.h \\\n   undo.h \\\n   util.h \\\n+  utildelegate.h \\\n   utilstrencodings.h \\\n   utilmoneystr.h \\\n+  utilsignal.h \\\n   utiltime.h \\\n   version.h \\\n   wallet.h \\"
      },
      {
        "sha": "c1b45d2d14195f1f14bf947e05743c97ffe0eec6",
        "filename": "src/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -8,6 +8,7 @@\n #include \"allocators.h\"\n #include \"keystore.h\"\n #include \"serialize.h\"\n+#include \"utilsignal.h\"\n \n class uint256;\n \n@@ -192,7 +193,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n     /* Wallet status (encrypted, locked) changed.\n      * Note: Called without locks held.\n      */\n-    boost::signals2::signal<void (CCryptoKeyStore* wallet)> NotifyStatusChanged;\n+    Gallant::Signal1<CCryptoKeyStore*> NotifyStatusChanged;\n };\n \n #endif // BITCOIN_CRYPTER_H"
      },
      {
        "sha": "b51ebf433dbe5c3ad30ba49c6f5483eb54531228",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -195,13 +195,15 @@ void HandleSIGHUP(int)\n \n bool static InitError(const std::string &str)\n {\n-    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_ERROR);\n+\tbool ret;\n+    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_ERROR, ret);\n     return false;\n }\n \n bool static InitWarning(const std::string &str)\n {\n-    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_WARNING);\n+\tbool ret;\n+    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_WARNING, ret);\n     return true;\n }\n \n@@ -759,7 +761,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n      */\n     if (fServer)\n     {\n-        uiInterface.InitMessage.connect(SetRPCWarmupStatus);\n+        uiInterface.InitMessage.Connect(SetRPCWarmupStatus);\n         StartRPCThreads();\n     }\n \n@@ -1023,9 +1025,10 @@ bool AppInit2(boost::thread_group& threadGroup)\n         if (!fLoaded) {\n             // first suggest a reindex\n             if (!fReset) {\n-                bool fRet = uiInterface.ThreadSafeMessageBox(\n+\t\t\t\tbool fRet;\n+                uiInterface.ThreadSafeMessageBox(\n                     strLoadError + \".\\n\\n\" + _(\"Do you want to rebuild the block database now?\"),\n-                    \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);\n+                    \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT, fRet);\n                 if (fRet) {\n                     fReindex = true;\n                     fRequestShutdown = false;\n@@ -1224,7 +1227,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // ********************************************************* Step 9: import blocks\n \n     if (mapArgs.count(\"-blocknotify\"))\n-        uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n+        uiInterface.NotifyBlockTip.Connect(BlockNotifyCallback);\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;"
      },
      {
        "sha": "2b67744c888f7b4ec125642a95b6a09eebe2efd9",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -10,7 +10,6 @@\n #include \"pubkey.h\"\n #include \"sync.h\"\n \n-#include <boost/signals2/signal.hpp>\n #include <boost/variant.hpp>\n \n class CScript;"
      },
      {
        "sha": "144209d14b91491558d7b7ecc13d3c25563de72f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 50,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -18,6 +18,7 @@\n #include \"ui_interface.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n+#include \"utilsignal.h\"\n \n #include <sstream>\n \n@@ -143,51 +144,51 @@ namespace {\n \n struct CMainSignals {\n     // Notifies listeners of updated transaction data (transaction, and optionally the block it is found in.\n-    boost::signals2::signal<void (const CTransaction &, const CBlock *)> SyncTransaction;\n+\tGallant::Signal2<const CTransaction &, const CBlock *> SyncTransaction;\n     // Notifies listeners of an erased transaction (currently disabled, requires transaction replacement).\n-    boost::signals2::signal<void (const uint256 &)> EraseTransaction;\n+    Gallant::Signal1<const uint256 &> EraseTransaction;\n     // Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible).\n-    boost::signals2::signal<void (const uint256 &)> UpdatedTransaction;\n+    Gallant::Signal1<const uint256 &> UpdatedTransaction;\n     // Notifies listeners of a new active block chain.\n-    boost::signals2::signal<void (const CBlockLocator &)> SetBestChain;\n+    Gallant::Signal1<const CBlockLocator &> SetBestChain;\n     // Notifies listeners about an inventory item being seen on the network.\n-    boost::signals2::signal<void (const uint256 &)> Inventory;\n+    Gallant::Signal1<const uint256 &> Inventory;\n     // Tells listeners to broadcast their data.\n-    boost::signals2::signal<void ()> Broadcast;\n+    Gallant::Signal0<void> Broadcast;\n     // Notifies listeners of a block validation result\n-    boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n+\tGallant::Signal2<const CBlock &, const CValidationState &> BlockChecked;\n } g_signals;\n \n } // anon namespace\n \n void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n-    g_signals.SyncTransaction.connect(boost::bind(&CValidationInterface::SyncTransaction, pwalletIn, _1, _2));\n-    g_signals.EraseTransaction.connect(boost::bind(&CValidationInterface::EraseFromWallet, pwalletIn, _1));\n-    g_signals.UpdatedTransaction.connect(boost::bind(&CValidationInterface::UpdatedTransaction, pwalletIn, _1));\n-    g_signals.SetBestChain.connect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n-    g_signals.Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n-    g_signals.Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn));\n-    g_signals.BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n+    g_signals.SyncTransaction.Connect(pwalletIn, &CValidationInterface::SyncTransaction);\n+    g_signals.EraseTransaction.Connect(pwalletIn, &CValidationInterface::EraseFromWallet);\n+    g_signals.UpdatedTransaction.Connect(pwalletIn, &CValidationInterface::UpdatedTransaction);\n+    g_signals.SetBestChain.Connect(pwalletIn, &CValidationInterface::SetBestChain);\n+    g_signals.Inventory.Connect(pwalletIn, &CValidationInterface::Inventory);\n+    g_signals.Broadcast.Connect(pwalletIn, &CValidationInterface::ResendWalletTransactions);\n+    g_signals.BlockChecked.Connect(pwalletIn, &CValidationInterface::BlockChecked);\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n-    g_signals.BlockChecked.disconnect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n-    g_signals.Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn));\n-    g_signals.Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n-    g_signals.SetBestChain.disconnect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n-    g_signals.UpdatedTransaction.disconnect(boost::bind(&CValidationInterface::UpdatedTransaction, pwalletIn, _1));\n-    g_signals.EraseTransaction.disconnect(boost::bind(&CValidationInterface::EraseFromWallet, pwalletIn, _1));\n-    g_signals.SyncTransaction.disconnect(boost::bind(&CValidationInterface::SyncTransaction, pwalletIn, _1, _2));\n+    g_signals.BlockChecked.Disconnect(pwalletIn, &CValidationInterface::BlockChecked);\n+    g_signals.Broadcast.Disconnect(pwalletIn, &CValidationInterface::ResendWalletTransactions);\n+    g_signals.Inventory.Disconnect(pwalletIn, &CValidationInterface::Inventory);\n+    g_signals.SetBestChain.Disconnect(pwalletIn, &CValidationInterface::SetBestChain);\n+    g_signals.UpdatedTransaction.Disconnect(pwalletIn, &CValidationInterface::UpdatedTransaction);\n+    g_signals.EraseTransaction.Disconnect(pwalletIn, &CValidationInterface::EraseFromWallet);\n+    g_signals.SyncTransaction.Disconnect(pwalletIn, &CValidationInterface::SyncTransaction);\n }\n \n void UnregisterAllValidationInterfaces() {\n-    g_signals.BlockChecked.disconnect_all_slots();\n-    g_signals.Broadcast.disconnect_all_slots();\n-    g_signals.Inventory.disconnect_all_slots();\n-    g_signals.SetBestChain.disconnect_all_slots();\n-    g_signals.UpdatedTransaction.disconnect_all_slots();\n-    g_signals.EraseTransaction.disconnect_all_slots();\n-    g_signals.SyncTransaction.disconnect_all_slots();\n+    g_signals.BlockChecked.Clear();\n+    g_signals.Broadcast.Clear();\n+    g_signals.Inventory.Clear();\n+    g_signals.SetBestChain.Clear();\n+    g_signals.UpdatedTransaction.Clear();\n+    g_signals.EraseTransaction.Clear();\n+    g_signals.SyncTransaction.Clear();\n }\n \n void SyncWithWallets(const CTransaction &tx, const CBlock *pblock) {\n@@ -259,10 +260,10 @@ CNodeState *State(NodeId pnode) {\n     return &it->second;\n }\n \n-int GetHeight()\n+void GetHeight(int &height)\n {\n     LOCK(cs_main);\n-    return chainActive.Height();\n+\theight = chainActive.Height();\n }\n \n void UpdatePreferredDownload(CNode* node, CNodeState* state)\n@@ -472,20 +473,20 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n \n void RegisterNodeSignals(CNodeSignals& nodeSignals)\n {\n-    nodeSignals.GetHeight.connect(&GetHeight);\n-    nodeSignals.ProcessMessages.connect(&ProcessMessages);\n-    nodeSignals.SendMessages.connect(&SendMessages);\n-    nodeSignals.InitializeNode.connect(&InitializeNode);\n-    nodeSignals.FinalizeNode.connect(&FinalizeNode);\n+    nodeSignals.GetHeight.Connect(&GetHeight);\n+    nodeSignals.ProcessMessages.Connect(&ProcessMessages);\n+    nodeSignals.SendMessages.Connect(&SendMessages);\n+    nodeSignals.InitializeNode.Connect(&InitializeNode);\n+    nodeSignals.FinalizeNode.Connect(&FinalizeNode);\n }\n \n void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n {\n-    nodeSignals.GetHeight.disconnect(&GetHeight);\n-    nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n-    nodeSignals.SendMessages.disconnect(&SendMessages);\n-    nodeSignals.InitializeNode.disconnect(&InitializeNode);\n-    nodeSignals.FinalizeNode.disconnect(&FinalizeNode);\n+    nodeSignals.GetHeight.Disconnect(&GetHeight);\n+    nodeSignals.ProcessMessages.Disconnect(&ProcessMessages);\n+    nodeSignals.SendMessages.Disconnect(&SendMessages);\n+    nodeSignals.InitializeNode.Disconnect(&InitializeNode);\n+    nodeSignals.FinalizeNode.Disconnect(&FinalizeNode);\n }\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -2718,9 +2719,10 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n bool AbortNode(const std::string &strMessage, const std::string &userMessage) {\n     strMiscWarning = strMessage;\n     LogPrintf(\"*** %s\\n\", strMessage);\n+\tbool ret;\n     uiInterface.ThreadSafeMessageBox(\n         userMessage.empty() ? _(\"Error: A fatal internal error occured, see debug.log for details\") : userMessage,\n-        \"\", CClientUIInterface::MSG_ERROR);\n+        \"\", CClientUIInterface::MSG_ERROR, ret);\n     StartShutdown();\n     return false;\n }\n@@ -4210,7 +4212,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n }\n \n // requires LOCK(cs_vRecvMsg)\n-bool ProcessMessages(CNode* pfrom)\n+void ProcessMessages(CNode* pfrom, bool &result)\n {\n     //if (fDebug)\n     //    LogPrintf(\"ProcessMessages(%u messages)\\n\", pfrom->vRecvMsg.size());\n@@ -4229,7 +4231,10 @@ bool ProcessMessages(CNode* pfrom)\n         ProcessGetData(pfrom);\n \n     // this maintains the order of responses\n-    if (!pfrom->vRecvGetData.empty()) return fOk;\n+    if (!pfrom->vRecvGetData.empty()) {\n+\t\t\tresult = fOk;\n+\t\t\treturn;\n+\t}\n \n     std::deque<CNetMessage>::iterator it = pfrom->vRecvMsg.begin();\n     while (!pfrom->fDisconnect && it != pfrom->vRecvMsg.end()) {\n@@ -4327,16 +4332,18 @@ bool ProcessMessages(CNode* pfrom)\n     if (!pfrom->fDisconnect)\n         pfrom->vRecvMsg.erase(pfrom->vRecvMsg.begin(), it);\n \n-    return fOk;\n+    result = fOk;\n }\n \n \n-bool SendMessages(CNode* pto, bool fSendTrickle)\n+void SendMessages(CNode* pto, bool fSendTrickle, bool &result)\n {\n     {\n         // Don't send anything until we get their version message\n-        if (pto->nVersion == 0)\n-            return true;\n+        if (pto->nVersion == 0) {\n+\t\t\tresult = true;\n+            return;\n+\t\t}\n \n         //\n         // Message: ping\n@@ -4368,8 +4375,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()\n-        if (!lockMain)\n-            return true;\n+        if (!lockMain) {\n+\t\t\tresult = true;\n+            return;\n+\t\t}\n \n         // Address refresh broadcast\n         static int64_t nLastRebroadcast;\n@@ -4567,7 +4576,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             pto->PushMessage(\"getdata\", vGetData);\n \n     }\n-    return true;\n+    result = true;\n }\n \n "
      },
      {
        "sha": "eedc9e13de7988080423239447901c7c172d6004",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -178,9 +178,9 @@ void UnloadBlockIndex();\n /** Print the loaded block tree */\n void PrintBlockTree();\n /** Process protocol messages received from a given node */\n-bool ProcessMessages(CNode* pfrom);\n+void ProcessMessages(CNode* pfrom, bool &result);\n /** Send queued protocol messages to be sent to a give node */\n-bool SendMessages(CNode* pto, bool fSendTrickle);\n+void SendMessages(CNode* pto, bool fSendTrickle, bool &result);\n /** Run an instance of the script checking thread */\n void ThreadScriptCheck();\n /** Check whether we are doing an initial block download (synchronizing from disk or network) */"
      },
      {
        "sha": "1eb9ef64d327a0fbd26250279281a944d9321d87",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -523,7 +523,8 @@ void CNode::CloseSocketDisconnect()\n \n void CNode::PushVersion()\n {\n-    int nBestHeight = g_signals.GetHeight().get_value_or(0);\n+\tint nBestHeight = 0;\n+\tg_signals.GetHeight(nBestHeight);\n \n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n@@ -1513,7 +1514,9 @@ void ThreadMessageHandler()\n                 TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n                 if (lockRecv)\n                 {\n-                    if (!g_signals.ProcessMessages(pnode))\n+\t\t\t\t\tbool ret;\n+\t\t\t\t\tg_signals.ProcessMessages(pnode, ret);\n+                    if (!ret)\n                         pnode->CloseSocketDisconnect();\n \n                     if (pnode->nSendSize < SendBufferSize())\n@@ -1530,8 +1533,9 @@ void ThreadMessageHandler()\n             // Send messages\n             {\n                 TRY_LOCK(pnode->cs_vSend, lockSend);\n+\t\t\t\tbool ret;\n                 if (lockSend)\n-                    g_signals.SendMessages(pnode, pnode == pnodeTrickle);\n+                    g_signals.SendMessages(pnode, pnode == pnodeTrickle, ret);\n             }\n             boost::this_thread::interruption_point();\n         }"
      },
      {
        "sha": "b649110f557e4ac2946d825ec78bacb556954406",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -18,6 +18,7 @@\n #include \"sync.h\"\n #include \"uint256.h\"\n #include \"utilstrencodings.h\"\n+#include \"utilsignal.h\"\n \n #include <deque>\n #include <stdint.h>\n@@ -28,7 +29,6 @@\n \n #include <boost/filesystem/path.hpp>\n #include <boost/foreach.hpp>\n-#include <boost/signals2/signal.hpp>\n \n class CAddrMan;\n class CBlockIndex;\n@@ -79,11 +79,11 @@ typedef int NodeId;\n // Signals for message handling\n struct CNodeSignals\n {\n-    boost::signals2::signal<int ()> GetHeight;\n-    boost::signals2::signal<bool (CNode*)> ProcessMessages;\n-    boost::signals2::signal<bool (CNode*, bool)> SendMessages;\n-    boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;\n-    boost::signals2::signal<void (NodeId)> FinalizeNode;\n+\tGallant::Signal1<int& /* result */> GetHeight;\n+\tGallant::Signal2<CNode*, bool& /* result */> ProcessMessages;\n+\tGallant::Signal3<CNode*, bool, bool& /* result */> SendMessages;\n+\tGallant::Signal2<NodeId, const CNode*> InitializeNode;\n+\tGallant::Signal1<NodeId> FinalizeNode;\n };\n \n "
      },
      {
        "sha": "f9c4b2b55f8be8ad1d2567a14dd9139bd179a465",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -12,7 +12,7 @@\n #include <stdint.h>\n #include <string>\n \n-static bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)\n+static void noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style, bool &result)\n {\n     bool fSecure = style & CClientUIInterface::SECURE;\n     style &= ~CClientUIInterface::SECURE;\n@@ -36,7 +36,7 @@ static bool noui_ThreadSafeMessageBox(const std::string& message, const std::str\n     if (!fSecure)\n         LogPrintf(\"%s: %s\\n\", strCaption, message);\n     fprintf(stderr, \"%s: %s\\n\", strCaption.c_str(), message.c_str());\n-    return false;\n+\tresult = false;\n }\n \n static void noui_InitMessage(const std::string& message)\n@@ -47,6 +47,6 @@ static void noui_InitMessage(const std::string& message)\n void noui_connect()\n {\n     // Connect bitcoind signal handlers\n-    uiInterface.ThreadSafeMessageBox.connect(noui_ThreadSafeMessageBox);\n-    uiInterface.InitMessage.connect(noui_InitMessage);\n+    uiInterface.ThreadSafeMessageBox.Connect(&noui_ThreadSafeMessageBox);\n+    uiInterface.InitMessage.Connect(&noui_InitMessage);\n }"
      },
      {
        "sha": "7f703ccb99fdeddc58f2f61d95e902a4ffa45035",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -84,9 +84,9 @@ static void InitMessage(const std::string &message)\n /*\n    Translate string to current locale using Qt.\n  */\n-static std::string Translate(const char* psz)\n+static void Translate(const char* psz, std::string &result)\n {\n-    return QCoreApplication::translate(\"bitcoin-core\", psz).toStdString();\n+\tresult = QCoreApplication::translate(\"bitcoin-core\", psz).toStdString();\n }\n \n /** Set up translations */\n@@ -526,7 +526,7 @@ int main(int argc, char *argv[])\n     // Now that QSettings are accessible, initialize translations\n     QTranslator qtTranslatorBase, qtTranslator, translatorBase, translator;\n     initTranslations(qtTranslatorBase, qtTranslator, translatorBase, translator);\n-    uiInterface.Translate.connect(Translate);\n+    uiInterface.Translate.Connect(Translate);\n \n     // Show help message immediately after parsing command-line options (for \"-lang\") and setting locale,\n     // but before showing splash screen.\n@@ -613,7 +613,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel();\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    uiInterface.InitMessage.Connect(InitMessage);\n \n     if (GetBoolArg(\"-splash\", true) && !GetBoolArg(\"-min\", false))\n         app.createSplashScreen(networkStyle.data());"
      },
      {
        "sha": "045418ffac168b9e2636f6cbbde9e20fb1898e18",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -991,33 +991,33 @@ void BitcoinGUI::showProgress(const QString &title, int nProgress)\n         progressDialog->setValue(nProgress);\n }\n \n-static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)\n+void BitcoinGUI::ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style, bool &result)\n {\n     bool modal = (style & CClientUIInterface::MODAL);\n     // The SECURE flag has no effect in the Qt GUI.\n     // bool secure = (style & CClientUIInterface::SECURE);\n     style &= ~CClientUIInterface::SECURE;\n     bool ret = false;\n     // In case of modal message, use blocking connection to wait for user to click a button\n-    QMetaObject::invokeMethod(gui, \"message\",\n+    QMetaObject::invokeMethod(this, \"message\",\n                                modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                Q_ARG(QString, QString::fromStdString(caption)),\n                                Q_ARG(QString, QString::fromStdString(message)),\n                                Q_ARG(unsigned int, style),\n                                Q_ARG(bool*, &ret));\n-    return ret;\n+    result = ret;\n }\n \n void BitcoinGUI::subscribeToCoreSignals()\n {\n     // Connect signals to client\n-    uiInterface.ThreadSafeMessageBox.connect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n+    uiInterface.ThreadSafeMessageBox.Connect(this, &BitcoinGUI::ThreadSafeMessageBox);\n }\n \n void BitcoinGUI::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from client\n-    uiInterface.ThreadSafeMessageBox.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n+    uiInterface.ThreadSafeMessageBox.Disconnect(this, &BitcoinGUI::ThreadSafeMessageBox);\n }\n \n UnitDisplayStatusBarControl::UnitDisplayStatusBarControl() :"
      },
      {
        "sha": "8556c1323c33a405a0d4f3cb71c76c061c8a636c",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -55,6 +55,8 @@ class BitcoinGUI : public QMainWindow\n     */\n     void setClientModel(ClientModel *clientModel);\n \n+\tvoid ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style, bool &result);\n+\n #ifdef ENABLE_WALLET\n     /** Set the wallet model.\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending"
      },
      {
        "sha": "86c104d324a081dc884027e2e00926532aafd84e",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -202,41 +202,41 @@ QString ClientModel::formatClientStartupTime() const\n }\n \n // Handlers for core signals\n-static void ShowProgress(ClientModel *clientmodel, const std::string &title, int nProgress)\n+void ClientModel::ShowProgress(const std::string &title, int nProgress)\n {\n     // emits signal \"showProgress\"\n-    QMetaObject::invokeMethod(clientmodel, \"showProgress\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(this, \"showProgress\", Qt::QueuedConnection,\n                               Q_ARG(QString, QString::fromStdString(title)),\n                               Q_ARG(int, nProgress));\n }\n \n-static void NotifyNumConnectionsChanged(ClientModel *clientmodel, int newNumConnections)\n+void ClientModel::NotifyNumConnectionsChanged(int newNumConnections)\n {\n     // Too noisy: qDebug() << \"NotifyNumConnectionsChanged : \" + QString::number(newNumConnections);\n-    QMetaObject::invokeMethod(clientmodel, \"updateNumConnections\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(this, \"updateNumConnections\", Qt::QueuedConnection,\n                               Q_ARG(int, newNumConnections));\n }\n \n-static void NotifyAlertChanged(ClientModel *clientmodel, const uint256 &hash, ChangeType status)\n+void ClientModel::NotifyAlertChanged(const uint256 &hash, ChangeType status)\n {\n     qDebug() << \"NotifyAlertChanged : \" + QString::fromStdString(hash.GetHex()) + \" status=\" + QString::number(status);\n-    QMetaObject::invokeMethod(clientmodel, \"updateAlert\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(this, \"updateAlert\", Qt::QueuedConnection,\n                               Q_ARG(QString, QString::fromStdString(hash.GetHex())),\n                               Q_ARG(int, status));\n }\n \n void ClientModel::subscribeToCoreSignals()\n {\n     // Connect signals to client\n-    uiInterface.ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n-    uiInterface.NotifyNumConnectionsChanged.connect(boost::bind(NotifyNumConnectionsChanged, this, _1));\n-    uiInterface.NotifyAlertChanged.connect(boost::bind(NotifyAlertChanged, this, _1, _2));\n+    uiInterface.ShowProgress.Connect(this, &ClientModel::ShowProgress);\n+    uiInterface.NotifyNumConnectionsChanged.Connect(this, &ClientModel::NotifyNumConnectionsChanged);\n+    uiInterface.NotifyAlertChanged.Connect(this, &ClientModel::NotifyAlertChanged);\n }\n \n void ClientModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from client\n-    uiInterface.ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n-    uiInterface.NotifyNumConnectionsChanged.disconnect(boost::bind(NotifyNumConnectionsChanged, this, _1));\n-    uiInterface.NotifyAlertChanged.disconnect(boost::bind(NotifyAlertChanged, this, _1, _2));\n+    uiInterface.ShowProgress.Disconnect(this, &ClientModel::ShowProgress);\n+    uiInterface.NotifyNumConnectionsChanged.Disconnect(this, &ClientModel::NotifyNumConnectionsChanged);\n+    uiInterface.NotifyAlertChanged.Disconnect(this, &ClientModel::NotifyAlertChanged);\n }"
      },
      {
        "sha": "3bba3af5799a3bc17d595d6dc92eb69b17466d98",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -5,6 +5,9 @@\n #ifndef BITCOIN_QT_CLIENTMODEL_H\n #define BITCOIN_QT_CLIENTMODEL_H\n \n+#include \"uint256.h\"\n+#include \"ui_interface.h\"\n+\n #include <QObject>\n \n class AddressTableModel;\n@@ -69,6 +72,10 @@ class ClientModel : public QObject\n     QString clientName() const;\n     QString formatClientStartupTime() const;\n \n+    void ShowProgress(const std::string &title, int nProgress); // != showProgress\n+\tvoid NotifyNumConnectionsChanged(int newNumConnections);\n+\tvoid NotifyAlertChanged(const uint256 &hash, ChangeType status);\n+\n private:\n     OptionsModel *optionsModel;\n     PeerTableModel *peerTableModel;"
      },
      {
        "sha": "5914026afef9a1c510dff1685da0b5dc74cd68de",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -109,45 +109,46 @@ void SplashScreen::slotFinish(QWidget *mainWin)\n     hide();\n }\n \n-static void InitMessage(SplashScreen *splash, const std::string &message)\n+void SplashScreen::InitMessage(const std::string &message)\n {\n-    QMetaObject::invokeMethod(splash, \"showMessage\",\n+    QMetaObject::invokeMethod(this, \"showMessage\",\n         Qt::QueuedConnection,\n         Q_ARG(QString, QString::fromStdString(message)),\n         Q_ARG(int, Qt::AlignBottom|Qt::AlignHCenter),\n         Q_ARG(QColor, QColor(55,55,55)));\n }\n \n-static void ShowProgress(SplashScreen *splash, const std::string &title, int nProgress)\n+void SplashScreen::ShowProgress(const std::string &title, int nProgress)\n {\n-    InitMessage(splash, title + strprintf(\"%d\", nProgress) + \"%\");\n+    InitMessage(title + strprintf(\"%d\", nProgress) + \"%\");\n }\n \n #ifdef ENABLE_WALLET\n-static void ConnectWallet(SplashScreen *splash, CWallet* wallet)\n+void SplashScreen::ConnectWallet(CWallet* wallet)\n {\n-    wallet->ShowProgress.connect(boost::bind(ShowProgress, splash, _1, _2));\n+    wallet->ShowProgress.Connect(this, & SplashScreen::ShowProgress);\n }\n #endif\n \n void SplashScreen::subscribeToCoreSignals()\n {\n     // Connect signals to client\n-    uiInterface.InitMessage.connect(boost::bind(InitMessage, this, _1));\n-    uiInterface.ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n+    uiInterface.InitMessage.Connect(this, &SplashScreen::InitMessage);\n+    uiInterface.ShowProgress.Connect(this, &SplashScreen::ShowProgress);\n #ifdef ENABLE_WALLET\n-    uiInterface.LoadWallet.connect(boost::bind(ConnectWallet, this, _1));\n+    uiInterface.LoadWallet.Connect(this, &SplashScreen::ConnectWallet);\n #endif\n }\n \n void SplashScreen::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from client\n-    uiInterface.InitMessage.disconnect(boost::bind(InitMessage, this, _1));\n-    uiInterface.ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n+    uiInterface.InitMessage.Disconnect(this, &SplashScreen::InitMessage);\n+    uiInterface.ShowProgress.Disconnect(this, &SplashScreen::ShowProgress);\n #ifdef ENABLE_WALLET\n+\tuiInterface.LoadWallet.Disconnect(this, &SplashScreen::ConnectWallet);\n     if(pwalletMain)\n-        pwalletMain->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n+\t\tpwalletMain->ShowProgress.Disconnect(this, &SplashScreen::ShowProgress);\n #endif\n }\n "
      },
      {
        "sha": "08860e15f152b96b82c44f3894f9799ea83eecb7",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_QT_SPLASHSCREEN_H\n #define BITCOIN_QT_SPLASHSCREEN_H\n \n+#include \"ui_interface.h\"\n+\n #include <QSplashScreen>\n \n class NetworkStyle;\n@@ -23,6 +25,10 @@ class SplashScreen : public QWidget\n     explicit SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle);\n     ~SplashScreen();\n \n+\tvoid InitMessage(const std::string &message);\n+    void ShowProgress(const std::string &title, int nProgress);\n+\tvoid ConnectWallet(CWallet *wallet);\n+\n protected:\n     void paintEvent(QPaintEvent *event);\n     void closeEvent(QCloseEvent *event);"
      },
      {
        "sha": "b4a1080a7f87ea5cce54d62d8e8b047e3991f044",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -673,7 +673,7 @@ struct TransactionNotification\n static bool fQueueNotifications = false;\n static std::vector< TransactionNotification > vQueueNotifications;\n \n-static void NotifyTransactionChanged(TransactionTableModel *ttm, CWallet *wallet, const uint256 &hash, ChangeType status)\n+void TransactionTableModel::NotifyTransactionChanged(CWallet *wallet, const uint256 &hash, ChangeType status)\n {\n     // Find transaction in wallet\n     std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(hash);\n@@ -688,10 +688,10 @@ static void NotifyTransactionChanged(TransactionTableModel *ttm, CWallet *wallet\n         vQueueNotifications.push_back(notification);\n         return;\n     }\n-    notification.invoke(ttm);\n+    notification.invoke(this);\n }\n \n-static void ShowProgress(TransactionTableModel *ttm, const std::string &title, int nProgress)\n+void TransactionTableModel::ShowProgress(const std::string &title, int nProgress)\n {\n     if (nProgress == 0)\n         fQueueNotifications = true;\n@@ -700,13 +700,13 @@ static void ShowProgress(TransactionTableModel *ttm, const std::string &title, i\n     {\n         fQueueNotifications = false;\n         if (vQueueNotifications.size() > 10) // prevent balloon spam, show maximum 10 balloons\n-            QMetaObject::invokeMethod(ttm, \"setProcessingQueuedTransactions\", Qt::QueuedConnection, Q_ARG(bool, true));\n+            QMetaObject::invokeMethod(this, \"setProcessingQueuedTransactions\", Qt::QueuedConnection, Q_ARG(bool, true));\n         for (unsigned int i = 0; i < vQueueNotifications.size(); ++i)\n         {\n             if (vQueueNotifications.size() - i <= 10)\n-                QMetaObject::invokeMethod(ttm, \"setProcessingQueuedTransactions\", Qt::QueuedConnection, Q_ARG(bool, false));\n+                QMetaObject::invokeMethod(this, \"setProcessingQueuedTransactions\", Qt::QueuedConnection, Q_ARG(bool, false));\n \n-            vQueueNotifications[i].invoke(ttm);\n+            vQueueNotifications[i].invoke(this);\n         }\n         std::vector<TransactionNotification >().swap(vQueueNotifications); // clear\n     }\n@@ -715,13 +715,13 @@ static void ShowProgress(TransactionTableModel *ttm, const std::string &title, i\n void TransactionTableModel::subscribeToCoreSignals()\n {\n     // Connect signals to wallet\n-    wallet->NotifyTransactionChanged.connect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n+    wallet->NotifyTransactionChanged.Connect(this, &TransactionTableModel::NotifyTransactionChanged);\n+    wallet->ShowProgress.Connect(this, &TransactionTableModel::ShowProgress);\n }\n \n void TransactionTableModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from wallet\n-    wallet->NotifyTransactionChanged.disconnect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n+    wallet->NotifyTransactionChanged.Disconnect(this, &TransactionTableModel::NotifyTransactionChanged);\n+    wallet->ShowProgress.Disconnect(this, &TransactionTableModel::ShowProgress);\n }"
      },
      {
        "sha": "46aba24d410c7cdee8d5bfd1058b9a5cae962fab",
        "filename": "src/qt/transactiontablemodel.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/transactiontablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/transactiontablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -6,6 +6,8 @@\n #define BITCOIN_QT_TRANSACTIONTABLEMODEL_H\n \n #include \"bitcoinunits.h\"\n+#include \"uint256.h\"\n+#include \"ui_interface.h\"\n \n #include <QAbstractTableModel>\n #include <QStringList>\n@@ -73,6 +75,8 @@ class TransactionTableModel : public QAbstractTableModel\n     QVariant headerData(int section, Qt::Orientation orientation, int role) const;\n     QModelIndex index(int row, int column, const QModelIndex & parent = QModelIndex()) const;\n     bool processingQueuedTransactions() { return fProcessingQueuedTransactions; }\n+    void ShowProgress(const std::string &title, int nProgress);\n+\tvoid NotifyTransactionChanged(CWallet *wallet, const uint256 &hash, ChangeType status);\n \n private:\n     CWallet* wallet;"
      },
      {
        "sha": "376d5c9a732f886732ae2188a90d0c73709ce0b6",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -428,13 +428,13 @@ bool WalletModel::backupWallet(const QString &filename)\n }\n \n // Handlers for core signals\n-static void NotifyKeyStoreStatusChanged(WalletModel *walletmodel, CCryptoKeyStore *wallet)\n+void WalletModel::NotifyKeyStoreStatusChanged(CCryptoKeyStore *wallet)\n {\n     qDebug() << \"NotifyKeyStoreStatusChanged\";\n-    QMetaObject::invokeMethod(walletmodel, \"updateStatus\", Qt::QueuedConnection);\n+    QMetaObject::invokeMethod(this, \"updateStatus\", Qt::QueuedConnection);\n }\n \n-static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n+void WalletModel::NotifyAddressBookChanged(CWallet *wallet,\n         const CTxDestination &address, const std::string &label, bool isMine,\n         const std::string &purpose, ChangeType status)\n {\n@@ -443,54 +443,54 @@ static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n     QString strPurpose = QString::fromStdString(purpose);\n \n     qDebug() << \"NotifyAddressBookChanged : \" + strAddress + \" \" + strLabel + \" isMine=\" + QString::number(isMine) + \" purpose=\" + strPurpose + \" status=\" + QString::number(status);\n-    QMetaObject::invokeMethod(walletmodel, \"updateAddressBook\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(this, \"updateAddressBook\", Qt::QueuedConnection,\n                               Q_ARG(QString, strAddress),\n                               Q_ARG(QString, strLabel),\n                               Q_ARG(bool, isMine),\n                               Q_ARG(QString, strPurpose),\n                               Q_ARG(int, status));\n }\n \n-static void NotifyTransactionChanged(WalletModel *walletmodel, CWallet *wallet, const uint256 &hash, ChangeType status)\n+void WalletModel::NotifyTransactionChanged(CWallet *wallet, const uint256 &hash, ChangeType status)\n {\n     Q_UNUSED(wallet);\n     Q_UNUSED(hash);\n     Q_UNUSED(status);\n-    QMetaObject::invokeMethod(walletmodel, \"updateTransaction\", Qt::QueuedConnection);\n+    QMetaObject::invokeMethod(this, \"updateTransaction\", Qt::QueuedConnection);\n }\n \n-static void ShowProgress(WalletModel *walletmodel, const std::string &title, int nProgress)\n+void WalletModel::ShowProgress(const std::string &title, int nProgress)\n {\n     // emits signal \"showProgress\"\n-    QMetaObject::invokeMethod(walletmodel, \"showProgress\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(this, \"showProgress\", Qt::QueuedConnection,\n                               Q_ARG(QString, QString::fromStdString(title)),\n                               Q_ARG(int, nProgress));\n }\n \n-static void NotifyWatchonlyChanged(WalletModel *walletmodel, bool fHaveWatchonly)\n+void WalletModel::NotifyWatchonlyChanged(bool fHaveWatchonly)\n {\n-    QMetaObject::invokeMethod(walletmodel, \"updateWatchOnlyFlag\", Qt::QueuedConnection,\n+    QMetaObject::invokeMethod(this, \"updateWatchOnlyFlag\", Qt::QueuedConnection,\n                               Q_ARG(bool, fHaveWatchonly));\n }\n \n void WalletModel::subscribeToCoreSignals()\n {\n     // Connect signals to wallet\n-    wallet->NotifyStatusChanged.connect(boost::bind(&NotifyKeyStoreStatusChanged, this, _1));\n-    wallet->NotifyAddressBookChanged.connect(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n-    wallet->NotifyTransactionChanged.connect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n-    wallet->NotifyWatchonlyChanged.connect(boost::bind(NotifyWatchonlyChanged, this, _1));\n+    wallet->NotifyStatusChanged.Connect(this, &WalletModel::NotifyKeyStoreStatusChanged);\n+    wallet->NotifyAddressBookChanged.Connect(this, &WalletModel::NotifyAddressBookChanged);\n+    wallet->NotifyTransactionChanged.Connect(this, &WalletModel::NotifyTransactionChanged);\n+    wallet->ShowProgress.Connect(this, &WalletModel::ShowProgress);\n+    wallet->NotifyWatchonlyChanged.Connect(this, &WalletModel::NotifyWatchonlyChanged);\n }\n \n void WalletModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from wallet\n-    wallet->NotifyStatusChanged.disconnect(boost::bind(&NotifyKeyStoreStatusChanged, this, _1));\n-    wallet->NotifyAddressBookChanged.disconnect(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n-    wallet->NotifyTransactionChanged.disconnect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n-    wallet->NotifyWatchonlyChanged.disconnect(boost::bind(NotifyWatchonlyChanged, this, _1));\n+    wallet->NotifyStatusChanged.Disconnect(this, &WalletModel::NotifyKeyStoreStatusChanged);\n+    wallet->NotifyAddressBookChanged.Disconnect(this, &WalletModel::NotifyAddressBookChanged);\n+    wallet->NotifyTransactionChanged.Disconnect(this, &WalletModel::NotifyTransactionChanged);\n+    wallet->ShowProgress.Disconnect(this, &WalletModel::ShowProgress);\n+    wallet->NotifyWatchonlyChanged.Disconnect(this, &WalletModel::NotifyWatchonlyChanged);\n }\n \n // WalletModel::UnlockContext implementation"
      },
      {
        "sha": "af4953f0bd9a74f7c2a013d758a5c68d2b04a86f",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -9,6 +9,8 @@\n #include \"walletmodeltransaction.h\"\n \n #include \"allocators.h\" /* for SecureString */\n+#include \"crypter.h\"\n+#include \"ui_interface.h\"\n \n #include <map>\n #include <vector>\n@@ -194,6 +196,14 @@ class WalletModel : public QObject\n     void loadReceiveRequests(std::vector<std::string>& vReceiveRequests);\n     bool saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest);\n \n+\tvoid NotifyAddressBookChanged(CWallet *wallet,\n+\t\t\t\t\tconst CTxDestination &address, const std::string &label, bool isMine,\n+\t\t\t\t\tconst std::string &purpose, ChangeType status);\n+    void NotifyKeyStoreStatusChanged(CCryptoKeyStore *wallet);\n+    void ShowProgress(const std::string &title, int nProgress); // != showProgress\n+\tvoid NotifyTransactionChanged(CWallet *wallet, const uint256 &hash, ChangeType status);\n+\tvoid NotifyWatchonlyChanged(bool fHaveWatchonly);\n+\n private:\n     CWallet *wallet;\n     bool fHaveWatchOnly;"
      },
      {
        "sha": "8f31170e73539fd06f6e3ae0deffe15868200227",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -544,9 +544,10 @@ void StartRPCThreads()\n             CSubNet subnet(strAllow);\n             if(!subnet.IsValid())\n             {\n+\t\t\t\tbool ret;\n                 uiInterface.ThreadSafeMessageBox(\n                     strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n+                    \"\", CClientUIInterface::MSG_ERROR, ret);\n                 StartShutdown();\n                 return;\n             }\n@@ -563,6 +564,7 @@ void StartRPCThreads()\n          (mapArgs[\"-rpcuser\"] == mapArgs[\"-rpcpassword\"])) && Params().RequireRPCPassword())\n     {\n         unsigned char rand_pwd[32];\n+\t\tbool ret;\n         GetRandBytes(rand_pwd, 32);\n         string strWhatAmI = \"To use bitcoind\";\n         if (mapArgs.count(\"-server\"))\n@@ -583,7 +585,7 @@ void StartRPCThreads()\n                 strWhatAmI,\n                 GetConfigFile().string(),\n                 EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32)),\n-                \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::SECURE);\n+                \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::SECURE, ret);\n         StartShutdown();\n         return;\n     }\n@@ -632,9 +634,10 @@ void StartRPCThreads()\n             }\n             catch(const boost::system::system_error &)\n             {\n+\t\t\t\tbool ret;\n                 uiInterface.ThreadSafeMessageBox(\n                     strprintf(_(\"Could not parse -rpcbind value %s as network address\"), addr),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n+                    \"\", CClientUIInterface::MSG_ERROR, ret);\n                 StartShutdown();\n                 return;\n             }\n@@ -683,7 +686,8 @@ void StartRPCThreads()\n     }\n \n     if (!fListening) {\n-        uiInterface.ThreadSafeMessageBox(strerr, \"\", CClientUIInterface::MSG_ERROR);\n+\t\tbool ret;\n+        uiInterface.ThreadSafeMessageBox(strerr, \"\", CClientUIInterface::MSG_ERROR, ret);\n         StartShutdown();\n         return;\n     }"
      },
      {
        "sha": "b043e2f344ecf22be6f8556bbfd306fca671fec7",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -45,48 +45,51 @@ BOOST_AUTO_TEST_SUITE(DoS_tests)\n \n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n+\tbool ret;\n     CNode::ClearBanned();\n     CAddress addr1(ip(0xa0b0c001));\n     CNode dummyNode1(INVALID_SOCKET, addr1, \"\", true);\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n-    SendMessages(&dummyNode1, false);\n+    SendMessages(&dummyNode1, false, ret);\n     BOOST_CHECK(CNode::IsBanned(addr1));\n     BOOST_CHECK(!CNode::IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002));\n     CNode dummyNode2(INVALID_SOCKET, addr2, \"\", true);\n     dummyNode2.nVersion = 1;\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, false);\n+    SendMessages(&dummyNode2, false, ret);\n     BOOST_CHECK(!CNode::IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(CNode::IsBanned(addr1));  // ... but 1 still should be\n     Misbehaving(dummyNode2.GetId(), 50);\n-    SendMessages(&dummyNode2, false);\n+    SendMessages(&dummyNode2, false, ret);\n     BOOST_CHECK(CNode::IsBanned(addr2));\n }\n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n {\n+\tbool ret;\n     CNode::ClearBanned();\n     mapArgs[\"-banscore\"] = \"111\"; // because 11 is my favorite number\n     CAddress addr1(ip(0xa0b0c001));\n     CNode dummyNode1(INVALID_SOCKET, addr1, \"\", true);\n     dummyNode1.nVersion = 1;\n     Misbehaving(dummyNode1.GetId(), 100);\n-    SendMessages(&dummyNode1, false);\n+    SendMessages(&dummyNode1, false, ret);\n     BOOST_CHECK(!CNode::IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 10);\n-    SendMessages(&dummyNode1, false);\n+    SendMessages(&dummyNode1, false, ret);\n     BOOST_CHECK(!CNode::IsBanned(addr1));\n     Misbehaving(dummyNode1.GetId(), 1);\n-    SendMessages(&dummyNode1, false);\n+    SendMessages(&dummyNode1, false, ret);\n     BOOST_CHECK(CNode::IsBanned(addr1));\n     mapArgs.erase(\"-banscore\");\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n+\tbool ret;\n     CNode::ClearBanned();\n     int64_t nStartTime = GetTime();\n     SetMockTime(nStartTime); // Overrides future calls to GetTime()\n@@ -96,7 +99,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     dummyNode.nVersion = 1;\n \n     Misbehaving(dummyNode.GetId(), 100);\n-    SendMessages(&dummyNode, false);\n+    SendMessages(&dummyNode, false, ret);\n     BOOST_CHECK(CNode::IsBanned(addr));\n \n     SetMockTime(nStartTime+60*60);"
      },
      {
        "sha": "4c53e167aec08ec35f60cac32d6dd2376c48c490",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -101,7 +101,8 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n                     string strMessage = _(\"Warning: Please check that your computer's date and time are correct! If your clock is wrong Bitcoin Core will not work properly.\");\n                     strMiscWarning = strMessage;\n                     LogPrintf(\"*** %s\\n\", strMessage);\n-                    uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n+\t\t\t\t\tbool ret;\n+                    uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING, ret);\n                 }\n             }\n         }"
      },
      {
        "sha": "19da1c3ea7a20ab88997acc5306fb608d66a4ce4",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 22,
        "deletions": 21,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -9,8 +9,7 @@\n #include <stdint.h>\n #include <string>\n \n-#include <boost/signals2/last_value.hpp>\n-#include <boost/signals2/signal.hpp>\n+#include \"utilsignal.h\"\n \n class CBasicKeyStore;\n class CWallet;\n@@ -73,31 +72,32 @@ class CClientUIInterface\n     };\n \n     /** Show message box. */\n-    boost::signals2::signal<bool (const std::string& message, const std::string& caption, unsigned int style), boost::signals2::last_value<bool> > ThreadSafeMessageBox;\n+\tGallant::Signal4<const std::string& /* message */, const std::string& /* caption */,\n+\t\t\tunsigned int /* style */, bool & /* result */> ThreadSafeMessageBox;\n \n     /** Progress message during initialization. */\n-    boost::signals2::signal<void (const std::string &message)> InitMessage;\n+    Gallant::Signal1<const std::string & /* message */> InitMessage;\n \n-    /** Translate a message to the native language of the user. */\n-    boost::signals2::signal<std::string (const char* psz)> Translate;\n+\t/** Translate a message to the native language of the user. */\n+\tGallant::Signal2<const char* /* psz */, std::string & /* result */> Translate;\n \n-    /** Number of network connections changed. */\n-    boost::signals2::signal<void (int newNumConnections)> NotifyNumConnectionsChanged;\n+\t/** Number of network connections changed. */\n+\tGallant::Signal1<int /* newNumConnections */> NotifyNumConnectionsChanged;\n \n-    /**\n-     * New, updated or cancelled alert.\n-     * @note called with lock cs_mapAlerts held.\n-     */\n-    boost::signals2::signal<void (const uint256 &hash, ChangeType status)> NotifyAlertChanged;\n+\t/**\n+\t * New, updated or cancelled alert.\n+\t * @note called with lock cs_mapAlerts held.\n+\t */\n+\tGallant::Signal2<const uint256 & /* hash*/, ChangeType /* status */> NotifyAlertChanged;\n \n-    /** A wallet has been loaded. */\n-    boost::signals2::signal<void (CWallet* wallet)> LoadWallet;\n+\t/** A wallet has been loaded. */\n+\tGallant::Signal1<CWallet * /* wallet */> LoadWallet;\n \n-    /** Show progress e.g. for verifychain */\n-    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n+\t/** Show progress e.g. for verifychain */\n+\tGallant::Signal2<const std::string & /* title */, int /* nProgress */> ShowProgress;\n \n-    /** New block has been accepted */\n-    boost::signals2::signal<void (const uint256& hash)> NotifyBlockTip;\n+\t/** New block has been accepted */\n+\tGallant::Signal1<const uint256 & /* hash */> NotifyBlockTip;\n };\n \n extern CClientUIInterface uiInterface;\n@@ -108,8 +108,9 @@ extern CClientUIInterface uiInterface;\n  */\n inline std::string _(const char* psz)\n {\n-    boost::optional<std::string> rv = uiInterface.Translate(psz);\n-    return rv ? (*rv) : psz;\n+\tstd::string rv(psz);\n+\tuiInterface.Translate(psz, rv);\n+\treturn rv;\n }\n \n #endif // BITCOIN_UI_INTERFACE_H"
      },
      {
        "sha": "c47e1c1c3f7c30de842c9858b849d4200a8d9ca7",
        "filename": "src/utildelegate.h",
        "status": "added",
        "additions": 2138,
        "deletions": 0,
        "changes": 2138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/utildelegate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/utildelegate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utildelegate.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -0,0 +1,2138 @@\n+/*\n+ *\tDelegate.h\n+ *\tEfficient delegates in C++ that generate only two lines of asm code\n+ *\n+ *\tCreated by Don Clugston.\n+ *\tContributions by Jody Hagins.\n+ *\tTweaked by Patrick Hogan on 5/18/09.\n+ *\thttp://www.codeproject.com/KB/cpp/FastDelegate.aspx\n+ *  http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible\n+ *\n+ *\tLicense:\n+ *\tAs stated explicitly in the article linked above, this code is released into the public domain\n+ *\tand may be used for any purpose.\n+ *\n+ */\n+\n+//\tDelegates.h\n+//\tEfficient delegates in C++ that generate only two lines of asm code!\n+//\tDocumentation is found at http://www.codeproject.com/KB/cpp/FastDelegate.aspx\n+//\n+//\tBy Don Clugston, Mar 2004.\n+//\tMajor contributions were made by Jody Hagins.\n+//\n+// History:\n+//\n+// 24-Apr-04 1.0  * Submitted to CodeProject.\n+// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.\n+//\t\t\t\t  * Improved syntax for horrible_cast (thanks Paul Bludov).\n+//\t\t\t\t  * Tested on Metrowerks MWCC and Intel ICL (IA32)\n+//\t\t\t\t  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.\n+//\t27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5\n+//\t\t\t\t  * Now works on /clr \"managed C++\" code on VC7, VC7.1\n+//\t\t\t\t  * Comeau C++ now compiles without warnings.\n+//\t\t\t\t  * Prevent the virtual inheritance case from being used on\n+//\t\t\t\t\t  VC6 and earlier, which generate incorrect code.\n+//\t\t\t\t  * Improved warning and error messages. Non-standard hacks\n+//\t\t\t\t\t now have compile-time checks to make them safer.\n+//\t\t\t\t  * implicit_cast used instead of static_cast in many cases.\n+//\t\t\t\t  * If calling a const member function, a const class pointer can be used.\n+//\t\t\t\t  * MakeDelegate() global helper function added to simplify pass-by-value.\n+//\t\t\t\t  * Added fastdelegate.clear()\n+// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)\n+// 30-Oct-04 1.3  * Support for (non-void) return values.\n+//\t\t\t\t  * No more workarounds in client code!\n+//\t\t\t\t\t MSVC and Intel now use a clever hack invented by John Dlugosz:\n+//\t\t\t\t\t - The FASTDELEGATEDECLARE workaround is no longer necessary.\n+//\t\t\t\t\t - No more warning messages for VC6\n+//\t\t\t\t  * Less use of macros. Error messages should be more comprehensible.\n+//\t\t\t\t  * Added include guards\n+//\t\t\t\t  * Added delegate::empty() to test if invocation is safe (Thanks Neville Franks).\n+//\t\t\t\t  * Now tested on VS 2005 Express Beta, PGI C++\n+// 24-Dec-04 1.4  * Added DelegateMemento, to allow collections of disparate delegates.\n+//\t\t\t\t  * <,>,<=,>= comparison operators to allow storage in ordered containers.\n+//\t\t\t\t  * Substantial reduction of code size, especially the 'Closure' class.\n+//\t\t\t\t  * Standardised all the compiler-specific workarounds.\n+//\t\t\t\t  * MFP conversion now works for CodePlay (but not yet supported in the full code).\n+//\t\t\t\t  * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1\n+//\t\t\t\t  * New syntax: delegate< int (char *, double) >.\n+// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .clear(), ==0 as equivalent to .empty(). (Thanks elfric).\n+//\t\t\t\t  * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.\n+// 30-Mar-05 1.5  * Safebool idiom: \"if (dg)\" is now equivalent to \"if (!dg.empty())\"\n+//\t\t\t\t  * Fully supported by CodePlay VectorC\n+//\t\t\t\t  * Bugfix for Metrowerks: empty() was buggy because a valid MFP can be 0 on MWCC!\n+//\t\t\t\t  * More optimal assignment,== and != operators for static function pointers.\n+//\n+// 19-May-09 1.5a Patrick Hogan:\n+//\t\t\t\t  * Bundled with Signals.h for signals and slots library\n+//\t\t\t\t  * Changed namespace to \"Gallant\"\n+\n+#ifndef _Delegate_H_\n+#define _Delegate_H_\n+\n+#if _MSC_VER > 1000\n+\t#pragma once\n+#endif // _MSC_VER > 1000\n+\n+#include <memory.h> // to allow <,> comparisons\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tConfiguration options\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// Uncomment the following #define for optimally-sized delegates.\n+// In this case, the generated asm code is almost identical to the code you'd get\n+// if the compiler had native support for delegates.\n+// It will not work on systems where sizeof(dataptr) < sizeof(codeptr).\n+// Thus, it will not work for DOS compilers using the medium model.\n+// It will also probably fail on some DSP systems.\n+#define FASTDELEGATE_USESTATICFUNCTIONHACK\n+\n+// Uncomment the next line to allow function declarator syntax.\n+// It is automatically enabled for those compilers where it is known to work.\n+//#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tCompiler identification for workarounds\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// Compiler identification. It's not easy to identify Visual C++ because\n+// many vendors fraudulently define Microsoft's identifiers.\n+#if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)\n+#define FASTDLGT_ISMSVC\n+\n+#if (_MSC_VER <1300) // Many workarounds are required for VC6.\n+#define FASTDLGT_VC6\n+#pragma warning(disable:4786) // disable this ridiculous warning\n+#endif\n+\n+#endif\n+\n+// Does the compiler uses Microsoft's member function pointer structure?\n+// If so, it needs special treatment.\n+// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's\n+// identifier, _MSC_VER. We need to filter Metrowerks out.\n+#if defined(_MSC_VER) && !defined(__MWERKS__)\n+#define FASTDLGT_MICROSOFT_MFP\n+\n+#if !defined(__VECTOR_C)\n+// CodePlay doesn't have the __single/multi/virtual_inheritance keywords\n+#define FASTDLGT_HASINHERITANCE_KEYWORDS\n+#endif\n+#endif\n+\n+// Does it allow function declarator syntax? The following compilers are known to work:\n+#if defined(FASTDLGT_ISMSVC) && (_MSC_VER >=1310) // VC 7.1\n+#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX\n+#endif\n+\n+// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.\n+#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)\n+#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX\n+#endif\n+\n+// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.\n+#if defined (__MWERKS__)\n+#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX\n+#endif\n+\n+#ifdef __GNUC__ // Workaround GCC bug #8271\n+\t// At present, GCC doesn't recognize constness of MFPs in templates\n+#define FASTDELEGATE_GCC_BUG_8271\n+#endif\n+\n+\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tGeneral tricks used in this code\n+//\n+// (a) Error messages are generated by typdefing an array of negative size to\n+//\t   generate compile-time errors.\n+// (b) Warning messages on MSVC are generated by declaring unused variables, and\n+//\t\tenabling the \"variable XXX is never used\" warning.\n+// (c) Unions are used in a few compiler-specific cases to perform illegal casts.\n+// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to\n+//\t   (char *) first to ensure that the correct number of *bytes* are added.\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tHelper templates\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+\n+namespace Gallant {\n+\n+namespace detail {\t// we'll hide the implementation details in a nested namespace.\n+\n+//\t\timplicit_cast< >\n+// I believe this was originally going to be in the C++ standard but\n+// was left out by accident. It's even milder than static_cast.\n+// I use it instead of static_cast<> to emphasize that I'm not doing\n+// anything nasty.\n+// Usage is identical to static_cast<>\n+template <class OutputClass, class InputClass>\n+inline OutputClass implicit_cast(InputClass input){\n+\treturn input;\n+}\n+\n+//\t\thorrible_cast< >\n+// This is truly evil. It completely subverts C++'s type system, allowing you\n+// to cast from any class to any other class. Technically, using a union\n+// to perform the cast is undefined behaviour (even in C). But we can see if\n+// it is OK by checking that the union is the same size as each of its members.\n+// horrible_cast<> should only be used for compiler-specific workarounds.\n+// Usage is identical to reinterpret_cast<>.\n+\n+// This union is declared outside the horrible_cast because BCC 5.5.1\n+// can't inline a function with a nested class, and gives a warning.\n+template <class OutputClass, class InputClass>\n+union horrible_union{\n+\tOutputClass out;\n+\tInputClass in;\n+};\n+\n+template <class OutputClass, class InputClass>\n+inline OutputClass horrible_cast(const InputClass input){\n+\thorrible_union<OutputClass, InputClass> u;\n+\t// Cause a compile-time error if in, out and u are not the same size.\n+\t// If the compile fails here, it means the compiler has peculiar\n+\t// unions which would prevent the cast from working.\n+\ttypedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u)\n+\t\t&& sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];\n+\tu.in = input;\n+\treturn u.out;\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tWorkarounds\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// Backwards compatibility: This macro used to be necessary in the virtual inheritance\n+// case for Intel and Microsoft. Now it just forward-declares the class.\n+#define FASTDELEGATEDECLARE(CLASSNAME)\tclass CLASSNAME;\n+\n+// Prevent use of the static function hack with the DOS medium model.\n+#ifdef __MEDIUM__\n+#undef FASTDELEGATE_USESTATICFUNCTIONHACK\n+#endif\n+\n+//\t\t\tDefaultVoid - a workaround for 'void' templates in VC6.\n+//\n+//\t(1) VC6 and earlier do not allow 'void' as a default template argument.\n+//\t(2) They also doesn't allow you to return 'void' from a function.\n+//\n+// Workaround for (1): Declare a dummy type 'DefaultVoid' which we use\n+//\t when we'd like to use 'void'. We convert it into 'void' and back\n+//\t using the templates DefaultVoidToVoid<> and VoidToDefaultVoid<>.\n+// Workaround for (2): On VC6, the code for calling a void function is\n+//\t identical to the code for calling a non-void function in which the\n+//\t return value is never used, provided the return value is returned\n+//\t in the EAX register, rather than on the stack.\n+//\t This is true for most fundamental types such as int, enum, void *.\n+//\t Const void * is the safest option since it doesn't participate\n+//\t in any automatic conversions. But on a 16-bit compiler it might\n+//\t cause extra code to be generated, so we disable it for all compilers\n+//\t except for VC6 (and VC5).\n+#ifdef FASTDLGT_VC6\n+// VC6 workaround\n+typedef const void * DefaultVoid;\n+#else\n+// On any other compiler, just use a normal void.\n+typedef void DefaultVoid;\n+#endif\n+\n+// Translate from 'DefaultVoid' to 'void'.\n+// Everything else is unchanged\n+template <class T>\n+struct DefaultVoidToVoid { typedef T type; };\n+\n+template <>\n+struct DefaultVoidToVoid<DefaultVoid> { typedef void type; };\n+\n+// Translate from 'void' into 'DefaultVoid'\n+// Everything else is unchanged\n+template <class T>\n+struct VoidToDefaultVoid { typedef T type; };\n+\n+template <>\n+struct VoidToDefaultVoid<void> { typedef DefaultVoid type; };\n+\n+\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tFast Delegates, part 1:\n+//\n+//\t\tConversion of member function pointer to a standard form\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// GenericClass is a fake class, ONLY used to provide a type.\n+// It is vitally important that it is never defined, so that the compiler doesn't\n+// think it can optimize the invocation. For example, Borland generates simpler\n+// code if it knows the class only uses single inheritance.\n+\n+// Compilers using Microsoft's structure need to be treated as a special case.\n+#ifdef\tFASTDLGT_MICROSOFT_MFP\n+\n+#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS\n+\t// For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP\n+\t// (4 bytes), even when the /vmg option is used. Declaring an empty class\n+\t// would give 16 byte pointers in this case....\n+\tclass __single_inheritance GenericClass;\n+#endif\n+\t// ...but for Codeplay, an empty class *always* gives 4 byte pointers.\n+\t// If compiled with the /clr option (\"managed C++\"), the JIT compiler thinks\n+\t// it needs to load GenericClass before it can call any of its functions,\n+\t// (compiles OK but crashes at runtime!), so we need to declare an\n+\t// empty class to make it happy.\n+\t// Codeplay and VC4 can't cope with the unknown_inheritance case either.\n+\tclass GenericClass {};\n+#else\n+\tclass GenericClass;\n+#endif\n+\n+// The size of a single inheritance member function pointer.\n+const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());\n+\n+//\t\t\t\t\t\tSimplifyMemFunc< >::Convert()\n+//\n+//\tA template function that converts an arbitrary member function pointer into the\n+//\tsimplest possible form of member function pointer, using a supplied 'this' pointer.\n+//\tAccording to the standard, this can be done legally with reinterpret_cast<>.\n+//\tFor (non-standard) compilers which use member function pointers which vary in size\n+//\tdepending on the class, we need to use\tknowledge of the internal structure of a\n+//\tmember function pointer, as used by the compiler. Template specialization is used\n+//\tto distinguish between the sizes. Because some compilers don't support partial\n+//\ttemplate specialisation, I use full specialisation of a wrapper struct.\n+\n+// general case -- don't know how to convert it. Force a compile failure\n+template <int N>\n+struct SimplifyMemFunc {\n+\ttemplate <class X, class XFuncType, class GenericMemFuncType>\n+\tinline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,\n+\t\tGenericMemFuncType &bound_func) {\n+\t\t// Unsupported member function type -- force a compile failure.\n+\t\t// (it's illegal to have a array with negative size).\n+\t\ttypedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];\n+\t\treturn 0;\n+\t}\n+};\n+\n+// For compilers where all member func ptrs are the same size, everything goes here.\n+// For non-standard compilers, only single_inheritance classes go here.\n+template <>\n+struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE>\t{\n+\ttemplate <class X, class XFuncType, class GenericMemFuncType>\n+\tinline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,\n+\t\t\tGenericMemFuncType &bound_func) {\n+#if defined __DMC__\n+\t\t// Digital Mars doesn't allow you to cast between abitrary PMF's,\n+\t\t// even though the standard says you can. The 32-bit compiler lets you\n+\t\t// static_cast through an int, but the DOS compiler doesn't.\n+\t\tbound_func = horrible_cast<GenericMemFuncType>(function_to_bind);\n+#else\n+\t\tbound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);\n+#endif\n+\t\treturn reinterpret_cast<GenericClass *>(pthis);\n+\t}\n+};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tFast Delegates, part 1b:\n+//\n+//\t\t\t\t\tWorkarounds for Microsoft and Intel\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+\n+// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),\n+// need to be treated as a special case.\n+#ifdef FASTDLGT_MICROSOFT_MFP\n+\n+// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)\n+// at the start of each function for extra safety, but VC6 seems to ICE\n+// intermittently if you do this inside a template.\n+\n+// __multiple_inheritance classes go here\n+// Nasty hack for Microsoft and Intel (IA32 and Itanium)\n+template<>\n+struct SimplifyMemFunc< SINGLE_MEMFUNCPTR_SIZE + sizeof(int) >\t{\n+\ttemplate <class X, class XFuncType, class GenericMemFuncType>\n+\tinline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,\n+\t\tGenericMemFuncType &bound_func) {\n+\t\t// We need to use a horrible_cast to do this conversion.\n+\t\t// In MSVC, a multiple inheritance member pointer is internally defined as:\n+\t\tunion {\n+\t\t\tXFuncType func;\n+\t\t\tstruct {\n+\t\t\t\tGenericMemFuncType funcaddress; // points to the actual member function\n+\t\t\t\tint delta;\t\t // #BYTES to be added to the 'this' pointer\n+\t\t\t}s;\n+\t\t} u;\n+\t\t// Check that the horrible_cast will work\n+\t\ttypedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)? 1 : -1];\n+\t\tu.func = function_to_bind;\n+\t\tbound_func = u.s.funcaddress;\n+\t\treturn reinterpret_cast<GenericClass *>(reinterpret_cast<char *>(pthis) + u.s.delta);\n+\t}\n+};\n+\n+// virtual inheritance is a real nuisance. It's inefficient and complicated.\n+// On MSVC and Intel, there isn't enough information in the pointer itself to\n+// enable conversion to a closure pointer. Earlier versions of this code didn't\n+// work for all cases, and generated a compile-time error instead.\n+// But a very clever hack invented by John M. Dlugosz solves this problem.\n+// My code is somewhat different to his: I have no asm code, and I make no\n+// assumptions about the calling convention that is used.\n+\n+// In VC++ and ICL, a virtual_inheritance member pointer\n+// is internally defined as:\n+struct MicrosoftVirtualMFP {\n+\tvoid (GenericClass::*codeptr)(); // points to the actual member function\n+\tint delta;\t\t// #bytes to be added to the 'this' pointer\n+\tint vtable_index; // or 0 if no virtual inheritance\n+};\n+// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the\n+// m_codeptr member is *always* called, regardless of the values of the other\n+// members. (This is *not* true for other compilers, eg GCC, which obtain the\n+// function address from the vtable if a virtual function is being called).\n+// Dlugosz's trick is to make the codeptr point to a probe function which\n+// returns the 'this' pointer that was used.\n+\n+// Define a generic class that uses virtual inheritance.\n+// It has a trival member function that returns the value of the 'this' pointer.\n+struct GenericVirtualClass : virtual public GenericClass\n+{\n+\ttypedef GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();\n+\tGenericVirtualClass * GetThis() { return this; }\n+};\n+\n+// __virtual_inheritance classes go here\n+template <>\n+struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2*sizeof(int) >\n+{\n+\n+\ttemplate <class X, class XFuncType, class GenericMemFuncType>\n+\tinline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,\n+\t\tGenericMemFuncType &bound_func) {\n+\t\tunion {\n+\t\t\tXFuncType func;\n+\t\t\tGenericClass* (X::*ProbeFunc)();\n+\t\t\tMicrosoftVirtualMFP s;\n+\t\t} u;\n+\t\tu.func = function_to_bind;\n+\t\tbound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);\n+\t\tunion {\n+\t\t\tGenericVirtualClass::ProbePtrType virtfunc;\n+\t\t\tMicrosoftVirtualMFP s;\n+\t\t} u2;\n+\t\t// Check that the horrible_cast<>s will work\n+\t\ttypedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)\n+\t\t\t&& sizeof(function_to_bind)==sizeof(u.ProbeFunc)\n+\t\t\t&& sizeof(u2.virtfunc)==sizeof(u2.s) ? 1 : -1];\n+   // Unfortunately, taking the address of a MF prevents it from being inlined, so\n+   // this next line can't be completely optimised away by the compiler.\n+\t\tu2.virtfunc = &GenericVirtualClass::GetThis;\n+\t\tu.s.codeptr = u2.s.codeptr;\n+\t\treturn (pthis->*u.ProbeFunc)();\n+\t}\n+};\n+\n+#if (_MSC_VER <1300)\n+\n+// Nasty hack for Microsoft Visual C++ 6.0\n+// unknown_inheritance classes go here\n+// There is a compiler bug in MSVC6 which generates incorrect code in this case!!\n+template <>\n+struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) >\n+{\n+\ttemplate <class X, class XFuncType, class GenericMemFuncType>\n+\tinline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,\n+\t\tGenericMemFuncType &bound_func) {\n+\t\t// There is an apalling but obscure compiler bug in MSVC6 and earlier:\n+\t\t// vtable_index and 'vtordisp' are always set to 0 in the\n+\t\t// unknown_inheritance case!\n+\t\t// This means that an incorrect function could be called!!!\n+\t\t// Compiling with the /vmg option leads to potentially incorrect code.\n+\t\t// This is probably the reason that the IDE has a user interface for specifying\n+\t\t// the /vmg option, but it is disabled -  you can only specify /vmg on\n+\t\t// the command line. In VC1.5 and earlier, the compiler would ICE if it ever\n+\t\t// encountered this situation.\n+\t\t// It is OK to use the /vmg option if /vmm or /vms is specified.\n+\n+\t\t// Fortunately, the wrong function is only called in very obscure cases.\n+\t\t// It only occurs when a derived class overrides a virtual function declared\n+\t\t// in a virtual base class, and the member function\n+\t\t// points to the *Derived* version of that function. The problem can be\n+\t\t// completely averted in 100% of cases by using the *Base class* for the\n+\t\t// member fpointer. Ie, if you use the base class as an interface, you'll\n+\t\t// stay out of trouble.\n+\t\t// Occasionally, you might want to point directly to a derived class function\n+\t\t// that isn't an override of a base class. In this case, both vtable_index\n+\t\t// and 'vtordisp' are zero, but a virtual_inheritance pointer will be generated.\n+\t\t// We can generate correct code in this case. To prevent an incorrect call from\n+\t\t// ever being made, on MSVC6 we generate a warning, and call a function to\n+\t\t// make the program crash instantly.\n+\t\ttypedef char ERROR_VC6CompilerBug[-100];\n+\t\treturn 0;\n+\t}\n+};\n+\n+\n+#else\n+\n+// Nasty hack for Microsoft and Intel (IA32 and Itanium)\n+// unknown_inheritance classes go here\n+// This is probably the ugliest bit of code I've ever written. Look at the casts!\n+// There is a compiler bug in MSVC6 which prevents it from using this code.\n+template <>\n+struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) >\n+{\n+\ttemplate <class X, class XFuncType, class GenericMemFuncType>\n+\tinline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,\n+\t\t\tGenericMemFuncType &bound_func) {\n+\t\t// The member function pointer is 16 bytes long. We can't use a normal cast, but\n+\t\t// we can use a union to do the conversion.\n+\t\tunion {\n+\t\t\tXFuncType func;\n+\t\t\t// In VC++ and ICL, an unknown_inheritance member pointer\n+\t\t\t// is internally defined as:\n+\t\t\tstruct {\n+\t\t\t\tGenericMemFuncType m_funcaddress; // points to the actual member function\n+\t\t\t\tint delta;\t\t// #bytes to be added to the 'this' pointer\n+\t\t\t\tint vtordisp;\t\t// #bytes to add to 'this' to find the vtable\n+\t\t\t\tint vtable_index; // or 0 if no virtual inheritance\n+\t\t\t} s;\n+\t\t} u;\n+\t\t// Check that the horrible_cast will work\n+\t\ttypedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType)==sizeof(u.s)? 1 : -1];\n+\t\tu.func = function_to_bind;\n+\t\tbound_func = u.s.funcaddress;\n+\t\tint virtual_delta = 0;\n+\t\tif (u.s.vtable_index) { // Virtual inheritance is used\n+\t\t\t// First, get to the vtable.\n+\t\t\t// It is 'vtordisp' bytes from the start of the class.\n+\t\t\tconst int * vtable = *reinterpret_cast<const int *const*>(\n+\t\t\t\treinterpret_cast<const char *>(pthis) + u.s.vtordisp );\n+\n+\t\t\t// 'vtable_index' tells us where in the table we should be looking.\n+\t\t\tvirtual_delta = u.s.vtordisp + *reinterpret_cast<const int *>(\n+\t\t\t\treinterpret_cast<const char *>(vtable) + u.s.vtable_index);\n+\t\t}\n+\t\t// The int at 'virtual_delta' gives us the amount to add to 'this'.\n+\t\t// Finally we can add the three components together. Phew!\n+\t\treturn reinterpret_cast<GenericClass *>(\n+\t\t\treinterpret_cast<char *>(pthis) + u.s.delta + virtual_delta);\n+\t};\n+};\n+#endif // MSVC 7 and greater\n+\n+#endif // MS/Intel hacks\n+\n+}  // namespace detail\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tFast Delegates, part 2:\n+//\n+//\tDefine the delegate storage, and cope with static functions\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// DelegateMemento -- an opaque structure which can hold an arbitary delegate.\n+// It knows nothing about the calling convention or number of arguments used by\n+// the function pointed to.\n+// It supplies comparison operators so that it can be stored in STL collections.\n+// It cannot be set to anything other than null, nor invoked directly:\n+//\t it must be converted to a specific delegate.\n+\n+// Implementation:\n+// There are two possible implementations: the Safe method and the Evil method.\n+//\t\t\t\tDelegateMemento - Safe version\n+//\n+// This implementation is standard-compliant, but a bit tricky.\n+// A static function pointer is stored inside the class.\n+// Here are the valid values:\n+// +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+\n+// |   0\t\t\t\t|  0\t   |   0\t\t| Empty\t\t\t |\n+// |   !=0\t\t\t\t|(dontcare)|  Invoker\t| Static function|\n+// |   0\t\t\t\t|  !=0\t   |  !=0*\t\t| Method call\t |\n+// +--------------------+----------+------------+----------------+\n+//\t* For Metrowerks, this can be 0. (first virtual function in a\n+//\t\t single_inheritance class).\n+// When stored stored inside a specific delegate, the 'dontcare' entries are replaced\n+// with a reference to the delegate itself. This complicates the = and == operators\n+// for the delegate class.\n+\n+//\t\t\t\tDelegateMemento - Evil version\n+//\n+// For compilers where data pointers are at least as big as code pointers, it is\n+// possible to store the function pointer in the this pointer, using another\n+// horrible_cast. In this case the DelegateMemento implementation is simple:\n+// +--pThis --+-- pMemFunc-+-- Meaning---------------------+\n+// |\t0\t  |\t 0\t\t   | Empty\t\t\t\t\t\t   |\n+// |  !=0\t  |\t !=0*\t   | Static function or method call|\n+// +----------+------------+-------------------------------+\n+//\t* For Metrowerks, this can be 0. (first virtual function in a\n+//\t\t single_inheritance class).\n+// Note that the Sun C++ and MSVC documentation explicitly state that they\n+// support static_cast between void * and function pointers.\n+\n+class DelegateMemento {\n+protected:\n+\t// the data is protected, not private, because many\n+\t// compilers have problems with template friends.\n+\ttypedef void (detail::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.\n+\tdetail::GenericClass *m_pthis;\n+\tGenericMemFuncType m_pFunction;\n+\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\ttypedef void (*GenericFuncPtr)(); // arbitrary code pointer\n+\tGenericFuncPtr m_pStaticFunction;\n+#endif\n+\n+public:\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\tDelegateMemento() : m_pthis(0), m_pFunction(0), m_pStaticFunction(0) {};\n+\tvoid clear() {\n+\t\tm_pthis=0; m_pFunction=0; m_pStaticFunction=0;\n+\t}\n+#else\n+\tDelegateMemento() : m_pthis(0), m_pFunction(0) {};\n+\tvoid clear() {\tm_pthis=0; m_pFunction=0;\t}\n+#endif\n+public:\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\tinline bool IsEqual (const DelegateMemento &x) const{\n+\t\t// We have to cope with the static function pointers as a special case\n+\t\tif (m_pFunction!=x.m_pFunction) return false;\n+\t\t// the static function ptrs must either both be equal, or both be 0.\n+\t\tif (m_pStaticFunction!=x.m_pStaticFunction) return false;\n+\t\tif (m_pStaticFunction!=0) return m_pthis==x.m_pthis;\n+\t\telse return true;\n+\t}\n+#else // Evil Method\n+\tinline bool IsEqual (const DelegateMemento &x) const{\n+\t\treturn m_pthis==x.m_pthis && m_pFunction==x.m_pFunction;\n+\t}\n+#endif\n+\t// Provide a strict weak ordering for DelegateMementos.\n+\tinline bool IsLess(const DelegateMemento &right) const {\n+\t\t// deal with static function pointers first\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\t\tif (m_pStaticFunction !=0 || right.m_pStaticFunction!=0)\n+\t\t\t\treturn m_pStaticFunction < right.m_pStaticFunction;\n+#endif\n+\t\tif (m_pthis !=right.m_pthis) return m_pthis < right.m_pthis;\n+\t// There are no ordering operators for member function pointers,\n+\t// but we can fake one by comparing each byte. The resulting ordering is\n+\t// arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.\n+\t\treturn memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;\n+\n+\t}\n+\t// BUGFIX (Mar 2005):\n+\t// We can't just compare m_pFunction because on Metrowerks,\n+\t// m_pFunction can be zero even if the delegate is not empty!\n+\tinline bool operator ! () const\t\t// Is it bound to anything?\n+\t{ return m_pthis==0 && m_pFunction==0; }\n+\tinline bool empty() const\t\t// Is it bound to anything?\n+\t{ return m_pthis==0 && m_pFunction==0; }\n+public:\n+\tDelegateMemento & operator = (const DelegateMemento &right)\t {\n+\t\tSetMementoFrom(right);\n+\t\treturn *this;\n+\t}\n+\tinline bool operator <(const DelegateMemento &right) {\n+\t\treturn IsLess(right);\n+\t}\n+\tinline bool operator >(const DelegateMemento &right) {\n+\t\treturn right.IsLess(*this);\n+\t}\n+\tDelegateMemento (const DelegateMemento &right)\t:\n+\t\tm_pthis(right.m_pthis), m_pFunction(right.m_pFunction)\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\t\t, m_pStaticFunction (right.m_pStaticFunction)\n+#endif\n+\t\t{}\n+protected:\n+\tvoid SetMementoFrom(const DelegateMemento &right)  {\n+\t\tm_pFunction = right.m_pFunction;\n+\t\tm_pthis = right.m_pthis;\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\t\tm_pStaticFunction = right.m_pStaticFunction;\n+#endif\n+\t}\n+};\n+\n+\n+//\t\t\t\t\t\tClosurePtr<>\n+//\n+// A private wrapper class that adds function signatures to DelegateMemento.\n+// It's the class that does most of the actual work.\n+// The signatures are specified by:\n+// GenericMemFunc: must be a type of GenericClass member function pointer.\n+// StaticFuncPtr:  must be a type of function pointer with the same signature\n+//\t\t\t\t   as GenericMemFunc.\n+// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6\n+//\t\t\t\t   where it never returns void (returns DefaultVoid instead).\n+\n+// An outer class, delegateN<>, handles the invoking and creates the\n+// necessary typedefs.\n+// This class does everything else.\n+\n+namespace detail {\n+\n+template < class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr>\n+class ClosurePtr : public DelegateMemento {\n+public:\n+\t// These functions are for setting the delegate to a member function.\n+\n+\t// Here's the clever bit: we convert an arbitrary member function into a\n+\t// standard form. XMemFunc should be a member function of class X, but I can't\n+\t// enforce that here. It needs to be enforced by the wrapper class.\n+\ttemplate < class X, class XMemFunc >\n+\tinline void bindmemfunc(X *pthis, XMemFunc function_to_bind ) {\n+\t\tm_pthis = SimplifyMemFunc< sizeof(function_to_bind) >\n+\t\t\t::Convert(pthis, function_to_bind, m_pFunction);\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\t\tm_pStaticFunction = 0;\n+#endif\n+\t}\n+\t// For const member functions, we only need a const class pointer.\n+\t// Since we know that the member function is const, it's safe to\n+\t// remove the const qualifier from the 'this' pointer with a const_cast.\n+\t// VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.\n+\ttemplate < class X, class XMemFunc>\n+\tinline void bindconstmemfunc(const X *pthis, XMemFunc function_to_bind) {\n+\t\tm_pthis= SimplifyMemFunc< sizeof(function_to_bind) >\n+\t\t\t::Convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\t\tm_pStaticFunction = 0;\n+#endif\n+\t}\n+#ifdef FASTDELEGATE_GCC_BUG_8271\t// At present, GCC doesn't recognize constness of MFPs in templates\n+\ttemplate < class X, class XMemFunc>\n+\tinline void bindmemfunc(const X *pthis, XMemFunc function_to_bind) {\n+\t\tbindconstmemfunc(pthis, function_to_bind);\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\t\tm_pStaticFunction = 0;\n+#endif\n+\t}\n+#endif\n+\t// These functions are required for invoking the stored function\n+\tinline GenericClass *GetClosureThis() const { return m_pthis; }\n+\tinline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }\n+\n+// There are a few ways of dealing with static function pointers.\n+// There's a standard-compliant, but tricky method.\n+// There's also a straightforward hack, that won't work on DOS compilers using the\n+// medium memory model. It's so evil that I can't recommend it, but I've\n+// implemented it anyway because it produces very nice asm code.\n+\n+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\n+//\t\t\t\tClosurePtr<> - Safe version\n+//\n+// This implementation is standard-compliant, but a bit tricky.\n+// I store the function pointer inside the class, and the delegate then\n+// points to itself. Whenever the delegate is copied, these self-references\n+// must be transformed, and this complicates the = and == operators.\n+public:\n+\t// The next two functions are for operator ==, =, and the copy constructor.\n+\t// We may need to convert the m_pthis pointers, so that\n+\t// they remain as self-references.\n+\ttemplate< class DerivedClass >\n+\tinline void CopyFrom (DerivedClass *pParent, const DelegateMemento &x) {\n+\t\tSetMementoFrom(x);\n+\t\tif (m_pStaticFunction!=0) {\n+\t\t\t// transform self references...\n+\t\t\tm_pthis=reinterpret_cast<GenericClass *>(pParent);\n+\t\t}\n+\t}\n+\t// For static functions, the 'static_function_invoker' class in the parent\n+\t// will be called. The parent then needs to call GetStaticFunction() to find out\n+\t// the actual function to invoke.\n+\ttemplate < class DerivedClass, class ParentInvokerSig >\n+\tinline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,\n+\t\t\t\tStaticFuncPtr function_to_bind ) {\n+\t\tif (function_to_bind==0) { // cope with assignment to 0\n+\t\t\tm_pFunction=0;\n+\t\t} else {\n+\t\t\tbindmemfunc(pParent, static_function_invoker);\n+\t\t}\n+\t\tm_pStaticFunction=reinterpret_cast<GenericFuncPtr>(function_to_bind);\n+\t}\n+\tinline UnvoidStaticFuncPtr GetStaticFunction() const {\n+\t\treturn reinterpret_cast<UnvoidStaticFuncPtr>(m_pStaticFunction);\n+\t}\n+#else\n+\n+//\t\t\t\tClosurePtr<> - Evil version\n+//\n+// For compilers where data pointers are at least as big as code pointers, it is\n+// possible to store the function pointer in the this pointer, using another\n+// horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and\n+// speeds up comparison and assignment. If C++ provided direct language support\n+// for delegates, they would produce asm code that was almost identical to this.\n+// Note that the Sun C++ and MSVC documentation explicitly state that they\n+// support static_cast between void * and function pointers.\n+\n+\ttemplate< class DerivedClass >\n+\tinline void CopyFrom (DerivedClass *pParent, const DelegateMemento &right) {\n+\t\tSetMementoFrom(right);\n+\t}\n+\t// For static functions, the 'static_function_invoker' class in the parent\n+\t// will be called. The parent then needs to call GetStaticFunction() to find out\n+\t// the actual function to invoke.\n+\t// ******** EVIL, EVIL CODE! *******\n+\ttemplate <\tclass DerivedClass, class ParentInvokerSig>\n+\tinline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,\n+\t\t\t\tStaticFuncPtr function_to_bind) {\n+\t\tif (function_to_bind==0) { // cope with assignment to 0\n+\t\t\tm_pFunction=0;\n+\t\t} else {\n+\t\t   // We'll be ignoring the 'this' pointer, but we need to make sure we pass\n+\t\t   // a valid value to bindmemfunc().\n+\t\t\tbindmemfunc(pParent, static_function_invoker);\n+\t\t}\n+\n+\t\t// WARNING! Evil hack. We store the function in the 'this' pointer!\n+\t\t// Ensure that there's a compilation failure if function pointers\n+\t\t// and data pointers have different sizes.\n+\t\t// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.\n+\t\ttypedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];\n+\t\tm_pthis = horrible_cast<GenericClass *>(function_to_bind);\n+\t\t// MSVC, SunC++ and DMC accept the following (non-standard) code:\n+//\t\tm_pthis = static_cast<GenericClass *>(static_cast<void *>(function_to_bind));\n+\t\t// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long\n+//\t\tm_pthis = reinterpret_cast<GenericClass *>(reinterpret_cast<long>(function_to_bind));\n+\t}\n+\t// ******** EVIL, EVIL CODE! *******\n+\t// This function will be called with an invalid 'this' pointer!!\n+\t// We're just returning the 'this' pointer, converted into\n+\t// a function pointer!\n+\tinline UnvoidStaticFuncPtr GetStaticFunction() const {\n+\t\t// Ensure that there's a compilation failure if function pointers\n+\t\t// and data pointers have different sizes.\n+\t\t// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.\n+\t\ttypedef int ERROR_CantUseEvilMethod[sizeof(UnvoidStaticFuncPtr)==sizeof(this) ? 1 : -1];\n+\t\treturn horrible_cast<UnvoidStaticFuncPtr>(this);\n+\t}\n+#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)\n+\n+\t// Does the closure contain this static function?\n+\tinline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr){\n+\t\tif (funcptr==0) return empty();\n+\t// For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary\n+\t// value that is not equal to any valid function pointer.\n+\t\telse return funcptr==reinterpret_cast<StaticFuncPtr>(GetStaticFunction());\n+\t}\n+};\n+\n+\n+} // namespace detail\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tFast Delegates, part 3:\n+//\n+//\t\t\t\tWrapper classes to ensure type safety\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+\n+// Once we have the member function conversion templates, it's easy to make the\n+// wrapper classes. So that they will work with as many compilers as possible,\n+// the classes are of the form\n+//\t Delegate3<int, char *, double>\n+// They can cope with any combination of parameters. The max number of parameters\n+// allowed is 8, but it is trivial to increase this limit.\n+// Note that we need to treat const member functions seperately.\n+// All this class does is to enforce type safety, and invoke the delegate with\n+// the correct list of parameters.\n+\n+// Because of the weird rule about the class of derived member function pointers,\n+// you sometimes need to apply a downcast to the 'this' pointer.\n+// This is the reason for the use of \"implicit_cast<X*>(pthis)\" in the code below.\n+// If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,\n+// without this trick you'd need to write:\n+//\t\tMyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);\n+// but with the trick you can write\n+//\t\tMyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);\n+\n+// RetType is the type the compiler uses in compiling the template. For VC6,\n+// it cannot be void. DesiredRetType is the real type which is returned from\n+// all of the functions. It can be void.\n+\n+// Implicit conversion to \"bool\" is achieved using the safe_bool idiom,\n+// using member data pointers (MDP). This allows \"if (dg)...\" syntax\n+// Because some compilers (eg codeplay) don't have a unique value for a zero\n+// MDP, an extra padding member is added to the SafeBool struct.\n+// Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so\n+// in that case the static function constructor is not made explicit; this\n+// allows \"if (dg==0) ...\" to compile.\n+\n+//N=0\n+template<class RetType=detail::DefaultVoid>\n+class Delegate0 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)();\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)();\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)();\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate0 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate0() { clear(); }\n+\tDelegate0(const Delegate0 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate0 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate0 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate0 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate0 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate0 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate0(Y *pthis, DesiredRetType (X::* function_to_bind)() ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)()) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate0(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate0(DesiredRetType (*function_to_bind)() ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)() ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)()) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate0::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() () const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction() const {\n+\treturn (*(m_Closure.GetStaticFunction()))(); }\n+};\n+\n+//N=1\n+template<class Param1, class RetType=detail::DefaultVoid>\n+class Delegate1 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate1 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate1() { clear(); }\n+\tDelegate1(const Delegate1 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate1 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate1 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate1 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate1 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate1 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate1(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate1(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate1(DesiredRetType (*function_to_bind)(Param1 p1) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate1::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1); }\n+};\n+\n+//N=2\n+template<class Param1, class Param2, class RetType=detail::DefaultVoid>\n+class Delegate2 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate2 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate2() { clear(); }\n+\tDelegate2(const Delegate2 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate2 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate2 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate2 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate2 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate2 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate2(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate2(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate2(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate2::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2); }\n+};\n+\n+//N=3\n+template<class Param1, class Param2, class Param3, class RetType=detail::DefaultVoid>\n+class Delegate3 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate3 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate3() { clear(); }\n+\tDelegate3(const Delegate3 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate3 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate3 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate3 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate3 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate3 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate3(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate3(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate3(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate3::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2, Param3 p3) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2, p3); }\n+};\n+\n+//N=4\n+template<class Param1, class Param2, class Param3, class Param4, class RetType=detail::DefaultVoid>\n+class Delegate4 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate4 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate4() { clear(); }\n+\tDelegate4(const Delegate4 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate4 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate4 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate4 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate4 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate4 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate4(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate4(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate4(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate4::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4); }\n+};\n+\n+//N=5\n+template<class Param1, class Param2, class Param3, class Param4, class Param5, class RetType=detail::DefaultVoid>\n+class Delegate5 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate5 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate5() { clear(); }\n+\tDelegate5(const Delegate5 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate5 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate5 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate5 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate5 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate5 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate5(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate5(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate5(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate5::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5); }\n+};\n+\n+//N=6\n+template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType=detail::DefaultVoid>\n+class Delegate6 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate6 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate6() { clear(); }\n+\tDelegate6(const Delegate6 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate6 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate6 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate6 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate6 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate6 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate6(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate6(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate6(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate6::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6); }\n+};\n+\n+//N=7\n+template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType=detail::DefaultVoid>\n+class Delegate7 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate7 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate7() { clear(); }\n+\tDelegate7(const Delegate7 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate7 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate7 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate7 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate7 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate7 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate7(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate7(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate7(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate7::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7); }\n+};\n+\n+//N=8\n+template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType=detail::DefaultVoid>\n+class Delegate8 {\n+private:\n+\ttypedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;\n+\ttypedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);\n+\ttypedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);\n+\ttypedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);\n+\ttypedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;\n+\tClosureType m_Closure;\n+public:\n+\t// Typedefs to aid generic programming\n+\ttypedef Delegate8 type;\n+\n+\t// Construction and comparison functions\n+\tDelegate8() { clear(); }\n+\tDelegate8(const Delegate8 &x) {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tvoid operator = (const Delegate8 &x)  {\n+\t\tm_Closure.CopyFrom(this, x.m_Closure); }\n+\tbool operator ==(const Delegate8 &x) const {\n+\t\treturn m_Closure.IsEqual(x.m_Closure);\t}\n+\tbool operator !=(const Delegate8 &x) const {\n+\t\treturn !m_Closure.IsEqual(x.m_Closure); }\n+\tbool operator <(const Delegate8 &x) const {\n+\t\treturn m_Closure.IsLess(x.m_Closure);\t}\n+\tbool operator >(const Delegate8 &x) const {\n+\t\treturn x.m_Closure.IsLess(m_Closure);\t}\n+\t// Binding to non-const member functions\n+\ttemplate < class X, class Y >\n+\tDelegate8(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }\n+\ttemplate < class X, class Y >\n+\tinline void Bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {\n+\t\tm_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);\t}\n+\t// Binding to const member functions.\n+\ttemplate < class X, class Y >\n+\tDelegate8(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);\t}\n+\ttemplate < class X, class Y >\n+\tinline void Bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {\n+\t\tm_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);\t}\n+\t// Static functions. We convert them into a member function call.\n+\t// This constructor also provides implicit conversion\n+\tDelegate8(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {\n+\t\tBind(function_to_bind); }\n+\t// for efficiency, prevent creation of a temporary\n+\tvoid operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {\n+\t\tBind(function_to_bind); }\n+\tinline void Bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {\n+\t\tm_Closure.bindstaticfunc(this, &Delegate8::InvokeStaticFunction,\n+\t\t\tfunction_to_bind); }\n+\t// Invoke the delegate\n+\tRetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {\n+\treturn (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8); }\n+\t// Implicit conversion to \"bool\" using the safe_bool idiom\n+private:\n+\ttypedef struct SafeBoolStruct {\n+\t\tint a_data_pointer_to_this_is_0_on_buggy_compilers;\n+\t\tStaticFunctionPtr m_nonzero;\n+\t} UselessTypedef;\n+\ttypedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;\n+public:\n+\toperator unspecified_bool_type() const {\n+\t\treturn empty()? 0: &SafeBoolStruct::m_nonzero;\n+\t}\n+\t// necessary to allow ==0 to work despite the safe_bool idiom\n+\tinline bool operator==(StaticFunctionPtr funcptr) {\n+\t\treturn m_Closure.IsEqualToStaticFuncPtr(funcptr);\t}\n+\tinline bool operator!=(StaticFunctionPtr funcptr) {\n+\t\treturn !m_Closure.IsEqualToStaticFuncPtr(funcptr);\t  }\n+\tinline bool operator ! () const {\t// Is it bound to anything?\n+\t\t\treturn !m_Closure; }\n+\tinline bool empty() const\t{\n+\t\t\treturn !m_Closure; }\n+\tvoid clear() { m_Closure.clear();}\n+\t// Conversion to and from the DelegateMemento storage class\n+\tconst DelegateMemento & GetMemento() { return m_Closure; }\n+\tvoid SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }\n+\n+private:\t// Invoker for static functions\n+\tRetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {\n+\treturn (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8); }\n+};\n+\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tFast Delegates, part 4:\n+//\n+//\t\t\t\tdelegate<> class (Original author: Jody Hagins)\n+//\tAllows boost::function style syntax like:\n+//\t\t\tdelegate< double (int, long) >\n+// instead of:\n+//\t\t\tDelegate2< int, long, double >\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#ifdef R\n+\t// Apparently we have a macro somewhere that is causing a compiler error\n+\t#undef R\n+#endif\n+\n+#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX\n+\n+// Declare delegate as a class template.  It will be specialized\n+// later for all number of arguments.\n+template <typename Signature>\n+class Delegate;\n+\n+//N=0\n+// Specialization to allow use of\n+// delegate< R (  ) >\n+// instead of\n+// Delegate0 < R >\n+template<typename R>\n+class Delegate< R (\t ) >\n+  // Inherit from Delegate0 so that it can be treated just like a Delegate0\n+  : public Delegate0 < R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate0 < R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)(\t))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)(  ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)(  ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=1\n+// Specialization to allow use of\n+// delegate< R ( Param1 ) >\n+// instead of\n+// Delegate1 < Param1, R >\n+template<typename R, class Param1>\n+class Delegate< R ( Param1 ) >\n+  // Inherit from Delegate1 so that it can be treated just like a Delegate1\n+  : public Delegate1 < Param1, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate1 < Param1, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=2\n+// Specialization to allow use of\n+// delegate< R ( Param1, Param2 ) >\n+// instead of\n+// Delegate2 < Param1, Param2, R >\n+template<typename R, class Param1, class Param2>\n+class Delegate< R ( Param1, Param2 ) >\n+  // Inherit from Delegate2 so that it can be treated just like a Delegate2\n+  : public Delegate2 < Param1, Param2, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate2 < Param1, Param2, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=3\n+// Specialization to allow use of\n+// delegate< R ( Param1, Param2, Param3 ) >\n+// instead of\n+// Delegate3 < Param1, Param2, Param3, R >\n+template<typename R, class Param1, class Param2, class Param3>\n+class Delegate< R ( Param1, Param2, Param3 ) >\n+  // Inherit from Delegate3 so that it can be treated just like a Delegate3\n+  : public Delegate3 < Param1, Param2, Param3, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate3 < Param1, Param2, Param3, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=4\n+// Specialization to allow use of\n+// delegate< R ( Param1, Param2, Param3, Param4 ) >\n+// instead of\n+// Delegate4 < Param1, Param2, Param3, Param4, R >\n+template<typename R, class Param1, class Param2, class Param3, class Param4>\n+class Delegate< R ( Param1, Param2, Param3, Param4 ) >\n+  // Inherit from Delegate4 so that it can be treated just like a Delegate4\n+  : public Delegate4 < Param1, Param2, Param3, Param4, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate4 < Param1, Param2, Param3, Param4, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=5\n+// Specialization to allow use of\n+// delegate< R ( Param1, Param2, Param3, Param4, Param5 ) >\n+// instead of\n+// Delegate5 < Param1, Param2, Param3, Param4, Param5, R >\n+template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5>\n+class Delegate< R ( Param1, Param2, Param3, Param4, Param5 ) >\n+  // Inherit from Delegate5 so that it can be treated just like a Delegate5\n+  : public Delegate5 < Param1, Param2, Param3, Param4, Param5, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate5 < Param1, Param2, Param3, Param4, Param5, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=6\n+// Specialization to allow use of\n+// delegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >\n+// instead of\n+// Delegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >\n+template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>\n+class Delegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >\n+  // Inherit from Delegate6 so that it can be treated just like a Delegate6\n+  : public Delegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=7\n+// Specialization to allow use of\n+// delegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >\n+// instead of\n+// Delegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >\n+template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>\n+class Delegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >\n+  // Inherit from Delegate7 so that it can be treated just like a Delegate7\n+  : public Delegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+//N=8\n+// Specialization to allow use of\n+// Delegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >\n+// instead of\n+// Delegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >\n+template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>\n+class Delegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >\n+  // Inherit from Delegate8 so that it can be treated just like a Delegate8\n+  : public Delegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >\n+{\n+public:\n+  // Make using the base type a bit easier via typedef.\n+  typedef Delegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R > BaseType;\n+\n+  // Allow users access to the specific type of this delegate.\n+  typedef Delegate SelfType;\n+\n+  // Mimic the base class constructors.\n+  Delegate() : BaseType() { }\n+\n+  template < class X, class Y >\n+  Delegate(Y * pthis,\n+\tR (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))\n+\t: BaseType(pthis, function_to_bind)\t { }\n+\n+  template < class X, class Y >\n+  Delegate(const Y *pthis,\n+\t  R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const)\n+\t: BaseType(pthis, function_to_bind)\n+  {\t }\n+\n+  Delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))\n+\t: BaseType(function_to_bind)  { }\n+  void operator = (const BaseType &x)  {\n+\t\t*static_cast<BaseType*>(this) = x; }\n+};\n+\n+\n+#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX\n+\n+////////////////////////////////////////////////////////////////////////////////\n+//\t\t\t\t\t\tFast Delegates, part 5:\n+//\n+//\t\t\t\tMakeDelegate() helper function\n+//\n+//\t\t\tMakeDelegate(&x, &X::func) returns a fastdelegate of the type\n+//\t\t\tnecessary for calling x.func() with the correct number of arguments.\n+//\t\t\tThis makes it possible to eliminate many typedefs from user code.\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// Also declare overloads of a MakeDelegate() global function to\n+// reduce the need for typedefs.\n+// We need seperate overloads for const and non-const member functions.\n+// Also, because of the weird rule about the class of derived member function pointers,\n+// implicit downcasts may need to be applied later to the 'this' pointer.\n+// That's why two classes (X and Y) appear in the definitions. Y must be implicitly\n+// castable to X.\n+\n+// Workaround for VC6. VC6 needs void return types converted into DefaultVoid.\n+// GCC 3.2 and later won't compile this unless it's preceded by 'typename',\n+// but VC6 doesn't allow 'typename' in this context.\n+// So, I have to use a macro.\n+\n+#ifdef FASTDLGT_VC6\n+#define FASTDLGT_RETTYPE detail::VoidToDefaultVoid<RetType>::type\n+#else\n+#define FASTDLGT_RETTYPE RetType\n+#endif\n+\n+//N=0\n+template <class X, class Y, class RetType>\n+Delegate0<FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)()) {\n+\treturn Delegate0<FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class RetType>\n+Delegate0<FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)() const) {\n+\treturn Delegate0<FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=1\n+template <class X, class Y, class Param1, class RetType>\n+Delegate1<Param1, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1)) {\n+\treturn Delegate1<Param1, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class RetType>\n+Delegate1<Param1, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1) const) {\n+\treturn Delegate1<Param1, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=2\n+template <class X, class Y, class Param1, class Param2, class RetType>\n+Delegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) {\n+\treturn Delegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class RetType>\n+Delegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2) const) {\n+\treturn Delegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=3\n+template <class X, class Y, class Param1, class Param2, class Param3, class RetType>\n+Delegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3)) {\n+\treturn Delegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class Param3, class RetType>\n+Delegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3) const) {\n+\treturn Delegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=4\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>\n+Delegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {\n+\treturn Delegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>\n+Delegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {\n+\treturn Delegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=5\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>\n+Delegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {\n+\treturn Delegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>\n+Delegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {\n+\treturn Delegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=6\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>\n+Delegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {\n+\treturn Delegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>\n+Delegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {\n+\treturn Delegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=7\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>\n+Delegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {\n+\treturn Delegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>\n+Delegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {\n+\treturn Delegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+//N=8\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>\n+Delegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {\n+\treturn Delegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>\n+Delegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {\n+\treturn Delegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE>(x, func);\n+}\n+\n+\n+ // clean up after ourselves...\n+#undef FASTDLGT_RETTYPE\n+\n+} // namespace\n+\n+#endif //_DELEGATES_H_\n+\n+"
      },
      {
        "sha": "470e06a6afd345a64a13f441bbd7f53c280b7d6b",
        "filename": "src/utilsignal.h",
        "status": "added",
        "additions": 659,
        "deletions": 0,
        "changes": 659,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/utilsignal.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/utilsignal.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilsignal.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -0,0 +1,659 @@\n+/*\n+ *  Signal.h\n+ *  A lightweight signals and slots implementation using fast delegates\n+ *\n+ *  Created by Patrick Hogan on 5/18/09.\n+ *\n+ */\n+\n+#ifndef _Signal_H_\n+#define _Signal_H_\n+\n+#include \"utildelegate.h\"\n+#include <set>\n+\n+namespace Gallant {\n+\n+template< class Param0 = void >\n+class Signal0\n+{\n+public:\n+\ttypedef Delegate0< void > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)() )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)() const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)() )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)() const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit() const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))();\n+\t\t}\n+\t}\n+\n+\tvoid operator() () const\n+\t{\n+\t\tEmit();\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1 >\n+class Signal1\n+{\n+public:\n+\ttypedef Delegate1< Param1 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1 ) const\n+\t{\n+\t\tEmit( p1 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2 >\n+class Signal2\n+{\n+public:\n+\ttypedef Delegate2< Param1, Param2 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2 ) const\n+\t{\n+\t\tEmit( p1, p2 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2, class Param3 >\n+class Signal3\n+{\n+public:\n+\ttypedef Delegate3< Param1, Param2, Param3 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2, Param3 p3 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2, p3 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2, Param3 p3 ) const\n+\t{\n+\t\tEmit( p1, p2, p3 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2, class Param3, class Param4 >\n+class Signal4\n+{\n+public:\n+\ttypedef Delegate4< Param1, Param2, Param3, Param4 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2, p3, p4 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const\n+\t{\n+\t\tEmit( p1, p2, p3, p4 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2, class Param3, class Param4, class Param5 >\n+class Signal5\n+{\n+public:\n+\ttypedef Delegate5< Param1, Param2, Param3, Param4, Param5 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2, p3, p4, p5 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const\n+\t{\n+\t\tEmit( p1, p2, p3, p4, p5 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2, class Param3, class Param4, class Param5, class Param6 >\n+class Signal6\n+{\n+public:\n+\ttypedef Delegate6< Param1, Param2, Param3, Param4, Param5, Param6 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2, p3, p4, p5, p6 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const\n+\t{\n+\t\tEmit( p1, p2, p3, p4, p5, p6 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7 >\n+class Signal7\n+{\n+public:\n+\ttypedef Delegate7< Param1, Param2, Param3, Param4, Param5, Param6, Param7 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2, p3, p4, p5, p6, p7 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const\n+\t{\n+\t\tEmit( p1, p2, p3, p4, p5, p6, p7 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+template< class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8 >\n+class Signal8\n+{\n+public:\n+\ttypedef Delegate8< Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 > _Delegate;\n+\n+private:\n+\ttypedef std::set<_Delegate> DelegateList;\n+\ttypedef typename DelegateList::const_iterator DelegateIterator;\n+\tDelegateList delegateList;\n+\n+public:\n+\tvoid Connect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.insert( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Connect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const )\n+\t{\n+\t\tdelegateList.insert( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Disconnect( _Delegate delegate )\n+\t{\n+\t\tdelegateList.erase( delegate );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\ttemplate< class X, class Y >\n+\tvoid Disconnect( Y * obj, void (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const )\n+\t{\n+\t\tdelegateList.erase( MakeDelegate( obj, func ) );\n+\t}\n+\n+\tvoid Clear()\n+\t{\n+\t\tdelegateList.clear();\n+\t}\n+\n+\tvoid Emit( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const\n+\t{\n+\t\tfor (DelegateIterator i = delegateList.begin(); i != delegateList.end(); )\n+\t\t{\n+\t\t\t(*(i++))( p1, p2, p3, p4, p5, p6, p7, p8 );\n+\t\t}\n+\t}\n+\n+\tvoid operator() ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const\n+\t{\n+\t\tEmit( p1, p2, p3, p4, p5, p6, p7, p8 );\n+\t}\n+\n+\tbool Empty() const\n+\t{\n+        return delegateList.empty();\n+    }\n+};\n+\n+\n+} // namespace\n+\n+#endif //_SIGNAL_H_\n+"
      },
      {
        "sha": "02c649b8956e0c2bc8e75e468ea73c67698a728b",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39415a4213653d374b508081ec5e59492f9def0c/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39415a4213653d374b508081ec5e59492f9def0c/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=39415a4213653d374b508081ec5e59492f9def0c",
        "patch": "@@ -414,23 +414,22 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * Address book entry changed.\n      * @note called with lock cs_wallet held.\n      */\n-    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n-            &address, const std::string &label, bool isMine,\n-            const std::string &purpose,\n-            ChangeType status)> NotifyAddressBookChanged;\n+\tGallant::Signal6<CWallet * /* wallet */, const CTxDestination & /* address */,\n+\t\t\tconst std::string & /* label */, bool /* isMine */, const std::string & /* purpose */,\n+\t\t\tChangeType /* status */> NotifyAddressBookChanged;\n \n     /** \n      * Wallet transaction added, removed or updated.\n      * @note called with lock cs_wallet held.\n      */\n-    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n-            ChangeType status)> NotifyTransactionChanged;\n+\tGallant::Signal3<CWallet * /* wallet */, const uint256 & /* hashTx */,\n+\t\t\tChangeType /* status */> NotifyTransactionChanged;\n \n     /** Show progress e.g. for rescan */\n-    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n+    Gallant::Signal2<const std::string & /* title */, int /* nProgress */> ShowProgress;\n \n     /** Watch-only address added */\n-    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n+\tGallant::Signal1<bool /* fHaveWatchOnly */> NotifyWatchonlyChanged;\n };\n \n /** A key allocated from the key pool. */"
      }
    ]
  }
]