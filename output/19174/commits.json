[
  {
    "sha": "0c8461a88ed66a1f70559fc96646708949b17e4b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzg0NjFhODhlZDY2YTFmNzA1NTlmYzk2NjQ2NzA4OTQ5YjE3ZTRi",
    "commit": {
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2020-06-04T22:55:12Z"
      },
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2020-07-14T14:00:24Z"
      },
      "message": "refactor: replace CConnman pointers by references in net_processing.cpp",
      "tree": {
        "sha": "0692fa56e1109a409560673a9c571ccabc9cb6dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0692fa56e1109a409560673a9c571ccabc9cb6dd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c8461a88ed66a1f70559fc96646708949b17e4b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c8461a88ed66a1f70559fc96646708949b17e4b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c8461a88ed66a1f70559fc96646708949b17e4b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c8461a88ed66a1f70559fc96646708949b17e4b/comments",
    "author": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following{/other_user}",
      "gists_url": "https://api.github.com/users/theStack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theStack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a655e89cb4dbdf6c9b47626aff2f06fa4fa4dee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a655e89cb4dbdf6c9b47626aff2f06fa4fa4dee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a655e89cb4dbdf6c9b47626aff2f06fa4fa4dee"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 64,
      "deletions": 64
    },
    "files": [
      {
        "sha": "8a292eb5858b0f4303a4d597c6148ac68238c5e1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 62,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c8461a88ed66a1f70559fc96646708949b17e4b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c8461a88ed66a1f70559fc96646708949b17e4b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0c8461a88ed66a1f70559fc96646708949b17e4b",
        "patch": "@@ -463,7 +463,7 @@ static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUS\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-static void PushNodeVersion(CNode& pnode, CConnman* connman, int64_t nTime)\n+static void PushNodeVersion(CNode& pnode, CConnman& connman, int64_t nTime)\n {\n     // Note that pnode->GetLocalServices() is a reflection of the local\n     // services we were offering when the CNode object was created for this\n@@ -477,7 +477,7 @@ static void PushNodeVersion(CNode& pnode, CConnman* connman, int64_t nTime)\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n-    connman->PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+    connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n             nonce, strSubVersion, nNodeStartingHeight, ::g_relay_txes && pnode.m_tx_relay != nullptr));\n \n     if (fLogIPs) {\n@@ -588,7 +588,7 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n  * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n  * removing the first element if necessary.\n  */\n-static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n@@ -604,20 +604,20 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connma\n                 return;\n             }\n         }\n-        connman->ForNode(nodeid, [connman](CNode* pfrom){\n+        connman.ForNode(nodeid, [&connman](CNode* pfrom){\n             AssertLockHeld(cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n-                connman->ForNode(lNodesAnnouncingHeaderAndIDs.front(), [connman, nCMPCTBLOCKVersion](CNode* pnodeStop){\n+                connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, nCMPCTBLOCKVersion](CNode* pnodeStop){\n                     AssertLockHeld(cs_main);\n-                    connman->PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));\n+                    connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));\n                     return true;\n                 });\n                 lNodesAnnouncingHeaderAndIDs.pop_front();\n             }\n-            connman->PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/true, nCMPCTBLOCKVersion));\n+            connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/true, nCMPCTBLOCKVersion));\n             lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n             return true;\n         });\n@@ -825,7 +825,7 @@ void PeerLogicValidation::InitializeNode(CNode *pnode) {\n         mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->fInbound, pnode->m_manual_connection));\n     }\n     if(!pnode->fInbound)\n-        PushNodeVersion(*pnode, connman, GetTime());\n+        PushNodeVersion(*pnode, *connman, GetTime());\n }\n \n void PeerLogicValidation::ReattemptInitialBroadcast(CScheduler& scheduler) const\n@@ -1378,7 +1378,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const BlockValidatio\n              !::ChainstateActive().IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n-            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);\n+            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, *connman);\n         }\n     }\n     if (it != mapBlockSource.end())\n@@ -1474,7 +1474,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, const CConnman&\n     connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, const CInv& inv, CConnman* connman)\n+void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n {\n     bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n@@ -1522,7 +1522,7 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n     const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     if (send &&\n-        connman->OutboundTargetReached(true) &&\n+        connman.OutboundTargetReached(true) &&\n         (((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) &&\n         !pfrom.HasPermission(PF_DOWNLOAD) // nodes with the download permission may exceed target\n     ) {\n@@ -1556,7 +1556,7 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n             if (!ReadRawBlockFromDisk(block_data, pindex, chainparams.MessageStart())) {\n                 assert(!\"cannot load block from disk\");\n             }\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n             // Don't set pblock as we've sent the block\n         } else {\n             // Send block from disk\n@@ -1567,9 +1567,9 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n         }\n         if (pblock) {\n             if (inv.type == MSG_BLOCK)\n-                connman->PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+                connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n             else if (inv.type == MSG_WITNESS_BLOCK)\n-                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n             else if (inv.type == MSG_FILTERED_BLOCK)\n             {\n                 bool sendMerkleBlock = false;\n@@ -1582,7 +1582,7 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n                     }\n                 }\n                 if (sendMerkleBlock) {\n-                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n                     // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                     // This avoids hurting performance by pointlessly requiring a round-trip\n                     // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -1591,7 +1591,7 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n                     // however we MUST always provide at least what the remote peer needs\n                     typedef std::pair<unsigned int, uint256> PairType;\n                     for (PairType& pair : merkleBlock.vMatchedTxn)\n-                        connman->PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+                        connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                 }\n                 // else\n                     // no response\n@@ -1606,13 +1606,13 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n                 int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                 if (CanDirectFetch(consensusParams) && pindex->nHeight >= ::ChainActive().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                     if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n-                        connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                        connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                     } else {\n                         CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                        connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                 } else {\n-                    connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                    connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n                 }\n             }\n         }\n@@ -1625,7 +1625,7 @@ void static ProcessGetBlockData(CNode& pfrom, const CChainParams& chainparams, c\n             // wait for other stuff first.\n             std::vector<CInv> vInv;\n             vInv.push_back(CInv(MSG_BLOCK, ::ChainActive().Tip()->GetBlockHash()));\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n             pfrom.hashContinue.SetNull();\n         }\n     }\n@@ -1660,7 +1660,7 @@ CTransactionRef static FindTxForGetData(const CNode& peer, const uint256& txid,\n     return {};\n }\n \n-void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnman* connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n+void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n {\n     AssertLockNotHeld(cs_main);\n \n@@ -1692,7 +1692,7 @@ void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnm\n         CTransactionRef tx = FindTxForGetData(pfrom, inv.hash, mempool_req, now);\n         if (tx) {\n             int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n-            connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n+            connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n             mempool.RemoveUnbroadcastTx(inv.hash);\n             // As we're going to send tx, make sure its unconfirmed parents are made requestable.\n             for (const auto& txin : tx->vin) {\n@@ -1738,7 +1738,7 @@ void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnm\n         // In normal operation, we often send NOTFOUND messages for parents of\n         // transactions that we relay; if a peer is missing a parent, they may\n         // assume we have them and request the parents from us.\n-        connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n+        connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n     }\n }\n \n@@ -1750,7 +1750,7 @@ static uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_ma\n     return nFetchFlags;\n }\n \n-inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode& pfrom, CConnman* connman) {\n+inline void static SendBlockTransactions(const CBlock& block, const BlockTransactionsRequest& req, CNode& pfrom, CConnman& connman) {\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n@@ -1763,10 +1763,10 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     LOCK(cs_main);\n     const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n     int nSendFlags = State(pfrom.GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-    connman->PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n+    connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateManager& chainman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+static void ProcessHeadersMessage(CNode& pfrom, CConnman& connman, ChainstateManager& chainman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n {\n     const CNetMsgMaker msgMaker(pfrom.GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1792,7 +1792,7 @@ static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -1857,7 +1857,7 @@ static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n             // TODO: optimize: if pindexLast is an ancestor of ::ChainActive().Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom.GetId(), pfrom.nStartingHeight);\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -1907,7 +1907,7 @@ static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n-                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                 }\n             }\n         }\n@@ -1948,7 +1948,7 @@ static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\n     return;\n }\n \n-void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+void static ProcessOrphanTx(CConnman& connman, CTxMemPool& mempool, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(g_cs_orphans);\n@@ -1972,7 +1972,7 @@ void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uin\n         if (setMisbehaving.count(fromPeer)) continue;\n         if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-            RelayTransaction(orphanHash, *connman);\n+            RelayTransaction(orphanHash, connman);\n             for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(orphanHash, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n@@ -2233,7 +2233,7 @@ void ProcessMessage(\n     const CChainParams& chainparams,\n     ChainstateManager& chainman,\n     CTxMemPool& mempool,\n-    CConnman* connman,\n+    CConnman& connman,\n     BanMan* banman,\n     const std::atomic<bool>& interruptMsgProc)\n {\n@@ -2271,7 +2271,7 @@ void ProcessMessage(\n         nServices = ServiceFlags(nServiceInt);\n         if (!pfrom.fInbound)\n         {\n-            connman->SetServices(pfrom.addr, nServices);\n+            connman.SetServices(pfrom.addr, nServices);\n         }\n         if (!pfrom.fInbound && !pfrom.fFeeler && !pfrom.m_manual_connection && !HasAllDesirableServiceFlags(nServices))\n         {\n@@ -2300,7 +2300,7 @@ void ProcessMessage(\n         if (!vRecv.empty())\n             vRecv >> fRelay;\n         // Disconnect if we connected to ourself\n-        if (pfrom.fInbound && !connman->CheckIncomingNonce(nNonce))\n+        if (pfrom.fInbound && !connman.CheckIncomingNonce(nNonce))\n         {\n             LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom.addr.ToString());\n             pfrom.fDisconnect = true;\n@@ -2316,7 +2316,7 @@ void ProcessMessage(\n         if (pfrom.fInbound)\n             PushNodeVersion(pfrom, connman, GetAdjustedTime());\n \n-        connman->PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+        connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n         pfrom.nServices = nServices;\n         pfrom.SetAddrLocal(addrMe);\n@@ -2372,9 +2372,9 @@ void ProcessMessage(\n             }\n \n             // Get recent addresses\n-            connman->PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n+            connman.PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n             pfrom.fGetAddr = true;\n-            connman->MarkAddressGood(pfrom.addr);\n+            connman.MarkAddressGood(pfrom.addr);\n         }\n \n         std::string remoteAddr;\n@@ -2393,7 +2393,7 @@ void ProcessMessage(\n         // If the peer is old enough to have the old alert system, send it the final alert.\n         if (pfrom.nVersion <= 70012) {\n             CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);\n-            connman->PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n+            connman.PushMessage(&pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));\n         }\n \n         // Feeler connections exist only to verify if address is online.\n@@ -2433,7 +2433,7 @@ void ProcessMessage(\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n         if (pfrom.nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n@@ -2444,9 +2444,9 @@ void ProcessMessage(\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n             if (pfrom.GetLocalServices() & NODE_WITNESS)\n-                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom.fSuccessfullyConnected = true;\n         return;\n@@ -2499,13 +2499,13 @@ void ProcessMessage(\n             if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n-                RelayAddress(addr, fReachable, *connman);\n+                RelayAddress(addr, fReachable, connman);\n             }\n             // Do not store addresses outside our network\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n-        connman->AddNewAddresses(vAddrOk, pfrom.addr, 2 * 60 * 60);\n+        connman.AddNewAddresses(vAddrOk, pfrom.addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000)\n             pfrom.fGetAddr = false;\n         if (pfrom.fOneShot)\n@@ -2602,7 +2602,7 @@ void ProcessMessage(\n         }\n \n         if (best_block != nullptr) {\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\n             LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\n         }\n \n@@ -2810,7 +2810,7 @@ void ProcessMessage(\n         // will re-announce the new block via headers (or compact blocks again)\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : ::ChainActive().Tip();\n-        connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+        connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n         return;\n     }\n \n@@ -2846,7 +2846,7 @@ void ProcessMessage(\n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n-            RelayTransaction(tx.GetHash(), *connman);\n+            RelayTransaction(tx.GetHash(), connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));\n                 if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n@@ -2921,7 +2921,7 @@ void ProcessMessage(\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n-                    RelayTransaction(tx.GetHash(), *connman);\n+                    RelayTransaction(tx.GetHash(), connman);\n                 }\n             }\n         }\n@@ -2975,7 +2975,7 @@ void ProcessMessage(\n         if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!::ChainstateActive().IsInitialBlockDownload())\n-                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n+                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             return;\n         }\n \n@@ -3036,7 +3036,7 @@ void ProcessMessage(\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return;\n         }\n@@ -3077,7 +3077,7 @@ void ProcessMessage(\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return;\n                 }\n \n@@ -3094,7 +3094,7 @@ void ProcessMessage(\n                     fProcessBLOCKTXN = true;\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             } else {\n                 // This block is either already in flight from a different\n@@ -3120,7 +3120,7 @@ void ProcessMessage(\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -3210,7 +3210,7 @@ void ProcessMessage(\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED.\n@@ -3345,7 +3345,7 @@ void ProcessMessage(\n         pfrom.fSentAddr = true;\n \n         pfrom.vAddrToSend.clear();\n-        std::vector<CAddress> vAddr = connman->GetAddresses();\n+        std::vector<CAddress> vAddr = connman.GetAddresses();\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr) {\n             bool banned_or_discouraged = banman && (banman->IsDiscouraged(addr) || banman->IsBanned(addr));\n@@ -3367,7 +3367,7 @@ void ProcessMessage(\n             return;\n         }\n \n-        if (connman->OutboundTargetReached(false) && !pfrom.HasPermission(PF_MEMPOOL))\n+        if (connman.OutboundTargetReached(false) && !pfrom.HasPermission(PF_MEMPOOL))\n         {\n             if (!pfrom.HasPermission(PF_NOBAN))\n             {\n@@ -3400,7 +3400,7 @@ void ProcessMessage(\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n         return;\n     }\n@@ -3540,17 +3540,17 @@ void ProcessMessage(\n     }\n \n     if (msg_type == NetMsgType::GETCFILTERS) {\n-        ProcessGetCFilters(pfrom, vRecv, chainparams, *connman);\n+        ProcessGetCFilters(pfrom, vRecv, chainparams, connman);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFHEADERS) {\n-        ProcessGetCFHeaders(pfrom, vRecv, chainparams, *connman);\n+        ProcessGetCFHeaders(pfrom, vRecv, chainparams, connman);\n         return;\n     }\n \n     if (msg_type == NetMsgType::GETCFCHECKPT) {\n-        ProcessGetCFCheckPt(pfrom, vRecv, chainparams, *connman);\n+        ProcessGetCFCheckPt(pfrom, vRecv, chainparams, connman);\n         return;\n     }\n \n@@ -3626,12 +3626,12 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fMoreWork = false;\n \n     if (!pfrom->vRecvGetData.empty())\n-        ProcessGetData(*pfrom, chainparams, connman, m_mempool, interruptMsgProc);\n+        ProcessGetData(*pfrom, chainparams, *connman, m_mempool, interruptMsgProc);\n \n     if (!pfrom->orphan_work_set.empty()) {\n         std::list<CTransactionRef> removed_txn;\n         LOCK2(cs_main, g_cs_orphans);\n-        ProcessOrphanTx(connman, m_mempool, pfrom->orphan_work_set, removed_txn);\n+        ProcessOrphanTx(*connman, m_mempool, pfrom->orphan_work_set, removed_txn);\n         for (const CTransactionRef& removedTx : removed_txn) {\n             AddToCompactExtraTransactions(removedTx);\n         }\n@@ -3691,7 +3691,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     }\n \n     try {\n-        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, connman, m_banman, interruptMsgProc);\n+        ProcessMessage(*pfrom, msg_type, vRecv, msg.m_time, chainparams, m_chainman, m_mempool, *connman, m_banman, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())"
      },
      {
        "sha": "9e40d5cd55045198d2eca601e47bb2230ddc3826",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c8461a88ed66a1f70559fc96646708949b17e4b/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c8461a88ed66a1f70559fc96646708949b17e4b/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=0c8461a88ed66a1f70559fc96646708949b17e4b",
        "patch": "@@ -38,7 +38,7 @@ void ProcessMessage(\n     const CChainParams& chainparams,\n     ChainstateManager& chainman,\n     CTxMemPool& mempool,\n-    CConnman* connman,\n+    CConnman& connman,\n     BanMan* banman,\n     const std::atomic<bool>& interruptMsgProc);\n \n@@ -89,7 +89,7 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     try {\n         ProcessMessage(p2p_node, random_message_type, random_bytes_data_stream, GetTime<std::chrono::microseconds>(),\n             Params(), *g_setup->m_node.chainman, *g_setup->m_node.mempool,\n-            g_setup->m_node.connman.get(), g_setup->m_node.banman.get(),\n+            *g_setup->m_node.connman, g_setup->m_node.banman.get(),\n             std::atomic<bool>{false});\n     } catch (const std::ios_base::failure&) {\n     }"
      }
    ]
  }
]