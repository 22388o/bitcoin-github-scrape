MarcoFalke,2018-01-26T03:22:20Z,"This was hit twice on travis, you might find one of the logs here https://travis-ci.org/bitcoin/bitcoin/jobs/332197296 (might disappear soon, on reset)",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-360673845,360673845,
promag,2018-01-27T16:07:21Z,"> A bit more background - we (essentially) use mempool.cs as a read lock and cs_main as a write lock for the mempool.\n\nWhy not just use `mempool.cs` for both read and write? Stopping a lot of stuff just to dump the mempool sounds bad.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-360994681,360994681,
MarcoFalke,2018-01-27T17:09:30Z,"@promag Pull request welcome, but I'd prefer not to do major refactoring in a bug-fix pull request.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-360998784,360998784,
promag,2018-01-27T22:17:26Z,"Thanks for the explanation @MarcoFalke.\n\nIMHO, and to cover other possible cases, `cs_main` could be locked right before returning in `SyncWithValidationInterfaceQueue`:\n```cpp\nvoid SyncWithValidationInterfaceQueue() {\n    AssertLockNotHeld(cs_main);\n    // Block until the validation queue drains\n    std::promise<void> promise;\n    CallFunctionInValidationInterfaceQueue([&promise] ",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-361019806,361019806,
TheBlueMatt,2018-01-28T15:50:01Z,"No, we should not take a cs_main in SyncWithValidationInterface. The bug here is mempool.cs - we're using it as a read lock but not holding cs_main during the whole ""write"" in ATMP. The fix here is fine - sync getrawmempool with ATMP (as it should be). Alternatively we could hold cs_main for longer in ATMP, but adding a cs_main to validationinterface to fix a mempool-specific bug is way overkill.\",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-361072650,361072650,
devrandom,2018-02-03T21:10:16Z,"The question for me is whether the production (i.e. non-test) use of `getrawmempool` benefits from the added synchronization.  If taking the lock is only to synchronize against the test-only `syncwithvalidationinterface`, then it doesn't seem right to pay the lock cost in a production path. \n\nAlso, looking at the code, it does seem like cs_main is held for all of ATMP, so I don't understand th",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-362854566,362854566,
promag,2018-02-03T21:19:13Z,The idea is to guarantee the result has transactions already processed and are not in the queue to be processed. Once the lock is acquired before returning means that ATMP finished.,https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-362855145,362855145,
devrandom,2018-02-03T21:29:43Z,"How does the user of `getrawmempool` use that synchronization guarantee?  i.e. what followup would be invalid if the tx is not completely processed?\n\n(we can move to IRC if this is too much back and forth)",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-362855882,362855882,
promag,2018-02-03T21:52:10Z,"@TheBlueMatt explains above https://github.com/bitcoin/bitcoin/pull/12273#pullrequestreview-91735276.\n\nI don't think this is a production/mainnet concern.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-362857442,362857442,
devrandom,2018-02-03T22:32:49Z,"I understand the comment you linked.  It still seems a bit better to solve the test issue by synchronizing an RPC call that is never used in production rather than `getrawmempool`, which could be used in production.  But the performance difference is likely very small, so it's not a strong concern.\n",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-362860617,362860617,
TheBlueMatt,2018-02-06T16:14:05Z,"I disagree wholly that this is not a ""production concern"" - we could absolutely have users who are doing a getrawmempool and then calling wallet functions based on the result, introducing a new race for them. I believe we should be marking this 0.16 as a regression.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363474029,363474029,
devrandom,2018-02-06T16:18:29Z,"Wouldn't all such followup actions take `cs_main`, so would be safe?",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363475766,363475766,
TheBlueMatt,2018-02-06T16:19:55Z,"Err, sorry, not wallet calls, sendrawtransaction followed by a getrawmempool to verify its there - if we can hit a realistic race in testing we probably should consider it a potentially-production-issue.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363476365,363476365,
promag,2018-02-06T16:26:26Z,"> Err, sorry, not wallet calls, sendrawtransaction followed by a getrawmempool to verify its there\n\n`sendrawtransaction` fails if rejected by mempool. But it's a regression like you said.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363478702,363478702,
TheBlueMatt,2018-02-06T16:32:30Z,"One naive usage (which is already at least somewhat racy, but...) would be to do a getrawmempool to cheaply look up a transaction you just sent's fee. Not a massive deal, but definitely a regression worth fixing.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363480637,363480637,
devrandom,2018-02-06T16:59:51Z,"With the proposed fix, `sendrawtransaction` followed by a `getrawmempool` is *not* guaranteed to return the sent transaction, since the lock is taken after the results are computed.",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363490673,363490673,
TheBlueMatt,2018-02-06T17:51:20Z,"Oh, I seem to have confused myself an mis-remembered the issue here - you cannot hit this purely from RPC, but can hit wallet errors:\nIf you're polling getrawmempool to wait for a transaction to appear in your mempool, you can then race ATMP and, thus, see a balance that is as-of an old mempool and not the one you just got out of getrawmempool",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363507269,363507269,
MarcoFalke,2018-02-06T18:50:26Z,Changed milestone to 0.16,https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363525368,363525368,
MarcoFalke,2018-02-06T18:55:11Z,"There has been too much discussion around this simple fix.\n\nClosing in favor of  #12368",https://github.com/bitcoin/bitcoin/pull/12273#issuecomment-363526810,363526810,
TheBlueMatt,2018-01-26T02:39:34Z,"This needs to go before mempoolToJONS, no? ie just do a { LOCK(cs_main); }.",https://github.com/bitcoin/bitcoin/pull/12273#discussion_r164023957,164023957,src/rpc/blockchain.cpp
MarcoFalke,2018-01-26T03:05:50Z,"Acquiring the lock and immediately giving it back to the ATMP calling thread will not solve any races. (At least on my machine I can still see them.)\n\nI guess, I could hold it for the whole duration of getrawmempool, if that is what you like.",https://github.com/bitcoin/bitcoin/pull/12273#discussion_r164026429,164026429,src/rpc/blockchain.cpp
TheBlueMatt,2018-01-26T03:12:07Z,"Ah, oops, yes, sorry, indeed, wrong direction. I guess this is fine for now, but we really need to kill the mempool.cs/cs_main garbage.",https://github.com/bitcoin/bitcoin/pull/12273#discussion_r164026988,164026988,src/rpc/blockchain.cpp
promag,2018-01-27T16:03:39Z,I don't understand why does it matter waiting for `cs_main` when the result is already determined. ,https://github.com/bitcoin/bitcoin/pull/12273#discussion_r164274736,164274736,src/rpc/blockchain.cpp
MarcoFalke,2018-01-27T17:07:35Z,"We want to wait for https://github.com/bitcoin/bitcoin/blob/8470e64724cb4a668079e7516dc61ec230346618/src/validation.cpp#L974\nwhich happens under `cs_main`, not `pool.cs`.",https://github.com/bitcoin/bitcoin/pull/12273#discussion_r164276208,164276208,src/rpc/blockchain.cpp
