sipa,2020-09-08 21:41:46,"I think including a full other reference implementation is overkill.\n\nEvery byte array as input has exactly one hash, regardless of how it is split up in chucks and hashed. You can verify the ""hash everything at once"" code path using test vectors. These are usually published by the same body that standardized the function, and are picked to give good coverage. By the nature of hashing, it tend",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689151515,689151515,
practicalswift,2020-09-08 21:43:16,"Concept ACK\n\nThis is excellent!\n\nBTW, if you're interested in differential cryptography fuzzing you should check out @guidovranken's really cool [Cryptofuzz project](https://github.com/guidovranken/cryptofuzz).\n\nThe list of bug trophies for Cryptofuzz is amazing! Cryptofuzz has found bugs in OpenSSL, LibreSSL, BoringSSL, libgcrypt, Crypto++, NSS, Botan, wolfCrypt, sjcl, SymCrypt, mbed ",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689152203,689152203,
elichai,2020-09-08 21:55:56,"> As you point out, the buffering logic is often far more error-prone, and harder to test. I think it's a useful target for fuzzing, but all you need for that is a fuzzer that takes as input a number of chunks, and then hashes them both concatenated at once, and split up as separate writes, and compares the result.\n\nI thought about this, but even if you test chuncks vs single write, you still ",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689158007,689158007,
sipa,2020-09-08 21:57:33,"> I thought about this, but even if you test chuncks vs single write, you still go through the same writer with the same logic, so it might not find an off by one bug in the memcpy of one of the branches in Write/Finalize.\n\nThat should be caught using test vectors, as the code path is identical for all inputs of the same length",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689158590,689158590,
elichai,2020-09-08 22:09:36,"> That should be caught using test vectors, as the code path is identical for all inputs of the same length\n\nYou can see in the paper I've linked that some times the test vectors don't cover all cases (a bug that returned the same value everytime a message of size BLOCK_SIZE was written, no matter the content, they had only 1 vector with a message of that length, so no one noticed).\nAlso dif",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689162817,689162817,
practicalswift,2020-09-08 22:16:09,The nice thing about differential fuzzing as suggested by @elichai is that we don't have to make _any_ assumptions about the implementation details of the function being fuzzed. Personally I think that benefit is worth the cost (in the form of an extra file in `src/test/fuzz/`).,https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689165085,689165085,
sipa,2020-09-08 22:16:19,"> You can see in the paper I've linked that some times the test vectors don't cover all cases (a bug that returned the same value everytime a message of size BLOCK_SIZE was written, no matter the content, they had only 1 vector with a message of that length, so no one noticed).\n\nSo include an test vector for every length, up to some multiple of the block size.\n\nThat's still far less effort",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689165138,689165138,
sipa,2020-09-08 22:21:15,"@practicalswift I think that spending time on blindly writing fuzzers without making _any_ assumptions about the code you're testing is often a waste of time. You can be far more effective by focussing on things that aren't guaranteed by the source code, or are likely to trigger edge cases. And this isn't just your time, but also the time of people reviewing and maintaining the codebase later.\n\n",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689166824,689166824,
practicalswift,2020-09-08 22:31:34,"@sipa \n\n> I think that spending time on blindly writing fuzzers without making any assumptions about the code you're testing is often a waste of time.\n\nFWIW the fuzzers that found https://github.com/sipa/miniscript/issues/7, https://github.com/sipa/miniscript/issues/12, https://github.com/sipa/miniscript/issues/13, https://github.com/sipa/miniscript/issues/14, https://github.com/sipa/minis",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689170237,689170237,
sipa,2020-09-08 22:32:50,"Don't put words in my mouth.\n\nI'm not saying that you can't find issues that way. I'm saying you can be more effective at it if you understand the code better.",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689170662,689170662,
guidovranken,2020-09-09 09:07:18,"Thanks for the heads up @practicalswift . I've implemented differential testing of Bitcoin's Siphash. No bugs found.\n\n@sipa Untested but the use of ```int count``` may cause it to produce incorrect results or worse with inputs >= 2GB.",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689433583,689433583,
MarcoFalke,2020-09-09 09:25:46,"I don't have any background in implementing hash functions, so I have no opinion on whether to only test that different chunk sizes on the same input reveal the same output or to test against a full reference impl. Maintaining a reference impl for hash functions should hopefully be of little overhead because we can assume they are well tested, bug free and stable, right?\n\nThough, a requirement",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689443442,689443442,
practicalswift,2020-09-09 11:33:57,"@guidovranken \n\n> @sipa Untested but the use of int count may cause it to produce incorrect results or worse with inputs >= 2GB.\n\nYes, a signed integer overflow takes place in `src/crypto/siphash.cpp`:\n\n```\n$ src/test/fuzz/simplest_possible_siphash_fuzzer -rss_limit_mb=8000 crash-061a172add013c03beedf57eb2a121a8289696af\ncrypto/siphash.cpp:56:10: runtime error: signed integer overfl",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689502641,689502641,
elichai,2020-09-09 12:16:30,"> I don't have any background in implementing hash functions, so I have no opinion on whether to only test that different chunk sizes on the same input reveal the same output or to test against a full reference impl. Maintaining a reference impl for hash functions should hopefully be of little overhead because we can assume they are well tested, bug free and stable, right?\n> \n> Though, a requi",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689523595,689523595,
practicalswift,2020-09-09 12:38:38,"Tested ACK 7f803816ee91fb2e050cdd7fd7df2f96806e0245 -- the fuzzing harness is written in such a way that it is able to trigger a signed integer overflow:\n\n```\n$ src/test/fuzz/crypto_siphash -rss_limit_mb=16000 crash-b992191b7160e637042d9918c3dffc562bc8bb14\ncrypto/siphash.cpp:56:10: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'\nSUMMARY: Undefin",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-689535281,689535281,
Crypt-iQ,2020-10-21 15:25:20,Concept ACK - really cool to see differential fuzzing in action.,https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-713657689,713657689,
elichai,2020-10-21 16:10:02,"> Fuzzing is good at finding combinations of inputs that trigger various code paths, so use it for that.\n\nUsing the fuzzer to find new test vectors and add them manually is a good idea. the problem is that every change in the logic (ie #18014) will require to re-run and generate new test vectors (and obviously test those against a reference implementation and against single full writes)",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-713687707,713687707,
laanwj,2020-11-19 15:18:32,"> I think including a full other reference implementation is overkill.\n\nWell, I'd normally agree, but looking at the actual code it's really small and placed in the test directory in any case. So, assuming there are no other problems such as licensing, I have no problems with it in that regard.\n",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-730444182,730444182,
DrahtBot,2020-12-04 03:40:04,<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.,https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-738545645,738545645,
practicalswift,2021-02-28 20:21:56,Needs rebase @elichai :),https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-787516398,787516398,
practicalswift,2021-03-19 14:50:27,"cr ACK e0d809082f5193be422252d11a88ec44f7d14170: patch still looks correct\n\nPersonally I think this fuzzing harness has already proven itself since it was able to trigger a now fixed signed integer overflow. No need to theorize when we have empirical evidence: practical is better than theoretical :)\n\nThanks @elichai for raising the quality bar!",https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-802889352,802889352,
MarcoFalke,2021-05-06 05:01:59,How is this different from https://github.com/google/oss-fuzz/pull/5717 ?,https://github.com/bitcoin/bitcoin/pull/19920#issuecomment-833225742,833225742,
