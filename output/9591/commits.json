[
  {
    "sha": "4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YWMxODQ1NDkyYzA4ZmY4ZmIyNWYwYzdiYjk0ZjhmZGNlMjAwOWRi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-01-19T22:52:43Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-01-19T22:52:43Z"
      },
      "message": "trivial: adhere to doc/developernotes.md coding style",
      "tree": {
        "sha": "f0ff1803f84d6af9142e9dd61f13a2a4d1900981",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0ff1803f84d6af9142e9dd61f13a2a4d1900981"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c5945804ca7e5edd9fce8c6de9b1f0ef775f9e79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5945804ca7e5edd9fce8c6de9b1f0ef775f9e79",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c5945804ca7e5edd9fce8c6de9b1f0ef775f9e79"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 62,
      "deletions": 43
    },
    "files": [
      {
        "sha": "f2dbe55332ba0726cfde56c6feebb58d0d8aaaaf",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 43,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
        "patch": "@@ -19,7 +19,8 @@\n \n CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n-        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block)\n+{\n     FillShortTxIDSelector();\n     //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n     prefilledtxn[0] = {0, block.vtx[0]};\n@@ -29,7 +30,8 @@ CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool f\n     }\n }\n \n-void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const\n+{\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << header << nonce;\n     CSHA256 hasher;\n@@ -40,31 +42,37 @@ void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n     shorttxidk1 = shorttxidhash.GetUint64(1);\n }\n \n-uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const\n+{\n     static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n     return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n }\n \n-\n-\n-ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, const std::vector<std::pair<uint256, CTransactionRef>>& extra_txn) {\n-    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock,\n+                                              const std::vector<std::pair<uint256,\n+                                              CTransactionRef>>& extra_txn)\n+{\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty())) {\n         return READ_STATUS_INVALID;\n-    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_BASE_SIZE / MIN_TRANSACTION_BASE_SIZE)\n+    }\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_BASE_SIZE / MIN_TRANSACTION_BASE_SIZE) {\n         return READ_STATUS_INVALID;\n+    }\n \n     assert(header.IsNull() && txn_available.empty());\n     header = cmpctblock.header;\n     txn_available.resize(cmpctblock.BlockTxCount());\n \n     int32_t lastprefilledindex = -1;\n     for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n-        if (cmpctblock.prefilledtxn[i].tx->IsNull())\n+        if (cmpctblock.prefilledtxn[i].tx->IsNull()) {\n             return READ_STATUS_INVALID;\n+        }\n \n         lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1; //index is a uint16_t, so can't overflow here\n-        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max()) {\n             return READ_STATUS_INVALID;\n+        }\n         if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i) {\n             // If we are inserting a tx at an index greater than our full list of shorttxids\n             // plus the number of prefilled txn we've inserted, then we have txn for which we\n@@ -82,8 +90,9 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n     uint16_t index_offset = 0;\n     for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n-        while (txn_available[i + index_offset])\n+        while (txn_available[i + index_offset]) {\n             index_offset++;\n+        }\n         shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n         // To determine the chance that the number of entries in a bucket exceeds N,\n         // we use the fact that the number of elements in a single bucket is\n@@ -95,8 +104,9 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n         // Thus: P(max_elements_per_bucket > N) <= S * (1 - cdf(binomial(n=S,p=1/S), N)).\n         // If we assume blocks of up to 16000, allowing 12 elements per bucket should\n         // only fail once per ~1 million block transfers (per peer and connection).\n-        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 12)\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 12) {\n             return READ_STATUS_FAILED;\n+        }\n     }\n     // TODO: in the shortid-collision case, we should instead request both transactions\n     // which collided. Falling back to full-block-request here is overkill.\n@@ -105,32 +115,33 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n \n     std::vector<bool> have_txn(txn_available.size());\n     {\n-    LOCK(pool->cs);\n-    const std::vector<std::pair<uint256, CTxMemPool::txiter> >& vTxHashes = pool->vTxHashes;\n-    for (size_t i = 0; i < vTxHashes.size(); i++) {\n-        uint64_t shortid = cmpctblock.GetShortID(vTxHashes[i].first);\n-        std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n-        if (idit != shorttxids.end()) {\n-            if (!have_txn[idit->second]) {\n-                txn_available[idit->second] = vTxHashes[i].second->GetSharedTx();\n-                have_txn[idit->second]  = true;\n-                mempool_count++;\n-            } else {\n-                // If we find two mempool txn that match the short id, just request it.\n-                // This should be rare enough that the extra bandwidth doesn't matter,\n-                // but eating a round-trip due to FillBlock failure would be annoying\n-                if (txn_available[idit->second]) {\n-                    txn_available[idit->second].reset();\n-                    mempool_count--;\n+        LOCK(pool->cs);\n+        const std::vector<std::pair<uint256, CTxMemPool::txiter> >& vTxHashes = pool->vTxHashes;\n+        for (size_t i = 0; i < vTxHashes.size(); i++) {\n+            uint64_t shortid = cmpctblock.GetShortID(vTxHashes[i].first);\n+            std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n+            if (idit != shorttxids.end()) {\n+                if (!have_txn[idit->second]) {\n+                    txn_available[idit->second] = vTxHashes[i].second->GetSharedTx();\n+                    have_txn[idit->second]  = true;\n+                    mempool_count++;\n+                } else {\n+                    // If we find two mempool txn that match the short id, just request it.\n+                    // This should be rare enough that the extra bandwidth doesn't matter,\n+                    // but eating a round-trip due to FillBlock failure would be annoying\n+                    if (txn_available[idit->second]) {\n+                        txn_available[idit->second].reset();\n+                        mempool_count--;\n+                    }\n                 }\n             }\n+            // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n+            // the performance win of an early exit here is too good to pass up and worth\n+            // the extra risk.\n+            if (mempool_count == shorttxids.size()) {\n+                break;\n+            }\n         }\n-        // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n-        // the performance win of an early exit here is too good to pass up and worth\n-        // the extra risk.\n-        if (mempool_count == shorttxids.size())\n-            break;\n-    }\n     }\n \n     for (size_t i = 0; i < extra_txn.size(); i++) {\n@@ -160,22 +171,25 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n         // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n         // the performance win of an early exit here is too good to pass up and worth\n         // the extra risk.\n-        if (mempool_count == shorttxids.size())\n+        if (mempool_count == shorttxids.size()) {\n             break;\n+        }\n     }\n \n     LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));\n \n     return READ_STATUS_OK;\n }\n \n-bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const\n+{\n     assert(!header.IsNull());\n     assert(index < txn_available.size());\n     return txn_available[index] ? true : false;\n }\n \n-ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing) {\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing)\n+{\n     assert(!header.IsNull());\n     uint256 hash = header.GetHash();\n     block = header;\n@@ -184,35 +198,40 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n     size_t tx_missing_offset = 0;\n     for (size_t i = 0; i < txn_available.size(); i++) {\n         if (!txn_available[i]) {\n-            if (vtx_missing.size() <= tx_missing_offset)\n+            if (vtx_missing.size() <= tx_missing_offset) {\n                 return READ_STATUS_INVALID;\n+            }\n             block.vtx[i] = vtx_missing[tx_missing_offset++];\n-        } else\n+        } else {\n             block.vtx[i] = std::move(txn_available[i]);\n+        }\n     }\n \n     // Make sure we can't call FillBlock again.\n     header.SetNull();\n     txn_available.clear();\n \n-    if (vtx_missing.size() != tx_missing_offset)\n+    if (vtx_missing.size() != tx_missing_offset) {\n         return READ_STATUS_INVALID;\n+    }\n \n     CValidationState state;\n     if (!CheckBlock(block, state, Params().GetConsensus())) {\n         // TODO: We really want to just check merkle tree manually here,\n         // but that is expensive, and CheckBlock caches a block's\n         // \"checked-status\" (in the CBlock?). CBlock should be able to\n         // check its own merkle root and cache that check.\n-        if (state.CorruptionPossible())\n+        if (state.CorruptionPossible()) {\n             return READ_STATUS_FAILED; // Possible Short ID collision\n+        }\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }\n \n     LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n     if (vtx_missing.size() < 5) {\n-        for (const auto& tx : vtx_missing)\n+        for (const auto& tx : vtx_missing) {\n             LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());\n+        }\n     }\n \n     return READ_STATUS_OK;"
      }
    ]
  },
  {
    "sha": "c189da97dd7133704995cfc17b15b3e435deea12",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMTg5ZGE5N2RkNzEzMzcwNDk5NWNmYzE3YjE1YjNlNDM1ZGVlYTEy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-01-19T23:17:52Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-01-20T17:41:03Z"
      },
      "message": "Compact blocks - count mempool and extra pool matches correctly",
      "tree": {
        "sha": "0bffd52a6487d3cd64c445b588e108b5299bb276",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0bffd52a6487d3cd64c445b588e108b5299bb276"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c189da97dd7133704995cfc17b15b3e435deea12",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c189da97dd7133704995cfc17b15b3e435deea12",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c189da97dd7133704995cfc17b15b3e435deea12",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c189da97dd7133704995cfc17b15b3e435deea12/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ac1845492c08ff8fb25f0c7bb94f8fdce2009db"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 27,
      "deletions": 13
    },
    "files": [
      {
        "sha": "0454aa87546ba0babb3ee90c3a3f44a63b685247",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 13,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c189da97dd7133704995cfc17b15b3e435deea12/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c189da97dd7133704995cfc17b15b3e435deea12/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=c189da97dd7133704995cfc17b15b3e435deea12",
        "patch": "@@ -113,6 +113,9 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     if (shorttxids.size() != cmpctblock.shorttxids.size())\n         return READ_STATUS_FAILED; // Short ID collision\n \n+    size_t missing_txs = shorttxids.size();\n+    bool shortid_collision = false;\n+\n     std::vector<bool> have_txn(txn_available.size());\n     {\n         LOCK(pool->cs);\n@@ -125,20 +128,32 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n                     txn_available[idit->second] = vTxHashes[i].second->GetSharedTx();\n                     have_txn[idit->second]  = true;\n                     mempool_count++;\n+                    missing_txs--;\n                 } else {\n                     // If we find two mempool txn that match the short id, just request it.\n                     // This should be rare enough that the extra bandwidth doesn't matter,\n                     // but eating a round-trip due to FillBlock failure would be annoying\n                     if (txn_available[idit->second]) {\n                         txn_available[idit->second].reset();\n-                        mempool_count--;\n+                        shortid_collision = true;\n                     }\n                 }\n             }\n-            // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n-            // the performance win of an early exit here is too good to pass up and worth\n-            // the extra risk.\n-            if (mempool_count == shorttxids.size()) {\n+            if (missing_txs == 0 && !shortid_collision) {\n+                // We've found transactions matching all of the shortids and haven't yet\n+                // found a shortid collision. We could continue scanning through the\n+                // mempool and extra pool in case there's a shortid collision later,\n+                // but running GetShortID() on the entire mempool and extra pool is an\n+                // expensive operation.\n+                //\n+                // Instead we just assume that we now have all the correct transactions\n+                // from the block. If one of our transactions isn't correct and is\n+                // actually a shortid collision, we'll return READ_STATUS_FAILED in\n+                // FillBlock() and fall back to requesting the full block from the peer.\n+                //\n+                // Put simply - there's a very high probibility that we can complete the\n+                // block now. The downside is that if we fail, we'll have to request a full\n+                // block.\n                 break;\n             }\n         }\n@@ -151,8 +166,8 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n             if (!have_txn[idit->second]) {\n                 txn_available[idit->second] = extra_txn[i].second;\n                 have_txn[idit->second]  = true;\n-                mempool_count++;\n                 extra_count++;\n+                missing_txs--;\n             } else {\n                 // If we find two mempool/extra txn that match the short id, just\n                 // request it.\n@@ -163,15 +178,14 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n                 if (txn_available[idit->second] &&\n                         txn_available[idit->second]->GetWitnessHash() != extra_txn[i].second->GetWitnessHash()) {\n                     txn_available[idit->second].reset();\n-                    mempool_count--;\n-                    extra_count--;\n+                    shortid_collision = true;\n                 }\n             }\n         }\n-        // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n-        // the performance win of an early exit here is too good to pass up and worth\n-        // the extra risk.\n-        if (mempool_count == shorttxids.size()) {\n+        if (missing_txs == 0 && !shortid_collision) {\n+            // See comment above - we have transactions for all shortids and haven't yet\n+            // found a shortid collision. Assume that we have all the correct transactions\n+            // in the block.\n             break;\n         }\n     }\n@@ -227,7 +241,7 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }\n \n-    LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n+    LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, up to %lu txn from mempool, up to %lu from extra pool and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n     if (vtx_missing.size() < 5) {\n         for (const auto& tx : vtx_missing) {\n             LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());"
      }
    ]
  }
]