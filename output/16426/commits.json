[
  {
    "sha": "b855592d835bf4b3fb1263b88d4f96669a1722b1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiODU1NTkyZDgzNWJmNGIzZmIxMjYzYjg4ZDRmOTY2NjlhMTcyMmIx",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2019-07-10T00:07:39Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-04-30T18:31:19Z"
      },
      "message": "[wallet] Move getHeight from Chain::Lock interface to simple Chain\n\nInstead of calling getHeight, we rely on CWallet::m_last_block\nprocessed_height where it's possible.",
      "tree": {
        "sha": "8e36d5158106b46fb12b4bb1813eb0685a03d0a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8e36d5158106b46fb12b4bb1813eb0685a03d0a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b855592d835bf4b3fb1263b88d4f96669a1722b1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b855592d835bf4b3fb1263b88d4f96669a1722b1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b855592d835bf4b3fb1263b88d4f96669a1722b1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b855592d835bf4b3fb1263b88d4f96669a1722b1/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "0f204dd3f21b997334a0e99954c939db154b64ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f204dd3f21b997334a0e99954c939db154b64ca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0f204dd3f21b997334a0e99954c939db154b64ca"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 27,
      "deletions": 30
    },
    "files": [
      {
        "sha": "b891cf2ee59415643262a56e89434b53caa65d97",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -55,15 +55,6 @@ bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec\n \n class LockImpl : public Chain::Lock, public UniqueLock<RecursiveMutex>\n {\n-    Optional<int> getHeight() override\n-    {\n-        LockAssertion lock(::cs_main);\n-        int height = ::ChainActive().Height();\n-        if (height >= 0) {\n-            return height;\n-        }\n-        return nullopt;\n-    }\n     Optional<int> getBlockHeight(const uint256& hash) override\n     {\n         LockAssertion lock(::cs_main);\n@@ -234,6 +225,15 @@ class ChainImpl : public Chain\n         std::unique_ptr<Chain::Lock> result = std::move(lock); // Temporary to avoid CWG 1579\n         return result;\n     }\n+    Optional<int> getHeight() override\n+    {\n+        LOCK(::cs_main);\n+        int height = ::ChainActive().Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n     bool findBlock(const uint256& hash, const FoundBlock& block) override\n     {\n         WAIT_LOCK(cs_main, lock);"
      },
      {
        "sha": "03635fd74faafb02d3068b37eba4fd74ad875d4a",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -87,11 +87,6 @@ class Chain\n     public:\n         virtual ~Lock() {}\n \n-        //! Get current chain height, not including genesis block (returns 0 if\n-        //! chain only contains genesis block, nullopt if chain does not contain\n-        //! any blocks).\n-        virtual Optional<int> getHeight() = 0;\n-\n         //! Get block height above genesis block. Returns 0 for genesis block,\n         //! 1 for following block, and so on. Returns nullopt for a block not\n         //! included in the current chain.\n@@ -135,6 +130,11 @@ class Chain\n     //! unlocked when the returned interface is freed.\n     virtual std::unique_ptr<Lock> lock(bool try_lock = false) = 0;\n \n+    //! Get current chain height, not including genesis block (returns 0 if\n+    //! chain only contains genesis block, nullopt if chain does not contain\n+    //! any blocks)\n+    virtual Optional<int> getHeight() = 0;\n+\n     //! Return whether node has the block and optionally return block metadata\n     //! or contents.\n     virtual bool findBlock(const uint256& hash, const FoundBlock& block={}) = 0;"
      },
      {
        "sha": "0c31ae0c818f78b65061f52f7be0c4d353bc3df0",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -228,7 +228,7 @@ class WalletImpl : public Wallet\n         auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         CTransactionRef tx;\n-        if (!m_wallet->CreateTransaction(*locked_chain, recipients, tx, fee, change_pos,\n+        if (!m_wallet->CreateTransaction(recipients, tx, fee, change_pos,\n                 fail_reason, coin_control, sign)) {\n             return {};\n         }\n@@ -335,7 +335,7 @@ class WalletImpl : public Wallet\n         LOCK(m_wallet->cs_wallet);\n         auto mi = m_wallet->mapWallet.find(txid);\n         if (mi != m_wallet->mapWallet.end()) {\n-            num_blocks = locked_chain->getHeight().get_value_or(-1);\n+            num_blocks = m_wallet->GetLastBlockHeight();\n             in_mempool = mi->second.InMempool();\n             order_form = mi->second.vOrderForm;\n             tx_status = MakeWalletTxStatus(*locked_chain, mi->second);"
      },
      {
        "sha": "d596db431ac5730463332a9d4e5266a063addf4e",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -219,7 +219,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     CAmount fee_ret;\n     int change_pos_in_out = -1; // No requested location for change\n     std::string fail_reason;\n-    if (!wallet.CreateTransaction(*locked_chain, recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, false)) {\n+    if (!wallet.CreateTransaction(recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, false)) {\n         errors.push_back(\"Unable to create transaction: \" + fail_reason);\n         return Result::WALLET_ERROR;\n     }"
      },
      {
        "sha": "4c78e6fdce17c143c4584d9468996867ad947af0",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -322,7 +322,7 @@ static UniValue setlabel(const JSONRPCRequest& request)\n }\n \n \n-static CTransactionRef SendMoney(interfaces::Chain::Lock& locked_chain, CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue)\n+static CTransactionRef SendMoney(CWallet* const pwallet, const CTxDestination& address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue)\n {\n     CAmount curBalance = pwallet->GetBalance(0, coin_control.m_avoid_address_reuse).m_mine_trusted;\n \n@@ -344,7 +344,7 @@ static CTransactionRef SendMoney(interfaces::Chain::Lock& locked_chain, CWallet\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n     CTransactionRef tx;\n-    if (!pwallet->CreateTransaction(locked_chain, vecSend, tx, nFeeRequired, nChangePosRet, strError, coin_control)) {\n+    if (!pwallet->CreateTransaction(vecSend, tx, nFeeRequired, nChangePosRet, strError, coin_control)) {\n         if (!fSubtractFeeFromAmount && nValue + nFeeRequired > curBalance)\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s\", FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n@@ -445,7 +445,7 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    CTransactionRef tx = SendMoney(*locked_chain, pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue));\n+    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue));\n     return tx->GetHash().GetHex();\n }\n \n@@ -913,7 +913,7 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     int nChangePosRet = -1;\n     std::string strFailReason;\n     CTransactionRef tx;\n-    bool fCreated = pwallet->CreateTransaction(*locked_chain, vecSend, tx, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n+    bool fCreated = pwallet->CreateTransaction(vecSend, tx, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n     pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */);\n@@ -3563,8 +3563,7 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n             stop_height = request.params[1].get_int();\n             if (*stop_height < 0 || *stop_height > tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid stop_height\");\n-            }\n-            else if (*stop_height < start_height) {\n+            } else if (*stop_height < start_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"stop_height must be greater than start_height\");\n             }\n         }"
      },
      {
        "sha": "1c569cbef1daf8a6ef065c2d2c6ff8245e413cfb",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -521,7 +521,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CCoinControl dummy;\n         {\n             auto locked_chain = m_chain->lock();\n-            BOOST_CHECK(wallet->CreateTransaction(*locked_chain, {recipient}, tx, fee, changePos, error, dummy));\n+            BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, changePos, error, dummy));\n         }\n         wallet->CommitTransaction(tx, {}, {});\n         CMutableTransaction blocktx;"
      },
      {
        "sha": "3be0453978ef89af0f20b87e6e600ab28251b121",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -2555,7 +2555,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n     LOCK(cs_wallet);\n \n     CTransactionRef tx_new;\n-    if (!CreateTransaction(*locked_chain, vecSend, tx_new, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n+    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n         return false;\n     }\n \n@@ -2671,8 +2671,7 @@ OutputType CWallet::TransactionChangeType(OutputType change_type, const std::vec\n     return m_default_address_type;\n }\n \n-bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet,\n-                         int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n+bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n {\n     CAmount nValue = 0;\n     const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n@@ -3943,7 +3942,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         }\n     }\n \n-    const Optional<int> tip_height = locked_chain->getHeight();\n+    const Optional<int> tip_height = chain.getHeight();\n     if (tip_height) {\n         walletInstance->m_last_block_processed = locked_chain->getBlockHash(*tip_height);\n         walletInstance->m_last_block_processed_height = *tip_height;"
      },
      {
        "sha": "662f5d4bb3250dd89d5033750972da31d654b40f",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b855592d835bf4b3fb1263b88d4f96669a1722b1/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "patch": "@@ -961,8 +961,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      * selected by SelectCoins(); Also create the change output, when needed\n      * @note passing nChangePosInOut as -1 will result in setting a random position\n      */\n-    bool CreateTransaction(interfaces::Chain::Lock& locked_chain, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut,\n-                           std::string& strFailReason, const CCoinControl& coin_control, bool sign = true);\n+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign = true);\n     /**\n      * Submit the transaction to the node's mempool and then relay to peers.\n      * Should be called after CreateTransaction unless you want to abort"
      }
    ]
  },
  {
    "sha": "de13363a472ea30dff2f8f55c6ae572281115380",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTEzMzYzYTQ3MmVhMzBkZmYyZjhmNTVjNmFlNTcyMjgxMTE1Mzgw",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2019-07-15T22:20:12Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-04-30T18:37:21Z"
      },
      "message": "[wallet] Move getBlockHeight from Chain::Lock interface to simple Chain\n\nAdd HaveChain to assert chain access for wallet-tool in LoadToWallet.",
      "tree": {
        "sha": "7e220b1927512f48b0c39d6c0120e6e99e22074b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e220b1927512f48b0c39d6c0120e6e99e22074b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de13363a472ea30dff2f8f55c6ae572281115380",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de13363a472ea30dff2f8f55c6ae572281115380",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de13363a472ea30dff2f8f55c6ae572281115380",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de13363a472ea30dff2f8f55c6ae572281115380/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b855592d835bf4b3fb1263b88d4f96669a1722b1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b855592d835bf4b3fb1263b88d4f96669a1722b1"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 20,
      "deletions": 18
    },
    "files": [
      {
        "sha": "ccdbf1f1d1de15065fde1daf3054f6d6b18a558b",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de13363a472ea30dff2f8f55c6ae572281115380/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de13363a472ea30dff2f8f55c6ae572281115380/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=de13363a472ea30dff2f8f55c6ae572281115380",
        "patch": "@@ -55,15 +55,6 @@ bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec\n \n class LockImpl : public Chain::Lock, public UniqueLock<RecursiveMutex>\n {\n-    Optional<int> getBlockHeight(const uint256& hash) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        CBlockIndex* block = LookupBlockIndex(hash);\n-        if (block && ::ChainActive().Contains(block)) {\n-            return block->nHeight;\n-        }\n-        return nullopt;\n-    }\n     uint256 getBlockHash(int height) override\n     {\n         LockAssertion lock(::cs_main);\n@@ -234,6 +225,15 @@ class ChainImpl : public Chain\n         }\n         return nullopt;\n     }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        LOCK(::cs_main);\n+        CBlockIndex* block = LookupBlockIndex(hash);\n+        if (block && ::ChainActive().Contains(block)) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n     bool findBlock(const uint256& hash, const FoundBlock& block) override\n     {\n         WAIT_LOCK(cs_main, lock);"
      },
      {
        "sha": "b85484c11bd1d84576d5e1c034304727c90b884d",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de13363a472ea30dff2f8f55c6ae572281115380/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de13363a472ea30dff2f8f55c6ae572281115380/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=de13363a472ea30dff2f8f55c6ae572281115380",
        "patch": "@@ -87,11 +87,6 @@ class Chain\n     public:\n         virtual ~Lock() {}\n \n-        //! Get block height above genesis block. Returns 0 for genesis block,\n-        //! 1 for following block, and so on. Returns nullopt for a block not\n-        //! included in the current chain.\n-        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n-\n         //! Get block hash. Height must be valid or this function will abort.\n         virtual uint256 getBlockHash(int height) = 0;\n \n@@ -135,6 +130,11 @@ class Chain\n     //! any blocks)\n     virtual Optional<int> getHeight() = 0;\n \n+    //! Get block height above genesis block. Returns 0 for genesis block,\n+    //! 1 for following block, and so on. Returns nullopt for a block not\n+    //! included in the current chain.\n+    virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n     //! Return whether node has the block and optionally return block metadata\n     //! or contents.\n     virtual bool findBlock(const uint256& hash, const FoundBlock& block={}) = 0;"
      },
      {
        "sha": "b7117e2e590346333679186655ab76971613972d",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de13363a472ea30dff2f8f55c6ae572281115380/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de13363a472ea30dff2f8f55c6ae572281115380/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=de13363a472ea30dff2f8f55c6ae572281115380",
        "patch": "@@ -885,10 +885,9 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n \n void CWallet::LoadToWallet(CWalletTx& wtxIn)\n {\n-    // If wallet doesn't have a chain (e.g bitcoin-wallet), lock can't be taken.\n-    auto locked_chain = LockChain();\n-    if (locked_chain) {\n-        Optional<int> block_height = locked_chain->getBlockHeight(wtxIn.m_confirm.hashBlock);\n+    // If wallet doesn't have a chain (e.g wallet-tool), don't bother to update txn.\n+    if (HaveChain()) {\n+        Optional<int> block_height = chain().getBlockHeight(wtxIn.m_confirm.hashBlock);\n         if (block_height) {\n             // Update cached block height variable since it not stored in the\n             // serialized transaction."
      },
      {
        "sha": "fa2821dfeae198e773c7cf3cdc43c1c803bf5f7a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de13363a472ea30dff2f8f55c6ae572281115380/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de13363a472ea30dff2f8f55c6ae572281115380/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=de13363a472ea30dff2f8f55c6ae572281115380",
        "patch": "@@ -778,6 +778,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /** Interface to assert chain access and if successful lock it */\n     std::unique_ptr<interfaces::Chain::Lock> LockChain() { return m_chain ? m_chain->lock() : nullptr; }\n \n+    /** Interface to assert chain access */\n+    bool HaveChain() const { return m_chain ? true : false; }\n+\n     std::map<uint256, CWalletTx> mapWallet GUARDED_BY(cs_wallet);\n \n     typedef std::multimap<int64_t, CWalletTx*> TxItems;"
      }
    ]
  },
  {
    "sha": "0a76287387950bc9c5b634e95c5cd5fb1029f42d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTc2Mjg3Mzg3OTUwYmM5YzViNjM0ZTk1YzVjZDVmYjEwMjlmNDJk",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2019-07-16T19:20:01Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-04-30T18:37:21Z"
      },
      "message": "[wallet] Move getBlockHash from Chain::Lock interface to simple Chain",
      "tree": {
        "sha": "40bc835faca023a5d008e9f315c5dc4918d11cb3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/40bc835faca023a5d008e9f315c5dc4918d11cb3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a76287387950bc9c5b634e95c5cd5fb1029f42d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a76287387950bc9c5b634e95c5cd5fb1029f42d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a76287387950bc9c5b634e95c5cd5fb1029f42d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a76287387950bc9c5b634e95c5cd5fb1029f42d/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "de13363a472ea30dff2f8f55c6ae572281115380",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de13363a472ea30dff2f8f55c6ae572281115380",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de13363a472ea30dff2f8f55c6ae572281115380"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 12,
      "deletions": 12
    },
    "files": [
      {
        "sha": "a4702558dc41da5a6843a50d891c4cbc5a248e04",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a76287387950bc9c5b634e95c5cd5fb1029f42d/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a76287387950bc9c5b634e95c5cd5fb1029f42d/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=0a76287387950bc9c5b634e95c5cd5fb1029f42d",
        "patch": "@@ -55,13 +55,6 @@ bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec\n \n class LockImpl : public Chain::Lock, public UniqueLock<RecursiveMutex>\n {\n-    uint256 getBlockHash(int height) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        CBlockIndex* block = ::ChainActive()[height];\n-        assert(block != nullptr);\n-        return block->GetBlockHash();\n-    }\n     bool haveBlockOnDisk(int height) override\n     {\n         LockAssertion lock(::cs_main);\n@@ -234,6 +227,13 @@ class ChainImpl : public Chain\n         }\n         return nullopt;\n     }\n+    uint256 getBlockHash(int height) override\n+    {\n+        LOCK(::cs_main);\n+        CBlockIndex* block = ::ChainActive()[height];\n+        assert(block);\n+        return block->GetBlockHash();\n+    }\n     bool findBlock(const uint256& hash, const FoundBlock& block) override\n     {\n         WAIT_LOCK(cs_main, lock);"
      },
      {
        "sha": "c82ade88974d0cab2673e91578ff8428bd85c875",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a76287387950bc9c5b634e95c5cd5fb1029f42d/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a76287387950bc9c5b634e95c5cd5fb1029f42d/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=0a76287387950bc9c5b634e95c5cd5fb1029f42d",
        "patch": "@@ -87,9 +87,6 @@ class Chain\n     public:\n         virtual ~Lock() {}\n \n-        //! Get block hash. Height must be valid or this function will abort.\n-        virtual uint256 getBlockHash(int height) = 0;\n-\n         //! Check that the block is available on disk (i.e. has not been\n         //! pruned), and contains transactions.\n         virtual bool haveBlockOnDisk(int height) = 0;\n@@ -135,6 +132,9 @@ class Chain\n     //! included in the current chain.\n     virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n \n+    //! Get block hash. Height must be valid or this function will abort.\n+    virtual uint256 getBlockHash(int height) = 0;\n+\n     //! Return whether node has the block and optionally return block metadata\n     //! or contents.\n     virtual bool findBlock(const uint256& hash, const FoundBlock& block={}) = 0;"
      },
      {
        "sha": "859a52f3e7346176844dc724ea293019f31a747a",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a76287387950bc9c5b634e95c5cd5fb1029f42d/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a76287387950bc9c5b634e95c5cd5fb1029f42d/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=0a76287387950bc9c5b634e95c5cd5fb1029f42d",
        "patch": "@@ -3943,7 +3943,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n \n     const Optional<int> tip_height = chain.getHeight();\n     if (tip_height) {\n-        walletInstance->m_last_block_processed = locked_chain->getBlockHash(*tip_height);\n+        walletInstance->m_last_block_processed = chain.getBlockHash(*tip_height);\n         walletInstance->m_last_block_processed_height = *tip_height;\n     } else {\n         walletInstance->m_last_block_processed.SetNull();\n@@ -3989,7 +3989,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n \n         {\n             WalletRescanReserver reserver(*walletInstance);\n-            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(locked_chain->getBlockHash(rescan_height), rescan_height, {} /* max height */, reserver, true /* update */).status)) {\n+            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(chain.getBlockHash(rescan_height), rescan_height, {} /* max height */, reserver, true /* update */).status)) {\n                 error = _(\"Failed to rescan the wallet during initialization\").translated;\n                 return nullptr;\n             }"
      }
    ]
  },
  {
    "sha": "841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NDExNzg4MjBkMzFlMWMyNGEwMGNiMmM4ZmMwYjFmZDJmMTI2ZjU2",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2019-07-16T21:01:46Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-04-30T18:37:21Z"
      },
      "message": "[wallet] Move methods from Chain::Lock interface to simple Chain\n\nRemove findPruned and findFork, no more used after 17954.",
      "tree": {
        "sha": "b1d92f9637fe1259b5d8e31b7338b4f1d53d9379",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b1d92f9637fe1259b5d8e31b7338b4f1d53d9379"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "0a76287387950bc9c5b634e95c5cd5fb1029f42d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a76287387950bc9c5b634e95c5cd5fb1029f42d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a76287387950bc9c5b634e95c5cd5fb1029f42d"
      }
    ],
    "stats": {
      "total": 220,
      "additions": 97,
      "deletions": 123
    },
    "files": [
      {
        "sha": "11cd20d785c56b7ba639ad593061645bf0079557",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 52,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -55,58 +55,6 @@ bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec\n \n class LockImpl : public Chain::Lock, public UniqueLock<RecursiveMutex>\n {\n-    bool haveBlockOnDisk(int height) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        CBlockIndex* block = ::ChainActive()[height];\n-        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n-    }\n-    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        CBlockIndex* block = ::ChainActive().FindEarliestAtLeast(time, height);\n-        if (block) {\n-            if (hash) *hash = block->GetBlockHash();\n-            return block->nHeight;\n-        }\n-        return nullopt;\n-    }\n-    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        const CBlockIndex* block = LookupBlockIndex(hash);\n-        const CBlockIndex* fork = block ? ::ChainActive().FindFork(block) : nullptr;\n-        if (height) {\n-            if (block) {\n-                *height = block->nHeight;\n-            } else {\n-                height->reset();\n-            }\n-        }\n-        if (fork) {\n-            return fork->nHeight;\n-        }\n-        return nullopt;\n-    }\n-    CBlockLocator getTipLocator() override\n-    {\n-        LockAssertion lock(::cs_main);\n-        return ::ChainActive().GetLocator();\n-    }\n-    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        if (CBlockIndex* fork = FindForkInGlobalIndex(::ChainActive(), locator)) {\n-            return fork->nHeight;\n-        }\n-        return nullopt;\n-    }\n-    bool checkFinalTx(const CTransaction& tx) override\n-    {\n-        LockAssertion lock(::cs_main);\n-        return CheckFinalTx(tx);\n-    }\n-\n     using UniqueLock::UniqueLock;\n };\n \n@@ -234,6 +182,40 @@ class ChainImpl : public Chain\n         assert(block);\n         return block->GetBlockHash();\n     }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        LOCK(cs_main);\n+        CBlockIndex* block = ::ChainActive()[height];\n+        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) override\n+    {\n+        LOCK(cs_main);\n+        CBlockIndex* block = ::ChainActive().FindEarliestAtLeast(time, height);\n+        if (block) {\n+            if (hash) *hash = block->GetBlockHash();\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    CBlockLocator getTipLocator() override\n+    {\n+        LOCK(cs_main);\n+        return ::ChainActive().GetLocator();\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LOCK(cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        LOCK(cs_main);\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::ChainActive(), locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n     bool findBlock(const uint256& hash, const FoundBlock& block) override\n     {\n         WAIT_LOCK(cs_main, lock);"
      },
      {
        "sha": "d35d38692521b3ec0b57acace54c271355f2b991",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 22,
        "deletions": 30,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -86,36 +86,6 @@ class Chain\n     {\n     public:\n         virtual ~Lock() {}\n-\n-        //! Check that the block is available on disk (i.e. has not been\n-        //! pruned), and contains transactions.\n-        virtual bool haveBlockOnDisk(int height) = 0;\n-\n-        //! Return height of the first block in the chain with timestamp equal\n-        //! or greater than the given time and height equal or greater than the\n-        //! given height, or nullopt if there is no block with a high enough\n-        //! timestamp and height. Also return the block hash as an optional output parameter\n-        //! (to avoid the cost of a second lookup in case this information is needed.)\n-        virtual Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) = 0;\n-\n-        //! Return height of the specified block if it is on the chain, otherwise\n-        //! return the height of the highest block on chain that's an ancestor\n-        //! of the specified block, or nullopt if there is no common ancestor.\n-        //! Also return the height of the specified block as an optional output\n-        //! parameter (to avoid the cost of a second hash lookup in case this\n-        //! information is desired).\n-        virtual Optional<int> findFork(const uint256& hash, Optional<int>* height) = 0;\n-\n-        //! Get locator for the current chain tip.\n-        virtual CBlockLocator getTipLocator() = 0;\n-\n-        //! Return height of the highest block on chain in common with the locator,\n-        //! which will either be the original block used to create the locator,\n-        //! or one of its ancestors.\n-        virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n-\n-        //! Check if transaction will be final given chain height current time.\n-        virtual bool checkFinalTx(const CTransaction& tx) = 0;\n     };\n \n     //! Return Lock interface. Chain is locked when this is called, and\n@@ -135,6 +105,28 @@ class Chain\n     //! Get block hash. Height must be valid or this function will abort.\n     virtual uint256 getBlockHash(int height) = 0;\n \n+    //! Check that the block is available on disk (i.e. has not been\n+    //! pruned), and contains transactions.\n+    virtual bool haveBlockOnDisk(int height) = 0;\n+\n+    //! Return height of the first block in the chain with timestamp equal\n+    //! or greater than the given time and height equal or greater than the\n+    //! given height, or nullopt if there is no block with a high enough\n+    //! timestamp and height. Also return the block hash as an optional output parameter\n+    //! (to avoid the cost of a second lookup in case this information is needed.)\n+    virtual Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) = 0;\n+\n+    //! Get locator for the current chain tip.\n+    virtual CBlockLocator getTipLocator() = 0;\n+\n+    //! Return height of the highest block on chain in common with the locator,\n+    //! which will either be the original block used to create the locator,\n+    //! or one of its ancestors.\n+    virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n+\n+    //! Check if transaction will be final given chain height current time.\n+    virtual bool checkFinalTx(const CTransaction& tx) = 0;\n+\n     //! Return whether node has the block and optionally return block metadata\n     //! or contents.\n     virtual bool findBlock(const uint256& hash, const FoundBlock& block={}) = 0;"
      },
      {
        "sha": "de26f329d71d3d5ed619dbf9015769329359ab6a",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -60,16 +60,16 @@ WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n }\n \n //! Construct wallet tx status struct.\n-WalletTxStatus MakeWalletTxStatus(interfaces::Chain::Lock& locked_chain, const CWalletTx& wtx)\n+WalletTxStatus MakeWalletTxStatus(CWallet& wallet, const CWalletTx& wtx)\n {\n     WalletTxStatus result;\n     result.block_height = wtx.m_confirm.block_height > 0 ? wtx.m_confirm.block_height : std::numeric_limits<int>::max();\n     result.blocks_to_maturity = wtx.GetBlocksToMaturity();\n     result.depth_in_main_chain = wtx.GetDepthInMainChain();\n     result.time_received = wtx.nTimeReceived;\n     result.lock_time = wtx.tx->nLockTime;\n-    result.is_final = locked_chain.checkFinalTx(*wtx.tx);\n-    result.is_trusted = wtx.IsTrusted(locked_chain);\n+    result.is_final = wallet.chain().checkFinalTx(*wtx.tx);\n+    result.is_trusted = wtx.IsTrusted();\n     result.is_abandoned = wtx.isAbandoned();\n     result.is_coinbase = wtx.IsCoinBase();\n     result.is_in_main_chain = wtx.IsInMainChain();\n@@ -322,7 +322,7 @@ class WalletImpl : public Wallet\n         num_blocks = m_wallet->GetLastBlockHeight();\n         block_time = -1;\n         CHECK_NONFATAL(m_wallet->chain().findBlock(m_wallet->GetLastBlockHash(), FoundBlock().time(block_time)));\n-        tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n+        tx_status = MakeWalletTxStatus(*m_wallet, mi->second);\n         return true;\n     }\n     WalletTx getWalletTxDetails(const uint256& txid,\n@@ -338,7 +338,7 @@ class WalletImpl : public Wallet\n             num_blocks = m_wallet->GetLastBlockHeight();\n             in_mempool = mi->second.InMempool();\n             order_form = mi->second.vOrderForm;\n-            tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n+            tx_status = MakeWalletTxStatus(*m_wallet, mi->second);\n             return MakeWalletTx(*m_wallet, mi->second);\n         }\n         return {};\n@@ -413,7 +413,7 @@ class WalletImpl : public Wallet\n         auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         CoinsList result;\n-        for (const auto& entry : m_wallet->ListCoins(*locked_chain)) {\n+        for (const auto& entry : m_wallet->ListCoins()) {\n             auto& group = result[entry.first];\n             for (const auto& coin : entry.second) {\n                 group.emplace_back(COutPoint(coin.tx->GetHash(), coin.i),"
      },
      {
        "sha": "4a026f9ef4bbd5b2390b9ae9ac85cb30a4e6c295",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -148,7 +148,7 @@ static void WalletTxToJSON(interfaces::Chain& chain, interfaces::Chain::Lock& lo\n         CHECK_NONFATAL(chain.findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(block_time)));\n         entry.pushKV(\"blocktime\", block_time);\n     } else {\n-        entry.pushKV(\"trusted\", wtx.IsTrusted(locked_chain));\n+        entry.pushKV(\"trusted\", wtx.IsTrusted());\n     }\n     uint256 hash = wtx.GetHash();\n     entry.pushKV(\"txid\", hash.GetHex());\n@@ -572,7 +572,7 @@ static UniValue signmessage(const JSONRPCRequest& request)\n     return signature;\n }\n \n-static CAmount GetReceived(interfaces::Chain::Lock& locked_chain, const CWallet& wallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n+static CAmount GetReceived(const CWallet& wallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     std::set<CTxDestination> address_set;\n \n@@ -602,7 +602,7 @@ static CAmount GetReceived(interfaces::Chain::Lock& locked_chain, const CWallet&\n     CAmount amount = 0;\n     for (const std::pair<const uint256, CWalletTx>& wtx_pair : wallet.mapWallet) {\n         const CWalletTx& wtx = wtx_pair.second;\n-        if (wtx.IsCoinBase() || !locked_chain.checkFinalTx(*wtx.tx) || wtx.GetDepthInMainChain() < min_depth) {\n+        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx) || wtx.GetDepthInMainChain() < min_depth) {\n             continue;\n         }\n \n@@ -655,7 +655,7 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n-    return ValueFromAmount(GetReceived(*locked_chain, *pwallet, request.params, /* by_label */ false));\n+    return ValueFromAmount(GetReceived(*pwallet, request.params, /* by_label */ false));\n }\n \n \n@@ -696,7 +696,7 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n-    return ValueFromAmount(GetReceived(*locked_chain, *pwallet, request.params, /* by_label */ true));\n+    return ValueFromAmount(GetReceived(*pwallet, request.params, /* by_label */ true));\n }\n \n \n@@ -1049,7 +1049,7 @@ static UniValue ListReceived(interfaces::Chain::Lock& locked_chain, const CWalle\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n-        if (wtx.IsCoinBase() || !locked_chain.checkFinalTx(*wtx.tx)) {\n+        if (wtx.IsCoinBase() || !pwallet->chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n@@ -2942,7 +2942,7 @@ static UniValue listunspent(const JSONRPCRequest& request)\n         cctl.m_max_depth = nMaxDepth;\n         auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n-        pwallet->AvailableCoins(*locked_chain, vecOutputs, !include_unsafe, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n+        pwallet->AvailableCoins(vecOutputs, !include_unsafe, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n     }\n \n     LOCK(pwallet->cs_wallet);"
      },
      {
        "sha": "227cf275cc66f632187d15c02fd906c7e8b09f0b",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -556,7 +556,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins(*locked_chain);\n+        list = wallet->ListCoins();\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(boost::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -573,7 +573,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins(*locked_chain);\n+        list = wallet->ListCoins();\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(boost::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -584,7 +584,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n         auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(*locked_chain, available);\n+        wallet->AvailableCoins(available);\n         BOOST_CHECK_EQUAL(available.size(), 2U);\n     }\n     for (const auto& group : list) {\n@@ -597,15 +597,15 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n         auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(*locked_chain, available);\n+        wallet->AvailableCoins(available);\n         BOOST_CHECK_EQUAL(available.size(), 0U);\n     }\n     // Confirm ListCoins still returns same result as before, despite coins\n     // being locked.\n     {\n         auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins(*locked_chain);\n+        list = wallet->ListCoins();\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(boost::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);"
      },
      {
        "sha": "6e8f7e0e8f7a6b75da331bfb46e77188accb8ba3",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -1927,16 +1927,16 @@ bool CWalletTx::InMempool() const\n     return fInMempool;\n }\n \n-bool CWalletTx::IsTrusted(interfaces::Chain::Lock& locked_chain) const\n+bool CWalletTx::IsTrusted() const\n {\n     std::set<uint256> s;\n-    return IsTrusted(locked_chain, s);\n+    return IsTrusted(s);\n }\n \n-bool CWalletTx::IsTrusted(interfaces::Chain::Lock& locked_chain, std::set<uint256>& trusted_parents) const\n+bool CWalletTx::IsTrusted(std::set<uint256>& trusted_parents) const\n {\n     // Quick answer in most cases\n-    if (!locked_chain.checkFinalTx(*tx)) return false;\n+    if (!pwallet->chain().checkFinalTx(*tx)) return false;\n     int nDepth = GetDepthInMainChain();\n     if (nDepth >= 1) return true;\n     if (nDepth < 0) return false;\n@@ -1958,7 +1958,7 @@ bool CWalletTx::IsTrusted(interfaces::Chain::Lock& locked_chain, std::set<uint25\n         // If we've already trusted this parent, continue\n         if (trusted_parents.count(parent->GetHash())) continue;\n         // Recurse to check that the parent is also trusted\n-        if (!parent->IsTrusted(locked_chain, trusted_parents)) return false;\n+        if (!parent->IsTrusted(trusted_parents)) return false;\n         trusted_parents.insert(parent->GetHash());\n     }\n     return true;\n@@ -2050,7 +2050,7 @@ CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) cons\n         for (const auto& entry : mapWallet)\n         {\n             const CWalletTx& wtx = entry.second;\n-            const bool is_trusted{wtx.IsTrusted(*locked_chain, trusted_parents)};\n+            const bool is_trusted{wtx.IsTrusted(trusted_parents)};\n             const int tx_depth{wtx.GetDepthInMainChain()};\n             const CAmount tx_credit_mine{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n             const CAmount tx_credit_watchonly{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n@@ -2076,7 +2076,7 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n \n     CAmount balance = 0;\n     std::vector<COutput> vCoins;\n-    AvailableCoins(*locked_chain, vCoins, true, coinControl);\n+    AvailableCoins(vCoins, true, coinControl);\n     for (const COutput& out : vCoins) {\n         if (out.fSpendable) {\n             balance += out.tx->tx->vout[out.i].nValue;\n@@ -2085,7 +2085,7 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n     return balance;\n }\n \n-void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<COutput>& vCoins, bool fOnlySafe, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n+void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n {\n     AssertLockHeld(cs_wallet);\n \n@@ -2103,7 +2103,7 @@ void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<\n         const uint256& wtxid = entry.first;\n         const CWalletTx& wtx = entry.second;\n \n-        if (!locked_chain.checkFinalTx(*wtx.tx)) {\n+        if (!chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n@@ -2119,7 +2119,7 @@ void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<\n         if (nDepth == 0 && !wtx.InMempool())\n             continue;\n \n-        bool safeTx = wtx.IsTrusted(locked_chain, trusted_parents);\n+        bool safeTx = wtx.IsTrusted(trusted_parents);\n \n         // We should not consider coins from transactions that are replacing\n         // other transactions.\n@@ -2207,14 +2207,14 @@ void CWallet::AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<\n     }\n }\n \n-std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins(interfaces::Chain::Lock& locked_chain) const\n+std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n {\n     AssertLockHeld(cs_wallet);\n \n     std::map<CTxDestination, std::vector<COutput>> result;\n     std::vector<COutput> availableCoins;\n \n-    AvailableCoins(locked_chain, availableCoins);\n+    AvailableCoins(availableCoins);\n \n     for (const COutput& coin : availableCoins) {\n         CTxDestination address;\n@@ -2706,7 +2706,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n         txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n         {\n             std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(*locked_chain, vAvailableCoins, true, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+            AvailableCoins(vAvailableCoins, true, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n             CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n \n             // Create change script that will be used if we need change\n@@ -3293,7 +3293,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain:\n         {\n             const CWalletTx& wtx = walletEntry.second;\n \n-            if (!wtx.IsTrusted(locked_chain, trusted_parents))\n+            if (!wtx.IsTrusted(trusted_parents))\n                 continue;\n \n             if (wtx.IsImmatureCoinBase())\n@@ -3813,7 +3813,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         }\n \n         auto locked_chain = chain.lock();\n-        walletInstance->chainStateFlushed(locked_chain->getTipLocator());\n+        walletInstance->chainStateFlushed(chain.getTipLocator());\n     } else if (wallet_creation_flags & WALLET_FLAG_DISABLE_PRIVATE_KEYS) {\n         // Make it impossible to disable private keys after creation\n         error = strprintf(_(\"Error loading %s: Private keys can only be disabled during creation\").translated, walletFile);\n@@ -3935,7 +3935,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         WalletBatch batch(*walletInstance->database);\n         CBlockLocator locator;\n         if (batch.ReadBestBlock(locator)) {\n-            if (const Optional<int> fork_height = locked_chain->findLocatorFork(locator)) {\n+            if (const Optional<int> fork_height = chain.findLocatorFork(locator)) {\n                 rescan_height = *fork_height;\n             }\n         }\n@@ -3960,7 +3960,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n             // If a block is pruned after this check, we will load the wallet,\n             // but fail the rescan with a generic error.\n             int block_height = *tip_height;\n-            while (block_height > 0 && locked_chain->haveBlockOnDisk(block_height - 1) && rescan_height != block_height) {\n+            while (block_height > 0 && chain.haveBlockOnDisk(block_height - 1) && rescan_height != block_height) {\n                 --block_height;\n             }\n \n@@ -3982,7 +3982,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n             if (!time_first_key || time < *time_first_key) time_first_key = time;\n         }\n         if (time_first_key) {\n-            if (Optional<int> first_block = locked_chain->findFirstBlockWithTimeAndHeight(*time_first_key - TIMESTAMP_WINDOW, rescan_height, nullptr)) {\n+            if (Optional<int> first_block = chain.findFirstBlockWithTimeAndHeight(*time_first_key - TIMESTAMP_WINDOW, rescan_height, nullptr)) {\n                 rescan_height = *first_block;\n             }\n         }\n@@ -3994,7 +3994,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n                 return nullptr;\n             }\n         }\n-        walletInstance->chainStateFlushed(locked_chain->getTipLocator());\n+        walletInstance->chainStateFlushed(chain.getTipLocator());\n         walletInstance->database->IncrementUpdateCounter();\n \n         // Restore wallet transaction metadata after -zapwallettxes=1"
      },
      {
        "sha": "fb23ea82a73901b2663310caa083bd7af9356bc0",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/841178820d31e1c24a00cb2c8fc0b1fd2f126f56/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "patch": "@@ -499,8 +499,8 @@ class CWalletTx\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n     bool InMempool() const;\n-    bool IsTrusted(interfaces::Chain::Lock& locked_chain) const;\n-    bool IsTrusted(interfaces::Chain::Lock& locked_chain, std::set<uint256>& trusted_parents) const;\n+    bool IsTrusted() const;\n+    bool IsTrusted(std::set<uint256>& trusted_parents) const;\n \n     int64_t GetTxTime() const;\n \n@@ -808,12 +808,12 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /**\n      * populate vCoins with vector of available COutputs.\n      */\n-    void AvailableCoins(interfaces::Chain::Lock& locked_chain, std::vector<COutput>& vCoins, bool fOnlySafe = true, const CCoinControl* coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe = true, const CCoinControl* coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Return list of available coins and locked coins grouped by non-change output address.\n      */\n-    std::map<CTxDestination, std::vector<COutput>> ListCoins(interfaces::Chain::Lock& locked_chain) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Find non-change parent output."
      }
    ]
  },
  {
    "sha": "6a72f26968cf931c985d8d4797b6264274cabd06",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTcyZjI2OTY4Y2Y5MzFjOTg1ZDhkNDc5N2I2MjY0Mjc0Y2FiZDA2",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2019-12-18T22:46:53Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-04-30T18:41:24Z"
      },
      "message": "[wallet] Remove locked_chain from CWallet, its RPCs and tests\n\nThis change is intended to make the bitcoin node and its rpc, network\nand gui interfaces more responsive while the wallet is in use. Currently\nbecause the node's cs_main mutex is always locked before the wallet's\ncs_wallet mutex (to prevent deadlocks), cs_main currently stays locked\nwhile the wallet does relatively slow things like creating and listing\ntransactions.\n\nThis commit only remmove chain lock tacking in wallet code, and invert\nlock order from cs_main, cs_wallet to cs_wallet, cs_main.\nmust happen at once to avoid any deadlock. Previous commit were only\nremoving Chain::Lock methods to Chain interface and enforcing they\ntake cs_main.\n\nRemove LockChain method from CWallet and Chain::Lock interface.",
      "tree": {
        "sha": "43314c9f174a36168f9c8f6f9662fcb66bb5c892",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/43314c9f174a36168f9c8f6f9662fcb66bb5c892"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a72f26968cf931c985d8d4797b6264274cabd06",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a72f26968cf931c985d8d4797b6264274cabd06",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a72f26968cf931c985d8d4797b6264274cabd06",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a72f26968cf931c985d8d4797b6264274cabd06/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/841178820d31e1c24a00cb2c8fc0b1fd2f126f56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/841178820d31e1c24a00cb2c8fc0b1fd2f126f56"
      }
    ],
    "stats": {
      "total": 307,
      "additions": 106,
      "deletions": 201
    },
    "files": [
      {
        "sha": "c5262e4bc0a42e75c4465019ca99c177c9b0b7ea",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -53,11 +53,6 @@ bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec\n     return true;\n }\n \n-class LockImpl : public Chain::Lock, public UniqueLock<RecursiveMutex>\n-{\n-    using UniqueLock::UniqueLock;\n-};\n-\n class NotificationsProxy : public CValidationInterface\n {\n public:\n@@ -150,13 +145,6 @@ class ChainImpl : public Chain\n {\n public:\n     explicit ChainImpl(NodeContext& node) : m_node(node) {}\n-    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n-    {\n-        auto lock = MakeUnique<LockImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n-        if (try_lock && lock && !*lock) return {};\n-        std::unique_ptr<Chain::Lock> result = std::move(lock); // Temporary to avoid CWG 1579\n-        return result;\n-    }\n     Optional<int> getHeight() override\n     {\n         LOCK(::cs_main);"
      },
      {
        "sha": "e33fe54ac8b1d79e1647c48f63eda437c963e904",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 9,
        "deletions": 21,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -59,39 +59,27 @@ class FoundBlock\n //! internal workings of the bitcoin node, and not being very convenient to use.\n //! Chain methods should be cleaned up and simplified over time. Examples:\n //!\n-//! * The Chain::lock() method, which lets clients delay chain tip updates\n-//!   should be removed when clients are able to respond to updates\n-//!   asynchronously\n-//!   (https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-380101269).\n-//!\n-//! * The initMessage() and showProgress() methods which the wallet uses to send\n+//! * The initMessages() and showProgress() methods which the wallet uses to send\n //!   notifications to the GUI should go away when GUI and wallet can directly\n //!   communicate with each other without going through the node\n //!   (https://github.com/bitcoin/bitcoin/pull/15288#discussion_r253321096).\n //!\n //! * The handleRpc, registerRpcs, rpcEnableDeprecated methods and other RPC\n //!   methods can go away if wallets listen for HTTP requests on their own\n //!   ports instead of registering to handle requests on the node HTTP port.\n+//!\n+//! * Move fee estimation queries to an asynchronous interface and let the\n+//!   wallet cache it, fee estimation being driven by node mempool, wallet\n+//!   should be the consumer.\n+//!\n+//! * The `guessVerificationProgress`, `getBlockHeight`, `getBlockHash`, etc\n+//!   methods can go away if rescan logic is moved on the node side, and wallet\n+//!   only register rescan request.\n class Chain\n {\n public:\n     virtual ~Chain() {}\n \n-    //! Interface for querying locked chain state, used by legacy code that\n-    //! assumes state won't change between calls. New code should avoid using\n-    //! the Lock interface and instead call higher-level Chain methods\n-    //! that return more information so the chain doesn't need to stay locked\n-    //! between calls.\n-    class Lock\n-    {\n-    public:\n-        virtual ~Lock() {}\n-    };\n-\n-    //! Return Lock interface. Chain is locked when this is called, and\n-    //! unlocked when the returned interface is freed.\n-    virtual std::unique_ptr<Lock> lock(bool try_lock = false) = 0;\n-\n     //! Get current chain height, not including genesis block (returns 0 if\n     //! chain only contains genesis block, nullopt if chain does not contain\n     //! any blocks)"
      },
      {
        "sha": "752448aac79b2928a785477d5adccde60283da91",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 23,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -196,25 +196,21 @@ class WalletImpl : public Wallet\n     }\n     void lockCoin(const COutPoint& output) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->LockCoin(output);\n     }\n     void unlockCoin(const COutPoint& output) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->UnlockCoin(output);\n     }\n     bool isLockedCoin(const COutPoint& output) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->IsLockedCoin(output.hash, output.n);\n     }\n     void listLockedCoins(std::vector<COutPoint>& outputs) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->ListLockedCoins(outputs);\n     }\n@@ -225,7 +221,6 @@ class WalletImpl : public Wallet\n         CAmount& fee,\n         std::string& fail_reason) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         CTransactionRef tx;\n         if (!m_wallet->CreateTransaction(recipients, tx, fee, change_pos,\n@@ -238,14 +233,12 @@ class WalletImpl : public Wallet\n         WalletValueMap value_map,\n         WalletOrderForm order_form) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         m_wallet->CommitTransaction(std::move(tx), std::move(value_map), std::move(order_form));\n     }\n     bool transactionCanBeAbandoned(const uint256& txid) override { return m_wallet->TransactionCanBeAbandoned(txid); }\n     bool abandonTransaction(const uint256& txid) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->AbandonTransaction(txid);\n     }\n@@ -273,7 +266,6 @@ class WalletImpl : public Wallet\n     }\n     CTransactionRef getTx(const uint256& txid) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         auto mi = m_wallet->mapWallet.find(txid);\n         if (mi != m_wallet->mapWallet.end()) {\n@@ -283,7 +275,6 @@ class WalletImpl : public Wallet\n     }\n     WalletTx getWalletTx(const uint256& txid) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         auto mi = m_wallet->mapWallet.find(txid);\n         if (mi != m_wallet->mapWallet.end()) {\n@@ -293,7 +284,6 @@ class WalletImpl : public Wallet\n     }\n     std::vector<WalletTx> getWalletTxs() override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         std::vector<WalletTx> result;\n         result.reserve(m_wallet->mapWallet.size());\n@@ -307,10 +297,6 @@ class WalletImpl : public Wallet\n         int& num_blocks,\n         int64_t& block_time) override\n     {\n-        auto locked_chain = m_wallet->chain().lock(true /* try_lock */);\n-        if (!locked_chain) {\n-            return false;\n-        }\n         TRY_LOCK(m_wallet->cs_wallet, locked_wallet);\n         if (!locked_wallet) {\n             return false;\n@@ -331,7 +317,6 @@ class WalletImpl : public Wallet\n         bool& in_mempool,\n         int& num_blocks) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         auto mi = m_wallet->mapWallet.find(txid);\n         if (mi != m_wallet->mapWallet.end()) {\n@@ -368,8 +353,6 @@ class WalletImpl : public Wallet\n     }\n     bool tryGetBalances(WalletBalances& balances, int& num_blocks, bool force, int cached_num_blocks) override\n     {\n-        auto locked_chain = m_wallet->chain().lock(true /* try_lock */);\n-        if (!locked_chain) return false;\n         TRY_LOCK(m_wallet->cs_wallet, locked_wallet);\n         if (!locked_wallet) {\n             return false;\n@@ -386,31 +369,26 @@ class WalletImpl : public Wallet\n     }\n     isminetype txinIsMine(const CTxIn& txin) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->IsMine(txin);\n     }\n     isminetype txoutIsMine(const CTxOut& txout) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->IsMine(txout);\n     }\n     CAmount getDebit(const CTxIn& txin, isminefilter filter) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->GetDebit(txin, filter);\n     }\n     CAmount getCredit(const CTxOut& txout, isminefilter filter) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         return m_wallet->GetCredit(txout, filter);\n     }\n     CoinsList listCoins() override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         CoinsList result;\n         for (const auto& entry : m_wallet->ListCoins()) {\n@@ -424,7 +402,6 @@ class WalletImpl : public Wallet\n     }\n     std::vector<WalletTxOut> getCoins(const std::vector<COutPoint>& outputs) override\n     {\n-        auto locked_chain = m_wallet->chain().lock();\n         LOCK(m_wallet->cs_wallet);\n         std::vector<WalletTxOut> result;\n         result.reserve(outputs.size());\n@@ -496,6 +473,7 @@ class WalletImpl : public Wallet\n     {\n         return MakeHandler(m_wallet->NotifyCanGetAddressesChanged.connect(fn));\n     }\n+    CWallet* wallet() override { return m_wallet.get(); }\n \n     std::shared_ptr<CWallet> m_wallet;\n };"
      },
      {
        "sha": "e5e3b8066384667cf944d30b83305f8c123907db",
        "filename": "src/interfaces/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/interfaces/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.h?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -300,6 +300,9 @@ class Wallet\n     //! Register handler for keypool changed messages.\n     using CanGetAddressesChangedFn = std::function<void()>;\n     virtual std::unique_ptr<Handler> handleCanGetAddressesChanged(CanGetAddressesChangedFn fn) = 0;\n+\n+    //! Return pointer to internal wallet class, useful for testing.\n+    virtual CWallet* wallet() { return nullptr; }\n };\n \n //! Information about one wallet address."
      },
      {
        "sha": "2ee9ae0d8667764f6ac3e0ffa7adf59f8ae66299",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -145,7 +145,6 @@ void TestGUI(interfaces::Node& node)\n     wallet->LoadWallet(firstRun);\n     {\n         auto spk_man = wallet->GetOrCreateLegacyScriptPubKeyMan();\n-        auto locked_chain = wallet->chain().lock();\n         LOCK2(wallet->cs_wallet, spk_man->cs_KeyStore);\n         wallet->SetAddressBook(GetDestinationForKey(test.coinbaseKey.GetPubKey(), wallet->m_default_address_type), \"\", \"receive\");\n         spk_man->AddKeyPubKey(test.coinbaseKey, test.coinbaseKey.GetPubKey());"
      },
      {
        "sha": "01fcb1680e7bb2a2708b78bc97f20adf12ac8f43",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -140,7 +140,6 @@ namespace feebumper {\n \n bool TransactionCanBeBumped(const CWallet& wallet, const uint256& txid)\n {\n-    auto locked_chain = wallet.chain().lock();\n     LOCK(wallet.cs_wallet);\n     const CWalletTx* wtx = wallet.GetWalletTx(txid);\n     if (wtx == nullptr) return false;\n@@ -156,7 +155,6 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     // We are going to modify coin control later, copy to re-use\n     CCoinControl new_coin_control(coin_control);\n \n-    auto locked_chain = wallet.chain().lock();\n     LOCK(wallet.cs_wallet);\n     errors.clear();\n     auto it = wallet.mapWallet.find(txid);\n@@ -240,14 +238,12 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n }\n \n bool SignTransaction(CWallet& wallet, CMutableTransaction& mtx) {\n-    auto locked_chain = wallet.chain().lock();\n     LOCK(wallet.cs_wallet);\n     return wallet.SignTransaction(mtx);\n }\n \n Result CommitTransaction(CWallet& wallet, const uint256& txid, CMutableTransaction&& mtx, std::vector<std::string>& errors, uint256& bumped_txid)\n {\n-    auto locked_chain = wallet.chain().lock();\n     LOCK(wallet.cs_wallet);\n     if (!errors.empty()) {\n         return Result::MISC_ERROR;"
      },
      {
        "sha": "c863d2253075ff8e475e4b5e1cea9964e223c9ba",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 15,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -133,7 +133,6 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     WalletRescanReserver reserver(*pwallet);\n     bool fRescan = true;\n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n \n         EnsureWalletIsUnlocked(pwallet);\n@@ -285,7 +284,6 @@ UniValue importaddress(const JSONRPCRequest& request)\n         fP2SH = request.params[3].get_bool();\n \n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n \n         CTxDestination dest = DecodeDestination(request.params[0].get_str());\n@@ -317,7 +315,6 @@ UniValue importaddress(const JSONRPCRequest& request)\n     {\n         RescanWallet(*pwallet, reserver);\n         {\n-            auto locked_chain = pwallet->chain().lock();\n             LOCK(pwallet->cs_wallet);\n             pwallet->ReacceptWalletTransactions();\n         }\n@@ -361,7 +358,6 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Something wrong with merkleblock\");\n     }\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n     int height;\n     if (!pwallet->chain().findAncestorByHash(pwallet->GetLastBlockHash(), merkleBlock.header.GetHash(), FoundBlock().height(height))) {\n@@ -407,7 +403,6 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     uint256 hash(ParseHashV(request.params[0], \"txid\"));\n@@ -487,7 +482,6 @@ UniValue importpubkey(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n \n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n \n         std::set<CScript> script_pub_keys;\n@@ -505,7 +499,6 @@ UniValue importpubkey(const JSONRPCRequest& request)\n     {\n         RescanWallet(*pwallet, reserver);\n         {\n-            auto locked_chain = pwallet->chain().lock();\n             LOCK(pwallet->cs_wallet);\n             pwallet->ReacceptWalletTransactions();\n         }\n@@ -557,7 +550,6 @@ UniValue importwallet(const JSONRPCRequest& request)\n     int64_t nTimeBegin = 0;\n     bool fGood = true;\n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n \n         EnsureWalletIsUnlocked(pwallet);\n@@ -700,7 +692,6 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n \n     LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*wallet);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n     EnsureWalletIsUnlocked(pwallet);\n@@ -756,7 +747,6 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     wallet.BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n     EnsureWalletIsUnlocked(&wallet);\n@@ -780,7 +770,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n     std::map<CKeyID, int64_t> mapKeyBirth;\n     const std::map<CKeyID, int64_t>& mapKeyPool = spk_man.GetAllReserveKeys();\n-    pwallet->GetKeyBirthTimes(*locked_chain, mapKeyBirth);\n+    pwallet->GetKeyBirthTimes(mapKeyBirth);\n \n     std::set<CScriptID> scripts = spk_man.GetCScripts();\n \n@@ -1379,7 +1369,6 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     int64_t nLowestTimestamp = 0;\n     UniValue response(UniValue::VARR);\n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n         EnsureWalletIsUnlocked(pwallet);\n \n@@ -1414,7 +1403,6 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     if (fRescan && fRunScan && requests.size()) {\n         int64_t scannedTime = pwallet->RescanFromTime(nLowestTimestamp, reserver, true /* update */);\n         {\n-            auto locked_chain = pwallet->chain().lock();\n             LOCK(pwallet->cs_wallet);\n             pwallet->ReacceptWalletTransactions();\n         }\n@@ -1676,7 +1664,6 @@ UniValue importdescriptors(const JSONRPCRequest& main_request) {\n     bool rescan = false;\n     UniValue response(UniValue::VARR);\n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n         EnsureWalletIsUnlocked(pwallet);\n \n@@ -1705,7 +1692,6 @@ UniValue importdescriptors(const JSONRPCRequest& main_request) {\n     if (rescan) {\n         int64_t scanned_time = pwallet->RescanFromTime(lowest_timestamp, reserver, true /* update */);\n         {\n-            auto locked_chain = pwallet->chain().lock();\n             LOCK(pwallet->cs_wallet);\n             pwallet->ReacceptWalletTransactions();\n         }"
      },
      {
        "sha": "91162d575dc667015d662005432349458a7e6096",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 44,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -133,7 +133,7 @@ LegacyScriptPubKeyMan& EnsureLegacyScriptPubKeyMan(CWallet& wallet, bool also_cr\n     return *spk_man;\n }\n \n-static void WalletTxToJSON(interfaces::Chain& chain, interfaces::Chain::Lock& locked_chain, const CWalletTx& wtx, UniValue& entry)\n+static void WalletTxToJSON(interfaces::Chain& chain, const CWalletTx& wtx, UniValue& entry)\n {\n     int confirms = wtx.GetDepthInMainChain();\n     entry.pushKV(\"confirmations\", confirms);\n@@ -399,7 +399,6 @@ static UniValue sendtoaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     CTxDestination dest = DecodeDestination(request.params[0].get_str());\n@@ -487,11 +486,10 @@ static UniValue listaddressgroupings(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances(*locked_chain);\n+    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n     for (const std::set<CTxDestination>& grouping : pwallet->GetAddressGroupings()) {\n         UniValue jsonGrouping(UniValue::VARR);\n         for (const CTxDestination& address : grouping)\n@@ -543,7 +541,6 @@ static UniValue signmessage(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     EnsureWalletIsUnlocked(pwallet);\n@@ -652,7 +649,6 @@ static UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     return ValueFromAmount(GetReceived(*pwallet, request.params, /* by_label */ false));\n@@ -693,7 +689,6 @@ static UniValue getreceivedbylabel(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     return ValueFromAmount(GetReceived(*pwallet, request.params, /* by_label */ true));\n@@ -736,7 +731,6 @@ static UniValue getbalance(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     const UniValue& dummy_value = request.params[0];\n@@ -778,7 +772,6 @@ static UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     return ValueFromAmount(pwallet->GetBalance().m_mine_untrusted_pending);\n@@ -841,7 +834,6 @@ static UniValue sendmany(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     if (!request.params[0].isNull() && !request.params[0].get_str().empty()) {\n@@ -963,7 +955,6 @@ static UniValue addmultisigaddress(const JSONRPCRequest& request)\n \n     LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n     std::string label;\n@@ -1016,7 +1007,7 @@ struct tallyitem\n     }\n };\n \n-static UniValue ListReceived(interfaces::Chain::Lock& locked_chain, const CWallet* const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ListReceived(const CWallet* const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -1209,10 +1200,9 @@ static UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(*locked_chain, pwallet, request.params, false);\n+    return ListReceived(pwallet, request.params, false);\n }\n \n static UniValue listreceivedbylabel(const JSONRPCRequest& request)\n@@ -1254,10 +1244,9 @@ static UniValue listreceivedbylabel(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(*locked_chain, pwallet, request.params, true);\n+    return ListReceived(pwallet, request.params, true);\n }\n \n static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n@@ -1278,7 +1267,7 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n  * @param  filter_ismine  The \"is mine\" filter flags.\n  * @param  filter_label   Optional label string to filter incoming transactions.\n  */\n-static void ListTransactions(interfaces::Chain::Lock& locked_chain, const CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     CAmount nFee;\n     std::list<COutputEntry> listReceived;\n@@ -1307,7 +1296,7 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, const CWalle\n             entry.pushKV(\"vout\", s.vout);\n             entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n             if (fLong)\n-                WalletTxToJSON(pwallet->chain(), locked_chain, wtx, entry);\n+                WalletTxToJSON(pwallet->chain(), wtx, entry);\n             entry.pushKV(\"abandoned\", wtx.isAbandoned());\n             ret.push_back(entry);\n         }\n@@ -1349,7 +1338,7 @@ static void ListTransactions(interfaces::Chain::Lock& locked_chain, const CWalle\n             }\n             entry.pushKV(\"vout\", r.vout);\n             if (fLong)\n-                WalletTxToJSON(pwallet->chain(), locked_chain, wtx, entry);\n+                WalletTxToJSON(pwallet->chain(), wtx, entry);\n             ret.push_back(entry);\n         }\n     }\n@@ -1464,7 +1453,6 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     UniValue ret(UniValue::VARR);\n \n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n \n         const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;\n@@ -1473,7 +1461,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n         for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n             CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(*locked_chain, pwallet, *pwtx, 0, true, ret, filter, filter_label);\n+            ListTransactions(pwallet, *pwtx, 0, true, ret, filter, filter_label);\n             if ((int)ret.size() >= (nCount+nFrom)) break;\n         }\n     }\n@@ -1557,7 +1545,6 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     // The way the 'height' is initialized is just a workaround for the gcc bug #47679 since version 4.6.0.\n@@ -1598,7 +1585,7 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n         CWalletTx tx = pairWtx.second;\n \n         if (depth == -1 || abs(tx.GetDepthInMainChain()) < depth) {\n-            ListTransactions(*locked_chain, pwallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n+            ListTransactions(pwallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n         }\n     }\n \n@@ -1615,7 +1602,7 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n             if (it != pwallet->mapWallet.end()) {\n                 // We want all transactions regardless of confirmation count to appear here,\n                 // even negative confirmation ones, hence the big negative.\n-                ListTransactions(*locked_chain, pwallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n+                ListTransactions(pwallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n             }\n         }\n         blockId = block.hashPrevBlock;\n@@ -1700,7 +1687,6 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     uint256 hash(ParseHashV(request.params[0], \"txid\"));\n@@ -1729,10 +1715,10 @@ static UniValue gettransaction(const JSONRPCRequest& request)\n     if (wtx.IsFromMe(filter))\n         entry.pushKV(\"fee\", ValueFromAmount(nFee));\n \n-    WalletTxToJSON(pwallet->chain(), *locked_chain, wtx, entry);\n+    WalletTxToJSON(pwallet->chain(), wtx, entry);\n \n     UniValue details(UniValue::VARR);\n-    ListTransactions(*locked_chain, pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n+    ListTransactions(pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n     entry.pushKV(\"details\", details);\n \n     std::string strHex = EncodeHexTx(*wtx.tx, pwallet->chain().rpcSerializationFlags());\n@@ -1776,7 +1762,6 @@ static UniValue abandontransaction(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     uint256 hash(ParseHashV(request.params[0], \"txid\"));\n@@ -1817,7 +1802,6 @@ static UniValue backupwallet(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     std::string strDest = request.params[0].get_str();\n@@ -1855,7 +1839,6 @@ static UniValue keypoolrefill(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Private keys are disabled for this wallet\");\n     }\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n@@ -1909,7 +1892,6 @@ static UniValue walletpassphrase(const JSONRPCRequest& request)\n \n     int64_t nSleepTime;\n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n \n         if (!pwallet->IsCrypted()) {\n@@ -1991,7 +1973,6 @@ static UniValue walletpassphrasechange(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     if (!pwallet->IsCrypted()) {\n@@ -2047,7 +2028,6 @@ static UniValue walletlock(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     if (!pwallet->IsCrypted()) {\n@@ -2094,7 +2074,6 @@ static UniValue encryptwallet(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n@@ -2173,7 +2152,6 @@ static UniValue lockunspent(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     RPCTypeCheckArgument(request.params[0], UniValue::VBOOL);\n@@ -2286,7 +2264,6 @@ static UniValue listlockunspent(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     std::vector<COutPoint> vOutpts;\n@@ -2329,7 +2306,6 @@ static UniValue settxfee(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     CAmount nAmount = AmountFromValue(request.params[0]);\n@@ -2388,7 +2364,6 @@ static UniValue getbalances(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     wallet.BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = wallet.chain().lock();\n     LOCK(wallet.cs_wallet);\n \n     const auto bal = wallet.GetBalance();\n@@ -2465,7 +2440,6 @@ static UniValue getwalletinfo(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n     UniValue obj(UniValue::VOBJ);\n@@ -2940,7 +2914,6 @@ static UniValue listunspent(const JSONRPCRequest& request)\n         cctl.m_avoid_address_reuse = false;\n         cctl.m_min_depth = nMinDepth;\n         cctl.m_max_depth = nMaxDepth;\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n         pwallet->AvailableCoins(vecOutputs, !include_unsafe, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n     }\n@@ -3312,7 +3285,6 @@ UniValue signrawtransactionwithwallet(const JSONRPCRequest& request)\n     }\n \n     // Sign the transaction\n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -3441,7 +3413,6 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n@@ -3548,7 +3519,6 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     Optional<int> stop_height;\n     uint256 start_block;\n     {\n-        auto locked_chain = pwallet->chain().lock();\n         LOCK(pwallet->cs_wallet);\n         int tip_height = pwallet->GetLastBlockHeight();\n \n@@ -4010,7 +3980,6 @@ UniValue sethdseed(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed to a wallet with private keys disabled\");\n     }\n \n-    auto locked_chain = pwallet->chain().lock();\n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n     // Do not do anything to non-HD wallets"
      },
      {
        "sha": "c049f2f15f25b37712304c2c3e2562b7d27f07ef",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 42,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -75,8 +75,6 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n \n     NodeContext node;\n     auto chain = interfaces::MakeChain(node);\n-    auto locked_chain = chain->lock();\n-    LockAssertion lock(::cs_main);\n \n     // Verify ScanForWalletTransactions fails to read an unknown start block.\n     {\n@@ -116,7 +114,10 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n     }\n \n     // Prune the older block file.\n-    PruneOneBlockFile(oldTip->GetBlockPos().nFile);\n+    {\n+        LOCK(cs_main);\n+        PruneOneBlockFile(oldTip->GetBlockPos().nFile);\n+    }\n     UnlinkPrunedFiles({oldTip->GetBlockPos().nFile});\n \n     // Verify ScanForWalletTransactions only picks transactions in the new block\n@@ -139,7 +140,10 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n     }\n \n     // Prune the remaining block file.\n-    PruneOneBlockFile(newTip->GetBlockPos().nFile);\n+    {\n+        LOCK(cs_main);\n+        PruneOneBlockFile(newTip->GetBlockPos().nFile);\n+    }\n     UnlinkPrunedFiles({newTip->GetBlockPos().nFile});\n \n     // Verify ScanForWalletTransactions scans no blocks.\n@@ -171,11 +175,12 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n \n     NodeContext node;\n     auto chain = interfaces::MakeChain(node);\n-    auto locked_chain = chain->lock();\n-    LockAssertion lock(::cs_main);\n \n     // Prune the older block file.\n-    PruneOneBlockFile(oldTip->GetBlockPos().nFile);\n+    {\n+        LOCK(cs_main);\n+        PruneOneBlockFile(oldTip->GetBlockPos().nFile);\n+    }\n     UnlinkPrunedFiles({oldTip->GetBlockPos().nFile});\n \n     // Verify importmulti RPC returns failure for a key whose creation time is\n@@ -241,8 +246,6 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n \n     NodeContext node;\n     auto chain = interfaces::MakeChain(node);\n-    auto locked_chain = chain->lock();\n-    LockAssertion lock(::cs_main);\n \n     std::string backup_file = (GetDataDir() / \"wallet.backup\").string();\n \n@@ -308,8 +311,6 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n     auto spk_man = wallet.GetOrCreateLegacyScriptPubKeyMan();\n     CWalletTx wtx(&wallet, m_coinbase_txns.back());\n \n-    auto locked_chain = chain->lock();\n-    LockAssertion lock(::cs_main);\n     LOCK2(wallet.cs_wallet, spk_man->cs_KeyStore);\n     wallet.SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());\n \n@@ -334,8 +335,6 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n     SetMockTime(mockTime);\n     CBlockIndex* block = nullptr;\n     if (blockTime > 0) {\n-        auto locked_chain = wallet.chain().lock();\n-        LockAssertion lock(::cs_main);\n         auto inserted = ::BlockIndex().emplace(GetRandHash(), new CBlockIndex);\n         assert(inserted.second);\n         const uint256& hash = inserted.first->first;\n@@ -345,7 +344,6 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n     }\n \n     CWalletTx wtx(&wallet, MakeTransactionRef(tx));\n-    LOCK(cs_main);\n     LOCK(wallet.cs_wallet);\n     // If transaction is already in map, to avoid inconsistencies, unconfirmation\n     // is needed before confirm again with different block.\n@@ -492,7 +490,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n         wallet = MakeUnique<CWallet>(m_chain.get(), WalletLocation(), WalletDatabase::CreateMock());\n         {\n-            LOCK2(::cs_main, wallet->cs_wallet);\n+            LOCK2(wallet->cs_wallet, ::cs_main);\n             wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());\n         }\n         bool firstRun;\n@@ -520,7 +518,6 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         std::string error;\n         CCoinControl dummy;\n         {\n-            auto locked_chain = m_chain->lock();\n             BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, changePos, error, dummy));\n         }\n         wallet->CommitTransaction(tx, {}, {});\n@@ -531,7 +528,6 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         }\n         CreateAndProcessBlock({CMutableTransaction(blocktx)}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n \n-        LOCK(cs_main);\n         LOCK(wallet->cs_wallet);\n         wallet->SetLastBlockProcessed(wallet->GetLastBlockHeight() + 1, ::ChainActive().Tip()->GetBlockHash());\n         auto it = wallet->mapWallet.find(tx->GetHash());\n@@ -554,7 +550,6 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     // address.\n     std::map<CTxDestination, std::vector<COutput>> list;\n     {\n-        auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         list = wallet->ListCoins();\n     }\n@@ -571,7 +566,6 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     // pubkey.\n     AddTx(CRecipient{GetScriptForRawPubKey({}), 1 * COIN, false /* subtract fee */});\n     {\n-        auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         list = wallet->ListCoins();\n     }\n@@ -581,7 +575,6 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n \n     // Lock both coins. Confirm number of available coins drops to 0.\n     {\n-        auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n         wallet->AvailableCoins(available);\n@@ -594,7 +587,6 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n         }\n     }\n     {\n-        auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n         wallet->AvailableCoins(available);\n@@ -603,7 +595,6 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     // Confirm ListCoins still returns same result as before, despite coins\n     // being locked.\n     {\n-        auto locked_chain = m_chain->lock();\n         LOCK(wallet->cs_wallet);\n         list = wallet->ListCoins();\n     }\n@@ -694,11 +685,20 @@ BOOST_FIXTURE_TEST_CASE(wallet_descriptor_test, BasicTestingSetup)\n //! conditions if it's called the same time an incoming transaction shows up in\n //! the mempool or a new block.\n //!\n-//! It isn't possible for a unit test to totally verify there aren't race\n-//! conditions without hooking into the implementation more, so this test just\n-//! verifies that new transactions are detected during loading without any\n-//! notifications at all, to infer that timing of notifications shouldn't\n-//! matter. The test could be extended to cover other scenarios in the future.\n+//! It isn't possible to verify there aren't race condition in every case, so\n+//! this test just checks two specific cases and ensures that timing of\n+//! notifications in these cases doesn't prevent the wallet from detecting\n+//! transactions.\n+//!\n+//! In the first case, block and mempool transactions are created before the\n+//! wallet is loaded, but notifications about these transactions are delayed\n+//! until after it is loaded. The notifications are superfluous in this case, so\n+//! the test verifies the transactions are detected before they arrive.\n+//!\n+//! In the second case, block and mempool transactions are created after the\n+//! wallet rescan and notifications are immediately synced, to verify the wallet\n+//! must already have a handler in place for them, and there's no gap after\n+//! rescanning where new transactions in new blocks could be lost.\n BOOST_FIXTURE_TEST_CASE(CreateWalletFromFile, TestChain100Setup)\n {\n     // Create new wallet with known key and unload it.\n@@ -709,6 +709,7 @@ BOOST_FIXTURE_TEST_CASE(CreateWalletFromFile, TestChain100Setup)\n     AddKey(*wallet, key);\n     TestUnloadWallet(std::move(wallet));\n \n+\n     // Add log hook to detect AddToWallet events from rescans, blockConnected,\n     // and transactionAddedToMempool notifications\n     int addtx_count = 0;\n@@ -717,21 +718,14 @@ BOOST_FIXTURE_TEST_CASE(CreateWalletFromFile, TestChain100Setup)\n         return false;\n     });\n \n+\n     bool rescan_completed = false;\n     DebugLogHelper rescan_check(\"[default wallet] Rescan completed\", [&](const std::string* s) {\n-        if (s) {\n-            // For now, just assert that cs_main is being held during the\n-            // rescan, ensuring that a new block couldn't be connected\n-            // that the wallet would miss. After\n-            // https://github.com/bitcoin/bitcoin/pull/16426 when cs_main is no\n-            // longer held, the test can be extended to append a new block here\n-            // and check it's handled correctly.\n-            AssertLockHeld(::cs_main);\n-            rescan_completed = true;\n-        }\n+        if (s) rescan_completed = true;\n         return false;\n     });\n \n+\n     // Block the queue to prevent the wallet receiving blockConnected and\n     // transactionAddedToMempool notifications, and create block and mempool\n     // transactions paying to the wallet\n@@ -746,29 +740,56 @@ BOOST_FIXTURE_TEST_CASE(CreateWalletFromFile, TestChain100Setup)\n     auto mempool_tx = TestSimpleSpend(*m_coinbase_txns[1], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n     BOOST_CHECK(chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));\n \n+\n     // Reload wallet and make sure new transactions are detected despite events\n     // being blocked\n     wallet = TestLoadWallet(*chain);\n     BOOST_CHECK(rescan_completed);\n     BOOST_CHECK_EQUAL(addtx_count, 2);\n-    unsigned int block_tx_time, mempool_tx_time;\n     {\n         LOCK(wallet->cs_wallet);\n-        block_tx_time = wallet->mapWallet.at(block_tx.GetHash()).nTimeReceived;\n-        mempool_tx_time = wallet->mapWallet.at(mempool_tx.GetHash()).nTimeReceived;\n+        BOOST_CHECK_EQUAL(wallet->mapWallet.count(block_tx.GetHash()), 1);\n+        BOOST_CHECK_EQUAL(wallet->mapWallet.count(mempool_tx.GetHash()), 1);\n     }\n \n+\n     // Unblock notification queue and make sure stale blockConnected and\n     // transactionAddedToMempool events are processed\n     promise.set_value();\n     SyncWithValidationInterfaceQueue();\n     BOOST_CHECK_EQUAL(addtx_count, 4);\n+\n+\n+    TestUnloadWallet(std::move(wallet));\n+\n+\n+    // Load wallet again, this time creating new block and mempool transactions\n+    // paying to the wallet as the wallet finishes loading and syncing the\n+    // queue so the events have to be handled immediately. Releasing the wallet\n+    // lock during the sync is a little artificial but is needed to avoid a\n+    // deadlock during the sync and simulates a new block notification happening\n+    // as soon as possible.\n+    addtx_count = 0;\n+    auto handler = HandleLoadWallet([&](std::unique_ptr<interfaces::Wallet> wallet) EXCLUSIVE_LOCKS_REQUIRED(wallet->wallet()->cs_wallet) {\n+            BOOST_CHECK(rescan_completed);\n+            m_coinbase_txns.push_back(CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+            block_tx = TestSimpleSpend(*m_coinbase_txns[2], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n+            m_coinbase_txns.push_back(CreateAndProcessBlock({block_tx}, GetScriptForRawPubKey(coinbaseKey.GetPubKey())).vtx[0]);\n+            mempool_tx = TestSimpleSpend(*m_coinbase_txns[3], 0, coinbaseKey, GetScriptForRawPubKey(key.GetPubKey()));\n+            BOOST_CHECK(chain->broadcastTransaction(MakeTransactionRef(mempool_tx), DEFAULT_TRANSACTION_MAXFEE, false, error));\n+            LEAVE_CRITICAL_SECTION(wallet->wallet()->cs_wallet);\n+            SyncWithValidationInterfaceQueue();\n+            ENTER_CRITICAL_SECTION(wallet->wallet()->cs_wallet);\n+        });\n+    wallet = TestLoadWallet(*chain);\n+    BOOST_CHECK_EQUAL(addtx_count, 4);\n     {\n         LOCK(wallet->cs_wallet);\n-        BOOST_CHECK_EQUAL(block_tx_time, wallet->mapWallet.at(block_tx.GetHash()).nTimeReceived);\n-        BOOST_CHECK_EQUAL(mempool_tx_time, wallet->mapWallet.at(mempool_tx.GetHash()).nTimeReceived);\n+        BOOST_CHECK_EQUAL(wallet->mapWallet.count(block_tx.GetHash()), 1);\n+        BOOST_CHECK_EQUAL(wallet->mapWallet.count(mempool_tx.GetHash()), 1);\n     }\n \n+\n     TestUnloadWallet(std::move(wallet));\n }\n "
      },
      {
        "sha": "a20ede59fd46c309156d7a114185fa2b7f0e0dd1",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 34,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -974,7 +974,6 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Co\n \n bool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n     const CWalletTx* wtx = GetWalletTx(hashTx);\n     return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() == 0 && !wtx->InMempool();\n@@ -992,7 +991,6 @@ void CWallet::MarkInputsDirty(const CTransactionRef& tx)\n \n bool CWallet::AbandonTransaction(const uint256& hashTx)\n {\n-    auto locked_chain = chain().lock(); // Temporary. Removed in upcoming lock cleanup\n     LOCK(cs_wallet);\n \n     WalletBatch batch(*database, \"r+\");\n@@ -1047,7 +1045,6 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n \n void CWallet::MarkConflicted(const uint256& hashBlock, int conflicting_height, const uint256& hashTx)\n {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     int conflictconfirms = (m_last_block_processed_height - conflicting_height + 1) * -1;\n@@ -1110,7 +1107,6 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, CWalletTx::Confirmatio\n }\n \n void CWallet::transactionAddedToMempool(const CTransactionRef& ptx) {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n     CWalletTx::Confirmation confirm(CWalletTx::Status::UNCONFIRMED, /* block_height */ 0, {}, /* nIndex */ 0);\n     SyncTransaction(ptx, confirm);\n@@ -1132,7 +1128,6 @@ void CWallet::transactionRemovedFromMempool(const CTransactionRef &ptx) {\n void CWallet::blockConnected(const CBlock& block, int height)\n {\n     const uint256& block_hash = block.GetHash();\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     m_last_block_processed_height = height;\n@@ -1146,7 +1141,6 @@ void CWallet::blockConnected(const CBlock& block, int height)\n \n void CWallet::blockDisconnected(const CBlock& block, int height)\n {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     // At block disconnection, this will change an abandoned transaction to\n@@ -1685,7 +1679,6 @@ CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_bloc\n         uint256 next_block_hash;\n         bool reorg = false;\n         if (chain().findBlock(block_hash, FoundBlock().data(block)) && !block.IsNull()) {\n-            auto locked_chain = chain().lock();\n             LOCK(cs_wallet);\n             next_block = chain().findNextBlock(block_hash, block_height, FoundBlock().hash(next_block_hash), &reorg);\n             if (reorg) {\n@@ -1714,7 +1707,6 @@ CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_bloc\n             break;\n         }\n         {\n-            auto locked_chain = chain().lock();\n             if (!next_block || reorg) {\n                 // break successfully when rescan has reached the tip, or\n                 // previous block is no longer on the chain due to a reorg\n@@ -2002,8 +1994,7 @@ void CWallet::ResendWalletTransactions()\n \n     int submitted_tx_count = 0;\n \n-    { // locked_chain and cs_wallet scope\n-        auto locked_chain = chain().lock();\n+    { // cs_wallet scope\n         LOCK(cs_wallet);\n \n         // Relay transactions\n@@ -2016,7 +2007,7 @@ void CWallet::ResendWalletTransactions()\n             std::string unused_err_string;\n             if (wtx.SubmitMemoryPoolAndRelay(unused_err_string, true)) ++submitted_tx_count;\n         }\n-    } // locked_chain and cs_wallet\n+    } // cs_wallet\n \n     if (submitted_tx_count > 0) {\n         WalletLogPrintf(\"%s: resubmit %u unconfirmed transactions\\n\", __func__, submitted_tx_count);\n@@ -2044,7 +2035,6 @@ CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) cons\n     Balance ret;\n     isminefilter reuse_filter = avoid_reuse ? ISMINE_NO : ISMINE_USED;\n     {\n-        auto locked_chain = chain().lock();\n         LOCK(cs_wallet);\n         std::set<uint256> trusted_parents;\n         for (const auto& entry : mapWallet)\n@@ -2071,7 +2061,6 @@ CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) cons\n \n CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     CAmount balance = 0;\n@@ -2550,7 +2539,6 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n     // Acquire the locks to prevent races to the new locked unspents between the\n     // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     CTransactionRef tx_new;\n@@ -2701,7 +2689,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n     int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n-        auto locked_chain = chain().lock();\n         LOCK(cs_wallet);\n         txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n         {\n@@ -3019,7 +3006,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n \n void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm)\n {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     CWalletTx wtxNew(this, std::move(tx));\n@@ -3059,11 +3045,6 @@ void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n \n DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n {\n-    // Even if we don't use this lock in this function, we want to preserve\n-    // lock order in LoadToWallet if query of chain state is needed to know\n-    // tx status. If lock can't be taken (e.g bitcoin-wallet), tx confirmation\n-    // status may be not reliable.\n-    auto locked_chain = LockChain();\n     LOCK(cs_wallet);\n \n     fFirstRunRet = false;\n@@ -3282,7 +3263,7 @@ void CWallet::MarkDestinationsDirty(const std::set<CTxDestination>& destinations\n     }\n }\n \n-std::map<CTxDestination, CAmount> CWallet::GetAddressBalances(interfaces::Chain::Lock& locked_chain) const\n+std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n {\n     std::map<CTxDestination, CAmount> balances;\n \n@@ -3509,7 +3490,7 @@ void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n \n /** @} */ // end of Actions\n \n-void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<CKeyID, int64_t>& mapKeyBirth) const {\n+void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n     AssertLockHeld(cs_wallet);\n     mapKeyBirth.clear();\n \n@@ -3719,11 +3700,6 @@ bool CWallet::Verify(interfaces::Chain& chain, const WalletLocation& location, b\n         // Recover readable keypairs:\n         CWallet dummyWallet(&chain, WalletLocation(), WalletDatabase::CreateDummy());\n         std::string backup_filename;\n-        // Even if we don't use this lock in this function, we want to preserve\n-        // lock order in LoadToWallet if query of chain state is needed to know\n-        // tx status. If lock can't be taken, tx confirmation status may be not\n-        // reliable.\n-        auto locked_chain = dummyWallet.LockChain();\n         if (!WalletBatch::Recover(wallet_path, (void *)&dummyWallet, WalletBatch::RecoverKeysOnlyFilter, backup_filename)) {\n             return false;\n         }\n@@ -3812,7 +3788,6 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n             }\n         }\n \n-        auto locked_chain = chain.lock();\n         walletInstance->chainStateFlushed(chain.getTipLocator());\n     } else if (wallet_creation_flags & WALLET_FLAG_DISABLE_PRIVATE_KEYS) {\n         // Make it impossible to disable private keys after creation\n@@ -3926,9 +3901,18 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n-    auto locked_chain = chain.lock();\n     LOCK(walletInstance->cs_wallet);\n \n+    // Register wallet with validationinterface. It's done before rescan to avoid\n+    // missing block connections between end of rescan and validation subscribing.\n+    // Because of wallet lock being hold, block connection notifications are going to\n+    // be pending on the validation-side until lock release. It's likely to have\n+    // block processing duplicata (if rescan block range overlaps with notification one)\n+    // but we guarantee at least than wallet state is correct after notifications delivery.\n+    // This is temporary until rescan and notifications delivery are unified under same\n+    // interface.\n+    walletInstance->m_chain_notifications_handler = walletInstance->chain().handleNotifications(walletInstance);\n+\n     int rescan_height = 0;\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {\n@@ -4029,9 +4013,6 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         }\n     }\n \n-    // Register with the validation interface. It's ok to do this after rescan since we're still holding locked_chain.\n-    walletInstance->m_chain_notifications_handler = walletInstance->chain().handleNotifications(walletInstance);\n-\n     walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n \n     {\n@@ -4091,7 +4072,6 @@ bool CWallet::UpgradeWallet(int version, std::string& error, std::vector<std::st\n \n void CWallet::postInitProcess()\n {\n-    auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n     // Add wallet transactions that aren't already in a block to mempool"
      },
      {
        "sha": "72b3cf1fb8510b33bf5d1f48f4d72393324e2e19",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a72f26968cf931c985d8d4797b6264274cabd06/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6a72f26968cf931c985d8d4797b6264274cabd06",
        "patch": "@@ -775,9 +775,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool IsLocked() const override;\n     bool Lock();\n \n-    /** Interface to assert chain access and if successful lock it */\n-    std::unique_ptr<interfaces::Chain::Lock> LockChain() { return m_chain ? m_chain->lock() : nullptr; }\n-\n     /** Interface to assert chain access */\n     bool HaveChain() const { return m_chain ? true : false; }\n \n@@ -878,7 +875,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);\n     bool EncryptWallet(const SecureString& strWalletPassphrase);\n \n-    void GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<CKeyID, int64_t> &mapKeyBirth) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    void GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     unsigned int ComputeTimeSmart(const CWalletTx& wtx) const;\n \n     /**\n@@ -1014,7 +1011,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     int64_t GetOldestKeyPoolTime() const;\n \n     std::set<std::set<CTxDestination>> GetAddressGroupings() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    std::map<CTxDestination, CAmount> GetAddressBalances(interfaces::Chain::Lock& locked_chain) const;\n+    std::map<CTxDestination, CAmount> GetAddressBalances() const;\n \n     std::set<CTxDestination> GetLabelAddresses(const std::string& label) const;\n "
      }
    ]
  }
]