[
  {
    "sha": "b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiN2I0OGM4YmJkZjdhOTA4NjE2MTBiMDM1ZDhiMGEyNDdlZjc4YzQ1",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-01-27T08:43:41Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-01-27T09:13:20Z"
      },
      "message": "Refactor: Remove using namespace <xxx> from src/*.cpp.",
      "tree": {
        "sha": "76e6ff7c7547127960ff5e603da95b669cbfdb26",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/76e6ff7c7547127960ff5e603da95b669cbfdb26"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9b4d2673b7757fd242b13c972c73897c92a90ce1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b4d2673b7757fd242b13c972c73897c92a90ce1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9b4d2673b7757fd242b13c972c73897c92a90ce1"
      }
    ],
    "stats": {
      "total": 385,
      "additions": 179,
      "deletions": 206
    },
    "files": [
      {
        "sha": "8d47cb76e8a58bebaf10b494776d240ea6793ca5",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -19,23 +19,21 @@\n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n \n-using namespace std;\n-\n CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n     /**\n      * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n      * - nElements * log(fp rate) / ln(2)^2\n      * We ignore filter parameters which will create a bloom filter larger than the protocol limits\n      */\n-    vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n+    vData(std::min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n     /**\n      * The ideal number of hash functions is filter size * ln(2) / number of elements\n      * Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n      * See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n      */\n     isFull(false),\n     isEmpty(true),\n-    nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n+    nHashFuncs(std::min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n     nTweak(nTweakIn),\n     nFlags(nFlagsIn)\n {\n@@ -58,7 +56,7 @@ inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<\n     return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n }\n \n-void CBloomFilter::insert(const vector<unsigned char>& vKey)\n+void CBloomFilter::insert(const std::vector<unsigned char>& vKey)\n {\n     if (isFull)\n         return;\n@@ -75,17 +73,17 @@ void CBloomFilter::insert(const COutPoint& outpoint)\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n-    vector<unsigned char> data(stream.begin(), stream.end());\n+    std::vector<unsigned char> data(stream.begin(), stream.end());\n     insert(data);\n }\n \n void CBloomFilter::insert(const uint256& hash)\n {\n-    vector<unsigned char> data(hash.begin(), hash.end());\n+    std::vector<unsigned char> data(hash.begin(), hash.end());\n     insert(data);\n }\n \n-bool CBloomFilter::contains(const vector<unsigned char>& vKey) const\n+bool CBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n {\n     if (isFull)\n         return true;\n@@ -105,13 +103,13 @@ bool CBloomFilter::contains(const COutPoint& outpoint) const\n {\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n-    vector<unsigned char> data(stream.begin(), stream.end());\n+    std::vector<unsigned char> data(stream.begin(), stream.end());\n     return contains(data);\n }\n \n bool CBloomFilter::contains(const uint256& hash) const\n {\n-    vector<unsigned char> data(hash.begin(), hash.end());\n+    std::vector<unsigned char> data(hash.begin(), hash.end());\n     return contains(data);\n }\n \n@@ -154,7 +152,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n         // This means clients don't have to update the filter themselves when a new relevant tx \n         // is discovered in order to find spending transactions, which avoids round-tripping and race conditions.\n         CScript::const_iterator pc = txout.scriptPubKey.begin();\n-        vector<unsigned char> data;\n+        std::vector<unsigned char> data;\n         while (pc < txout.scriptPubKey.end())\n         {\n             opcodetype opcode;\n@@ -168,7 +166,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n                 else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n                 {\n                     txnouttype type;\n-                    vector<vector<unsigned char> > vSolutions;\n+                    std::vector<std::vector<unsigned char> > vSolutions;\n                     if (Solver(txout.scriptPubKey, type, vSolutions) &&\n                             (type == TX_PUBKEY || type == TX_MULTISIG))\n                         insert(COutPoint(hash, i));\n@@ -189,7 +187,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n \n         // Match if the filter contains any arbitrary script data element in any scriptSig in tx\n         CScript::const_iterator pc = txin.scriptSig.begin();\n-        vector<unsigned char> data;\n+        std::vector<unsigned char> data;\n         while (pc < txin.scriptSig.end())\n         {\n             opcodetype opcode;\n@@ -280,7 +278,7 @@ void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n \n void CRollingBloomFilter::insert(const uint256& hash)\n {\n-    vector<unsigned char> vData(hash.begin(), hash.end());\n+    std::vector<unsigned char> vData(hash.begin(), hash.end());\n     insert(vData);\n }\n \n@@ -300,7 +298,7 @@ bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n \n bool CRollingBloomFilter::contains(const uint256& hash) const\n {\n-    vector<unsigned char> vData(hash.begin(), hash.end());\n+    std::vector<unsigned char> vData(hash.begin(), hash.end());\n     return contains(vData);\n }\n "
      },
      {
        "sha": "a5b369c4fc4c3e11eb6e33a0e5fc47a9e90b8752",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -5,8 +5,6 @@\n \n #include \"chain.h\"\n \n-using namespace std;\n-\n /**\n  * CChain implementation\n  */"
      },
      {
        "sha": "a5f232c22857a05b55ae3f79a3106122300065ea",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 16,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -20,13 +20,11 @@\n #include <boost/algorithm/string/split.hpp>\n #include <boost/assign/list_of.hpp>\n \n-using namespace std;\n-\n CScript ParseScript(const std::string& s)\n {\n     CScript result;\n \n-    static map<string, opcodetype> mapOpNames;\n+    static std::map<std::string, opcodetype> mapOpNames;\n \n     if (mapOpNames.empty())\n     {\n@@ -39,15 +37,15 @@ CScript ParseScript(const std::string& s)\n             const char* name = GetOpName((opcodetype)op);\n             if (strcmp(name, \"OP_UNKNOWN\") == 0)\n                 continue;\n-            string strName(name);\n+            std::string strName(name);\n             mapOpNames[strName] = (opcodetype)op;\n             // Convenience: OP_ADD and just ADD are both recognized:\n             boost::algorithm::replace_first(strName, \"OP_\", \"\");\n             mapOpNames[strName] = (opcodetype)op;\n         }\n     }\n \n-    vector<string> words;\n+    std::vector<std::string> words;\n     boost::algorithm::split(words, s, boost::algorithm::is_any_of(\" \\t\\n\"), boost::algorithm::token_compress_on);\n \n     for (std::vector<std::string>::const_iterator w = words.begin(); w != words.end(); ++w)\n@@ -57,16 +55,16 @@ CScript ParseScript(const std::string& s)\n             // Empty string, ignore. (boost::split given '' will return one word)\n         }\n         else if (all(*w, boost::algorithm::is_digit()) ||\n-            (boost::algorithm::starts_with(*w, \"-\") && all(string(w->begin()+1, w->end()), boost::algorithm::is_digit())))\n+            (boost::algorithm::starts_with(*w, \"-\") && all(std::string(w->begin()+1, w->end()), boost::algorithm::is_digit())))\n         {\n             // Number\n             int64_t n = atoi64(*w);\n             result << n;\n         }\n-        else if (boost::algorithm::starts_with(*w, \"0x\") && (w->begin()+2 != w->end()) && IsHex(string(w->begin()+2, w->end())))\n+        else if (boost::algorithm::starts_with(*w, \"0x\") && (w->begin()+2 != w->end()) && IsHex(std::string(w->begin()+2, w->end())))\n         {\n             // Raw hex data, inserted NOT pushed onto stack:\n-            std::vector<unsigned char> raw = ParseHex(string(w->begin()+2, w->end()));\n+            std::vector<unsigned char> raw = ParseHex(std::string(w->begin()+2, w->end()));\n             result.insert(result.end(), raw.begin(), raw.end());\n         }\n         else if (w->size() >= 2 && boost::algorithm::starts_with(*w, \"'\") && boost::algorithm::ends_with(*w, \"'\"))\n@@ -83,7 +81,7 @@ CScript ParseScript(const std::string& s)\n         }\n         else\n         {\n-            throw runtime_error(\"script parse error\");\n+            throw std::runtime_error(\"script parse error\");\n         }\n     }\n \n@@ -95,7 +93,7 @@ bool DecodeHexTx(CMutableTransaction& tx, const std::string& strHexTx, bool fTry\n     if (!IsHex(strHexTx))\n         return false;\n \n-    vector<unsigned char> txData(ParseHex(strHexTx));\n+    std::vector<unsigned char> txData(ParseHex(strHexTx));\n \n     if (fTryNoWitness) {\n         CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n@@ -138,9 +136,9 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n-uint256 ParseHashUV(const UniValue& v, const string& strName)\n+uint256 ParseHashUV(const UniValue& v, const std::string& strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.getValStr();\n     return ParseHashStr(strHex, strName);  // Note: ParseHashStr(\"\") throws a runtime_error\n@@ -149,19 +147,19 @@ uint256 ParseHashUV(const UniValue& v, const string& strName)\n uint256 ParseHashStr(const std::string& strHex, const std::string& strName)\n {\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw std::runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n \n     uint256 result;\n     result.SetHex(strHex);\n     return result;\n }\n \n-vector<unsigned char> ParseHexUV(const UniValue& v, const string& strName)\n+std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName)\n {\n-    string strHex;\n+    std::string strHex;\n     if (v.isStr())\n         strHex = v.getValStr();\n     if (!IsHex(strHex))\n-        throw runtime_error(strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n+        throw std::runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n     return ParseHex(strHex);\n }"
      },
      {
        "sha": "b0993a131f02a8be24b33d36b8b43c60225d12de",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 22,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -18,16 +18,14 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n-string FormatScript(const CScript& script)\n+std::string FormatScript(const CScript& script)\n {\n-    string ret;\n+    std::string ret;\n     CScript::const_iterator it = script.begin();\n     opcodetype op;\n     while (it != script.end()) {\n         CScript::const_iterator it2 = it;\n-        vector<unsigned char> vch;\n+        std::vector<unsigned char> vch;\n         if (script.GetOp2(it, op, &vch)) {\n             if (op == OP_0) {\n                 ret += \"0 \";\n@@ -36,9 +34,9 @@ string FormatScript(const CScript& script)\n                 ret += strprintf(\"%i \", op - OP_1NEGATE - 1);\n                 continue;\n             } else if (op >= OP_NOP && op <= OP_NOP10) {\n-                string str(GetOpName(op));\n-                if (str.substr(0, 3) == string(\"OP_\")) {\n-                    ret += str.substr(3, string::npos) + \" \";\n+                std::string str(GetOpName(op));\n+                if (str.substr(0, 3) == std::string(\"OP_\")) {\n+                    ret += str.substr(3, std::string::npos) + \" \";\n                     continue;\n                 }\n             }\n@@ -55,14 +53,14 @@ string FormatScript(const CScript& script)\n     return ret.substr(0, ret.size() - 1);\n }\n \n-const map<unsigned char, string> mapSigHashTypes =\n+const std::map<unsigned char, std::string> mapSigHashTypes =\n     boost::assign::map_list_of\n-    (static_cast<unsigned char>(SIGHASH_ALL), string(\"ALL\"))\n-    (static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), string(\"ALL|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE), string(\"NONE\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), string(\"NONE|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE), string(\"SINGLE\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), string(\"SINGLE|ANYONECANPAY\"))\n+    (static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\"))\n+    (static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\"))\n+    (static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\"))\n+    (static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\"))\n+    (static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\"))\n+    (static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\"))\n     ;\n \n /**\n@@ -72,11 +70,11 @@ const map<unsigned char, string> mapSigHashTypes =\n  *                                     of a signature. Only pass true for scripts you believe could contain signatures. For example,\n  *                                     pass false, or omit the this argument (defaults to false), for scriptPubKeys.\n  */\n-string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n+std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n {\n-    string str;\n+    std::string str;\n     opcodetype opcode;\n-    vector<unsigned char> vch;\n+    std::vector<unsigned char> vch;\n     CScript::const_iterator pc = script.begin();\n     while (pc < script.end()) {\n         if (!str.empty()) {\n@@ -87,12 +85,12 @@ string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n             return str;\n         }\n         if (0 <= opcode && opcode <= OP_PUSHDATA4) {\n-            if (vch.size() <= static_cast<vector<unsigned char>::size_type>(4)) {\n+            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) {\n                 str += strprintf(\"%d\", CScriptNum(vch, false).getint());\n             } else {\n                 // the IsUnspendable check makes sure not to try to decode OP_RETURN data that may match the format of a signature\n                 if (fAttemptSighashDecode && !script.IsUnspendable()) {\n-                    string strSigHashDecode;\n+                    std::string strSigHashDecode;\n                     // goal: only attempt to decode a defined sighash type from data that looks like a signature within a scriptSig.\n                     // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to\n                     // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the\n@@ -116,7 +114,7 @@ string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n     return str;\n }\n \n-string EncodeHexTx(const CTransaction& tx, const int serialFlags)\n+std::string EncodeHexTx(const CTransaction& tx, const int serialFlags)\n {\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | serialFlags);\n     ssTx << tx;\n@@ -127,7 +125,7 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n                         UniValue& out, bool fIncludeHex)\n {\n     txnouttype type;\n-    vector<CTxDestination> addresses;\n+    std::vector<CTxDestination> addresses;\n     int nRequired;\n \n     out.pushKV(\"asm\", ScriptToAsmStr(scriptPubKey));"
      },
      {
        "sha": "453fd833a3ba7f53f6c519336177260577706a48",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 16,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -65,8 +65,6 @@\n #include \"zmq/zmqnotificationinterface.h\"\n #endif\n \n-using namespace std;\n-\n bool fFeeEstimatesInitialized = false;\n static const bool DEFAULT_PROXYRANDOMIZE = true;\n static const bool DEFAULT_REST_ENABLE = false;\n@@ -310,10 +308,10 @@ void OnRPCStopped()\n void OnRPCPreCommand(const CRPCCommand& cmd)\n {\n     // Observe safe mode\n-    string strWarning = GetWarnings(\"rpc\");\n+    std::string strWarning = GetWarnings(\"rpc\");\n     if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\", DEFAULT_DISABLE_SAFEMODE) &&\n         !cmd.okSafeMode)\n-        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, string(\"Safe mode: \") + strWarning);\n+        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, std::string(\"Safe mode: \") + strWarning);\n }\n \n std::string HelpMessage(HelpMessageMode mode)\n@@ -322,7 +320,7 @@ std::string HelpMessage(HelpMessageMode mode)\n \n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n     // Do not translate _(...) -help-debug options, Many technical terms, and only a very small audience, so is unnecessary stress to translators.\n-    string strUsage = HelpMessageGroup(_(\"Options:\"));\n+    std::string strUsage = HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"Print this help message and exit\"));\n     strUsage += HelpMessageOpt(\"-version\", _(\"Print version and exit\"));\n     strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"));\n@@ -436,7 +434,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified BIP9 deployment (regtest-only)\");\n     }\n-    string debugCategories = \"addrman, alert, bench, cmpctblock, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n+    std::string debugCategories = \"addrman, alert, bench, cmpctblock, coindb, db, http, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n         debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n@@ -576,15 +574,14 @@ struct CImportingNow\n // works correctly.\n void CleanupBlockRevFiles()\n {\n-    using namespace boost::filesystem;\n-    map<string, path> mapBlockFiles;\n+    std::map<std::string, boost::filesystem::path> mapBlockFiles;\n \n     // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    path blocksdir = GetDataDir() / \"blocks\";\n-    for (directory_iterator it(blocksdir); it != directory_iterator(); it++) {\n+    boost::filesystem::path blocksdir = GetDataDir() / \"blocks\";\n+    for (boost::filesystem::directory_iterator it(blocksdir); it != boost::filesystem::directory_iterator(); it++) {\n         if (is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n             it->path().filename().string().substr(8,4) == \".dat\")\n@@ -601,7 +598,7 @@ void CleanupBlockRevFiles()\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    BOOST_FOREACH(const PAIRTYPE(string, path)& item, mapBlockFiles) {\n+    BOOST_FOREACH(const PAIRTYPE(std::string, boost::filesystem::path)& item, mapBlockFiles) {\n         if (atoi(item.first) == nContigCounter) {\n             nContigCounter++;\n             continue;\n@@ -894,8 +891,8 @@ bool AppInitParameterInteraction()\n     fDebug = mapMultiArgs.count(\"-debug\");\n     // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n     if (fDebug) {\n-        const vector<string>& categories = mapMultiArgs.at(\"-debug\");\n-        if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), string(\"0\")) != categories.end())\n+        const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n+        if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), std::string(\"0\")) != categories.end())\n             fDebug = false;\n     }\n \n@@ -1063,7 +1060,7 @@ bool AppInitParameterInteraction()\n         if (!chainparams.MineBlocksOnDemand()) {\n             return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n         }\n-        const vector<string>& deployments = mapMultiArgs.at(\"-bip9params\");\n+        const std::vector<std::string>& deployments = mapMultiArgs.at(\"-bip9params\");\n         for (auto i : deployments) {\n             std::vector<std::string> vDeploymentParams;\n             boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n@@ -1208,9 +1205,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     RegisterNodeSignals(GetNodeSignals());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n-    std::vector<string> uacomments;\n+    std::vector<std::string> uacomments;\n     if (mapMultiArgs.count(\"-uacomment\")) {\n-        BOOST_FOREACH(string cmt, mapMultiArgs.at(\"-uacomment\"))\n+        BOOST_FOREACH(std::string cmt, mapMultiArgs.at(\"-uacomment\"))\n         {\n             if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n                 return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));"
      },
      {
        "sha": "e3f3e4621ad8c9f19bb7ae3d256d068b77313782",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -9,14 +9,12 @@\n #include \"consensus/consensus.h\"\n #include \"utilstrencodings.h\"\n \n-using namespace std;\n-\n CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n {\n     header = block.GetBlockHeader();\n \n-    vector<bool> vMatch;\n-    vector<uint256> vHashes;\n+    std::vector<bool> vMatch;\n+    std::vector<uint256> vHashes;\n \n     vMatch.reserve(block.vtx.size());\n     vHashes.reserve(block.vtx.size());\n@@ -27,7 +25,7 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n         if (filter.IsRelevantAndUpdate(*block.vtx[i]))\n         {\n             vMatch.push_back(true);\n-            vMatchedTxn.push_back(make_pair(i, hash));\n+            vMatchedTxn.push_back(std::make_pair(i, hash));\n         }\n         else\n             vMatch.push_back(false);\n@@ -41,8 +39,8 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, const std::set<uint256>& txids)\n {\n     header = block.GetBlockHeader();\n \n-    vector<bool> vMatch;\n-    vector<uint256> vHashes;\n+    std::vector<bool> vMatch;\n+    std::vector<uint256> vHashes;\n \n     vMatch.reserve(block.vtx.size());\n     vHashes.reserve(block.vtx.size());"
      },
      {
        "sha": "d01edd93b52e65b3178b6cbd4e9db4a01b62375c",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -31,8 +31,6 @@\n #include <queue>\n #include <utility>\n \n-using namespace std;\n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // BitcoinMiner\n@@ -500,7 +498,7 @@ void BlockAssembler::addPackageTxs()\n         }\n \n         // Package can be added. Sort the entries in a valid order.\n-        vector<CTxMemPool::txiter> sortedEntries;\n+        std::vector<CTxMemPool::txiter> sortedEntries;\n         SortForBlock(ancestors, iter, sortedEntries);\n \n         for (size_t i=0; i<sortedEntries.size(); ++i) {\n@@ -529,7 +527,7 @@ void BlockAssembler::addPriorityTxs()\n     fNeedSizeAccounting = true;\n \n     // This vector will be sorted into a priority queue:\n-    vector<TxCoinAgePriority> vecPriority;\n+    std::vector<TxCoinAgePriority> vecPriority;\n     TxCoinAgePriorityCompare pricomparer;\n     std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash> waitPriMap;\n     typedef std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash>::iterator waitPriIter;"
      },
      {
        "sha": "b9667eb6c64b7e7092ae8a62e291d71ab578d1bc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 53,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -32,8 +32,6 @@\n \n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -55,8 +53,8 @@ struct COrphanTx {\n     NodeId fromPeer;\n     int64_t nTimeExpire;\n };\n-map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);\n-map<COutPoint, set<map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(cs_main);\n+std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(cs_main);\n+std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(cs_main);\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n static size_t vExtraTxnForCompactIt = 0;\n@@ -76,7 +74,7 @@ namespace {\n      * Set mapBlockSource[hash].second to false if the node should not be\n      * punished if the block is invalid.\n      */\n-    map<uint256, std::pair<NodeId, bool>> mapBlockSource;\n+    std::map<uint256, std::pair<NodeId, bool>> mapBlockSource;\n \n     /**\n      * Filter for transactions that were recently rejected by\n@@ -108,10 +106,10 @@ namespace {\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n-    list<NodeId> lNodesAnnouncingHeaderAndIDs;\n+    std::list<NodeId> lNodesAnnouncingHeaderAndIDs;\n \n     /** Number of preferable block download peers. */\n     int nPreferredDownload = 0;\n@@ -135,7 +133,7 @@ namespace {\n \n struct CBlockReject {\n     unsigned char chRejectCode;\n-    string strRejectReason;\n+    std::string strRejectReason;\n     uint256 hashBlock;\n };\n \n@@ -172,7 +170,7 @@ struct CNodeState {\n     bool fSyncStarted;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n     int64_t nStallingSince;\n-    list<QueuedBlock> vBlocksInFlight;\n+    std::list<QueuedBlock> vBlocksInFlight;\n     //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n     int64_t nDownloadingSince;\n     int nBlocksInFlight;\n@@ -224,11 +222,11 @@ struct CNodeState {\n };\n \n /** Map maintaining per-node state. Requires cs_main. */\n-map<NodeId, CNodeState> mapNodeState;\n+std::map<NodeId, CNodeState> mapNodeState;\n \n // Requires cs_main.\n CNodeState *State(NodeId pnode) {\n-    map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n+    std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n     if (it == mapNodeState.end())\n         return NULL;\n     return &it->second;\n@@ -310,7 +308,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n-    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n@@ -334,12 +332,12 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n     // Short-circuit most stuff in case its from the same node\n-    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n         *pit = &itInFlight->second.second;\n         return false;\n@@ -348,7 +346,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n     // Make sure it's not listed somewhere already.\n     MarkBlockAsReceived(hash);\n \n-    list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n+    std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n     state->nBlocksInFlight++;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n@@ -640,7 +638,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n \n int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n+    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n     BOOST_FOREACH(const CTxIn& txin, it->second.tx->vin)\n@@ -659,10 +657,10 @@ int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n void EraseOrphansFor(NodeId peer)\n {\n     int nErased = 0;\n-    map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+    std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n     while (iter != mapOrphanTransactions.end())\n     {\n-        map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n+        std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n         if (maybeErase->second.fromPeer == peer)\n         {\n             nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n@@ -681,10 +679,10 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n         // Sweep out expired orphan pool entries:\n         int nErased = 0;\n         int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n-        map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+        std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n         while (iter != mapOrphanTransactions.end())\n         {\n-            map<uint256, COrphanTx>::iterator maybeErase = iter++;\n+            std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n             if (maybeErase->second.nTimeExpire <= nNow) {\n                 nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n             } else {\n@@ -699,7 +697,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n     {\n         // Evict a random orphan:\n         uint256 randomhash = GetRandHash();\n-        map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n+        std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n         if (it == mapOrphanTransactions.end())\n             it = mapOrphanTransactions.begin();\n         EraseOrphanTx(it->first);\n@@ -961,7 +959,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman& connman, std::atomic<bool>& interruptMsgProc)\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n-    vector<CInv> vNotFound;\n+    std::vector<CInv> vNotFound;\n     CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     LOCK(cs_main);\n \n@@ -1083,7 +1081,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // Bypass PushInventory, this must send even if redundant,\n                         // and we want it right after the last block so they don't\n                         // wait for other stuff first.\n-                        vector<CInv> vInv;\n+                        std::vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n                         connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                         pfrom->hashContinue.SetNull();\n@@ -1160,7 +1158,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, std::atomic<bool>& interruptMsgProc)\n+bool static ProcessMessage(CNode* pfrom, std::string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n     if (IsArgSet(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -1190,7 +1188,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\")));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -1311,7 +1309,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        string remoteAddr;\n+        std::string remoteAddr;\n         if (fLogIPs)\n             remoteAddr = \", peeraddr=\" + pfrom->addr.ToString();\n \n@@ -1352,7 +1350,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     if (strCommand == NetMsgType::VERACK)\n     {\n-        pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+        pfrom->SetRecvVersion(std::min(pfrom->nVersion, PROTOCOL_VERSION));\n \n         if (!pfrom->fInbound) {\n             // Mark this node as currently connected, so we update its timestamp later.\n@@ -1385,7 +1383,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::ADDR)\n     {\n-        vector<CAddress> vAddr;\n+        std::vector<CAddress> vAddr;\n         vRecv >> vAddr;\n \n         // Don't want addr from older versions unless seeding\n@@ -1399,7 +1397,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         // Store the new addresses\n-        vector<CAddress> vAddrOk;\n+        std::vector<CAddress> vAddrOk;\n         int64_t nNow = GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n         BOOST_FOREACH(CAddress& addr, vAddr)\n@@ -1462,7 +1460,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::INV)\n     {\n-        vector<CInv> vInv;\n+        std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n@@ -1529,7 +1527,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::GETDATA)\n     {\n-        vector<CInv> vInv;\n+        std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n@@ -1691,7 +1689,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n-        vector<CBlock> vHeaders;\n+        std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n         LogPrint(\"net\", \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n@@ -1727,8 +1725,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n-        deque<COutPoint> vWorkQueue;\n-        vector<uint256> vEraseQueue;\n+        std::deque<COutPoint> vWorkQueue;\n+        std::vector<uint256> vEraseQueue;\n         CTransactionRef ptx;\n         vRecv >> ptx;\n         const CTransaction& tx = *ptx;\n@@ -1761,7 +1759,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n             // Recursively process any orphan transactions that depended on this one\n-            set<NodeId> setMisbehaving;\n+            std::set<NodeId> setMisbehaving;\n             while (!vWorkQueue.empty()) {\n                 auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());\n                 vWorkQueue.pop_front();\n@@ -1955,7 +1953,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n \n-        std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n         bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n \n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n@@ -1990,7 +1988,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n-                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n@@ -2108,7 +2106,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         {\n             LOCK(cs_main);\n \n-            map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n                 LogPrint(\"net\", \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n@@ -2265,7 +2263,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n-            vector<const CBlockIndex *> vToFetch;\n+            std::vector<const CBlockIndex*> vToFetch;\n             const CBlockIndex *pindexWalk = pindexLast;\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n@@ -2286,7 +2284,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n             } else {\n-                vector<CInv> vGetData;\n+                std::vector<CInv> vGetData;\n                 // Download as much as possible, from earliest to latest.\n                 BOOST_REVERSE_FOREACH(const CBlockIndex *pindex, vToFetch) {\n                     if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n@@ -2365,7 +2363,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         pfrom->fSentAddr = true;\n \n         pfrom->vAddrToSend.clear();\n-        vector<CAddress> vAddr = connman.GetAddresses();\n+        std::vector<CAddress> vAddr = connman.GetAddresses();\n         FastRandomContext insecure_rand;\n         BOOST_FOREACH(const CAddress &addr, vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n@@ -2496,7 +2494,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::FILTERADD)\n     {\n-        vector<unsigned char> vData;\n+        std::vector<unsigned char> vData;\n         vRecv >> vData;\n \n         // Nodes must NEVER send a data item > 520 bytes (the max size for a script data object,\n@@ -2534,10 +2532,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     {\n         if (fDebug) {\n             try {\n-                string strMsg; unsigned char ccode; string strReason;\n+                std::string strMsg; unsigned char ccode; std::string strReason;\n                 vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);\n \n-                ostringstream ss;\n+                std::ostringstream ss;\n                 ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;\n \n                 if (strMsg == NetMsgType::BLOCK || strMsg == NetMsgType::TX)\n@@ -2635,7 +2633,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, std::atomic<bool>& interru\n             LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n             return fMoreWork;\n         }\n-        string strCommand = hdr.GetCommand();\n+        std::string strCommand = hdr.GetCommand();\n \n         // Message size\n         unsigned int nMessageSize = hdr.nMessageSize;\n@@ -2664,7 +2662,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, std::atomic<bool>& interru\n         }\n         catch (const std::ios_base::failure& e)\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\")));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n@@ -2761,7 +2759,7 @@ bool SendMessages(CNode* pto, CConnman& connman, std::atomic<bool>& interruptMsg\n         CNodeState &state = *State(pto->GetId());\n \n         BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n+            connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n         state.rejects.clear();\n \n         if (state.fShouldBan) {\n@@ -2794,7 +2792,7 @@ bool SendMessages(CNode* pto, CConnman& connman, std::atomic<bool>& interruptMsg\n         //\n         if (pto->nNextAddrSend < nNow) {\n             pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n-            vector<CAddress> vAddr;\n+            std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());\n             BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n             {\n@@ -2862,7 +2860,7 @@ bool SendMessages(CNode* pto, CConnman& connman, std::atomic<bool>& interruptMsg\n             // blocks, or if the peer doesn't want headers, just\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n-            vector<CBlock> vHeaders;\n+            std::vector<CBlock> vHeaders;\n             bool fRevertToInv = ((!state.fPreferHeaders &&\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n@@ -2994,7 +2992,7 @@ bool SendMessages(CNode* pto, CConnman& connman, std::atomic<bool>& interruptMsg\n         //\n         // Message: inventory\n         //\n-        vector<CInv> vInv;\n+        std::vector<CInv> vInv;\n         {\n             LOCK(pto->cs_inventory);\n             vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n@@ -3059,7 +3057,7 @@ bool SendMessages(CNode* pto, CConnman& connman, std::atomic<bool>& interruptMsg\n             // Determine transactions to relay\n             if (fSendTrickle) {\n                 // Produce a vector with all candidates for sending\n-                vector<std::set<uint256>::iterator> vInvTx;\n+                std::vector<std::set<uint256>::iterator> vInvTx;\n                 vInvTx.reserve(pto->setInventoryTxToSend.size());\n                 for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n                     vInvTx.push_back(it);\n@@ -3153,9 +3151,9 @@ bool SendMessages(CNode* pto, CConnman& connman, std::atomic<bool>& interruptMsg\n         //\n         // Message: getdata (blocks)\n         //\n-        vector<CInv> vGetData;\n+        std::vector<CInv> vGetData;\n         if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            vector<const CBlockIndex*> vToDownload;\n+            std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {"
      },
      {
        "sha": "54eefcafe364fc570afbebcff49505725760774d",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 27,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -20,8 +20,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n \n enum RetFormat {\n@@ -64,7 +62,7 @@ extern UniValue mempoolToJSON(bool fVerbose = false);\n extern void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n extern UniValue blockheaderToJSON(const CBlockIndex* blockindex);\n \n-static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, string message)\n+static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string message)\n {\n     req->WriteHeader(\"Content-Type\", \"text/plain\");\n     req->WriteReply(status, message + \"\\r\\n\");\n@@ -92,9 +90,9 @@ static enum RetFormat ParseDataFormat(std::string& param, const std::string& str\n     return rf_names[0].rf;\n }\n \n-static string AvailableDataFormatsString()\n+static std::string AvailableDataFormatsString()\n {\n-    string formats = \"\";\n+    std::string formats = \"\";\n     for (unsigned int i = 0; i < ARRAYLEN(rf_names); i++)\n         if (strlen(rf_names[i].name) > 0) {\n             formats.append(\".\");\n@@ -108,7 +106,7 @@ static string AvailableDataFormatsString()\n     return formats;\n }\n \n-static bool ParseHashStr(const string& strReq, uint256& v)\n+static bool ParseHashStr(const std::string& strReq, uint256& v)\n {\n     if (!IsHex(strReq) || (strReq.size() != 64))\n         return false;\n@@ -132,7 +130,7 @@ static bool rest_headers(HTTPRequest* req,\n         return false;\n     std::string param;\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n-    vector<string> path;\n+    std::vector<std::string> path;\n     boost::split(path, param, boost::is_any_of(\"/\"));\n \n     if (path.size() != 2)\n@@ -142,7 +140,7 @@ static bool rest_headers(HTTPRequest* req,\n     if (count < 1 || count > 2000)\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n \n-    string hashStr = path[1];\n+    std::string hashStr = path[1];\n     uint256 hash;\n     if (!ParseHashStr(hashStr, hash))\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n@@ -168,14 +166,14 @@ static bool rest_headers(HTTPRequest* req,\n \n     switch (rf) {\n     case RF_BINARY: {\n-        string binaryHeader = ssHeader.str();\n+        std::string binaryHeader = ssHeader.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n@@ -185,7 +183,7 @@ static bool rest_headers(HTTPRequest* req,\n         BOOST_FOREACH(const CBlockIndex *pindex, headers) {\n             jsonHeaders.push_back(blockheaderToJSON(pindex));\n         }\n-        string strJSON = jsonHeaders.write() + \"\\n\";\n+        std::string strJSON = jsonHeaders.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -232,22 +230,22 @@ static bool rest_block(HTTPRequest* req,\n \n     switch (rf) {\n     case RF_BINARY: {\n-        string binaryBlock = ssBlock.str();\n+        std::string binaryBlock = ssBlock.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n     case RF_JSON: {\n         UniValue objBlock = blockToJSON(block, pblockindex, showTxDetails);\n-        string strJSON = objBlock.write() + \"\\n\";\n+        std::string strJSON = objBlock.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -287,7 +285,7 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n         JSONRPCRequest jsonRequest;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\n-        string strJSON = chainInfoObject.write() + \"\\n\";\n+        std::string strJSON = chainInfoObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -312,7 +310,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n     case RF_JSON: {\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n-        string strJSON = mempoolInfoObject.write() + \"\\n\";\n+        std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -337,7 +335,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n     case RF_JSON: {\n         UniValue mempoolObject = mempoolToJSON(true);\n \n-        string strJSON = mempoolObject.write() + \"\\n\";\n+        std::string strJSON = mempoolObject.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -372,14 +370,14 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n \n     switch (rf) {\n     case RF_BINARY: {\n-        string binaryTx = ssTx.str();\n+        std::string binaryTx = ssTx.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n     case RF_HEX: {\n-        string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n@@ -388,7 +386,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     case RF_JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToJSON(*tx, hashBlock, objTx);\n-        string strJSON = objTx.write() + \"\\n\";\n+        std::string strJSON = objTx.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;\n@@ -410,7 +408,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     std::string param;\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n-    vector<string> uriParts;\n+    std::vector<std::string> uriParts;\n     if (param.length() > 1)\n     {\n         std::string strUriParams = param.substr(1);\n@@ -424,7 +422,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n \n     bool fInputParsed = false;\n     bool fCheckMemPool = false;\n-    vector<COutPoint> vOutPoints;\n+    std::vector<COutPoint> vOutPoints;\n \n     // parse/deserialize input\n     // input-format = output-format, rest/getutxos/bin requires binary input, gives binary output, ...\n@@ -498,8 +496,8 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\n \n     // check spentness and form a bitmap (as well as a JSON capable human-readable string representation)\n-    vector<unsigned char> bitmap;\n-    vector<CCoin> outs;\n+    std::vector<unsigned char> bitmap;\n+    std::vector<CCoin> outs;\n     std::string bitmapStringRepresentation;\n     std::vector<bool> hits;\n     bitmap.resize((vOutPoints.size() + 7) / 8);\n@@ -546,7 +544,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n-        string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n+        std::string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n \n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, ssGetUTXOResponseString);\n@@ -556,7 +554,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     case RF_HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n-        string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n+        std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n \n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n@@ -588,7 +586,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         objGetUTXOResponse.push_back(Pair(\"utxos\", utxos));\n \n         // return json string\n-        string strJSON = objGetUTXOResponse.write() + \"\\n\";\n+        std::string strJSON = objGetUTXOResponse.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n         return true;"
      },
      {
        "sha": "2ff6437c732cc4571bc3671574f39f6c53bedb11",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -17,8 +17,6 @@\n \n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n static CCriticalSection cs_nTimeOffset;\n static int64_t nTimeOffset = 0;\n \n@@ -51,7 +49,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n {\n     LOCK(cs_nTimeOffset);\n     // Ignore duplicates\n-    static set<CNetAddr> setKnown;\n+    static std::set<CNetAddr> setKnown;\n     if (setKnown.size() == BITCOIN_TIMEDATA_MAX_SAMPLES)\n         return;\n     if (!setKnown.insert(ip).second)"
      },
      {
        "sha": "1a30bb58ad80bcdd4b6b92aa46573f8d51523a27",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -14,8 +14,6 @@\n \n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n@@ -32,11 +30,11 @@ CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(Get\n }\n \n bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    return db.Read(make_pair(DB_COINS, txid), coins);\n+    return db.Read(std::make_pair(DB_COINS, txid), coins);\n }\n \n bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n-    return db.Exists(make_pair(DB_COINS, txid));\n+    return db.Exists(std::make_pair(DB_COINS, txid));\n }\n \n uint256 CCoinsViewDB::GetBestBlock() const {\n@@ -53,9 +51,9 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             if (it->second.coins.IsPruned())\n-                batch.Erase(make_pair(DB_COINS, it->first));\n+                batch.Erase(std::make_pair(DB_COINS, it->first));\n             else\n-                batch.Write(make_pair(DB_COINS, it->first), it->second.coins);\n+                batch.Write(std::make_pair(DB_COINS, it->first), it->second.coins);\n             changed++;\n         }\n         count++;\n@@ -73,7 +71,7 @@ CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWra\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n-    return Read(make_pair(DB_BLOCK_FILES, nFile), info);\n+    return Read(std::make_pair(DB_BLOCK_FILES, nFile), info);\n }\n \n bool CBlockTreeDB::WriteReindexing(bool fReindexing) {\n@@ -139,23 +137,23 @@ void CCoinsViewDBCursor::Next()\n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<int, const CBlockFileInfo*> >::const_iterator it=fileInfo.begin(); it != fileInfo.end(); it++) {\n-        batch.Write(make_pair(DB_BLOCK_FILES, it->first), *it->second);\n+        batch.Write(std::make_pair(DB_BLOCK_FILES, it->first), *it->second);\n     }\n     batch.Write(DB_LAST_BLOCK, nLastFile);\n     for (std::vector<const CBlockIndex*>::const_iterator it=blockinfo.begin(); it != blockinfo.end(); it++) {\n-        batch.Write(make_pair(DB_BLOCK_INDEX, (*it)->GetBlockHash()), CDiskBlockIndex(*it));\n+        batch.Write(std::make_pair(DB_BLOCK_INDEX, (*it)->GetBlockHash()), CDiskBlockIndex(*it));\n     }\n     return WriteBatch(batch, true);\n }\n \n bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n-    return Read(make_pair(DB_TXINDEX, txid), pos);\n+    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n }\n \n bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n-        batch.Write(make_pair(DB_TXINDEX, it->first), it->second);\n+        batch.Write(std::make_pair(DB_TXINDEX, it->first), it->second);\n     return WriteBatch(batch);\n }\n \n@@ -175,7 +173,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());\n \n-    pcursor->Seek(make_pair(DB_BLOCK_INDEX, uint256()));\n+    pcursor->Seek(std::make_pair(DB_BLOCK_INDEX, uint256()));\n \n     // Load mapBlockIndex\n     while (pcursor->Valid()) {"
      },
      {
        "sha": "a1a37dac755b1eff45b4422d1645b6dc84f7aae0",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -18,8 +18,6 @@\n #include \"utiltime.h\"\n #include \"version.h\"\n \n-using namespace std;\n-\n CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, double _entryPriority, unsigned int _entryHeight,\n                                  CAmount _inChainInputValue,\n@@ -658,7 +656,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     const int64_t nSpendHeight = GetSpendHeight(mempoolDuplicate);\n \n     LOCK(cs);\n-    list<const CTxMemPoolEntry*> waitingOnDependants;\n+    std::list<const CTxMemPoolEntry*> waitingOnDependants;\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n         checkTotal += it->GetTxSize();\n@@ -816,7 +814,7 @@ std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::Get\n     return iters;\n }\n \n-void CTxMemPool::queryHashes(vector<uint256>& vtxid)\n+void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n {\n     LOCK(cs);\n     auto iters = GetSortedDepthAndScore();\n@@ -920,7 +918,7 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n     return true;\n }\n \n-void CTxMemPool::PrioritiseTransaction(const uint256 hash, const string strHash, double dPriorityDelta, const CAmount& nFeeDelta)\n+void CTxMemPool::PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount& nFeeDelta)\n {\n     {\n         LOCK(cs);"
      },
      {
        "sha": "5a14e7475e1c7d386c0101a2b661a7bebc18fab7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 24,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7b48c8bbdf7a90861610b035d8b0a247ef78c45/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b7b48c8bbdf7a90861610b035d8b0a247ef78c45",
        "patch": "@@ -46,8 +46,6 @@\n #include <boost/math/distributions/poisson.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -90,7 +88,7 @@ static void CheckBlockIndex(const Consensus::Params& consensusParams);\n /** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n \n-const string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n \n // Internal stuff\n namespace {\n@@ -123,11 +121,11 @@ namespace {\n      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n      * missing the data for the block.\n      */\n-    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n     /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n      */\n-    multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n+    std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n@@ -151,10 +149,10 @@ namespace {\n     arith_uint256 nLastPreciousChainwork = 0;\n \n     /** Dirty block index entries. */\n-    set<CBlockIndex*> setDirtyBlockIndex;\n+    std::set<CBlockIndex*> setDirtyBlockIndex;\n \n     /** Dirty block file entries. */\n-    set<int> setDirtyFileInfo;\n+    std::set<int> setDirtyFileInfo;\n } // anon namespace\n \n /* Use this class to start tracking transactions that are removed from the\n@@ -517,7 +515,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n     if (fCheckDuplicateInputs) {\n-        set<COutPoint> vInOutPoints;\n+        std::set<COutPoint> vInOutPoints;\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n@@ -596,7 +594,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n-    string reason;\n+    std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n         return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n \n@@ -611,7 +609,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-in-mempool\");\n \n     // Check for conflicts with in-memory transactions\n-    set<uint256> setConflicts;\n+    std::set<uint256> setConflicts;\n     {\n     LOCK(pool.cs); // protect pool.mapNextTx\n     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n@@ -831,7 +829,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fReplacementTransaction)\n         {\n             CFeeRate newFeeRate(nModifiedFees, nSize);\n-            set<uint256> setConflictsParents;\n+            std::set<uint256> setConflictsParents;\n             const int maxDescendantsToVisit = 100;\n             CTxMemPool::setEntries setIterConflicting;\n             BOOST_FOREACH(const uint256 &hashConflicting, setConflicts)\n@@ -2052,13 +2050,13 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int n\n         {\n             std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;\n             vFiles.reserve(setDirtyFileInfo.size());\n-            for (set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n-                vFiles.push_back(make_pair(*it, &vinfoBlockFile[*it]));\n+            for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n+                vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));\n                 setDirtyFileInfo.erase(it++);\n             }\n             std::vector<const CBlockIndex*> vBlocks;\n             vBlocks.reserve(setDirtyBlockIndex.size());\n-            for (set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n+            for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n                 vBlocks.push_back(*it);\n                 setDirtyBlockIndex.erase(it++);\n             }\n@@ -2670,7 +2668,7 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n+    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n     if (miPrev != mapBlockIndex.end())\n@@ -2707,7 +2705,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n \n     if (pindexNew->pprev == NULL || pindexNew->pprev->nChainTx) {\n         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n-        deque<CBlockIndex*> queue;\n+        std::deque<CBlockIndex*> queue;\n         queue.push_back(pindexNew);\n \n         // Recursively process any descendant blocks that now may be eligible to be connected.\n@@ -3329,7 +3327,7 @@ void PruneOneBlockFile(const int fileNumber)\n \n void UnlinkPrunedFiles(std::set<int>& setFilesToPrune)\n {\n-    for (set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n+    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {\n         CDiskBlockPos pos(*it, 0);\n         boost::filesystem::remove(GetBlockPosFilename(pos, \"blk\"));\n         boost::filesystem::remove(GetBlockPosFilename(pos, \"rev\"));\n@@ -3347,7 +3345,7 @@ void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeig\n         return;\n \n     // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n-    unsigned int nLastBlockWeCanPrune = min((unsigned)nManualPruneHeight, chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP);\n+    unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP);\n     int count=0;\n     for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n         if (vinfoBlockFile[fileNumber].nSize == 0 || vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune)\n@@ -3474,8 +3472,8 @@ CBlockIndex * InsertBlockIndex(uint256 hash)\n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n     if (!pindexNew)\n-        throw runtime_error(std::string(__func__) + \": new CBlockIndex failed\");\n-    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n+        throw std::runtime_error(std::string(__func__) + \": new CBlockIndex failed\");\n+    mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n \n     return pindexNew;\n@@ -3489,12 +3487,12 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     boost::this_thread::interruption_point();\n \n     // Calculate nChainWork\n-    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n+    std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(mapBlockIndex.size());\n     BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n-        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n+        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n     BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n@@ -3545,7 +3543,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n \n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n-    set<int> setBlkDataFiles;\n+    std::set<int> setBlkDataFiles;\n     BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n@@ -3932,7 +3930,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 NotifyHeaderTip();\n \n                 // Recursively process earlier encountered successors of this block\n-                deque<uint256> queue;\n+                std::deque<uint256> queue;\n                 queue.push_back(hash);\n                 while (!queue.empty()) {\n                     uint256 head = queue.front();"
      }
    ]
  }
]