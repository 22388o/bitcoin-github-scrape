[
  {
    "sha": "f26502e9fc8a669b30717525597e3f468eaecf79",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMjY1MDJlOWZjOGE2NjliMzA3MTc1MjU1OTdlM2Y0NjhlYWVjZjc5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-07-23T14:34:40Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-12T08:22:07Z"
      },
      "message": "[addrman] Specify max addresses and pct when calling GetAddresses()\n\nCAddrMan.GetAddr() would previously limit the number and percentage of\naddresses returned (to ADDRMAN_GETADDR_MAX (1000) and\nADDRMAN_GETADDR_MAX_PCT (23) respectively). Instead, make it the callers\nresponsibility to specify the maximum addresses and percentage they want\nreturned.\n\nFor net_processing, the maximums are MAX_ADDR_TO_SEND (1000) and\nMAX_PCT_ADDR_TO_SEND (23). For rpc/net, the maximum is specified by the\nclient.",
      "tree": {
        "sha": "828ca2eb39f9889bab4d2fb6ca09126d790883fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/828ca2eb39f9889bab4d2fb6ca09126d790883fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f26502e9fc8a669b30717525597e3f468eaecf79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f26502e9fc8a669b30717525597e3f468eaecf79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f26502e9fc8a669b30717525597e3f468eaecf79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f26502e9fc8a669b30717525597e3f468eaecf79/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3c93623be20d534bb653410db03d38152135e2e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c93623be20d534bb653410db03d38152135e2e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3c93623be20d534bb653410db03d38152135e2e6"
      }
    ],
    "stats": {
      "total": 73,
      "additions": 35,
      "deletions": 38
    },
    "files": [
      {
        "sha": "7636c6bad2638a284f573101e64cfd97a3d27d4d",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -479,11 +479,15 @@ int CAddrMan::Check_()\n }\n #endif\n \n-void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n+void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct)\n {\n-    unsigned int nNodes = ADDRMAN_GETADDR_MAX_PCT * vRandom.size() / 100;\n-    if (nNodes > ADDRMAN_GETADDR_MAX)\n-        nNodes = ADDRMAN_GETADDR_MAX;\n+    size_t nNodes = vRandom.size();\n+    if (max_pct != 0) {\n+        nNodes = max_pct * nNodes / 100;\n+    }\n+    if (max_addresses != 0) {\n+        nNodes = std::min(nNodes, max_addresses);\n+    }\n \n     // gather a list of random nodes, skipping those of low quality\n     for (unsigned int n = 0; n < vRandom.size(); n++) {"
      },
      {
        "sha": "ca045b91cdaa53f32cbb00aba951b43e56ffdd7e",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -153,12 +153,6 @@ class CAddrInfo : public CAddress\n //! how recent a successful connection should be before we allow an address to be evicted from tried\n #define ADDRMAN_REPLACEMENT_HOURS 4\n \n-//! the maximum percentage of nodes to return in a getaddr call\n-#define ADDRMAN_GETADDR_MAX_PCT 23\n-\n-//! the maximum number of nodes to return in a getaddr call\n-#define ADDRMAN_GETADDR_MAX 1000\n-\n //! Convenience\n #define ADDRMAN_TRIED_BUCKET_COUNT (1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2)\n #define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n@@ -261,7 +255,7 @@ friend class CAddrManTest;\n #endif\n \n     //! Select several addresses at once.\n-    void GetAddr_(std::vector<CAddress> &vAddr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void GetAddr_(std::vector<CAddress> &vAddr, size_t max_addresses, size_t max_pct) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Mark an entry as currently-connected-to.\n     void Connected_(const CService &addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -638,13 +632,13 @@ friend class CAddrManTest;\n     }\n \n     //! Return a bunch of addresses, selected at random.\n-    std::vector<CAddress> GetAddr()\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct)\n     {\n         Check();\n         std::vector<CAddress> vAddr;\n         {\n             LOCK(cs);\n-            GetAddr_(vAddr);\n+            GetAddr_(vAddr, max_addresses, max_pct);\n         }\n         Check();\n         return vAddr;"
      },
      {
        "sha": "ebdad5a4b8ff4c6884454d9a7f7930847a2f387c",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -98,7 +98,7 @@ static void AddrManGetAddr(benchmark::Bench& bench)\n     FillAddrMan(addrman);\n \n     bench.run([&] {\n-        const auto& addresses = addrman.GetAddr();\n+        const auto& addresses = addrman.GetAddr(2500, 23);\n         assert(addresses.size() > 0);\n     });\n }"
      },
      {
        "sha": "931c08a71e503ce4eea7bda1f09a241293c48ecf",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -2528,9 +2528,9 @@ void CConnman::AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddres\n     addrman.Add(vAddr, addrFrom, nTimePenalty);\n }\n \n-std::vector<CAddress> CConnman::GetAddresses()\n+std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct)\n {\n-    std::vector<CAddress> addresses = addrman.GetAddr();\n+    std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct);\n     if (m_banman) {\n         addresses.erase(std::remove_if(addresses.begin(), addresses.end(),\n                         [this](const CAddress& addr){return m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr);}),\n@@ -2539,12 +2539,12 @@ std::vector<CAddress> CConnman::GetAddresses()\n     return addresses;\n }\n \n-std::vector<CAddress> CConnman::GetAddresses(Network requestor_network)\n+std::vector<CAddress> CConnman::GetAddresses(Network requestor_network, size_t max_addresses, size_t max_pct)\n {\n     const auto current_time = GetTime<std::chrono::microseconds>();\n     if (m_addr_response_caches.find(requestor_network) == m_addr_response_caches.end() ||\n         m_addr_response_caches[requestor_network].m_update_addr_response < current_time) {\n-        m_addr_response_caches[requestor_network].m_addrs_response_cache = GetAddresses();\n+        m_addr_response_caches[requestor_network].m_addrs_response_cache = GetAddresses(max_addresses, max_pct);\n         m_addr_response_caches[requestor_network].m_update_addr_response = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));\n     }\n     return m_addr_response_caches[requestor_network].m_addrs_response_cache;"
      },
      {
        "sha": "015c1eca0fc1c432e6d34c009a17c9925454da67",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -51,11 +51,8 @@ static const bool DEFAULT_WHITELISTFORCERELAY = false;\n static const int TIMEOUT_INTERVAL = 20 * 60;\n /** Run the feeler connection loop once every 2 minutes or 120 seconds. **/\n static const int FEELER_INTERVAL = 120;\n-/** The maximum number of new addresses to accumulate before announcing. */\n-static const unsigned int MAX_ADDR_TO_SEND = 1000;\n-// TODO: remove ADDRMAN_GETADDR_MAX and let the caller specify this limit with MAX_ADDR_TO_SEND.\n-static_assert(MAX_ADDR_TO_SEND == ADDRMAN_GETADDR_MAX,\n-    \"Max allowed ADDR message size should be equal to the max number of records returned from AddrMan.\");\n+/** The maximum number of addresses from our addrman to return in response to a getaddr message. */\n+static constexpr size_t MAX_ADDR_TO_SEND = 1000;\n /** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n /** Maximum length of the user agent string in `version` message */\n@@ -254,14 +251,14 @@ class CConnman\n     void SetServices(const CService &addr, ServiceFlags nServices);\n     void MarkAddressGood(const CAddress& addr);\n     void AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses();\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n     /**\n      * Cache is used to minimize topology leaks, so it should\n      * be used for all non-trusted calls, for example, p2p.\n      * A non-malicious call (from RPC or a peer with addr permission) should\n      * call the function without a parameter to avoid using the cache.\n      */\n-    std::vector<CAddress> GetAddresses(Network requestor_network);\n+    std::vector<CAddress> GetAddresses(Network requestor_network, size_t max_addresses, size_t max_pct);\n \n     // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n     // a peer that is better than all our current peers."
      },
      {
        "sha": "1530da8d7f1288e42c29c7a41d1298bfee0ecf84",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -143,6 +143,8 @@ static constexpr unsigned int MAX_FEEFILTER_CHANGE_DELAY = 5 * 60;\n static constexpr uint32_t MAX_GETCFILTERS_SIZE = 1000;\n /** Maximum number of cf hashes that may be requested with one getcfheaders. See BIP 157. */\n static constexpr uint32_t MAX_GETCFHEADERS_SIZE = 2000;\n+/** the maximum percentage of addresses from our addrman to return in response to a getaddr message. */\n+static constexpr size_t MAX_PCT_ADDR_TO_SEND = 23;\n \n struct COrphanTx {\n     // When modifying, adapt the copy of this definition in tests/DoS_tests.\n@@ -3476,9 +3478,9 @@ void ProcessMessage(\n         pfrom.vAddrToSend.clear();\n         std::vector<CAddress> vAddr;\n         if (pfrom.HasPermission(PF_ADDR)) {\n-            vAddr = connman.GetAddresses();\n+            vAddr = connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         } else {\n-            vAddr = connman.GetAddresses(pfrom.addr.GetNetwork());\n+            vAddr = connman.GetAddresses(pfrom.addr.GetNetwork(), MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         }\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr) {"
      },
      {
        "sha": "3a67bb717fcbfaf90b7975c2c57a5b8c4748337d",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -727,7 +727,7 @@ static UniValue getnodeaddresses(const JSONRPCRequest& request)\n             RPCHelpMan{\"getnodeaddresses\",\n                 \"\\nReturn known addresses which can potentially be used to find new nodes in the network\\n\",\n                 {\n-                    {\"count\", RPCArg::Type::NUM, /* default */ \"1\", \"How many addresses to return. Limited to the smaller of \" + ToString(ADDRMAN_GETADDR_MAX) + \" or \" + ToString(ADDRMAN_GETADDR_MAX_PCT) + \"% of all known addresses.\"},\n+                    {\"count\", RPCArg::Type::NUM, /* default */ \"1\", \"The maximum number of addresses to return. Specify 0 to return all known addresses.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"\",\n@@ -754,18 +754,16 @@ static UniValue getnodeaddresses(const JSONRPCRequest& request)\n     int count = 1;\n     if (!request.params[0].isNull()) {\n         count = request.params[0].get_int();\n-        if (count <= 0) {\n+        if (count < 0) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Address count out of range\");\n         }\n     }\n     // returns a shuffled list of CAddress\n-    std::vector<CAddress> vAddr = node.connman->GetAddresses();\n+    std::vector<CAddress> vAddr = node.connman->GetAddresses(count, /* max_pct */ 0);\n     UniValue ret(UniValue::VARR);\n \n-    int address_return_count = std::min<int>(count, vAddr.size());\n-    for (int i = 0; i < address_return_count; ++i) {\n+    for (const CAddress& addr : vAddr) {\n         UniValue obj(UniValue::VOBJ);\n-        const CAddress& addr = vAddr[i];\n         obj.pushKV(\"time\", (int)addr.nTime);\n         obj.pushKV(\"services\", (uint64_t)addr.nServices);\n         obj.pushKV(\"address\", addr.ToStringIP());"
      },
      {
        "sha": "25fdd645688ed4e849781b5abd304e9d0b8506bd",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f26502e9fc8a669b30717525597e3f468eaecf79/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f26502e9fc8a669b30717525597e3f468eaecf79/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=f26502e9fc8a669b30717525597e3f468eaecf79",
        "patch": "@@ -392,7 +392,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n-    std::vector<CAddress> vAddr1 = addrman.GetAddr();\n+    std::vector<CAddress> vAddr1 = addrman.GetAddr(/* max_addresses */ 0, /* max_pct */0);\n     BOOST_CHECK_EQUAL(vAddr1.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n@@ -415,13 +415,15 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     BOOST_CHECK(addrman.Add(addr4, source2));\n     BOOST_CHECK(addrman.Add(addr5, source1));\n \n-    // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n-    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 0, /* max_pct */ 0).size(), 5U);\n+    // Net processing asks for 23% of addresses. 23% of 5 is 1 rounded down.\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23).size(), 1U);\n \n     // Test: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 0, /* max_pct */ 0).size(), 5U);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23).size(), 1U);\n \n     // Test: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n@@ -436,7 +438,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         if (i % 8 == 0)\n             addrman.Good(addr);\n     }\n-    std::vector<CAddress> vAddr = addrman.GetAddr();\n+    std::vector<CAddress> vAddr = addrman.GetAddr(/* max_addresses */ 2500, /* max_pct */ 23);\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n     BOOST_CHECK_EQUAL(vAddr.size(), percent23);"
      }
    ]
  },
  {
    "sha": "ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZTgwNTFiYmQ4Mzc3ZjI0NThmZjFmMTY3ZGMzMGMyZDVmODNlMzE3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-07-23T15:21:14Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-12T08:22:10Z"
      },
      "message": "[test] Test that getnodeaddresses() can return all known addresses",
      "tree": {
        "sha": "fec2c63e88f2c3ab8c8d94ec0124c69314722849",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fec2c63e88f2c3ab8c8d94ec0124c69314722849"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae8051bbd8377f2458ff1f167dc30c2d5f83e317/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f26502e9fc8a669b30717525597e3f468eaecf79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f26502e9fc8a669b30717525597e3f468eaecf79",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f26502e9fc8a669b30717525597e3f468eaecf79"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 13,
      "deletions": 5
    },
    "files": [
      {
        "sha": "6173e658b0946e97fa6b849b6646e41515b44e5f",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae8051bbd8377f2458ff1f167dc30c2d5f83e317/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae8051bbd8377f2458ff1f167dc30c2d5f83e317/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
        "patch": "@@ -168,16 +168,24 @@ def _test_getnodeaddresses(self):\n             msg.addrs.append(addr)\n         self.nodes[0].p2p.send_and_ping(msg)\n \n-        # obtain addresses via rpc call and check they were ones sent in before\n-        REQUEST_COUNT = 10\n-        node_addresses = self.nodes[0].getnodeaddresses(REQUEST_COUNT)\n-        assert_equal(len(node_addresses), REQUEST_COUNT)\n+        # Obtain addresses via rpc call and check they were ones sent in before.\n+        #\n+        # All addresses added above are in the same netgroup and so are assigned\n+        # to the same bucket. Maximum possible addresses in addrman is therefore\n+        # 64, although actual number will usually be slightly less due to\n+        # BucketPosition collisions.\n+        node_addresses = self.nodes[0].getnodeaddresses(0)\n+        assert_greater_than(len(node_addresses), 50)\n+        assert_greater_than(65, len(node_addresses))\n         for a in node_addresses:\n-            assert_greater_than(a[\"time\"], 1527811200) # 1st June 2018\n+            assert_greater_than(a[\"time\"], 1527811200)  # 1st June 2018\n             assert_equal(a[\"services\"], NODE_NETWORK | NODE_WITNESS)\n             assert a[\"address\"] in imported_addrs\n             assert_equal(a[\"port\"], 8333)\n \n+        node_addresses = self.nodes[0].getnodeaddresses(1)\n+        assert_equal(len(node_addresses), 1)\n+\n         assert_raises_rpc_error(-8, \"Address count out of range\", self.nodes[0].getnodeaddresses, -1)\n \n         # addrman's size cannot be known reliably after insertion, as hash collisions may occur"
      }
    ]
  },
  {
    "sha": "37a480e0cd94895b6051abef12d984ff74bdc4a3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozN2E0ODBlMGNkOTQ4OTViNjA1MWFiZWYxMmQ5ODRmZjc0YmRjNGEz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-07-23T17:10:35Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-08-12T08:22:10Z"
      },
      "message": "[net] Add addpeeraddress RPC method\n\nAllows addresses to be added to Address Manager for testing.",
      "tree": {
        "sha": "2885b0f7c992305d28df604b3913bc3d6ac87b8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2885b0f7c992305d28df604b3913bc3d6ac87b8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37a480e0cd94895b6051abef12d984ff74bdc4a3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37a480e0cd94895b6051abef12d984ff74bdc4a3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37a480e0cd94895b6051abef12d984ff74bdc4a3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37a480e0cd94895b6051abef12d984ff74bdc4a3/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae8051bbd8377f2458ff1f167dc30c2d5f83e317",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ae8051bbd8377f2458ff1f167dc30c2d5f83e317"
      }
    ],
    "stats": {
      "total": 88,
      "additions": 66,
      "deletions": 22
    },
    "files": [
      {
        "sha": "3fd3f19b5c5942ac60b06c6ef2f161eeef109d8c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=37a480e0cd94895b6051abef12d984ff74bdc4a3",
        "patch": "@@ -2523,9 +2523,9 @@ void CConnman::MarkAddressGood(const CAddress& addr)\n     addrman.Good(addr);\n }\n \n-void CConnman::AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty)\n+bool CConnman::AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty)\n {\n-    addrman.Add(vAddr, addrFrom, nTimePenalty);\n+    return addrman.Add(vAddr, addrFrom, nTimePenalty);\n }\n \n std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct)"
      },
      {
        "sha": "fa2299f0124a730d1d2ffc0161571eb9fcb693a7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=37a480e0cd94895b6051abef12d984ff74bdc4a3",
        "patch": "@@ -250,7 +250,7 @@ class CConnman\n     // Addrman functions\n     void SetServices(const CService &addr, ServiceFlags nServices);\n     void MarkAddressGood(const CAddress& addr);\n-    void AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n     std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n     /**\n      * Cache is used to minimize topology leaks, so it should"
      },
      {
        "sha": "97d1c003696d0ceb742b4c2a75435fc8a2a46f5f",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=37a480e0cd94895b6051abef12d984ff74bdc4a3",
        "patch": "@@ -173,6 +173,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"createwallet\", 4, \"avoid_reuse\"},\n     { \"createwallet\", 5, \"descriptors\"},\n     { \"getnodeaddresses\", 0, \"count\"},\n+    { \"addpeeraddress\", 1, \"port\"},\n     { \"stop\", 0, \"wait\" },\n };\n // clang-format on"
      },
      {
        "sha": "abd02bd2c3ac57a9f64f09a5c4b0439fadca2b1e",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37a480e0cd94895b6051abef12d984ff74bdc4a3/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=37a480e0cd94895b6051abef12d984ff74bdc4a3",
        "patch": "@@ -773,6 +773,54 @@ static UniValue getnodeaddresses(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static UniValue addpeeraddress(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"addpeeraddress\",\n+        \"\\nAdd the address of a potential peer to the address manager. This RPC is for testing only.\\n\",\n+        {\n+            {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address of the peer\"},\n+            {\"port\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The port of the peer\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::BOOL, \"success\", \"whether the peer address was successfully added to the address manager\"},\n+            },\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"addpeeraddress\", \"\\\"1.2.3.4\\\" 8333\")\n+    + HelpExampleRpc(\"addpeeraddress\", \"\\\"1.2.3.4\\\", 8333\")\n+        },\n+    }.Check(request);\n+\n+    NodeContext& node = EnsureNodeContext(request.context);\n+    if (!node.connman) {\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n+\n+    UniValue obj(UniValue::VOBJ);\n+\n+    std::string addr_string = request.params[0].get_str();\n+    uint16_t port = request.params[1].get_int();\n+\n+    CNetAddr net_addr;\n+    if (!LookupHost(addr_string, net_addr, false)) {\n+        obj.pushKV(\"success\", false);\n+        return obj;\n+    }\n+    CAddress address = CAddress({net_addr, port}, ServiceFlags(NODE_NETWORK|NODE_WITNESS));\n+    address.nTime = GetAdjustedTime();\n+    // The source address is set equal to the address. This is equivalent to the peer\n+    // announcing itself.\n+    if (!node.connman->AddNewAddresses({address}, address)) {\n+        obj.pushKV(\"success\", false);\n+        return obj;\n+    }\n+\n+    obj.pushKV(\"success\", true);\n+    return obj;\n+}\n+\n void RegisterNetRPCCommands(CRPCTable &t)\n {\n // clang-format off\n@@ -792,6 +840,7 @@ static const CRPCCommand commands[] =\n     { \"network\",            \"clearbanned\",            &clearbanned,            {} },\n     { \"network\",            \"setnetworkactive\",       &setnetworkactive,       {\"state\"} },\n     { \"network\",            \"getnodeaddresses\",       &getnodeaddresses,       {\"count\"} },\n+    { \"hidden\",             \"addpeeraddress\",         &addpeeraddress,         {\"address\", \"port\"} },\n };\n // clang-format on\n "
      },
      {
        "sha": "ef5ccf7c6de7f6ce298c738bf85cc44dfa027102",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 13,
        "deletions": 19,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37a480e0cd94895b6051abef12d984ff74bdc4a3/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37a480e0cd94895b6051abef12d984ff74bdc4a3/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=37a480e0cd94895b6051abef12d984ff74bdc4a3",
        "patch": "@@ -22,8 +22,6 @@\n from test_framework.mininode import P2PInterface\n import test_framework.messages\n from test_framework.messages import (\n-    CAddress,\n-    msg_addr,\n     NODE_NETWORK,\n     NODE_WITNESS,\n )\n@@ -154,29 +152,25 @@ def test_service_flags(self):\n     def _test_getnodeaddresses(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        # send some addresses to the node via the p2p message addr\n-        msg = msg_addr()\n+        # Add some addresses to the Address Manager over RPC. Due to the way\n+        # bucket and bucket position are calculated, some of these addresses\n+        # will collide.\n         imported_addrs = []\n-        for i in range(256):\n-            a = \"123.123.123.{}\".format(i)\n+        for i in range(10000):\n+            first_octet = i >> 8\n+            second_octet = i % 256\n+            a = \"{}.{}.1.1\".format(first_octet, second_octet)\n             imported_addrs.append(a)\n-            addr = CAddress()\n-            addr.time = 100000000\n-            addr.nServices = NODE_NETWORK | NODE_WITNESS\n-            addr.ip = a\n-            addr.port = 8333\n-            msg.addrs.append(addr)\n-        self.nodes[0].p2p.send_and_ping(msg)\n+            self.nodes[0].addpeeraddress(a, 8333)\n \n         # Obtain addresses via rpc call and check they were ones sent in before.\n         #\n-        # All addresses added above are in the same netgroup and so are assigned\n-        # to the same bucket. Maximum possible addresses in addrman is therefore\n-        # 64, although actual number will usually be slightly less due to\n-        # BucketPosition collisions.\n+        # Maximum possible addresses in addrman is 10000, although actual\n+        # number will usually be less due to bucket and bucket position\n+        # collisions.\n         node_addresses = self.nodes[0].getnodeaddresses(0)\n-        assert_greater_than(len(node_addresses), 50)\n-        assert_greater_than(65, len(node_addresses))\n+        assert_greater_than(len(node_addresses), 5000)\n+        assert_greater_than(10000, len(node_addresses))\n         for a in node_addresses:\n             assert_greater_than(a[\"time\"], 1527811200)  # 1st June 2018\n             assert_equal(a[\"services\"], NODE_NETWORK | NODE_WITNESS)"
      }
    ]
  }
]