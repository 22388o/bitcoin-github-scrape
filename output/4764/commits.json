[
  {
    "sha": "92bb6f2f1729192703dd49bb982c1dd4c0062fa0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MmJiNmYyZjE3MjkxOTI3MDNkZDQ5YmI5ODJjMWRkNGMwMDYyZmEw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-08-26T00:26:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-08-26T00:26:41Z"
      },
      "message": "Bypass reloading blocks from disk",
      "tree": {
        "sha": "a9fa5e6e1d20ce317542a3ebb899ace7e62cecd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a9fa5e6e1d20ce317542a3ebb899ace7e62cecd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92bb6f2f1729192703dd49bb982c1dd4c0062fa0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92bb6f2f1729192703dd49bb982c1dd4c0062fa0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92bb6f2f1729192703dd49bb982c1dd4c0062fa0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92bb6f2f1729192703dd49bb982c1dd4c0062fa0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "49f954f154e3576a6a8270e00ab95f52dd02c667",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49f954f154e3576a6a8270e00ab95f52dd02c667",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/49f954f154e3576a6a8270e00ab95f52dd02c667"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 27,
      "deletions": 18
    },
    "files": [
      {
        "sha": "a5c1103ef4f5366aef7be523f91c6ea1e2574588",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 17,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92bb6f2f1729192703dd49bb982c1dd4c0062fa0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92bb6f2f1729192703dd49bb982c1dd4c0062fa0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=92bb6f2f1729192703dd49bb982c1dd4c0062fa0",
        "patch": "@@ -1975,23 +1975,27 @@ static int64_t nTimeFlush = 0;\n static int64_t nTimeChainState = 0;\n static int64_t nTimePostConnect = 0;\n \n-// Connect a new block to chainActive.\n-bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n+// Connect a new block to chainActive. pblock is either NULL or a pointer to a CBlock\n+// corresponding to pindexNew, to bypass loading it again from disk.\n+bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *pblock) {\n     assert(pindexNew->pprev == chainActive.Tip());\n     mempool.check(pcoinsTip);\n     // Read block from disk.\n     int64_t nTime1 = GetTimeMicros();\n     CBlock block;\n-    if (!ReadBlockFromDisk(block, pindexNew))\n-        return state.Abort(_(\"Failed to read block\"));\n+    if (!pblock) {\n+        if (!ReadBlockFromDisk(block, pindexNew))\n+            return state.Abort(_(\"Failed to read block\"));\n+        pblock = &block;\n+    }\n     // Apply the block atomically to the chain state.\n     int64_t nTime2 = GetTimeMicros(); nTimeReadFromDisk += nTime2 - nTime1;\n     int64_t nTime3;\n     LogPrint(\"bench\", \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);\n     {\n         CCoinsViewCache view(*pcoinsTip, true);\n         CInv inv(MSG_BLOCK, pindexNew->GetBlockHash());\n-        if (!ConnectBlock(block, state, pindexNew, view)) {\n+        if (!ConnectBlock(*pblock, state, pindexNew, view)) {\n             if (state.IsInvalid())\n                 InvalidBlockFound(pindexNew, state);\n             return error(\"ConnectTip() : ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n@@ -2010,7 +2014,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n     LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.\n     list<CTransaction> txConflicted;\n-    mempool.removeForBlock(block.vtx, pindexNew->nHeight, txConflicted);\n+    mempool.removeForBlock(pblock->vtx, pindexNew->nHeight, txConflicted);\n     mempool.check(pcoinsTip);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew);\n@@ -2020,8 +2024,8 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n         SyncWithWallets(tx, NULL);\n     }\n     // ... and about transactions that got confirmed:\n-    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        SyncWithWallets(tx, &block);\n+    BOOST_FOREACH(const CTransaction &tx, pblock->vtx) {\n+        SyncWithWallets(tx, pblock);\n     }\n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n     LogPrint(\"bench\", \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);\n@@ -2070,7 +2074,8 @@ static CBlockIndex* FindMostWorkChain() {\n }\n \n // Try to make some progress towards making pindexMostWork the active block.\n-static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMostWork) {\n+// pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.\n+static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMostWork, CBlock *pblock) {\n     AssertLockHeld(cs_main);\n     bool fInvalidFound = false;\n     const CBlockIndex *pindexOldTip = chainActive.Tip();\n@@ -2085,14 +2090,15 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n     // Build list of new blocks to connect.\n     std::vector<CBlockIndex*> vpindexToConnect;\n     vpindexToConnect.reserve(pindexMostWork->nHeight - (pindexFork ? pindexFork->nHeight : -1));\n-    while (pindexMostWork && pindexMostWork != pindexFork) {\n-        vpindexToConnect.push_back(pindexMostWork);\n-        pindexMostWork = pindexMostWork->pprev;\n+    CBlockIndex *pindexIter = pindexMostWork;\n+    while (pindexIter && pindexIter != pindexFork) {\n+        vpindexToConnect.push_back(pindexIter);\n+        pindexIter = pindexIter->pprev;\n     }\n \n     // Connect new blocks.\n     BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n-        if (!ConnectTip(state, pindexConnect)) {\n+        if (!ConnectTip(state, pindexConnect, pindexConnect == pindexMostWork ? pblock : NULL)) {\n             if (state.IsInvalid()) {\n                 // The block violates a consensus rule.\n                 if (!state.CorruptionPossible())\n@@ -2133,7 +2139,10 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n     return true;\n }\n \n-bool ActivateBestChain(CValidationState &state) {\n+// Make the best chain active, in multiple steps. The result is either failure\n+// or an activated best chain. pblock is either NULL or a pointer to a block\n+// that is already loaded (to avoid loading it again from disk).\n+bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n     CBlockIndex *pindexNewTip = NULL;\n     CBlockIndex *pindexMostWork = NULL;\n     do {\n@@ -2148,7 +2157,7 @@ bool ActivateBestChain(CValidationState &state) {\n             if (pindexMostWork == NULL || pindexMostWork == chainActive.Tip())\n                 return true;\n \n-            if (!ActivateBestChainStep(state, pindexMostWork))\n+            if (!ActivateBestChainStep(state, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : NULL))\n                 return false;\n \n             pindexNewTip = chainActive.Tip();\n@@ -2696,7 +2705,7 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n \n     }\n \n-    if (!ActivateBestChain(state))\n+    if (!ActivateBestChain(state, pblock))\n         return error(\"ProcessBlock() : ActivateBestChain failed\");\n \n     return true;\n@@ -3136,7 +3145,7 @@ bool InitBlockIndex() {\n             CBlockIndex *pindex = AddToBlockIndex(block);\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos))\n                 return error(\"LoadBlockIndex() : genesis block not accepted\");\n-            if (!ActivateBestChain(state))\n+            if (!ActivateBestChain(state, &block))\n                 return error(\"LoadBlockIndex() : genesis block cannot be activated\");\n         } catch(std::runtime_error &e) {\n             return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());"
      },
      {
        "sha": "444c887204b88b02eef4ddf39bb98cb3cae06f17",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92bb6f2f1729192703dd49bb982c1dd4c0062fa0/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92bb6f2f1729192703dd49bb982c1dd4c0062fa0/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=92bb6f2f1729192703dd49bb982c1dd4c0062fa0",
        "patch": "@@ -160,7 +160,7 @@ std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n /** Find the best known block, and make it the tip of the block chain */\n-bool ActivateBestChain(CValidationState &state);\n+bool ActivateBestChain(CValidationState &state, CBlock *pblock = NULL);\n int64_t GetBlockValue(int nHeight, int64_t nFees);\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev);"
      }
    ]
  }
]