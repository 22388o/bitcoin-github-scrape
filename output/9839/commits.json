[
  {
    "sha": "864890adf5fefcf969f82f70949199b68b36f165",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NjQ4OTBhZGY1ZmVmY2Y5NjlmODJmNzA5NDkxOTliNjhiMzZmMTY1",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-23T18:05:40Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-23T19:09:43Z"
      },
      "message": "[qa] Make import-rescan.py watchonly check reliable\n\nSend payments during the test from a different node than the node generating\nkeys to be imported, so the spending node doesn't create transactions that\ninadvertently involve (spend funds from) the imported keys.\n\nFixes #9826",
      "tree": {
        "sha": "1b3ed2dff2382dc4967400b8fe1b7a2095f43404",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1b3ed2dff2382dc4967400b8fe1b7a2095f43404"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/864890adf5fefcf969f82f70949199b68b36f165",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/864890adf5fefcf969f82f70949199b68b36f165",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/864890adf5fefcf969f82f70949199b68b36f165",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/864890adf5fefcf969f82f70949199b68b36f165/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bed5b30a5622782b35d0d28fccde979e188901f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bed5b30a5622782b35d0d28fccde979e188901f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bed5b30a5622782b35d0d28fccde979e188901f1"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 18,
      "deletions": 12
    },
    "files": [
      {
        "sha": "7f2c321746c88c229c2680c6188e94061c13cb2c",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/864890adf5fefcf969f82f70949199b68b36f165/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/864890adf5fefcf969f82f70949199b68b36f165/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=864890adf5fefcf969f82f70949199b68b36f165",
        "patch": "@@ -5,11 +5,11 @@\n \"\"\"Test rescan behavior of importaddress, importpubkey, importprivkey, and\n importmulti RPCs with different types of keys and rescan options.\n \n-In the first part of the test, node 0 creates an address for each type of\n-import RPC call and sends BTC to it. Then other nodes import the addresses,\n-and the test makes listtransactions and getbalance calls to confirm that the\n-importing node either did or did not execute rescans picking up the send\n-transactions.\n+In the first part of the test, node 1 creates an address for each type of\n+import RPC call and node 0 sends BTC to it. Then other nodes import the\n+addresses, and the test makes listtransactions and getbalance calls to confirm\n+that the importing node either did or did not execute rescans picking up the\n+send transactions.\n \n In the second part of the test, node 0 sends more BTC to each address, and the\n test makes more listtransactions and getbalance calls to confirm that the\n@@ -81,6 +81,12 @@ def check(self, txid=None, amount=None, confirmations=None):\n             assert_equal(tx[\"txid\"], txid)\n             assert_equal(tx[\"confirmations\"], confirmations)\n             assert_equal(\"trusted\" not in tx, True)\n+            # Verify the transaction is correctly marked watchonly depending on\n+            # whether the transaction pays to an imported public key or\n+            # imported private key. The test setup ensures that transaction\n+            # inputs will not be from watchonly keys (important because\n+            # involvesWatchonly will be true if either the transaction output\n+            # or inputs are watchonly).\n             if self.data != Data.priv:\n                 assert_equal(tx[\"involvesWatchonly\"], True)\n             else:\n@@ -106,11 +112,11 @@ def check(self, txid=None, amount=None, confirmations=None):\n class ImportRescanTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n-        self.num_nodes = 1 + len(IMPORT_NODES)\n+        self.num_nodes = 2 + len(IMPORT_NODES)\n \n     def setup_network(self):\n         extra_args = [[\"-debug=1\"] for _ in range(self.num_nodes)]\n-        for i, import_node in enumerate(IMPORT_NODES, 1):\n+        for i, import_node in enumerate(IMPORT_NODES, 2):\n             if import_node.prune:\n                 extra_args[i] += [\"-prune=1\"]\n \n@@ -123,9 +129,9 @@ def run_test(self):\n         # each possible type of wallet import RPC.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n             variant.label = \"label {} {}\".format(i, variant)\n-            variant.address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress(variant.label))\n-            variant.key = self.nodes[0].dumpprivkey(variant.address[\"address\"])\n-            variant.initial_amount = 25 - (i + 1) / 4.0\n+            variant.address = self.nodes[1].validateaddress(self.nodes[1].getnewaddress(variant.label))\n+            variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n+            variant.initial_amount = 10 - (i + 1) / 4.0\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n \n         # Generate a block containing the initial transactions, then another\n@@ -142,7 +148,7 @@ def run_test(self):\n         for variant in IMPORT_VARIANTS:\n             variant.expect_disabled = variant.rescan == Rescan.yes and variant.prune and variant.call == Call.single\n             expect_rescan = variant.rescan == Rescan.yes and not variant.expect_disabled\n-            variant.node = self.nodes[1 + IMPORT_NODES.index(ImportNode(variant.prune, expect_rescan))]\n+            variant.node = self.nodes[2 + IMPORT_NODES.index(ImportNode(variant.prune, expect_rescan))]\n             variant.do_import(timestamp)\n             if expect_rescan:\n                 variant.expected_balance = variant.initial_amount\n@@ -156,7 +162,7 @@ def run_test(self):\n         # Create new transactions sending to each address.\n         fee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n         for i, variant in enumerate(IMPORT_VARIANTS):\n-            variant.sent_amount = 25 - (2 * i + 1) / 8.0\n+            variant.sent_amount = 10 - (2 * i + 1) / 8.0\n             variant.sent_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.sent_amount)\n \n         # Generate a block containing the new transactions."
      }
    ]
  }
]