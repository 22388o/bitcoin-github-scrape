[
  {
    "sha": "f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMTUyMWFjOWMyNmI0NzQ0MGIwYTFhYWNhNDZiZTBlNDBjM2ExMTE3",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-30T14:55:54Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:55:15Z"
      },
      "message": "move-only: Add txorphanage module\n\nThis module captures orphan tracking code for tx relay.\n\nCan be reviewed with --color-moved=dimmed-zebra",
      "tree": {
        "sha": "1a5045938b931d8c27f0b935900de0ae6fa3623d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1a5045938b931d8c27f0b935900de0ae6fa3623d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8d6994f93d3297cd8a84e73e8696bf21ff7da903",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d6994f93d3297cd8a84e73e8696bf21ff7da903",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d6994f93d3297cd8a84e73e8696bf21ff7da903"
      }
    ],
    "stats": {
      "total": 303,
      "additions": 169,
      "deletions": 134
    },
    "files": [
      {
        "sha": "cb9b719ae4c6fda716298a0a128b5d55ddcf91b4",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -224,8 +224,9 @@ BITCOIN_CORE_H = \\\n   timedata.h \\\n   torcontrol.h \\\n   txdb.h \\\n-  txrequest.h \\\n   txmempool.h \\\n+  txorphanage.h \\\n+  txrequest.h \\\n   undo.h \\\n   util/asmap.h \\\n   util/bip32.h \\\n@@ -343,8 +344,9 @@ libbitcoin_server_a_SOURCES = \\\n   timedata.cpp \\\n   torcontrol.cpp \\\n   txdb.cpp \\\n-  txrequest.cpp \\\n   txmempool.cpp \\\n+  txorphanage.cpp \\\n+  txrequest.cpp \\\n   validation.cpp \\\n   validationinterface.cpp \\\n   versionbits.cpp \\"
      },
      {
        "sha": "847dffa9d821805f6e0fe5b93821d035eb4a97b7",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -52,6 +52,7 @@\n #include <torcontrol.h>\n #include <txdb.h>\n #include <txmempool.h>\n+#include <txorphanage.h>\n #include <util/asmap.h>\n #include <util/check.h>\n #include <util/moneystr.h>"
      },
      {
        "sha": "36ddf6bfad4fd988a73c5175d4ce769a58c73285",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 122,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -26,6 +26,7 @@\n #include <streams.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n+#include <txorphanage.h>\n #include <txrequest.h>\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n@@ -35,10 +36,6 @@\n #include <memory>\n #include <typeinfo>\n \n-/** Expiration time for orphan transactions in seconds */\n-static constexpr int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n-/** Minimum time between orphan transactions expire time checks in seconds */\n-static constexpr int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n /** How long to cache transactions in mapRelay for normal relay */\n static constexpr std::chrono::seconds RELAY_TX_CACHE_TIME = std::chrono::minutes{15};\n /** How long a transaction has to be in the mempool before it can unconditionally be relayed (even when not in mapRelay). */\n@@ -148,25 +145,6 @@ static constexpr uint32_t MAX_GETCFHEADERS_SIZE = 2000;\n /** the maximum percentage of addresses from our addrman to return in response to a getaddr message. */\n static constexpr size_t MAX_PCT_ADDR_TO_SEND = 23;\n \n-struct COrphanTx {\n-    // When modifying, adapt the copy of this definition in tests/DoS_tests.\n-    CTransactionRef tx;\n-    NodeId fromPeer;\n-    int64_t nTimeExpire;\n-    size_t list_pos;\n-};\n-\n-/** Guards orphan transactions and extra txs for compact blocks */\n-RecursiveMutex g_cs_orphans;\n-/** Map from txid to orphan transaction record. Limited by\n- *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */\n-std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n-/** Index from wtxid into the mapOrphanTransactions to lookup orphan\n- *  transactions using their witness ids. */\n-std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n-\n-void EraseOrphansFor(NodeId peer);\n-\n // Internal stuff\n namespace {\n /** Blocks that are in flight, and that are in the queue to be downloaded. */\n@@ -474,21 +452,6 @@ namespace {\n     /** Number of preferable block download peers. */\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n \n-    struct IteratorComparator\n-    {\n-        template<typename I>\n-        bool operator()(const I& a, const I& b) const\n-        {\n-            return &(*a) < &(*b);\n-        }\n-    };\n-\n-    /** Index from the parents' COutPoint into the mapOrphanTransactions. Used\n-     *  to remove orphan transactions from the mapOrphanTransactions */\n-    std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n-    /** Orphan transactions in vector for quick random eviction */\n-    std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n-\n     /** Orphan/conflicted/etc transactions that are kept for compact block reconstruction.\n      *  The last -blockreconstructionextratxn/DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN of\n      *  these are kept in a ring buffer */\n@@ -1144,90 +1107,6 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n     return true;\n }\n \n-int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n-{\n-    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n-    if (it == mapOrphanTransactions.end())\n-        return 0;\n-    for (const CTxIn& txin : it->second.tx->vin)\n-    {\n-        auto itPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n-        if (itPrev == mapOrphanTransactionsByPrev.end())\n-            continue;\n-        itPrev->second.erase(it);\n-        if (itPrev->second.empty())\n-            mapOrphanTransactionsByPrev.erase(itPrev);\n-    }\n-\n-    size_t old_pos = it->second.list_pos;\n-    assert(g_orphan_list[old_pos] == it);\n-    if (old_pos + 1 != g_orphan_list.size()) {\n-        // Unless we're deleting the last entry in g_orphan_list, move the last\n-        // entry to the position we're deleting.\n-        auto it_last = g_orphan_list.back();\n-        g_orphan_list[old_pos] = it_last;\n-        it_last->second.list_pos = old_pos;\n-    }\n-    g_orphan_list.pop_back();\n-    g_orphans_by_wtxid.erase(it->second.tx->GetWitnessHash());\n-\n-    mapOrphanTransactions.erase(it);\n-    return 1;\n-}\n-\n-void EraseOrphansFor(NodeId peer)\n-{\n-    LOCK(g_cs_orphans);\n-    int nErased = 0;\n-    std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n-    while (iter != mapOrphanTransactions.end())\n-    {\n-        std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n-        if (maybeErase->second.fromPeer == peer)\n-        {\n-            nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n-        }\n-    }\n-    if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n-}\n-\n-\n-unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n-{\n-    LOCK(g_cs_orphans);\n-\n-    unsigned int nEvicted = 0;\n-    static int64_t nNextSweep;\n-    int64_t nNow = GetTime();\n-    if (nNextSweep <= nNow) {\n-        // Sweep out expired orphan pool entries:\n-        int nErased = 0;\n-        int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n-        std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n-        while (iter != mapOrphanTransactions.end())\n-        {\n-            std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n-            if (maybeErase->second.nTimeExpire <= nNow) {\n-                nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n-            } else {\n-                nMinExpTime = std::min(maybeErase->second.nTimeExpire, nMinExpTime);\n-            }\n-        }\n-        // Sweep again 5 minutes after the next entry that expires in order to batch the linear scan.\n-        nNextSweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n-        if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n-    }\n-    FastRandomContext rng;\n-    while (mapOrphanTransactions.size() > nMaxOrphans)\n-    {\n-        // Evict a random orphan:\n-        size_t randompos = rng.randrange(g_orphan_list.size());\n-        EraseOrphanTx(g_orphan_list[randompos]->first);\n-        ++nEvicted;\n-    }\n-    return nEvicted;\n-}\n-\n void PeerManagerImpl::Misbehaving(const NodeId pnode, const int howmuch, const std::string& message)\n {\n     assert(howmuch > 0);"
      },
      {
        "sha": "caada7464670e53c1c0ddb5edd5c68a56f3571a4",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -15,7 +15,6 @@ class CTxMemPool;\n class ChainstateManager;\n \n extern RecursiveMutex cs_main;\n-extern RecursiveMutex g_cs_orphans;\n \n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;"
      },
      {
        "sha": "87ab865aca62da6808cb7d11bde6767e226247c1",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -14,6 +14,7 @@\n #include <script/signingprovider.h>\n #include <script/standard.h>\n #include <serialize.h>\n+#include <txorphanage.h>\n #include <util/memory.h>\n #include <util/string.h>\n #include <util/system.h>\n@@ -45,15 +46,6 @@ struct CConnmanTest : public CConnman {\n \n // Tests these internal-to-net_processing.cpp methods:\n extern bool AddOrphanTx(const CTransactionRef& tx, NodeId peer);\n-extern void EraseOrphansFor(NodeId peer);\n-extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n-\n-struct COrphanTx {\n-    CTransactionRef tx;\n-    NodeId fromPeer;\n-    int64_t nTimeExpire;\n-};\n-extern std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n \n static CService ip(uint32_t i)\n {"
      },
      {
        "sha": "cea724344e665b75f9bcdf1b11c653e9e7c22d68",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -18,6 +18,7 @@\n #include <test/util/net.h>\n #include <test/util/setup_common.h>\n #include <test/util/validation.h>\n+#include <txorphanage.h>\n #include <util/memory.h>\n #include <validationinterface.h>\n #include <version.h>"
      },
      {
        "sha": "12186f4f25d64b9ffba9543f930803b975f619d2",
        "filename": "src/test/fuzz/process_messages.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/test/fuzz/process_messages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/test/fuzz/process_messages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_messages.cpp?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -13,6 +13,7 @@\n #include <test/util/net.h>\n #include <test/util/setup_common.h>\n #include <test/util/validation.h>\n+#include <txorphanage.h>\n #include <util/memory.h>\n #include <validation.h>\n #include <validationinterface.h>"
      },
      {
        "sha": "1d6391516225d2d5ae910ec7abf3746f9c07b6a8",
        "filename": "src/txorphanage.cpp",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -0,0 +1,106 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txorphanage.h>\n+\n+#include <consensus/validation.h>\n+#include <policy/policy.h>\n+\n+#include <assert.h>\n+\n+/** Minimum time between orphan transactions expire time checks in seconds */\n+static constexpr int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n+\n+RecursiveMutex g_cs_orphans;\n+\n+std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n+\n+    std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n+\n+    std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n+\n+int EraseOrphanTx(uint256 hash)\n+{\n+    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n+    if (it == mapOrphanTransactions.end())\n+        return 0;\n+    for (const CTxIn& txin : it->second.tx->vin)\n+    {\n+        auto itPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n+        if (itPrev == mapOrphanTransactionsByPrev.end())\n+            continue;\n+        itPrev->second.erase(it);\n+        if (itPrev->second.empty())\n+            mapOrphanTransactionsByPrev.erase(itPrev);\n+    }\n+\n+    size_t old_pos = it->second.list_pos;\n+    assert(g_orphan_list[old_pos] == it);\n+    if (old_pos + 1 != g_orphan_list.size()) {\n+        // Unless we're deleting the last entry in g_orphan_list, move the last\n+        // entry to the position we're deleting.\n+        auto it_last = g_orphan_list.back();\n+        g_orphan_list[old_pos] = it_last;\n+        it_last->second.list_pos = old_pos;\n+    }\n+    g_orphan_list.pop_back();\n+    g_orphans_by_wtxid.erase(it->second.tx->GetWitnessHash());\n+\n+    mapOrphanTransactions.erase(it);\n+    return 1;\n+}\n+\n+void EraseOrphansFor(NodeId peer)\n+{\n+    LOCK(g_cs_orphans);\n+    int nErased = 0;\n+    std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+    while (iter != mapOrphanTransactions.end())\n+    {\n+        std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n+        if (maybeErase->second.fromPeer == peer)\n+        {\n+            nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n+        }\n+    }\n+    if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n+}\n+\n+unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n+{\n+    LOCK(g_cs_orphans);\n+\n+    unsigned int nEvicted = 0;\n+    static int64_t nNextSweep;\n+    int64_t nNow = GetTime();\n+    if (nNextSweep <= nNow) {\n+        // Sweep out expired orphan pool entries:\n+        int nErased = 0;\n+        int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n+        std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n+        while (iter != mapOrphanTransactions.end())\n+        {\n+            std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n+            if (maybeErase->second.nTimeExpire <= nNow) {\n+                nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n+            } else {\n+                nMinExpTime = std::min(maybeErase->second.nTimeExpire, nMinExpTime);\n+            }\n+        }\n+        // Sweep again 5 minutes after the next entry that expires in order to batch the linear scan.\n+        nNextSweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n+        if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n+    }\n+    FastRandomContext rng;\n+    while (mapOrphanTransactions.size() > nMaxOrphans)\n+    {\n+        // Evict a random orphan:\n+        size_t randompos = rng.randrange(g_orphan_list.size());\n+        EraseOrphanTx(g_orphan_list[randompos]->first);\n+        ++nEvicted;\n+    }\n+    return nEvicted;\n+}\n+"
      },
      {
        "sha": "d97b4b1f43ba34eb4dbe081ddcdceaebf9bd0e02",
        "filename": "src/txorphanage.h",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1521ac9c26b47440b0a1aaca46be0e40c3a1117/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXORPHANAGE_H\n+#define BITCOIN_TXORPHANAGE_H\n+\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+\n+/** Expiration time for orphan transactions in seconds */\n+static constexpr int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n+\n+/** Guards orphan transactions and extra txs for compact blocks */\n+extern RecursiveMutex g_cs_orphans;\n+\n+struct COrphanTx {\n+    // When modifying, adapt the copy of this definition in tests/DoS_tests.\n+    CTransactionRef tx;\n+    NodeId fromPeer;\n+    int64_t nTimeExpire;\n+    size_t list_pos;\n+};\n+\n+int EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+void EraseOrphansFor(NodeId peer);\n+unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n+\n+/** Map from txid to orphan transaction record. Limited by\n+ *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */\n+extern std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+\n+/** Index from wtxid into the mapOrphanTransactions to lookup orphan\n+ *  transactions using their witness ids. */\n+extern std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n+\n+    struct IteratorComparator\n+    {\n+        template<typename I>\n+        bool operator()(const I& a, const I& b) const\n+        {\n+            return &(*a) < &(*b);\n+        }\n+    };\n+\n+    /** Index from the parents' COutPoint into the mapOrphanTransactions. Used\n+     *  to remove orphan transactions from the mapOrphanTransactions */\n+    extern std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n+\n+    /** Orphan transactions in vector for quick random eviction */\n+    extern std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n+\n+#endif // BITCOIN_TXORPHANAGE_H"
      }
    ]
  },
  {
    "sha": "b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOWMyN2I0MTcwM2FkMTcyNjFiM2Q0OTc5ZjhjZDhkNWI5YWQyMjU5",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:04:21Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:55:20Z"
      },
      "message": "txorphanage: Pass uint256 by reference instead of value",
      "tree": {
        "sha": "524d463ffbcd4bfdd859bbffe1b5bb7a43af3b7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/524d463ffbcd4bfdd859bbffe1b5bb7a43af3b7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1521ac9c26b47440b0a1aaca46be0e40c3a1117",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f1521ac9c26b47440b0a1aaca46be0e40c3a1117"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "5b08d1c521762ac04523cec9a937ae0ec6dba12c",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
        "patch": "@@ -21,9 +21,9 @@ std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUA\n \n     std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n \n-int EraseOrphanTx(uint256 hash)\n+int EraseOrphanTx(const uint256& txid)\n {\n-    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n+    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(txid);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n     for (const CTxIn& txin : it->second.tx->vin)"
      },
      {
        "sha": "343f12c9c5f787efc6ada828c5202abf73333499",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
        "patch": "@@ -23,7 +23,7 @@ struct COrphanTx {\n     size_t list_pos;\n };\n \n-int EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+int EraseOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void EraseOrphansFor(NodeId peer);\n unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n "
      }
    ]
  },
  {
    "sha": "8333ef6a3127bdb2280c9fe185df291d00f18d2b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MzMzZWY2YTMxMjdiZGIyMjgwYzlmZTE4NWRmMjkxZDAwZjE4ZDJi",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T15:35:08Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:55:20Z"
      },
      "message": "txorphanage: Add lock annotations\n\nEraseOrphansFor was called both with and without g_cs_orphans held,\ncorrect that so that it's always called with it already held.\n\nLimitOrphanTxSize was always called with g_cs_orphans held, so\nadd annotations and don't lock it a second time.",
      "tree": {
        "sha": "68099cc1bc4cb0fe52b5d055d81307e6630f7678",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/68099cc1bc4cb0fe52b5d055d81307e6630f7678"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8333ef6a3127bdb2280c9fe185df291d00f18d2b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8333ef6a3127bdb2280c9fe185df291d00f18d2b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8333ef6a3127bdb2280c9fe185df291d00f18d2b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8333ef6a3127bdb2280c9fe185df291d00f18d2b/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9c27b41703ad17261b3d4979f8cd8d5b9ad2259"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 6,
      "deletions": 5
    },
    "files": [
      {
        "sha": "3ee5dec7b0536b6ebb0c93efd6d3b9b06eb2b08f",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8333ef6a3127bdb2280c9fe185df291d00f18d2b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8333ef6a3127bdb2280c9fe185df291d00f18d2b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8333ef6a3127bdb2280c9fe185df291d00f18d2b",
        "patch": "@@ -990,7 +990,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n-    EraseOrphansFor(nodeid);\n+    WITH_LOCK(g_cs_orphans, EraseOrphansFor(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);"
      },
      {
        "sha": "fef827e0c4cd17bdcbe57c126cc16e11d0b5f6cf",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8333ef6a3127bdb2280c9fe185df291d00f18d2b/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8333ef6a3127bdb2280c9fe185df291d00f18d2b/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=8333ef6a3127bdb2280c9fe185df291d00f18d2b",
        "patch": "@@ -54,7 +54,8 @@ int EraseOrphanTx(const uint256& txid)\n \n void EraseOrphansFor(NodeId peer)\n {\n-    LOCK(g_cs_orphans);\n+    AssertLockHeld(g_cs_orphans);\n+\n     int nErased = 0;\n     std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n     while (iter != mapOrphanTransactions.end())\n@@ -70,7 +71,7 @@ void EraseOrphansFor(NodeId peer)\n \n unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n {\n-    LOCK(g_cs_orphans);\n+    AssertLockHeld(g_cs_orphans);\n \n     unsigned int nEvicted = 0;\n     static int64_t nNextSweep;"
      },
      {
        "sha": "d8dfaec8a007f116b8c70bd7ccaa6bbded1ef25c",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8333ef6a3127bdb2280c9fe185df291d00f18d2b/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8333ef6a3127bdb2280c9fe185df291d00f18d2b/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=8333ef6a3127bdb2280c9fe185df291d00f18d2b",
        "patch": "@@ -24,8 +24,8 @@ struct COrphanTx {\n };\n \n int EraseOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-void EraseOrphansFor(NodeId peer);\n-unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n+void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n /** Map from txid to orphan transaction record. Limited by\n  *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */"
      }
    ]
  },
  {
    "sha": "ac6c1bf29b209d3839c79501b4517b66a2dd3202",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYzZjMWJmMjliMjA5ZDM4MzljNzk1MDFiNDUxN2I2NmEyZGQzMjAy",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T10:36:24Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:55:20Z"
      },
      "message": "txorphanage: Extract AddChildrenToWorkSet\n\nExtract some common code into AddChildrenToWorkSet function.\n\n(It's a hard knock life)",
      "tree": {
        "sha": "14bee8367c702eca3f1b8d746214d9ab384b6be7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/14bee8367c702eca3f1b8d746214d9ab384b6be7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ac6c1bf29b209d3839c79501b4517b66a2dd3202",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac6c1bf29b209d3839c79501b4517b66a2dd3202",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ac6c1bf29b209d3839c79501b4517b66a2dd3202",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac6c1bf29b209d3839c79501b4517b66a2dd3202/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8333ef6a3127bdb2280c9fe185df291d00f18d2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8333ef6a3127bdb2280c9fe185df291d00f18d2b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8333ef6a3127bdb2280c9fe185df291d00f18d2b"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 16,
      "deletions": 16
    },
    "files": [
      {
        "sha": "f32fd09abf83d47adfe6479509f74403956abe4b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 16,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac6c1bf29b209d3839c79501b4517b66a2dd3202/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac6c1bf29b209d3839c79501b4517b66a2dd3202/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ac6c1bf29b209d3839c79501b4517b66a2dd3202",
        "patch": "@@ -2090,14 +2090,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n             RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n-            for (unsigned int i = 0; i < porphanTx->vout.size(); i++) {\n-                auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(orphanHash, i));\n-                if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n-                    for (const auto& elem : it_by_prev->second) {\n-                        orphan_work_set.insert(elem->first);\n-                    }\n-                }\n-            }\n+            AddChildrenToWorkSet(*porphanTx, orphan_work_set);\n             EraseOrphanTx(orphanHash);\n             for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n                 AddToCompactExtraTransactions(removedTx);\n@@ -3116,14 +3109,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             m_txrequest.ForgetTxHash(tx.GetHash());\n             m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n             RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n-            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(txid, i));\n-                if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n-                    for (const auto& elem : it_by_prev->second) {\n-                        peer->m_orphan_work_set.insert(elem->first);\n-                    }\n-                }\n-            }\n+            AddChildrenToWorkSet(tx, peer->m_orphan_work_set);\n \n             pfrom.nLastTXTime = GetTime();\n "
      },
      {
        "sha": "1b9ee1b01a6bbd1bb492c7b479db8f213d0bf8ee",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac6c1bf29b209d3839c79501b4517b66a2dd3202/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac6c1bf29b209d3839c79501b4517b66a2dd3202/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=ac6c1bf29b209d3839c79501b4517b66a2dd3202",
        "patch": "@@ -105,3 +105,16 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     return nEvicted;\n }\n \n+void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set)\n+{\n+    AssertLockHeld(g_cs_orphans);\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        const auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(tx.GetHash(), i));\n+        if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                orphan_work_set.insert(elem->first);\n+            }\n+        }\n+    }\n+}\n+"
      },
      {
        "sha": "c57249265e7e31c518b599fb2bc26608564eeb21",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac6c1bf29b209d3839c79501b4517b66a2dd3202/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac6c1bf29b209d3839c79501b4517b66a2dd3202/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=ac6c1bf29b209d3839c79501b4517b66a2dd3202",
        "patch": "@@ -26,6 +26,7 @@ struct COrphanTx {\n int EraseOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n /** Map from txid to orphan transaction record. Limited by\n  *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */"
      }
    ]
  },
  {
    "sha": "4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZmJlYmI5N2Q4YzYxZTNlYTViMTBiN2EzMDhiMTg3ZTI3MjczY2Vk",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T11:24:08Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:55:20Z"
      },
      "message": "txorphanage: Extract HaveOrphanTx\n\nExtract some common code into HaveOrphanTx function.",
      "tree": {
        "sha": "b4551d3eac3195d26643b6bd01d60fcc1444485d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b4551d3eac3195d26643b6bd01d60fcc1444485d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ac6c1bf29b209d3839c79501b4517b66a2dd3202",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac6c1bf29b209d3839c79501b4517b66a2dd3202",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac6c1bf29b209d3839c79501b4517b66a2dd3202"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 12,
      "deletions": 8
    },
    "files": [
      {
        "sha": "5f211e0df2870cfdafe3f2f38cfa48d2caca438f",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
        "patch": "@@ -1484,14 +1484,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIR\n \n     const uint256& hash = gtxid.GetHash();\n \n-    {\n-        LOCK(g_cs_orphans);\n-        if (!gtxid.IsWtxid() && mapOrphanTransactions.count(hash)) {\n-            return true;\n-        } else if (gtxid.IsWtxid() && g_orphans_by_wtxid.count(hash)) {\n-            return true;\n-        }\n-    }\n+    if (HaveOrphanTx(gtxid)) return true;\n \n     {\n         LOCK(m_recent_confirmed_transactions_mutex);"
      },
      {
        "sha": "6784d7a43a39e6dfe423c111b53a11cd181d302c",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
        "patch": "@@ -118,3 +118,13 @@ void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work\n     }\n }\n \n+bool HaveOrphanTx(const GenTxid& gtxid)\n+{\n+    LOCK(g_cs_orphans);\n+    if (gtxid.IsWtxid()) {\n+        return g_orphans_by_wtxid.count(gtxid.GetHash()) > 0;\n+    } else {\n+        return mapOrphanTransactions.count(gtxid.GetHash()) > 0;\n+    }\n+}\n+"
      },
      {
        "sha": "ab4960be69340945bdecf19671a3a169cb14cdbc",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4fbebb97d8c61e3ea5b10b7a308b187e27273ced/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
        "patch": "@@ -27,6 +27,7 @@ int EraseOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+bool HaveOrphanTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n \n /** Map from txid to orphan transaction record. Limited by\n  *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */"
      }
    ]
  },
  {
    "sha": "cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzJhZGZjZmYwZDNhNWVlZGE5MzVjNjg3NGQwNGQ5Zjc5YTdmNjgw",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T11:59:57Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:55:20Z"
      },
      "message": "txorphanage: Extract GetOrphanTx\n\nExtract orphan lookup code into GetOrphanTx function.",
      "tree": {
        "sha": "ebeee044bb211af292b35eaad614ee1aefb3988a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ebeee044bb211af292b35eaad614ee1aefb3988a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fbebb97d8c61e3ea5b10b7a308b187e27273ced",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4fbebb97d8c61e3ea5b10b7a308b187e27273ced"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 14,
      "deletions": 5
    },
    "files": [
      {
        "sha": "31735b95281e447ea7575cab5de91fe3c62c59be",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
        "patch": "@@ -2073,10 +2073,10 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         const uint256 orphanHash = *orphan_work_set.begin();\n         orphan_work_set.erase(orphan_work_set.begin());\n \n-        auto orphan_it = mapOrphanTransactions.find(orphanHash);\n-        if (orphan_it == mapOrphanTransactions.end()) continue;\n+        const COrphanTx* orphantx = GetOrphanTx(orphanHash);\n+        if (orphantx == nullptr) continue;\n \n-        const CTransactionRef porphanTx = orphan_it->second.tx;\n+        const CTransactionRef porphanTx = orphantx->tx;\n         const MempoolAcceptResult result = AcceptToMemoryPool(m_mempool, porphanTx, false /* bypass_limits */);\n         const TxValidationState& state = result.m_state;\n \n@@ -2093,10 +2093,10 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n             if (state.IsInvalid()) {\n                 LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s from peer=%d. %s\\n\",\n                     orphanHash.ToString(),\n-                    orphan_it->second.fromPeer,\n+                    orphantx->fromPeer,\n                     state.ToString());\n                 // Maybe punish peer that gave us an invalid orphan tx\n-                MaybePunishNodeForTx(orphan_it->second.fromPeer, state);\n+                MaybePunishNodeForTx(orphantx->fromPeer, state);\n             }\n             // Has inputs but not accepted to mempool\n             // Probably non-standard or insufficient fee"
      },
      {
        "sha": "fc5d80438e7ce4b63a43097b69e8bb404468e4e3",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
        "patch": "@@ -128,3 +128,11 @@ bool HaveOrphanTx(const GenTxid& gtxid)\n     }\n }\n \n+COrphanTx* GetOrphanTx(const uint256& txid)\n+{\n+    AssertLockHeld(g_cs_orphans);\n+\n+    const auto it = mapOrphanTransactions.find(txid);\n+    if (it == mapOrphanTransactions.end()) return nullptr;\n+    return &it->second;\n+}"
      },
      {
        "sha": "05912128de776021986c1a90bf21a75c8b5d5e40",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
        "patch": "@@ -28,6 +28,7 @@ void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n bool HaveOrphanTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n+COrphanTx* GetOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n /** Map from txid to orphan transaction record. Limited by\n  *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */"
      }
    ]
  },
  {
    "sha": "f991733fce501b365b5b8da9b35c0e9ed5509741",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTkxNzMzZmNlNTAxYjM2NWI1YjhkYTliMzVjMGU5ZWQ1NTA5NzQx",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T13:12:24Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:57:12Z"
      },
      "message": "txorphanage: Extract OrphanageAddTx\n\nExtract code from AddOrphanTx into OrphanageAddTx.",
      "tree": {
        "sha": "e9b30b1adcc60da7e417beb5ef1d31b0c19221d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e9b30b1adcc60da7e417beb5ef1d31b0c19221d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f991733fce501b365b5b8da9b35c0e9ed5509741",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f991733fce501b365b5b8da9b35c0e9ed5509741",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f991733fce501b365b5b8da9b35c0e9ed5509741",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f991733fce501b365b5b8da9b35c0e9ed5509741/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc2adfcff0d3a5eeda935c6874d04d9f79a7f680"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 40,
      "deletions": 29
    },
    "files": [
      {
        "sha": "d026c97c760e3a4e993342d5f81c3b9f745ae6b4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 26,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f991733fce501b365b5b8da9b35c0e9ed5509741/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f991733fce501b365b5b8da9b35c0e9ed5509741/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f991733fce501b365b5b8da9b35c0e9ed5509741",
        "patch": "@@ -1073,37 +1073,12 @@ static void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_L\n \n bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n-    const uint256& hash = tx->GetHash();\n-    if (mapOrphanTransactions.count(hash))\n+    if (!OrphanageAddTx(tx, peer)) {\n         return false;\n-\n-    // Ignore big transactions, to avoid a\n-    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n-    // large transaction with a missing parent then we assume\n-    // it will rebroadcast it later, after the parent transaction(s)\n-    // have been mined or received.\n-    // 100 orphans, each of which is at most 100,000 bytes big is\n-    // at most 10 megabytes of orphans and somewhat more byprev index (in the worst case):\n-    unsigned int sz = GetTransactionWeight(*tx);\n-    if (sz > MAX_STANDARD_TX_WEIGHT)\n-    {\n-        LogPrint(BCLog::MEMPOOL, \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n-        return false;\n-    }\n-\n-    auto ret = mapOrphanTransactions.emplace(hash, COrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME, g_orphan_list.size()});\n-    assert(ret.second);\n-    g_orphan_list.push_back(ret.first);\n-    // Allow for lookups in the orphan pool by wtxid, as well as txid\n-    g_orphans_by_wtxid.emplace(tx->GetWitnessHash(), ret.first);\n-    for (const CTxIn& txin : tx->vin) {\n-        mapOrphanTransactionsByPrev[txin.prevout].insert(ret.first);\n     }\n \n     AddToCompactExtraTransactions(tx);\n \n-    LogPrint(BCLog::MEMPOOL, \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n-             mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n     return true;\n }\n "
      },
      {
        "sha": "0b8bf11dcf00a4d8e99753dfcc230820d1ec7aaf",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f991733fce501b365b5b8da9b35c0e9ed5509741/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f991733fce501b365b5b8da9b35c0e9ed5509741/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=f991733fce501b365b5b8da9b35c0e9ed5509741",
        "patch": "@@ -9,6 +9,8 @@\n \n #include <assert.h>\n \n+/** Expiration time for orphan transactions in seconds */\n+static constexpr int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n /** Minimum time between orphan transactions expire time checks in seconds */\n static constexpr int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n \n@@ -21,6 +23,42 @@ std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUA\n \n     std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n \n+bool OrphanageAddTx(const CTransactionRef& tx, NodeId peer)\n+{\n+    AssertLockHeld(g_cs_orphans);\n+\n+    const uint256& hash = tx->GetHash();\n+    if (mapOrphanTransactions.count(hash))\n+        return false;\n+\n+    // Ignore big transactions, to avoid a\n+    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n+    // large transaction with a missing parent then we assume\n+    // it will rebroadcast it later, after the parent transaction(s)\n+    // have been mined or received.\n+    // 100 orphans, each of which is at most 100,000 bytes big is\n+    // at most 10 megabytes of orphans and somewhat more byprev index (in the worst case):\n+    unsigned int sz = GetTransactionWeight(*tx);\n+    if (sz > MAX_STANDARD_TX_WEIGHT)\n+    {\n+        LogPrint(BCLog::MEMPOOL, \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n+        return false;\n+    }\n+\n+    auto ret = mapOrphanTransactions.emplace(hash, COrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME, g_orphan_list.size()});\n+    assert(ret.second);\n+    g_orphan_list.push_back(ret.first);\n+    // Allow for lookups in the orphan pool by wtxid, as well as txid\n+    g_orphans_by_wtxid.emplace(tx->GetWitnessHash(), ret.first);\n+    for (const CTxIn& txin : tx->vin) {\n+        mapOrphanTransactionsByPrev[txin.prevout].insert(ret.first);\n+    }\n+\n+    LogPrint(BCLog::MEMPOOL, \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n+             mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n+    return true;\n+}\n+\n int EraseOrphanTx(const uint256& txid)\n {\n     std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(txid);"
      },
      {
        "sha": "357ecffa24f33733d1fb08b55fce8844e1d75abb",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f991733fce501b365b5b8da9b35c0e9ed5509741/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f991733fce501b365b5b8da9b35c0e9ed5509741/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=f991733fce501b365b5b8da9b35c0e9ed5509741",
        "patch": "@@ -9,9 +9,6 @@\n #include <primitives/transaction.h>\n #include <sync.h>\n \n-/** Expiration time for orphan transactions in seconds */\n-static constexpr int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n-\n /** Guards orphan transactions and extra txs for compact blocks */\n extern RecursiveMutex g_cs_orphans;\n \n@@ -29,6 +26,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n bool HaveOrphanTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n COrphanTx* GetOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+bool OrphanageAddTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n /** Map from txid to orphan transaction record. Limited by\n  *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */"
      }
    ]
  },
  {
    "sha": "4095e44621043d97924d1a71214af73b6b1c77b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MDk1ZTQ0NjIxMDQzZDk3OTI0ZDFhNzEyMTRhZjczYjZiMWM3N2I0",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T16:00:14Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:57:18Z"
      },
      "message": "denialofservices_tests: check txorphanage's AddTx\n\nRather than checking net_processing's internal implementation of\nAddOrphanTx, test txorphanage's exported AddTx interface. Note that\nthis means AddToCompactExtraTransactions is no longer tested here.",
      "tree": {
        "sha": "8f8fd4388246a7fcc97958ca5faa087324c87a21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f8fd4388246a7fcc97958ca5faa087324c87a21"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4095e44621043d97924d1a71214af73b6b1c77b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4095e44621043d97924d1a71214af73b6b1c77b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4095e44621043d97924d1a71214af73b6b1c77b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4095e44621043d97924d1a71214af73b6b1c77b4/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f991733fce501b365b5b8da9b35c0e9ed5509741",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f991733fce501b365b5b8da9b35c0e9ed5509741",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f991733fce501b365b5b8da9b35c0e9ed5509741"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 5,
      "deletions": 7
    },
    "files": [
      {
        "sha": "0c4f8fb94cb494498a6708431d07e11262d585d9",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4095e44621043d97924d1a71214af73b6b1c77b4/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4095e44621043d97924d1a71214af73b6b1c77b4/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=4095e44621043d97924d1a71214af73b6b1c77b4",
        "patch": "@@ -44,9 +44,6 @@ struct CConnmanTest : public CConnman {\n     }\n };\n \n-// Tests these internal-to-net_processing.cpp methods:\n-extern bool AddOrphanTx(const CTransactionRef& tx, NodeId peer);\n-\n static CService ip(uint32_t i)\n {\n     struct in_addr s;\n@@ -320,6 +317,8 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     FillableSigningProvider keystore;\n     BOOST_CHECK(keystore.AddKey(key));\n \n+    LOCK(g_cs_orphans);\n+\n     // 50 orphan transactions:\n     for (int i = 0; i < 50; i++)\n     {\n@@ -332,7 +331,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout[0].nValue = 1*CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));\n \n-        AddOrphanTx(MakeTransactionRef(tx), i);\n+        OrphanageAddTx(MakeTransactionRef(tx), i);\n     }\n \n     // ... and 50 that depend on other orphans:\n@@ -349,7 +348,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));\n         BOOST_CHECK(SignSignature(keystore, *txPrev, tx, 0, SIGHASH_ALL));\n \n-        AddOrphanTx(MakeTransactionRef(tx), i);\n+        OrphanageAddTx(MakeTransactionRef(tx), i);\n     }\n \n     // This really-big orphan should be ignored:\n@@ -373,10 +372,9 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         for (unsigned int j = 1; j < tx.vin.size(); j++)\n             tx.vin[j].scriptSig = tx.vin[0].scriptSig;\n \n-        BOOST_CHECK(!AddOrphanTx(MakeTransactionRef(tx), i));\n+        BOOST_CHECK(!OrphanageAddTx(MakeTransactionRef(tx), i));\n     }\n \n-    LOCK2(cs_main, g_cs_orphans);\n     // Test EraseOrphansFor:\n     for (NodeId i = 0; i < 3; i++)\n     {"
      }
    ]
  },
  {
    "sha": "06b1d03f94a0f7b18b0e24d416117226876de3e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNmIxZDAzZjk0YTBmN2IxOGIwZTI0ZDQxNjExNzIyNjg3NmRlM2U3",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T13:37:41Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T13:57:18Z"
      },
      "message": "txorphanage: Extract EraseOrphansForBlock\n\nExtract code that erases orphans when a new block is found into\nEraseOrphansForBlock.",
      "tree": {
        "sha": "8563a5396cc02445ad2a8f6ce985ee64588c17ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8563a5396cc02445ad2a8f6ce985ee64588c17ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/06b1d03f94a0f7b18b0e24d416117226876de3e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06b1d03f94a0f7b18b0e24d416117226876de3e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/06b1d03f94a0f7b18b0e24d416117226876de3e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06b1d03f94a0f7b18b0e24d416117226876de3e7/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4095e44621043d97924d1a71214af73b6b1c77b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4095e44621043d97924d1a71214af73b6b1c77b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4095e44621043d97924d1a71214af73b6b1c77b4"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 34,
      "deletions": 30
    },
    "files": [
      {
        "sha": "b325bfa22564894aa51d3a95723c2370608ee7b2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 30,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06b1d03f94a0f7b18b0e24d416117226876de3e7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06b1d03f94a0f7b18b0e24d416117226876de3e7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=06b1d03f94a0f7b18b0e24d416117226876de3e7",
        "patch": "@@ -1247,37 +1247,9 @@ PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& conn\n  */\n void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex)\n {\n-    {\n-        LOCK(g_cs_orphans);\n-\n-        std::vector<uint256> vOrphanErase;\n-\n-        for (const CTransactionRef& ptx : pblock->vtx) {\n-            const CTransaction& tx = *ptx;\n+    EraseOrphansForBlock(*pblock);\n+    m_last_tip_update = GetTime();\n \n-            // Which orphan pool entries must we evict?\n-            for (const auto& txin : tx.vin) {\n-                auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n-                if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n-                for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n-                    const CTransaction& orphanTx = *(*mi)->second.tx;\n-                    const uint256& orphanHash = orphanTx.GetHash();\n-                    vOrphanErase.push_back(orphanHash);\n-                }\n-            }\n-        }\n-\n-        // Erase orphan transactions included or precluded by this block\n-        if (vOrphanErase.size()) {\n-            int nErased = 0;\n-            for (const uint256& orphanHash : vOrphanErase) {\n-                nErased += EraseOrphanTx(orphanHash);\n-            }\n-            LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n-        }\n-\n-        m_last_tip_update = GetTime();\n-    }\n     {\n         LOCK(m_recent_confirmed_transactions_mutex);\n         for (const auto& ptx : pblock->vtx) {"
      },
      {
        "sha": "1735d1242400de07727b3da1c9f4cc0cb44b784c",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06b1d03f94a0f7b18b0e24d416117226876de3e7/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06b1d03f94a0f7b18b0e24d416117226876de3e7/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=06b1d03f94a0f7b18b0e24d416117226876de3e7",
        "patch": "@@ -174,3 +174,34 @@ COrphanTx* GetOrphanTx(const uint256& txid)\n     if (it == mapOrphanTransactions.end()) return nullptr;\n     return &it->second;\n }\n+\n+void EraseOrphansForBlock(const CBlock& block)\n+{\n+    LOCK(g_cs_orphans);\n+\n+    std::vector<uint256> vOrphanErase;\n+\n+    for (const CTransactionRef& ptx : block.vtx) {\n+        const CTransaction& tx = *ptx;\n+\n+        // Which orphan pool entries must we evict?\n+        for (const auto& txin : tx.vin) {\n+            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n+            if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n+            for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n+                const CTransaction& orphanTx = *(*mi)->second.tx;\n+                const uint256& orphanHash = orphanTx.GetHash();\n+                vOrphanErase.push_back(orphanHash);\n+            }\n+        }\n+    }\n+\n+    // Erase orphan transactions included or precluded by this block\n+    if (vOrphanErase.size()) {\n+        int nErased = 0;\n+        for (const uint256& orphanHash : vOrphanErase) {\n+            nErased += EraseOrphanTx(orphanHash);\n+        }\n+        LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n+    }\n+}"
      },
      {
        "sha": "30782daf4da67819124b82e3abfd883095b4349a",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06b1d03f94a0f7b18b0e24d416117226876de3e7/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06b1d03f94a0f7b18b0e24d416117226876de3e7/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=06b1d03f94a0f7b18b0e24d416117226876de3e7",
        "patch": "@@ -22,6 +22,7 @@ struct COrphanTx {\n \n int EraseOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+void EraseOrphansForBlock(const CBlock& block) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n bool HaveOrphanTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);"
      }
    ]
  },
  {
    "sha": "9c0514cd5be16179e53bfe9934a01948f9d27d2a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YzA1MTRjZDViZTE2MTc5ZTUzYmZlOTkzNGEwMTk0OGY5ZDI3ZDJh",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T13:42:00Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:17:10Z"
      },
      "message": "txorphanage: Move functions and data into class\n\nCollects all the orphan handling globals into a single global in\nnet_processing, and ensures access is encapuslated into the interface\nfunctions. Also adds doxygen comments for methods.",
      "tree": {
        "sha": "130bd9756a25c359bec6d8e6d115fcca1098e83e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/130bd9756a25c359bec6d8e6d115fcca1098e83e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c0514cd5be16179e53bfe9934a01948f9d27d2a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c0514cd5be16179e53bfe9934a01948f9d27d2a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c0514cd5be16179e53bfe9934a01948f9d27d2a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c0514cd5be16179e53bfe9934a01948f9d27d2a/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06b1d03f94a0f7b18b0e24d416117226876de3e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06b1d03f94a0f7b18b0e24d416117226876de3e7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06b1d03f94a0f7b18b0e24d416117226876de3e7"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 110,
      "deletions": 92
    },
    "files": [
      {
        "sha": "780a5c2979c54eb48b9f0188d8e26f271ac556f6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 27,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "patch": "@@ -198,7 +198,7 @@ struct Peer {\n     std::atomic<int> m_starting_height{-1};\n \n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n-    std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n+    TxOrphanage::WorkSet m_orphan_work_set GUARDED_BY(g_cs_orphans);\n \n     /** Protects m_getdata_requests **/\n     Mutex m_getdata_requests_mutex;\n@@ -448,6 +448,8 @@ class PeerManagerImpl final : public PeerManager\n } // namespace\n \n namespace {\n+    /** Storage for orphan information */\n+    TxOrphanage m_orphanage;\n \n     /** Number of preferable block download peers. */\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n@@ -990,7 +992,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n-    WITH_LOCK(g_cs_orphans, EraseOrphansFor(nodeid));\n+    WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n@@ -1057,7 +1059,7 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n \n //////////////////////////////////////////////////////////////////////////////\n //\n-// mapOrphanTransactions\n+// Orphan handling\n //\n \n static void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n@@ -1073,7 +1075,7 @@ static void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_L\n \n bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n-    if (!OrphanageAddTx(tx, peer)) {\n+    if (!m_orphanage.AddTx(tx, peer)) {\n         return false;\n     }\n \n@@ -1241,13 +1243,13 @@ PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& conn\n }\n \n /**\n- * Evict orphan txn pool entries (EraseOrphanTx) based on a newly connected\n+ * Evict orphan txn pool entries based on a newly connected\n  * block, remember the recently confirmed transactions, and delete tracked\n  * announcements for them. Also save the time of the last tip update.\n  */\n void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex)\n {\n-    EraseOrphansForBlock(*pblock);\n+    m_orphanage.EraseForBlock(*pblock);\n     m_last_tip_update = GetTime();\n \n     {\n@@ -1431,7 +1433,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIR\n \n     const uint256& hash = gtxid.GetHash();\n \n-    if (HaveOrphanTx(gtxid)) return true;\n+    if (m_orphanage.HaveTx(gtxid)) return true;\n \n     {\n         LOCK(m_recent_confirmed_transactions_mutex);\n@@ -2020,7 +2022,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         const uint256 orphanHash = *orphan_work_set.begin();\n         orphan_work_set.erase(orphan_work_set.begin());\n \n-        const COrphanTx* orphantx = GetOrphanTx(orphanHash);\n+        const TxOrphanage::COrphanTx* orphantx = m_orphanage.GetTx(orphanHash);\n         if (orphantx == nullptr) continue;\n \n         const CTransactionRef porphanTx = orphantx->tx;\n@@ -2030,8 +2032,8 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n             RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n-            AddChildrenToWorkSet(*porphanTx, orphan_work_set);\n-            EraseOrphanTx(orphanHash);\n+            m_orphanage.AddChildrenToWorkSet(*porphanTx, orphan_work_set);\n+            m_orphanage.EraseTx(orphanHash);\n             for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n                 AddToCompactExtraTransactions(removedTx);\n             }\n@@ -2078,7 +2080,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n                     recentRejects->insert(porphanTx->GetHash());\n                 }\n             }\n-            EraseOrphanTx(orphanHash);\n+            m_orphanage.EraseTx(orphanHash);\n             break;\n         }\n     }\n@@ -3049,7 +3051,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             m_txrequest.ForgetTxHash(tx.GetHash());\n             m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n             RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n-            AddChildrenToWorkSet(tx, peer->m_orphan_work_set);\n+            m_orphanage.AddChildrenToWorkSet(tx, peer->m_orphan_work_set);\n \n             pfrom.nLastTXTime = GetTime();\n \n@@ -3104,11 +3106,11 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 m_txrequest.ForgetTxHash(tx.GetHash());\n                 m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n \n-                // DoS prevention: do not allow mapOrphanTransactions to grow unbounded (see CVE-2012-3789)\n+                // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n                 unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n-                unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n+                unsigned int nEvicted = m_orphanage.LimitOrphans(nMaxOrphanTx);\n                 if (nEvicted > 0) {\n-                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                    LogPrint(BCLog::MEMPOOL, \"orphanage overflow, removed %u tx\\n\", nEvicted);\n                 }\n             } else {\n                 LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n@@ -4700,15 +4702,3 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     return true;\n }\n \n-class CNetProcessingCleanup\n-{\n-public:\n-    CNetProcessingCleanup() {}\n-    ~CNetProcessingCleanup() {\n-        // orphan transactions\n-        mapOrphanTransactions.clear();\n-        mapOrphanTransactionsByPrev.clear();\n-        g_orphans_by_wtxid.clear();\n-    }\n-};\n-static CNetProcessingCleanup instance_of_cnetprocessingcleanup;"
      },
      {
        "sha": "28fde9d078d028482a55c7cff575485cc19fde4f",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 22,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "patch": "@@ -284,15 +284,23 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     peerLogic->FinalizeNode(dummyNode, dummy);\n }\n \n-static CTransactionRef RandomOrphan()\n+class TxOrphanageTest : public TxOrphanage\n {\n-    std::map<uint256, COrphanTx>::iterator it;\n-    LOCK2(cs_main, g_cs_orphans);\n-    it = mapOrphanTransactions.lower_bound(InsecureRand256());\n-    if (it == mapOrphanTransactions.end())\n-        it = mapOrphanTransactions.begin();\n-    return it->second.tx;\n-}\n+public:\n+    inline size_t CountOrphans() const EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+    {\n+        return mapOrphanTransactions.size();\n+    }\n+\n+    CTransactionRef RandomOrphan() EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+    {\n+        std::map<uint256, COrphanTx>::iterator it;\n+        it = mapOrphanTransactions.lower_bound(InsecureRand256());\n+        if (it == mapOrphanTransactions.end())\n+            it = mapOrphanTransactions.begin();\n+        return it->second.tx;\n+    }\n+};\n \n static void MakeNewKeyWithFastRandomContext(CKey& key)\n {\n@@ -312,6 +320,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     // signature's R and S values have leading zeros.\n     g_insecure_rand_ctx = FastRandomContext(ArithToUint256(arith_uint256(33)));\n \n+    TxOrphanageTest orphanage;\n     CKey key;\n     MakeNewKeyWithFastRandomContext(key);\n     FillableSigningProvider keystore;\n@@ -331,13 +340,13 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout[0].nValue = 1*CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));\n \n-        OrphanageAddTx(MakeTransactionRef(tx), i);\n+        orphanage.AddTx(MakeTransactionRef(tx), i);\n     }\n \n     // ... and 50 that depend on other orphans:\n     for (int i = 0; i < 50; i++)\n     {\n-        CTransactionRef txPrev = RandomOrphan();\n+        CTransactionRef txPrev = orphanage.RandomOrphan();\n \n         CMutableTransaction tx;\n         tx.vin.resize(1);\n@@ -348,13 +357,13 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));\n         BOOST_CHECK(SignSignature(keystore, *txPrev, tx, 0, SIGHASH_ALL));\n \n-        OrphanageAddTx(MakeTransactionRef(tx), i);\n+        orphanage.AddTx(MakeTransactionRef(tx), i);\n     }\n \n     // This really-big orphan should be ignored:\n     for (int i = 0; i < 10; i++)\n     {\n-        CTransactionRef txPrev = RandomOrphan();\n+        CTransactionRef txPrev = orphanage.RandomOrphan();\n \n         CMutableTransaction tx;\n         tx.vout.resize(1);\n@@ -372,24 +381,24 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         for (unsigned int j = 1; j < tx.vin.size(); j++)\n             tx.vin[j].scriptSig = tx.vin[0].scriptSig;\n \n-        BOOST_CHECK(!OrphanageAddTx(MakeTransactionRef(tx), i));\n+        BOOST_CHECK(!orphanage.AddTx(MakeTransactionRef(tx), i));\n     }\n \n     // Test EraseOrphansFor:\n     for (NodeId i = 0; i < 3; i++)\n     {\n-        size_t sizeBefore = mapOrphanTransactions.size();\n-        EraseOrphansFor(i);\n-        BOOST_CHECK(mapOrphanTransactions.size() < sizeBefore);\n+        size_t sizeBefore = orphanage.CountOrphans();\n+        orphanage.EraseForPeer(i);\n+        BOOST_CHECK(orphanage.CountOrphans() < sizeBefore);\n     }\n \n     // Test LimitOrphanTxSize() function:\n-    LimitOrphanTxSize(40);\n-    BOOST_CHECK(mapOrphanTransactions.size() <= 40);\n-    LimitOrphanTxSize(10);\n-    BOOST_CHECK(mapOrphanTransactions.size() <= 10);\n-    LimitOrphanTxSize(0);\n-    BOOST_CHECK(mapOrphanTransactions.empty());\n+    orphanage.LimitOrphans(40);\n+    BOOST_CHECK(orphanage.CountOrphans() <= 40);\n+    orphanage.LimitOrphans(10);\n+    BOOST_CHECK(orphanage.CountOrphans() <= 10);\n+    orphanage.LimitOrphans(0);\n+    BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "91c49f5fee2ca29310fe3d0d8960da1503686e1f",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 19,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "patch": "@@ -16,14 +16,7 @@ static constexpr int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n \n RecursiveMutex g_cs_orphans;\n \n-std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n-std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n-\n-    std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n-\n-    std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n-\n-bool OrphanageAddTx(const CTransactionRef& tx, NodeId peer)\n+bool TxOrphanage::AddTx(const CTransactionRef& tx, NodeId peer)\n {\n     AssertLockHeld(g_cs_orphans);\n \n@@ -59,8 +52,9 @@ bool OrphanageAddTx(const CTransactionRef& tx, NodeId peer)\n     return true;\n }\n \n-int EraseOrphanTx(const uint256& txid)\n+int TxOrphanage::EraseTx(const uint256& txid)\n {\n+    AssertLockHeld(g_cs_orphans);\n     std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(txid);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n@@ -90,7 +84,7 @@ int EraseOrphanTx(const uint256& txid)\n     return 1;\n }\n \n-void EraseOrphansFor(NodeId peer)\n+void TxOrphanage::EraseForPeer(NodeId peer)\n {\n     AssertLockHeld(g_cs_orphans);\n \n@@ -101,13 +95,13 @@ void EraseOrphansFor(NodeId peer)\n         std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n         if (maybeErase->second.fromPeer == peer)\n         {\n-            nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n+            nErased += EraseTx(maybeErase->second.tx->GetHash());\n         }\n     }\n     if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n }\n \n-unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n+unsigned int TxOrphanage::LimitOrphans(unsigned int nMaxOrphans)\n {\n     AssertLockHeld(g_cs_orphans);\n \n@@ -123,7 +117,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n         {\n             std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n             if (maybeErase->second.nTimeExpire <= nNow) {\n-                nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n+                nErased += EraseTx(maybeErase->second.tx->GetHash());\n             } else {\n                 nMinExpTime = std::min(maybeErase->second.nTimeExpire, nMinExpTime);\n             }\n@@ -137,13 +131,13 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     {\n         // Evict a random orphan:\n         size_t randompos = rng.randrange(g_orphan_list.size());\n-        EraseOrphanTx(g_orphan_list[randompos]->first);\n+        EraseTx(g_orphan_list[randompos]->first);\n         ++nEvicted;\n     }\n     return nEvicted;\n }\n \n-void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set)\n+void TxOrphanage::AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set)\n {\n     AssertLockHeld(g_cs_orphans);\n     for (unsigned int i = 0; i < tx.vout.size(); i++) {\n@@ -156,7 +150,7 @@ void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work\n     }\n }\n \n-bool HaveOrphanTx(const GenTxid& gtxid)\n+bool TxOrphanage::HaveTx(const GenTxid& gtxid)\n {\n     LOCK(g_cs_orphans);\n     if (gtxid.IsWtxid()) {\n@@ -166,7 +160,7 @@ bool HaveOrphanTx(const GenTxid& gtxid)\n     }\n }\n \n-COrphanTx* GetOrphanTx(const uint256& txid)\n+TxOrphanage::COrphanTx* TxOrphanage::GetTx(const uint256& txid)\n {\n     AssertLockHeld(g_cs_orphans);\n \n@@ -175,7 +169,7 @@ COrphanTx* GetOrphanTx(const uint256& txid)\n     return &it->second;\n }\n \n-void EraseOrphansForBlock(const CBlock& block)\n+void TxOrphanage::EraseForBlock(const CBlock& block)\n {\n     LOCK(g_cs_orphans);\n \n@@ -200,7 +194,7 @@ void EraseOrphansForBlock(const CBlock& block)\n     if (vOrphanErase.size()) {\n         int nErased = 0;\n         for (const uint256& orphanHash : vOrphanErase) {\n-            nErased += EraseOrphanTx(orphanHash);\n+            nErased += EraseTx(orphanHash);\n         }\n         LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }"
      },
      {
        "sha": "1fb5d7dc42227f889eb8ac834942cdfadcb463ca",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 48,
        "deletions": 23,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c0514cd5be16179e53bfe9934a01948f9d27d2a/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "patch": "@@ -12,30 +12,50 @@\n /** Guards orphan transactions and extra txs for compact blocks */\n extern RecursiveMutex g_cs_orphans;\n \n-struct COrphanTx {\n-    // When modifying, adapt the copy of this definition in tests/DoS_tests.\n-    CTransactionRef tx;\n-    NodeId fromPeer;\n-    int64_t nTimeExpire;\n-    size_t list_pos;\n-};\n+/** Data structure to keep track of orphan transactions\n+ */\n+class TxOrphanage {\n+public:\n+    struct COrphanTx {\n+        CTransactionRef tx;\n+        NodeId fromPeer;\n+        int64_t nTimeExpire;\n+        size_t list_pos;\n+    };\n+\n+    /** Add a new orphan transaction */\n+    bool AddTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+\n+    /** Check if we already have an orphan transaction (by txid or wtxid) */\n+    bool HaveTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n+\n+    /** Get the details of an orphan transaction (returns nullptr if not found) */\n+    COrphanTx* GetTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+\n+    /** Erase an orphan by txid */\n+    int EraseTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n-int EraseOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-void EraseOrphansForBlock(const CBlock& block) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n-unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-void AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-bool HaveOrphanTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n-COrphanTx* GetOrphanTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-bool OrphanageAddTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+    /** Erase all orphans announced by a peer (eg, after that peer disconnects) */\n+    void EraseForPeer(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n-/** Map from txid to orphan transaction record. Limited by\n- *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */\n-extern std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+    /** Erase all orphans included in / invalidated by a new block */\n+    void EraseForBlock(const CBlock& block) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n \n-/** Index from wtxid into the mapOrphanTransactions to lookup orphan\n- *  transactions using their witness ids. */\n-extern std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n+    /** Limit the orphanage to the given maximum */\n+    unsigned int LimitOrphans(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+\n+    /** A set of orphans to be tested for potential acceptance into the mempool */\n+    using WorkSet = std::set<uint256>;\n+\n+    /** Add any orphans that list a particular tx as a parent into a peer's work set */\n+    void AddChildrenToWorkSet(const CTransaction& tx, WorkSet& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+\n+protected:\n+    /** Map from txid to orphan transaction record. Limited by\n+     *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */\n+    std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+\n+    using OrphanMap = decltype(mapOrphanTransactions);\n \n     struct IteratorComparator\n     {\n@@ -48,9 +68,14 @@ extern std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wt\n \n     /** Index from the parents' COutPoint into the mapOrphanTransactions. Used\n      *  to remove orphan transactions from the mapOrphanTransactions */\n-    extern std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n+    std::map<COutPoint, std::set<OrphanMap::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n \n     /** Orphan transactions in vector for quick random eviction */\n-    extern std::vector<std::map<uint256, COrphanTx>::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n+    std::vector<OrphanMap::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n+\n+    /** Index from wtxid into the mapOrphanTransactions to lookup orphan\n+     *  transactions using their witness ids. */\n+    std::map<uint256, OrphanMap::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n+};\n \n #endif // BITCOIN_TXORPHANAGE_H"
      },
      {
        "sha": "8783c244c3ff3838ff6d6d35712796841127e2e7",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c0514cd5be16179e53bfe9934a01948f9d27d2a/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c0514cd5be16179e53bfe9934a01948f9d27d2a/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "patch": "@@ -154,7 +154,7 @@ def run_test(self):\n             orphan_tx_pool[i].vin.append(CTxIn(outpoint=COutPoint(i, 333)))\n             orphan_tx_pool[i].vout.append(CTxOut(nValue=11 * COIN, scriptPubKey=SCRIPT_PUB_KEY_OP_TRUE))\n \n-        with node.assert_debug_log(['mapOrphan overflow, removed 1 tx']):\n+        with node.assert_debug_log(['orphanage overflow, removed 1 tx']):\n             node.p2ps[0].send_txs_and_test(orphan_tx_pool, node, success=False)\n \n         rejected_parent = CTransaction()"
      }
    ]
  },
  {
    "sha": "4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODk2Y2FkY2NlOTJjODdiNGJkYWYwMmI3ZTU4MjVmMzI2OGNkNjlk",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T12:53:06Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:17:16Z"
      },
      "message": "scripted-diff: Update txorphanage naming convention\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/mapOrphanTransactionsByPrev/m_outpoint_to_orphan_it/g' src/txorphanage.h src/txorphanage.cpp\nsed -i 's/mapOrphanTransactions/m_orphans/g' src/txorphanage.h src/txorphanage.cpp src/net_processing.cpp src/test/denialofservice_tests.cpp\nsed -i 's/g_orphan_list/m_orphan_list/g' src/txorphanage.h src/txorphanage.cpp\nsed -i 's/g_orphans_by_wtxid/m_wtxid_to_orphan_it/g' src/txorphanage.h src/txorphanage.cpp\nsed -i 's/nMaxOrphans/max_orphans/g' src/txorphanage.h src/txorphanage.cpp\nsed -i 's/COrphanTx/OrphanTx/g' src/txorphanage.h src/txorphanage.cpp src/net_processing.cpp src/test/denialofservice_tests.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "94b74bd30054520851da0316abed8b9857d25d3b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94b74bd30054520851da0316abed8b9857d25d3b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c0514cd5be16179e53bfe9934a01948f9d27d2a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c0514cd5be16179e53bfe9934a01948f9d27d2a"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 55,
      "deletions": 55
    },
    "files": [
      {
        "sha": "8a39edceb5fbdd667e6dc8f5af4bedd8f7b69160",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
        "patch": "@@ -2022,7 +2022,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         const uint256 orphanHash = *orphan_work_set.begin();\n         orphan_work_set.erase(orphan_work_set.begin());\n \n-        const TxOrphanage::COrphanTx* orphantx = m_orphanage.GetTx(orphanHash);\n+        const TxOrphanage::OrphanTx* orphantx = m_orphanage.GetTx(orphanHash);\n         if (orphantx == nullptr) continue;\n \n         const CTransactionRef porphanTx = orphantx->tx;"
      },
      {
        "sha": "fa51e5cab1a451b8c60bd5944008334fcfe6075c",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
        "patch": "@@ -289,15 +289,15 @@ class TxOrphanageTest : public TxOrphanage\n public:\n     inline size_t CountOrphans() const EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n     {\n-        return mapOrphanTransactions.size();\n+        return m_orphans.size();\n     }\n \n     CTransactionRef RandomOrphan() EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n     {\n-        std::map<uint256, COrphanTx>::iterator it;\n-        it = mapOrphanTransactions.lower_bound(InsecureRand256());\n-        if (it == mapOrphanTransactions.end())\n-            it = mapOrphanTransactions.begin();\n+        std::map<uint256, OrphanTx>::iterator it;\n+        it = m_orphans.lower_bound(InsecureRand256());\n+        if (it == m_orphans.end())\n+            it = m_orphans.begin();\n         return it->second.tx;\n     }\n };"
      },
      {
        "sha": "a634bde953bdb21d1b13e0113dfb2dc3d68812bb",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 38,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
        "patch": "@@ -21,7 +21,7 @@ bool TxOrphanage::AddTx(const CTransactionRef& tx, NodeId peer)\n     AssertLockHeld(g_cs_orphans);\n \n     const uint256& hash = tx->GetHash();\n-    if (mapOrphanTransactions.count(hash))\n+    if (m_orphans.count(hash))\n         return false;\n \n     // Ignore big transactions, to avoid a\n@@ -38,49 +38,49 @@ bool TxOrphanage::AddTx(const CTransactionRef& tx, NodeId peer)\n         return false;\n     }\n \n-    auto ret = mapOrphanTransactions.emplace(hash, COrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME, g_orphan_list.size()});\n+    auto ret = m_orphans.emplace(hash, OrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME, m_orphan_list.size()});\n     assert(ret.second);\n-    g_orphan_list.push_back(ret.first);\n+    m_orphan_list.push_back(ret.first);\n     // Allow for lookups in the orphan pool by wtxid, as well as txid\n-    g_orphans_by_wtxid.emplace(tx->GetWitnessHash(), ret.first);\n+    m_wtxid_to_orphan_it.emplace(tx->GetWitnessHash(), ret.first);\n     for (const CTxIn& txin : tx->vin) {\n-        mapOrphanTransactionsByPrev[txin.prevout].insert(ret.first);\n+        m_outpoint_to_orphan_it[txin.prevout].insert(ret.first);\n     }\n \n     LogPrint(BCLog::MEMPOOL, \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n-             mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n+             m_orphans.size(), m_outpoint_to_orphan_it.size());\n     return true;\n }\n \n int TxOrphanage::EraseTx(const uint256& txid)\n {\n     AssertLockHeld(g_cs_orphans);\n-    std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(txid);\n-    if (it == mapOrphanTransactions.end())\n+    std::map<uint256, OrphanTx>::iterator it = m_orphans.find(txid);\n+    if (it == m_orphans.end())\n         return 0;\n     for (const CTxIn& txin : it->second.tx->vin)\n     {\n-        auto itPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n-        if (itPrev == mapOrphanTransactionsByPrev.end())\n+        auto itPrev = m_outpoint_to_orphan_it.find(txin.prevout);\n+        if (itPrev == m_outpoint_to_orphan_it.end())\n             continue;\n         itPrev->second.erase(it);\n         if (itPrev->second.empty())\n-            mapOrphanTransactionsByPrev.erase(itPrev);\n+            m_outpoint_to_orphan_it.erase(itPrev);\n     }\n \n     size_t old_pos = it->second.list_pos;\n-    assert(g_orphan_list[old_pos] == it);\n-    if (old_pos + 1 != g_orphan_list.size()) {\n-        // Unless we're deleting the last entry in g_orphan_list, move the last\n+    assert(m_orphan_list[old_pos] == it);\n+    if (old_pos + 1 != m_orphan_list.size()) {\n+        // Unless we're deleting the last entry in m_orphan_list, move the last\n         // entry to the position we're deleting.\n-        auto it_last = g_orphan_list.back();\n-        g_orphan_list[old_pos] = it_last;\n+        auto it_last = m_orphan_list.back();\n+        m_orphan_list[old_pos] = it_last;\n         it_last->second.list_pos = old_pos;\n     }\n-    g_orphan_list.pop_back();\n-    g_orphans_by_wtxid.erase(it->second.tx->GetWitnessHash());\n+    m_orphan_list.pop_back();\n+    m_wtxid_to_orphan_it.erase(it->second.tx->GetWitnessHash());\n \n-    mapOrphanTransactions.erase(it);\n+    m_orphans.erase(it);\n     return 1;\n }\n \n@@ -89,10 +89,10 @@ void TxOrphanage::EraseForPeer(NodeId peer)\n     AssertLockHeld(g_cs_orphans);\n \n     int nErased = 0;\n-    std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n-    while (iter != mapOrphanTransactions.end())\n+    std::map<uint256, OrphanTx>::iterator iter = m_orphans.begin();\n+    while (iter != m_orphans.end())\n     {\n-        std::map<uint256, COrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n+        std::map<uint256, OrphanTx>::iterator maybeErase = iter++; // increment to avoid iterator becoming invalid\n         if (maybeErase->second.fromPeer == peer)\n         {\n             nErased += EraseTx(maybeErase->second.tx->GetHash());\n@@ -101,7 +101,7 @@ void TxOrphanage::EraseForPeer(NodeId peer)\n     if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n }\n \n-unsigned int TxOrphanage::LimitOrphans(unsigned int nMaxOrphans)\n+unsigned int TxOrphanage::LimitOrphans(unsigned int max_orphans)\n {\n     AssertLockHeld(g_cs_orphans);\n \n@@ -112,10 +112,10 @@ unsigned int TxOrphanage::LimitOrphans(unsigned int nMaxOrphans)\n         // Sweep out expired orphan pool entries:\n         int nErased = 0;\n         int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n-        std::map<uint256, COrphanTx>::iterator iter = mapOrphanTransactions.begin();\n-        while (iter != mapOrphanTransactions.end())\n+        std::map<uint256, OrphanTx>::iterator iter = m_orphans.begin();\n+        while (iter != m_orphans.end())\n         {\n-            std::map<uint256, COrphanTx>::iterator maybeErase = iter++;\n+            std::map<uint256, OrphanTx>::iterator maybeErase = iter++;\n             if (maybeErase->second.nTimeExpire <= nNow) {\n                 nErased += EraseTx(maybeErase->second.tx->GetHash());\n             } else {\n@@ -127,11 +127,11 @@ unsigned int TxOrphanage::LimitOrphans(unsigned int nMaxOrphans)\n         if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n     }\n     FastRandomContext rng;\n-    while (mapOrphanTransactions.size() > nMaxOrphans)\n+    while (m_orphans.size() > max_orphans)\n     {\n         // Evict a random orphan:\n-        size_t randompos = rng.randrange(g_orphan_list.size());\n-        EraseTx(g_orphan_list[randompos]->first);\n+        size_t randompos = rng.randrange(m_orphan_list.size());\n+        EraseTx(m_orphan_list[randompos]->first);\n         ++nEvicted;\n     }\n     return nEvicted;\n@@ -141,8 +141,8 @@ void TxOrphanage::AddChildrenToWorkSet(const CTransaction& tx, std::set<uint256>\n {\n     AssertLockHeld(g_cs_orphans);\n     for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-        const auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(tx.GetHash(), i));\n-        if (it_by_prev != mapOrphanTransactionsByPrev.end()) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(tx.GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n             for (const auto& elem : it_by_prev->second) {\n                 orphan_work_set.insert(elem->first);\n             }\n@@ -154,18 +154,18 @@ bool TxOrphanage::HaveTx(const GenTxid& gtxid)\n {\n     LOCK(g_cs_orphans);\n     if (gtxid.IsWtxid()) {\n-        return g_orphans_by_wtxid.count(gtxid.GetHash()) > 0;\n+        return m_wtxid_to_orphan_it.count(gtxid.GetHash()) > 0;\n     } else {\n-        return mapOrphanTransactions.count(gtxid.GetHash()) > 0;\n+        return m_orphans.count(gtxid.GetHash()) > 0;\n     }\n }\n \n-TxOrphanage::COrphanTx* TxOrphanage::GetTx(const uint256& txid)\n+TxOrphanage::OrphanTx* TxOrphanage::GetTx(const uint256& txid)\n {\n     AssertLockHeld(g_cs_orphans);\n \n-    const auto it = mapOrphanTransactions.find(txid);\n-    if (it == mapOrphanTransactions.end()) return nullptr;\n+    const auto it = m_orphans.find(txid);\n+    if (it == m_orphans.end()) return nullptr;\n     return &it->second;\n }\n \n@@ -180,8 +180,8 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n \n         // Which orphan pool entries must we evict?\n         for (const auto& txin : tx.vin) {\n-            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n-            if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n+            auto itByPrev = m_outpoint_to_orphan_it.find(txin.prevout);\n+            if (itByPrev == m_outpoint_to_orphan_it.end()) continue;\n             for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n                 const CTransaction& orphanTx = *(*mi)->second.tx;\n                 const uint256& orphanHash = orphanTx.GetHash();"
      },
      {
        "sha": "f33415ad958056ea06067bb7c7607de12840ad1a",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4896cadcce92c87b4bdaf02b7e5825f3268cd69d/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
        "patch": "@@ -16,7 +16,7 @@ extern RecursiveMutex g_cs_orphans;\n  */\n class TxOrphanage {\n public:\n-    struct COrphanTx {\n+    struct OrphanTx {\n         CTransactionRef tx;\n         NodeId fromPeer;\n         int64_t nTimeExpire;\n@@ -30,7 +30,7 @@ class TxOrphanage {\n     bool HaveTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n \n     /** Get the details of an orphan transaction (returns nullptr if not found) */\n-    COrphanTx* GetTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+    OrphanTx* GetTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n     /** Erase an orphan by txid */\n     int EraseTx(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n@@ -42,7 +42,7 @@ class TxOrphanage {\n     void EraseForBlock(const CBlock& block) EXCLUSIVE_LOCKS_REQUIRED(!g_cs_orphans);\n \n     /** Limit the orphanage to the given maximum */\n-    unsigned int LimitOrphans(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+    unsigned int LimitOrphans(unsigned int max_orphans) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n     /** A set of orphans to be tested for potential acceptance into the mempool */\n     using WorkSet = std::set<uint256>;\n@@ -53,9 +53,9 @@ class TxOrphanage {\n protected:\n     /** Map from txid to orphan transaction record. Limited by\n      *  -maxorphantx/DEFAULT_MAX_ORPHAN_TRANSACTIONS */\n-    std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n+    std::map<uint256, OrphanTx> m_orphans GUARDED_BY(g_cs_orphans);\n \n-    using OrphanMap = decltype(mapOrphanTransactions);\n+    using OrphanMap = decltype(m_orphans);\n \n     struct IteratorComparator\n     {\n@@ -66,16 +66,16 @@ class TxOrphanage {\n         }\n     };\n \n-    /** Index from the parents' COutPoint into the mapOrphanTransactions. Used\n-     *  to remove orphan transactions from the mapOrphanTransactions */\n-    std::map<COutPoint, std::set<OrphanMap::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n+    /** Index from the parents' COutPoint into the m_orphans. Used\n+     *  to remove orphan transactions from the m_orphans */\n+    std::map<COutPoint, std::set<OrphanMap::iterator, IteratorComparator>> m_outpoint_to_orphan_it GUARDED_BY(g_cs_orphans);\n \n     /** Orphan transactions in vector for quick random eviction */\n-    std::vector<OrphanMap::iterator> g_orphan_list GUARDED_BY(g_cs_orphans);\n+    std::vector<OrphanMap::iterator> m_orphan_list GUARDED_BY(g_cs_orphans);\n \n-    /** Index from wtxid into the mapOrphanTransactions to lookup orphan\n+    /** Index from wtxid into the m_orphans to lookup orphan\n      *  transactions using their witness ids. */\n-    std::map<uint256, OrphanMap::iterator> g_orphans_by_wtxid GUARDED_BY(g_cs_orphans);\n+    std::map<uint256, OrphanMap::iterator> m_wtxid_to_orphan_it GUARDED_BY(g_cs_orphans);\n };\n \n #endif // BITCOIN_TXORPHANAGE_H"
      }
    ]
  },
  {
    "sha": "7990854dfd75e56b52ee1b43d96e7d57421d19bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OTkwODU0ZGZkNzVlNTZiNTJlZTFiNDNkOTZlN2Q1NzQyMWQxOWJm",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-31T13:50:53Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:17:16Z"
      },
      "message": "net_processing: move AddToCompactExtraTransactions and AddOrphanTx into PeerManagerImpl\n\nAllows making m_orphanage, vExtraTxnForCompact and vExtraTxnForCompactIt\nmember vars instead of globals.",
      "tree": {
        "sha": "bd1dc1770222e468e9097800259b8c242539d202",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd1dc1770222e468e9097800259b8c242539d202"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7990854dfd75e56b52ee1b43d96e7d57421d19bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7990854dfd75e56b52ee1b43d96e7d57421d19bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7990854dfd75e56b52ee1b43d96e7d57421d19bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7990854dfd75e56b52ee1b43d96e7d57421d19bf/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4896cadcce92c87b4bdaf02b7e5825f3268cd69d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4896cadcce92c87b4bdaf02b7e5825f3268cd69d"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 14,
      "deletions": 10
    },
    "files": [
      {
        "sha": "1d9d2a014cb63e7bdb4ce97c2703d3a66c9cef33",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 10,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7990854dfd75e56b52ee1b43d96e7d57421d19bf/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7990854dfd75e56b52ee1b43d96e7d57421d19bf/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7990854dfd75e56b52ee1b43d96e7d57421d19bf",
        "patch": "@@ -444,22 +444,26 @@ class PeerManagerImpl final : public PeerManager\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n-};\n-} // namespace\n-\n-namespace {\n     /** Storage for orphan information */\n     TxOrphanage m_orphanage;\n \n-    /** Number of preferable block download peers. */\n-    int nPreferredDownload GUARDED_BY(cs_main) = 0;\n+    void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+\n+    bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n \n     /** Orphan/conflicted/etc transactions that are kept for compact block reconstruction.\n      *  The last -blockreconstructionextratxn/DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN of\n      *  these are kept in a ring buffer */\n-    static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n+    std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n     /** Offset into vExtraTxnForCompact to insert the next tx */\n-    static size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n+    size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n+};\n+} // namespace\n+\n+namespace {\n+\n+    /** Number of preferable block download peers. */\n+    int nPreferredDownload GUARDED_BY(cs_main) = 0;\n } // namespace\n \n namespace {\n@@ -1062,7 +1066,7 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n // Orphan handling\n //\n \n-static void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+void PeerManagerImpl::AddToCompactExtraTransactions(const CTransactionRef& tx)\n {\n     size_t max_extra_txn = gArgs.GetArg(\"-blockreconstructionextratxn\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN);\n     if (max_extra_txn <= 0)\n@@ -1073,7 +1077,7 @@ static void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_L\n     vExtraTxnForCompactIt = (vExtraTxnForCompactIt + 1) % max_extra_txn;\n }\n \n-bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+bool PeerManagerImpl::AddOrphanTx(const CTransactionRef& tx, NodeId peer)\n {\n     if (!m_orphanage.AddTx(tx, peer)) {\n         return false;"
      }
    ]
  },
  {
    "sha": "79eb731855978001c323c939c8cebf84c2271c20",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OWViNzMxODU1OTc4MDAxYzMyM2M5MzljOGNlYmY4NGMyMjcxYzIw",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T11:59:48Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:27:08Z"
      },
      "message": "net_processing: move CNodeState definition earlier",
      "tree": {
        "sha": "862e90b177b345fb5e86b8343e9d4c868e171bc6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/862e90b177b345fb5e86b8343e9d4c868e171bc6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/79eb731855978001c323c939c8cebf84c2271c20",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79eb731855978001c323c939c8cebf84c2271c20",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/79eb731855978001c323c939c8cebf84c2271c20",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79eb731855978001c323c939c8cebf84c2271c20/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7990854dfd75e56b52ee1b43d96e7d57421d19bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7990854dfd75e56b52ee1b43d96e7d57421d19bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7990854dfd75e56b52ee1b43d96e7d57421d19bf"
      }
    ],
    "stats": {
      "total": 254,
      "additions": 128,
      "deletions": 126
    },
    "files": [
      {
        "sha": "f2591407edffcf857aad05ad67a3f41738f933d7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 128,
        "deletions": 126,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/79eb731855978001c323c939c8cebf84c2271c20/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/79eb731855978001c323c939c8cebf84c2271c20/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=79eb731855978001c323c939c8cebf84c2271c20",
        "patch": "@@ -155,6 +155,134 @@ struct QueuedBlock {\n     std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n };\n \n+/**\n+ * Maintain validation-specific state about nodes, protected by cs_main, instead\n+ * by CNode's own locks. This simplifies asynchronous operation, where\n+ * processing of incoming data is done after the ProcessMessage call returns,\n+ * and we're no longer holding the node's locks.\n+ */\n+struct CNodeState {\n+    //! The peer's address\n+    const CService address;\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *pindexBestKnownBlock;\n+    //! The hash of the last unknown block this peer has announced.\n+    uint256 hashLastUnknownBlock;\n+    //! The last full block we both have.\n+    const CBlockIndex *pindexLastCommonBlock;\n+    //! The best header we have sent our peer.\n+    const CBlockIndex *pindexBestHeaderSent;\n+    //! Length of current-streak of unconnecting headers announcements\n+    int nUnconnectingHeaders;\n+    //! Whether we've started headers synchronization with this peer.\n+    bool fSyncStarted;\n+    //! When to potentially disconnect peer for stalling headers download\n+    int64_t nHeadersSyncTimeout;\n+    //! Since when we're stalling block download progress (in microseconds), or 0.\n+    int64_t nStallingSince;\n+    std::list<QueuedBlock> vBlocksInFlight;\n+    //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n+    int64_t nDownloadingSince;\n+    int nBlocksInFlight;\n+    int nBlocksInFlightValidHeaders;\n+    //! Whether we consider this a preferred download peer.\n+    bool fPreferredDownload;\n+    //! Whether this peer wants invs or headers (when possible) for block announcements.\n+    bool fPreferHeaders;\n+    //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n+    bool fPreferHeaderAndIDs;\n+    /**\n+      * Whether this peer will send us cmpctblocks if we request them.\n+      * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,\n+      * but is used as a flag to \"lock in\" the version of compact blocks (fWantsCmpctWitness) we send.\n+      */\n+    bool fProvidesHeaderAndIDs;\n+    //! Whether this peer can give us witnesses\n+    bool fHaveWitness;\n+    //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n+    bool fWantsCmpctWitness;\n+    /**\n+     * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,\n+     * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n+     */\n+    bool fSupportsDesiredCmpctVersion;\n+\n+    /** State used to enforce CHAIN_SYNC_TIMEOUT and EXTRA_PEER_CHECK_INTERVAL logic.\n+      *\n+      * Both are only in effect for outbound, non-manual, non-protected connections.\n+      * Any peer protected (m_protect = true) is not chosen for eviction. A peer is\n+      * marked as protected if all of these are true:\n+      *   - its connection type is IsBlockOnlyConn() == false\n+      *   - it gave us a valid connecting header\n+      *   - we haven't reached MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT yet\n+      *   - it has a better chain than we have\n+      *\n+      * CHAIN_SYNC_TIMEOUT: if a peer's best known block has less work than our tip,\n+      * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:\n+      *   - If at timeout their best known block now has more work than our tip\n+      *     when the timeout was set, then either reset the timeout or clear it\n+      *     (after comparing against our current tip's work)\n+      *   - If at timeout their best known block still has less work than our\n+      *     tip did when the timeout was set, then send a getheaders message,\n+      *     and set a shorter timeout, HEADERS_RESPONSE_TIME seconds in future.\n+      *     If their best known block is still behind when that new timeout is\n+      *     reached, disconnect.\n+      *\n+      * EXTRA_PEER_CHECK_INTERVAL: after each interval, if we have too many outbound peers,\n+      * drop the outbound one that least recently announced us a new block.\n+      */\n+    struct ChainSyncTimeoutState {\n+        //! A timeout used for checking whether our peer has sufficiently synced\n+        int64_t m_timeout;\n+        //! A header with the work we require on our peer's chain\n+        const CBlockIndex * m_work_header;\n+        //! After timeout is reached, set to true after sending getheaders\n+        bool m_sent_getheaders;\n+        //! Whether this peer is protected from disconnection due to a bad/slow chain\n+        bool m_protect;\n+    };\n+\n+    ChainSyncTimeoutState m_chain_sync;\n+\n+    //! Time of last new block announcement\n+    int64_t m_last_block_announcement;\n+\n+    //! Whether this peer is an inbound connection\n+    bool m_is_inbound;\n+\n+    //! A rolling bloom filter of all announced tx CInvs to this peer.\n+    CRollingBloomFilter m_recently_announced_invs = CRollingBloomFilter{INVENTORY_MAX_RECENT_RELAY, 0.000001};\n+\n+    //! Whether this peer relays txs via wtxid\n+    bool m_wtxid_relay{false};\n+\n+    CNodeState(CAddress addrIn, bool is_inbound)\n+        : address(addrIn), m_is_inbound(is_inbound)\n+    {\n+        pindexBestKnownBlock = nullptr;\n+        hashLastUnknownBlock.SetNull();\n+        pindexLastCommonBlock = nullptr;\n+        pindexBestHeaderSent = nullptr;\n+        nUnconnectingHeaders = 0;\n+        fSyncStarted = false;\n+        nHeadersSyncTimeout = 0;\n+        nStallingSince = 0;\n+        nDownloadingSince = 0;\n+        nBlocksInFlight = 0;\n+        nBlocksInFlightValidHeaders = 0;\n+        fPreferredDownload = false;\n+        fPreferHeaders = false;\n+        fPreferHeaderAndIDs = false;\n+        fProvidesHeaderAndIDs = false;\n+        fHaveWitness = false;\n+        fWantsCmpctWitness = false;\n+        fSupportsDesiredCmpctVersion = false;\n+        m_chain_sync = { 0, nullptr, false, false };\n+        m_last_block_announcement = 0;\n+        m_recently_announced_invs.reset();\n+    }\n+};\n+\n /**\n  * Data structure for an individual peer. This struct is not protected by\n  * cs_main since it does not contain validation-critical data.\n@@ -467,133 +595,7 @@ namespace {\n } // namespace\n \n namespace {\n-/**\n- * Maintain validation-specific state about nodes, protected by cs_main, instead\n- * by CNode's own locks. This simplifies asynchronous operation, where\n- * processing of incoming data is done after the ProcessMessage call returns,\n- * and we're no longer holding the node's locks.\n- */\n-struct CNodeState {\n-    //! The peer's address\n-    const CService address;\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *pindexBestKnownBlock;\n-    //! The hash of the last unknown block this peer has announced.\n-    uint256 hashLastUnknownBlock;\n-    //! The last full block we both have.\n-    const CBlockIndex *pindexLastCommonBlock;\n-    //! The best header we have sent our peer.\n-    const CBlockIndex *pindexBestHeaderSent;\n-    //! Length of current-streak of unconnecting headers announcements\n-    int nUnconnectingHeaders;\n-    //! Whether we've started headers synchronization with this peer.\n-    bool fSyncStarted;\n-    //! When to potentially disconnect peer for stalling headers download\n-    int64_t nHeadersSyncTimeout;\n-    //! Since when we're stalling block download progress (in microseconds), or 0.\n-    int64_t nStallingSince;\n-    std::list<QueuedBlock> vBlocksInFlight;\n-    //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n-    int64_t nDownloadingSince;\n-    int nBlocksInFlight;\n-    int nBlocksInFlightValidHeaders;\n-    //! Whether we consider this a preferred download peer.\n-    bool fPreferredDownload;\n-    //! Whether this peer wants invs or headers (when possible) for block announcements.\n-    bool fPreferHeaders;\n-    //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n-    bool fPreferHeaderAndIDs;\n-    /**\n-      * Whether this peer will send us cmpctblocks if we request them.\n-      * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,\n-      * but is used as a flag to \"lock in\" the version of compact blocks (fWantsCmpctWitness) we send.\n-      */\n-    bool fProvidesHeaderAndIDs;\n-    //! Whether this peer can give us witnesses\n-    bool fHaveWitness;\n-    //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n-    bool fWantsCmpctWitness;\n-    /**\n-     * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,\n-     * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n-     */\n-    bool fSupportsDesiredCmpctVersion;\n \n-    /** State used to enforce CHAIN_SYNC_TIMEOUT and EXTRA_PEER_CHECK_INTERVAL logic.\n-      *\n-      * Both are only in effect for outbound, non-manual, non-protected connections.\n-      * Any peer protected (m_protect = true) is not chosen for eviction. A peer is\n-      * marked as protected if all of these are true:\n-      *   - its connection type is IsBlockOnlyConn() == false\n-      *   - it gave us a valid connecting header\n-      *   - we haven't reached MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT yet\n-      *   - it has a better chain than we have\n-      *\n-      * CHAIN_SYNC_TIMEOUT: if a peer's best known block has less work than our tip,\n-      * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:\n-      *   - If at timeout their best known block now has more work than our tip\n-      *     when the timeout was set, then either reset the timeout or clear it\n-      *     (after comparing against our current tip's work)\n-      *   - If at timeout their best known block still has less work than our\n-      *     tip did when the timeout was set, then send a getheaders message,\n-      *     and set a shorter timeout, HEADERS_RESPONSE_TIME seconds in future.\n-      *     If their best known block is still behind when that new timeout is\n-      *     reached, disconnect.\n-      *\n-      * EXTRA_PEER_CHECK_INTERVAL: after each interval, if we have too many outbound peers,\n-      * drop the outbound one that least recently announced us a new block.\n-      */\n-    struct ChainSyncTimeoutState {\n-        //! A timeout used for checking whether our peer has sufficiently synced\n-        int64_t m_timeout;\n-        //! A header with the work we require on our peer's chain\n-        const CBlockIndex * m_work_header;\n-        //! After timeout is reached, set to true after sending getheaders\n-        bool m_sent_getheaders;\n-        //! Whether this peer is protected from disconnection due to a bad/slow chain\n-        bool m_protect;\n-    };\n-\n-    ChainSyncTimeoutState m_chain_sync;\n-\n-    //! Time of last new block announcement\n-    int64_t m_last_block_announcement;\n-\n-    //! Whether this peer is an inbound connection\n-    bool m_is_inbound;\n-\n-    //! A rolling bloom filter of all announced tx CInvs to this peer.\n-    CRollingBloomFilter m_recently_announced_invs = CRollingBloomFilter{INVENTORY_MAX_RECENT_RELAY, 0.000001};\n-\n-    //! Whether this peer relays txs via wtxid\n-    bool m_wtxid_relay{false};\n-\n-    CNodeState(CAddress addrIn, bool is_inbound)\n-        : address(addrIn), m_is_inbound(is_inbound)\n-    {\n-        pindexBestKnownBlock = nullptr;\n-        hashLastUnknownBlock.SetNull();\n-        pindexLastCommonBlock = nullptr;\n-        pindexBestHeaderSent = nullptr;\n-        nUnconnectingHeaders = 0;\n-        fSyncStarted = false;\n-        nHeadersSyncTimeout = 0;\n-        nStallingSince = 0;\n-        nDownloadingSince = 0;\n-        nBlocksInFlight = 0;\n-        nBlocksInFlightValidHeaders = 0;\n-        fPreferredDownload = false;\n-        fPreferHeaders = false;\n-        fPreferHeaderAndIDs = false;\n-        fProvidesHeaderAndIDs = false;\n-        fHaveWitness = false;\n-        fWantsCmpctWitness = false;\n-        fSupportsDesiredCmpctVersion = false;\n-        m_chain_sync = { 0, nullptr, false, false };\n-        m_last_block_announcement = 0;\n-        m_recently_announced_invs.reset();\n-    }\n-};\n \n /** Map maintaining per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);"
      }
    ]
  },
  {
    "sha": "2284ccb23bd24a03f2ba0381de3406254492fcf1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMjg0Y2NiMjNiZDI0YTAzZjJiYTAzODFkZTM0MDYyNTQ0OTJmY2Yx",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T11:34:05Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:27:08Z"
      },
      "message": "net_processing: Move UpdatePreferredDownload to PeerManagerImpl\n\nAllows nPreferredDownload to become a member var instead of global.",
      "tree": {
        "sha": "74c489230c265e9258dc08731c32adf142febe88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/74c489230c265e9258dc08731c32adf142febe88"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2284ccb23bd24a03f2ba0381de3406254492fcf1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2284ccb23bd24a03f2ba0381de3406254492fcf1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2284ccb23bd24a03f2ba0381de3406254492fcf1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2284ccb23bd24a03f2ba0381de3406254492fcf1/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "79eb731855978001c323c939c8cebf84c2271c20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79eb731855978001c323c939c8cebf84c2271c20",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/79eb731855978001c323c939c8cebf84c2271c20"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 3,
      "deletions": 4
    },
    "files": [
      {
        "sha": "97b09d82d6c4ae64adfb4878fe030c0323d3a700",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2284ccb23bd24a03f2ba0381de3406254492fcf1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2284ccb23bd24a03f2ba0381de3406254492fcf1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2284ccb23bd24a03f2ba0381de3406254492fcf1",
        "patch": "@@ -585,13 +585,12 @@ class PeerManagerImpl final : public PeerManager\n     std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n     /** Offset into vExtraTxnForCompact to insert the next tx */\n     size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n-};\n-} // namespace\n \n-namespace {\n+    void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Number of preferable block download peers. */\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n+};\n } // namespace\n \n namespace {\n@@ -607,7 +606,7 @@ static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return &it->second;\n }\n \n-static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManagerImpl::UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n "
      }
    ]
  },
  {
    "sha": "2f2062e41e1de7e9314dd74a2b450922794f6765",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjIwNjJlNDFlMWRlN2U5MzE0ZGQ3NGEyYjQ1MDkyMjc5NGY2NzY1",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T12:00:33Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:27:08Z"
      },
      "message": "net_processing: move State() into PeerManagerImpl\n\nThis allows making mapNodeState not a global. Requires also moving\nProcessBlockAvailability, UpdateBlockAvailability, RelayTransaction,\nProcessGetBlockData, GetFetchFlags, and UpdateLastBlockAnnounceTime\ninto PeerManagerImpl, as well as removing the const annotation from\nReattemptInitialBroadcast (as they invoke State()).\n\nAlso requires moving RelayTransaction and UpdateLastBlockAnnounceTime\ninto PeerManager.",
      "tree": {
        "sha": "891d90c6828660a0f1a6bac1ee812cb1a314e7da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/891d90c6828660a0f1a6bac1ee812cb1a314e7da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f2062e41e1de7e9314dd74a2b450922794f6765",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f2062e41e1de7e9314dd74a2b450922794f6765",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f2062e41e1de7e9314dd74a2b450922794f6765",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f2062e41e1de7e9314dd74a2b450922794f6765/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2284ccb23bd24a03f2ba0381de3406254492fcf1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2284ccb23bd24a03f2ba0381de3406254492fcf1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2284ccb23bd24a03f2ba0381de3406254492fcf1"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 33,
      "deletions": 22
    },
    "files": [
      {
        "sha": "962d30ac8e83cdb5a4637be218bc6f78e10df58c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 15,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f2062e41e1de7e9314dd74a2b450922794f6765/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f2062e41e1de7e9314dd74a2b450922794f6765/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2f2062e41e1de7e9314dd74a2b450922794f6765",
        "patch": "@@ -375,7 +375,7 @@ class PeerManagerImpl final : public PeerManager\n     void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n-    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n+    void ReattemptInitialBroadcast(CScheduler& scheduler);\n \n     /** Get a shared pointer to the Peer object.\n      *  May return an empty shared_ptr if the Peer object can't be found. */\n@@ -590,16 +590,23 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Number of preferable block download peers. */\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n+\n+    CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman);\n+    uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds) override;\n+\n+    /** Map maintaining per-node state. */\n+    std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n };\n } // namespace\n \n namespace {\n-\n-\n-/** Map maintaining per-node state. */\n-static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n-\n-static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+CNodeState *PeerManagerImpl::State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n     if (it == mapNodeState.end())\n         return nullptr;\n@@ -675,7 +682,8 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n }\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n-static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -691,7 +699,8 @@ static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_\n }\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n-static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -918,7 +927,7 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n \n // This function is used for testing the stale tip eviction logic, see\n // denialofservice_tests.cpp\n-void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n+void PeerManagerImpl::UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n {\n     LOCK(cs_main);\n     CNodeState *state = State(node);\n@@ -945,7 +954,7 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n     }\n }\n \n-void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler) const\n+void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler)\n {\n     std::set<uint256> unbroadcast_txids = m_mempool.GetUnbroadcastTxs();\n \n@@ -1453,9 +1462,9 @@ bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED\n     return g_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n }\n \n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n {\n-    connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    connman.ForEachNode([this, &txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n         AssertLockHeld(::cs_main);\n \n         CNodeState* state = State(pnode->GetId());\n@@ -1523,7 +1532,7 @@ static void RelayAddress(const CNode& originator,\n     connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n-void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n+void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman)\n {\n     bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n@@ -1800,7 +1809,8 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n     }\n }\n \n-static uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+uint32_t PeerManagerImpl::GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     uint32_t nFetchFlags = 0;\n     if ((pfrom.GetLocalServices() & NODE_WITNESS) && State(pfrom.GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;"
      },
      {
        "sha": "40e5982a5d7640620b7093b425cd75315059db0a",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f2062e41e1de7e9314dd74a2b450922794f6765/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f2062e41e1de7e9314dd74a2b450922794f6765/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=2f2062e41e1de7e9314dd74a2b450922794f6765",
        "patch": "@@ -40,6 +40,9 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n                                              bool ignore_incoming_txs);\n     virtual ~PeerManager() { }\n \n+    /** Relay transaction to every node */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main) = 0;\n+\n     /** Get statistics from node state */\n     virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) = 0;\n \n@@ -65,9 +68,8 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Process a single message from a peer. Public for fuzz testing */\n     virtual void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n                                 const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) = 0;\n-};\n \n-/** Relay transaction to every node */\n-void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    virtual void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds) = 0;\n+};\n \n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "342152f3196b6f10e834fc882a5907534ef7d147",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f2062e41e1de7e9314dd74a2b450922794f6765/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f2062e41e1de7e9314dd74a2b450922794f6765/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=2f2062e41e1de7e9314dd74a2b450922794f6765",
        "patch": "@@ -33,6 +33,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     // and reset after chain clients and RPC sever are stopped. node.connman should never be null here.\n     assert(node.connman);\n     assert(node.mempool);\n+    assert(node.peerman);\n     std::promise<void> promise;\n     uint256 hashTx = tx->GetHash();\n     bool callback_set = false;\n@@ -100,7 +101,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n         node.mempool->AddUnbroadcastTx(hashTx);\n \n         LOCK(cs_main);\n-        RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman);\n+        node.peerman->RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman);\n     }\n \n     return TransactionError::OK;"
      },
      {
        "sha": "d55f721fdfe1baf02e66cec05fd694845f718c45",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f2062e41e1de7e9314dd74a2b450922794f6765/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f2062e41e1de7e9314dd74a2b450922794f6765/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=2f2062e41e1de7e9314dd74a2b450922794f6765",
        "patch": "@@ -53,8 +53,6 @@ static CService ip(uint32_t i)\n \n static NodeId id = 0;\n \n-void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds);\n-\n BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n \n // Test eviction of an outbound peer whose chain never advances\n@@ -191,7 +189,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n \n     // Update the last announced block time for the last\n     // peer, and check that the next newest node gets evicted.\n-    UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), GetTime());\n+    peerLogic->UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), GetTime());\n \n     peerLogic->CheckForStaleTipAndEvictPeers();\n     for (int i = 0; i < max_outbound_full_relay - 1; ++i) {"
      }
    ]
  },
  {
    "sha": "cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZmVjMmI5NTI3OTJmMWJhMmU5MDE4NDMzZTBlYjZjNTczMGE1MWE2",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T12:18:16Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:27:08Z"
      },
      "message": "net_processing: RelayTransaction no longer needs connman passed in",
      "tree": {
        "sha": "2f519549e2b36ccfabd4e6e35703e5f684232fd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f519549e2b36ccfabd4e6e35703e5f684232fd5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f2062e41e1de7e9314dd74a2b450922794f6765",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f2062e41e1de7e9314dd74a2b450922794f6765",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f2062e41e1de7e9314dd74a2b450922794f6765"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 12,
      "deletions": 13
    },
    "files": [
      {
        "sha": "0143746009fb01da67e74c9fe7e22033ad7413f1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
        "patch": "@@ -594,7 +594,7 @@ class PeerManagerImpl final : public PeerManager\n     CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void RelayTransaction(const uint256& txid, const uint256& wtxid) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman);\n     uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds) override;\n@@ -963,7 +963,7 @@ void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler)\n \n         if (tx != nullptr) {\n             LOCK(cs_main);\n-            RelayTransaction(txid, tx->GetWitnessHash(), m_connman);\n+            RelayTransaction(txid, tx->GetWitnessHash());\n         } else {\n             m_mempool.RemoveUnbroadcastTx(txid, true);\n         }\n@@ -1462,9 +1462,9 @@ bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED\n     return g_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n }\n \n-void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n {\n-    connman.ForEachNode([this, &txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    m_connman.ForEachNode([this, &txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n         AssertLockHeld(::cs_main);\n \n         CNodeState* state = State(pnode->GetId());\n@@ -2046,7 +2046,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-            RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n+            RelayTransaction(orphanHash, porphanTx->GetWitnessHash());\n             m_orphanage.AddChildrenToWorkSet(*porphanTx, orphan_work_set);\n             m_orphanage.EraseTx(orphanHash);\n             for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n@@ -3050,7 +3050,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     LogPrintf(\"Not relaying non-mempool transaction %s from forcerelay peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n                 } else {\n                     LogPrintf(\"Force relaying tx %s from peer=%d\\n\", tx.GetHash().ToString(), pfrom.GetId());\n-                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n+                    RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n                 }\n             }\n             return;\n@@ -3065,7 +3065,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // requests for it.\n             m_txrequest.ForgetTxHash(tx.GetHash());\n             m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n-            RelayTransaction(tx.GetHash(), tx.GetWitnessHash(), m_connman);\n+            RelayTransaction(tx.GetHash(), tx.GetWitnessHash());\n             m_orphanage.AddChildrenToWorkSet(tx, peer->m_orphan_work_set);\n \n             pfrom.nLastTXTime = GetTime();"
      },
      {
        "sha": "cd3017d0c86305aeb43b4be70282ccc0b7815063",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
        "patch": "@@ -41,7 +41,7 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     virtual ~PeerManager() { }\n \n     /** Relay transaction to every node */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main) = 0;\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main) = 0;\n \n     /** Get statistics from node state */\n     virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) = 0;"
      },
      {
        "sha": "ca5b6a50521179a589c1e676819eef891f6ebf13",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cfec2b952792f1ba2e9018433e0eb6c5730a51a6/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
        "patch": "@@ -29,11 +29,10 @@ static TransactionError HandleATMPError(const TxValidationState& state, std::str\n TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback)\n {\n     // BroadcastTransaction can be called by either sendrawtransaction RPC or wallet RPCs.\n-    // node.connman is assigned both before chain clients and before RPC server is accepting calls,\n-    // and reset after chain clients and RPC sever are stopped. node.connman should never be null here.\n-    assert(node.connman);\n-    assert(node.mempool);\n+    // node.peerman is assigned both before chain clients and before RPC server is accepting calls,\n+    // and reset after chain clients and RPC sever are stopped. node.peerman should never be null here.\n     assert(node.peerman);\n+    assert(node.mempool);\n     std::promise<void> promise;\n     uint256 hashTx = tx->GetHash();\n     bool callback_set = false;\n@@ -101,7 +100,7 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n         node.mempool->AddUnbroadcastTx(hashTx);\n \n         LOCK(cs_main);\n-        node.peerman->RelayTransaction(hashTx, tx->GetWitnessHash(), *node.connman);\n+        node.peerman->RelayTransaction(hashTx, tx->GetWitnessHash());\n     }\n \n     return TransactionError::OK;"
      }
    ]
  },
  {
    "sha": "03180f21212c41703857612c66dcf557ed1b4735",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMzE4MGYyMTIxMmM0MTcwMzg1NzYxMmM2NmRjZjU1N2VkMWI0NzM1",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T12:26:55Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:27:08Z"
      },
      "message": "net_processing: move cs_most_recent_block globals into PeerManagerImpl",
      "tree": {
        "sha": "fbc81568984444ce2fbacf941b924605f95bd9f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fbc81568984444ce2fbacf941b924605f95bd9f6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/03180f21212c41703857612c66dcf557ed1b4735",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03180f21212c41703857612c66dcf557ed1b4735",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/03180f21212c41703857612c66dcf557ed1b4735",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03180f21212c41703857612c66dcf557ed1b4735/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cfec2b952792f1ba2e9018433e0eb6c5730a51a6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cfec2b952792f1ba2e9018433e0eb6c5730a51a6"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "23b26e9ae142deb1a0b36611b5e3b58c421120ca",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/03180f21212c41703857612c66dcf557ed1b4735/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/03180f21212c41703857612c66dcf557ed1b4735/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=03180f21212c41703857612c66dcf557ed1b4735",
        "patch": "@@ -601,6 +601,13 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Map maintaining per-node state. */\n     std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n+\n+    // All of the following cache a recent block, and are protected by cs_most_recent_block\n+    RecursiveMutex cs_most_recent_block;\n+    std::shared_ptr<const CBlock> most_recent_block GUARDED_BY(cs_most_recent_block);\n+    std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block GUARDED_BY(cs_most_recent_block);\n+    uint256 most_recent_block_hash GUARDED_BY(cs_most_recent_block);\n+    bool fWitnessesPresentInMostRecentCompactBlock GUARDED_BY(cs_most_recent_block) = false;\n };\n } // namespace\n \n@@ -1298,13 +1305,6 @@ void PeerManagerImpl::BlockDisconnected(const std::shared_ptr<const CBlock> &blo\n     m_recent_confirmed_transactions->reset();\n }\n \n-// All of the following cache a recent block, and are protected by cs_most_recent_block\n-static RecursiveMutex cs_most_recent_block;\n-static std::shared_ptr<const CBlock> most_recent_block GUARDED_BY(cs_most_recent_block);\n-static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block GUARDED_BY(cs_most_recent_block);\n-static uint256 most_recent_block_hash GUARDED_BY(cs_most_recent_block);\n-static bool fWitnessesPresentInMostRecentCompactBlock GUARDED_BY(cs_most_recent_block);\n-\n /**\n  * Maintain state about the best-seen block and fast-announce a compact block\n  * to compatible peers."
      }
    ]
  },
  {
    "sha": "9ac47922a3262a290a3139ba65b95c60b110db8f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YWM0NzkyMmEzMjYyYTI5MGEzMTM5YmE2NWI5NWM2MGIxMTBkYjhm",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T11:22:18Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:27:08Z"
      },
      "message": "net_processing: annotate local static variables\n\nThese function-local variables are effectively globals; annotate them\nso it's easier to refactor them later.",
      "tree": {
        "sha": "afc0eeed07580d6064283630b6ca031e942252af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/afc0eeed07580d6064283630b6ca031e942252af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ac47922a3262a290a3139ba65b95c60b110db8f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ac47922a3262a290a3139ba65b95c60b110db8f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ac47922a3262a290a3139ba65b95c60b110db8f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ac47922a3262a290a3139ba65b95c60b110db8f/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "03180f21212c41703857612c66dcf557ed1b4735",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03180f21212c41703857612c66dcf557ed1b4735",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/03180f21212c41703857612c66dcf557ed1b4735"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 5,
      "deletions": 4
    },
    "files": [
      {
        "sha": "dcf4634f34e9fae2e275521eb9c7f5fa3cf693eb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ac47922a3262a290a3139ba65b95c60b110db8f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ac47922a3262a290a3139ba65b95c60b110db8f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9ac47922a3262a290a3139ba65b95c60b110db8f",
        "patch": "@@ -1316,7 +1316,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n \n     LOCK(cs_main);\n \n-    static int nHighestFastAnnounce = 0;\n+    static int nHighestFastAnnounce = 0; // GUARDED_BY(cs_main)\n     if (pindex->nHeight <= nHighestFastAnnounce)\n         return;\n     nHighestFastAnnounce = pindex->nHeight;\n@@ -4683,13 +4683,14 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             !pto->HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n         ) {\n             CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n-            static FeeFilterRounder g_filter_rounder{CFeeRate{DEFAULT_MIN_RELAY_TX_FEE}};\n+            AssertLockHeld(cs_main);\n+            static FeeFilterRounder g_filter_rounder{CFeeRate{DEFAULT_MIN_RELAY_TX_FEE}}; // GUARDED_BY(cs_main)\n             if (m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                 // Received tx-inv messages are discarded when the active\n                 // chainstate is in IBD, so tell the peer to not send them.\n                 currentFilter = MAX_MONEY;\n             } else {\n-                static const CAmount MAX_FILTER{g_filter_rounder.round(MAX_MONEY)};\n+                static const CAmount MAX_FILTER{g_filter_rounder.round(MAX_MONEY)}; // GUARDED_BY(cs_main)\n                 if (pto->m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n                     // Send the current filter if we sent MAX_FILTER previously\n                     // and made it out of IBD."
      },
      {
        "sha": "4e0fa192fb66d40f4111ad41d35200099bea86bb",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ac47922a3262a290a3139ba65b95c60b110db8f/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ac47922a3262a290a3139ba65b95c60b110db8f/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=9ac47922a3262a290a3139ba65b95c60b110db8f",
        "patch": "@@ -106,7 +106,7 @@ unsigned int TxOrphanage::LimitOrphans(unsigned int max_orphans)\n     AssertLockHeld(g_cs_orphans);\n \n     unsigned int nEvicted = 0;\n-    static int64_t nNextSweep;\n+    static int64_t nNextSweep; // GUARDED_BY(g_cs_orphans)\n     int64_t nNow = GetTime();\n     if (nNextSweep <= nNow) {\n         // Sweep out expired orphan pool entries:"
      }
    ]
  },
  {
    "sha": "d9cedeba8aacb1d4095ab0abd82bca7379361329",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOWNlZGViYThhYWNiMWQ0MDk1YWIwYWJkODJiY2E3Mzc5MzYxMzI5",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T12:45:58Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:29:29Z"
      },
      "message": "net_processing: move static local variables to PeerManagerImpl members",
      "tree": {
        "sha": "9cf2d681517e94e8449545189029be6fb70ee2ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9cf2d681517e94e8449545189029be6fb70ee2ae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d9cedeba8aacb1d4095ab0abd82bca7379361329",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9cedeba8aacb1d4095ab0abd82bca7379361329",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d9cedeba8aacb1d4095ab0abd82bca7379361329",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9cedeba8aacb1d4095ab0abd82bca7379361329/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ac47922a3262a290a3139ba65b95c60b110db8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ac47922a3262a290a3139ba65b95c60b110db8f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ac47922a3262a290a3139ba65b95c60b110db8f"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 15,
      "deletions": 9
    },
    "files": [
      {
        "sha": "f869d6bb75f48c22261a4a5d09d6bd86ab02f7ab",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9cedeba8aacb1d4095ab0abd82bca7379361329/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9cedeba8aacb1d4095ab0abd82bca7379361329/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d9cedeba8aacb1d4095ab0abd82bca7379361329",
        "patch": "@@ -591,6 +591,9 @@ class PeerManagerImpl final : public PeerManager\n     /** Number of preferable block download peers. */\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n \n+    /** Height of highest fast announce block, updated by NewPoWValidBlock */\n+    int m_height_of_highest_fast_announce GUARDED_BY(cs_main) = 0;\n+\n     CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -608,6 +611,10 @@ class PeerManagerImpl final : public PeerManager\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block GUARDED_BY(cs_most_recent_block);\n     uint256 most_recent_block_hash GUARDED_BY(cs_most_recent_block);\n     bool fWitnessesPresentInMostRecentCompactBlock GUARDED_BY(cs_most_recent_block) = false;\n+\n+    // Fee calculator helpers for SendMessages()\n+    FeeFilterRounder m_filter_rounder GUARDED_BY(cs_main) {CFeeRate{DEFAULT_MIN_RELAY_TX_FEE}};\n+    const CAmount MAX_FILTER GUARDED_BY(cs_main) {m_filter_rounder.round(MAX_MONEY)};\n };\n } // namespace\n \n@@ -1316,10 +1323,9 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n \n     LOCK(cs_main);\n \n-    static int nHighestFastAnnounce = 0; // GUARDED_BY(cs_main)\n-    if (pindex->nHeight <= nHighestFastAnnounce)\n+    if (pindex->nHeight <= m_height_of_highest_fast_announce)\n         return;\n-    nHighestFastAnnounce = pindex->nHeight;\n+    m_height_of_highest_fast_announce = pindex->nHeight;\n \n     bool fWitnessEnabled = IsWitnessEnabled(pindex->pprev, m_chainparams.GetConsensus());\n     uint256 hashBlock(pblock->GetHash());\n@@ -4684,21 +4690,19 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         ) {\n             CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             AssertLockHeld(cs_main);\n-            static FeeFilterRounder g_filter_rounder{CFeeRate{DEFAULT_MIN_RELAY_TX_FEE}}; // GUARDED_BY(cs_main)\n             if (m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                 // Received tx-inv messages are discarded when the active\n                 // chainstate is in IBD, so tell the peer to not send them.\n                 currentFilter = MAX_MONEY;\n             } else {\n-                static const CAmount MAX_FILTER{g_filter_rounder.round(MAX_MONEY)}; // GUARDED_BY(cs_main)\n                 if (pto->m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n                     // Send the current filter if we sent MAX_FILTER previously\n                     // and made it out of IBD.\n                     pto->m_tx_relay->nextSendTimeFeeFilter = count_microseconds(current_time) - 1;\n                 }\n             }\n             if (count_microseconds(current_time) > pto->m_tx_relay->nextSendTimeFeeFilter) {\n-                CAmount filterToSend = g_filter_rounder.round(currentFilter);\n+                CAmount filterToSend = m_filter_rounder.round(currentFilter);\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n                 if (filterToSend != pto->m_tx_relay->lastSentFeeFilter) {"
      },
      {
        "sha": "5487b318deaef7ae37e8740fc1ce8cf24b0b206e",
        "filename": "src/txorphanage.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9cedeba8aacb1d4095ab0abd82bca7379361329/src/txorphanage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9cedeba8aacb1d4095ab0abd82bca7379361329/src/txorphanage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.cpp?ref=d9cedeba8aacb1d4095ab0abd82bca7379361329",
        "patch": "@@ -106,9 +106,8 @@ unsigned int TxOrphanage::LimitOrphans(unsigned int max_orphans)\n     AssertLockHeld(g_cs_orphans);\n \n     unsigned int nEvicted = 0;\n-    static int64_t nNextSweep; // GUARDED_BY(g_cs_orphans)\n     int64_t nNow = GetTime();\n-    if (nNextSweep <= nNow) {\n+    if (m_next_sweep <= nNow) {\n         // Sweep out expired orphan pool entries:\n         int nErased = 0;\n         int64_t nMinExpTime = nNow + ORPHAN_TX_EXPIRE_TIME - ORPHAN_TX_EXPIRE_INTERVAL;\n@@ -123,7 +122,7 @@ unsigned int TxOrphanage::LimitOrphans(unsigned int max_orphans)\n             }\n         }\n         // Sweep again 5 minutes after the next entry that expires in order to batch the linear scan.\n-        nNextSweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n+        m_next_sweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n         if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n     }\n     FastRandomContext rng;"
      },
      {
        "sha": "e31a54a09bb5c9a654e8071d526e7d183e2658b0",
        "filename": "src/txorphanage.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9cedeba8aacb1d4095ab0abd82bca7379361329/src/txorphanage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9cedeba8aacb1d4095ab0abd82bca7379361329/src/txorphanage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txorphanage.h?ref=d9cedeba8aacb1d4095ab0abd82bca7379361329",
        "patch": "@@ -76,6 +76,9 @@ class TxOrphanage {\n     /** Index from wtxid into the m_orphans to lookup orphan\n      *  transactions using their witness ids. */\n     std::map<uint256, OrphanMap::iterator> m_wtxid_to_orphan_it GUARDED_BY(g_cs_orphans);\n+\n+    /** Timestamp for next sweep of orphans by LimitOrphanTxSize */\n+    int64_t m_next_sweep GUARDED_BY(g_cs_orphans) = 0;\n };\n \n #endif // BITCOIN_TXORPHANAGE_H"
      }
    ]
  },
  {
    "sha": "c4fd99ee61500023d94d33fbddfae6a899945621",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNGZkOTllZTYxNTAwMDIzZDk0ZDMzZmJkZGZhZTZhODk5OTQ1NjIx",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T14:01:37Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:29:32Z"
      },
      "message": "net_processing: Provide State(CNode&) shortcut",
      "tree": {
        "sha": "1b91e452a1ea625de10f0b78602e1773568e96d8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1b91e452a1ea625de10f0b78602e1773568e96d8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c4fd99ee61500023d94d33fbddfae6a899945621",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4fd99ee61500023d94d33fbddfae6a899945621",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c4fd99ee61500023d94d33fbddfae6a899945621",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4fd99ee61500023d94d33fbddfae6a899945621/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d9cedeba8aacb1d4095ab0abd82bca7379361329",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9cedeba8aacb1d4095ab0abd82bca7379361329",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d9cedeba8aacb1d4095ab0abd82bca7379361329"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 36,
      "deletions": 34
    },
    "files": [
      {
        "sha": "a46dda79b6bab0a1542046d271d3fca5feac92c4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 34,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c4fd99ee61500023d94d33fbddfae6a899945621/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c4fd99ee61500023d94d33fbddfae6a899945621/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c4fd99ee61500023d94d33fbddfae6a899945621",
        "patch": "@@ -595,6 +595,8 @@ class PeerManagerImpl final : public PeerManager\n     int m_height_of_highest_fast_announce GUARDED_BY(cs_main) = 0;\n \n     CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CNodeState* State(const CNode& node) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return State(node.GetId()); }\n+\n     void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void RelayTransaction(const uint256& txid, const uint256& wtxid) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -1345,7 +1347,7 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n         if (pnode->GetCommonVersion() < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n             return;\n         ProcessBlockAvailability(pnode->GetId());\n-        CNodeState &state = *State(pnode->GetId());\n+        CNodeState &state = *State(*pnode);\n         // If the peer has, or we announced to them the previous block already,\n         // but we don't think they have this one, go ahead and announce it\n         if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n@@ -1473,7 +1475,7 @@ void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid\n     m_connman.ForEachNode([this, &txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n         AssertLockHeld(::cs_main);\n \n-        CNodeState* state = State(pnode->GetId());\n+        CNodeState* state = State(*pnode);\n         if (state == nullptr) return;\n         if (state->m_wtxid_relay) {\n             pnode->PushTxInventory(wtxid);\n@@ -1663,7 +1665,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChain\n                 // they won't have a useful mempool to match against a compact block,\n                 // and we don't feel like constructing the object for them, so\n                 // instead we respond with the full, non-compact block.\n-                bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n+                bool fPeerWantsWitness = State(pfrom)->fWantsCmpctWitness;\n                 int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                 if (CanDirectFetch(consensusParams) && pindex->nHeight >= ::ChainActive().Height() - MAX_CMPCTBLOCK_DEPTH) {\n                     if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n@@ -1709,7 +1711,7 @@ CTransactionRef PeerManagerImpl::FindTxForGetData(const CNode& peer, const GenTx\n     {\n         LOCK(cs_main);\n         // Otherwise, the transaction must have been announced recently.\n-        if (State(peer.GetId())->m_recently_announced_invs.contains(gtxid.GetHash())) {\n+        if (State(peer)->m_recently_announced_invs.contains(gtxid.GetHash())) {\n             // If it was, it can be relayed from either the mempool...\n             if (txinfo.tx) return std::move(txinfo.tx);\n             // ... or the relay pool.\n@@ -1775,7 +1777,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n                 // Relaying a transaction with a recent but unconfirmed parent.\n                 if (WITH_LOCK(pfrom.m_tx_relay->cs_tx_inventory, return !pfrom.m_tx_relay->filterInventoryKnown.contains(parent_txid))) {\n                     LOCK(cs_main);\n-                    State(pfrom.GetId())->m_recently_announced_invs.insert(parent_txid);\n+                    State(pfrom)->m_recently_announced_invs.insert(parent_txid);\n                 }\n             }\n         } else {\n@@ -1818,7 +1820,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n uint32_t PeerManagerImpl::GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     uint32_t nFetchFlags = 0;\n-    if ((pfrom.GetLocalServices() & NODE_WITNESS) && State(pfrom.GetId())->fHaveWitness) {\n+    if ((pfrom.GetLocalServices() & NODE_WITNESS) && State(pfrom)->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n     }\n     return nFetchFlags;\n@@ -1836,7 +1838,7 @@ void PeerManagerImpl::SendBlockTransactions(CNode& pfrom, const CBlock& block, c\n     }\n     LOCK(cs_main);\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n-    int nSendFlags = State(pfrom.GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+    int nSendFlags = State(pfrom)->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n     m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n@@ -1856,7 +1858,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n     const CBlockIndex *pindexLast = nullptr;\n     {\n         LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom.GetId());\n+        CNodeState *nodestate = State(pfrom);\n \n         // If this looks like it could be a block announcement (nCount <\n         // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n@@ -1911,7 +1913,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n \n     {\n         LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom.GetId());\n+        CNodeState *nodestate = State(pfrom);\n         if (nodestate->nUnconnectingHeaders > 0) {\n             LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom.GetId(), nodestate->nUnconnectingHeaders);\n         }\n@@ -1947,7 +1949,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             while (pindexWalk && !::ChainActive().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n                         !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n-                        (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n+                        (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom)->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n                 }\n@@ -2446,13 +2448,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if((nServices & NODE_WITNESS))\n         {\n             LOCK(cs_main);\n-            State(pfrom.GetId())->fHaveWitness = true;\n+            State(pfrom)->fHaveWitness = true;\n         }\n \n         // Potentially mark this peer as a preferred download peer.\n         {\n         LOCK(cs_main);\n-        UpdatePreferredDownload(pfrom, State(pfrom.GetId()));\n+        UpdatePreferredDownload(pfrom, State(pfrom));\n         }\n \n         if (!pfrom.IsInboundConn() && !pfrom.IsBlockOnlyConn()) {\n@@ -2579,7 +2581,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n     if (msg_type == NetMsgType::SENDHEADERS) {\n         LOCK(cs_main);\n-        State(pfrom.GetId())->fPreferHeaders = true;\n+        State(pfrom)->fPreferHeaders = true;\n         return;\n     }\n \n@@ -2590,21 +2592,21 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (nCMPCTBLOCKVersion == 1 || ((pfrom.GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n             LOCK(cs_main);\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n-            if (!State(pfrom.GetId())->fProvidesHeaderAndIDs) {\n-                State(pfrom.GetId())->fProvidesHeaderAndIDs = true;\n-                State(pfrom.GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+            if (!State(pfrom)->fProvidesHeaderAndIDs) {\n+                State(pfrom)->fProvidesHeaderAndIDs = true;\n+                State(pfrom)->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n             }\n-            if (State(pfrom.GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) { // ignore later version announces\n-                State(pfrom.GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            if (State(pfrom)->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) { // ignore later version announces\n+                State(pfrom)->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n                 // save whether peer selects us as BIP152 high-bandwidth peer\n                 // (receiving sendcmpct(1) signals high-bandwidth, sendcmpct(0) low-bandwidth)\n                 pfrom.m_bip152_highbandwidth_from = fAnnounceUsingCMPCTBLOCK;\n             }\n-            if (!State(pfrom.GetId())->fSupportsDesiredCmpctVersion) {\n+            if (!State(pfrom)->fSupportsDesiredCmpctVersion) {\n                 if (pfrom.GetLocalServices() & NODE_WITNESS)\n-                    State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n+                    State(pfrom)->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n                 else\n-                    State(pfrom.GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n+                    State(pfrom)->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n             }\n         }\n         return;\n@@ -2621,8 +2623,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n         if (pfrom.GetCommonVersion() >= WTXID_RELAY_VERSION) {\n             LOCK(cs_main);\n-            if (!State(pfrom.GetId())->m_wtxid_relay) {\n-                State(pfrom.GetId())->m_wtxid_relay = true;\n+            if (!State(pfrom)->m_wtxid_relay) {\n+                State(pfrom)->m_wtxid_relay = true;\n                 m_wtxid_relay_peers++;\n             } else {\n                 LogPrint(BCLog::NET, \"ignoring duplicate wtxidrelay from peer=%d\\n\", pfrom.GetId());\n@@ -2745,7 +2747,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // Ignore INVs that don't match wtxidrelay setting.\n             // Note that orphan parent fetching always uses MSG_TX GETDATAs regardless of the wtxidrelay setting.\n             // This is fine as no INV messages are involved in that process.\n-            if (State(pfrom.GetId())->m_wtxid_relay) {\n+            if (State(pfrom)->m_wtxid_relay) {\n                 if (inv.IsMsgTx()) continue;\n             } else {\n                 if (inv.IsMsgWtx()) continue;\n@@ -2925,7 +2927,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // actually receive all the data read from disk over the network.\n         LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom.GetId(), MAX_BLOCKTXN_DEPTH);\n         CInv inv;\n-        WITH_LOCK(cs_main, inv.type = State(pfrom.GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n+        WITH_LOCK(cs_main, inv.type = State(pfrom)->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK);\n         inv.hash = req.blockhash;\n         WITH_LOCK(peer->m_getdata_requests_mutex, peer->m_getdata_requests.push_back(inv));\n         // The message processing loop will go around again (without pausing) and we'll respond then\n@@ -2949,7 +2951,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        CNodeState *nodestate = State(pfrom.GetId());\n+        CNodeState *nodestate = State(pfrom);\n         const CBlockIndex* pindex = nullptr;\n         if (locator.IsNull())\n         {\n@@ -3019,7 +3021,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         LOCK2(cs_main, g_cs_orphans);\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n+        CNodeState* nodestate = State(pfrom);\n \n         const uint256& hash = nodestate->m_wtxid_relay ? wtxid : txid;\n         pfrom.AddKnownTx(hash);\n@@ -3267,7 +3269,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         assert(pindex);\n         UpdateBlockAvailability(pfrom.GetId(), pindex->GetBlockHash());\n \n-        CNodeState *nodestate = State(pfrom.GetId());\n+        CNodeState *nodestate = State(pfrom);\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n@@ -3947,7 +3949,7 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);\n \n-    CNodeState &state = *State(pto.GetId());\n+    CNodeState &state = *State(pto);\n     const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n \n     if (!state.m_chain_sync.m_protect && pto.IsOutboundOrBlockRelayConn() && state.fSyncStarted) {\n@@ -4028,7 +4030,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             // at all.\n             // Note that we only request blocks from a peer if we learn of a\n             // valid headers chain with at least as much work as our tip.\n-            CNodeState *node_state = State(pnode->GetId());\n+            CNodeState *node_state = State(*pnode);\n             if (node_state == nullptr ||\n                 (time_in_seconds - pnode->nTimeConnected >= MINIMUM_CONNECT_TIME && node_state->nBlocksInFlight == 0)) {\n                 pnode->fDisconnect = true;\n@@ -4057,7 +4059,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             // Only consider outbound-full-relay peers that are not already\n             // marked for disconnection\n             if (!pnode->IsFullOutboundConn() || pnode->fDisconnect) return;\n-            CNodeState *state = State(pnode->GetId());\n+            CNodeState *state = State(*pnode);\n             if (state == nullptr) return; // shouldn't be possible, but just in case\n             // Don't evict our protected peers\n             if (state->m_chain_sync.m_protect) return;\n@@ -4075,7 +4077,7 @@ void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n                 // it time for new information to have arrived.\n                 // Also don't disconnect any peer we're trying to download a\n                 // block from.\n-                CNodeState &state = *State(pnode->GetId());\n+                CNodeState &state = *State(*pnode);\n                 if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n                     LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n                     pnode->fDisconnect = true;\n@@ -4192,7 +4194,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     {\n         LOCK(cs_main);\n \n-        CNodeState &state = *State(pto->GetId());\n+        CNodeState &state = *State(*pto);\n \n         // Address refresh broadcast\n         auto current_time = GetTime<std::chrono::microseconds>();\n@@ -4527,7 +4529,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+                        State(*pto)->m_recently_announced_invs.insert(hash);\n                         vInv.push_back(inv);\n                         nRelayedTransactions++;\n                         {"
      }
    ]
  },
  {
    "sha": "70402660aab037b28aa38efc18d6139927bf2836",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MDQwMjY2MGFhYjAzN2IyOGFhMzhlZmMxOGQ2MTM5OTI3YmYyODM2",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T13:50:23Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:29:32Z"
      },
      "message": "net_processing: move CNodeState into Peer\n\nAlso obsoletes mapNodeState.",
      "tree": {
        "sha": "99d14e2c78847830433aca16a88354fcee5d1601",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/99d14e2c78847830433aca16a88354fcee5d1601"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/70402660aab037b28aa38efc18d6139927bf2836",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70402660aab037b28aa38efc18d6139927bf2836",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/70402660aab037b28aa38efc18d6139927bf2836",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70402660aab037b28aa38efc18d6139927bf2836/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c4fd99ee61500023d94d33fbddfae6a899945621",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4fd99ee61500023d94d33fbddfae6a899945621",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c4fd99ee61500023d94d33fbddfae6a899945621"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 30,
      "deletions": 27
    },
    "files": [
      {
        "sha": "736df85a59476992ad62302aed8fd560cc07c08e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 27,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70402660aab037b28aa38efc18d6139927bf2836/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70402660aab037b28aa38efc18d6139927bf2836/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=70402660aab037b28aa38efc18d6139927bf2836",
        "patch": "@@ -333,7 +333,10 @@ struct Peer {\n     /** Work queue of items requested by this peer **/\n     std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n \n-    explicit Peer(NodeId id) : m_id(id) {}\n+    /** Traditional CNodeState info **/\n+    CNodeState nodestate GUARDED_BY(cs_main);\n+\n+    explicit Peer(NodeId id, CAddress addr, bool is_inbound) : m_id(id),  nodestate(addr, is_inbound) {}\n };\n \n using PeerRef = std::shared_ptr<Peer>;\n@@ -383,7 +386,7 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Get a shared pointer to the Peer object and remove it from m_peer_map.\n      *  May return an empty shared_ptr if the Peer object can't be found. */\n-    PeerRef RemovePeer(NodeId id);\n+    PeerRef RemovePeer(NodeId id) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /**\n      * Potentially mark a node discouraged based on the contents of a BlockValidationState object\n@@ -457,6 +460,10 @@ class PeerManagerImpl final : public PeerManager\n      * by the m_peer_mutex. Once a shared pointer reference is\n      * taken, the lock may be released. Individual fields are protected by\n      * their own locks.\n+     *\n+     * Removals to this are additionally gated by cs_main, so that holding\n+     * a non-shared reference to peer.nodestate is safe while cs_main\n+     * is held (see State, RemoveNode).\n      */\n     std::map<NodeId, PeerRef> m_peer_map GUARDED_BY(m_peer_mutex);\n \n@@ -604,9 +611,6 @@ class PeerManagerImpl final : public PeerManager\n     uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds) override;\n \n-    /** Map maintaining per-node state. */\n-    std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n-\n     // All of the following cache a recent block, and are protected by cs_most_recent_block\n     RecursiveMutex cs_most_recent_block;\n     std::shared_ptr<const CBlock> most_recent_block GUARDED_BY(cs_most_recent_block);\n@@ -623,10 +627,12 @@ class PeerManagerImpl final : public PeerManager\n namespace {\n CNodeState *PeerManagerImpl::State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n-    if (it == mapNodeState.end())\n-        return nullptr;\n-    return &it->second;\n+    PeerRef peer = GetPeerRef(pnode);\n+    if (!peer) return nullptr;\n+    // peer will not be removed from m_peer_map until RemovePeer is called,\n+    // which requires cs_main to be held; as such the nodestate returned will\n+    // remain valid at least until cs_main is freed\n+    return &peer->nodestate;\n }\n \n void PeerManagerImpl::UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -957,11 +963,10 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n     NodeId nodeid = pnode->GetId();\n     {\n         LOCK(cs_main);\n-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, pnode->IsInboundConn()));\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n     {\n-        PeerRef peer = std::make_shared<Peer>(nodeid);\n+        PeerRef peer = std::make_shared<Peer>(nodeid, std::move(addr), pnode->IsInboundConn());\n         LOCK(m_peer_mutex);\n         m_peer_map.emplace_hint(m_peer_map.end(), nodeid, std::move(peer));\n     }\n@@ -997,18 +1002,17 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     fUpdateConnectionTime = false;\n     LOCK(cs_main);\n     int misbehavior{0};\n-    {\n-        // We remove the PeerRef from g_peer_map here, but we don't always\n-        // destruct the Peer. Sometimes another thread is still holding a\n-        // PeerRef, so the refcount is >= 1. Be careful not to do any\n-        // processing here that assumes Peer won't be changed before it's\n-        // destructed.\n-        PeerRef peer = RemovePeer(nodeid);\n-        assert(peer != nullptr);\n-        misbehavior = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);\n-    }\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n+\n+    // We remove the PeerRef from g_peer_map here, but we don't always\n+    // destruct the Peer. Sometimes another thread is still holding a\n+    // PeerRef, so the refcount is >= 1. Be careful not to do any\n+    // processing here that assumes Peer won't be changed before it's\n+    // destructed.\n+    PeerRef peer = RemovePeer(nodeid);\n+    assert(peer != nullptr);\n+    misbehavior = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);\n+\n+    CNodeState *state = &peer->nodestate;\n \n     if (state->fSyncStarted)\n         nSyncStarted--;\n@@ -1032,9 +1036,8 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     m_wtxid_relay_peers -= state->m_wtxid_relay;\n     assert(m_wtxid_relay_peers >= 0);\n \n-    mapNodeState.erase(nodeid);\n-\n-    if (mapNodeState.empty()) {\n+    LOCK(m_peer_mutex);\n+    if (m_peer_map.empty()) {\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n@@ -1053,7 +1056,7 @@ PeerRef PeerManagerImpl::GetPeerRef(NodeId id) const\n     return it != m_peer_map.end() ? it->second : nullptr;\n }\n \n-PeerRef PeerManagerImpl::RemovePeer(NodeId id)\n+PeerRef PeerManagerImpl::RemovePeer(NodeId id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     PeerRef ret;\n     LOCK(m_peer_mutex);"
      }
    ]
  },
  {
    "sha": "e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMmRlNjI0ZGQzZmM2ZDhiYTBjNzA1NTIyZWYxZjUyYzU1MzljYmRl",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-04T07:59:21Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:31:43Z"
      },
      "message": "Make ProcessBlockAvailability take a CNodeState& instead of a NodeId\n\nFixes lock order violations introduced by merging CNodeState into Peer",
      "tree": {
        "sha": "724c9731e27172fa67282e8c28406f93a6c99095",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/724c9731e27172fa67282e8c28406f93a6c99095"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "70402660aab037b28aa38efc18d6139927bf2836",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70402660aab037b28aa38efc18d6139927bf2836",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/70402660aab037b28aa38efc18d6139927bf2836"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 11,
      "deletions": 14
    },
    "files": [
      {
        "sha": "b8c9f953aae7ac38ea78d5355027091bd95052a7",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 14,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
        "patch": "@@ -604,7 +604,7 @@ class PeerManagerImpl final : public PeerManager\n     CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     CNodeState* State(const CNode& node) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return State(node.GetId()); }\n \n-    void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ProcessBlockAvailability(CNodeState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void RelayTransaction(const uint256& txid, const uint256& wtxid) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, const CInv& inv, CConnman& connman);\n@@ -704,18 +704,15 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n }\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n-void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManagerImpl::ProcessBlockAvailability(CNodeState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    if (!state->hashLastUnknownBlock.IsNull()) {\n-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(state->hashLastUnknownBlock);\n+    if (!state.hashLastUnknownBlock.IsNull()) {\n+        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(state.hashLastUnknownBlock);\n         if (pindex && pindex->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-                state->pindexBestKnownBlock = pindex;\n+            if (state.pindexBestKnownBlock == nullptr || pindex->nChainWork >= state.pindexBestKnownBlock->nChainWork) {\n+                state.pindexBestKnownBlock = pindex;\n             }\n-            state->hashLastUnknownBlock.SetNull();\n+            state.hashLastUnknownBlock.SetNull();\n         }\n     }\n }\n@@ -726,7 +723,7 @@ void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n-    ProcessBlockAvailability(nodeid);\n+    ProcessBlockAvailability(*state);\n \n     const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);\n     if (pindex && pindex->nChainWork > 0) {\n@@ -813,7 +810,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n     assert(state != nullptr);\n \n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n-    ProcessBlockAvailability(nodeid);\n+    ProcessBlockAvailability(*state);\n \n     if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < ::ChainActive().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n@@ -1349,8 +1346,8 @@ void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::sha\n         // TODO: Avoid the repeated-serialization here\n         if (pnode->GetCommonVersion() < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n             return;\n-        ProcessBlockAvailability(pnode->GetId());\n         CNodeState &state = *State(*pnode);\n+        ProcessBlockAvailability(state);\n         // If the peer has, or we announced to them the previous block already,\n         // but we don't think they have this one, go ahead and announce it\n         if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n@@ -4299,7 +4296,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                                  (!state.fPreferHeaderAndIDs || peer->m_blocks_for_headers_relay.size() > 1)) ||\n                                  peer->m_blocks_for_headers_relay.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n-            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(state); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;"
      }
    ]
  },
  {
    "sha": "3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZGE4ZDM2ZGIxYTFjZGQ4OTE4ZmE5NTVmZTAxZDUwYWI0YzUyMjMz",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-04T07:59:00Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T14:31:45Z"
      },
      "message": "Use Peer::nodestate directly instead of State()\n\nFixes lock order violations caused by merging CNodeState into Peer",
      "tree": {
        "sha": "14bcacba474130bcb63bda80a942e0a306f84ad4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/14bcacba474130bcb63bda80a942e0a306f84ad4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3da8d36db1a1cdd8918fa955fe01d50ab4c52233/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e2de624dd3fc6d8ba0c705522ef1f52c5539cbde"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "29d1070b197f62d72192f61040bc1c4275e04bb1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3da8d36db1a1cdd8918fa955fe01d50ab4c52233/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3da8d36db1a1cdd8918fa955fe01d50ab4c52233/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
        "patch": "@@ -1777,7 +1777,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic\n                 // Relaying a transaction with a recent but unconfirmed parent.\n                 if (WITH_LOCK(pfrom.m_tx_relay->cs_tx_inventory, return !pfrom.m_tx_relay->filterInventoryKnown.contains(parent_txid))) {\n                     LOCK(cs_main);\n-                    State(pfrom)->m_recently_announced_invs.insert(parent_txid);\n+                    peer.nodestate.m_recently_announced_invs.insert(parent_txid);\n                 }\n             }\n         } else {\n@@ -4194,7 +4194,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     {\n         LOCK(cs_main);\n \n-        CNodeState &state = *State(*pto);\n+        CNodeState& state = peer->nodestate;\n \n         // Address refresh broadcast\n         auto current_time = GetTime<std::chrono::microseconds>();\n@@ -4529,7 +4529,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(*pto)->m_recently_announced_invs.insert(hash);\n+                        peer->nodestate.m_recently_announced_invs.insert(hash);\n                         vInv.push_back(inv);\n                         nRelayedTransactions++;\n                         {"
      }
    ]
  },
  {
    "sha": "bdbc1352475a8dec4187db2ce32795050efca83e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGJjMTM1MjQ3NWE4ZGVjNDE4N2RiMmNlMzI3OTUwNTBlZmNhODNl",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-09T13:08:20Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T16:34:31Z"
      },
      "message": "Make NetEventsInterface take a reference to a peer, since nullptr would be k-razy",
      "tree": {
        "sha": "68a3508f6c640b0207b04fcb48584b6d9f36f5d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/68a3508f6c640b0207b04fcb48584b6d9f36f5d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdbc1352475a8dec4187db2ce32795050efca83e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdbc1352475a8dec4187db2ce32795050efca83e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bdbc1352475a8dec4187db2ce32795050efca83e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdbc1352475a8dec4187db2ce32795050efca83e/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3da8d36db1a1cdd8918fa955fe01d50ab4c52233",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3da8d36db1a1cdd8918fa955fe01d50ab4c52233"
      }
    ],
    "stats": {
      "total": 315,
      "additions": 157,
      "deletions": 158
    },
    "files": [
      {
        "sha": "c178e038e3197b5e53098de1eb6892c95ebbef7c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -1114,7 +1114,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     pnode->AddRef();\n     pnode->m_permissionFlags = permissionFlags;\n     pnode->m_prefer_evict = discouraged;\n-    m_msgproc->InitializeNode(pnode);\n+    m_msgproc->InitializeNode(*pnode);\n \n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -2143,7 +2143,7 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     if (grantOutbound)\n         grantOutbound->MoveTo(pnode->grantOutbound);\n \n-    m_msgproc->InitializeNode(pnode);\n+    m_msgproc->InitializeNode(*pnode);\n     {\n         LOCK(cs_vNodes);\n         vNodes.push_back(pnode);\n@@ -2171,14 +2171,14 @@ void CConnman::ThreadMessageHandler()\n                 continue;\n \n             // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n+            bool fMoreNodeWork = m_msgproc->ProcessMessages(*pnode, flagInterruptMsgProc);\n             fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n             if (flagInterruptMsgProc)\n                 return;\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n-                m_msgproc->SendMessages(pnode);\n+                m_msgproc->SendMessages(*pnode);\n             }\n \n             if (flagInterruptMsgProc)"
      },
      {
        "sha": "82a9716f69309d0a99e73e779c365cd75a700c0d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -768,28 +768,27 @@ class NetEventsInterface\n {\n public:\n     /** Initialize a peer (setup state, queue any initial messages) */\n-    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void InitializeNode(CNode& node) = 0;\n \n     /** Handle removal of a peer (clear state) */\n     virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n     /**\n     * Process protocol messages received from a given node\n     *\n-    * @param[in]   pnode           The node which we have received messages from.\n+    * @param[in]   node            The node which we have received messages from.\n     * @param[in]   interrupt       Interrupt condition for processing threads\n     * @return                      True if there is more work to be done\n     */\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool ProcessMessages(CNode& node, std::atomic<bool>& interrupt) = 0;\n \n     /**\n     * Send queued protocol messages to a given node.\n     *\n-    * @param[in]   pnode           The node which we are sending messages to.\n+    * @param[in]   node            The node which we are sending messages to.\n     * @return                      True if there is more work to be done\n     */\n-    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n-\n+    virtual bool SendMessages(CNode& node) EXCLUSIVE_LOCKS_REQUIRED(node.cs_sendProcessing) = 0;\n \n protected:\n     /**"
      },
      {
        "sha": "946161acef46056c8e42d454a12d18fc69d804a9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 131,
        "changes": 262,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -356,10 +356,10 @@ class PeerManagerImpl final : public PeerManager\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n \n     /** Implement NetEventsInterface */\n-    void InitializeNode(CNode* pnode) override;\n+    void InitializeNode(CNode& node) override;\n     void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n-    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n-    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n+    bool ProcessMessages(CNode& node, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode& node) override EXCLUSIVE_LOCKS_REQUIRED(node.cs_sendProcessing);\n \n     /** Implement PeerManager */\n     void CheckForStaleTipAndEvictPeers() override;\n@@ -953,22 +953,22 @@ void PeerManagerImpl::UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_s\n     if (state) state->m_last_block_announcement = time_in_seconds;\n }\n \n-void PeerManagerImpl::InitializeNode(CNode *pnode)\n+void PeerManagerImpl::InitializeNode(CNode& node)\n {\n-    CAddress addr = pnode->addr;\n-    std::string addrName = pnode->GetAddrName();\n-    NodeId nodeid = pnode->GetId();\n+    CAddress addr = node.addr;\n+    std::string addrName = node.GetAddrName();\n+    NodeId nodeid = node.GetId();\n     {\n         LOCK(cs_main);\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n     {\n-        PeerRef peer = std::make_shared<Peer>(nodeid, std::move(addr), pnode->IsInboundConn());\n+        PeerRef peer = std::make_shared<Peer>(nodeid, std::move(addr), node.IsInboundConn());\n         LOCK(m_peer_mutex);\n         m_peer_map.emplace_hint(m_peer_map.end(), nodeid, std::move(peer));\n     }\n-    if (!pnode->IsInboundConn()) {\n-        PushNodeVersion(*pnode, GetTime());\n+    if (!node.IsInboundConn()) {\n+        PushNodeVersion(node, GetTime());\n     }\n }\n \n@@ -3868,17 +3868,17 @@ bool PeerManagerImpl::MaybeDiscourageAndDisconnect(CNode& pnode)\n     return true;\n }\n \n-bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n+bool PeerManagerImpl::ProcessMessages(CNode& node, std::atomic<bool>& interruptMsgProc)\n {\n     bool fMoreWork = false;\n \n-    PeerRef peer = GetPeerRef(pfrom->GetId());\n+    PeerRef peer = GetPeerRef(node.GetId());\n     if (peer == nullptr) return false;\n \n     {\n         LOCK(peer->m_getdata_requests_mutex);\n         if (!peer->m_getdata_requests.empty()) {\n-            ProcessGetData(*pfrom, *peer, interruptMsgProc);\n+            ProcessGetData(node, *peer, interruptMsgProc);\n         }\n     }\n \n@@ -3889,7 +3889,7 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n         }\n     }\n \n-    if (pfrom->fDisconnect)\n+    if (node.fDisconnect)\n         return false;\n \n     // this maintains the order of responses\n@@ -3905,32 +3905,32 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n     }\n \n     // Don't bother if send buffer is too full to respond anyway\n-    if (pfrom->fPauseSend) return false;\n+    if (node.fPauseSend) return false;\n \n     std::list<CNetMessage> msgs;\n     {\n-        LOCK(pfrom->cs_vProcessMsg);\n-        if (pfrom->vProcessMsg.empty()) return false;\n+        LOCK(node.cs_vProcessMsg);\n+        if (node.vProcessMsg.empty()) return false;\n         // Just take one message\n-        msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n-        pfrom->nProcessQueueSize -= msgs.front().m_raw_message_size;\n-        pfrom->fPauseRecv = pfrom->nProcessQueueSize > m_connman.GetReceiveFloodSize();\n-        fMoreWork = !pfrom->vProcessMsg.empty();\n+        msgs.splice(msgs.begin(), node.vProcessMsg, node.vProcessMsg.begin());\n+        node.nProcessQueueSize -= msgs.front().m_raw_message_size;\n+        node.fPauseRecv = node.nProcessQueueSize > m_connman.GetReceiveFloodSize();\n+        fMoreWork = !node.vProcessMsg.empty();\n     }\n     CNetMessage& msg(msgs.front());\n \n     if (gArgs.GetBoolArg(\"-capturemessages\", false)) {\n-        CaptureMessage(pfrom->addr, msg.m_command, MakeUCharSpan(msg.m_recv), /* incoming */ true);\n+        CaptureMessage(node.addr, msg.m_command, MakeUCharSpan(msg.m_recv), /* incoming */ true);\n     }\n \n-    msg.SetVersion(pfrom->GetCommonVersion());\n+    msg.SetVersion(node.GetCommonVersion());\n     const std::string& msg_type = msg.m_command;\n \n     // Message size\n     unsigned int nMessageSize = msg.m_message_size;\n \n     try {\n-        ProcessMessage(*pfrom, msg_type, msg.m_recv, msg.m_time, interruptMsgProc);\n+        ProcessMessage(node, msg_type, msg.m_recv, msg.m_time, interruptMsgProc);\n         if (interruptMsgProc) return false;\n         {\n             LOCK(peer->m_getdata_requests_mutex);\n@@ -4146,31 +4146,31 @@ class CompareInvMempoolOrder\n };\n }\n \n-bool PeerManagerImpl::SendMessages(CNode* pto)\n+bool PeerManagerImpl::SendMessages(CNode& node)\n {\n-    PeerRef peer = GetPeerRef(pto->GetId());\n+    PeerRef peer = GetPeerRef(node.GetId());\n     const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n \n     // We must call MaybeDiscourageAndDisconnect first, to ensure that we'll\n     // disconnect misbehaving peers even before the version handshake is complete.\n-    if (MaybeDiscourageAndDisconnect(*pto)) return true;\n+    if (MaybeDiscourageAndDisconnect(node)) return true;\n \n     // Don't send anything until the version handshake is complete\n-    if (!pto->fSuccessfullyConnected || pto->fDisconnect)\n+    if (!node.fSuccessfullyConnected || node.fDisconnect)\n         return true;\n \n     // If we get here, the outgoing message serialization version is set and can't change.\n-    const CNetMsgMaker msgMaker(pto->GetCommonVersion());\n+    const CNetMsgMaker msgMaker(node.GetCommonVersion());\n \n     //\n     // Message: ping\n     //\n     bool pingSend = false;\n-    if (pto->fPingQueued) {\n+    if (node.fPingQueued) {\n         // RPC ping request by user\n         pingSend = true;\n     }\n-    if (pto->nPingNonceSent == 0 && pto->m_ping_start.load() + PING_INTERVAL < GetTime<std::chrono::microseconds>()) {\n+    if (node.nPingNonceSent == 0 && node.m_ping_start.load() + PING_INTERVAL < GetTime<std::chrono::microseconds>()) {\n         // Ping automatically sent as a latency probe & keepalive.\n         pingSend = true;\n     }\n@@ -4179,15 +4179,15 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         while (nonce == 0) {\n             GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n         }\n-        pto->fPingQueued = false;\n-        pto->m_ping_start = GetTime<std::chrono::microseconds>();\n-        if (pto->GetCommonVersion() > BIP0031_VERSION) {\n-            pto->nPingNonceSent = nonce;\n-            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n+        node.fPingQueued = false;\n+        node.m_ping_start = GetTime<std::chrono::microseconds>();\n+        if (node.GetCommonVersion() > BIP0031_VERSION) {\n+            node.nPingNonceSent = nonce;\n+            m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::PING, nonce));\n         } else {\n             // Peer is too old to support ping command with nonce, pong will never arrive.\n-            pto->nPingNonceSent = 0;\n-            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n+            node.nPingNonceSent = 0;\n+            m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::PING));\n         }\n     }\n \n@@ -4199,66 +4199,66 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // Address refresh broadcast\n         auto current_time = GetTime<std::chrono::microseconds>();\n \n-        if (pto->RelayAddrsWithConn() && !::ChainstateActive().IsInitialBlockDownload() && pto->m_next_local_addr_send < current_time) {\n+        if (node.RelayAddrsWithConn() && !::ChainstateActive().IsInitialBlockDownload() && node.m_next_local_addr_send < current_time) {\n             // If we've sent before, clear the bloom filter for the peer, so that our\n             // self-announcement will actually go out.\n             // This might be unnecessary if the bloom filter has already rolled\n             // over since our last self-announcement, but there is only a small\n             // bandwidth cost that we can incur by doing this (which happens\n             // once a day on average).\n-            if (pto->m_next_local_addr_send != 0us) {\n-                pto->m_addr_known->reset();\n+            if (node.m_next_local_addr_send != 0us) {\n+                node.m_addr_known->reset();\n             }\n-            AdvertiseLocal(pto);\n-            pto->m_next_local_addr_send = PoissonNextSend(current_time, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n+            AdvertiseLocal(&node);\n+            node.m_next_local_addr_send = PoissonNextSend(current_time, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n         }\n \n         //\n         // Message: addr\n         //\n-        if (pto->RelayAddrsWithConn() && pto->m_next_addr_send < current_time) {\n-            pto->m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n+        if (node.RelayAddrsWithConn() && node.m_next_addr_send < current_time) {\n+            node.m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n             std::vector<CAddress> vAddr;\n-            vAddr.reserve(pto->vAddrToSend.size());\n-            assert(pto->m_addr_known);\n+            vAddr.reserve(node.vAddrToSend.size());\n+            assert(node.m_addr_known);\n \n             const char* msg_type;\n             int make_flags;\n-            if (pto->m_wants_addrv2) {\n+            if (node.m_wants_addrv2) {\n                 msg_type = NetMsgType::ADDRV2;\n                 make_flags = ADDRV2_FORMAT;\n             } else {\n                 msg_type = NetMsgType::ADDR;\n                 make_flags = 0;\n             }\n \n-            for (const CAddress& addr : pto->vAddrToSend)\n+            for (const CAddress& addr : node.vAddrToSend)\n             {\n-                if (!pto->m_addr_known->contains(addr.GetKey()))\n+                if (!node.m_addr_known->contains(addr.GetKey()))\n                 {\n-                    pto->m_addr_known->insert(addr.GetKey());\n+                    node.m_addr_known->insert(addr.GetKey());\n                     vAddr.push_back(addr);\n                     // receiver rejects addr messages larger than MAX_ADDR_TO_SEND\n                     if (vAddr.size() >= MAX_ADDR_TO_SEND)\n                     {\n-                        m_connman.PushMessage(pto, msgMaker.Make(make_flags, msg_type, vAddr));\n+                        m_connman.PushMessage(&node, msgMaker.Make(make_flags, msg_type, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n-            pto->vAddrToSend.clear();\n+            node.vAddrToSend.clear();\n             if (!vAddr.empty())\n-                m_connman.PushMessage(pto, msgMaker.Make(make_flags, msg_type, vAddr));\n+                m_connman.PushMessage(&node, msgMaker.Make(make_flags, msg_type, vAddr));\n             // we only send the big addr message once\n-            if (pto->vAddrToSend.capacity() > 40)\n-                pto->vAddrToSend.shrink_to_fit();\n+            if (node.vAddrToSend.capacity() > 40)\n+                node.vAddrToSend.shrink_to_fit();\n         }\n \n         // Start block sync\n         if (pindexBestHeader == nullptr)\n             pindexBestHeader = ::ChainActive().Tip();\n-        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->IsAddrFetchConn()); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !node.fClient && !node.IsAddrFetchConn()); // Download if this is a nice peer, or we have no nice peers and this one might do.\n+        if (!state.fSyncStarted && !node.fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n@@ -4274,8 +4274,8 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n-                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), peer->m_starting_height);\n-                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n+                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, node.GetId(), peer->m_starting_height);\n+                m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -4350,7 +4350,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n                     LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->GetId());\n+                            vHeaders.front().GetHash().ToString(), node.GetId());\n \n                     int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n@@ -4359,10 +4359,10 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n                             if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n-                                m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n+                                m_connman.PushMessage(&node, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n-                                m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                                m_connman.PushMessage(&node, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                             }\n                             fGotBlockFromCache = true;\n                         }\n@@ -4372,20 +4372,20 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                         assert(ret);\n                         CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                        m_connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                        m_connman.PushMessage(&node, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     }\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {\n                         LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n                                 vHeaders.front().GetHash().ToString(),\n-                                vHeaders.back().GetHash().ToString(), pto->GetId());\n+                                vHeaders.back().GetHash().ToString(), node.GetId());\n                     } else {\n                         LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n-                                vHeaders.front().GetHash().ToString(), pto->GetId());\n+                                vHeaders.front().GetHash().ToString(), node.GetId());\n                     }\n-                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+                    m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n@@ -4411,7 +4411,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     if (!PeerHasHeader(&state, pindex)) {\n                         peer->m_blocks_for_inv_relay.push_back(hashToAnnounce);\n                         LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n-                            pto->GetId(), hashToAnnounce.ToString());\n+                            node.GetId(), hashToAnnounce.ToString());\n                     }\n                 }\n             }\n@@ -4430,79 +4430,79 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             for (const uint256& hash : peer->m_blocks_for_inv_relay) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n-                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                    m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::INV, vInv));\n                     vInv.clear();\n                 }\n             }\n             peer->m_blocks_for_inv_relay.clear();\n \n-            if (pto->m_tx_relay != nullptr) {\n-                LOCK(pto->m_tx_relay->cs_tx_inventory);\n+            if (node.m_tx_relay != nullptr) {\n+                LOCK(node.m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n-                bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n-                if (pto->m_tx_relay->nNextInvSend < current_time) {\n+                bool fSendTrickle = node.HasPermission(PF_NOBAN);\n+                if (node.m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n-                    if (pto->IsInboundConn()) {\n-                        pto->m_tx_relay->nNextInvSend = std::chrono::microseconds{m_connman.PoissonNextSendInbound(count_microseconds(current_time), INVENTORY_BROADCAST_INTERVAL)};\n+                    if (node.IsInboundConn()) {\n+                        node.m_tx_relay->nNextInvSend = std::chrono::microseconds{m_connman.PoissonNextSendInbound(count_microseconds(current_time), INVENTORY_BROADCAST_INTERVAL)};\n                     } else {\n                         // Use half the delay for outbound peers, as there is less privacy concern for them.\n-                        pto->m_tx_relay->nNextInvSend = PoissonNextSend(current_time, std::chrono::seconds{INVENTORY_BROADCAST_INTERVAL >> 1});\n+                        node.m_tx_relay->nNextInvSend = PoissonNextSend(current_time, std::chrono::seconds{INVENTORY_BROADCAST_INTERVAL >> 1});\n                     }\n                 }\n \n                 // Time to send but the peer has requested we not relay transactions.\n                 if (fSendTrickle) {\n-                    LOCK(pto->m_tx_relay->cs_filter);\n-                    if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->setInventoryTxToSend.clear();\n+                    LOCK(node.m_tx_relay->cs_filter);\n+                    if (!node.m_tx_relay->fRelayTxes) node.m_tx_relay->setInventoryTxToSend.clear();\n                 }\n \n                 // Respond to BIP35 mempool requests\n-                if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n+                if (fSendTrickle && node.m_tx_relay->fSendMempool) {\n                     auto vtxinfo = m_mempool.infoAll();\n-                    pto->m_tx_relay->fSendMempool = false;\n-                    const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n+                    node.m_tx_relay->fSendMempool = false;\n+                    const CFeeRate filterrate{node.m_tx_relay->minFeeFilter.load()};\n \n-                    LOCK(pto->m_tx_relay->cs_filter);\n+                    LOCK(node.m_tx_relay->cs_filter);\n \n                     for (const auto& txinfo : vtxinfo) {\n                         const uint256& hash = state.m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n+                        node.m_tx_relay->setInventoryTxToSend.erase(hash);\n                         // Don't send transactions that peers will not put into their mempool\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (pto->m_tx_relay->pfilter) {\n-                            if (!pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (node.m_tx_relay->pfilter) {\n+                            if (!node.m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         }\n-                        pto->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        node.m_tx_relay->filterInventoryKnown.insert(hash);\n                         // Responses to MEMPOOL requests bypass the m_recently_announced_invs filter.\n                         vInv.push_back(inv);\n                         if (vInv.size() == MAX_INV_SZ) {\n-                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                            m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n                     }\n-                    pto->m_tx_relay->m_last_mempool_req = GetTime<std::chrono::seconds>();\n+                    node.m_tx_relay->m_last_mempool_req = GetTime<std::chrono::seconds>();\n                 }\n \n                 // Determine transactions to relay\n                 if (fSendTrickle) {\n                     // Produce a vector with all candidates for sending\n                     std::vector<std::set<uint256>::iterator> vInvTx;\n-                    vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n-                    for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n+                    vInvTx.reserve(node.m_tx_relay->setInventoryTxToSend.size());\n+                    for (std::set<uint256>::iterator it = node.m_tx_relay->setInventoryTxToSend.begin(); it != node.m_tx_relay->setInventoryTxToSend.end(); it++) {\n                         vInvTx.push_back(it);\n                     }\n-                    const CFeeRate filterrate{pto->m_tx_relay->minFeeFilter.load()};\n+                    const CFeeRate filterrate{node.m_tx_relay->minFeeFilter.load()};\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n                     CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, state.m_wtxid_relay);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n                     unsigned int nRelayedTransactions = 0;\n-                    LOCK(pto->m_tx_relay->cs_filter);\n+                    LOCK(node.m_tx_relay->cs_filter);\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n@@ -4511,9 +4511,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         uint256 hash = *it;\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                         // Remove it from the to-be-sent set\n-                        pto->m_tx_relay->setInventoryTxToSend.erase(it);\n+                        node.m_tx_relay->setInventoryTxToSend.erase(it);\n                         // Check if not in the filter already\n-                        if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n+                        if (node.m_tx_relay->filterInventoryKnown.contains(hash)) {\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n@@ -4527,7 +4527,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                             continue;\n                         }\n-                        if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        if (node.m_tx_relay->pfilter && !node.m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         peer->nodestate.m_recently_announced_invs.insert(hash);\n                         vInv.push_back(inv);\n@@ -4551,33 +4551,33 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             }\n                         }\n                         if (vInv.size() == MAX_INV_SZ) {\n-                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                            m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::INV, vInv));\n                             vInv.clear();\n                         }\n-                        pto->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        node.m_tx_relay->filterInventoryKnown.insert(hash);\n                         if (hash != txid) {\n                             // Insert txid into filterInventoryKnown, even for\n                             // wtxidrelay peers. This prevents re-adding of\n                             // unconfirmed parents to the recently_announced\n                             // filter, when a child tx is requested. See\n                             // ProcessGetData().\n-                            pto->m_tx_relay->filterInventoryKnown.insert(txid);\n+                            node.m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n                 }\n             }\n         }\n         if (!vInv.empty())\n-            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+            m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n         current_time = GetTime<std::chrono::microseconds>();\n         if (state.nStallingSince && state.nStallingSince < count_microseconds(current_time) - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n-            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n-            pto->fDisconnect = true;\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", node.GetId());\n+            node.fDisconnect = true;\n             return true;\n         }\n         // In case there is a block that has been in flight from this peer for 2 + 0.5 * N times the block interval\n@@ -4589,8 +4589,8 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n             if (count_microseconds(current_time) > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n-                pto->fDisconnect = true;\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), node.GetId());\n+                node.fDisconnect = true;\n                 return true;\n             }\n         }\n@@ -4604,12 +4604,12 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     // Note: If all our peers are inbound, then we won't\n                     // disconnect our sync peer for stalling; we have bigger\n                     // problems if we can't get any outbound peers.\n-                    if (!pto->HasPermission(PF_NOBAN)) {\n-                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n-                        pto->fDisconnect = true;\n+                    if (!node.HasPermission(PF_NOBAN)) {\n+                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", node.GetId());\n+                        node.fDisconnect = true;\n                         return true;\n                     } else {\n-                        LogPrintf(\"Timeout downloading headers from noban peer=%d, not disconnecting\\n\", pto->GetId());\n+                        LogPrintf(\"Timeout downloading headers from noban peer=%d, not disconnecting\\n\", node.GetId());\n                         // Reset the headers sync state so that we have a\n                         // chance to try downloading from a different peer.\n                         // Note: this will also result in at least one more\n@@ -4629,22 +4629,22 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n         // Check that outbound peers have reasonable chains\n         // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n-        ConsiderEviction(*pto, GetTime());\n+        ConsiderEviction(node, GetTime());\n \n         //\n         // Message: getdata (blocks)\n         //\n         std::vector<CInv> vGetData;\n-        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!node.fClient && ((fFetch && !node.m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n+            FindNextBlocksToDownload(node.GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n             for (const CBlockIndex *pindex : vToDownload) {\n-                uint32_t nFetchFlags = GetFetchFlags(*pto);\n+                uint32_t nFetchFlags = GetFetchFlags(node);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                MarkBlockAsInFlight(node.GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->GetId());\n+                    pindex->nHeight, node.GetId());\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n@@ -4658,21 +4658,21 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // Message: getdata (transactions)\n         //\n         std::vector<std::pair<NodeId, GenTxid>> expired;\n-        auto requestable = m_txrequest.GetRequestable(pto->GetId(), current_time, &expired);\n+        auto requestable = m_txrequest.GetRequestable(node.GetId(), current_time, &expired);\n         for (const auto& entry : expired) {\n             LogPrint(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n                 entry.second.GetHash().ToString(), entry.first);\n         }\n         for (const GenTxid& gtxid : requestable) {\n             if (!AlreadyHaveTx(gtxid)) {\n                 LogPrint(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n-                    gtxid.GetHash().ToString(), pto->GetId());\n-                vGetData.emplace_back(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*pto)), gtxid.GetHash());\n+                    gtxid.GetHash().ToString(), node.GetId());\n+                vGetData.emplace_back(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(node)), gtxid.GetHash());\n                 if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                     vGetData.clear();\n                 }\n-                m_txrequest.RequestedTx(pto->GetId(), gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n+                m_txrequest.RequestedTx(node.GetId(), gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n             } else {\n                 // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n                 // this should already be called whenever a transaction becomes AlreadyHaveTx().\n@@ -4682,13 +4682,13 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n \n         if (!vGetData.empty())\n-            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+            m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n         //\n         // Message: feefilter\n         //\n-        if (pto->m_tx_relay != nullptr && pto->GetCommonVersion() >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n-            !pto->HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n+        if (node.m_tx_relay != nullptr && node.GetCommonVersion() >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+            !node.HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n         ) {\n             CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             AssertLockHeld(cs_main);\n@@ -4697,27 +4697,27 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 // chainstate is in IBD, so tell the peer to not send them.\n                 currentFilter = MAX_MONEY;\n             } else {\n-                if (pto->m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n+                if (node.m_tx_relay->lastSentFeeFilter == MAX_FILTER) {\n                     // Send the current filter if we sent MAX_FILTER previously\n                     // and made it out of IBD.\n-                    pto->m_tx_relay->nextSendTimeFeeFilter = count_microseconds(current_time) - 1;\n+                    node.m_tx_relay->nextSendTimeFeeFilter = count_microseconds(current_time) - 1;\n                 }\n             }\n-            if (count_microseconds(current_time) > pto->m_tx_relay->nextSendTimeFeeFilter) {\n+            if (count_microseconds(current_time) > node.m_tx_relay->nextSendTimeFeeFilter) {\n                 CAmount filterToSend = m_filter_rounder.round(currentFilter);\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-                if (filterToSend != pto->m_tx_relay->lastSentFeeFilter) {\n-                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n-                    pto->m_tx_relay->lastSentFeeFilter = filterToSend;\n+                if (filterToSend != node.m_tx_relay->lastSentFeeFilter) {\n+                    m_connman.PushMessage(&node, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n+                    node.m_tx_relay->lastSentFeeFilter = filterToSend;\n                 }\n-                pto->m_tx_relay->nextSendTimeFeeFilter = PoissonNextSend(count_microseconds(current_time), AVG_FEEFILTER_BROADCAST_INTERVAL);\n+                node.m_tx_relay->nextSendTimeFeeFilter = PoissonNextSend(count_microseconds(current_time), AVG_FEEFILTER_BROADCAST_INTERVAL);\n             }\n             // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n             // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n-            else if (count_microseconds(current_time) + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->m_tx_relay->nextSendTimeFeeFilter &&\n-                     (currentFilter < 3 * pto->m_tx_relay->lastSentFeeFilter / 4 || currentFilter > 4 * pto->m_tx_relay->lastSentFeeFilter / 3)) {\n-                pto->m_tx_relay->nextSendTimeFeeFilter = count_microseconds(current_time) + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n+            else if (count_microseconds(current_time) + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < node.m_tx_relay->nextSendTimeFeeFilter &&\n+                     (currentFilter < 3 * node.m_tx_relay->lastSentFeeFilter / 4 || currentFilter > 4 * node.m_tx_relay->lastSentFeeFilter / 3)) {\n+                node.m_tx_relay->nextSendTimeFeeFilter = count_microseconds(current_time) + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n             }\n         }\n     } // release cs_main"
      },
      {
        "sha": "338d4d40141697517ad4bc61909b74a0196e56e6",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -75,7 +75,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     CNode dummyNode1(id++, ServiceFlags(NODE_NETWORK | NODE_WITNESS), INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", ConnectionType::OUTBOUND_FULL_RELAY);\n     dummyNode1.SetCommonVersion(PROTOCOL_VERSION);\n \n-    peerLogic->InitializeNode(&dummyNode1);\n+    peerLogic->InitializeNode(dummyNode1);\n     dummyNode1.fSuccessfullyConnected = true;\n \n     // This test requires that we have a chain with non-zero work.\n@@ -88,7 +88,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     // Test starts here\n     {\n         LOCK(dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode1)); // should result in getheaders\n     }\n     {\n         LOCK(dummyNode1.cs_vSend);\n@@ -101,7 +101,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     SetMockTime(nStartTime+21*60);\n     {\n         LOCK(dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in getheaders\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode1)); // should result in getheaders\n     }\n     {\n         LOCK(dummyNode1.cs_vSend);\n@@ -111,7 +111,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     SetMockTime(nStartTime+24*60);\n     {\n         LOCK(dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1)); // should result in disconnect\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode1)); // should result in disconnect\n     }\n     BOOST_CHECK(dummyNode1.fDisconnect == true);\n     SetMockTime(0);\n@@ -127,7 +127,7 @@ static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerManager &pee\n     CNode &node = *vNodes.back();\n     node.SetCommonVersion(PROTOCOL_VERSION);\n \n-    peerLogic.InitializeNode(&node);\n+    peerLogic.InitializeNode(node);\n     node.fSuccessfullyConnected = true;\n \n     connman->AddNode(node);\n@@ -218,32 +218,32 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode1(id++, NODE_NETWORK, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", ConnectionType::INBOUND);\n     dummyNode1.SetCommonVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode1);\n+    peerLogic->InitializeNode(dummyNode1);\n     dummyNode1.fSuccessfullyConnected = true;\n     peerLogic->Misbehaving(dummyNode1.GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\"); // Should be discouraged\n     {\n         LOCK(dummyNode1.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode1));\n     }\n     BOOST_CHECK(banman->IsDiscouraged(addr1));\n     BOOST_CHECK(!banman->IsDiscouraged(ip(0xa0b0c001|0x0000ff00))); // Different IP, not discouraged\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n     CNode dummyNode2(id++, NODE_NETWORK, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", ConnectionType::INBOUND);\n     dummyNode2.SetCommonVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode2);\n+    peerLogic->InitializeNode(dummyNode2);\n     dummyNode2.fSuccessfullyConnected = true;\n     peerLogic->Misbehaving(dummyNode2.GetId(), DISCOURAGEMENT_THRESHOLD - 1, /* message */ \"\");\n     {\n         LOCK(dummyNode2.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode2));\n     }\n     BOOST_CHECK(!banman->IsDiscouraged(addr2)); // 2 not discouraged yet...\n     BOOST_CHECK(banman->IsDiscouraged(addr1));  // ... but 1 still should be\n     peerLogic->Misbehaving(dummyNode2.GetId(), 1, /* message */ \"\");         // 2 reaches discouragement threshold\n     {\n         LOCK(dummyNode2.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode2));\n     }\n     BOOST_CHECK(banman->IsDiscouraged(addr1));  // Expect both 1 and 2\n     BOOST_CHECK(banman->IsDiscouraged(addr2));  // to be discouraged now\n@@ -268,13 +268,13 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n     CNode dummyNode(id++, NODE_NETWORK, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", ConnectionType::INBOUND);\n     dummyNode.SetCommonVersion(PROTOCOL_VERSION);\n-    peerLogic->InitializeNode(&dummyNode);\n+    peerLogic->InitializeNode(dummyNode);\n     dummyNode.fSuccessfullyConnected = true;\n \n     peerLogic->Misbehaving(dummyNode.GetId(), DISCOURAGEMENT_THRESHOLD, /* message */ \"\");\n     {\n         LOCK(dummyNode.cs_sendProcessing);\n-        BOOST_CHECK(peerLogic->SendMessages(&dummyNode));\n+        BOOST_CHECK(peerLogic->SendMessages(dummyNode));\n     }\n     BOOST_CHECK(banman->IsDiscouraged(addr));\n "
      },
      {
        "sha": "feef16e5dda74a0b39facca6d2dda5fef8c60760",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -83,7 +83,7 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n     const bool successfully_connected{fuzzed_data_provider.ConsumeBool()};\n     p2p_node.fSuccessfullyConnected = successfully_connected;\n     connman.AddTestNode(p2p_node);\n-    g_setup->m_node.peerman->InitializeNode(&p2p_node);\n+    g_setup->m_node.peerman->InitializeNode(p2p_node);\n     FillNode(fuzzed_data_provider, p2p_node, /* init_version */ successfully_connected);\n \n     const auto mock_time = ConsumeTime(fuzzed_data_provider);\n@@ -98,7 +98,7 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n     }\n     {\n         LOCK(p2p_node.cs_sendProcessing);\n-        g_setup->m_node.peerman->SendMessages(&p2p_node);\n+        g_setup->m_node.peerman->SendMessages(p2p_node);\n     }\n     SyncWithValidationInterfaceQueue();\n     LOCK2(::cs_main, g_cs_orphans); // See init.cpp for rationale for implicit locking order requirement"
      },
      {
        "sha": "c79d781e883b604109cf7b9aa9b2db9642be3601",
        "filename": "src/test/fuzz/process_messages.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/fuzz/process_messages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/fuzz/process_messages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_messages.cpp?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -50,7 +50,7 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n         const bool successfully_connected{fuzzed_data_provider.ConsumeBool()};\n         p2p_node.fSuccessfullyConnected = successfully_connected;\n         p2p_node.fPauseSend = false;\n-        g_setup->m_node.peerman->InitializeNode(&p2p_node);\n+        g_setup->m_node.peerman->InitializeNode(p2p_node);\n         FillNode(fuzzed_data_provider, p2p_node, /* init_version */ successfully_connected);\n \n         connman.AddTestNode(p2p_node);\n@@ -77,7 +77,7 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n         }\n         {\n             LOCK(random_node.cs_sendProcessing);\n-            g_setup->m_node.peerman->SendMessages(&random_node);\n+            g_setup->m_node.peerman->SendMessages(random_node);\n         }\n     }\n     SyncWithValidationInterfaceQueue();"
      },
      {
        "sha": "54541e4add3e3f7cb83a77d994242e7fc9612306",
        "filename": "src/test/util/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/util/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bdbc1352475a8dec4187db2ce32795050efca83e/src/test/util/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/net.h?ref=bdbc1352475a8dec4187db2ce32795050efca83e",
        "patch": "@@ -23,7 +23,7 @@ struct ConnmanTestMsg : public CConnman {\n         vNodes.clear();\n     }\n \n-    void ProcessMessagesOnce(CNode& node) { m_msgproc->ProcessMessages(&node, flagInterruptMsgProc); }\n+    void ProcessMessagesOnce(CNode& node) { m_msgproc->ProcessMessages(node, flagInterruptMsgProc); }\n \n     void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n "
      }
    ]
  },
  {
    "sha": "60d865bedafb3f72f8abfc81b1d165aeaa867632",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MGQ4NjViZWRhZmIzZjcyZjhhYmZjODFiMWQxNjVhZWFhODY3NjMy",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-11T01:39:03Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T16:34:33Z"
      },
      "message": "wip update PeerManagerImpl doxygen comments",
      "tree": {
        "sha": "4e55b56979a1474399c4e6855c67aec88009b9e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e55b56979a1474399c4e6855c67aec88009b9e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/60d865bedafb3f72f8abfc81b1d165aeaa867632",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60d865bedafb3f72f8abfc81b1d165aeaa867632",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/60d865bedafb3f72f8abfc81b1d165aeaa867632",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60d865bedafb3f72f8abfc81b1d165aeaa867632/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bdbc1352475a8dec4187db2ce32795050efca83e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bdbc1352475a8dec4187db2ce32795050efca83e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bdbc1352475a8dec4187db2ce32795050efca83e"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 5,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e1cd9333ef231b8bf2d88ca14bada7a93606cdae",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60d865bedafb3f72f8abfc81b1d165aeaa867632/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60d865bedafb3f72f8abfc81b1d165aeaa867632/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=60d865bedafb3f72f8abfc81b1d165aeaa867632",
        "patch": "@@ -523,25 +523,26 @@ class PeerManagerImpl final : public PeerManager\n     std::unique_ptr<CRollingBloomFilter> recentRejects GUARDED_BY(cs_main);\n     uint256 hashRecentRejectsChainTip GUARDED_BY(cs_main);\n \n-    /*\n+    /**\n      * Filter for transactions that have been recently confirmed.\n      * We use this to avoid requesting transactions that have already been\n-     * confirnmed.\n+     * confirmed.\n      */\n     Mutex m_recent_confirmed_transactions_mutex;\n     std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n \n-    /* Returns a bool indicating whether we requested this block.\n+    /** Returns a bool indicating whether we requested this block.\n      * Also used if a block was /not/ received and timed out or started with another peer\n      */\n     bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    /* Mark a block as in flight\n+    /** Mark a block as in flight\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n      * pit will only be valid as long as the same cs_main lock is being held\n      */\n     bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+    /** Determine if tip may be stale based on when last blocks was received */\n     bool TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has"
      }
    ]
  },
  {
    "sha": "3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZjkwYTE4YWQ3MTA4MmJjYjY5ZDBlZjRiZmVkZWViMmRhYWQwNmYz",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T17:20:55Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-02-15T17:20:55Z"
      },
      "message": "net_processing: don't use gArgs directly",
      "tree": {
        "sha": "bca836bf478b86c256c2e20a25810380f58e4091",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bca836bf478b86c256c2e20a25810380f58e4091"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60d865bedafb3f72f8abfc81b1d165aeaa867632",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60d865bedafb3f72f8abfc81b1d165aeaa867632",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60d865bedafb3f72f8abfc81b1d165aeaa867632"
      }
    ],
    "stats": {
      "total": 133,
      "additions": 75,
      "deletions": 58
    },
    "files": [
      {
        "sha": "a68fa9cc7ef824cee193a96293b87e2d6041b73c",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
        "patch": "@@ -1411,7 +1411,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n \n     assert(!node.peerman);\n     node.peerman = PeerManager::make(chainparams, *node.connman, node.banman.get(),\n-                                     *node.scheduler, chainman, *node.mempool, ignores_incoming_txs);\n+                                     *node.scheduler, chainman, *node.mempool, gArgs);\n     RegisterValidationInterface(node.peerman.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "698c676f3b98ef2e494c2563e52324b5ed943dd9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 50,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
        "patch": "@@ -346,7 +346,7 @@ class PeerManagerImpl final : public PeerManager\n public:\n     PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n                     CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                    bool ignore_incoming_txs);\n+                    const ArgsManager& args);\n \n     /** Overridden from CValidationInterface. */\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n@@ -622,9 +622,71 @@ class PeerManagerImpl final : public PeerManager\n     // Fee calculator helpers for SendMessages()\n     FeeFilterRounder m_filter_rounder GUARDED_BY(cs_main) {CFeeRate{DEFAULT_MIN_RELAY_TX_FEE}};\n     const CAmount MAX_FILTER GUARDED_BY(cs_main) {m_filter_rounder.round(MAX_MONEY)};\n+\n+    // Cache command-line/config-file parameters\n+    const size_t m_max_extra_txn;\n+    const unsigned int nMaxOrphanTx;\n+    const bool m_capture_messages;\n+    const bool m_enable_feefilter;\n+    const uint64_t m_maxmempool_bytes;\n };\n } // namespace\n \n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                                               CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                                               const ArgsManager& args)\n+{\n+    return std::make_unique<PeerManagerImpl>(chainparams, connman, banman, scheduler, chainman, pool, args);\n+}\n+\n+template<typename T, typename F>\n+static inline T bounds_check_cast(F v)\n+{\n+    return static_cast<T>(std::clamp(v, static_cast<F>(std::numeric_limits<F>::min()), static_cast<F>(std::numeric_limits<F>::max())));\n+}\n+\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                                 CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                                 const ArgsManager& args)\n+    : m_chainparams(chainparams),\n+      m_connman(connman),\n+      m_banman(banman),\n+      m_chainman(chainman),\n+      m_mempool(pool),\n+      m_stale_tip_check_time(0),\n+      m_ignore_incoming_txs{args.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)},\n+      m_max_extra_txn{bounds_check_cast<unsigned int>(args.GetArg(\"-blockreconstructionextratxn\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN))},\n+      nMaxOrphanTx{bounds_check_cast<unsigned int>(args.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS))},\n+      m_capture_messages{args.GetBoolArg(\"-capturemessages\", false)},\n+      m_enable_feefilter{args.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER)},\n+      m_maxmempool_bytes{bounds_check_cast<uint64_t>(args.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000)}\n+{\n+    // Initialize global variables that cannot be constructed at startup.\n+    recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n+\n+    // Blocks don't typically have more than 4000 transactions, so this should\n+    // be at least six blocks (~1 hr) worth of transactions that we can store,\n+    // inserting both a txid and wtxid for every observed transaction.\n+    // If the number of transactions appearing in a block goes up, or if we are\n+    // seeing getdata requests more than an hour after initial announcement, we\n+    // can increase this number.\n+    // The false positive rate of 1/1M should come out to less than 1\n+    // transaction per day that would be inadvertently ignored (which is the\n+    // same probability that we have in the reject filter).\n+    m_recent_confirmed_transactions.reset(new CRollingBloomFilter(48000, 0.000001));\n+\n+    // Stale tip checking and peer eviction are on two different timers, but we\n+    // don't want them to get out of sync due to drift in the scheduler, so we\n+    // combine them in one function and schedule at the quicker (peer-eviction)\n+    // timer.\n+    static_assert(EXTRA_PEER_CHECK_INTERVAL < STALE_CHECK_INTERVAL, \"peer eviction timer should be less than stale tip check timer\");\n+    scheduler.scheduleEvery([this] { this->CheckForStaleTipAndEvictPeers(); }, std::chrono::seconds{EXTRA_PEER_CHECK_INTERVAL});\n+\n+    // schedule next run for 10-15 minutes in the future\n+    const std::chrono::milliseconds delta = std::chrono::minutes{10} + GetRandMillis(std::chrono::minutes{5});\n+    scheduler.scheduleFromNow([&] { ReattemptInitialBroadcast(scheduler); }, delta);\n+}\n+\n namespace {\n CNodeState *PeerManagerImpl::State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n@@ -1095,7 +1157,7 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n \n void PeerManagerImpl::AddToCompactExtraTransactions(const CTransactionRef& tx)\n {\n-    size_t max_extra_txn = gArgs.GetArg(\"-blockreconstructionextratxn\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN);\n+    size_t max_extra_txn = m_max_extra_txn;\n     if (max_extra_txn <= 0)\n         return;\n     if (!vExtraTxnForCompact.size())\n@@ -1229,50 +1291,6 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                                               CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                                               bool ignore_incoming_txs)\n-{\n-    return std::make_unique<PeerManagerImpl>(chainparams, connman, banman, scheduler, chainman, pool, ignore_incoming_txs);\n-}\n-\n-PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                                 CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                                 bool ignore_incoming_txs)\n-    : m_chainparams(chainparams),\n-      m_connman(connman),\n-      m_banman(banman),\n-      m_chainman(chainman),\n-      m_mempool(pool),\n-      m_stale_tip_check_time(0),\n-      m_ignore_incoming_txs(ignore_incoming_txs)\n-{\n-    // Initialize global variables that cannot be constructed at startup.\n-    recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n-\n-    // Blocks don't typically have more than 4000 transactions, so this should\n-    // be at least six blocks (~1 hr) worth of transactions that we can store,\n-    // inserting both a txid and wtxid for every observed transaction.\n-    // If the number of transactions appearing in a block goes up, or if we are\n-    // seeing getdata requests more than an hour after initial announcement, we\n-    // can increase this number.\n-    // The false positive rate of 1/1M should come out to less than 1\n-    // transaction per day that would be inadvertently ignored (which is the\n-    // same probability that we have in the reject filter).\n-    m_recent_confirmed_transactions.reset(new CRollingBloomFilter(48000, 0.000001));\n-\n-    // Stale tip checking and peer eviction are on two different timers, but we\n-    // don't want them to get out of sync due to drift in the scheduler, so we\n-    // combine them in one function and schedule at the quicker (peer-eviction)\n-    // timer.\n-    static_assert(EXTRA_PEER_CHECK_INTERVAL < STALE_CHECK_INTERVAL, \"peer eviction timer should be less than stale tip check timer\");\n-    scheduler.scheduleEvery([this] { this->CheckForStaleTipAndEvictPeers(); }, std::chrono::seconds{EXTRA_PEER_CHECK_INTERVAL});\n-\n-    // schedule next run for 10-15 minutes in the future\n-    const std::chrono::milliseconds delta = std::chrono::minutes{10} + GetRandMillis(std::chrono::minutes{5});\n-    scheduler.scheduleFromNow([&] { ReattemptInitialBroadcast(scheduler); }, delta);\n-}\n-\n /**\n  * Evict orphan txn pool entries based on a newly connected\n  * block, remember the recently confirmed transactions, and delete tracked\n@@ -3131,7 +3149,6 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n \n                 // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n-                unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n                 unsigned int nEvicted = m_orphanage.LimitOrphans(nMaxOrphanTx);\n                 if (nEvicted > 0) {\n                     LogPrint(BCLog::MEMPOOL, \"orphanage overflow, removed %u tx\\n\", nEvicted);\n@@ -3920,7 +3937,7 @@ bool PeerManagerImpl::ProcessMessages(CNode& node, std::atomic<bool>& interruptM\n     }\n     CNetMessage& msg(msgs.front());\n \n-    if (gArgs.GetBoolArg(\"-capturemessages\", false)) {\n+    if (m_capture_messages) {\n         CaptureMessage(node.addr, msg.m_command, MakeUCharSpan(msg.m_recv), /* incoming */ true);\n     }\n \n@@ -4688,10 +4705,10 @@ bool PeerManagerImpl::SendMessages(CNode& node)\n         //\n         // Message: feefilter\n         //\n-        if (node.m_tx_relay != nullptr && node.GetCommonVersion() >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+        if (node.m_tx_relay != nullptr && node.GetCommonVersion() >= FEEFILTER_VERSION && m_enable_feefilter &&\n             !node.HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n         ) {\n-            CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n+            CAmount currentFilter = m_mempool.GetMinFee(m_maxmempool_bytes).GetFeePerK();\n             AssertLockHeld(cs_main);\n             if (m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                 // Received tx-inv messages are discarded when the active"
      },
      {
        "sha": "750cb599916765d395916d9fbb50bf82d0fa9ea4",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
        "patch": "@@ -10,6 +10,7 @@\n #include <sync.h>\n #include <validationinterface.h>\n \n+class ArgsManager;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n@@ -37,7 +38,7 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n public:\n     static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n                                              CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                                             bool ignore_incoming_txs);\n+                                             const ArgsManager& args);\n     virtual ~PeerManager() { }\n \n     /** Relay transaction to every node */"
      },
      {
        "sha": "2293be6993290aab5287fef4acb297be95e837dd",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
        "patch": "@@ -68,7 +68,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     const CChainParams& chainparams = Params();\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, gArgs);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     const CChainParams& chainparams = Params();\n     auto connman = MakeUnique<CConnmanTest>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, gArgs);\n \n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n     CConnman::Options options;\n@@ -212,7 +212,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, gArgs);\n \n     banman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -259,7 +259,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n     auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                       *m_node.chainman, *m_node.mempool, false);\n+                                       *m_node.chainman, *m_node.mempool, gArgs);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "be0c4b50e701af6af334b454a4ad7ba69c8372d7",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=3f90a18ad71082bcb69d0ef4bfedeeb2daad06f3",
        "patch": "@@ -190,8 +190,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, m_node.banman.get(),\n-                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n-                                       false);\n+                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool, gArgs);\n     {\n         CConnman::Options options;\n         options.m_msgproc = m_node.peerman.get();"
      }
    ]
  }
]