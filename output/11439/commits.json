[
  {
    "sha": "7e0ee167dcba08d55648a501edf85e7d9f7b35d1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZTBlZTE2N2RjYmEwOGQ1NTY0OGE1MDFlZGY4NWU3ZDlmN2IzNWQx",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-02T21:16:15Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2017-10-02T21:32:38Z"
      },
      "message": "[test] Refactor ZMQ test to use one address per notification type\n\nWith this change it is possible to test the notifications independently,\nregardless of the publishing order, since each notification type is published\nto a different address.",
      "tree": {
        "sha": "eada1e09e4b529b3d384d0e9680b9cbd013cdee4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eada1e09e4b529b3d384d0e9680b9cbd013cdee4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e0ee167dcba08d55648a501edf85e7d9f7b35d1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e0ee167dcba08d55648a501edf85e7d9f7b35d1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e0ee167dcba08d55648a501edf85e7d9f7b35d1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e0ee167dcba08d55648a501edf85e7d9f7b35d1/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ddf60db7ad636b6a31b590251c671ded635fa1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ddf60db7ad636b6a31b590251c671ded635fa1d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ddf60db7ad636b6a31b590251c671ded635fa1d"
      }
    ],
    "stats": {
      "total": 132,
      "additions": 54,
      "deletions": 78
    },
    "files": [
      {
        "sha": "22f518d83f81aee7601ce278d0cd9f8df6a5070b",
        "filename": "test/functional/zmq_test.py",
        "status": "modified",
        "additions": 54,
        "deletions": 78,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e0ee167dcba08d55648a501edf85e7d9f7b35d1/test/functional/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e0ee167dcba08d55648a501edf85e7d9f7b35d1/test/functional/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zmq_test.py?ref=7e0ee167dcba08d55648a501edf85e7d9f7b35d1",
        "patch": "@@ -13,14 +13,39 @@\n                                  hash256,\n                                 )\n \n-class ZMQTest (BitcoinTestFramework):\n+class Subscriber():\n+    def __init__(self, socket, address):\n+        self.address = address\n+        self.sequence = 0\n+        self.socket = socket\n+\n+class ZMQTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n+        self.subscribers = {}\n+\n+    def subscribe(self, type):\n+        import zmq\n+        address = \"tcp://127.0.0.1:%d\" % (28332 + len(self.subscribers))\n+        socket = self.zmqContext.socket(zmq.SUB)\n+        socket.set(zmq.RCVTIMEO, 60000)\n+        socket.setsockopt(zmq.SUBSCRIBE, type.encode('latin-1'))\n+        socket.connect(address)\n+        self.subscribers[type] = Subscriber(socket, address)\n+\n+    def receive(self, type):\n+        subscriber = self.subscribers[type]\n+        topic, body, seq = subscriber.socket.recv_multipart()\n+        assert_equal(topic, type.encode('latin-1'))\n+        assert_equal(struct.unpack('<I', seq)[-1], subscriber.sequence)\n+        subscriber.sequence += 1\n+        return body\n \n     def setup_nodes(self):\n         # Try to import python3-zmq. Skip this test if the import fails.\n         try:\n             import zmq\n+            self.zmqContext = zmq.Context()\n         except ImportError:\n             raise SkipTest(\"python3-zmq module not available.\")\n \n@@ -33,17 +58,12 @@ def setup_nodes(self):\n         if not config[\"components\"].getboolean(\"ENABLE_ZMQ\"):\n             raise SkipTest(\"bitcoind has not been built with zmq enabled.\")\n \n-        self.zmqContext = zmq.Context()\n-        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n-        self.zmqSubSocket.set(zmq.RCVTIMEO, 60000)\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashblock\")\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashtx\")\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"rawblock\")\n-        self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"rawtx\")\n-        ip_address = \"tcp://127.0.0.1:28332\"\n-        self.zmqSubSocket.connect(ip_address)\n-        self.extra_args = [['-zmqpubhashblock=%s' % ip_address, '-zmqpubhashtx=%s' % ip_address,\n-                       '-zmqpubrawblock=%s' % ip_address, '-zmqpubrawtx=%s' % ip_address], []]\n+        self.subscribe(\"hashblock\")\n+        self.subscribe(\"hashtx\")\n+        self.subscribe(\"rawblock\")\n+        self.subscribe(\"rawtx\")\n+\n+        self.extra_args = [[\"-zmqpub%s=%s\" % (type, sub.address) for type, sub in self.subscribers.items()], []]\n         self.add_nodes(self.num_nodes, self.extra_args)\n         self.start_nodes()\n \n@@ -60,92 +80,48 @@ def _zmq_test(self):\n         self.sync_all()\n \n         self.log.info(\"Wait for tx\")\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"hashtx\")\n-        txhash = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0)  # must be sequence 0 on hashtx\n-\n-        # rawtx\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"rawtx\")\n-        body = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0) # must be sequence 0 on rawtx\n-\n+        txid = self.receive(\"hashtx\")\n+        hex = self.receive(\"rawtx\")\n         # Check that the rawtx hashes to the hashtx\n-        assert_equal(hash256(body), txhash)\n+        assert_equal(hash256(hex), txid)\n \n         self.log.info(\"Wait for block\")\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"hashblock\")\n-        body = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0)  # must be sequence 0 on hashblock\n-        blkhash = bytes_to_hex_str(body)\n-        assert_equal(genhashes[0], blkhash)  # blockhash from generate must be equal to the hash received over zmq\n-\n-        # rawblock\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"rawblock\")\n-        body = msg[1]\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, 0) #must be sequence 0 on rawblock\n+        # block hash from generate must be equal to the hash received over zmq\n+        hash = bytes_to_hex_str(self.receive(\"hashblock\"))\n+        assert_equal(genhashes[0], hash)\n \n+        block = self.receive(\"rawblock\")\n         # Check the hash of the rawblock's header matches generate\n-        assert_equal(genhashes[0], bytes_to_hex_str(hash256(body[:80])))\n+        assert_equal(genhashes[0], bytes_to_hex_str(hash256(block[:80])))\n \n-        self.log.info(\"Generate 10 blocks (and 10 coinbase txes)\")\n-        n = 10\n+        n = 5\n+        self.log.info(\"Generate %(n)d blocks (and %(n)d coinbase txes)\" % {\"n\": n})\n         genhashes = self.nodes[1].generate(n)\n         self.sync_all()\n \n-        zmqHashes = []\n-        zmqRawHashed = []\n-        blockcount = 0\n-        for x in range(n * 4):\n-            msg = self.zmqSubSocket.recv_multipart()\n-            topic = msg[0]\n-            body = msg[1]\n-            if topic == b\"hashblock\":\n-                zmqHashes.append(bytes_to_hex_str(body))\n-                msgSequence = struct.unpack('<I', msg[-1])[-1]\n-                assert_equal(msgSequence, blockcount + 1)\n-                blockcount += 1\n-            if topic == b\"rawblock\":\n-                zmqRawHashed.append(bytes_to_hex_str(hash256(body[:80])))\n-                msgSequence = struct.unpack('<I', msg[-1])[-1]\n-                assert_equal(msgSequence, blockcount)\n-\n         for x in range(n):\n-            assert_equal(genhashes[x], zmqHashes[x])  # blockhash from generate must be equal to the hash received over zmq\n-            assert_equal(genhashes[x], zmqRawHashed[x])\n+            hash = bytes_to_hex_str(self.receive(\"hashblock\"))\n+            assert_equal(genhashes[x], hash)\n+\n+            block = self.receive(\"rawblock\")\n+            assert_equal(genhashes[x], bytes_to_hex_str(hash256(block[:80])))\n+\n+            txid = self.receive(\"hashtx\")\n+            assert_equal(bytes_to_hex_str(txid), self.nodes[1].getblock(hash)[\"tx\"][0])\n+\n+            self.receive(\"rawtx\")\n \n         self.log.info(\"Wait for tx from second node\")\n         # test tx from a second node\n         hashRPC = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n         self.sync_all()\n \n         # now we should receive a zmq msg because the tx was broadcast\n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"hashtx\")\n-        body = msg[1]\n+        body = self.receive(\"hashtx\")\n         hashZMQ = bytes_to_hex_str(body)\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, blockcount + 1)\n \n-        msg = self.zmqSubSocket.recv_multipart()\n-        topic = msg[0]\n-        assert_equal(topic, b\"rawtx\")\n-        body = msg[1]\n+        body = self.receive(\"rawtx\")\n         hashedZMQ = bytes_to_hex_str(hash256(body))\n-        msgSequence = struct.unpack('<I', msg[-1])[-1]\n-        assert_equal(msgSequence, blockcount+1)\n         assert_equal(hashRPC, hashZMQ)  # txid from sendtoaddress must be equal to the hash received over zmq\n         assert_equal(hashRPC, hashedZMQ)\n "
      }
    ]
  }
]