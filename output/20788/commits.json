[
  {
    "sha": "aa17a44551c03b00a47854438afe9f2f89b6ea74",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYTE3YTQ0NTUxYzAzYjAwYTQ3ODU0NDM4YWZlOWYyZjg5YjZlYTc0",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-01-04T12:14:32Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-10T10:00:12Z"
      },
      "message": "net: move MillisToTimeval() from netbase to util/time\n\nMove `MillisToTimeval()` from `netbase.{h,cpp}` to\n`src/util/system.{h,cpp}`.\n\nThis is necessary in order to use `MillisToTimeval()` from a newly\nintroduced `src/util/sock.{h,cpp}` which cannot depend on netbase\nbecause netbase will depend on it.",
      "tree": {
        "sha": "32818a531a860f31a2ada1ae8fdef4341cc5296f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32818a531a860f31a2ada1ae8fdef4341cc5296f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa17a44551c03b00a47854438afe9f2f89b6ea74",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmAjrqwACgkQVN8G9ktV\ny7+hXiAAjI1eo6ax6Dde8329S1S2oI6W52PWzJ4GVnRhT5jevbCEOF2okY5RroSy\npV7pPHrvBuIVlLsSPD6m3Hpt9dtWlnahsflv+eVM/MB2BiafcZttlwsnpVOM9S4z\nLYihTijQoffVWeJg3bFsueME2bWDDl5dcC2CpRC06LZf2C9rVNSZ4eoClvE/mX5m\nYpq+/tikTCT7WfSmnzNIN2Wj/zQP1mWlF2SKSVup9JI0BC7YuNBvP2k8cnDccoV2\n0RkIjRPecY3TAIUF46KBupnJfsIZSlqP+cLOj/rWhpl3KrHR7IAR6FF+70K5UV4i\nPVrtLJ18vbq9xPWGyiCdsHG+fP1sH4GdhDbCvt/SzWSVem1eHFfrcpZNvO+YN0+r\nwxYhiavvQWMkZ7blXw0unX81R9ObcxYhIJR1tJR6AF2aYDHlLgiqP5Tdmibfz9qe\nJZ44KSAkEsXbG6+FFPVrQ1O/kxm0Zv2N0NsuMXGNTI9cKfETkN0JjlSXRmAUuyZS\nrQyZe4dVtB0YeDvgZRSsWSGtS18VTihaIyJni9tZIGxVplKiW0GkmuUjvRwjIqPk\nVlWIVKi2ycbwc5f62UYFpeO5B1dQU1THjtca97GCwbxVFy4kjYmnEJeXuraeeMk9\nRZBHExCvF2lQZcVr2696Fl6DfTl6b6PfSejj6RJpqXWhO07+F58STZSHSoWAi8P8\nAYDFnd/fhi0UjRzPHcgdEiCoKMF2nQVueV6mfyKfDx95vVl2wSlEy3jrmcM7Lw1Z\n5GNV2PqFcaGeDAD3x+8IrjbwbWh2Kc74TbceUoFIDJujtglfhC3Uv8asUmZTxLs4\nzVEDNUlvj5sT5V0+q/wM+vc0b2lpb9OAgcJcwohXwBUsW+nJGPRdqgA2Jv8I2GVh\njsFv+DZYaDs5KZsmFeuBmqoqWV773s8bKrvOVqg9ZF/GpdchOL3D4NEjCxJc2yTn\ndNfg5+71KHQ92afs0Irh75wo+nj4wdC3Dvja0V+aSFX6+IUQh2ksltzHendpxLk8\netPnSlRwbOAopWgHzf89OgYOs+DtVBIdfqcU4bEAo3I9KJSdFapwHh7nOscYgN4U\n/fkhgck1igbQOBikm7CpSL0Q9x/96YV6DopS7vzDqq3noheDBHWPBvmbWRftriQh\nXOr5ihp+Iyou/hi+58BERAI6d5eiyn1ggze11mG217qJAkJpaKVSFXTaOz5csRgz\n627lSJfCxNBxGviGYFWwE9A3m67CxsWSWCp4BvjUZssgxOnMs4uz4HoJ2uIXd3Et\ndOBnHgVimL/DPrtnTnwy7TlCgyGw0nDkEFjd7CKAcuTPyTcfI3ZSxpXki/HcLNta\nTB1Zz7mZ/49rh5fPDDTp02BhU1oAZw==\n=ZqBu\n-----END PGP SIGNATURE-----",
        "payload": "tree 32818a531a860f31a2ada1ae8fdef4341cc5296f\nparent 29d2aeb4a2b1830be4724aab3a84a62f072056f4\nauthor Vasil Dimov <vd@FreeBSD.org> 1609762472 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1612951212 +0100\n\nnet: move MillisToTimeval() from netbase to util/time\n\nMove `MillisToTimeval()` from `netbase.{h,cpp}` to\n`src/util/system.{h,cpp}`.\n\nThis is necessary in order to use `MillisToTimeval()` from a newly\nintroduced `src/util/sock.{h,cpp}` which cannot depend on netbase\nbecause netbase will depend on it.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa17a44551c03b00a47854438afe9f2f89b6ea74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aa17a44551c03b00a47854438afe9f2f89b6ea74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa17a44551c03b00a47854438afe9f2f89b6ea74/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29d2aeb4a2b1830be4724aab3a84a62f072056f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29d2aeb4a2b1830be4724aab3a84a62f072056f4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29d2aeb4a2b1830be4724aab3a84a62f072056f4"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 18,
      "deletions": 12
    },
    "files": [
      {
        "sha": "93c395b9ec805628b7ecda47db80ddaf33dbc12c",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "patch": "@@ -10,6 +10,7 @@\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/system.h>\n+#include <util/time.h>\n \n #include <atomic>\n #include <cstdint>\n@@ -271,14 +272,6 @@ CService LookupNumeric(const std::string& name, int portDefault)\n     return addr;\n }\n \n-struct timeval MillisToTimeval(int64_t nTimeout)\n-{\n-    struct timeval timeout;\n-    timeout.tv_sec  = nTimeout / 1000;\n-    timeout.tv_usec = (nTimeout % 1000) * 1000;\n-    return timeout;\n-}\n-\n /** SOCKS version */\n enum SOCKSVersion: uint8_t {\n     SOCKS4 = 0x04,"
      },
      {
        "sha": "3dc656d0db7e51c282c00ce8ac207ce4785e03dc",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "patch": "@@ -62,10 +62,6 @@ bool CloseSocket(SOCKET& hSocket);\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n /** Set the TCP_NODELAY flag on a socket */\n bool SetSocketNoDelay(const SOCKET& hSocket);\n-/**\n- * Convert milliseconds to a struct timeval for e.g. select.\n- */\n-struct timeval MillisToTimeval(int64_t nTimeout);\n void InterruptSocks5(bool interrupt);\n \n #endif // BITCOIN_NETBASE_H"
      },
      {
        "sha": "208794a4e5a62ef52d8f0e3a0b43649fbf1e05d0",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "patch": "@@ -14,6 +14,7 @@\n #include <netbase.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n+#include <util/time.h>\n \n #include <vector>\n #include <deque>"
      },
      {
        "sha": "4da041e5a56d62867a1dd87ac194e5db3d2b36f0",
        "filename": "src/util/time.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/util/time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/util/time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.cpp?ref=aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "patch": "@@ -7,6 +7,7 @@\n #include <config/bitcoin-config.h>\n #endif\n \n+#include <compat.h>\n #include <util/time.h>\n \n #include <atomic>\n@@ -114,3 +115,11 @@ int64_t ParseISO8601DateTime(const std::string& str)\n         return 0;\n     return (ptime - epoch).total_seconds();\n }\n+\n+struct timeval MillisToTimeval(int64_t nTimeout)\n+{\n+    struct timeval timeout;\n+    timeout.tv_sec  = nTimeout / 1000;\n+    timeout.tv_usec = (nTimeout % 1000) * 1000;\n+    return timeout;\n+}"
      },
      {
        "sha": "2c0e3d83f6bc0a8491c1697e7c28c108b21950ca",
        "filename": "src/util/time.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/util/time.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa17a44551c03b00a47854438afe9f2f89b6ea74/src/util/time.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.h?ref=aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_UTIL_TIME_H\n #define BITCOIN_UTIL_TIME_H\n \n+#include <compat.h>\n+\n #include <chrono>\n #include <stdint.h>\n #include <string>\n@@ -57,4 +59,9 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n int64_t ParseISO8601DateTime(const std::string& str);\n \n+/**\n+ * Convert milliseconds to a struct timeval for e.g. select.\n+ */\n+struct timeval MillisToTimeval(int64_t nTimeout);\n+\n #endif // BITCOIN_UTIL_TIME_H"
      }
    ]
  },
  {
    "sha": "dec9b5e850c6aad989e814aea5b630b36f55d580",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZWM5YjVlODUwYzZhYWQ5ODllODE0YWVhNWI2MzBiMzZmNTVkNTgw",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-01-04T12:02:43Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-10T12:30:08Z"
      },
      "message": "net: move CloseSocket() from netbase to util/sock\n\nMove `CloseSocket()` (and `NetworkErrorString()` which it uses) from\n`netbase.{h,cpp}` to newly added `src/util/sock.{h,cpp}`.\n\nThis is necessary in order to use `CloseSocket()` from a newly\nintroduced Sock class (which will live in `src/util/sock.{h,cpp}`).\n`sock.{h,cpp}` cannot depend on netbase because netbase will depend\non it.",
      "tree": {
        "sha": "993908d7a5dfdeb82f365bee1e19084eebd29d31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/993908d7a5dfdeb82f365bee1e19084eebd29d31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dec9b5e850c6aad989e814aea5b630b36f55d580",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmAj0dAACgkQVN8G9ktV\ny7/hfR//YFulBovNjPnZ/fTpubTHRnyx+wFLIx9+kafz+mtS4yI/kb3CpuvVcQgG\nqRMhiyF/eIV5XhZGjZ5uEG70VRZlWNyoMyw5FORLwTF+ngbHTqT0Zb8VHT0S2SYb\nfNZ+Hkwz2HkkiiKdD9EGuhEMgrxOI2xahlZDzo15kmz+Aq314OIOjb4W74y9hJ80\nFZoqvbpSspi+JC9glubW5aRXKvimy/Jug6/6w8C2d371V02iUQD2WKL3PXohwocS\naOux6239IUG4AfvsiF19nv9TwJm7dXvzqhbCJFYKDbVHLv9aKNUC8Tx4ADyGI3yp\nVYwYnM0NQqJWuY5thn3W24ro3WFuBoufiUAN06/4T+R/ellwn9BqZc8Mz6wpSAXI\nvNtCSal6yQSEExjsCWxVlUusYc78hz1J9xNFxi4koQOifZJFeefyS0XxIXSDA5f4\nqP9PQwZpeyoRelnTb/5+nMe/1wRBkj4qHDdOEfqxOAyUsmvbUOFFfuh4zu/VR1Yi\nt+LMsvhRmPLNNeV7FAkw5zHqx01F/ihbUc1oEZml3JYCPICZsxU265a8/UeBZqhR\nmDqjIW+NV0dz8GZDfkl3OxycJZdFgEXe0u3C72OIcPEbpX16Bg5t8IMFLcUI3c/9\ngGO2zpa8jlqqGQ0LhUO63g9JoqVRVk1ASUOOTdvmI8nrtPAvHoCuAX5VEdoRJWm6\n73VZBL/uU31sQXk/uZiJHBcYRFtG69ISjqoROTfeVKCLGN5E9NeKDJQk7t3IDsMz\n2EsDRBndiBLGCS3pUNAfyHWJSc5EtN7rP+NIWBYI3fR4Mvk5ykX7Now0w34awRfd\nm2pEZSlg0UJ89sBS1JI1zc7X+EXA7DEJImnA8TxVozd96QDT1KTXxtrQY7t2EU1r\n5CFLQIPDrSTOkYWU8KBZBD3Yd5Ieh7qEBa7hf28HxgSZZzbqp51qVzRkEJcr29BT\nOFuPMC8vy5keBEVw/uXww2dSyCZbBE2brWdbvbk4OBrotySU98Ecp4gN5hsNGbDc\nUkUOHN9HTm3zCOLtIO6WIDROh2AW5jj70L8ivI/4t6g67tkYSK5Fd/I1V7cFdUgG\nB6iTIux/3sMCNGT3pOu46T4CzVEC6yqetGut6Tm7oz1QUCOoAjkPNMMdjIUMP/4P\nw8/shAt/MgPwYRWksyNzzV66sxGNYuMuH/h1FTZrGAUwwcGor+6LF568wxiWMsUm\nPfFzZp45fzrj18f1QppYXnK6rDJmQ/XOT+gwFpZ3CVD5aEu+eLCTjnd8TMa1/ZOR\nZ5jGztMKNEibS11Y7RgivVi53Sa1zimNVdaAPs3hCh7kb03dhyLh7fzStvRac8kD\nlVq9lYS4svlkFk5K7naTe5BIJeh/mg==\n=xeXL\n-----END PGP SIGNATURE-----",
        "payload": "tree 993908d7a5dfdeb82f365bee1e19084eebd29d31\nparent aa17a44551c03b00a47854438afe9f2f89b6ea74\nauthor Vasil Dimov <vd@FreeBSD.org> 1609761763 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1612960208 +0100\n\nnet: move CloseSocket() from netbase to util/sock\n\nMove `CloseSocket()` (and `NetworkErrorString()` which it uses) from\n`netbase.{h,cpp}` to newly added `src/util/sock.{h,cpp}`.\n\nThis is necessary in order to use `CloseSocket()` from a newly\nintroduced Sock class (which will live in `src/util/sock.{h,cpp}`).\n`sock.{h,cpp}` cannot depend on netbase because netbase will depend\non it.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dec9b5e850c6aad989e814aea5b630b36f55d580",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dec9b5e850c6aad989e814aea5b630b36f55d580",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dec9b5e850c6aad989e814aea5b630b36f55d580/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa17a44551c03b00a47854438afe9f2f89b6ea74",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aa17a44551c03b00a47854438afe9f2f89b6ea74"
      }
    ],
    "stats": {
      "total": 141,
      "additions": 86,
      "deletions": 55
    },
    "files": [
      {
        "sha": "2e35ecdfbda8675340313846f25ecbdada178af1",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dec9b5e850c6aad989e814aea5b630b36f55d580/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dec9b5e850c6aad989e814aea5b630b36f55d580/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=dec9b5e850c6aad989e814aea5b630b36f55d580",
        "patch": "@@ -238,6 +238,7 @@ BITCOIN_CORE_H = \\\n   util/rbf.h \\\n   util/ref.h \\\n   util/settings.h \\\n+  util/sock.h \\\n   util/spanparsing.h \\\n   util/string.h \\\n   util/system.h \\\n@@ -552,6 +553,7 @@ libbitcoin_util_a_SOURCES = \\\n   util/error.cpp \\\n   util/fees.cpp \\\n   util/hasher.cpp \\\n+  util/sock.cpp \\\n   util/system.cpp \\\n   util/message.cpp \\\n   util/moneystr.cpp \\"
      },
      {
        "sha": "38aaeff121ca74e1848c1901768f1fb670fb5a36",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dec9b5e850c6aad989e814aea5b630b36f55d580/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dec9b5e850c6aad989e814aea5b630b36f55d580/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=dec9b5e850c6aad989e814aea5b630b36f55d580",
        "patch": "@@ -20,6 +20,7 @@\n #include <protocol.h>\n #include <random.h>\n #include <scheduler.h>\n+#include <util/sock.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n "
      },
      {
        "sha": "3a3407f901b09d8d9b29af87d1ace0fa79098894",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 51,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dec9b5e850c6aad989e814aea5b630b36f55d580/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dec9b5e850c6aad989e814aea5b630b36f55d580/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=dec9b5e850c6aad989e814aea5b630b36f55d580",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <sync.h>\n #include <tinyformat.h>\n+#include <util/sock.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/system.h>\n@@ -862,57 +863,6 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n     return false;\n }\n \n-#ifdef WIN32\n-std::string NetworkErrorString(int err)\n-{\n-    wchar_t buf[256];\n-    buf[0] = 0;\n-    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n-            nullptr, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-            buf, ARRAYSIZE(buf), nullptr))\n-    {\n-        return strprintf(\"%s (%d)\", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);\n-    }\n-    else\n-    {\n-        return strprintf(\"Unknown error (%d)\", err);\n-    }\n-}\n-#else\n-std::string NetworkErrorString(int err)\n-{\n-    char buf[256];\n-    buf[0] = 0;\n-    /* Too bad there are two incompatible implementations of the\n-     * thread-safe strerror. */\n-    const char *s;\n-#ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n-    s = strerror_r(err, buf, sizeof(buf));\n-#else /* POSIX variant always returns message in buffer */\n-    s = buf;\n-    if (strerror_r(err, buf, sizeof(buf)))\n-        buf[0] = 0;\n-#endif\n-    return strprintf(\"%s (%d)\", s, err);\n-}\n-#endif\n-\n-bool CloseSocket(SOCKET& hSocket)\n-{\n-    if (hSocket == INVALID_SOCKET)\n-        return false;\n-#ifdef WIN32\n-    int ret = closesocket(hSocket);\n-#else\n-    int ret = close(hSocket);\n-#endif\n-    if (ret) {\n-        LogPrintf(\"Socket close failed: %d. Error: %s\\n\", hSocket, NetworkErrorString(WSAGetLastError()));\n-    }\n-    hSocket = INVALID_SOCKET;\n-    return ret != SOCKET_ERROR;\n-}\n-\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking)\n {\n     if (fNonBlocking) {"
      },
      {
        "sha": "38d33e475bd649cae4238888176d5ce3e28e57ee",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dec9b5e850c6aad989e814aea5b630b36f55d580/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dec9b5e850c6aad989e814aea5b630b36f55d580/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=dec9b5e850c6aad989e814aea5b630b36f55d580",
        "patch": "@@ -54,10 +54,6 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet);\n SOCKET CreateSocket(const CService &addrConnect);\n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocketRet, int nTimeout, bool& outProxyConnectionFailed);\n-/** Return readable error string for a network error code */\n-std::string NetworkErrorString(int err);\n-/** Close socket and set hSocket to INVALID_SOCKET */\n-bool CloseSocket(SOCKET& hSocket);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n /** Set the TCP_NODELAY flag on a socket */"
      },
      {
        "sha": "35eca4afb17fe5dd720f234a431d63c6c4b398f3",
        "filename": "src/util/sock.cpp",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dec9b5e850c6aad989e814aea5b630b36f55d580/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dec9b5e850c6aad989e814aea5b630b36f55d580/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=dec9b5e850c6aad989e814aea5b630b36f55d580",
        "patch": "@@ -0,0 +1,64 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compat.h>\n+#include <logging.h>\n+#include <tinyformat.h>\n+#include <util/sock.h>\n+\n+#include <codecvt>\n+#include <cwchar>\n+#include <locale>\n+#include <string>\n+\n+#ifdef WIN32\n+std::string NetworkErrorString(int err)\n+{\n+    wchar_t buf[256];\n+    buf[0] = 0;\n+    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n+            nullptr, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+            buf, ARRAYSIZE(buf), nullptr))\n+    {\n+        return strprintf(\"%s (%d)\", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);\n+    }\n+    else\n+    {\n+        return strprintf(\"Unknown error (%d)\", err);\n+    }\n+}\n+#else\n+std::string NetworkErrorString(int err)\n+{\n+    char buf[256];\n+    buf[0] = 0;\n+    /* Too bad there are two incompatible implementations of the\n+     * thread-safe strerror. */\n+    const char *s;\n+#ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n+    s = strerror_r(err, buf, sizeof(buf));\n+#else /* POSIX variant always returns message in buffer */\n+    s = buf;\n+    if (strerror_r(err, buf, sizeof(buf)))\n+        buf[0] = 0;\n+#endif\n+    return strprintf(\"%s (%d)\", s, err);\n+}\n+#endif\n+\n+bool CloseSocket(SOCKET& hSocket)\n+{\n+    if (hSocket == INVALID_SOCKET)\n+        return false;\n+#ifdef WIN32\n+    int ret = closesocket(hSocket);\n+#else\n+    int ret = close(hSocket);\n+#endif\n+    if (ret) {\n+        LogPrintf(\"Socket close failed: %d. Error: %s\\n\", hSocket, NetworkErrorString(WSAGetLastError()));\n+    }\n+    hSocket = INVALID_SOCKET;\n+    return ret != SOCKET_ERROR;\n+}"
      },
      {
        "sha": "0d48235043f6b19e6388facce47586ad52d109a8",
        "filename": "src/util/sock.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dec9b5e850c6aad989e814aea5b630b36f55d580/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dec9b5e850c6aad989e814aea5b630b36f55d580/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=dec9b5e850c6aad989e814aea5b630b36f55d580",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_SOCK_H\n+#define BITCOIN_UTIL_SOCK_H\n+\n+#include <compat.h>\n+\n+#include <string>\n+\n+/** Return readable error string for a network error code */\n+std::string NetworkErrorString(int err);\n+\n+/** Close socket and set hSocket to INVALID_SOCKET */\n+bool CloseSocket(SOCKET& hSocket);\n+\n+#endif // BITCOIN_UTIL_SOCK_H"
      }
    ]
  },
  {
    "sha": "ba9d73268f9585d4b9254adcf54708f88222798b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYTlkNzMyNjhmOTU4NWQ0YjkyNTRhZGNmNTQ3MDhmODgyMjI3OThi",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-12-23T15:40:11Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-10T12:30:08Z"
      },
      "message": "net: add RAII socket and use it instead of bare SOCKET\n\nIntroduce a class to manage the lifetime of a socket - when the object\nthat contains the socket goes out of scope, the underlying socket will\nbe closed.\n\nIn addition, the new `Sock` class has a `Send()`, `Recv()` and `Wait()`\nmethods that can be overridden by unit tests to mock the socket\noperations.\n\nThe `Wait()` method also hides the\n`#ifdef USE_POLL poll() #else select() #endif` technique from higher\nlevel code.",
      "tree": {
        "sha": "7817023a5deab6c4bcb0de90b748e49dc026f1ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7817023a5deab6c4bcb0de90b748e49dc026f1ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba9d73268f9585d4b9254adcf54708f88222798b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmAj0dAACgkQVN8G9ktV\ny7/UjR//Zh2EpQ2kluxW98HyaiatH9lIUhopPymbGXyM5RCvPDbASRmUcwUVociO\nmGkdmq1EsIlBVhZOfwJB6UuaZWui7NboQHSn7B9pqD3FdVseye9PNP3gjzpre9PM\n1171XX6wieZcDAbxYDNVHfkZsupV+bTBvYnt63sLVYsfD+Jo7IvwvriZqeaVZ27/\nIVz7/yzRrjvR/CIL+SNeN7owsMyuInavOSqZpAdQf7POPm9CXVlhMmNMTAd3o/GM\nqwGprFFyfV1MdSGqIoKs5gnFBEs73DUqzAXRcJXDy1rca9jeOt/wCSg0C4i1HZk7\nWvY9nLlKQpCpoOrE9PP79Lp0sMtWC4xDx2S3ONitl53zbqrjNlrrEygyaZhsP2Vg\njjzEM6jmZBDOZMpL9m5ubIYjmgc7qhxJIRHXlIemOZQEspBBkk9ZEba8++AnBXDw\nJ5yT+LP2vPt9MEBQnJADwUFjchaGnMhpzd0WY6BHWhW+5TAfpJmtfp7fUPzSxtSv\n/nWkYUgn1bg4ili2wGy6Y4YjIbOPdYKDFuGTH8h8bTDF8X22fPv6vqpNpEGjiW7S\nMHYaGAotXQURaBwlEBehrZSub1razS9NNv8FHug0GqdN6nyg4ukodgMNZS5l1a+/\n5rfCwef/cjhLek/h1Arc5NKXUTOIx6dL7zA9qWEiwrtYlj5q0iAbUzPHLccY2Isw\n13QFYC/lrn0cHVpuXe3tVcsc8h2PUc8aU1R2dCN/ryhkCT5tO5yComlOBXJsqfhY\nh5IjGQ4ZYyaN0r99s7ETCCW2L91CCBShqfnvegEJufcFmawX5KtqBSLYNvzCDzYv\nlAiE2tSHOWTo+EG7WVGP3NE2clQiXwz8vXZOw1U/YzVC7UMpd5b4t99fVu0Uajxj\nrmpC6Ii9+gSsCoiKeq+MsRhDXq8c1fUW2287wcz9+91602xOsD8l9ELLlRTd13PV\nUM/+31PQcOgBlOpx9kTY+5Qkc1KGWWALPvrYkA4WyQldKhRDongrGRE0Lrkp157Q\n7T55bncbMXaWsQRuYJrpc+/ebagUK/EJJKOq6AX9ZT3pi5+k0pqDulttqu0TF5xs\nO8QI5re5EyB1vToSdwt0yxyYf2kmRp2u39qKWP2XCJjY20QhcN3smdrNt3NdbirT\nKTJPp4BL7ecF4C3H15RhjrZG6P6FZ9YaEQZ1CH1tIiu3e4W3iUFDZrXTXFRI/Ifn\nbJ674fyJ0vbhkxh8AG7fkcE3ZCLhH8L4M3XrpxJyuo4BVoysP0OP/nZ7mwvjR933\n5yHHHYJv85caDEs0vEYdn8LVFVBX73GtNTGDN7uPzcLg7sbPv/QZyu63+YDEdgg8\nDLRfBRP1OkZk+lTHpdyd5q7jE3wtpQ==\n=eyRd\n-----END PGP SIGNATURE-----",
        "payload": "tree 7817023a5deab6c4bcb0de90b748e49dc026f1ab\nparent dec9b5e850c6aad989e814aea5b630b36f55d580\nauthor Vasil Dimov <vd@FreeBSD.org> 1608738011 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1612960208 +0100\n\nnet: add RAII socket and use it instead of bare SOCKET\n\nIntroduce a class to manage the lifetime of a socket - when the object\nthat contains the socket goes out of scope, the underlying socket will\nbe closed.\n\nIn addition, the new `Sock` class has a `Send()`, `Recv()` and `Wait()`\nmethods that can be overridden by unit tests to mock the socket\noperations.\n\nThe `Wait()` method also hides the\n`#ifdef USE_POLL poll() #else select() #endif` technique from higher\nlevel code.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba9d73268f9585d4b9254adcf54708f88222798b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ba9d73268f9585d4b9254adcf54708f88222798b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba9d73268f9585d4b9254adcf54708f88222798b/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dec9b5e850c6aad989e814aea5b630b36f55d580",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dec9b5e850c6aad989e814aea5b630b36f55d580",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dec9b5e850c6aad989e814aea5b630b36f55d580"
      }
    ],
    "stats": {
      "total": 291,
      "additions": 250,
      "deletions": 41
    },
    "files": [
      {
        "sha": "2a3669b90e885fd2f4c0f96972bce3571e3cda51",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 24,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -429,51 +429,53 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n \n     // Connect\n     bool connected = false;\n-    SOCKET hSocket = INVALID_SOCKET;\n+    std::unique_ptr<Sock> sock;\n     proxyType proxy;\n     if (addrConnect.IsValid()) {\n         bool proxyConnectionFailed = false;\n \n         if (GetProxy(addrConnect.GetNetwork(), proxy)) {\n-            hSocket = CreateSocket(proxy.proxy);\n-            if (hSocket == INVALID_SOCKET) {\n+            sock = CreateSock(proxy.proxy);\n+            if (!sock) {\n                 return nullptr;\n             }\n-            connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(), hSocket, nConnectTimeout, proxyConnectionFailed);\n+            connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(),\n+                                            sock->Get(), nConnectTimeout, proxyConnectionFailed);\n         } else {\n             // no proxy needed (none set for target network)\n-            hSocket = CreateSocket(addrConnect);\n-            if (hSocket == INVALID_SOCKET) {\n+            sock = CreateSock(addrConnect);\n+            if (!sock) {\n                 return nullptr;\n             }\n-            connected = ConnectSocketDirectly(addrConnect, hSocket, nConnectTimeout, conn_type == ConnectionType::MANUAL);\n+            connected = ConnectSocketDirectly(addrConnect, sock->Get(), nConnectTimeout,\n+                                              conn_type == ConnectionType::MANUAL);\n         }\n         if (!proxyConnectionFailed) {\n             // If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to\n             // the proxy, mark this as an attempt.\n             addrman.Attempt(addrConnect, fCountFailure);\n         }\n     } else if (pszDest && GetNameProxy(proxy)) {\n-        hSocket = CreateSocket(proxy.proxy);\n-        if (hSocket == INVALID_SOCKET) {\n+        sock = CreateSock(proxy.proxy);\n+        if (!sock) {\n             return nullptr;\n         }\n         std::string host;\n         int port = default_port;\n         SplitHostPort(std::string(pszDest), port, host);\n         bool proxyConnectionFailed;\n-        connected = ConnectThroughProxy(proxy, host, port, hSocket, nConnectTimeout, proxyConnectionFailed);\n+        connected = ConnectThroughProxy(proxy, host, port, sock->Get(), nConnectTimeout,\n+                                        proxyConnectionFailed);\n     }\n     if (!connected) {\n-        CloseSocket(hSocket);\n         return nullptr;\n     }\n \n     // Add node\n     NodeId id = GetNewNodeId();\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-    CAddress addr_bind = GetBindAddress(hSocket);\n-    CNode* pnode = new CNode(id, nLocalServices, hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type);\n+    CAddress addr_bind = GetBindAddress(sock->Get());\n+    CNode* pnode = new CNode(id, nLocalServices, sock->Release(), addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type);\n     pnode->AddRef();\n \n     // We're making a new connection, harvest entropy from the time (and our peer count)\n@@ -2177,53 +2179,50 @@ bool CConnman::BindListenPort(const CService& addrBind, bilingual_str& strError,\n         return false;\n     }\n \n-    SOCKET hListenSocket = CreateSocket(addrBind);\n-    if (hListenSocket == INVALID_SOCKET)\n-    {\n+    std::unique_ptr<Sock> sock = CreateSock(addrBind);\n+    if (!sock) {\n         strError = strprintf(Untranslated(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError.original);\n         return false;\n     }\n \n     // Allow binding if the port is still in TIME_WAIT state after\n     // the program was closed and restarted.\n-    setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int));\n+    setsockopt(sock->Get(), SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int));\n \n     // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n     // and enable it by default or not. Try to enable it, if possible.\n     if (addrBind.IsIPv6()) {\n #ifdef IPV6_V6ONLY\n-        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int));\n+        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int));\n #endif\n #ifdef WIN32\n         int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n-        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));\n+        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));\n #endif\n     }\n \n-    if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n+    if (::bind(sock->Get(), (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n             strError = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"), addrBind.ToString(), PACKAGE_NAME);\n         else\n             strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));\n         LogPrintf(\"%s\\n\", strError.original);\n-        CloseSocket(hListenSocket);\n         return false;\n     }\n     LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n \n     // Listen for incoming connections\n-    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n+    if (listen(sock->Get(), SOMAXCONN) == SOCKET_ERROR)\n     {\n         strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError.original);\n-        CloseSocket(hListenSocket);\n         return false;\n     }\n \n-    vhListenSocket.push_back(ListenSocket(hListenSocket, permissions));\n+    vhListenSocket.push_back(ListenSocket(sock->Release(), permissions));\n     return true;\n }\n "
      },
      {
        "sha": "93a04ab5b4a5eabece86591260c9e91d37f9039c",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 16,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -15,7 +15,9 @@\n \n #include <atomic>\n #include <cstdint>\n+#include <functional>\n #include <limits>\n+#include <memory>\n \n #ifndef WIN32\n #include <fcntl.h>\n@@ -559,34 +561,28 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n     return true;\n }\n \n-/**\n- * Try to create a socket file descriptor with specific properties in the\n- * communications domain (address family) of the specified service.\n- *\n- * For details on the desired properties, see the inline comments in the source\n- * code.\n- */\n-SOCKET CreateSocket(const CService &addrConnect)\n+std::unique_ptr<Sock> CreateSockTCP(const CService& address_family)\n {\n     // Create a sockaddr from the specified service.\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n-        LogPrintf(\"Cannot create socket for %s: unsupported network\\n\", addrConnect.ToString());\n-        return INVALID_SOCKET;\n+    if (!address_family.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n+        LogPrintf(\"Cannot create socket for %s: unsupported network\\n\", address_family.ToString());\n+        return nullptr;\n     }\n \n     // Create a TCP socket in the address family of the specified service.\n     SOCKET hSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n-    if (hSocket == INVALID_SOCKET)\n-        return INVALID_SOCKET;\n+    if (hSocket == INVALID_SOCKET) {\n+        return nullptr;\n+    }\n \n     // Ensure that waiting for I/O on this socket won't result in undefined\n     // behavior.\n     if (!IsSelectableSocket(hSocket)) {\n         CloseSocket(hSocket);\n         LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-        return INVALID_SOCKET;\n+        return nullptr;\n     }\n \n #ifdef SO_NOSIGPIPE\n@@ -602,11 +598,14 @@ SOCKET CreateSocket(const CService &addrConnect)\n     // Set the non-blocking option on the socket.\n     if (!SetSocketNonBlocking(hSocket, true)) {\n         CloseSocket(hSocket);\n-        LogPrintf(\"CreateSocket: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        LogPrintf(\"Error setting socket to non-blocking: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return nullptr;\n     }\n-    return hSocket;\n+    return std::make_unique<Sock>(hSocket);\n }\n \n+std::function<std::unique_ptr<Sock>(const CService&)> CreateSock = CreateSockTCP;\n+\n template<typename... Args>\n static void LogConnectFailure(bool manual_connection, const char* fmt, const Args&... args) {\n     std::string error_message = tfm::format(fmt, args...);"
      },
      {
        "sha": "d9068882354d89f063425a13667f27b389a92211",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -12,7 +12,10 @@\n #include <compat.h>\n #include <netaddress.h>\n #include <serialize.h>\n+#include <util/sock.h>\n \n+#include <functional>\n+#include <memory>\n #include <stdint.h>\n #include <string>\n #include <vector>\n@@ -51,7 +54,19 @@ bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllo\n bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n CService LookupNumeric(const std::string& name, int portDefault = 0);\n bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet);\n-SOCKET CreateSocket(const CService &addrConnect);\n+\n+/**\n+ * Create a TCP socket in the given address family.\n+ * @param[in] address_family The socket is created in the same address family as this address.\n+ * @return pointer to the created Sock object or unique_ptr that owns nothing in case of failure\n+ */\n+std::unique_ptr<Sock> CreateSockTCP(const CService& address_family);\n+\n+/**\n+ * Socket factory. Defaults to `CreateSockTCP()`, but can be overridden by unit tests.\n+ */\n+extern std::function<std::unique_ptr<Sock>(const CService&)> CreateSock;\n+\n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocketRet, int nTimeout, bool& outProxyConnectionFailed);\n /** Disable or enable blocking-mode for a socket */"
      },
      {
        "sha": "4c65b5b68094664a7ceb9d40efa1b2307ad5545f",
        "filename": "src/util/sock.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -6,12 +6,97 @@\n #include <logging.h>\n #include <tinyformat.h>\n #include <util/sock.h>\n+#include <util/system.h>\n+#include <util/time.h>\n \n #include <codecvt>\n #include <cwchar>\n #include <locale>\n #include <string>\n \n+#ifdef USE_POLL\n+#include <poll.h>\n+#endif\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+ssize_t Sock::Send(const void* data, size_t len, int flags) const\n+{\n+    return send(m_socket, static_cast<const char*>(data), len, flags);\n+}\n+\n+ssize_t Sock::Recv(void* buf, size_t len, int flags) const\n+{\n+    return recv(m_socket, static_cast<char*>(buf), len, flags);\n+}\n+\n+bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n+{\n+#ifdef USE_POLL\n+    pollfd fd;\n+    fd.fd = m_socket;\n+    fd.events = 0;\n+    if (requested & RECV) {\n+        fd.events |= POLLIN;\n+    }\n+    if (requested & SEND) {\n+        fd.events |= POLLOUT;\n+    }\n+\n+    return poll(&fd, 1, count_milliseconds(timeout)) != SOCKET_ERROR;\n+#else\n+    if (!IsSelectableSocket(m_socket)) {\n+        return false;\n+    }\n+\n+    fd_set fdset_recv;\n+    fd_set fdset_send;\n+    FD_ZERO(&fdset_recv);\n+    FD_ZERO(&fdset_send);\n+\n+    if (requested & RECV) {\n+        FD_SET(m_socket, &fdset_recv);\n+    }\n+\n+    if (requested & SEND) {\n+        FD_SET(m_socket, &fdset_send);\n+    }\n+\n+    timeval timeout_struct = MillisToTimeval(timeout);\n+\n+    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+#endif /* USE_POLL */\n+}\n+\n #ifdef WIN32\n std::string NetworkErrorString(int err)\n {"
      },
      {
        "sha": "26fe60f18f76094cb5a89f77d0a3503276ac40ce",
        "filename": "src/util/sock.h",
        "status": "modified",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -7,8 +7,108 @@\n \n #include <compat.h>\n \n+#include <chrono>\n #include <string>\n \n+/**\n+ * RAII helper class that manages a socket. Mimics `std::unique_ptr`, but instead of a pointer it\n+ * contains a socket and closes it automatically when it goes out of scope.\n+ */\n+class Sock\n+{\n+public:\n+    /**\n+     * Default constructor, creates an empty object that does nothing when destroyed.\n+     */\n+    Sock();\n+\n+    /**\n+     * Take ownership of an existent socket.\n+     */\n+    explicit Sock(SOCKET s);\n+\n+    /**\n+     * Copy constructor, disabled because closing the same socket twice is undesirable.\n+     */\n+    Sock(const Sock&) = delete;\n+\n+    /**\n+     * Move constructor, grab the socket from another object and close ours (if set).\n+     */\n+    Sock(Sock&& other);\n+\n+    /**\n+     * Destructor, close the socket or do nothing if empty.\n+     */\n+    virtual ~Sock();\n+\n+    /**\n+     * Copy assignment operator, disabled because closing the same socket twice is undesirable.\n+     */\n+    Sock& operator=(const Sock&) = delete;\n+\n+    /**\n+     * Move assignment operator, grab the socket from another object and close ours (if set).\n+     */\n+    virtual Sock& operator=(Sock&& other);\n+\n+    /**\n+     * Get the value of the contained socket.\n+     * @return socket or INVALID_SOCKET if empty\n+     */\n+    virtual SOCKET Get() const;\n+\n+    /**\n+     * Get the value of the contained socket and drop ownership. It will not be closed by the\n+     * destructor after this call.\n+     * @return socket or INVALID_SOCKET if empty\n+     */\n+    virtual SOCKET Release();\n+\n+    /**\n+     * Close if non-empty.\n+     */\n+    virtual void Reset();\n+\n+    /**\n+     * send(2) wrapper. Equivalent to `send(this->Get(), data, len, flags);`. Code that uses this\n+     * wrapper can be unit-tested if this method is overridden by a mock Sock implementation.\n+     */\n+    virtual ssize_t Send(const void* data, size_t len, int flags) const;\n+\n+    /**\n+     * recv(2) wrapper. Equivalent to `recv(this->Get(), buf, len, flags);`. Code that uses this\n+     * wrapper can be unit-tested if this method is overridden by a mock Sock implementation.\n+     */\n+    virtual ssize_t Recv(void* buf, size_t len, int flags) const;\n+\n+    using Event = uint8_t;\n+\n+    /**\n+     * If passed to `Wait()`, then it will wait for readiness to read from the socket.\n+     */\n+    static constexpr Event RECV = 0b01;\n+\n+    /**\n+     * If passed to `Wait()`, then it will wait for readiness to send to the socket.\n+     */\n+    static constexpr Event SEND = 0b10;\n+\n+    /**\n+     * Wait for readiness for input (recv) or output (send).\n+     * @param[in] timeout Wait this much for at least one of the requested events to occur.\n+     * @param[in] requested Wait for those events, bitwise-or of `RECV` and `SEND`.\n+     * @return true on success and false otherwise\n+     */\n+    virtual bool Wait(std::chrono::milliseconds timeout, Event requested) const;\n+\n+private:\n+    /**\n+     * Contained socket. `INVALID_SOCKET` designates the object is empty.\n+     */\n+    SOCKET m_socket;\n+};\n+\n /** Return readable error string for a network error code */\n std::string NetworkErrorString(int err);\n "
      },
      {
        "sha": "4aed9f60b067516e43883c4a856a5d1ffdba92e9",
        "filename": "src/util/time.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.cpp?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -123,3 +123,8 @@ struct timeval MillisToTimeval(int64_t nTimeout)\n     timeout.tv_usec = (nTimeout % 1000) * 1000;\n     return timeout;\n }\n+\n+struct timeval MillisToTimeval(std::chrono::milliseconds ms)\n+{\n+    return MillisToTimeval(count_milliseconds(ms));\n+}"
      },
      {
        "sha": "03b75b5be56193b3ae73ed956f1fdee7e1e34e75",
        "filename": "src/util/time.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/time.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ba9d73268f9585d4b9254adcf54708f88222798b/src/util/time.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.h?ref=ba9d73268f9585d4b9254adcf54708f88222798b",
        "patch": "@@ -27,6 +27,7 @@ void UninterruptibleSleep(const std::chrono::microseconds& n);\n  * interface that doesn't support std::chrono (e.g. RPC, debug log, or the GUI)\n  */\n inline int64_t count_seconds(std::chrono::seconds t) { return t.count(); }\n+inline int64_t count_milliseconds(std::chrono::milliseconds t) { return t.count(); }\n inline int64_t count_microseconds(std::chrono::microseconds t) { return t.count(); }\n \n /**\n@@ -64,4 +65,9 @@ int64_t ParseISO8601DateTime(const std::string& str);\n  */\n struct timeval MillisToTimeval(int64_t nTimeout);\n \n+/**\n+ * Convert milliseconds to a struct timeval for e.g. select.\n+ */\n+struct timeval MillisToTimeval(std::chrono::milliseconds ms);\n+\n #endif // BITCOIN_UTIL_TIME_H"
      }
    ]
  },
  {
    "sha": "04ae8469049e1f14585aabfb618ae522150240a7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNGFlODQ2OTA0OWUxZjE0NTg1YWFiZmI2MThhZTUyMjE1MDI0MGE3",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-12-28T15:57:10Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-10T12:30:08Z"
      },
      "message": "net: use Sock in InterruptibleRecv() and Socks5()\n\nUse the `Sock` class instead of `SOCKET` for `InterruptibleRecv()` and\n`Socks5()`.\n\nThis way the `Socks5()` function can be tested by giving it a mocked\ninstance of a socket.\n\nCo-authored-by: practicalswift <practicalswift@users.noreply.github.com>",
      "tree": {
        "sha": "80472dda64d7565ea923d84a9f11b60e243609d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/80472dda64d7565ea923d84a9f11b60e243609d6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04ae8469049e1f14585aabfb618ae522150240a7",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmAj0dAACgkQVN8G9ktV\ny79JdyAAiLCoVpzPO2HwbeAKrBGP3GFM0vdOYfludRcJ5Dq7XiCoq6c0qNnOwCPU\nvigmQlhhFBseE/u0UBkFhucUDVHOmKwO+xCXUeQQP1sOd0QY4PFpUnxBpbwvsRkA\nzHt4Pj2Nq+rGVC33q2chf4LC2FWhdlFys7tIUevb/BXDs6dlfKqZy4EFOpsw+TjT\nRn1oW4urHuKi2BMacCU/JmjpPqMIaU3c+sP1XLdmLGB+J8onOnTqFROXvq5QML5l\n8IY93UKAEYvN9IRwZmcQ1ZsPuzX53s5dM9TqNhQavjgSa77BxBEfYUnqblyp9S14\nc5UwGHnjBbK3OV2BlmDYv+o3LwGy5MuR/Itq3i8wpUEtd318zGitNYCd4OMZTre8\neaekTuYlrgC4cINRBVs5zls63hm8txjUdo8RJEkSMc33CFgDFrICje9GArO0lp4P\nLTRVJ0qp9zI7wcZOcg4kck6SRHqYZpSLMMrqihCPwXwHBHcAjtGEPX2IUIbqqfG5\ndPdjlV9Crzr+DvjbfxfKIOvt+77WWXlJBXnGyp+e0cj7YkGS2s/2N8AF33U19QnU\nYDB0QwVMadvo+CN9fivw0+V3QFXhGTSz/0Vh+9X4j+g2tVNcArdQjKMzo+LIT23p\nh+lQVjvJgDI8ztQP8EpGKOqhVuzc5/QIqHX1611W+SVyFyQe9BJFeT8LkLHYhuoq\nhctJyth40osO5sqjUaHWpemvJJyvG6+YlQfTEbI15AZz+ZgB0Zp90pDmZjwQVkg5\nYbBD75sZJ5fGLy3EZhThG9YS4PNJurYElx3QXAKltfjxSV446NWlLKUm2kUM8RWU\nmUz2ooztJvdwhBelX86ZtJtmb+uIE7HvXW+DXs4oHbgG19ohxEwBuBaMsa+zPz1j\nkt6AV0kPMbq+FlUOWBRVqViZqwVQ8XQ1BYYxjEg/fgXFPxYLTY9DKZ6gq4i+kRyq\n7OJJVpzVqkNOKq0Y7xWkIbDlDdT+i70G/Qo0baDoUS7BlxLHI2XieFNpZLtpSyma\n6OOsBAoHFHqmSonXVuLV8dVaTNUiz3Tj3JWh1VQeNavpkU/Q+ibjA5To7286dgIm\nbt2/l6YlOhaspSWF4gdB1pKDY5FoO2K0NIoQzE0JZNciQMaXzBczw+ij1zULi44y\n/El55MHA82F7Ges9y99HHZgjyzNTXmcuGdIJvOyl5UGjr44XVGWfAdwvxBrvVKjD\nOi2Zd/MfcTe3fFEElDiPBUuSuO4xlf7zHra8p0Nz0NUX+Wh9ArP6MvQmp0ZbZimh\nSHi8yPpmB+kGEmZIWqsgIRtAgO2f9mml6j4/bcjt1EOa0XYd0mIxsuH/NT5OMbi1\naV80z70gKDwD9N8ISAjjnq0PvfDLEw==\n=lSs9\n-----END PGP SIGNATURE-----",
        "payload": "tree 80472dda64d7565ea923d84a9f11b60e243609d6\nparent ba9d73268f9585d4b9254adcf54708f88222798b\nauthor Vasil Dimov <vd@FreeBSD.org> 1609171030 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1612960208 +0100\n\nnet: use Sock in InterruptibleRecv() and Socks5()\n\nUse the `Sock` class instead of `SOCKET` for `InterruptibleRecv()` and\n`Socks5()`.\n\nThis way the `Socks5()` function can be tested by giving it a mocked\ninstance of a socket.\n\nCo-authored-by: practicalswift <practicalswift@users.noreply.github.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04ae8469049e1f14585aabfb618ae522150240a7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/04ae8469049e1f14585aabfb618ae522150240a7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04ae8469049e1f14585aabfb618ae522150240a7/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ba9d73268f9585d4b9254adcf54708f88222798b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ba9d73268f9585d4b9254adcf54708f88222798b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ba9d73268f9585d4b9254adcf54708f88222798b"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 12,
      "deletions": 27
    },
    "files": [
      {
        "sha": "16aa489873bcc8af641330e44aa60a1c5ab76fe1",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04ae8469049e1f14585aabfb618ae522150240a7/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04ae8469049e1f14585aabfb618ae522150240a7/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=04ae8469049e1f14585aabfb618ae522150240a7",
        "patch": "@@ -440,7 +440,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n                 return nullptr;\n             }\n             connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(),\n-                                            sock->Get(), nConnectTimeout, proxyConnectionFailed);\n+                                            *sock, nConnectTimeout, proxyConnectionFailed);\n         } else {\n             // no proxy needed (none set for target network)\n             sock = CreateSock(addrConnect);\n@@ -464,7 +464,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         int port = default_port;\n         SplitHostPort(std::string(pszDest), port, host);\n         bool proxyConnectionFailed;\n-        connected = ConnectThroughProxy(proxy, host, port, sock->Get(), nConnectTimeout,\n+        connected = ConnectThroughProxy(proxy, host, port, *sock, nConnectTimeout,\n                                         proxyConnectionFailed);\n     }\n     if (!connected) {"
      },
      {
        "sha": "59a082befaa0b352ad8a243763bce80c2982ee67",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 24,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04ae8469049e1f14585aabfb618ae522150240a7/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04ae8469049e1f14585aabfb618ae522150240a7/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=04ae8469049e1f14585aabfb618ae522150240a7",
        "patch": "@@ -343,15 +343,15 @@ enum class IntrRecvError {\n  *      Sockets can be made non-blocking with SetSocketNonBlocking(const\n  *      SOCKET&, bool).\n  */\n-static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const SOCKET& hSocket)\n+static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const Sock& hSocket)\n {\n     int64_t curTime = GetTimeMillis();\n     int64_t endTime = curTime + timeout;\n     // Maximum time to wait for I/O readiness. It will take up until this time\n     // (in millis) to break off in case of an interruption.\n     const int64_t maxWait = 1000;\n     while (len > 0 && curTime < endTime) {\n-        ssize_t ret = recv(hSocket, (char*)data, len, 0); // Optimistically try the recv first\n+        ssize_t ret = hSocket.Recv(data, len, 0); // Optimistically try the recv first\n         if (ret > 0) {\n             len -= ret;\n             data += ret;\n@@ -360,25 +360,10 @@ static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, c\n         } else { // Other error or blocking\n             int nErr = WSAGetLastError();\n             if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL) {\n-                if (!IsSelectableSocket(hSocket)) {\n-                    return IntrRecvError::NetworkError;\n-                }\n                 // Only wait at most maxWait milliseconds at a time, unless\n                 // we're approaching the end of the specified total timeout\n                 int timeout_ms = std::min(endTime - curTime, maxWait);\n-#ifdef USE_POLL\n-                struct pollfd pollfd = {};\n-                pollfd.fd = hSocket;\n-                pollfd.events = POLLIN;\n-                int nRet = poll(&pollfd, 1, timeout_ms);\n-#else\n-                struct timeval tval = MillisToTimeval(timeout_ms);\n-                fd_set fdset;\n-                FD_ZERO(&fdset);\n-                FD_SET(hSocket, &fdset);\n-                int nRet = select(hSocket + 1, &fdset, nullptr, nullptr, &tval);\n-#endif\n-                if (nRet == SOCKET_ERROR) {\n+                if (!hSocket.Wait(std::chrono::milliseconds{timeout_ms}, Sock::RECV)) {\n                     return IntrRecvError::NetworkError;\n                 }\n             } else {\n@@ -442,7 +427,7 @@ static std::string Socks5ErrorString(uint8_t err)\n  * @see <a href=\"https://www.ietf.org/rfc/rfc1928.txt\">RFC1928: SOCKS Protocol\n  *      Version 5</a>\n  */\n-static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, const SOCKET& hSocket)\n+static bool Socks5(const std::string& strDest, int port, const ProxyCredentials* auth, const Sock& hSocket)\n {\n     IntrRecvError recvr;\n     LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n@@ -460,7 +445,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         vSocks5Init.push_back(0x01); // 1 method identifier follows...\n         vSocks5Init.push_back(SOCKS5Method::NOAUTH);\n     }\n-    ssize_t ret = send(hSocket, (const char*)vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n+    ssize_t ret = hSocket.Send(vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)vSocks5Init.size()) {\n         return error(\"Error sending to proxy\");\n     }\n@@ -482,7 +467,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         vAuth.insert(vAuth.end(), auth->username.begin(), auth->username.end());\n         vAuth.push_back(auth->password.size());\n         vAuth.insert(vAuth.end(), auth->password.begin(), auth->password.end());\n-        ret = send(hSocket, (const char*)vAuth.data(), vAuth.size(), MSG_NOSIGNAL);\n+        ret = hSocket.Send(vAuth.data(), vAuth.size(), MSG_NOSIGNAL);\n         if (ret != (ssize_t)vAuth.size()) {\n             return error(\"Error sending authentication to proxy\");\n         }\n@@ -508,7 +493,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n     vSocks5.insert(vSocks5.end(), strDest.begin(), strDest.end());\n     vSocks5.push_back((port >> 8) & 0xFF);\n     vSocks5.push_back((port >> 0) & 0xFF);\n-    ret = send(hSocket, (const char*)vSocks5.data(), vSocks5.size(), MSG_NOSIGNAL);\n+    ret = hSocket.Send(vSocks5.data(), vSocks5.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)vSocks5.size()) {\n         return error(\"Error sending to proxy\");\n     }\n@@ -787,10 +772,10 @@ bool IsProxy(const CNetAddr &addr) {\n  *\n  * @returns Whether or not the operation succeeded.\n  */\n-bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocket, int nTimeout, bool& outProxyConnectionFailed)\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& hSocket, int nTimeout, bool& outProxyConnectionFailed)\n {\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy.proxy, hSocket, nTimeout, true)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, hSocket.Get(), nTimeout, true)) {\n         outProxyConnectionFailed = true;\n         return false;\n     }"
      },
      {
        "sha": "9ad9a864d8ed8ce570905b1c01f22a348f32c7f5",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04ae8469049e1f14585aabfb618ae522150240a7/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04ae8469049e1f14585aabfb618ae522150240a7/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=04ae8469049e1f14585aabfb618ae522150240a7",
        "patch": "@@ -68,7 +68,7 @@ std::unique_ptr<Sock> CreateSockTCP(const CService& address_family);\n extern std::function<std::unique_ptr<Sock>(const CService&)> CreateSock;\n \n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n-bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocketRet, int nTimeout, bool& outProxyConnectionFailed);\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& hSocketRet, int nTimeout, bool& outProxyConnectionFailed);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n /** Set the TCP_NODELAY flag on a socket */"
      }
    ]
  },
  {
    "sha": "7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YmQyMWNlMWVmYzM2M2IzZThlYTFkNTFkZDE0MTBjY2Q2NjgyMGNi",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-04T17:07:24Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-10T12:30:09Z"
      },
      "message": "style: rename hSocket to sock\n\nIn the arguments of `InterruptibleRecv()`, `Socks5()` and\n`ConnectThroughProxy()` the variable `hSocket` was previously of type\n`SOCKET`, but has been changed to `Sock`. Thus rename it to `sock` to\nimply its type, to distinguish from other `SOCKET` variables and to\nabide to the coding style wrt variables' names.",
      "tree": {
        "sha": "f725f2599ccf07f30785fce70d095936851ac887",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f725f2599ccf07f30785fce70d095936851ac887"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmAj0dEACgkQVN8G9ktV\ny7+RlCAAmfcvS7z4QY7ADAGX5jCdFbKwfvnykrlZtw7xVKsFwEpjCzizMzz7Pls4\nrbndkAWuxCFG3ue/P+uOPM9S1Yyyg02zo/8eq772DvNbhGNc3D2Sy31rZDC9pxXd\nKRmoERIgn+nU8wXLvojAU7EMRqtbFDSj1biTOVZBRa+iDTNzfsyI35WsphNlwxgt\n6yP4G3raU3VA372/qKvqkbI3ynPanR3yC1B7UnxyXR6y2LctNx8wW8ra8SV5veqz\nSJqeSSLFQ3w5fScgg7tPKtVrzMyIWpe1ZC8rUfIrLjgByhR61thO7zKsVNVx0zm/\ngLJzheAgG0+CTqW+Bnr/R34anxqd/QUQz/MJlnTfowhVOVQWx8uB+zeRX5Do9Lox\nPBnwc8EZ6rM2GJEWir74Ls8JjkNV4q2YdwGlSjoyp3NRZFYlCSzTResJKixTfITX\neqVjJBk2LTKL0lnR8oXteb3VI3c8XtMEnY0U2j5ZIhOv5BSsqy6f50MtUZX9mtcM\nddee/OJei5IPSh4RihMBuqQbBgb6gGIGkWsvzTRn+e2HVVHPxCvAAvcj6rbTwKZQ\nLJla96TOLALjn9ZEysZYugLfzyh0pTZqCtaBy2GJ1U2lXf6rXdqLp/Uu7asF+UZQ\nuFpSJp/6TH73zR4K+TCf6ulnJGBn+Fx/97IUg5BtwqiGjTokQ33ZxdLe+kCx57M/\nkNio5k4i6SEDQIaAjGy3xQuApOnjhki0YqwuG8JcNOUYQ8XxBIZBWkbTkKYU6XZ5\n581kFCrP26NjbXvdqegZnZEfhoM55BKXlHOzSLXmUrkT954+nAu2psmmnRf+DwX6\nzJ8OZ00rAKYQcOWQS2nWxDIwF367opmyNV+7LyfRiLUylrNYJzqUVQmIa6NRMltk\nJ3ckEvOS6n8H+090ywA58I+KEZnfhRCsl06LSvV4404iC0fN6XIFZZ9bucqJ9j03\n3SyIO8It5yiOqu8jr8q1KndDnVWelkN5WrinyZmTptrpRdkxR1P9xHL41kwhI+In\nWUiv2SfDbWN/iQyLwQvBCPqUhV6FQM++2UTcaWhDPfBlRdYTCNrHHIkJ597MPt3l\ng46n6knOtkTq0/OWjc2Owstu8l1RVDJStzccmYwPqfFmyuG6gEsWkHUwU1vMD3Kh\n5y5Dbrzcu9922N1N1mfAyMvRaOawSg9HbHy/GBGQBAnAwfdsvSPtYEgETEKekBSR\novcp6DseCxsIGEcfzExHfScvRoXmbW666RBZT3AVTveUZ4i2T9ADjeWKZT0fwUez\nA39pdDQBoijblFO0a0NoY8DoJKaBdR3MSzOqyUA8I2Z2t2ckx3i/A5naGHj1UNjO\npYQK5p1B96MGU461YR5SFzuYtlFT5A==\n=GIWv\n-----END PGP SIGNATURE-----",
        "payload": "tree f725f2599ccf07f30785fce70d095936851ac887\nparent 04ae8469049e1f14585aabfb618ae522150240a7\nauthor Vasil Dimov <vd@FreeBSD.org> 1612458444 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1612960209 +0100\n\nstyle: rename hSocket to sock\n\nIn the arguments of `InterruptibleRecv()`, `Socks5()` and\n`ConnectThroughProxy()` the variable `hSocket` was previously of type\n`SOCKET`, but has been changed to `Sock`. Thus rename it to `sock` to\nimply its type, to distinguish from other `SOCKET` variables and to\nabide to the coding style wrt variables' names.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04ae8469049e1f14585aabfb618ae522150240a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04ae8469049e1f14585aabfb618ae522150240a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04ae8469049e1f14585aabfb618ae522150240a7"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 23,
      "deletions": 24
    },
    "files": [
      {
        "sha": "24188f83c6bfdf25ca4cdb22d24fb7037233edb8",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 23,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
        "patch": "@@ -332,8 +332,7 @@ enum class IntrRecvError {\n  * @param data The buffer where the read bytes should be stored.\n  * @param len The number of bytes to read into the specified buffer.\n  * @param timeout The total timeout in milliseconds for this read.\n- * @param hSocket The socket (has to be in non-blocking mode) from which to read\n- *                bytes.\n+ * @param sock The socket (has to be in non-blocking mode) from which to read bytes.\n  *\n  * @returns An IntrRecvError indicating the resulting status of this read.\n  *          IntrRecvError::OK only if all of the specified number of bytes were\n@@ -343,15 +342,15 @@ enum class IntrRecvError {\n  *      Sockets can be made non-blocking with SetSocketNonBlocking(const\n  *      SOCKET&, bool).\n  */\n-static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const Sock& hSocket)\n+static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const Sock& sock)\n {\n     int64_t curTime = GetTimeMillis();\n     int64_t endTime = curTime + timeout;\n     // Maximum time to wait for I/O readiness. It will take up until this time\n     // (in millis) to break off in case of an interruption.\n     const int64_t maxWait = 1000;\n     while (len > 0 && curTime < endTime) {\n-        ssize_t ret = hSocket.Recv(data, len, 0); // Optimistically try the recv first\n+        ssize_t ret = sock.Recv(data, len, 0); // Optimistically try the recv first\n         if (ret > 0) {\n             len -= ret;\n             data += ret;\n@@ -363,7 +362,7 @@ static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, c\n                 // Only wait at most maxWait milliseconds at a time, unless\n                 // we're approaching the end of the specified total timeout\n                 int timeout_ms = std::min(endTime - curTime, maxWait);\n-                if (!hSocket.Wait(std::chrono::milliseconds{timeout_ms}, Sock::RECV)) {\n+                if (!sock.Wait(std::chrono::milliseconds{timeout_ms}, Sock::RECV)) {\n                     return IntrRecvError::NetworkError;\n                 }\n             } else {\n@@ -417,7 +416,7 @@ static std::string Socks5ErrorString(uint8_t err)\n  * @param port The destination port.\n  * @param auth The credentials with which to authenticate with the specified\n  *             SOCKS5 proxy.\n- * @param hSocket The SOCKS5 proxy socket.\n+ * @param sock The SOCKS5 proxy socket.\n  *\n  * @returns Whether or not the operation succeeded.\n  *\n@@ -427,7 +426,7 @@ static std::string Socks5ErrorString(uint8_t err)\n  * @see <a href=\"https://www.ietf.org/rfc/rfc1928.txt\">RFC1928: SOCKS Protocol\n  *      Version 5</a>\n  */\n-static bool Socks5(const std::string& strDest, int port, const ProxyCredentials* auth, const Sock& hSocket)\n+static bool Socks5(const std::string& strDest, int port, const ProxyCredentials* auth, const Sock& sock)\n {\n     IntrRecvError recvr;\n     LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n@@ -445,12 +444,12 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials*\n         vSocks5Init.push_back(0x01); // 1 method identifier follows...\n         vSocks5Init.push_back(SOCKS5Method::NOAUTH);\n     }\n-    ssize_t ret = hSocket.Send(vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n+    ssize_t ret = sock.Send(vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)vSocks5Init.size()) {\n         return error(\"Error sending to proxy\");\n     }\n     uint8_t pchRet1[2];\n-    if ((recvr = InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+    if ((recvr = InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n         LogPrintf(\"Socks5() connect to %s:%d failed: InterruptibleRecv() timeout or other failure\\n\", strDest, port);\n         return false;\n     }\n@@ -467,13 +466,13 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials*\n         vAuth.insert(vAuth.end(), auth->username.begin(), auth->username.end());\n         vAuth.push_back(auth->password.size());\n         vAuth.insert(vAuth.end(), auth->password.begin(), auth->password.end());\n-        ret = hSocket.Send(vAuth.data(), vAuth.size(), MSG_NOSIGNAL);\n+        ret = sock.Send(vAuth.data(), vAuth.size(), MSG_NOSIGNAL);\n         if (ret != (ssize_t)vAuth.size()) {\n             return error(\"Error sending authentication to proxy\");\n         }\n         LogPrint(BCLog::PROXY, \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n         uint8_t pchRetA[2];\n-        if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+        if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n             return error(\"Error reading proxy authentication response\");\n         }\n         if (pchRetA[0] != 0x01 || pchRetA[1] != 0x00) {\n@@ -493,12 +492,12 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials*\n     vSocks5.insert(vSocks5.end(), strDest.begin(), strDest.end());\n     vSocks5.push_back((port >> 8) & 0xFF);\n     vSocks5.push_back((port >> 0) & 0xFF);\n-    ret = hSocket.Send(vSocks5.data(), vSocks5.size(), MSG_NOSIGNAL);\n+    ret = sock.Send(vSocks5.data(), vSocks5.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)vSocks5.size()) {\n         return error(\"Error sending to proxy\");\n     }\n     uint8_t pchRet2[4];\n-    if ((recvr = InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+    if ((recvr = InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n         if (recvr == IntrRecvError::Timeout) {\n             /* If a timeout happens here, this effectively means we timed out while connecting\n              * to the remote node. This is very common for Tor, so do not print an\n@@ -522,24 +521,24 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials*\n     uint8_t pchRet3[256];\n     switch (pchRet2[3])\n     {\n-        case SOCKS5Atyp::IPV4: recvr = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket); break;\n-        case SOCKS5Atyp::IPV6: recvr = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket); break;\n+        case SOCKS5Atyp::IPV4: recvr = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, sock); break;\n+        case SOCKS5Atyp::IPV6: recvr = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, sock); break;\n         case SOCKS5Atyp::DOMAINNAME:\n         {\n-            recvr = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n+            recvr = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, sock);\n             if (recvr != IntrRecvError::OK) {\n                 return error(\"Error reading from proxy\");\n             }\n             int nRecv = pchRet3[0];\n-            recvr = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n+            recvr = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, sock);\n             break;\n         }\n         default: return error(\"Error: malformed proxy response\");\n     }\n     if (recvr != IntrRecvError::OK) {\n         return error(\"Error reading from proxy\");\n     }\n-    if ((recvr = InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+    if ((recvr = InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n         return error(\"Error reading from proxy\");\n     }\n     LogPrint(BCLog::NET, \"SOCKS5 connected %s\\n\", strDest);\n@@ -764,18 +763,18 @@ bool IsProxy(const CNetAddr &addr) {\n  * @param proxy The SOCKS5 proxy.\n  * @param strDest The destination service to which to connect.\n  * @param port The destination port.\n- * @param hSocket The socket on which to connect to the SOCKS5 proxy.\n+ * @param sock The socket on which to connect to the SOCKS5 proxy.\n  * @param nTimeout Wait this many milliseconds for the connection to the SOCKS5\n  *                 proxy to be established.\n  * @param[out] outProxyConnectionFailed Whether or not the connection to the\n  *                                      SOCKS5 proxy failed.\n  *\n  * @returns Whether or not the operation succeeded.\n  */\n-bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& hSocket, int nTimeout, bool& outProxyConnectionFailed)\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed)\n {\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy.proxy, hSocket.Get(), nTimeout, true)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, sock.Get(), nTimeout, true)) {\n         outProxyConnectionFailed = true;\n         return false;\n     }\n@@ -784,11 +783,11 @@ bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int\n         ProxyCredentials random_auth;\n         static std::atomic_int counter(0);\n         random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n-        if (!Socks5(strDest, (uint16_t)port, &random_auth, hSocket)) {\n+        if (!Socks5(strDest, (uint16_t)port, &random_auth, sock)) {\n             return false;\n         }\n     } else {\n-        if (!Socks5(strDest, (uint16_t)port, 0, hSocket)) {\n+        if (!Socks5(strDest, (uint16_t)port, 0, sock)) {\n             return false;\n         }\n     }"
      },
      {
        "sha": "afc373ef49bf0e4c89c622a1127b907a51c96628",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
        "patch": "@@ -68,7 +68,7 @@ std::unique_ptr<Sock> CreateSockTCP(const CService& address_family);\n extern std::function<std::unique_ptr<Sock>(const CService&)> CreateSock;\n \n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n-bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& hSocketRet, int nTimeout, bool& outProxyConnectionFailed);\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n /** Set the TCP_NODELAY flag on a socket */"
      }
    ]
  },
  {
    "sha": "615ba0eb96cf131364c1ceca9d3dedf006fa1e1c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTViYTBlYjk2Y2YxMzEzNjRjMWNlY2E5ZDNkZWRmMDA2ZmExZTFj",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-01-04T10:44:21Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2021-02-11T09:44:53Z"
      },
      "message": "test: add Sock unit tests",
      "tree": {
        "sha": "1e6cb39b6dcc9c2e86ccfde16fc0c228830e1e1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e6cb39b6dcc9c2e86ccfde16fc0c228830e1e1b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmAk/JcACgkQVN8G9ktV\ny79e2B/9E1zQeRBE+2iwA4vbywEpuo2+udT8GQXnPQl0WCkHXelJVUAnTRvLwhc5\nu+YJ0+EDeicq+Qabxjy3VbwjhaUxnfIwuIc/ExFsVyQof7nonOUGPQdWFoVynXb9\nfTWD8nYBbLBZiz4IT5WFdVYMbGHH0VGg5b+6cqY+WgetHxZ8XHEJgnO2fnzCwrfW\nOlB6KuUqjofOpyW2eIyrkb0SrV60LiG7WvLLBa38CgQHSSpKRXfH3pybQrjMzgUq\n5UZPzHNhJrW3Qkfr1k9h66HmsKefnE7WAWULJTJRVBWQQZojuJWIF6RxvK0DL8bP\nCWdo6vQGAMLeRGZ2AMTPf4DugoNiFUgnx9V1hPTSL7opsJC8fiA5ObtlQPUzrGg6\nyBV6O1BBqHZLJyyiPJz/JFdi8yDkXehtvOXN9h6zc0fLXM5jz8odntgaCLDmcOMI\nWddBGSwgHJQxc+s0Vps3q9aIYQnVZllTShqn8GmrQJS9Xwwz8V6eqv1I8B6R2a3Z\n1g65ZKmQ0ByvSmqHbEnu2IcL9MWcHhElBg5m2sRfxIPOoGtTq5nzSanOOtcTDo2+\nO1CQOfEt5kjmWMqSzErIdEbIpRItAsdSSk/OdEsdPQncKzErDlDghw1TFqhQqC7e\nyzYlZKa0LXNVVFQKh1T8i3d0F6JAikPow7QocOykVEjUgbZmstsG+LK8Sz6+NUsP\nbt5ssN8KAIPDb6UDseHR+HqkVq+0BzLvt7GwUBeTwOVhGOzPHlqRi7irb9U/Pck2\nMNQeaDV8Fi3V3JC+osZtQw3+iHi8nWovGuGlsnglKHO8FNJufi426LbWU6zXMf5W\nUmvuFOKOE21LiGT/KV3Gs0iuieuY8yi17Yg+sNjxpXI+2V/Bq/duedQuxp/J4bGw\ntID/QYFQ6HvcmJchyNFgWk0QBQpd/wajh2HwZPJjgxVVf6ueCf1MCybonwm1Q54j\nK4RrWK09EhZh8/FP8MAlkO3MBn0oSbvxi7vtOPp4Fm5U2pEafYnCYRaLbeneCz1n\nxmOVBw5lG7UZ+yjOoMAG+8NEip7oOfPK7HqPI5oNwxy+CJlf2IdDSu8GsMVmLP5j\nTZD3pZz86J7OiiErdrNLxvkfEXSP4qqizE+cKVpVTgR2P2Ucoc55Y8V+ymlFHnDy\nrNm3Sw0AhhRr4G3UiVDgFVFk6l1AUQAHLZsK+hkpVLZgJGJbGwDeJs+J6ZnZ7Wk6\nXs44AQfFyy6f6iqgp1PKOaQfAB54DKOSDgTJJCUTAllkRnwlyCkVsD0kLXZ1j40k\n7JKiwLmDqf/zY7RUp9vkPT9VLuKK0rwvSwNJoU1bWUmgQDFy+9+Z3+D3b7GZL1n+\nvPH9lpsRtAesIVSDXSU/cRM+NdE0IA==\n=VoB7\n-----END PGP SIGNATURE-----",
        "payload": "tree 1e6cb39b6dcc9c2e86ccfde16fc0c228830e1e1b\nparent 7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb\nauthor Vasil Dimov <vd@FreeBSD.org> 1609757061 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1613036693 +0100\n\ntest: add Sock unit tests\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7bd21ce1efc363b3e8ea1d51dd1410ccd66820cb"
      }
    ],
    "stats": {
      "total": 150,
      "additions": 150,
      "deletions": 0
    },
    "files": [
      {
        "sha": "770aba467de111cba7a7b331fc574c2998976e93",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=615ba0eb96cf131364c1ceca9d3dedf006fa1e1c",
        "patch": "@@ -114,6 +114,7 @@ BITCOIN_TESTS =\\\n   test/sighash_tests.cpp \\\n   test/sigopcount_tests.cpp \\\n   test/skiplist_tests.cpp \\\n+  test/sock_tests.cpp \\\n   test/streams_tests.cpp \\\n   test/sync_tests.cpp \\\n   test/system_tests.cpp \\"
      },
      {
        "sha": "cc0e6e70575c89d8f4c4765c45fb4d2b50bf7e63",
        "filename": "src/test/sock_tests.cpp",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c/src/test/sock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/615ba0eb96cf131364c1ceca9d3dedf006fa1e1c/src/test/sock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sock_tests.cpp?ref=615ba0eb96cf131364c1ceca9d3dedf006fa1e1c",
        "patch": "@@ -0,0 +1,149 @@\n+// Copyright (c) 2021-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compat.h>\n+#include <test/util/setup_common.h>\n+#include <util/sock.h>\n+#include <util/system.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <thread>\n+\n+using namespace std::chrono_literals;\n+\n+BOOST_FIXTURE_TEST_SUITE(sock_tests, BasicTestingSetup)\n+\n+static bool SocketIsClosed(const SOCKET& s)\n+{\n+    // Notice that if another thread is running and creates its own socket after `s` has been\n+    // closed, it may be assigned the same file descriptor number. In this case, our test will\n+    // wrongly pretend that the socket is not closed.\n+    int type;\n+    socklen_t len = sizeof(type);\n+    return getsockopt(s, SOL_SOCKET, SO_TYPE, (sockopt_arg_type)&type, &len) == SOCKET_ERROR;\n+}\n+\n+static SOCKET CreateSocket()\n+{\n+    const SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    BOOST_REQUIRE(s != static_cast<SOCKET>(SOCKET_ERROR));\n+    return s;\n+}\n+\n+BOOST_AUTO_TEST_CASE(constructor_and_destructor)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock* sock = new Sock(s);\n+    BOOST_CHECK_EQUAL(sock->Get(), s);\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    delete sock;\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(move_constructor)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock* sock1 = new Sock(s);\n+    Sock* sock2 = new Sock(std::move(*sock1));\n+    delete sock1;\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    BOOST_CHECK_EQUAL(sock2->Get(), s);\n+    delete sock2;\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(move_assignment)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock* sock1 = new Sock(s);\n+    Sock* sock2 = new Sock();\n+    *sock2 = std::move(*sock1);\n+    delete sock1;\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    BOOST_CHECK_EQUAL(sock2->Get(), s);\n+    delete sock2;\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(release)\n+{\n+    SOCKET s = CreateSocket();\n+    Sock* sock = new Sock(s);\n+    BOOST_CHECK_EQUAL(sock->Release(), s);\n+    delete sock;\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    BOOST_REQUIRE(CloseSocket(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(reset)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock sock(s);\n+    sock.Reset();\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+#ifndef WIN32 // Windows does not have socketpair(2).\n+\n+static void CreateSocketPair(int s[2])\n+{\n+    BOOST_REQUIRE_EQUAL(socketpair(AF_UNIX, SOCK_STREAM, 0, s), 0);\n+}\n+\n+static void SendAndRecvMessage(const Sock& sender, const Sock& receiver)\n+{\n+    const char* msg = \"abcd\";\n+    constexpr size_t msg_len = 4;\n+    char recv_buf[10];\n+\n+    BOOST_CHECK_EQUAL(sender.Send(msg, msg_len, 0), msg_len);\n+    BOOST_CHECK_EQUAL(receiver.Recv(recv_buf, sizeof(recv_buf), 0), msg_len);\n+    BOOST_CHECK_EQUAL(strncmp(msg, recv_buf, msg_len), 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(send_and_receive)\n+{\n+    int s[2];\n+    CreateSocketPair(s);\n+\n+    Sock* sock0 = new Sock(s[0]);\n+    Sock* sock1 = new Sock(s[1]);\n+\n+    SendAndRecvMessage(*sock0, *sock1);\n+\n+    Sock* sock0moved = new Sock(std::move(*sock0));\n+    Sock* sock1moved = new Sock();\n+    *sock1moved = std::move(*sock1);\n+\n+    delete sock0;\n+    delete sock1;\n+\n+    SendAndRecvMessage(*sock1moved, *sock0moved);\n+\n+    delete sock0moved;\n+    delete sock1moved;\n+\n+    BOOST_CHECK(SocketIsClosed(s[0]));\n+    BOOST_CHECK(SocketIsClosed(s[1]));\n+}\n+\n+BOOST_AUTO_TEST_CASE(wait)\n+{\n+    int s[2];\n+    CreateSocketPair(s);\n+\n+    Sock sock0(s[0]);\n+    Sock sock1(s[1]);\n+\n+    std::thread waiter([&sock0]() { sock0.Wait(24h, Sock::RECV); });\n+\n+    BOOST_REQUIRE_EQUAL(sock1.Send(\"a\", 1, 0), 1);\n+\n+    waiter.join();\n+}\n+\n+#endif /* WIN32 */\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]