[
  {
    "sha": "99b1800ce9e57298fd67dacedc59c3d3b1230138",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OWIxODAwY2U5ZTU3Mjk4ZmQ2N2RhY2VkYzU5YzNkM2IxMjMwMTM4",
    "commit": {
      "author": {
        "name": "Max Justicz",
        "email": "max@justi.cz",
        "date": "2017-08-30T07:52:14Z"
      },
      "committer": {
        "name": "Max Justicz",
        "email": "max@justi.cz",
        "date": "2017-09-06T05:29:40Z"
      },
      "message": "add verifyrawtransaction rpc\n\nadd tests\n\nfix typo\n\nadd dryrun flag to AcceptToMemoryPool]\n\ncheck each transaction against local policy rules\n\nstop doing needless work in CreateNewBlock\n\nupdate docs\n\nadd ancestor topological sort\n\nadd better tests for multi ancestors and policy flag\n\nadd moar tests\n\nmake everything snake_case",
      "tree": {
        "sha": "ed83a9f5a5032cd5e7f282139348ba63b4bdf194",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed83a9f5a5032cd5e7f282139348ba63b4bdf194"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99b1800ce9e57298fd67dacedc59c3d3b1230138",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99b1800ce9e57298fd67dacedc59c3d3b1230138",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99b1800ce9e57298fd67dacedc59c3d3b1230138",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99b1800ce9e57298fd67dacedc59c3d3b1230138/comments",
    "author": {
      "login": "justicz",
      "id": 17011613,
      "node_id": "MDQ6VXNlcjE3MDExNjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17011613?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/justicz",
      "html_url": "https://github.com/justicz",
      "followers_url": "https://api.github.com/users/justicz/followers",
      "following_url": "https://api.github.com/users/justicz/following{/other_user}",
      "gists_url": "https://api.github.com/users/justicz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/justicz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/justicz/subscriptions",
      "organizations_url": "https://api.github.com/users/justicz/orgs",
      "repos_url": "https://api.github.com/users/justicz/repos",
      "events_url": "https://api.github.com/users/justicz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/justicz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "justicz",
      "id": 17011613,
      "node_id": "MDQ6VXNlcjE3MDExNjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17011613?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/justicz",
      "html_url": "https://github.com/justicz",
      "followers_url": "https://api.github.com/users/justicz/followers",
      "following_url": "https://api.github.com/users/justicz/following{/other_user}",
      "gists_url": "https://api.github.com/users/justicz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/justicz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/justicz/subscriptions",
      "organizations_url": "https://api.github.com/users/justicz/orgs",
      "repos_url": "https://api.github.com/users/justicz/repos",
      "events_url": "https://api.github.com/users/justicz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/justicz/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6866b4912b8013ed748d12250209f7079a3c92e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6866b4912b8013ed748d12250209f7079a3c92e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6866b4912b8013ed748d12250209f7079a3c92e6"
      }
    ],
    "stats": {
      "total": 501,
      "additions": 458,
      "deletions": 43
    },
    "files": [
      {
        "sha": "3afeed6ad77735f7bac8aa6a9318a808fc460e48",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -126,7 +126,7 @@ void BlockAssembler::resetBlock()\n     nFees = 0;\n }\n \n-std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx)\n+std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx, bool fPopulateTxs)\n {\n     int64_t nTimeStart = GetTimeMicros();\n \n@@ -170,7 +170,10 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n \n     int nPackagesSelected = 0;\n     int nDescendantsUpdated = 0;\n-    addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+\n+    if (fPopulateTxs) {\n+        addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+    }\n \n     int64_t nTime1 = GetTimeMicros();\n "
      },
      {
        "sha": "26ae04d39d80350803590c1c4f2bcd20f7c52fbd",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -168,7 +168,7 @@ class BlockAssembler\n     BlockAssembler(const CChainParams& params, const Options& options);\n \n     /** Construct a new block template with coinbase to scriptPubKeyIn */\n-    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx=true);\n+    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx=true, bool fPopulateTxs=true);\n \n private:\n     // utility functions"
      },
      {
        "sha": "ac367ba5ef7dd5ab838d41886049ba119b9855db",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -95,6 +95,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"createrawtransaction\", 3, \"replaceable\" },\n     { \"signrawtransaction\", 1, \"prevtxs\" },\n     { \"signrawtransaction\", 2, \"privkeys\" },\n+    { \"verifyrawtransactions\", 0, \"transactions\" },\n+    { \"verifyrawtransactions\", 1, \"use_local_policy\" },\n     { \"sendrawtransaction\", 1, \"allowhighfees\" },\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },"
      },
      {
        "sha": "3b0fb5f70c4831d57ec4f4d6ef3fad336fc8f0fc",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 223,
        "deletions": 2,
        "changes": 225,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -13,7 +13,9 @@\n #include \"validation.h\"\n #include \"merkleblock.h\"\n #include \"net.h\"\n+#include \"miner.h\"\n #include \"policy/policy.h\"\n+#include \"policy/fees.h\"\n #include \"policy/rbf.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/safemode.h\"\n@@ -887,6 +889,224 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue verifyrawtransactions(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"verifyrawtransactions [\\\"hex_tx\\\", ...] ( use_local_rules )\\n\"\n+            \"\\nTests the validity of a series of raw transactions (serialized, hex-encoded), without submitting them.\\n\"\n+            \"The transactions can be dependent on one another, or have ancestors residing in the mempool. The\\n\"\n+            \"use_local_rules flag determines if the transactions should be validated against the node's local\\n\"\n+            \"policies. Setting it to false effectively checks if this node would reject the block containing\\n\"\n+            \"these transactions and their mempool resident ancestors, should they be mined.\\n\"\n+            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"transactions\\\"    (array) A json array of hex encoded transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hex_tx\\\"       (string) A hex encoded transaction\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"2. \\\"use_local_rules\\\" (boolean, optional, default=true) If enabled, checks transactions against local policies\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"valid\\\"  : true|false,    (string) The transaction id\\n\"\n+            \"  \\\"reason\\\" : \\\"reason\\\",      (string) Description of why verification failed or succeeded\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"Create a transaction\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\"\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nVerify the transaction (signed hex)\\n\"\n+            + HelpExampleCli(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"verifyrawtransactions\", \"[\\\"signedhex\\\"]\")\n+        );\n+\n+    LOCK(cs_main);\n+    LOCK(mempool.cs);\n+\n+    // Type check arguments\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+    UniValue hex_transactions = request.params[0].get_array();\n+\n+    // { valid true/false , reason str }\n+    UniValue result(UniValue::VOBJ);\n+\n+    bool use_local_policy = request.params[1].isNull() || request.params[1].get_bool();\n+\n+    // Parse all of the transactions (map is txhash -> tx).\n+    std::map<uint256, CTransactionRef> transactions;\n+    std::map<uint256, CTransactionRef>::iterator txit;\n+    for (unsigned int idx = 0; idx < hex_transactions.size(); idx++) {\n+        const UniValue& hex_tx = hex_transactions[idx];\n+        CMutableTransaction mtx;\n+        if (!DecodeHexTx(mtx, hex_tx.get_str())) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+        }\n+        CTransactionRef ref = MakeTransactionRef(std::move(mtx));\n+        transactions.insert(std::pair<uint256, CTransactionRef>(ref->GetHash(), ref));\n+    }\n+\n+    // Should we check against our local policy, or just consensus rules?\n+    if (use_local_policy) {\n+        // For each input transaction\n+        for (auto const& hash_tx : transactions) {\n+            CTransactionRef tx(hash_tx.second);\n+            const uint256& hash = tx->GetHash();\n+            CCoinsViewCache& view = *pcoinsTip;\n+\n+            // Fail fast if we have an unspent output from this transaction\n+            // already in our wallet, which indicates right away that this is a\n+            // duplicate tx (copied from sendrawtransaction)\n+            bool have_chain = false;\n+            for (size_t o = 0; !have_chain && o < tx->vout.size(); o++) {\n+                const Coin& existingCoin = view.AccessCoin(COutPoint(hash, o));\n+                have_chain = !existingCoin.IsSpent();\n+            }\n+\n+            // Check if transaction already exists in mempool\n+            bool have_mempool = mempool.exists(hash);\n+\n+            if (have_chain) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in chain\"));\n+                return result;\n+            }\n+\n+            if (have_mempool) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in mempool\"));\n+                return result;\n+            }\n+\n+            // If we are reasonably confident that this transaction is not a\n+            // duplicate, do an AcceptToMemoryPool dry run\n+            CValidationState state;\n+            bool missing_inputs;\n+\n+            // Call AcceptToMemoryPool with the dryrun flag set\n+            if (!AcceptToMemoryPool(mempool, state, std::move(tx), true, &missing_inputs, nullptr, false, true, 0)) {\n+                if (state.IsInvalid()) {\n+                    result.push_back(Pair(\"valid\",  false));\n+                    result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n+                    return result;\n+                } else if (missing_inputs) {\n+                    // We want to ignore the \"missing inputs\" case here, since the input\n+                    // may actually be in the mempool. If the input is truly missing, we\n+                    // will find out later after the ancestor and consensus check.\n+                    continue;\n+                }\n+                // Unknown error\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"couldn't accept transaction to mempool\"));\n+                return result;\n+            }\n+        }\n+    }\n+\n+    // Find the ancestors of all of the transactions, including ones in mempool\n+    std::map<uint256, CTransactionRef> ancestors;\n+    for (auto const& hash_tx : transactions) {\n+        CTransactionRef tx = hash_tx.second;\n+        for (const CTxIn& txin : tx->vin) {\n+            // Check the mempool\n+            const uint256& hash = txin.prevout.hash;\n+            CTxMemPool::txiter it = mempool.mapTx.find(hash);\n+\n+            // Ancestor not in mempool\n+            if (it == mempool.mapTx.end()) {\n+                continue;\n+            }\n+\n+            // Add the ancestor to the map\n+            ancestors.insert(std::pair<uint256, CTransactionRef>(hash, MakeTransactionRef(it->GetTx())));\n+\n+            // CalculateMemPoolAncestors only works on mempool entries, which is why we are iterating over vin\n+            CTxMemPool::setEntries tx_ancestors;\n+            uint64_t no_limit = std::numeric_limits<uint64_t>::max();\n+            std::string dummy;\n+            mempool.CalculateMemPoolAncestors(*it, tx_ancestors, no_limit, no_limit, no_limit, no_limit, dummy, false);\n+\n+            // Insert ancestors' ancestors into the map\n+            for (CTxMemPool::txiter ancestor_it : tx_ancestors) {\n+                CTransactionRef atf = MakeTransactionRef(ancestor_it->GetTx());\n+                ancestors.insert(std::pair<uint256, CTransactionRef>(atf->GetHash(), atf));\n+            }\n+        }\n+    }\n+\n+    // Merge the ancestors into the transactions\n+    transactions.insert(ancestors.begin(), ancestors.end());\n+\n+    // Now, come up with a valid topological sort over the transactions\n+    std::vector<CTransactionRef> ordered_tx;\n+\n+    // Iterate over the transactions, removing all of those with no\n+    // dependencies in the list each time. Technically, this is worst\n+    // case n^2 since the transactions could be dependent in reverse\n+    // order. In practice, I think this is better than e.g. implementing\n+    // an asymptotically efficient topological sort since input sizes will\n+    // likely be small and this is way easier to implement.\n+    while (transactions.size() > 0) {\n+        auto hash_tx = transactions.begin();\n+        bool found_independent = false;\n+        while (hash_tx != transactions.end()) {\n+            CTransactionRef tx = hash_tx->second;\n+            bool is_independent = true;\n+            for (const CTxIn& txin : tx->vin) {\n+                txit = transactions.find(txin.prevout.hash);\n+                if (txit != transactions.end()) {\n+                    is_independent = false;\n+                    break;\n+                }\n+            }\n+            if (is_independent) {\n+                found_independent = true;\n+                ordered_tx.push_back(tx);\n+                hash_tx = transactions.erase(hash_tx);\n+            } else {\n+                hash_tx++;\n+            }\n+        }\n+        if (found_independent) {\n+            continue;\n+        }\n+        // We got all the way through without finding an independent tx\n+        result.push_back(Pair(\"valid\",  false));\n+        result.push_back(Pair(\"reason\", \"circular transaction dependency\"));\n+        return result;\n+    }\n+\n+    // Create the dummy block\n+    CScript scriptDummy = CScript() << OP_TRUE;\n+    std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(scriptDummy, true, false));\n+    CBlock* pblock = &pblocktemplate->block;\n+\n+    // Add all of the transactions\n+    pblock->vtx.reserve(1 + ordered_tx.size());\n+    pblock->vtx.insert(pblock->vtx.begin() + 1, ordered_tx.begin(), ordered_tx.end());\n+\n+    // Check if that block would be valid (modulo PoW and merkle root checks)\n+    CBlockIndex* const index_prev = chainActive.Tip();\n+    CValidationState state;\n+    bool res = TestBlockValidity(state, Params(), *pblock, index_prev, false, false);\n+\n+    if (!res) {\n+        result.push_back(Pair(\"valid\",  false));\n+        if (state.IsInvalid()) {\n+            result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n+        } else {\n+            result.push_back(Pair(\"reason\", \"unknown consensus error\"));\n+        }\n+    } else {\n+        result.push_back(Pair(\"valid\",  true));\n+        result.push_back(Pair(\"reason\", \"transaction(s) appear to be valid\"));\n+    }\n+\n+    return result;\n+}\n+\n UniValue sendrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n@@ -937,7 +1157,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         CValidationState state;\n         bool fMissingInputs;\n         bool fLimitFree = true;\n-        if (!AcceptToMemoryPool(mempool, state, std::move(tx), fLimitFree, &fMissingInputs, nullptr, false, nMaxRawTxFee)) {\n+        if (!AcceptToMemoryPool(mempool, state, std::move(tx), fLimitFree, &fMissingInputs, nullptr, false, false, nMaxRawTxFee)) {\n             if (state.IsInvalid()) {\n                 throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n             } else {\n@@ -969,10 +1189,11 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   {\"hexstring\"} },\n     { \"rawtransactions\",    \"decodescript\",           &decodescript,           {\"hexstring\"} },\n     { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     {\"hexstring\",\"allowhighfees\"} },\n+    { \"rawtransactions\",    \"verifyrawtransactions\",  &verifyrawtransactions,  {\"transactions\",\"use_local_policy\"} },\n     { \"rawtransactions\",    \"combinerawtransaction\",  &combinerawtransaction,  {\"txs\"} },\n     { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n \n-    { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          {\"txids\", \"blockhash\"} },\n+    { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          {\"txids\",\"blockhash\"} },\n     { \"blockchain\",         \"verifytxoutproof\",       &verifytxoutproof,       {\"proof\"} },\n };\n "
      },
      {
        "sha": "85d21388ea1f9c1682fc7765561c8ffa1747b14f",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -49,6 +49,12 @@ BOOST_AUTO_TEST_CASE(rpc_rawparams)\n     BOOST_CHECK_THROW(CallRPC(\"getrawtransaction not_hex\"), std::runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"getrawtransaction a3b807410df0b60fcb9736768df5823938b2f838694939ba45f3c0a1bff150ed not_int\"), std::runtime_error);\n \n+    BOOST_CHECK_THROW(CallRPC(\"verifyrawtransactions\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"verifyrawtransactions not_array\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"verifyrawtransactions [] not_bool\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"verifyrawtransactions [not_hex]\"), std::runtime_error);\n+    BOOST_CHECK_THROW(CallRPC(\"verifyrawtransactions [not_hex] true\"), std::runtime_error);\n+\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction\"), std::runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction null null\"), std::runtime_error);\n     BOOST_CHECK_THROW(CallRPC(\"createrawtransaction not_array\"), std::runtime_error);"
      },
      {
        "sha": "bb0185ecd3ef6f282920eee80a1a04c76aaa5bb4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 34,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -442,7 +442,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n \n static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n+                              bool fOverrideMempoolLimit, bool fDryRun, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n {\n     const CTransaction& tx = *ptx;\n     const uint256 hash = tx.GetHash();\n@@ -839,48 +839,57 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             }\n         }\n \n-        // Remove conflicting transactions from the mempool\n-        for (const CTxMemPool::txiter it : allConflicting)\n-        {\n-            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n-                    it->GetTx().GetHash().ToString(),\n-                    hash.ToString(),\n-                    FormatMoney(nModifiedFees - nConflictingFees),\n-                    (int)nSize - (int)nConflictingSize);\n-            if (plTxnReplaced)\n-                plTxnReplaced->push_back(it->GetSharedTx());\n-        }\n-        pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n-\n-        // This transaction should only count for fee estimation if it isn't a\n-        // BIP 125 replacement transaction (may not be widely supported), the\n-        // node is not behind, and the transaction is not dependent on any other\n-        // transactions in the mempool.\n-        bool validForFeeEstimation = !fReplacementTransaction && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);\n-\n-        // Store transaction in memory\n-        pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);\n-\n-        // trim mempool and check if tx was trimmed\n-        if (!fOverrideMempoolLimit) {\n-            LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n-            if (!pool.exists(hash))\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+        if (!fDryRun) {\n+            // Remove conflicting transactions from the mempool\n+            for (const CTxMemPool::txiter it : allConflicting) {\n+                LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+                        it->GetTx().GetHash().ToString(),\n+                        hash.ToString(),\n+                        FormatMoney(nModifiedFees - nConflictingFees),\n+                        (int)nSize - (int)nConflictingSize);\n+                if (plTxnReplaced)\n+                    plTxnReplaced->push_back(it->GetSharedTx());\n+            }\n+            pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n+\n+            // This transaction should only count for fee estimation if it isn't a\n+            // BIP 125 replacement transaction (may not be widely supported), the\n+            // node is not behind, and the transaction is not dependent on any other\n+            // transactions in the mempool.\n+            bool validForFeeEstimation = !fReplacementTransaction && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);\n+\n+            // Store transaction in memory\n+            pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);\n+\n+            // trim mempool and check if tx was trimmed\n+            if (!fOverrideMempoolLimit) {\n+                // We don't have this failure mode in dry-run mode since we aren't\n+                // adding the transaction to the mempool in the first place\n+                LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+                if (!pool.exists(hash))\n+                    return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+            }\n         }\n     }\n \n-    GetMainSignals().TransactionAddedToMempool(ptx);\n+    if (!fDryRun) {\n+        GetMainSignals().TransactionAddedToMempool(ptx);\n+    }\n \n     return true;\n }\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n+                        bool fOverrideMempoolLimit, bool fDryRun, const CAmount nAbsurdFee)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);\n+    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, fDryRun, nAbsurdFee, coins_to_uncache);\n+    if (fDryRun) {\n+        // If we are just testing the transaction, don't mess with the caches\n+        return res;\n+    }\n     if (!res) {\n         for (const COutPoint& hashTx : coins_to_uncache)\n             pcoinsTip->Uncache(hashTx);\n@@ -893,10 +902,10 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n \n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n+                        bool fOverrideMempoolLimit, bool fDryRun, const CAmount nAbsurdFee)\n {\n     const CChainParams& chainparams = Params();\n-    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee);\n+    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, fDryRun, nAbsurdFee);\n }\n \n /** Return transaction in txOut, and if it was found inside a block, its hash is placed in hashBlock */\n@@ -4305,7 +4314,7 @@ bool LoadMempool(void)\n             CValidationState state;\n             if (nTime + nExpiryTimeout > nNow) {\n                 LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, nullptr, nTime, nullptr, false, 0);\n+                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, nullptr, nTime, nullptr, false, false, 0);\n                 if (state.IsValid()) {\n                     ++count;\n                 } else {"
      },
      {
        "sha": "8f29b54407b81995d1dfafac781cbc2d846de240",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -301,7 +301,7 @@ void PruneBlockFilesManual(int nManualPruneHeight);\n  * plTxnReplaced will be appended to with all transactions replaced from mempool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced = nullptr,\n-                        bool fOverrideMempoolLimit=false, const CAmount nAbsurdFee=0);\n+                        bool fOverrideMempoolLimit=false, bool fDryRun=false, const CAmount nAbsurdFee=0);\n \n /** Convert CValidationState to a human-readable message for logging */\n std::string FormatStateMessage(const CValidationState &state);"
      },
      {
        "sha": "3a4a9ca1cf70efe1dbef22728baceae34b4de60d",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -4021,5 +4021,5 @@ int CMerkleTx::GetBlocksToMaturity() const\n \n bool CMerkleTx::AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state)\n {\n-    return ::AcceptToMemoryPool(mempool, state, tx, true, nullptr, nullptr, false, nAbsurdFee);\n+    return ::AcceptToMemoryPool(mempool, state, tx, true, nullptr, nullptr, false, false, nAbsurdFee);\n }"
      },
      {
        "sha": "1ce75dddfb0bd9799b477e09b61b487f30fb6252",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 176,
        "deletions": 2,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99b1800ce9e57298fd67dacedc59c3d3b1230138/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99b1800ce9e57298fd67dacedc59c3d3b1230138/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "patch": "@@ -35,17 +35,176 @@ def run_test(self):\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.5)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.0)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0)\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),4.0)\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),3.0)\n         self.sync_all()\n         self.nodes[0].generate(5)\n         self.sync_all()\n \n+        unspent = self.nodes[2].listunspent()\n+\n+        fivebtc  = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"5.0\")][0]\n+        fourbtc  = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"4.0\")][0]\n+        threebtc = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"3.0\")][0]\n+\n+        #########################################\n+        # {create|verify|send}rawtransaction with valid or empty transaction #\n+        #########################################\n+        inputs  = [ {'txid' : fivebtc[\"txid\"], 'vout' : fivebtc[\"vout\"]} ]\n+        outputs = { self.nodes[0].getnewaddress(): 4.9 }\n+        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n+\n+        # This transaction is not signed and thus should not validate\n+        res = self.nodes[2].verifyrawtransactions([rawtx])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"mandatory-script-verify\" in res['reason'], True)\n+\n+        # Sign the transaction\n+        rawtx = self.nodes[2].signrawtransaction(rawtx)\n+\n+        # This transaction is signed and valid, so verifyrawtransaction should succeed\n+        res = self.nodes[2].verifyrawtransactions([rawtx['hex']])\n+        assert_equal(res['valid'], True)\n+        assert_equal(\"appear to be valid\" in res['reason'], True)\n+\n+        # Verifying no transactions should succeed\n+        res = self.nodes[2].verifyrawtransactions([])\n+        assert_equal(res['valid'], True)\n+\n+        res = self.nodes[2].verifyrawtransactions([], False)\n+        assert_equal(res['valid'], True)\n+\n+        # Add transaction to mempool\n+        assert_equal(len(self.nodes[2].getrawmempool()), 0)\n+        self.nodes[2].sendrawtransaction(rawtx['hex'])\n+\n+        # mempool should have one entry now\n+        assert_equal(len(self.nodes[2].getrawmempool()), 1)\n+\n+        # verifyrawtransactions should fail now since the tx is already in the mempool\n+        res = self.nodes[2].verifyrawtransactions([rawtx['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"mempool\" in res['reason'], True)\n+\n+        # mempool should still have one entry (should not be touched by verifyrawtransaction)\n+        assert_equal(len(self.nodes[2].getrawmempool()), 1)\n+\n+        # Mine the transaction\n+        self.sync_all()\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+\n+        # Once confirmed, should no longer be spendable\n+        res = self.nodes[2].verifyrawtransactions([rawtx['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"chain\" in res['reason'], True)\n+\n+        #########################################\n+        # {create|verify|send}rawtransaction with verifying multiple tx/mempool ancestor #\n+        #########################################\n+        inputs  = [ {'txid' : fourbtc[\"txid\"], 'vout' : fourbtc[\"vout\"]} ]\n+        outputs = { self.nodes[2].getnewaddress(): 3.9 }\n+        rawtx0  = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawtx0  = self.nodes[2].signrawtransaction(rawtx0)\n+\n+        # This transaction is signed and valid, so verifyrawtransaction should succeed\n+        res = self.nodes[2].verifyrawtransactions([rawtx0['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        txdec = self.nodes[2].decoderawtransaction(rawtx0[\"hex\"])\n+\n+        # Create another transaction dependent on the first\n+        inputs  = [ {'txid' : txdec[\"txid\"], 'vout' : 0} ]\n+        outputs = { self.nodes[2].getnewaddress(): 3.8 }\n+        rawtx1  = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawtx1  = self.nodes[2].signrawtransaction(rawtx1, [{\"txid\": txdec[\"txid\"], \"vout\": 0,\n+                                    \"scriptPubKey\": txdec[\"vout\"][0][\"scriptPubKey\"][\"hex\"]}])\n+\n+        txdec = self.nodes[2].decoderawtransaction(rawtx1[\"hex\"])\n+\n+        # One more, so we can test multiple mempool ancestors\n+        inputs  = [ {'txid' : txdec[\"txid\"], 'vout' : 0} ]\n+        outputs = { self.nodes[2].getnewaddress(): 3.7 }\n+        rawtx2  = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawtx2  = self.nodes[2].signrawtransaction(rawtx2, [{\"txid\": txdec[\"txid\"], \"vout\": 0,\n+                                    \"scriptPubKey\": txdec[\"vout\"][0][\"scriptPubKey\"][\"hex\"]}])\n+\n+        # We don't know about the first tx yet, so verifyrawtransaction should fail\n+        res = self.nodes[2].verifyrawtransactions([rawtx1['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"missingorspent\" in res['reason'], True)\n+        res = self.nodes[2].verifyrawtransactions([rawtx2['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"missingorspent\" in res['reason'], True)\n+\n+        # Passing 0, 1, 2 or 0, 1 should work, though\n+        res = self.nodes[2].verifyrawtransactions([rawtx0['hex'], rawtx1['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        res = self.nodes[2].verifyrawtransactions([rawtx0['hex'], rawtx1['hex'], rawtx2['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        # Order shouldn't matter\n+        res = self.nodes[2].verifyrawtransactions([rawtx1['hex'], rawtx0['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        res = self.nodes[2].verifyrawtransactions([rawtx2['hex'], rawtx0['hex'], rawtx1['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        # Add the first transaction to the mempool\n+        self.nodes[2].sendrawtransaction(rawtx0['hex'])\n+\n+        # Now that the first tx is in the mempool, verifyrawtransactions for the second should succeed\n+        res = self.nodes[2].verifyrawtransactions([rawtx1['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        # Third should still fail\n+        res = self.nodes[2].verifyrawtransactions([rawtx2['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"missingorspent\" in res['reason'], True)\n+\n+        # Add the second transaction to the mempool\n+        self.nodes[2].sendrawtransaction(rawtx1['hex'])\n+\n+        # Third should work now\n+        res = self.nodes[2].verifyrawtransactions([rawtx2['hex']])\n+        assert_equal(res['valid'], True)\n+\n+        #########################################\n+        # {create|verify}rawtransaction with violation of local rules #\n+        #########################################\n+\n+        inputs  = [ {'txid' : threebtc[\"txid\"], 'vout' : threebtc[\"vout\"]} ]\n+        outputs = { self.nodes[2].getnewaddress(): 3.0 } # no fee\n+\n+        nofee = self.nodes[2].createrawtransaction(inputs, outputs)\n+        nofee = self.nodes[2].signrawtransaction(nofee)\n+\n+        # There is no fee, so verifyrawtransactions should fail if use_local_rules is default or true\n+        res = self.nodes[2].verifyrawtransactions([nofee['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"relay fee\" in res['reason'], True)\n+\n+        res = self.nodes[2].verifyrawtransactions([nofee['hex']], True)\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"relay fee\" in res['reason'], True)\n+\n+        # But this transaction would be fine if it were mined into a block\n+        res = self.nodes[2].verifyrawtransactions([nofee['hex']], False)\n+        assert_equal(res['valid'], True)\n+\n         #########################################\n-        # sendrawtransaction with missing input #\n+        # {create|verify|send}rawtransaction with missing input #\n         #########################################\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1}] #won't exists\n         outputs = { self.nodes[0].getnewaddress() : 4.998 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n-        rawtx   = self.nodes[2].signrawtransaction(rawtx)\n+        rawtx = self.nodes[2].signrawtransaction(rawtx)\n+\n+        # This transaction is missing inputs and thus should not validate\n+        res = self.nodes[2].verifyrawtransactions([rawtx['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"missingorspent\" in res['reason'], True)\n \n         # This will raise an exception since there are missing inputs\n         assert_raises_jsonrpc(-25, \"Missing inputs\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n@@ -92,6 +251,11 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n+        # verifyrawtransaction should fail since output was already spent\n+        res = self.nodes[0].verifyrawtransactions([decTx['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"in chain\" in res['reason'], True)\n+\n         #THIS IS A INCOMPLETE FEATURE\n         #NODE2 HAS TWO OF THREE KEY AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n         assert_equal(self.nodes[2].getbalance(), bal) #for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n@@ -111,8 +275,18 @@ def run_test(self):\n         rawTxPartialSigned = self.nodes[1].signrawtransaction(rawTx, inputs)\n         assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n \n+        # verifyrawtransaction should fail since output is not fully signed\n+        res = self.nodes[0].verifyrawtransactions([rawTxPartialSigned['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"mandatory-script-verify\" in res['reason'], True)\n+\n         rawTxSigned = self.nodes[2].signrawtransaction(rawTx, inputs)\n         assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n+\n+        # verifyrawtransaction should succeed since output is fully signed\n+        res = self.nodes[0].verifyrawtransactions([rawTxSigned['hex']])\n+        assert_equal(res['valid'], True)\n+\n         self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n         rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n         self.sync_all()"
      }
    ]
  },
  {
    "sha": "95eb8b6f4c4c6680ac6108344383f9df694446fd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NWViOGI2ZjRjNGM2NjgwYWM2MTA4MzQ0MzgzZjlkZjY5NDQ0NmZk",
    "commit": {
      "author": {
        "name": "Max Justicz",
        "email": "max@justi.cz",
        "date": "2017-09-06T09:37:53Z"
      },
      "committer": {
        "name": "Max Justicz",
        "email": "max@justi.cz",
        "date": "2017-09-06T09:37:53Z"
      },
      "message": "add dryRunMapTx to mempool",
      "tree": {
        "sha": "b2fb1f745e16740abf51f302a786d2caa20a0a96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2fb1f745e16740abf51f302a786d2caa20a0a96"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95eb8b6f4c4c6680ac6108344383f9df694446fd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95eb8b6f4c4c6680ac6108344383f9df694446fd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/95eb8b6f4c4c6680ac6108344383f9df694446fd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95eb8b6f4c4c6680ac6108344383f9df694446fd/comments",
    "author": {
      "login": "justicz",
      "id": 17011613,
      "node_id": "MDQ6VXNlcjE3MDExNjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17011613?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/justicz",
      "html_url": "https://github.com/justicz",
      "followers_url": "https://api.github.com/users/justicz/followers",
      "following_url": "https://api.github.com/users/justicz/following{/other_user}",
      "gists_url": "https://api.github.com/users/justicz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/justicz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/justicz/subscriptions",
      "organizations_url": "https://api.github.com/users/justicz/orgs",
      "repos_url": "https://api.github.com/users/justicz/repos",
      "events_url": "https://api.github.com/users/justicz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/justicz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "justicz",
      "id": 17011613,
      "node_id": "MDQ6VXNlcjE3MDExNjEz",
      "avatar_url": "https://avatars.githubusercontent.com/u/17011613?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/justicz",
      "html_url": "https://github.com/justicz",
      "followers_url": "https://api.github.com/users/justicz/followers",
      "following_url": "https://api.github.com/users/justicz/following{/other_user}",
      "gists_url": "https://api.github.com/users/justicz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/justicz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/justicz/subscriptions",
      "organizations_url": "https://api.github.com/users/justicz/orgs",
      "repos_url": "https://api.github.com/users/justicz/repos",
      "events_url": "https://api.github.com/users/justicz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/justicz/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99b1800ce9e57298fd67dacedc59c3d3b1230138",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99b1800ce9e57298fd67dacedc59c3d3b1230138"
      }
    ],
    "stats": {
      "total": 195,
      "additions": 120,
      "deletions": 75
    },
    "files": [
      {
        "sha": "fc7a37995c349515dcc4d86345ebedd206f223a6",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 64,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=95eb8b6f4c4c6680ac6108344383f9df694446fd",
        "patch": "@@ -948,63 +948,6 @@ UniValue verifyrawtransactions(const JSONRPCRequest& request)\n         transactions.insert(std::pair<uint256, CTransactionRef>(ref->GetHash(), ref));\n     }\n \n-    // Should we check against our local policy, or just consensus rules?\n-    if (use_local_policy) {\n-        // For each input transaction\n-        for (auto const& hash_tx : transactions) {\n-            CTransactionRef tx(hash_tx.second);\n-            const uint256& hash = tx->GetHash();\n-            CCoinsViewCache& view = *pcoinsTip;\n-\n-            // Fail fast if we have an unspent output from this transaction\n-            // already in our wallet, which indicates right away that this is a\n-            // duplicate tx (copied from sendrawtransaction)\n-            bool have_chain = false;\n-            for (size_t o = 0; !have_chain && o < tx->vout.size(); o++) {\n-                const Coin& existingCoin = view.AccessCoin(COutPoint(hash, o));\n-                have_chain = !existingCoin.IsSpent();\n-            }\n-\n-            // Check if transaction already exists in mempool\n-            bool have_mempool = mempool.exists(hash);\n-\n-            if (have_chain) {\n-                result.push_back(Pair(\"valid\",  false));\n-                result.push_back(Pair(\"reason\", \"transaction already in chain\"));\n-                return result;\n-            }\n-\n-            if (have_mempool) {\n-                result.push_back(Pair(\"valid\",  false));\n-                result.push_back(Pair(\"reason\", \"transaction already in mempool\"));\n-                return result;\n-            }\n-\n-            // If we are reasonably confident that this transaction is not a\n-            // duplicate, do an AcceptToMemoryPool dry run\n-            CValidationState state;\n-            bool missing_inputs;\n-\n-            // Call AcceptToMemoryPool with the dryrun flag set\n-            if (!AcceptToMemoryPool(mempool, state, std::move(tx), true, &missing_inputs, nullptr, false, true, 0)) {\n-                if (state.IsInvalid()) {\n-                    result.push_back(Pair(\"valid\",  false));\n-                    result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n-                    return result;\n-                } else if (missing_inputs) {\n-                    // We want to ignore the \"missing inputs\" case here, since the input\n-                    // may actually be in the mempool. If the input is truly missing, we\n-                    // will find out later after the ancestor and consensus check.\n-                    continue;\n-                }\n-                // Unknown error\n-                result.push_back(Pair(\"valid\",  false));\n-                result.push_back(Pair(\"reason\", \"couldn't accept transaction to mempool\"));\n-                return result;\n-            }\n-        }\n-    }\n-\n     // Find the ancestors of all of the transactions, including ones in mempool\n     std::map<uint256, CTransactionRef> ancestors;\n     for (auto const& hash_tx : transactions) {\n@@ -1041,6 +984,7 @@ UniValue verifyrawtransactions(const JSONRPCRequest& request)\n \n     // Now, come up with a valid topological sort over the transactions\n     std::vector<CTransactionRef> ordered_tx;\n+    std::vector<CTransactionRef> block_tx;\n \n     // Iterate over the transactions, removing all of those with no\n     // dependencies in the list each time. Technically, this is worst\n@@ -1063,7 +1007,11 @@ UniValue verifyrawtransactions(const JSONRPCRequest& request)\n             }\n             if (is_independent) {\n                 found_independent = true;\n-                ordered_tx.push_back(tx);\n+                // Don't insert mempool ancestors\n+                if (ancestors.find(hash_tx->first) == ancestors.end()) {\n+                    ordered_tx.push_back(tx);\n+                }\n+                block_tx.push_back(tx);\n                 hash_tx = transactions.erase(hash_tx);\n             } else {\n                 hash_tx++;\n@@ -1078,19 +1026,78 @@ UniValue verifyrawtransactions(const JSONRPCRequest& request)\n         return result;\n     }\n \n+    // Should we check against our local policy, or just consensus rules?\n+    if (use_local_policy) {\n+        // For each input transaction\n+        for (auto const& tx : ordered_tx) {\n+            const uint256& hash = tx->GetHash();\n+            CCoinsViewCache& view = *pcoinsTip;\n+\n+            // Fail fast if we have an unspent output from this transaction\n+            // already in our wallet, which indicates right away that this is a\n+            // duplicate tx (copied from sendrawtransaction)\n+            bool have_chain = false;\n+            for (size_t o = 0; !have_chain && o < tx->vout.size(); o++) {\n+                const Coin& existing_coin = view.AccessCoin(COutPoint(hash, o));\n+                have_chain = !existing_coin.IsSpent();\n+            }\n+\n+            // Check if transaction already exists in mempool\n+            bool have_mempool = mempool.exists(hash);\n+\n+            if (have_chain) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in chain\"));\n+                return result;\n+            }\n+\n+            if (have_mempool) {\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"transaction already in mempool\"));\n+                return result;\n+            }\n+\n+            // If we are reasonably confident that this transaction is not a\n+            // duplicate, do an AcceptToMemoryPool dry run\n+            CValidationState state;\n+            bool missing_inputs;\n+\n+            // Call AcceptToMemoryPool with the dryrun flag set\n+            if (!AcceptToMemoryPool(mempool, state, std::move(tx), true, &missing_inputs, nullptr, false, true, 0)) {\n+                if (state.IsInvalid()) {\n+                    result.push_back(Pair(\"valid\",  false));\n+                    result.push_back(Pair(\"reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason())));\n+                    return result;\n+                } else if (missing_inputs) {\n+                    // We want to ignore the \"missing inputs\" case here, since the input\n+                    // may actually be in the mempool. If the input is truly missing, we\n+                    // will find out later after the ancestor and consensus check.\n+                    continue;\n+                }\n+                // Unknown error\n+                result.push_back(Pair(\"valid\",  false));\n+                result.push_back(Pair(\"reason\", \"couldn't accept transaction to mempool\"));\n+                return result;\n+            }\n+        }\n+    }\n+\n+    // Clean up the dryRunMap\n+    mempool.dryRunMapTx.clear();\n+\n     // Create the dummy block\n-    CScript scriptDummy = CScript() << OP_TRUE;\n-    std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(scriptDummy, true, false));\n-    CBlock* pblock = &pblocktemplate->block;\n+    CScript script_dummy = CScript() << OP_TRUE;\n+    std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(script_dummy, true, false));\n+    CBlock* block = &pblocktemplate->block;\n \n     // Add all of the transactions\n-    pblock->vtx.reserve(1 + ordered_tx.size());\n-    pblock->vtx.insert(pblock->vtx.begin() + 1, ordered_tx.begin(), ordered_tx.end());\n+    block->vtx.reserve(1 + block_tx.size());\n+    block->vtx.insert(block->vtx.begin() + 1, block_tx.begin(), block_tx.end());\n \n     // Check if that block would be valid (modulo PoW and merkle root checks)\n     CBlockIndex* const index_prev = chainActive.Tip();\n     CValidationState state;\n-    bool res = TestBlockValidity(state, Params(), *pblock, index_prev, false, false);\n+    bool res = TestBlockValidity(state, Params(), *block, index_prev, false, false);\n \n     if (!res) {\n         result.push_back(Pair(\"valid\",  false));"
      },
      {
        "sha": "20ccd3919f49f4d76c35b1e778c328502f200bc2",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 6,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=95eb8b6f4c4c6680ac6108344383f9df694446fd",
        "patch": "@@ -357,13 +357,19 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate, bool dryRun)\n {\n     NotifyEntryAdded(entry.GetSharedTx());\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n+\n+    if (dryRun) {\n+        dryRunMapTx.insert(entry);\n+        return true;\n+    }\n+\n     indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n     mapLinks.insert(make_pair(newit, TxLinks()));\n \n@@ -815,10 +821,18 @@ std::vector<TxMempoolInfo> CTxMemPool::infoAll() const\n CTransactionRef CTxMemPool::get(const uint256& hash) const\n {\n     LOCK(cs);\n+\n     indexed_transaction_set::const_iterator i = mapTx.find(hash);\n-    if (i == mapTx.end())\n-        return nullptr;\n-    return i->GetSharedTx();\n+    if (i != mapTx.end()) {\n+        return i->GetSharedTx();\n+    }\n+\n+    i = dryRunMapTx.find(hash);\n+    if (i != dryRunMapTx.end()) {\n+        return i->GetSharedTx();\n+    }\n+\n+    return nullptr;\n }\n \n TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n@@ -932,14 +946,14 @@ int CTxMemPool::Expire(int64_t time) {\n     return stage.size();\n }\n \n-bool CTxMemPool::addUnchecked(const uint256&hash, const CTxMemPoolEntry &entry, bool validFeeEstimate)\n+bool CTxMemPool::addUnchecked(const uint256&hash, const CTxMemPoolEntry &entry, bool validFeeEstimate, bool dryRun)\n {\n     LOCK(cs);\n     setEntries setAncestors;\n     uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n     CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n-    return addUnchecked(hash, entry, setAncestors, validFeeEstimate);\n+    return addUnchecked(hash, entry, setAncestors, validFeeEstimate, dryRun);\n }\n \n void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)"
      },
      {
        "sha": "d20db84911feb1a3a4929956b0e03e03c8198a9c",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=95eb8b6f4c4c6680ac6108344383f9df694446fd",
        "patch": "@@ -463,6 +463,7 @@ class CTxMemPool\n \n     mutable CCriticalSection cs;\n     indexed_transaction_set mapTx;\n+    indexed_transaction_set dryRunMapTx;\n \n     typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n     std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx witness hashes/entries in mapTx, in random order\n@@ -513,8 +514,8 @@ class CTxMemPool\n     // to track size/count of descendant transactions.  First version of\n     // addUnchecked can be used to have it call CalculateMemPoolAncestors(), and\n     // then invoke the second version.\n-    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool validFeeEstimate = true);\n-    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate = true);\n+    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool validFeeEstimate = true, bool dryRun = false);\n+    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate = true, bool dryRun = false);\n \n     void removeRecursive(const CTransaction &tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n     void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);"
      },
      {
        "sha": "f5fe4731b02de3e3029fb20b850a749f4e4c15f2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95eb8b6f4c4c6680ac6108344383f9df694446fd/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=95eb8b6f4c4c6680ac6108344383f9df694446fd",
        "patch": "@@ -570,7 +570,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // be mined yet.\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp, false))\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n         }\n \n@@ -851,6 +851,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     plTxnReplaced->push_back(it->GetSharedTx());\n             }\n             pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n+        }\n \n             // This transaction should only count for fee estimation if it isn't a\n             // BIP 125 replacement transaction (may not be widely supported), the\n@@ -859,8 +860,9 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             bool validForFeeEstimation = !fReplacementTransaction && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);\n \n             // Store transaction in memory\n-            pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);\n+            pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation, fDryRun);\n \n+        if (!fDryRun) {\n             // trim mempool and check if tx was trimmed\n             if (!fOverrideMempoolLimit) {\n                 // We don't have this failure mode in dry-run mode since we aren't"
      },
      {
        "sha": "cfdef35eea592e494acc0abe02618c574a9b06ef",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 22,
        "deletions": 1,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95eb8b6f4c4c6680ac6108344383f9df694446fd/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95eb8b6f4c4c6680ac6108344383f9df694446fd/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=95eb8b6f4c4c6680ac6108344383f9df694446fd",
        "patch": "@@ -37,6 +37,7 @@ def run_test(self):\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),4.0)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),3.0)\n+        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),2.0)\n         self.sync_all()\n         self.nodes[0].generate(5)\n         self.sync_all()\n@@ -46,6 +47,7 @@ def run_test(self):\n         fivebtc  = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"5.0\")][0]\n         fourbtc  = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"4.0\")][0]\n         threebtc = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"3.0\")][0]\n+        twobtc   = [tx for tx in unspent if tx[\"amount\"] == Decimal(\"2.0\")][0]\n \n         #########################################\n         # {create|verify|send}rawtransaction with valid or empty transaction #\n@@ -122,17 +124,28 @@ def run_test(self):\n \n         txdec = self.nodes[2].decoderawtransaction(rawtx1[\"hex\"])\n \n-        # One more, so we can test multiple mempool ancestors\n+        # Another, so we can test multiple mempool ancestors\n         inputs  = [ {'txid' : txdec[\"txid\"], 'vout' : 0} ]\n         outputs = { self.nodes[2].getnewaddress(): 3.7 }\n         rawtx2  = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawtx2  = self.nodes[2].signrawtransaction(rawtx2, [{\"txid\": txdec[\"txid\"], \"vout\": 0,\n                                     \"scriptPubKey\": txdec[\"vout\"][0][\"scriptPubKey\"][\"hex\"]}])\n \n+        txdec = self.nodes[2].decoderawtransaction(rawtx2[\"hex\"])\n+\n+        # One last one to test that we can do local policy checks on transactions\n+        # that don't have mempool ancestors\n+        inputs  = [ {'txid' : txdec[\"txid\"], 'vout' : 0} ]\n+        outputs = { self.nodes[2].getnewaddress(): 3.7 } # no fee\n+        rawtx3  = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawtx3  = self.nodes[2].signrawtransaction(rawtx3, [{\"txid\": txdec[\"txid\"], \"vout\": 0,\n+                                    \"scriptPubKey\": txdec[\"vout\"][0][\"scriptPubKey\"][\"hex\"]}])\n+\n         # We don't know about the first tx yet, so verifyrawtransaction should fail\n         res = self.nodes[2].verifyrawtransactions([rawtx1['hex']])\n         assert_equal(res['valid'], False)\n         assert_equal(\"missingorspent\" in res['reason'], True)\n+\n         res = self.nodes[2].verifyrawtransactions([rawtx2['hex']])\n         assert_equal(res['valid'], False)\n         assert_equal(\"missingorspent\" in res['reason'], True)\n@@ -151,6 +164,14 @@ def run_test(self):\n         res = self.nodes[2].verifyrawtransactions([rawtx2['hex'], rawtx0['hex'], rawtx1['hex']])\n         assert_equal(res['valid'], True)\n \n+        # Transaction with insufficient fee should be caught, but not if use_local_policy is false\n+        res = self.nodes[2].verifyrawtransactions([rawtx2['hex'], rawtx0['hex'], rawtx1['hex'], rawtx3['hex']])\n+        assert_equal(res['valid'], False)\n+        assert_equal(\"relay fee\" in res['reason'], True)\n+\n+        res = self.nodes[2].verifyrawtransactions([rawtx2['hex'], rawtx0['hex'], rawtx1['hex'], rawtx3['hex']], False)\n+        assert_equal(res['valid'], True)\n+\n         # Add the first transaction to the mempool\n         self.nodes[2].sendrawtransaction(rawtx0['hex'])\n "
      }
    ]
  }
]