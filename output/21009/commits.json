[
  {
    "sha": "d831e711cab83c70bf2ded62fe33f484844e73dd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODMxZTcxMWNhYjgzYzcwYmYyZGVkNjJmZTMzZjQ4NDg0NGU3M2Rk",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-01-24T23:14:15Z"
      },
      "committer": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-04-21T23:09:14Z"
      },
      "message": "[validation] RewindBlockIndex no longer needed\n\nInstead of rewinding blocks, we request that the user restarts with\n-reindex",
      "tree": {
        "sha": "10c6e33cf3a3814dd73ec186d442d217800cb149",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10c6e33cf3a3814dd73ec186d442d217800cb149"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d831e711cab83c70bf2ded62fe33f484844e73dd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d831e711cab83c70bf2ded62fe33f484844e73dd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d831e711cab83c70bf2ded62fe33f484844e73dd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d831e711cab83c70bf2ded62fe33f484844e73dd/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "92cf3a22e3c79ce28c5cc9dcbc18348c43cbe4d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92cf3a22e3c79ce28c5cc9dcbc18348c43cbe4d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/92cf3a22e3c79ce28c5cc9dcbc18348c43cbe4d9"
      }
    ],
    "stats": {
      "total": 208,
      "additions": 43,
      "deletions": 165
    },
    "files": [
      {
        "sha": "a1c026f806865b71bcc323f64570c6be1e9f5f06",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 20,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d831e711cab83c70bf2ded62fe33f484844e73dd/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d831e711cab83c70bf2ded62fe33f484844e73dd/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d831e711cab83c70bf2ded62fe33f484844e73dd",
        "patch": "@@ -1698,29 +1698,17 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n                 break;\n             }\n \n-            bool failed_rewind{false};\n-            // Can't hold cs_main while calling RewindBlockIndex, so retrieve the relevant\n-            // chainstates beforehand.\n-            for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {\n-                if (!fReset) {\n-                    // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n-                    // It both disconnects blocks based on the chainstate, and drops block data in\n-                    // BlockIndex() based on lack of available witness data.\n-                    uiInterface.InitMessage(_(\"Rewinding blocks...\").translated);\n-                    if (!chainstate->RewindBlockIndex(chainparams)) {\n-                        strLoadError = _(\n-                            \"Unable to rewind the database to a pre-fork state. \"\n-                            \"You will need to redownload the blockchain\");\n-                        failed_rewind = true;\n-                        break; // out of the per-chainstate loop\n-                    }\n+            if (!fReset) {\n+                LOCK(cs_main);\n+                auto chainstates{chainman.GetAll()};\n+                if (std::any_of(chainstates.begin(), chainstates.end(),\n+                                [&chainparams](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(chainparams); })) {\n+                    strLoadError = strprintf(_(\"Witness data for blocks after height %d requires validation. Please restart with -reindex.\"),\n+                                             chainparams.GetConsensus().SegwitHeight);\n+                    break;\n                 }\n             }\n \n-            if (failed_rewind) {\n-                break; // out of the chainstate activation do-while\n-            }\n-\n             bool failed_verification = false;\n \n             try {"
      },
      {
        "sha": "fdc7ef8845a16d619f849b47f8721ad48be1f74f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 130,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d831e711cab83c70bf2ded62fe33f484844e73dd/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d831e711cab83c70bf2ded62fe33f484844e73dd/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d831e711cab83c70bf2ded62fe33f484844e73dd",
        "patch": "@@ -4431,143 +4431,23 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n     return true;\n }\n \n-//! Helper for CChainState::RewindBlockIndex\n-void CChainState::EraseBlockData(CBlockIndex* index)\n+bool CChainState::NeedsRedownload(const CChainParams& params) const\n {\n     AssertLockHeld(cs_main);\n-    assert(!m_chain.Contains(index)); // Make sure this block isn't active\n-\n-    // Reduce validity\n-    index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n-    // Remove have-data flags.\n-    index->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n-    // Remove storage location.\n-    index->nFile = 0;\n-    index->nDataPos = 0;\n-    index->nUndoPos = 0;\n-    // Remove various other things\n-    index->nTx = 0;\n-    index->nChainTx = 0;\n-    index->nSequenceId = 0;\n-    // Make sure it gets written.\n-    setDirtyBlockIndex.insert(index);\n-    // Update indexes\n-    setBlockIndexCandidates.erase(index);\n-    auto ret = m_blockman.m_blocks_unlinked.equal_range(index->pprev);\n-    while (ret.first != ret.second) {\n-        if (ret.first->second == index) {\n-            m_blockman.m_blocks_unlinked.erase(ret.first++);\n-        } else {\n-            ++ret.first;\n-        }\n-    }\n-    // Mark parent as eligible for main chain again\n-    if (index->pprev && index->pprev->IsValid(BLOCK_VALID_TRANSACTIONS) && index->pprev->HaveTxsDownloaded()) {\n-        setBlockIndexCandidates.insert(index->pprev);\n-    }\n-}\n-\n-bool CChainState::RewindBlockIndex(const CChainParams& params)\n-{\n-    // Note that during -reindex-chainstate we are called with an empty m_chain!\n \n-    // First erase all post-segwit blocks without witness not in the main chain,\n-    // as this can we done without costly DisconnectTip calls. Active\n-    // blocks will be dealt with below (releasing cs_main in between).\n-    {\n-        LOCK(cs_main);\n-        for (const auto& entry : m_blockman.m_block_index) {\n-            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(entry.second)) {\n-                EraseBlockData(entry.second);\n-            }\n-        }\n-    }\n+    // At and above params.SegwitHeight, segwit consensus rules must be validated\n+    CBlockIndex* block{m_chain.Tip()};\n+    const int segwit_height{params.GetConsensus().SegwitHeight};\n \n-    // Find what height we need to reorganize to.\n-    CBlockIndex *tip;\n-    int nHeight = 1;\n-    {\n-        LOCK(cs_main);\n-        while (nHeight <= m_chain.Height()) {\n-            // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n-            // blocks in ConnectBlock, we don't need to go back and\n-            // re-download/re-verify blocks from before segwit actually activated.\n-            if (IsWitnessEnabled(m_chain[nHeight - 1], params.GetConsensus()) && !(m_chain[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n-                break;\n-            }\n-            nHeight++;\n-        }\n-\n-        tip = m_chain.Tip();\n-    }\n-    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n-\n-    BlockValidationState state;\n-    // Loop until the tip is below nHeight, or we reach a pruned block.\n-    while (!ShutdownRequested()) {\n-        {\n-            LOCK(cs_main);\n-            LOCK(m_mempool.cs);\n-            // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n-            assert(tip == m_chain.Tip());\n-            if (tip == nullptr || tip->nHeight < nHeight) break;\n-            if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n-                // If pruning, don't try rewinding past the HAVE_DATA point;\n-                // since older blocks can't be served anyway, there's\n-                // no need to walk further, and trying to DisconnectTip()\n-                // will fail (and require a needless reindex/redownload\n-                // of the blockchain).\n-                break;\n-            }\n-\n-            // Disconnect block\n-            if (!DisconnectTip(state, params, nullptr)) {\n-                return error(\"RewindBlockIndex: unable to disconnect block at height %i (%s)\", tip->nHeight, state.ToString());\n-            }\n-\n-            // Reduce validity flag and have-data flags.\n-            // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n-            // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n-            // Note: If we encounter an insufficiently validated block that\n-            // is on m_chain, it must be because we are a pruning node, and\n-            // this block or some successor doesn't HAVE_DATA, so we were unable to\n-            // rewind all the way.  Blocks remaining on m_chain at this point\n-            // must not have their validity reduced.\n-            EraseBlockData(tip);\n-\n-            tip = tip->pprev;\n-        }\n-        // Make sure the queue of validation callbacks doesn't grow unboundedly.\n-        LimitValidationInterfaceQueue();\n-\n-        // Occasionally flush state to disk.\n-        if (!FlushStateToDisk(params, state, FlushStateMode::PERIODIC)) {\n-            LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", state.ToString());\n-            return false;\n-        }\n-    }\n-\n-    {\n-        LOCK(cs_main);\n-        if (m_chain.Tip() != nullptr) {\n-            // We can't prune block index candidates based on our tip if we have\n-            // no tip due to m_chain being empty!\n-            PruneBlockIndexCandidates();\n-\n-            CheckBlockIndex(params.GetConsensus());\n-\n-            // FlushStateToDisk can possibly read ::ChainActive(). Be conservative\n-            // and skip it here, we're about to -reindex-chainstate anyway, so\n-            // it'll get called a bunch real soon.\n-            BlockValidationState state;\n-            if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n-                LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", state.ToString());\n-                return false;\n-            }\n+    while (block != nullptr && block->nHeight >= segwit_height) {\n+        if (!(block->nStatus & BLOCK_OPT_WITNESS)) {\n+            // block is insufficiently validated for a segwit client\n+            return true;\n         }\n+        block = block->pprev;\n     }\n \n-    return true;\n+    return false;\n }\n \n void CChainState::UnloadBlockIndex() {"
      },
      {
        "sha": "3c7f593c825f89e18d58599b3d34a253e752a167",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d831e711cab83c70bf2ded62fe33f484844e73dd/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d831e711cab83c70bf2ded62fe33f484844e73dd/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=d831e711cab83c70bf2ded62fe33f484844e73dd",
        "patch": "@@ -722,7 +722,9 @@ class CChainState\n \n     /** Replay blocks that aren't fully applied to the database. */\n     bool ReplayBlocks(const CChainParams& params);\n-    bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n+\n+    /** Whether the chain state needs to be redownloaded due to lack of witness data */\n+    [[nodiscard]] bool NeedsRedownload(const CChainParams& params) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n     bool LoadGenesisBlock(const CChainParams& chainparams);\n \n@@ -769,9 +771,6 @@ class CChainState\n \n     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    //! Mark a block as not having block data\n-    void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n     void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     void InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n "
      },
      {
        "sha": "14a4afc2d76e860a791e7364253a401ff53242af",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 22,
        "deletions": 11,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d831e711cab83c70bf2ded62fe33f484844e73dd/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d831e711cab83c70bf2ded62fe33f484844e73dd/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=d831e711cab83c70bf2ded62fe33f484844e73dd",
        "patch": "@@ -1956,22 +1956,33 @@ def test_non_standard_witness(self):\n     def test_upgrade_after_activation(self):\n         \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n \n-        self.restart_node(2, extra_args=[\"-segwitheight={}\".format(SEGWIT_HEIGHT)])\n+        # All nodes are caught up and node 2 is a pre-segwit node that will soon upgrade.\n+        for n in range(2):\n+            assert_equal(self.nodes[n].getblockcount(), self.nodes[2].getblockcount())\n+            assert softfork_active(self.nodes[n], \"segwit\")\n+        assert SEGWIT_HEIGHT < self.nodes[2].getblockcount()\n+        assert 'segwit' not in self.nodes[2].getblockchaininfo()['softforks']\n+\n+        # Restarting node 2 should result in a shutdown because the blockchain consists of\n+        # insufficiently validated blocks per segwit consensus rules.\n+        self.stop_node(2)\n+        with self.nodes[2].assert_debug_log(expected_msgs=[\n+                f\"Witness data for blocks after height {SEGWIT_HEIGHT} requires validation. Please restart with -reindex.\"], timeout=10):\n+            self.nodes[2].start([f\"-segwitheight={SEGWIT_HEIGHT}\"])\n+\n+        # As directed, the user restarts the node with -reindex\n+        self.start_node(2, extra_args=[\"-reindex\", f\"-segwitheight={SEGWIT_HEIGHT}\"])\n+\n+        # With the segwit consensus rules, the node is able to validate only up to SEGWIT_HEIGHT - 1\n+        assert_equal(self.nodes[2].getblockcount(), SEGWIT_HEIGHT - 1)\n         self.connect_nodes(0, 2)\n \n         # We reconnect more than 100 blocks, give it plenty of time\n+        # sync_blocks() also verifies the best block hash is the same for all nodes\n         self.sync_blocks(timeout=240)\n \n-        # Make sure that this peer thinks segwit has activated.\n-        assert softfork_active(self.nodes[2], 'segwit')\n-\n-        # Make sure this peer's blocks match those of node0.\n-        height = self.nodes[2].getblockcount()\n-        while height >= 0:\n-            block_hash = self.nodes[2].getblockhash(height)\n-            assert_equal(block_hash, self.nodes[0].getblockhash(height))\n-            assert_equal(self.nodes[0].getblock(block_hash), self.nodes[2].getblock(block_hash))\n-            height -= 1\n+        # The upgraded node should now have segwit activated\n+        assert softfork_active(self.nodes[2], \"segwit\")\n \n     @subtest  # type: ignore\n     def test_witness_sigops(self):"
      }
    ]
  }
]