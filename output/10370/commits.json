[
  {
    "sha": "2045ffebe1c885af2a2543eaa709da732f514577",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDQ1ZmZlYmUxYzg4NWFmMmEyNTQzZWFhNzA5ZGE3MzJmNTE0NTc3",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T18:58:32Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:36:44Z"
      },
      "message": "indexes: adds additional address, spent and timestamp indexes\n\nAdds new bitcoin.conf configuration options for three new indexes:\n-addressindex=1\n-spentindex=1\n-timestampindex=1\n\nThe addressindex records all changes to an address for retrieving txids, balances and\nunspent outputs for addresses. Changes are stored and sorted in block order. Both p2sh\nand p2pkh address types are supported. The index records two sets of key/value pairs.\nThe first records all activity and is useful for viewing transaction history and\nall changes. The second is specifically for retrieving unspent outputs by address, and\nis smaller as values are removed once they are spent.\n\nThe spentindex has multiple purposes and brings closer together inputs and outputs of\ntransactions. The main purpose is to efficiently determine the address and amount of\nan input's previous output. The second purpose is to be able to determine which\ninput spent an output.\n\nThe timestampindex keeps track of timestamps with block hashes and is useful for searching\nblocks by date instead of by height. This is useful for a block explorer that will give\nsearch options by date. The index uses logical time correction to make sure that the\nresults are sorted in block order. The logical time of a block is actual timestamp of the\nblock, unless it is less than (earlier) the previous block's logical time, and in that\ncase it is one second greater than the previous block's logical time.\n\nIncludes logical time fix by Chethan Krishna\n\nConflicts:\n\tsrc/main.cpp\n\tsrc/main.h\n\tsrc/txdb.cpp\n\tsrc/txdb.h\n\tsrc/txmempool.h",
      "tree": {
        "sha": "3f797361d0a5243bcd533475cef439b3a91af9e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3f797361d0a5243bcd533475cef439b3a91af9e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2045ffebe1c885af2a2543eaa709da732f514577",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2045ffebe1c885af2a2543eaa709da732f514577",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2045ffebe1c885af2a2543eaa709da732f514577",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2045ffebe1c885af2a2543eaa709da732f514577/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c973cc5a43187f4cfd7d053da3f9e35aa3866590",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c973cc5a43187f4cfd7d053da3f9e35aa3866590",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c973cc5a43187f4cfd7d053da3f9e35aa3866590"
      }
    ],
    "stats": {
      "total": 1194,
      "additions": 1194,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1a23c0a7768d6530a5696309cffdd615ba20fca9",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -77,6 +77,8 @@ endif\n # bitcoin core #\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n+  addressindex.h \\\n+  spentindex.h \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\"
      },
      {
        "sha": "9e734b84dcdcaa7581674d0ba8644a6df5e178a2",
        "filename": "src/addressindex.h",
        "status": "added",
        "additions": 82,
        "deletions": 0,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/addressindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/addressindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addressindex.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -0,0 +1,82 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRESSINDEX_H\n+#define BITCOIN_ADDRESSINDEX_H\n+\n+#include \"uint256.h\"\n+#include \"amount.h\"\n+\n+struct CMempoolAddressDelta\n+{\n+    int64_t time;\n+    CAmount amount;\n+    uint256 prevhash;\n+    unsigned int prevout;\n+\n+    CMempoolAddressDelta(int64_t t, CAmount a, uint256 hash, unsigned int out) {\n+        time = t;\n+        amount = a;\n+        prevhash = hash;\n+        prevout = out;\n+    }\n+\n+    CMempoolAddressDelta(int64_t t, CAmount a) {\n+        time = t;\n+        amount = a;\n+        prevhash.SetNull();\n+        prevout = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDeltaKey\n+{\n+    int type;\n+    uint160 addressBytes;\n+    uint256 txhash;\n+    unsigned int index;\n+    int spending;\n+\n+    CMempoolAddressDeltaKey(int addressType, uint160 addressHash, uint256 hash, unsigned int i, int s) {\n+        type = addressType;\n+        addressBytes = addressHash;\n+        txhash = hash;\n+        index = i;\n+        spending = s;\n+    }\n+\n+    CMempoolAddressDeltaKey(int addressType, uint160 addressHash) {\n+        type = addressType;\n+        addressBytes = addressHash;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = 0;\n+    }\n+};\n+\n+struct CMempoolAddressDeltaKeyCompare\n+{\n+    bool operator()(const CMempoolAddressDeltaKey& a, const CMempoolAddressDeltaKey& b) const {\n+        if (a.type == b.type) {\n+            if (a.addressBytes == b.addressBytes) {\n+                if (a.txhash == b.txhash) {\n+                    if (a.index == b.index) {\n+                        return a.spending < b.spending;\n+                    } else {\n+                        return a.index < b.index;\n+                    }\n+                } else {\n+                    return a.txhash < b.txhash;\n+                }\n+            } else {\n+                return a.addressBytes < b.addressBytes;\n+            }\n+        } else {\n+            return a.type < b.type;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_ADDRESSINDEX_H"
      },
      {
        "sha": "4b2fec57d97e1c7edf2f8625fcfa98b98eceb87f",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -271,6 +271,23 @@ CTxDestination CBitcoinAddress::Get() const\n         return CNoDestination();\n }\n \n+bool CBitcoinAddress::GetIndexKey(uint160& hashBytes, int& type) const\n+{\n+    if (!IsValid()) {\n+        return false;\n+    } else if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) {\n+        memcpy(&hashBytes, &vchData[0], 20);\n+        type = 1;\n+        return true;\n+    } else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) {\n+        memcpy(&hashBytes, &vchData[0], 20);\n+        type = 2;\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const\n {\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))"
      },
      {
        "sha": "c51dc9361e533f5a9d024d31955259092514b591",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -116,6 +116,7 @@ class CBitcoinAddress : public CBase58Data {\n \n     CTxDestination Get() const;\n     bool GetKeyID(CKeyID &keyID) const;\n+    bool GetIndexKey(uint160& hashBytes, int& type) const;\n     bool IsScript() const;\n };\n "
      },
      {
        "sha": "7ac5fc9261c28f2c69f374e6b8c7a094ecec4c23",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -377,6 +377,10 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX));\n \n+    strUsage += HelpMessageOpt(\"-addressindex\", strprintf(_(\"Maintain a full address index, used to query for the balance, txids and unspent outputs for addresses (default: %u)\"), DEFAULT_ADDRESSINDEX));\n+    strUsage += HelpMessageOpt(\"-timestampindex\", strprintf(_(\"Maintain a timestamp index for block hashes, used to query blocks hashes by a range of timestamps (default: %u)\"), DEFAULT_TIMESTAMPINDEX));\n+    strUsage += HelpMessageOpt(\"-spentindex\", strprintf(_(\"Maintain a full spent index, used to query the spending txid and input index for an outpoint (default: %u)\"), DEFAULT_SPENTINDEX));\n+\n     strUsage += HelpMessageGroup(_(\"Connection options:\"));\n     strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open\"));\n     strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));"
      },
      {
        "sha": "6117616079996153ceac8d6a56ce0efcaa3dc3a5",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -199,6 +199,17 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n     return subscript.GetSigOpCount(true);\n }\n \n+bool CScript::IsPayToPublicKeyHash() const\n+{\n+    // Extra-fast test for pay-to-pubkey-hash CScripts:\n+    return (this->size() == 25 &&\n+\t    (*this)[0] == OP_DUP &&\n+\t    (*this)[1] == OP_HASH160 &&\n+\t    (*this)[2] == 0x14 &&\n+\t    (*this)[23] == OP_EQUALVERIFY &&\n+\t    (*this)[24] == OP_CHECKSIG);\n+}\n+\n bool CScript::IsPayToScriptHash() const\n {\n     // Extra-fast test for pay-to-script-hash CScripts:"
      },
      {
        "sha": "b10ea1d3a934784261d27685b0b954dcf842a2b2",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -619,6 +619,8 @@ class CScript : public CScriptBase\n      */\n     unsigned int GetSigOpCount(const CScript& scriptSig) const;\n \n+    bool IsPayToPublicKeyHash() const;\n+\n     bool IsPayToScriptHash() const;\n     bool IsPayToWitnessScriptHash() const;\n     bool IsWitnessProgram(int& version, std::vector<unsigned char>& program) const;"
      },
      {
        "sha": "86fff89414ca6208915d19b0daa1a610902d9aff",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -77,6 +77,11 @@ template<typename Stream> inline void ser_writedata32(Stream &s, uint32_t obj)\n     obj = htole32(obj);\n     s.write((char*)&obj, 4);\n }\n+template<typename Stream> inline void ser_writedata32be(Stream &s, uint32_t obj)\n+{\n+    obj = htobe32(obj);\n+    s.write((char*)&obj, 4);\n+}\n template<typename Stream> inline void ser_writedata64(Stream &s, uint64_t obj)\n {\n     obj = htole64(obj);\n@@ -100,6 +105,12 @@ template<typename Stream> inline uint32_t ser_readdata32(Stream &s)\n     s.read((char*)&obj, 4);\n     return le32toh(obj);\n }\n+template<typename Stream> inline uint32_t ser_readdata32be(Stream &s)\n+{\n+    uint32_t obj;\n+    s.read((char*)&obj, 4);\n+    return be32toh(obj);\n+}\n template<typename Stream> inline uint64_t ser_readdata64(Stream &s)\n {\n     uint64_t obj;"
      },
      {
        "sha": "bd5da45d60dbc0d7377779329c90e597e0f1841e",
        "filename": "src/spentindex.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/spentindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/spentindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/spentindex.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SPENTINDEX_H\n+#define BITCOIN_SPENTINDEX_H\n+\n+#include \"uint256.h\"\n+#include \"amount.h\"\n+\n+struct CSpentIndexKey {\n+    uint256 txid;\n+    unsigned int outputIndex;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(txid);\n+        READWRITE(outputIndex);\n+    }\n+\n+    CSpentIndexKey(uint256 t, unsigned int i) {\n+        txid = t;\n+        outputIndex = i;\n+    }\n+\n+    CSpentIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        txid.SetNull();\n+        outputIndex = 0;\n+    }\n+\n+};\n+\n+struct CSpentIndexValue {\n+    uint256 txid;\n+    unsigned int inputIndex;\n+    int blockHeight;\n+    CAmount satoshis;\n+    int addressType;\n+    uint160 addressHash;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(txid);\n+        READWRITE(inputIndex);\n+        READWRITE(blockHeight);\n+        READWRITE(satoshis);\n+        READWRITE(addressType);\n+        READWRITE(addressHash);\n+    }\n+\n+    CSpentIndexValue(uint256 t, unsigned int i, int h, CAmount s, int type, uint160 a) {\n+        txid = t;\n+        inputIndex = i;\n+        blockHeight = h;\n+        satoshis = s;\n+        addressType = type;\n+        addressHash = a;\n+    }\n+\n+    CSpentIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        txid.SetNull();\n+        inputIndex = 0;\n+        blockHeight = 0;\n+        satoshis = 0;\n+        addressType = 0;\n+        addressHash.SetNull();\n+    }\n+\n+    bool IsNull() const {\n+        return txid.IsNull();\n+    }\n+};\n+\n+struct CSpentIndexKeyCompare\n+{\n+    bool operator()(const CSpentIndexKey& a, const CSpentIndexKey& b) const {\n+        if (a.txid == b.txid) {\n+            return a.outputIndex < b.outputIndex;\n+        } else {\n+            return a.txid < b.txid;\n+        }\n+    }\n+};\n+\n+#endif // BITCOIN_SPENTINDEX_H"
      },
      {
        "sha": "5cc7207b3d9fbd7a666ef8445cda6b345eda27e0",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 166,
        "deletions": 0,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -17,6 +17,11 @@\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n+static const char DB_ADDRESSINDEX = 'a';\n+static const char DB_ADDRESSUNSPENTINDEX = 'u';\n+static const char DB_TIMESTAMPINDEX = 's';\n+static const char DB_BLOCKHASHINDEX = 'z';\n+static const char DB_SPENTINDEX = 'p';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n@@ -157,6 +162,157 @@ bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos>\n     return WriteBatch(batch);\n }\n \n+bool CBlockTreeDB::ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value) {\n+    return Read(make_pair(DB_SPENTINDEX, key), value);\n+}\n+\n+bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CSpentIndexKey,CSpentIndexValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n+        if (it->second.IsNull()) {\n+            batch.Erase(make_pair(DB_SPENTINDEX, it->first));\n+        } else {\n+            batch.Write(make_pair(DB_SPENTINDEX, it->first), it->second);\n+        }\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n+        if (it->second.IsNull()) {\n+            batch.Erase(make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n+        } else {\n+            batch.Write(make_pair(DB_ADDRESSUNSPENTINDEX, it->first), it->second);\n+        }\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n+                                           std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    pcursor->Seek(make_pair(DB_ADDRESSUNSPENTINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char,CAddressUnspentKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_ADDRESSUNSPENTINDEX && key.second.hashBytes == addressHash) {\n+            CAddressUnspentValue nValue;\n+            if (pcursor->GetValue(nValue)) {\n+                unspentOutputs.push_back(make_pair(key.second, nValue));\n+                pcursor->Next();\n+            } else {\n+                return error(\"failed to get address unspent value\");\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+        batch.Write(make_pair(DB_ADDRESSINDEX, it->first), it->second);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n+        batch.Erase(make_pair(DB_ADDRESSINDEX, it->first));\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n+                                    std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                                    int start, int end) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    if (start > 0 && end > 0) {\n+        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorHeightKey(type, addressHash, start)));\n+    } else {\n+        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+    }\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char,CAddressIndexKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_ADDRESSINDEX && key.second.hashBytes == addressHash) {\n+            if (end > 0 && key.second.blockHeight > end) {\n+                break;\n+            }\n+            CAmount nValue;\n+            if (pcursor->GetValue(nValue)) {\n+                addressIndex.push_back(make_pair(key.second, nValue));\n+                pcursor->Next();\n+            } else {\n+                return error(\"failed to get address index value\");\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteTimestampIndex(const CTimestampIndexKey &timestampIndex) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    batch.Write(make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes) {\n+\n+    boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n+\n+    pcursor->Seek(make_pair(DB_TIMESTAMPINDEX, CTimestampIndexIteratorKey(low)));\n+\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<char, CTimestampIndexKey> key;\n+        if (pcursor->GetKey(key) && key.first == DB_TIMESTAMPINDEX && key.second.timestamp < high) {\n+            if (fActiveOnly) {\n+                if (blockOnchainActive(key.second.blockHash)) {\n+                    hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n+                }\n+            } else {\n+                hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n+            }\n+\n+            pcursor->Next();\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CBlockTreeDB::WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts) {\n+    CDBBatch batch(&GetObfuscateKey());\n+    batch.Write(make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n+    return WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::ReadTimestampBlockIndex(const uint256 &hash, unsigned int &ltimestamp) {\n+\n+    CTimestampBlockIndexValue(lts);\n+    if (!Read(std::make_pair(DB_BLOCKHASHINDEX, hash), lts))\n+\treturn false;\n+\n+    ltimestamp = lts.ltimestamp;\n+    return true;\n+}\n+\n bool CBlockTreeDB::WriteFlag(const std::string &name, bool fValue) {\n     return Write(std::make_pair(DB_FLAG, name), fValue ? '1' : '0');\n }\n@@ -169,6 +325,16 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n+bool CBlockTreeDB::blockOnchainActive(const uint256 &hash) {\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+    \n+    if (!chainActive.Contains(pblockindex)) {\n+        return false;\n+    }\n+    \n+    return true;\n+}\n+\n bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());"
      },
      {
        "sha": "6a550624171402ad5cd99751848a387064d34f66",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -19,6 +19,17 @@\n \n class CBlockIndex;\n class CCoinsViewDBCursor;\n+struct CAddressUnspentKey;\n+struct CAddressUnspentValue;\n+struct CAddressIndexKey;\n+struct CAddressIndexIteratorKey;\n+struct CAddressIndexIteratorHeightKey;\n+struct CTimestampIndexKey;\n+struct CTimestampIndexIteratorKey;\n+struct CTimestampBlockIndexKey;\n+struct CTimestampBlockIndexValue;\n+struct CSpentIndexKey;\n+struct CSpentIndexValue;\n class uint256;\n \n //! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n@@ -120,9 +131,24 @@ class CBlockTreeDB : public CDBWrapper\n     bool ReadReindexing(bool &fReindex);\n     bool ReadTxIndex(const uint256 &txid, CDiskTxPos &pos);\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n+    bool ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+    bool UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect);\n+    bool UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect);\n+    bool ReadAddressUnspentIndex(uint160 addressHash, int type,\n+                                 std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &vect);\n+    bool WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount> > &vect);\n+    bool EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount> > &vect);\n+    bool ReadAddressIndex(uint160 addressHash, int type,\n+                          std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                          int start = 0, int end = 0);\n+    bool WriteTimestampIndex(const CTimestampIndexKey &timestampIndex);\n+    bool ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &vect);\n+    bool WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts);\n+    bool ReadTimestampBlockIndex(const uint256 &hash, unsigned int &logicalTS);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n+    bool blockOnchainActive(const uint256 &hash);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "3611b12963ddabb7080a01d1b8d0188e1d5b8d90",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 0,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -426,6 +426,145 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     return true;\n }\n \n+void CTxMemPool::addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view)\n+{\n+    LOCK(cs);\n+    const CTransaction& tx = entry.GetTx();\n+    std::vector<CMempoolAddressDeltaKey> inserted;\n+\n+    uint256 txhash = tx.GetHash();\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        const CTxIn input = tx.vin[j];\n+        const CTxOut &prevout = view.GetOutputFor(input);\n+        if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+            CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, j, 1);\n+            CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n+            mapAddress.insert(make_pair(key, delta));\n+            inserted.push_back(key);\n+        } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+            CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, j, 1);\n+            CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n+            mapAddress.insert(make_pair(key, delta));\n+            inserted.push_back(key);\n+        }\n+    }\n+\n+    for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+        const CTxOut &out = tx.vout[k];\n+        if (out.scriptPubKey.IsPayToScriptHash()) {\n+            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+            CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, k, 0);\n+            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            inserted.push_back(key);\n+        } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+            std::pair<addressDeltaMap::iterator,bool> ret;\n+            CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, k, 0);\n+            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            inserted.push_back(key);\n+        }\n+    }\n+\n+    mapAddressInserted.insert(make_pair(txhash, inserted));\n+}\n+\n+bool CTxMemPool::getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n+                                 std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > &results)\n+{\n+    LOCK(cs);\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        addressDeltaMap::iterator ait = mapAddress.lower_bound(CMempoolAddressDeltaKey((*it).second, (*it).first));\n+        while (ait != mapAddress.end() && (*ait).first.addressBytes == (*it).first && (*ait).first.type == (*it).second) {\n+            results.push_back(*ait);\n+            ait++;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CTxMemPool::removeAddressIndex(const uint256 txhash)\n+{\n+    LOCK(cs);\n+    addressDeltaMapInserted::iterator it = mapAddressInserted.find(txhash);\n+\n+    if (it != mapAddressInserted.end()) {\n+        std::vector<CMempoolAddressDeltaKey> keys = (*it).second;\n+        for (std::vector<CMempoolAddressDeltaKey>::iterator mit = keys.begin(); mit != keys.end(); mit++) {\n+            mapAddress.erase(*mit);\n+        }\n+        mapAddressInserted.erase(it);\n+    }\n+\n+    return true;\n+}\n+\n+void CTxMemPool::addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view)\n+{\n+    LOCK(cs);\n+\n+    const CTransaction& tx = entry.GetTx();\n+    std::vector<CSpentIndexKey> inserted;\n+\n+    uint256 txhash = tx.GetHash();\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        const CTxIn input = tx.vin[j];\n+        const CTxOut &prevout = view.GetOutputFor(input);\n+        uint160 addressHash;\n+        int addressType;\n+\n+        if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+            addressType = 2;\n+        } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+            addressType = 1;\n+        } else {\n+            addressHash.SetNull();\n+            addressType = 0;\n+        }\n+\n+        CSpentIndexKey key = CSpentIndexKey(input.prevout.hash, input.prevout.n);\n+        CSpentIndexValue value = CSpentIndexValue(txhash, j, -1, prevout.nValue, addressType, addressHash);\n+\n+        mapSpent.insert(make_pair(key, value));\n+        inserted.push_back(key);\n+\n+    }\n+\n+    mapSpentInserted.insert(make_pair(txhash, inserted));\n+}\n+\n+bool CTxMemPool::getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n+{\n+    LOCK(cs);\n+    mapSpentIndex::iterator it;\n+\n+    it = mapSpent.find(key);\n+    if (it != mapSpent.end()) {\n+        value = it->second;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CTxMemPool::removeSpentIndex(const uint256 txhash)\n+{\n+    LOCK(cs);\n+    mapSpentIndexInserted::iterator it = mapSpentInserted.find(txhash);\n+\n+    if (it != mapSpentInserted.end()) {\n+        std::vector<CSpentIndexKey> keys = (*it).second;\n+        for (std::vector<CSpentIndexKey>::iterator mit = keys.begin(); mit != keys.end(); mit++) {\n+            mapSpent.erase(*mit);\n+        }\n+        mapSpentInserted.erase(it);\n+    }\n+\n+    return true;\n+}\n+\n void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n {\n     NotifyEntryRemoved(it->GetSharedTx(), reason);\n@@ -449,6 +588,8 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n     mapTx.erase(it);\n     nTransactionsUpdated++;\n     if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash);}\n+    removeAddressIndex(hash);\n+    removeSpentIndex(hash);\n }\n \n // Calculates descendants of entry that are not already in setDescendants, and adds to"
      },
      {
        "sha": "eed58adc9f52da3aec47d7a1a96e4ba7b2c766b3",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -13,6 +13,8 @@\n #include <utility>\n #include <string>\n \n+#include \"addressindex.h\"\n+#include \"spentindex.h\"\n #include \"amount.h\"\n #include \"coins.h\"\n #include \"indirectmap.h\"\n@@ -486,6 +488,18 @@ class CTxMemPool\n     typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n     txlinksMap mapLinks;\n \n+    typedef std::map<CMempoolAddressDeltaKey, CMempoolAddressDelta, CMempoolAddressDeltaKeyCompare> addressDeltaMap;\n+    addressDeltaMap mapAddress;\n+\n+    typedef std::map<uint256, std::vector<CMempoolAddressDeltaKey> > addressDeltaMapInserted;\n+    addressDeltaMapInserted mapAddressInserted;\n+\n+    typedef std::map<CSpentIndexKey, CSpentIndexValue, CSpentIndexKeyCompare> mapSpentIndex;\n+    mapSpentIndex mapSpent;\n+\n+    typedef std::map<uint256, std::vector<CSpentIndexKey> > mapSpentIndexInserted;\n+    mapSpentIndexInserted mapSpentInserted;\n+\n     void UpdateParent(txiter entry, txiter parent, bool add);\n     void UpdateChild(txiter entry, txiter child, bool add);\n \n@@ -515,6 +529,15 @@ class CTxMemPool\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool validFeeEstimate = true);\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate = true);\n \n+    void addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view);\n+    bool getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n+                         std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > &results);\n+    bool removeAddressIndex(const uint256 txhash);\n+\n+    void addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCache &view);\n+    bool getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+    bool removeSpentIndex(const uint256 txhash);\n+\n     void removeRecursive(const CTransaction &tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN);\n     void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);\n     void removeConflicts(const CTransaction &tx);"
      },
      {
        "sha": "e00ddd254d11d79e3899f2de597116e47a6bdeb4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 267,
        "deletions": 0,
        "changes": 267,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -65,6 +65,9 @@ int nScriptCheckThreads = 0;\n std::atomic_bool fImporting(false);\n bool fReindex = false;\n bool fTxIndex = false;\n+bool fAddressIndex = false;\n+bool fTimestampIndex = false;\n+bool fSpentIndex = false;\n bool fHavePruned = false;\n bool fPruneMode = false;\n bool fIsBareMultisigStd = DEFAULT_PERMIT_BAREMULTISIG;\n@@ -943,6 +946,16 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);\n \n+        // Add memory address index\n+        if (fAddressIndex) {\n+            pool.addAddressIndex(entry, view);\n+        }\n+\n+        // Add memory spent index\n+        if (fSpentIndex) {\n+            pool.addSpentIndex(entry, view);\n+        }\n+\n         // trim mempool and check if tx was trimmed\n         if (!fOverrideMempoolLimit) {\n             LimitMempoolSize(pool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n@@ -979,6 +992,55 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     return AcceptToMemoryPoolWithTime(pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee);\n }\n \n+bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes)\n+{\n+    if (!fTimestampIndex)\n+        return error(\"Timestamp index not enabled\");\n+\n+    if (!pblocktree->ReadTimestampIndex(high, low, fActiveOnly, hashes))\n+        return error(\"Unable to get hashes for timestamps\");\n+\n+    return true;\n+}\n+\n+bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n+{\n+    if (!fSpentIndex)\n+        return false;\n+\n+    if (mempool.getSpentIndex(key, value))\n+        return true;\n+\n+    if (!pblocktree->ReadSpentIndex(key, value))\n+        return false;\n+\n+    return true;\n+}\n+\n+bool GetAddressIndex(uint160 addressHash, int type,\n+                     std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex, int start, int end)\n+{\n+    if (!fAddressIndex)\n+        return error(\"address index not enabled\");\n+\n+    if (!pblocktree->ReadAddressIndex(addressHash, type, addressIndex, start, end))\n+        return error(\"unable to get txids for address\");\n+\n+    return true;\n+}\n+\n+bool GetAddressUnspent(uint160 addressHash, int type,\n+                       std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs)\n+{\n+    if (!fAddressIndex)\n+        return error(\"address index not enabled\");\n+\n+    if (!pblocktree->ReadAddressUnspentIndex(addressHash, type, unspentOutputs))\n+        return error(\"unable to get txids for address\");\n+\n+    return true;\n+}\n+\n /** Return transaction in txOut, and if it was found inside a block, its hash is placed in hashBlock */\n bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)\n {\n@@ -1554,11 +1616,46 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n         return DISCONNECT_FAILED;\n     }\n \n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > addressUnspentIndex;\n+    std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> > spentIndex;\n+\n     // undo transactions in reverse order\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n         const CTransaction &tx = *(block.vtx[i]);\n         uint256 hash = tx.GetHash();\n \n+        if (fAddressIndex) {\n+\n+            for (unsigned int k = tx.vout.size(); k-- > 0;) {\n+                const CTxOut &out = tx.vout[k];\n+\n+                if (out.scriptPubKey.IsPayToScriptHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+\n+                    // undo receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+\n+                    // undo unspent index\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+\n+                } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+\n+                    // undo receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+\n+                    // undo unspent index\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+\n+                } else {\n+                    continue;\n+                }\n+\n+            }\n+\n+        }\n+\n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n         {\n@@ -1590,13 +1687,57 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n                 const CTxInUndo &undo = txundo.vprevout[j];\n                 if (!ApplyTxInUndo(undo, view, out))\n                     fClean = false;\n+\n+                const CTxIn input = tx.vin[j];\n+\n+                if (fSpentIndex) {\n+                    // undo and delete the spent index\n+                    spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue()));\n+                }\n+\n+                if (fAddressIndex) {\n+                    const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n+                    if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+\n+                        // undo spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+\n+                        // restore unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+\n+\n+                    } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+\n+                        // undo spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+\n+                        // restore unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+\n             }\n         }\n     }\n \n+\n     // move best block pointer to prevout block\n     view.SetBestBlock(pindex->pprev->GetBlockHash());\n \n+    if (fAddressIndex) {\n+        if (!pblocktree->EraseAddressIndex(addressIndex)) {\n+            return AbortNode(state, \"Failed to delete address index\");\n+        }\n+        if (!pblocktree->UpdateAddressUnspentIndex(addressUnspentIndex)) {\n+            return AbortNode(state, \"Failed to write address unspent index\");\n+        }\n+    }\n+\n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n@@ -1827,6 +1968,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = *(block.vtx[i]);\n+        const uint256 txhash = tx.GetHash();\n \n         nInputs += tx.vin.size();\n \n@@ -1848,6 +1990,43 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n                 return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n+\n+            if (fAddressIndex || fSpentIndex)\n+            {\n+                for (size_t j = 0; j < tx.vin.size(); j++) {\n+\n+                    const CTxIn input = tx.vin[j];\n+                    const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n+                    uint160 hashBytes;\n+                    int addressType;\n+\n+                    if (prevout.scriptPubKey.IsPayToScriptHash()) {\n+                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+                        addressType = 2;\n+                    } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n+                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+                        addressType = 1;\n+                    } else {\n+                        hashBytes.SetNull();\n+                        addressType = 0;\n+                    }\n+\n+                    if (fAddressIndex && addressType > 0) {\n+                        // record spending activity\n+                        addressIndex.push_back(make_pair(CAddressIndexKey(addressType, hashBytes, pindex->nHeight, i, txhash, j, true), prevout.nValue * -1));\n+\n+                        // remove address from unspent index\n+                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(addressType, hashBytes, input.prevout.hash, input.prevout.n), CAddressUnspentValue()));\n+                    }\n+\n+                    if (fSpentIndex) {\n+                        // add the spent index to determine the txid and input that spent an output\n+                        // and to find the amount and address from an input\n+                        spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue(txhash, j, pindex->nHeight, prevout.nValue, addressType, hashBytes)));\n+                    }\n+                }\n+\n+            }\n         }\n \n         // GetTransactionSigOpCost counts 3 types of sigops:\n@@ -1872,6 +2051,35 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n             control.Add(vChecks);\n         }\n \n+        if (fAddressIndex) {\n+            for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+                const CTxOut &out = tx.vout[k];\n+\n+                if (out.scriptPubKey.IsPayToScriptHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+\n+                    // record receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+\n+                    // record unspent output\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+\n+                } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+\n+                    // record receiving activity\n+                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+\n+                    // record unspent output\n+                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+\n+                } else {\n+                    continue;\n+                }\n+\n+            }\n+        }\n+\n         CTxUndo undoDummy;\n         if (i > 0) {\n             blockundo.vtxundo.push_back(CTxUndo());\n@@ -1922,6 +2130,41 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         if (!pblocktree->WriteTxIndex(vPos))\n             return AbortNode(state, \"Failed to write transaction index\");\n \n+    if (fAddressIndex) {\n+        if (!pblocktree->WriteAddressIndex(addressIndex)) {\n+            return AbortNode(state, \"Failed to write address index\");\n+        }\n+\n+        if (!pblocktree->UpdateAddressUnspentIndex(addressUnspentIndex)) {\n+            return AbortNode(state, \"Failed to write address unspent index\");\n+        }\n+    }\n+\n+    if (fSpentIndex)\n+        if (!pblocktree->UpdateSpentIndex(spentIndex))\n+            return AbortNode(state, \"Failed to write transaction index\");\n+\n+    if (fTimestampIndex) {\n+        unsigned int logicalTS = pindex->nTime;\n+        unsigned int prevLogicalTS = 0;\n+\n+        // retrieve logical timestamp of the previous block\n+        if (pindex->pprev)\n+            if (!pblocktree->ReadTimestampBlockIndex(pindex->pprev->GetBlockHash(), prevLogicalTS))\n+                LogPrintf(\"%s: Failed to read previous block's logical timestamp\\n\", __func__);\n+\n+        if (logicalTS <= prevLogicalTS) {\n+            logicalTS = prevLogicalTS + 1;\n+            LogPrintf(\"%s: Previous logical timestamp is newer Actual[%d] prevLogical[%d] Logical[%d]\\n\", __func__, pindex->nTime, prevLogicalTS, logicalTS);\n+        }\n+\n+        if (!pblocktree->WriteTimestampIndex(CTimestampIndexKey(logicalTS, pindex->GetBlockHash())))\n+            return AbortNode(state, \"Failed to write timestamp index\");\n+\n+        if (!pblocktree->WriteTimestampBlockIndex(CTimestampBlockIndexKey(pindex->GetBlockHash()), CTimestampBlockIndexValue(logicalTS)))\n+            return AbortNode(state, \"Failed to write blockhash index\");\n+    }\n+\n     // add this block to the view's block chain\n     view.SetBestBlock(pindex->GetBlockHash());\n \n@@ -3579,6 +3822,18 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n+    // Check whether we have an address index\n+    pblocktree->ReadFlag(\"addressindex\", fAddressIndex);\n+    LogPrintf(\"%s: address index %s\\n\", __func__, fAddressIndex ? \"enabled\" : \"disabled\");\n+\n+    // Check whether we have a timestamp index\n+    pblocktree->ReadFlag(\"timestampindex\", fTimestampIndex);\n+    LogPrintf(\"%s: timestamp index %s\\n\", __func__, fTimestampIndex ? \"enabled\" : \"disabled\");\n+\n+    // Check whether we have a spent index\n+    pblocktree->ReadFlag(\"spentindex\", fSpentIndex);\n+    LogPrintf(\"%s: spent index %s\\n\", __func__, fSpentIndex ? \"enabled\" : \"disabled\");\n+\n     // Load pointer to end of best chain\n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n@@ -3832,6 +4087,18 @@ bool InitBlockIndex(const CChainParams& chainparams)\n     // Use the provided setting for -txindex in the new database\n     fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);\n     pblocktree->WriteFlag(\"txindex\", fTxIndex);\n+\n+    // Use the provided setting for -addressindex in the new database\n+    fAddressIndex = GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX);\n+    pblocktree->WriteFlag(\"addressindex\", fAddressIndex);\n+\n+    // Use the provided setting for -timestampindex in the new database\n+    fTimestampIndex = GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX);\n+    pblocktree->WriteFlag(\"timestampindex\", fTimestampIndex);\n+\n+    fSpentIndex = GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX);\n+    pblocktree->WriteFlag(\"spentindex\", fSpentIndex);\n+\n     LogPrintf(\"Initializing databases...\\n\");\n \n     // Only add the genesis block if not reindexing (in which case we reuse the one already on disk)"
      },
      {
        "sha": "c7311ceb4b3f9d0ad78d2f85d01b92cda4fe7438",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 343,
        "deletions": 0,
        "changes": 343,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2045ffebe1c885af2a2543eaa709da732f514577/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2045ffebe1c885af2a2543eaa709da732f514577/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=2045ffebe1c885af2a2543eaa709da732f514577",
        "patch": "@@ -18,6 +18,7 @@\n #include \"script/script_error.h\"\n #include \"sync.h\"\n #include \"versionbits.h\"\n+#include \"spentindex.h\"\n \n #include <algorithm>\n #include <exception>\n@@ -131,6 +132,9 @@ static const int64_t MAX_FEE_ESTIMATION_TIP_AGE = 3 * 60 * 60;\n static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const bool DEFAULT_CHECKPOINTS_ENABLED = true;\n static const bool DEFAULT_TXINDEX = false;\n+static const bool DEFAULT_ADDRESSINDEX = false;\n+static const bool DEFAULT_TIMESTAMPINDEX = false;\n+static const bool DEFAULT_SPENTINDEX = false;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n /** Default for -persistmempool */\n static const bool DEFAULT_PERSIST_MEMPOOL = true;\n@@ -342,6 +346,338 @@ ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::D\n /** Get the block height at which the BIP9 deployment switched into the state for the block building on the current tip. */\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n+struct CTimestampIndexIteratorKey {\n+    unsigned int timestamp;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampIndexIteratorKey(unsigned int time) {\n+        timestamp = time;\n+    }\n+\n+    CTimestampIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+    }\n+};\n+\n+struct CTimestampIndexKey {\n+    unsigned int timestamp;\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 36;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampIndexKey(unsigned int time, uint256 hash) {\n+        timestamp = time;\n+        blockHash = hash;\n+    }\n+\n+    CTimestampIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexKey {\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 32;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampBlockIndexKey(uint256 hash) {\n+        blockHash = hash;\n+    }\n+\n+    CTimestampBlockIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexValue {\n+    unsigned int ltimestamp;\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, ltimestamp);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        ltimestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampBlockIndexValue (unsigned int time) {\n+        ltimestamp = time;\n+    }\n+\n+    CTimestampBlockIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        ltimestamp = 0;\n+    }\n+};\n+\n+struct CAddressUnspentKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    uint256 txhash;\n+    size_t index;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 57;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+    }\n+\n+    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        txhash = txid;\n+        index = indexValue;\n+    }\n+\n+    CAddressUnspentKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        txhash.SetNull();\n+        index = 0;\n+    }\n+};\n+\n+struct CAddressUnspentValue {\n+    CAmount satoshis;\n+    CScript script;\n+    int blockHeight;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(satoshis);\n+        READWRITE(*(CScriptBase*)(&script));\n+        READWRITE(blockHeight);\n+    }\n+\n+    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n+        satoshis = sats;\n+        script = scriptPubKey;\n+        blockHeight = height;\n+    }\n+\n+    CAddressUnspentValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        satoshis = -1;\n+        script.clear();\n+        blockHeight = 0;\n+    }\n+\n+    bool IsNull() const {\n+        return (satoshis == -1);\n+    }\n+};\n+\n+struct CAddressIndexKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+    unsigned int txindex;\n+    uint256 txhash;\n+    size_t index;\n+    bool spending;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 66;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        // Heights are stored big-endian for key sorting in LevelDB\n+        ser_writedata32be(s, blockHeight);\n+        ser_writedata32be(s, txindex);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+        char f = spending;\n+        ser_writedata8(s, f);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+        txindex = ser_readdata32be(s);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+        char f = ser_readdata8(s);\n+        spending = f;\n+    }\n+\n+    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n+                     uint256 txid, size_t indexValue, bool isSpending) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+        txindex = blockindex;\n+        txhash = txid;\n+        index = indexValue;\n+        spending = isSpending;\n+    }\n+\n+    CAddressIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+        txindex = 0;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = false;\n+    }\n+\n+};\n+\n+struct CAddressIndexIteratorKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 21;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+    }\n+\n+    CAddressIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+    }\n+};\n+\n+struct CAddressIndexIteratorHeightKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 25;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        ser_writedata32be(s, blockHeight);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+    }\n+\n+    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+    }\n+\n+    CAddressIndexIteratorHeightKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+    }\n+};\n+\n /** \n  * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n  * @return number of sigops this transaction's outputs will produce when spent\n@@ -471,6 +807,13 @@ class CScriptCheck\n     ScriptError GetScriptError() const { return error; }\n };\n \n+bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes);\n+bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+bool GetAddressIndex(uint160 addressHash, int type,\n+                     std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n+                     int start = 0, int end = 0);\n+bool GetAddressUnspent(uint160 addressHash, int type,\n+                       std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > &unspentOutputs);\n \n /** Functions for disk access for blocks */\n bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart);"
      }
    ]
  },
  {
    "sha": "65cbc4c31905ae30e5706e859d56427474d500a0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NWNiYzRjMzE5MDVhZTMwZTU3MDZlODU5ZDU2NDI3NDc0ZDUwMGEw",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T19:00:31Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:47Z"
      },
      "message": "rpc: adds rpc commands for address, spent and timestamp indexes\n\nAdds new rpc commands that use the address, spent and timestamp indexes,\nincluding the new commands:\n\n- getblockdeltas\n- getblockhashes\n- getaddressmempool\n- getaddressutxos\n- getaddressdeltas\n- getaddressbalance\n- getaddresstxids\n- getspentinfo\n\nAnd modifications to the command:\n- getrawtransaction\n\nConflicts:\n\tsrc/rpc/blockchain.cpp\n\tsrc/rpc/client.cpp\n\tsrc/rpc/misc.cpp\n\tsrc/rpc/rawtransaction.cpp\n\tsrc/rpc/server.cpp\n\tsrc/rpcserver.h",
      "tree": {
        "sha": "bb8778a742edb5f65da9f15fd8ba313c4efa91e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bb8778a742edb5f65da9f15fd8ba313c4efa91e1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65cbc4c31905ae30e5706e859d56427474d500a0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65cbc4c31905ae30e5706e859d56427474d500a0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/65cbc4c31905ae30e5706e859d56427474d500a0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65cbc4c31905ae30e5706e859d56427474d500a0/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2045ffebe1c885af2a2543eaa709da732f514577",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2045ffebe1c885af2a2543eaa709da732f514577",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2045ffebe1c885af2a2543eaa709da732f514577"
      }
    ],
    "stats": {
      "total": 889,
      "additions": 879,
      "deletions": 10
    },
    "files": [
      {
        "sha": "6aa4b23ae63361755b844241d2ea0f0a78acb42f",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65cbc4c31905ae30e5706e859d56427474d500a0/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65cbc4c31905ae30e5706e859d56427474d500a0/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=65cbc4c31905ae30e5706e859d56427474d500a0",
        "patch": "@@ -189,6 +189,7 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n \n         UniValue outValue(UniValue::VNUM, FormatMoney(txout.nValue));\n         out.pushKV(\"value\", outValue);\n+        out.pushKV(\"valueSat\", txout.nValue);\n         out.pushKV(\"n\", (int64_t)i);\n \n         UniValue o(UniValue::VOBJ);"
      },
      {
        "sha": "fc8c4a4d44dbe467e5c4258791413b8cfa0cd44c",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 210,
        "deletions": 0,
        "changes": 210,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=65cbc4c31905ae30e5706e859d56427474d500a0",
        "patch": "@@ -6,6 +6,7 @@\n #include \"rpc/blockchain.h\"\n \n #include \"amount.h\"\n+#include \"base58.h\"\n #include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n@@ -17,6 +18,10 @@\n #include \"policy/policy.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/server.h\"\n+#include \"script/script.h\"\n+#include \"script/script_error.h\"\n+#include \"script/sign.h\"\n+#include \"script/standard.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n #include \"txmempool.h\"\n@@ -102,6 +107,112 @@ UniValue blockheaderToJSON(const CBlockIndex* blockindex)\n     return result;\n }\n \n+UniValue blockToDeltasJSON(const CBlock& block, const CBlockIndex* blockindex)\n+{\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n+    int confirmations = -1;\n+    // Only report confirmations if the block is on the main chain\n+    if (chainActive.Contains(blockindex)) {\n+        confirmations = chainActive.Height() - blockindex->nHeight + 1;\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block is an orphan\");\n+    }\n+    result.push_back(Pair(\"confirmations\", confirmations));\n+    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+    result.push_back(Pair(\"height\", blockindex->nHeight));\n+    result.push_back(Pair(\"version\", block.nVersion));\n+    result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (unsigned int i = 0; i < block.vtx.size(); i++) {\n+        const CTransaction &tx = block.vtx[i];\n+        const uint256 txhash = tx.GetHash();\n+\n+        UniValue entry(UniValue::VOBJ);\n+        entry.push_back(Pair(\"txid\", txhash.GetHex()));\n+        entry.push_back(Pair(\"index\", (int)i));\n+\n+        UniValue inputs(UniValue::VARR);\n+\n+        if (!tx.IsCoinBase()) {\n+\n+            for (size_t j = 0; j < tx.vin.size(); j++) {\n+                const CTxIn input = tx.vin[j];\n+\n+                UniValue delta(UniValue::VOBJ);\n+\n+                CSpentIndexValue spentInfo;\n+                CSpentIndexKey spentKey(input.prevout.hash, input.prevout.n);\n+\n+                if (GetSpentIndex(spentKey, spentInfo)) {\n+                    if (spentInfo.addressType == 1) {\n+                        delta.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(spentInfo.addressHash)).ToString()));\n+                    } else if (spentInfo.addressType == 2)  {\n+                        delta.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(spentInfo.addressHash)).ToString()));\n+                    } else {\n+                        continue;\n+                    }\n+                    delta.push_back(Pair(\"satoshis\", -1 * spentInfo.satoshis));\n+                    delta.push_back(Pair(\"index\", (int)j));\n+                    delta.push_back(Pair(\"prevtxid\", input.prevout.hash.GetHex()));\n+                    delta.push_back(Pair(\"prevout\", (int)input.prevout.n));\n+\n+                    inputs.push_back(delta);\n+                } else {\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, \"Spent information not available\");\n+                }\n+\n+            }\n+        }\n+\n+        entry.push_back(Pair(\"inputs\", inputs));\n+\n+        UniValue outputs(UniValue::VARR);\n+\n+        for (unsigned int k = 0; k < tx.vout.size(); k++) {\n+            const CTxOut &out = tx.vout[k];\n+\n+            UniValue delta(UniValue::VOBJ);\n+\n+            if (out.scriptPubKey.IsPayToScriptHash()) {\n+                vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+                delta.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(uint160(hashBytes))).ToString()));\n+\n+            } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n+                vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+                delta.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(uint160(hashBytes))).ToString()));\n+            } else {\n+                continue;\n+            }\n+\n+            delta.push_back(Pair(\"satoshis\", out.nValue));\n+            delta.push_back(Pair(\"index\", (int)k));\n+\n+            outputs.push_back(delta);\n+        }\n+\n+        entry.push_back(Pair(\"outputs\", outputs));\n+        deltas.push_back(entry);\n+\n+    }\n+    result.push_back(Pair(\"deltas\", deltas));\n+    result.push_back(Pair(\"time\", block.GetBlockTime()));\n+    result.push_back(Pair(\"mediantime\", (int64_t)blockindex->GetMedianTimePast()));\n+    result.push_back(Pair(\"nonce\", (uint64_t)block.nNonce));\n+    result.push_back(Pair(\"bits\", strprintf(\"%08x\", block.nBits)));\n+    result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n+    result.push_back(Pair(\"chainwork\", blockindex->nChainWork.GetHex()));\n+\n+    if (blockindex->pprev)\n+        result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n+    CBlockIndex *pnext = chainActive.Next(blockindex);\n+    if (pnext)\n+        result.push_back(Pair(\"nextblockhash\", pnext->GetBlockHash().GetHex()));\n+    return result;\n+}\n+\n UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails)\n {\n     UniValue result(UniValue::VOBJ);\n@@ -600,6 +711,102 @@ UniValue getmempoolentry(const JSONRPCRequest& request)\n     return info;\n }\n \n+UniValue getblockdeltas(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\"\");\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(uint256S(strHash));\n+\n+    if (mapBlockIndex.count(hash) == 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+\n+    CBlock block;\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Block not available (pruned data)\");\n+\n+    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n+\n+    return blockToDeltasJSON(block, pblockindex);\n+}\n+\n+UniValue getblockhashes(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2)\n+        throw runtime_error(\n+            \"getblockhashes timestamp\\n\"\n+            \"\\nReturns array of hashes of blocks within the timestamp range provided.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. high         (numeric, required) The newer block timestamp\\n\"\n+            \"2. low          (numeric, required) The older block timestamp\\n\"\n+            \"3. options      (string, required) A json object\\n\"\n+            \"    {\\n\"\n+            \"      \\\"noOrphans\\\":true   (boolean) will only include blocks on the main chain\\n\"\n+            \"      \\\"logicalTimes\\\":true   (boolean) will include logical timestamps with hashes\\n\"\n+            \"    }\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"hash\\\"         (string) The block hash\\n\"\n+            \"]\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"blockhash\\\": (string) The block hash\\n\"\n+            \"    \\\"logicalts\\\": (numeric) The logical timestamp\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505\")\n+            + HelpExampleRpc(\"getblockhashes\", \"1231614698, 1231024505\")\n+            + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505 '{\\\"noOrphans\\\":false, \\\"logicalTimes\\\":true}'\")\n+            );\n+\n+    unsigned int high = params[0].get_int();\n+    unsigned int low = params[1].get_int();\n+    bool fActiveOnly = false;\n+    bool fLogicalTS = false;\n+\n+    if (params.size() > 2) {\n+        if (params[2].isObject()) {\n+            UniValue noOrphans = find_value(params[2].get_obj(), \"noOrphans\");\n+            UniValue returnLogical = find_value(params[2].get_obj(), \"logicalTimes\");\n+\n+            if (noOrphans.isBool())\n+                fActiveOnly = noOrphans.get_bool();\n+\n+            if (returnLogical.isBool())\n+                fLogicalTS = returnLogical.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint256, unsigned int> > blockHashes;\n+\n+    if (fActiveOnly)\n+        LOCK(cs_main);\n+\n+    if (!GetTimestampIndex(high, low, fActiveOnly, blockHashes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for block hashes\");\n+    }\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<uint256, unsigned int> >::const_iterator it=blockHashes.begin(); it!=blockHashes.end(); it++) {\n+        if (fLogicalTS) {\n+            UniValue item(UniValue::VOBJ);\n+            item.push_back(Pair(\"blockhash\", it->first.GetHex()));\n+            item.push_back(Pair(\"logicalts\", (int)it->second));\n+            result.push_back(item);\n+        } else {\n+            result.push_back(it->first.GetHex());\n+        }\n+    }\n+\n+    return result;\n+}\n+\n UniValue getblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n@@ -1490,6 +1697,8 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true,  {} },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true,  {} },\n     { \"blockchain\",         \"getblock\",               &getblock,               true,  {\"blockhash\",\"verbose\"} },\n+    { \"blockchain\",         \"getblockdeltas\",         &getblockdeltas,         false },\n+    { \"blockchain\",         \"getblockhashes\",         &getblockhashes,         true  },\n     { \"blockchain\",         \"getblockhash\",           &getblockhash,           true,  {\"height\"} },\n     { \"blockchain\",         \"getblockheader\",         &getblockheader,         true,  {\"blockhash\",\"verbose\"} },\n     { \"blockchain\",         \"getchaintips\",           &getchaintips,           true,  {} },\n@@ -1503,6 +1712,7 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,  {} },\n     { \"blockchain\",         \"pruneblockchain\",        &pruneblockchain,        true,  {\"height\"} },\n     { \"blockchain\",         \"verifychain\",            &verifychain,            true,  {\"checklevel\",\"nblocks\"} },\n+    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false },\n \n     { \"blockchain\",         \"preciousblock\",          &preciousblock,          true,  {\"blockhash\"} },\n "
      },
      {
        "sha": "13d8734b4cec3d2430736be4505e695bd069694a",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=65cbc4c31905ae30e5706e859d56427474d500a0",
        "patch": "@@ -113,6 +113,15 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"setnetworkactive\", 0, \"state\" },\n     { \"getmempoolancestors\", 1, \"verbose\" },\n     { \"getmempooldescendants\", 1, \"verbose\" },\n+    { \"getblockhashes\", 0 },\n+    { \"getblockhashes\", 1 },\n+    { \"getblockhashes\", 2 },\n+    { \"getspentinfo\", 0},\n+    { \"getaddresstxids\", 0},\n+    { \"getaddressbalance\", 0},\n+    { \"getaddressdeltas\", 0},\n+    { \"getaddressutxos\", 0},\n+    { \"getaddressmempool\", 0},\n     { \"bumpfee\", 1, \"options\" },\n     { \"logging\", 0, \"include\" },\n     { \"logging\", 1, \"exclude\" },"
      },
      {
        "sha": "be3597d6fab7773f1803806aa8c27b4993738cf5",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 535,
        "deletions": 0,
        "changes": 535,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=65cbc4c31905ae30e5706e859d56427474d500a0",
        "patch": "@@ -14,6 +14,7 @@\n #include \"rpc/blockchain.h\"\n #include \"rpc/server.h\"\n #include \"timedata.h\"\n+#include \"txmempool.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #ifdef ENABLE_WALLET\n@@ -647,6 +648,13 @@ static const CRPCCommand commands[] =\n     { \"util\",               \"verifymessage\",          &verifymessage,          true,  {\"address\",\"signature\",\"message\"} },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true,  {\"privkey\",\"message\"} },\n \n+    /* Address index */\n+    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true  },\n+    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false },\n+    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false },\n+    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n+    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n+\n     /* Not shown in help */\n     { \"hidden\",             \"setmocktime\",            &setmocktime,            true,  {\"timestamp\"}},\n     { \"hidden\",             \"echo\",                   &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n@@ -659,3 +667,530 @@ void RegisterMiscRPCCommands(CRPCTable &t)\n     for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n         t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n }\n+\n+bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)\n+{\n+    if (type == 2) {\n+        address = CBitcoinAddress(CScriptID(hash)).ToString();\n+    } else if (type == 1) {\n+        address = CBitcoinAddress(CKeyID(hash)).ToString();\n+    } else {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool getAddressesFromParams(const UniValue& params, std::vector<std::pair<uint160, int> > &addresses)\n+{\n+    if (params[0].isStr()) {\n+        CBitcoinAddress address(params[0].get_str());\n+        uint160 hashBytes;\n+        int type = 0;\n+        if (!address.GetIndexKey(hashBytes, type)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+        }\n+        addresses.push_back(std::make_pair(hashBytes, type));\n+    } else if (params[0].isObject()) {\n+\n+        UniValue addressValues = find_value(params[0].get_obj(), \"addresses\");\n+        if (!addressValues.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Addresses is expected to be an array\");\n+        }\n+\n+        std::vector<UniValue> values = addressValues.getValues();\n+\n+        for (std::vector<UniValue>::iterator it = values.begin(); it != values.end(); ++it) {\n+\n+            CBitcoinAddress address(it->get_str());\n+            uint160 hashBytes;\n+            int type = 0;\n+            if (!address.GetIndexKey(hashBytes, type)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+            }\n+            addresses.push_back(std::make_pair(hashBytes, type));\n+        }\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    return true;\n+}\n+\n+bool heightSort(std::pair<CAddressUnspentKey, CAddressUnspentValue> a,\n+                std::pair<CAddressUnspentKey, CAddressUnspentValue> b) {\n+    return a.second.blockHeight < b.second.blockHeight;\n+}\n+\n+bool timestampSort(std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> a,\n+                   std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> b) {\n+    return a.second.time < b.second.time;\n+}\n+\n+UniValue getaddressmempool(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressmempool\\n\"\n+            \"\\nReturns all mempool deltas for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"timestamp\\\"  (number) The time the transaction entered the mempool (seconds)\\n\"\n+            \"    \\\"prevtxid\\\"  (string) The previous txid (if spending)\\n\"\n+            \"    \\\"prevout\\\"  (string) The previous transaction output index (if spending)\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressmempool\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressmempool\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > indexes;\n+\n+    if (!mempool.getAddressIndex(addresses, indexes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+    }\n+\n+    std::sort(indexes.begin(), indexes.end(), timestampSort);\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> >::iterator it = indexes.begin();\n+         it != indexes.end(); it++) {\n+\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.addressBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"address\", address));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"satoshis\", it->second.amount));\n+        delta.push_back(Pair(\"timestamp\", it->second.time));\n+        if (it->second.amount < 0) {\n+            delta.push_back(Pair(\"prevtxid\", it->second.prevhash.GetHex()));\n+            delta.push_back(Pair(\"prevout\", (int)it->second.prevout));\n+        }\n+        result.push_back(delta);\n+    }\n+\n+    return result;\n+}\n+\n+UniValue getaddressutxos(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressutxos\\n\"\n+            \"\\nReturns all unspent outputs for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ],\\n\"\n+            \"  \\\"chainInfo\\\"  (boolean) Include chain info with results\\n\"\n+            \"}\\n\"\n+            \"\\nResult\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The address base58check encoded\\n\"\n+            \"    \\\"txid\\\"  (string) The output txid\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"outputIndex\\\"  (number) The output index\\n\"\n+            \"    \\\"script\\\"  (strin) The script hex encoded\\n\"\n+            \"    \\\"satoshis\\\"  (number) The number of satoshis of the output\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressutxos\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressutxos\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+            );\n+\n+    bool includeChainInfo = false;\n+    if (params[0].isObject()) {\n+        UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n+        if (chainInfo.isBool()) {\n+            includeChainInfo = chainInfo.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > unspentOutputs;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressUnspent((*it).first, (*it).second, unspentOutputs)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    std::sort(unspentOutputs.begin(), unspentOutputs.end(), heightSort);\n+\n+    UniValue utxos(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=unspentOutputs.begin(); it!=unspentOutputs.end(); it++) {\n+        UniValue output(UniValue::VOBJ);\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        output.push_back(Pair(\"address\", address));\n+        output.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        output.push_back(Pair(\"outputIndex\", (int)it->first.index));\n+        output.push_back(Pair(\"script\", HexStr(it->second.script.begin(), it->second.script.end())));\n+        output.push_back(Pair(\"satoshis\", it->second.satoshis));\n+        output.push_back(Pair(\"height\", it->second.blockHeight));\n+        utxos.push_back(output);\n+    }\n+\n+    if (includeChainInfo) {\n+        UniValue result(UniValue::VOBJ);\n+        result.push_back(Pair(\"utxos\", utxos));\n+\n+        LOCK(cs_main);\n+        result.push_back(Pair(\"hash\", chainActive.Tip()->GetBlockHash().GetHex()));\n+        result.push_back(Pair(\"height\", (int)chainActive.Height()));\n+        return result;\n+    } else {\n+        return utxos;\n+    }\n+}\n+\n+UniValue getaddressdeltas(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1 || !params[0].isObject())\n+        throw runtime_error(\n+            \"getaddressdeltas\\n\"\n+            \"\\nReturns all changes for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"  \\\"chainInfo\\\" (boolean) Include chain info in results, only applies if start and end specified\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressdeltas\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressdeltas\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+\n+    UniValue startValue = find_value(params[0].get_obj(), \"start\");\n+    UniValue endValue = find_value(params[0].get_obj(), \"end\");\n+\n+    UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n+    bool includeChainInfo = false;\n+    if (chainInfo.isBool()) {\n+        includeChainInfo = chainInfo.get_bool();\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+\n+    if (startValue.isNum() && endValue.isNum()) {\n+        start = startValue.get_int();\n+        end = endValue.get_int();\n+        if (start <= 0 || end <= 0) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start and end is expected to be greater than zero\");\n+        }\n+        if (end < start) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"End value is expected to be greater than start\");\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"satoshis\", it->second));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"blockindex\", (int)it->first.txindex));\n+        delta.push_back(Pair(\"height\", it->first.blockHeight));\n+        delta.push_back(Pair(\"address\", address));\n+        deltas.push_back(delta);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    if (includeChainInfo && start > 0 && end > 0) {\n+        LOCK(cs_main);\n+\n+        if (start > chainActive.Height() || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start or end is outside chain range\");\n+        }\n+\n+        CBlockIndex* startIndex = chainActive[start];\n+        CBlockIndex* endIndex = chainActive[end];\n+\n+        UniValue startInfo(UniValue::VOBJ);\n+        UniValue endInfo(UniValue::VOBJ);\n+\n+        startInfo.push_back(Pair(\"hash\", startIndex->GetBlockHash().GetHex()));\n+        startInfo.push_back(Pair(\"height\", start));\n+\n+        endInfo.push_back(Pair(\"hash\", endIndex->GetBlockHash().GetHex()));\n+        endInfo.push_back(Pair(\"height\", end));\n+\n+        result.push_back(Pair(\"deltas\", deltas));\n+        result.push_back(Pair(\"start\", startInfo));\n+        result.push_back(Pair(\"end\", endInfo));\n+\n+        return result;\n+    } else {\n+        return deltas;\n+    }\n+}\n+\n+UniValue getaddressbalance(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressbalance\\n\"\n+            \"\\nReturns the balance for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"balance\\\"  (string) The current balance in satoshis\\n\"\n+            \"  \\\"received\\\"  (string) The total number of satoshis received (including change)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressbalance\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressbalance\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    CAmount balance = 0;\n+    CAmount received = 0;\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        if (it->second > 0) {\n+            received += it->second;\n+        }\n+        balance += it->second;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"balance\", balance));\n+    result.push_back(Pair(\"received\", received));\n+\n+    return result;\n+\n+}\n+\n+UniValue getaddresstxids(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"getaddresstxids\\n\"\n+            \"\\nReturns the txids for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"transactionid\\\"  (string) The transaction id\\n\"\n+            \"  ,...\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddresstxids\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddresstxids\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+    if (params[0].isObject()) {\n+        UniValue startValue = find_value(params[0].get_obj(), \"start\");\n+        UniValue endValue = find_value(params[0].get_obj(), \"end\");\n+        if (startValue.isNum() && endValue.isNum()) {\n+            start = startValue.get_int();\n+            end = endValue.get_int();\n+        }\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    std::set<std::pair<int, std::string> > txids;\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        int height = it->first.blockHeight;\n+        std::string txid = it->first.txhash.GetHex();\n+\n+        if (addresses.size() > 1) {\n+            txids.insert(std::make_pair(height, txid));\n+        } else {\n+            if (txids.insert(std::make_pair(height, txid)).second) {\n+                result.push_back(txid);\n+            }\n+        }\n+    }\n+\n+    if (addresses.size() > 1) {\n+        for (std::set<std::pair<int, std::string> >::const_iterator it=txids.begin(); it!=txids.end(); it++) {\n+            result.push_back(it->second);\n+        }\n+    }\n+\n+    return result;\n+\n+}\n+\n+UniValue getspentinfo(const UniValue& params, bool fHelp)\n+{\n+\n+    if (fHelp || params.size() != 1 || !params[0].isObject())\n+        throw runtime_error(\n+            \"getspentinfo\\n\"\n+            \"\\nReturns the txid and index where an output is spent.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\" (string) The hex string of the txid\\n\"\n+            \"  \\\"index\\\" (number) The start block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\"  (string) The transaction id\\n\"\n+            \"  \\\"index\\\"  (number) The spending input index\\n\"\n+            \"  ,...\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getspentinfo\", \"'{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}'\")\n+            + HelpExampleRpc(\"getspentinfo\", \"{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}\")\n+        );\n+\n+    UniValue txidValue = find_value(params[0].get_obj(), \"txid\");\n+    UniValue indexValue = find_value(params[0].get_obj(), \"index\");\n+\n+    if (!txidValue.isStr() || !indexValue.isNum()) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid txid or index\");\n+    }\n+\n+    uint256 txid = ParseHashV(txidValue, \"txid\");\n+    int outputIndex = indexValue.get_int();\n+\n+    CSpentIndexKey key(txid, outputIndex);\n+    CSpentIndexValue value;\n+\n+    if (!GetSpentIndex(key, value)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unable to get spent info\");\n+    }\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"txid\", value.txid.GetHex()));\n+    obj.push_back(Pair(\"index\", (int)value.inputIndex));\n+    obj.push_back(Pair(\"height\", value.blockHeight));\n+\n+    return obj;\n+}"
      },
      {
        "sha": "408633aaf14ca784c5b57ae345bac4ddd49521d9",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 124,
        "deletions": 10,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65cbc4c31905ae30e5706e859d56427474d500a0/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=65cbc4c31905ae30e5706e859d56427474d500a0",
        "patch": "@@ -35,6 +35,99 @@\n #include <univalue.h>\n \n \n+void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, UniValue& entry,\n+                      int nHeight = 0, int nConfirmations = 0, int nBlockTime = 0)\n+{\n+\n+    uint256 txid = tx.GetHash();\n+    entry.push_back(Pair(\"txid\", txid.GetHex()));\n+    entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n+    entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n+    entry.push_back(Pair(\"vsize\", (int)::GetVirtualTransactionSize(tx)));\n+    entry.push_back(Pair(\"version\", tx.nVersion));\n+    entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n+    UniValue vin(UniValue::VARR);\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+        UniValue in(UniValue::VOBJ);\n+        if (tx.IsCoinBase())\n+            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+        else {\n+            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n+            in.push_back(Pair(\"vout\", (int64_t)txin.prevout.n));\n+            UniValue o(UniValue::VOBJ);\n+            o.push_back(Pair(\"asm\", ScriptToAsmStr(txin.scriptSig, true)));\n+            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+            in.push_back(Pair(\"scriptSig\", o));\n+\n+            // Add address and value info if spentindex enabled\n+            CSpentIndexValue spentInfo;\n+            CSpentIndexKey spentKey(txin.prevout.hash, txin.prevout.n);\n+            if (GetSpentIndex(spentKey, spentInfo)) {\n+                in.push_back(Pair(\"value\", ValueFromAmount(spentInfo.satoshis)));\n+                in.push_back(Pair(\"valueSat\", spentInfo.satoshis));\n+                if (spentInfo.addressType == 1) {\n+                    in.push_back(Pair(\"address\", CBitcoinAddress(CKeyID(spentInfo.addressHash)).ToString()));\n+                } else if (spentInfo.addressType == 2)  {\n+                    in.push_back(Pair(\"address\", CBitcoinAddress(CScriptID(spentInfo.addressHash)).ToString()));\n+                }\n+            }\n+\n+        }\n+        if (!tx.wit.IsNull()) {\n+            if (!tx.wit.vtxinwit[i].IsNull()) {\n+                UniValue txinwitness(UniValue::VARR);\n+                for (unsigned int j = 0; j < tx.wit.vtxinwit[i].scriptWitness.stack.size(); j++) {\n+                    std::vector<unsigned char> item = tx.wit.vtxinwit[i].scriptWitness.stack[j];\n+                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n+                }\n+                in.push_back(Pair(\"txinwitness\", txinwitness));\n+            }\n+\n+        }\n+        in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n+        vin.push_back(in);\n+    }\n+    entry.push_back(Pair(\"vin\", vin));\n+    UniValue vout(UniValue::VARR);\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        const CTxOut& txout = tx.vout[i];\n+        UniValue out(UniValue::VOBJ);\n+        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n+        out.push_back(Pair(\"valueSat\", txout.nValue));\n+        out.push_back(Pair(\"n\", (int64_t)i));\n+        UniValue o(UniValue::VOBJ);\n+        ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n+        out.push_back(Pair(\"scriptPubKey\", o));\n+\n+        // Add spent information if spentindex is enabled\n+        CSpentIndexValue spentInfo;\n+        CSpentIndexKey spentKey(txid, i);\n+        if (GetSpentIndex(spentKey, spentInfo)) {\n+            out.push_back(Pair(\"spentTxId\", spentInfo.txid.GetHex()));\n+            out.push_back(Pair(\"spentIndex\", (int)spentInfo.inputIndex));\n+            out.push_back(Pair(\"spentHeight\", spentInfo.blockHeight));\n+        }\n+\n+        vout.push_back(out);\n+    }\n+    entry.push_back(Pair(\"vout\", vout));\n+\n+    if (!hashBlock.IsNull()) {\n+        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n+\n+        if (nConfirmations > 0) {\n+            entry.push_back(Pair(\"height\", nHeight));\n+            entry.push_back(Pair(\"confirmations\", nConfirmations));\n+            entry.push_back(Pair(\"time\", nBlockTime));\n+            entry.push_back(Pair(\"blocktime\", nBlockTime));\n+        } else {\n+            entry.push_back(Pair(\"height\", -1));\n+            entry.push_back(Pair(\"confirmations\", 0));\n+        }\n+    }\n+\n+}\n+\n void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n     // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\n@@ -50,12 +143,14 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n         if (mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex* pindex = (*mi).second;\n             if (chainActive.Contains(pindex)) {\n+                entry.push_back(Pair(\"height\", pindex->nHeight));\n                 entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n                 entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\n                 entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\n-            }\n-            else\n+            } else {\n+                entry.push_back(Pair(\"height\", -1));\n                 entry.push_back(Pair(\"confirmations\", 0));\n+            }\n         }\n     }\n }\n@@ -132,8 +227,6 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", true\")\n         );\n \n-    LOCK(cs_main);\n-\n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n \n     // Accept either a bool (true) or a num (>=1) to indicate verbose output.\n@@ -154,12 +247,32 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n         }\n     }\n \n-    CTransactionRef tx;\n+    CTransaction tx;\n+\n     uint256 hashBlock;\n-    if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n-            : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\") +\n-            \". Use gettransaction for wallet transactions.\");\n+    int nHeight = 0;\n+    int nConfirmations = 0;\n+    int nBlockTime = 0;\n+\n+    {\n+        LOCK(cs_main);\n+        if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n+\n+        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n+        if (mi != mapBlockIndex.end() && (*mi).second) {\n+            CBlockIndex* pindex = (*mi).second;\n+            if (chainActive.Contains(pindex)) {\n+                nHeight = pindex->nHeight;\n+                nConfirmations = 1 + chainActive.Height() - pindex->nHeight;\n+                nBlockTime = pindex->GetBlockTime();\n+            } else {\n+                nHeight = -1;\n+                nConfirmations = 0;\n+                nBlockTime = pindex->GetBlockTime();\n+            }\n+        }\n+    }\n \n     std::string strHex = EncodeHexTx(*tx, RPCSerializationFlags());\n \n@@ -168,7 +281,8 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n \n     UniValue result(UniValue::VOBJ);\n     result.push_back(Pair(\"hex\", strHex));\n-    TxToJSON(*tx, hashBlock, result);\n+    TxToJSONExpanded(*tx, hashBlock, result, nHeight, nConfirmations, nBlockTime);\n+\n     return result;\n }\n "
      }
    ]
  },
  {
    "sha": "74241141baa2b0571178232e8d3f9b59f6285e4c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NDI0MTE0MWJhYTJiMDU3MTE3ODIzMmU4ZDNmOWI1OWY2Mjg1ZTRj",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T19:01:44Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "tests: adds rpc tests for address, spent and timestamp indexes\n\nTests the functionality of the indexes as well as the rpc commands",
      "tree": {
        "sha": "7e662bd5dc76f200f7c3681a2fe005c15c40badf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e662bd5dc76f200f7c3681a2fe005c15c40badf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/74241141baa2b0571178232e8d3f9b59f6285e4c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74241141baa2b0571178232e8d3f9b59f6285e4c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/74241141baa2b0571178232e8d3f9b59f6285e4c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74241141baa2b0571178232e8d3f9b59f6285e4c/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "65cbc4c31905ae30e5706e859d56427474d500a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65cbc4c31905ae30e5706e859d56427474d500a0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65cbc4c31905ae30e5706e859d56427474d500a0"
      }
    ],
    "stats": {
      "total": 626,
      "additions": 626,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8b0b6d38af41ef9ad856eb391f9bb6b98a6cd701",
        "filename": "qa/rpc-tests/addressindex.py",
        "status": "added",
        "additions": 349,
        "deletions": 0,
        "changes": 349,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/addressindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/addressindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/addressindex.py?ref=74241141baa2b0571178232e8d3f9b59f6285e4c",
        "patch": "@@ -0,0 +1,349 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test addressindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class AddressIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-relaypriority=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-addressindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-addressindex\", \"-relaypriority=0\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-addressindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+        assert_equal(self.nodes[1].getbalance(), 0)\n+        assert_equal(self.nodes[2].getbalance(), 0)\n+\n+        # Check that balances are correct\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 0)\n+\n+        # Check p2pkh and p2sh address indexes\n+        print \"Testing p2pkh and p2sh address index...\"\n+\n+        txid0 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 10)\n+        self.nodes[0].generate(1)\n+\n+        txidb0 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 10)\n+        self.nodes[0].generate(1)\n+\n+        txid1 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 15)\n+        self.nodes[0].generate(1)\n+\n+        txidb1 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 15)\n+        self.nodes[0].generate(1)\n+\n+        txid2 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 20)\n+        self.nodes[0].generate(1)\n+\n+        txidb2 = self.nodes[0].sendtoaddress(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", 20)\n+        self.nodes[0].generate(1)\n+\n+        self.sync_all()\n+\n+        txids = self.nodes[1].getaddresstxids(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\")\n+        assert_equal(len(txids), 3)\n+        assert_equal(txids[0], txid0)\n+        assert_equal(txids[1], txid1)\n+        assert_equal(txids[2], txid2)\n+\n+        txidsb = self.nodes[1].getaddresstxids(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(len(txidsb), 3)\n+        assert_equal(txidsb[0], txidb0)\n+        assert_equal(txidsb[1], txidb1)\n+        assert_equal(txidsb[2], txidb2)\n+\n+        # Check that limiting by height works\n+        print \"Testing querying txids by range of block heights..\"\n+        height_txids = self.nodes[1].getaddresstxids({\n+            \"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\"],\n+            \"start\": 105,\n+            \"end\": 110\n+        })\n+        assert_equal(len(height_txids), 2)\n+        assert_equal(height_txids[0], txidb0)\n+        assert_equal(height_txids[1], txidb1)\n+\n+        # Check that multiple addresses works\n+        multitxids = self.nodes[1].getaddresstxids({\"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\", \"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\"]})\n+        assert_equal(len(multitxids), 6)\n+        assert_equal(multitxids[0], txid0)\n+        assert_equal(multitxids[1], txidb0)\n+        assert_equal(multitxids[2], txid1)\n+        assert_equal(multitxids[3], txidb1)\n+        assert_equal(multitxids[4], txid2)\n+        assert_equal(multitxids[5], txidb2)\n+\n+        # Check that balances are correct\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 45 * 100000000)\n+\n+        # Check that outputs with the same address will only return one txid\n+        print \"Testing for txid uniqueness...\"\n+        addressHash = \"6349a418fc4578d10a372b54b45c280cc8c4382f\".decode(\"hex\")\n+        scriptPubKey = CScript([OP_HASH160, addressHash, OP_EQUAL])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(10, scriptPubKey), CTxOut(11, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        sent_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txidsmany = self.nodes[1].getaddresstxids(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(len(txidsmany), 4)\n+        assert_equal(txidsmany[3], sent_txid)\n+\n+        # Check that balances are correct\n+        print \"Testing balances...\"\n+        balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n+        assert_equal(balance0[\"balance\"], 45 * 100000000 + 21)\n+\n+        # Check that balances are correct after spending\n+        print \"Testing balances after spending...\"\n+        privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n+        self.nodes[0].importprivkey(privkey2)\n+\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vout = [CTxOut(amount, scriptPubKey2)]\n+        tx.rehash()\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        spending_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        balance1 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance1[\"balance\"], amount)\n+\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(spending_txid, 16), 0))]\n+        send_amount = 1 * 100000000 + 12840\n+        change_amount = amount - send_amount - 10000\n+        tx.vout = [CTxOut(change_amount, scriptPubKey2), CTxOut(send_amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        sent_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        balance2 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance2[\"balance\"], change_amount)\n+\n+        # Check that deltas are returned correctly\n+        deltas = self.nodes[1].getaddressdeltas({\"addresses\": [address2], \"start\": 1, \"end\": 200})\n+        balance3 = 0\n+        for delta in deltas:\n+            balance3 += delta[\"satoshis\"]\n+        assert_equal(balance3, change_amount)\n+        assert_equal(deltas[0][\"address\"], address2)\n+        assert_equal(deltas[0][\"blockindex\"], 1)\n+\n+        # Check that entire range will be queried\n+        deltasAll = self.nodes[1].getaddressdeltas({\"addresses\": [address2]})\n+        assert_equal(len(deltasAll), len(deltas))\n+\n+        # Check that deltas can be returned from range of block heights\n+        deltas = self.nodes[1].getaddressdeltas({\"addresses\": [address2], \"start\": 113, \"end\": 113})\n+        assert_equal(len(deltas), 1)\n+\n+        # Check that unspent outputs can be queried\n+        print \"Testing utxos...\"\n+        utxos = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos), 1)\n+        assert_equal(utxos[0][\"satoshis\"], change_amount)\n+\n+        # Check that indexes will be updated with a reorg\n+        print \"Testing reorg...\"\n+\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        self.nodes[1].invalidateblock(best_hash)\n+        self.nodes[2].invalidateblock(best_hash)\n+        self.nodes[3].invalidateblock(best_hash)\n+        self.sync_all()\n+\n+        balance4 = self.nodes[1].getaddressbalance(address2)\n+        assert_equal(balance4, balance1)\n+\n+        utxos2 = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos2), 1)\n+        assert_equal(utxos2[0][\"satoshis\"], amount)\n+\n+        # Check sorting of utxos\n+        self.nodes[2].generate(150)\n+\n+        txidsort1 = self.nodes[2].sendtoaddress(address2, 50)\n+        self.nodes[2].generate(1)\n+        txidsort2 = self.nodes[2].sendtoaddress(address2, 50)\n+        self.nodes[2].generate(1)\n+        self.sync_all()\n+\n+        utxos3 = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n+        assert_equal(len(utxos3), 3)\n+        assert_equal(utxos3[0][\"height\"], 114)\n+        assert_equal(utxos3[1][\"height\"], 264)\n+        assert_equal(utxos3[2][\"height\"], 265)\n+\n+        # Check mempool indexing\n+        print \"Testing mempool indexing...\"\n+\n+        privKey3 = \"cVfUn53hAbRrDEuMexyfgDpZPhF7KqXpS8UZevsyTDaugB7HZ3CD\"\n+        address3 = \"mw4ynwhS7MmrQ27hr82kgqu7zryNDK26JB\"\n+        addressHash3 = \"aa9872b5bbcdb511d89e0e11aa27da73fd2c3f50\".decode(\"hex\")\n+        scriptPubKey3 = CScript([OP_DUP, OP_HASH160, addressHash3, OP_EQUALVERIFY, OP_CHECKSIG])\n+        address4 = \"2N8oFVB2vThAKury4vnLquW2zVjsYjjAkYQ\"\n+        scriptPubKey4 = CScript([OP_HASH160, addressHash3, OP_EQUAL])\n+        unspent = self.nodes[2].listunspent()\n+\n+        tx = CTransaction()\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vout = [CTxOut(amount, scriptPubKey3)]\n+        tx.rehash()\n+        signed_tx = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        memtxid1 = self.nodes[2].sendrawtransaction(signed_tx[\"hex\"], True)\n+        time.sleep(2)\n+\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(int(unspent[1][\"txid\"], 16), unspent[1][\"vout\"]))]\n+        amount = unspent[1][\"amount\"] * 100000000\n+        tx2.vout = [\n+            CTxOut(amount / 4, scriptPubKey3),\n+            CTxOut(amount / 4, scriptPubKey3),\n+            CTxOut(amount / 4, scriptPubKey4),\n+            CTxOut(amount / 4, scriptPubKey4)\n+        ]\n+        tx2.rehash()\n+        signed_tx2 = self.nodes[2].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n+        memtxid2 = self.nodes[2].sendrawtransaction(signed_tx2[\"hex\"], True)\n+        time.sleep(2)\n+\n+        mempool = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool), 3)\n+        assert_equal(mempool[0][\"txid\"], memtxid1)\n+        assert_equal(mempool[0][\"address\"], address3)\n+        assert_equal(mempool[0][\"index\"], 0)\n+        assert_equal(mempool[1][\"txid\"], memtxid2)\n+        assert_equal(mempool[1][\"index\"], 0)\n+        assert_equal(mempool[2][\"txid\"], memtxid2)\n+        assert_equal(mempool[2][\"index\"], 1)\n+\n+        self.nodes[2].generate(1);\n+        self.sync_all();\n+        mempool2 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool2), 0)\n+\n+        tx = CTransaction()\n+        tx.vin = [\n+            CTxIn(COutPoint(int(memtxid2, 16), 0)),\n+            CTxIn(COutPoint(int(memtxid2, 16), 1))\n+        ]\n+        tx.vout = [CTxOut(amount / 2 - 10000, scriptPubKey2)]\n+        tx.rehash()\n+        self.nodes[2].importprivkey(privKey3)\n+        signed_tx3 = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        memtxid3 = self.nodes[2].sendrawtransaction(signed_tx3[\"hex\"], True)\n+        time.sleep(2)\n+\n+        mempool3 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n+        assert_equal(len(mempool3), 2)\n+        assert_equal(mempool3[0][\"prevtxid\"], memtxid2)\n+        assert_equal(mempool3[0][\"prevout\"], 0)\n+        assert_equal(mempool3[1][\"prevtxid\"], memtxid2)\n+        assert_equal(mempool3[1][\"prevout\"], 1)\n+\n+        # sending and receiving to the same address\n+        privkey1 = \"cQY2s58LhzUCmEXN8jtAp1Etnijx78YRZ466w4ikX1V4UpTpbsf8\"\n+        address1 = \"myAUWSHnwsQrhuMWv4Br6QsCnpB41vFwHn\"\n+        address1hash = \"c192bff751af8efec15135d42bfeedf91a6f3e34\".decode(\"hex\")\n+        address1script = CScript([OP_DUP, OP_HASH160, address1hash, OP_EQUALVERIFY, OP_CHECKSIG])\n+\n+        self.nodes[0].sendtoaddress(address1, 10)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        utxos = self.nodes[1].getaddressutxos({\"addresses\": [address1]})\n+        assert_equal(len(utxos), 1)\n+\n+        tx = CTransaction()\n+        tx.vin = [\n+            CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"outputIndex\"]))\n+        ]\n+        amount = utxos[0][\"satoshis\"] - 1000\n+        tx.vout = [CTxOut(amount, address1script)]\n+        tx.rehash()\n+        self.nodes[0].importprivkey(privkey1)\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        mem_txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+\n+        self.sync_all()\n+        mempool_deltas = self.nodes[2].getaddressmempool({\"addresses\": [address1]})\n+        assert_equal(len(mempool_deltas), 2)\n+\n+        # Include chaininfo in results\n+        print \"Testing results with chain info...\"\n+\n+        deltas_with_info = self.nodes[1].getaddressdeltas({\n+            \"addresses\": [address2],\n+            \"start\": 1,\n+            \"end\": 200,\n+            \"chainInfo\": True\n+        })\n+        start_block_hash = self.nodes[1].getblockhash(1);\n+        end_block_hash = self.nodes[1].getblockhash(200);\n+        assert_equal(deltas_with_info[\"start\"][\"height\"], 1)\n+        assert_equal(deltas_with_info[\"start\"][\"hash\"], start_block_hash)\n+        assert_equal(deltas_with_info[\"end\"][\"height\"], 200)\n+        assert_equal(deltas_with_info[\"end\"][\"hash\"], end_block_hash)\n+\n+        utxos_with_info = self.nodes[1].getaddressutxos({\"addresses\": [address2], \"chainInfo\": True})\n+        expected_tip_block_hash = self.nodes[1].getblockhash(267);\n+        assert_equal(utxos_with_info[\"height\"], 267)\n+        assert_equal(utxos_with_info[\"hash\"], expected_tip_block_hash)\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    AddressIndexTest().main()"
      },
      {
        "sha": "1366dbe315e4f1ae88cd3281cb6c4da21edf04f7",
        "filename": "qa/rpc-tests/spentindex.py",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/spentindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/spentindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/spentindex.py?ref=74241141baa2b0571178232e8d3f9b59f6285e4c",
        "patch": "@@ -0,0 +1,139 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test addressindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class SpentIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-spentindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-spentindex\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-spentindex\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+\n+        # Check that\n+        print \"Testing spent index...\"\n+\n+        privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        print \"Testing getspentinfo method...\"\n+\n+        # Check that the spentinfo works standalone\n+        info = self.nodes[1].getspentinfo({\"txid\": unspent[0][\"txid\"], \"index\": unspent[0][\"vout\"]})\n+        assert_equal(info[\"txid\"], txid)\n+        assert_equal(info[\"index\"], 0)\n+        assert_equal(info[\"height\"], 106)\n+\n+        print \"Testing getrawtransaction method...\"\n+\n+        # Check that verbose raw transaction includes spent info\n+        txVerbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentTxId\"], txid)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentIndex\"], 0)\n+        assert_equal(txVerbose[\"vout\"][unspent[0][\"vout\"]][\"spentHeight\"], 106)\n+\n+        # Check that verbose raw transaction includes input values\n+        txVerbose2 = self.nodes[3].getrawtransaction(txid, 1)\n+        assert_equal(txVerbose2[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n+        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount)\n+\n+        # Check that verbose raw transaction includes address values and input values\n+        privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(int(txid, 16), 0))]\n+        tx2.vout = [CTxOut(amount, scriptPubKey2)]\n+        tx.rehash()\n+        self.nodes[0].importprivkey(privkey)\n+        signed_tx2 = self.nodes[0].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n+        txid2 = self.nodes[0].sendrawtransaction(signed_tx2[\"hex\"], True)\n+\n+        # Check the mempool index\n+        self.sync_all()\n+        txVerbose3 = self.nodes[1].getrawtransaction(txid2, 1)\n+        assert_equal(txVerbose3[\"vin\"][0][\"address\"], address2)\n+        assert_equal(txVerbose3[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n+        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount)\n+\n+        # Check the database index\n+        block_hash = self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        txVerbose4 = self.nodes[3].getrawtransaction(txid2, 1)\n+        assert_equal(txVerbose4[\"vin\"][0][\"address\"], address2)\n+        assert_equal(txVerbose4[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n+        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount)\n+\n+\n+        # Check block deltas\n+        print \"Testing getblockdeltas...\"\n+\n+        block = self.nodes[3].getblockdeltas(block_hash[0])\n+        assert_equal(len(block[\"deltas\"]), 2)\n+        assert_equal(block[\"deltas\"][0][\"index\"], 0)\n+        assert_equal(len(block[\"deltas\"][0][\"inputs\"]), 0)\n+        assert_equal(len(block[\"deltas\"][0][\"outputs\"]), 0)\n+        assert_equal(block[\"deltas\"][1][\"index\"], 1)\n+        assert_equal(block[\"deltas\"][1][\"txid\"], txid2)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"index\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], amount * -1)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevtxid\"], txid)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevout\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"index\"], 0)\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n+        assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"satoshis\"], amount)\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    SpentIndexTest().main()"
      },
      {
        "sha": "289c81b2a5212df1c623d4aaced5bda32a1906c3",
        "filename": "qa/rpc-tests/timestampindex.py",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/timestampindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/timestampindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/timestampindex.py?ref=74241141baa2b0571178232e8d3f9b59f6285e4c",
        "patch": "@@ -0,0 +1,61 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test timestampindex generation and fetching\n+#\n+\n+import time\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+\n+class TimestampIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-timestampindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-timestampindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining 25 blocks...\"\n+        blockhashes = self.nodes[0].generate(25)\n+        time.sleep(3)\n+        print \"Mining 25 blocks...\"\n+        blockhashes.extend(self.nodes[0].generate(25))\n+        time.sleep(3)\n+        print \"Mining 25 blocks...\"\n+        blockhashes.extend(self.nodes[0].generate(25))\n+        self.sync_all()\n+        low = self.nodes[1].getblock(blockhashes[0])[\"time\"]\n+        high = low + 76\n+\n+        print \"Checking timestamp index...\"\n+        hashes = self.nodes[1].getblockhashes(high, low)\n+\n+        assert_equal(len(hashes), len(blockhashes))\n+\n+        assert_equal(hashes, blockhashes)\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    TimestampIndexTest().main()"
      },
      {
        "sha": "b139253b769ec2a7ecb51bf94f463291bb6a0a28",
        "filename": "qa/rpc-tests/txindex.py",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/txindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74241141baa2b0571178232e8d3f9b59f6285e4c/qa/rpc-tests/txindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txindex.py?ref=74241141baa2b0571178232e8d3f9b59f6285e4c",
        "patch": "@@ -0,0 +1,73 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test txindex generation and fetching\n+#\n+\n+import time\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+class TxIndexTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 4)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        # Nodes 0/1 are \"wallet\" nodes\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        # Nodes 2/3 are used for testing\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[0], 3)\n+\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        print \"Mining blocks...\"\n+        self.nodes[0].generate(105)\n+        self.sync_all()\n+\n+        chain_height = self.nodes[1].getblockcount()\n+        assert_equal(chain_height, 105)\n+\n+        print \"Testing transaction index...\"\n+\n+        privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n+        address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n+        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        unspent = self.nodes[0].listunspent()\n+        tx = CTransaction()\n+        amount = unspent[0][\"amount\"] * 100000000\n+        tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n+        tx.vout = [CTxOut(amount, scriptPubKey)]\n+        tx.rehash()\n+\n+        signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n+        txid = self.nodes[0].sendrawtransaction(signed_tx[\"hex\"], True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # Check verbose raw transaction results\n+        verbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n+        assert_equal(verbose[\"vout\"][0][\"valueSat\"], 5000000000);\n+        assert_equal(verbose[\"vout\"][0][\"value\"], 50);\n+\n+        print \"Passed\\n\"\n+\n+\n+if __name__ == '__main__':\n+    TxIndexTest().main()"
      },
      {
        "sha": "f07fe80819c1a2080e60bf45760093664145d932",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74241141baa2b0571178232e8d3f9b59f6285e4c/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74241141baa2b0571178232e8d3f9b59f6285e4c/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=74241141baa2b0571178232e8d3f9b59f6285e4c",
        "patch": "@@ -90,6 +90,10 @@\n     'multi_rpc.py',\n     'proxy_test.py',\n     'signrawtransactions.py',\n+    'addressindex.py',\n+    'timestampindex.py',\n+    'spentindex.py',\n+    'txindex.py',\n     'disconnect_ban.py',\n     'decodescript.py',\n     'blockchain.py',"
      }
    ]
  },
  {
    "sha": "9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YWUzMjJkMDZkM2RjMjhjYzg5OGM0NGE1Y2QzMmFiODhjNTg1OGMx",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-04T19:03:13Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "tests: adds unit test for IsPayToPublicKeyHash method",
      "tree": {
        "sha": "287ff2502be9754ddc4d697a96796f9222ce855c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/287ff2502be9754ddc4d697a96796f9222ce855c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "74241141baa2b0571178232e8d3f9b59f6285e4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74241141baa2b0571178232e8d3f9b59f6285e4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/74241141baa2b0571178232e8d3f9b59f6285e4c"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 60,
      "deletions": 0
    },
    "files": [
      {
        "sha": "df30e9653e49c12b54190cec22810de60eb9125c",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
        "patch": "@@ -64,6 +64,7 @@ BITCOIN_TESTS =\\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\\n   test/script_P2SH_tests.cpp \\\n+  test/script_P2PKH_tests.cpp \\\n   test/script_tests.cpp \\\n   test/scriptnum_tests.cpp \\\n   test/serialize_tests.cpp \\"
      },
      {
        "sha": "3a7dc16608aaac610bf97577a66cf4038d3f4396",
        "filename": "src/test/script_P2PKH_tests.cpp",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1/src/test/script_P2PKH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1/src/test/script_P2PKH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2PKH_tests.cpp?ref=9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2012-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script/script.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+using namespace std;\n+\n+BOOST_FIXTURE_TEST_SUITE(script_P2PKH_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(IsPayToPublicKeyHash)\n+{\n+    // Test CScript::IsPayToPublicKeyHash()\n+    uint160 dummy;\n+    CScript p2pkh;\n+    p2pkh << OP_DUP << OP_HASH160 << ToByteVector(dummy) << OP_EQUALVERIFY << OP_CHECKSIG;\n+    BOOST_CHECK(p2pkh.IsPayToPublicKeyHash());\n+\n+    static const unsigned char direct[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char notp2pkh1[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(notp2pkh1, notp2pkh1+sizeof(notp2pkh1)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char p2sh[] = {\n+        OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL\n+    };\n+    BOOST_CHECK(!CScript(p2sh, p2sh+sizeof(p2sh)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char extra[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(extra, extra+sizeof(extra)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char missing[] = {\n+        OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUALVERIFY, OP_CHECKSIG, OP_RETURN\n+    };\n+    BOOST_CHECK(!CScript(missing, missing+sizeof(missing)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char missing2[] = {\n+        OP_DUP, OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+    };\n+    BOOST_CHECK(!CScript(missing2, missing2+sizeof(missing)).IsPayToPublicKeyHash());\n+\n+    static const unsigned char tooshort[] = {\n+        OP_DUP, OP_HASH160, 2, 0,0, OP_EQUALVERIFY, OP_CHECKSIG\n+    };\n+    BOOST_CHECK(!CScript(tooshort, tooshort+sizeof(direct)).IsPayToPublicKeyHash());\n+\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "1b99ecb09117ba0865737870279d02714d554c0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYjk5ZWNiMDkxMTdiYTA4NjU3Mzc4NzAyNzlkMDI3MTRkNTU0YzBj",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T18:21:25Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "indexes: refactoring and fixes applying changes to 0.13",
      "tree": {
        "sha": "9f2cfc7e93697d9ad4d9bb67ea0416afb2d266ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9f2cfc7e93697d9ad4d9bb67ea0416afb2d266ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1b99ecb09117ba0865737870279d02714d554c0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b99ecb09117ba0865737870279d02714d554c0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1b99ecb09117ba0865737870279d02714d554c0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b99ecb09117ba0865737870279d02714d554c0c/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ae322d06d3dc28cc898c44a5cd32ab88c5858c1"
      }
    ],
    "stats": {
      "total": 737,
      "additions": 374,
      "deletions": 363
    },
    "files": [
      {
        "sha": "dbb09c7fe9b4c4e2d76a1facdc57d031520c498f",
        "filename": "src/addressindex.h",
        "status": "modified",
        "additions": 213,
        "deletions": 0,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/addressindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/addressindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addressindex.h?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -8,6 +8,219 @@\n \n #include \"uint256.h\"\n #include \"amount.h\"\n+#include \"script/script.h\"\n+\n+struct CAddressUnspentKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    uint256 txhash;\n+    size_t index;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 57;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+    }\n+\n+    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        txhash = txid;\n+        index = indexValue;\n+    }\n+\n+    CAddressUnspentKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        txhash.SetNull();\n+        index = 0;\n+    }\n+};\n+\n+struct CAddressUnspentValue {\n+    CAmount satoshis;\n+    CScript script;\n+    int blockHeight;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(satoshis);\n+        READWRITE(*(CScriptBase*)(&script));\n+        READWRITE(blockHeight);\n+    }\n+\n+    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n+        satoshis = sats;\n+        script = scriptPubKey;\n+        blockHeight = height;\n+    }\n+\n+    CAddressUnspentValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        satoshis = -1;\n+        script.clear();\n+        blockHeight = 0;\n+    }\n+\n+    bool IsNull() const {\n+        return (satoshis == -1);\n+    }\n+};\n+\n+struct CAddressIndexKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+    unsigned int txindex;\n+    uint256 txhash;\n+    size_t index;\n+    bool spending;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 66;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        // Heights are stored big-endian for key sorting in LevelDB\n+        ser_writedata32be(s, blockHeight);\n+        ser_writedata32be(s, txindex);\n+        txhash.Serialize(s, nType, nVersion);\n+        ser_writedata32(s, index);\n+        char f = spending;\n+        ser_writedata8(s, f);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+        txindex = ser_readdata32be(s);\n+        txhash.Unserialize(s, nType, nVersion);\n+        index = ser_readdata32(s);\n+        char f = ser_readdata8(s);\n+        spending = f;\n+    }\n+\n+    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n+                     uint256 txid, size_t indexValue, bool isSpending) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+        txindex = blockindex;\n+        txhash = txid;\n+        index = indexValue;\n+        spending = isSpending;\n+    }\n+\n+    CAddressIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+        txindex = 0;\n+        txhash.SetNull();\n+        index = 0;\n+        spending = false;\n+    }\n+\n+};\n+\n+struct CAddressIndexIteratorKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 21;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+    }\n+\n+    CAddressIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+    }\n+};\n+\n+struct CAddressIndexIteratorHeightKey {\n+    unsigned int type;\n+    uint160 hashBytes;\n+    int blockHeight;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 25;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata8(s, type);\n+        hashBytes.Serialize(s, nType, nVersion);\n+        ser_writedata32be(s, blockHeight);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        type = ser_readdata8(s);\n+        hashBytes.Unserialize(s, nType, nVersion);\n+        blockHeight = ser_readdata32be(s);\n+    }\n+\n+    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n+        type = addressType;\n+        hashBytes = addressHash;\n+        blockHeight = height;\n+    }\n+\n+    CAddressIndexIteratorHeightKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        type = 0;\n+        hashBytes.SetNull();\n+        blockHeight = 0;\n+    }\n+};\n \n struct CMempoolAddressDelta\n {"
      },
      {
        "sha": "2c159631093ecfb94c358569cc3ed71c82204651",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -1712,7 +1712,6 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,  {} },\n     { \"blockchain\",         \"pruneblockchain\",        &pruneblockchain,        true,  {\"height\"} },\n     { \"blockchain\",         \"verifychain\",            &verifychain,            true,  {\"checklevel\",\"nblocks\"} },\n-    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false },\n \n     { \"blockchain\",         \"preciousblock\",          &preciousblock,          true,  {\"blockhash\"} },\n "
      },
      {
        "sha": "1641e4c531f3cd08a3c89f789c42c44569a1a72b",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -655,6 +655,9 @@ static const CRPCCommand commands[] =\n     { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n     { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n \n+    /* Blockchain */\n+    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false, {} },\n+\n     /* Not shown in help */\n     { \"hidden\",             \"setmocktime\",            &setmocktime,            true,  {\"timestamp\"}},\n     { \"hidden\",             \"echo\",                   &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},"
      },
      {
        "sha": "998fa0d376d21637b3a560f771788830fc397b87",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -47,7 +47,8 @@ void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, UniValue&\n     entry.push_back(Pair(\"version\", tx.nVersion));\n     entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n     UniValue vin(UniValue::VARR);\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        const CTxIn& txin = tx.vin[i];\n         UniValue in(UniValue::VOBJ);\n         if (tx.IsCoinBase())\n             in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));"
      },
      {
        "sha": "ea792797e18e1bef590c0e8798fb9cfa28c67a3a",
        "filename": "src/timestampindex.h",
        "status": "added",
        "additions": 131,
        "deletions": 0,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/timestampindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/timestampindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timestampindex.h?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -0,0 +1,131 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TIMESTAMPINDEX_H\n+#define BITCOIN_TIMESTAMPINDEX_H\n+\n+#include \"uint256.h\"\n+\n+struct CTimestampIndexIteratorKey {\n+    unsigned int timestamp;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampIndexIteratorKey(unsigned int time) {\n+        timestamp = time;\n+    }\n+\n+    CTimestampIndexIteratorKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+    }\n+};\n+\n+struct CTimestampIndexKey {\n+    unsigned int timestamp;\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 36;\n+    }\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, timestamp);\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        timestamp = ser_readdata32be(s);\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampIndexKey(unsigned int time, uint256 hash) {\n+        timestamp = time;\n+        blockHash = hash;\n+    }\n+\n+    CTimestampIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        timestamp = 0;\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexKey {\n+    uint256 blockHash;\n+\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 32;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        blockHash.Serialize(s, nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        blockHash.Unserialize(s, nType, nVersion);\n+    }\n+\n+    CTimestampBlockIndexKey(uint256 hash) {\n+        blockHash = hash;\n+    }\n+\n+    CTimestampBlockIndexKey() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        blockHash.SetNull();\n+    }\n+};\n+\n+struct CTimestampBlockIndexValue {\n+    unsigned int ltimestamp;\n+    size_t GetSerializeSize(int nType, int nVersion) const {\n+        return 4;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const {\n+        ser_writedata32be(s, ltimestamp);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion) {\n+        ltimestamp = ser_readdata32be(s);\n+    }\n+\n+    CTimestampBlockIndexValue (unsigned int time) {\n+        ltimestamp = time;\n+    }\n+\n+    CTimestampBlockIndexValue() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        ltimestamp = 0;\n+    }\n+};\n+\n+#endif // BITCOIN_TIMESTAMPINDEX_H"
      },
      {
        "sha": "5d07d4dd7e670e8e46e03be537ed510af207de6d",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 17,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -167,7 +167,7 @@ bool CBlockTreeDB::ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n }\n \n bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CSpentIndexKey,CSpentIndexValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n         if (it->second.IsNull()) {\n             batch.Erase(make_pair(DB_SPENTINDEX, it->first));\n@@ -179,7 +179,7 @@ bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey,\n }\n \n bool CBlockTreeDB::UpdateAddressUnspentIndex(const std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue > >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n         if (it->second.IsNull()) {\n             batch.Erase(make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n@@ -217,14 +217,14 @@ bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n }\n \n bool CBlockTreeDB::WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n         batch.Write(make_pair(DB_ADDRESSINDEX, it->first), it->second);\n     return WriteBatch(batch);\n }\n \n bool CBlockTreeDB::EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n         batch.Erase(make_pair(DB_ADDRESSINDEX, it->first));\n     return WriteBatch(batch);\n@@ -265,7 +265,7 @@ bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n }\n \n bool CBlockTreeDB::WriteTimestampIndex(const CTimestampIndexKey &timestampIndex) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     batch.Write(make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n     return WriteBatch(batch);\n }\n@@ -281,7 +281,7 @@ bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned i\n         std::pair<char, CTimestampIndexKey> key;\n         if (pcursor->GetKey(key) && key.first == DB_TIMESTAMPINDEX && key.second.timestamp < high) {\n             if (fActiveOnly) {\n-                if (blockOnchainActive(key.second.blockHash)) {\n+                if (HashOnchainActive(key.second.blockHash)) {\n                     hashes.push_back(std::make_pair(key.second.blockHash, key.second.timestamp));\n                 }\n             } else {\n@@ -298,7 +298,7 @@ bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned i\n }\n \n bool CBlockTreeDB::WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts) {\n-    CDBBatch batch(&GetObfuscateKey());\n+    CDBBatch batch(*this);\n     batch.Write(make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n     return WriteBatch(batch);\n }\n@@ -325,16 +325,6 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n-bool CBlockTreeDB::blockOnchainActive(const uint256 &hash) {\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n-    \n-    if (!chainActive.Contains(pblockindex)) {\n-        return false;\n-    }\n-    \n-    return true;\n-}\n-\n bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());"
      },
      {
        "sha": "4c6bd72030ff8277ad7eb9b85d4b425e9fe92bb8",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 12,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -6,9 +6,13 @@\n #ifndef BITCOIN_TXDB_H\n #define BITCOIN_TXDB_H\n \n+#include \"main.h\"\n #include \"coins.h\"\n #include \"dbwrapper.h\"\n #include \"chain.h\"\n+#include \"addressindex.h\"\n+#include \"spentindex.h\"\n+#include \"timestampindex.h\"\n \n #include <map>\n #include <string>\n@@ -19,17 +23,6 @@\n \n class CBlockIndex;\n class CCoinsViewDBCursor;\n-struct CAddressUnspentKey;\n-struct CAddressUnspentValue;\n-struct CAddressIndexKey;\n-struct CAddressIndexIteratorKey;\n-struct CAddressIndexIteratorHeightKey;\n-struct CTimestampIndexKey;\n-struct CTimestampIndexIteratorKey;\n-struct CTimestampBlockIndexKey;\n-struct CTimestampBlockIndexValue;\n-struct CSpentIndexKey;\n-struct CSpentIndexValue;\n class uint256;\n \n //! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n@@ -148,7 +141,6 @@ class CBlockTreeDB : public CDBWrapper\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n-    bool blockOnchainActive(const uint256 &hash);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "a840c57db4879e28f4bc41fba770e100574808ef",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -1017,6 +1017,17 @@ bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)\n     return true;\n }\n \n+bool HashOnchainActive(const uint256 &hash)\n+{\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    if (!chainActive.Contains(pblockindex)) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n bool GetAddressIndex(uint160 addressHash, int type,\n                      std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex, int start, int end)\n {"
      },
      {
        "sha": "7e8aebc6dee8b5a6bcf50e33b9e224c5a84d5907",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 332,
        "changes": 335,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b99ecb09117ba0865737870279d02714d554c0c/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b99ecb09117ba0865737870279d02714d554c0c/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=1b99ecb09117ba0865737870279d02714d554c0c",
        "patch": "@@ -19,6 +19,8 @@\n #include \"sync.h\"\n #include \"versionbits.h\"\n #include \"spentindex.h\"\n+#include \"addressindex.h\"\n+#include \"timestampindex.h\"\n \n #include <algorithm>\n #include <exception>\n@@ -346,338 +348,6 @@ ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::D\n /** Get the block height at which the BIP9 deployment switched into the state for the block building on the current tip. */\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n-struct CTimestampIndexIteratorKey {\n-    unsigned int timestamp;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 4;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata32be(s, timestamp);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        timestamp = ser_readdata32be(s);\n-    }\n-\n-    CTimestampIndexIteratorKey(unsigned int time) {\n-        timestamp = time;\n-    }\n-\n-    CTimestampIndexIteratorKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        timestamp = 0;\n-    }\n-};\n-\n-struct CTimestampIndexKey {\n-    unsigned int timestamp;\n-    uint256 blockHash;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 36;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata32be(s, timestamp);\n-        blockHash.Serialize(s, nType, nVersion);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        timestamp = ser_readdata32be(s);\n-        blockHash.Unserialize(s, nType, nVersion);\n-    }\n-\n-    CTimestampIndexKey(unsigned int time, uint256 hash) {\n-        timestamp = time;\n-        blockHash = hash;\n-    }\n-\n-    CTimestampIndexKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        timestamp = 0;\n-        blockHash.SetNull();\n-    }\n-};\n-\n-struct CTimestampBlockIndexKey {\n-    uint256 blockHash;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 32;\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        blockHash.Serialize(s, nType, nVersion);\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        blockHash.Unserialize(s, nType, nVersion);\n-    }\n-\n-    CTimestampBlockIndexKey(uint256 hash) {\n-        blockHash = hash;\n-    }\n-\n-    CTimestampBlockIndexKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        blockHash.SetNull();\n-    }\n-};\n-\n-struct CTimestampBlockIndexValue {\n-    unsigned int ltimestamp;\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 4;\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata32be(s, ltimestamp);\n-    }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        ltimestamp = ser_readdata32be(s);\n-    }\n-\n-    CTimestampBlockIndexValue (unsigned int time) {\n-        ltimestamp = time;\n-    }\n-\n-    CTimestampBlockIndexValue() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        ltimestamp = 0;\n-    }\n-};\n-\n-struct CAddressUnspentKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-    uint256 txhash;\n-    size_t index;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 57;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        txhash.Serialize(s, nType, nVersion);\n-        ser_writedata32(s, index);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        txhash.Unserialize(s, nType, nVersion);\n-        index = ser_readdata32(s);\n-    }\n-\n-    CAddressUnspentKey(unsigned int addressType, uint160 addressHash, uint256 txid, size_t indexValue) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-        txhash = txid;\n-        index = indexValue;\n-    }\n-\n-    CAddressUnspentKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-        txhash.SetNull();\n-        index = 0;\n-    }\n-};\n-\n-struct CAddressUnspentValue {\n-    CAmount satoshis;\n-    CScript script;\n-    int blockHeight;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(satoshis);\n-        READWRITE(*(CScriptBase*)(&script));\n-        READWRITE(blockHeight);\n-    }\n-\n-    CAddressUnspentValue(CAmount sats, CScript scriptPubKey, int height) {\n-        satoshis = sats;\n-        script = scriptPubKey;\n-        blockHeight = height;\n-    }\n-\n-    CAddressUnspentValue() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        satoshis = -1;\n-        script.clear();\n-        blockHeight = 0;\n-    }\n-\n-    bool IsNull() const {\n-        return (satoshis == -1);\n-    }\n-};\n-\n-struct CAddressIndexKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-    int blockHeight;\n-    unsigned int txindex;\n-    uint256 txhash;\n-    size_t index;\n-    bool spending;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 66;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        // Heights are stored big-endian for key sorting in LevelDB\n-        ser_writedata32be(s, blockHeight);\n-        ser_writedata32be(s, txindex);\n-        txhash.Serialize(s, nType, nVersion);\n-        ser_writedata32(s, index);\n-        char f = spending;\n-        ser_writedata8(s, f);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        blockHeight = ser_readdata32be(s);\n-        txindex = ser_readdata32be(s);\n-        txhash.Unserialize(s, nType, nVersion);\n-        index = ser_readdata32(s);\n-        char f = ser_readdata8(s);\n-        spending = f;\n-    }\n-\n-    CAddressIndexKey(unsigned int addressType, uint160 addressHash, int height, int blockindex,\n-                     uint256 txid, size_t indexValue, bool isSpending) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-        blockHeight = height;\n-        txindex = blockindex;\n-        txhash = txid;\n-        index = indexValue;\n-        spending = isSpending;\n-    }\n-\n-    CAddressIndexKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-        blockHeight = 0;\n-        txindex = 0;\n-        txhash.SetNull();\n-        index = 0;\n-        spending = false;\n-    }\n-\n-};\n-\n-struct CAddressIndexIteratorKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 21;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-    }\n-\n-    CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-    }\n-\n-    CAddressIndexIteratorKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-    }\n-};\n-\n-struct CAddressIndexIteratorHeightKey {\n-    unsigned int type;\n-    uint160 hashBytes;\n-    int blockHeight;\n-\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n-        return 25;\n-    }\n-    template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        ser_writedata32be(s, blockHeight);\n-    }\n-    template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        blockHeight = ser_readdata32be(s);\n-    }\n-\n-    CAddressIndexIteratorHeightKey(unsigned int addressType, uint160 addressHash, int height) {\n-        type = addressType;\n-        hashBytes = addressHash;\n-        blockHeight = height;\n-    }\n-\n-    CAddressIndexIteratorHeightKey() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        type = 0;\n-        hashBytes.SetNull();\n-        blockHeight = 0;\n-    }\n-};\n-\n /** \n  * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n  * @return number of sigops this transaction's outputs will produce when spent\n@@ -809,6 +479,7 @@ class CScriptCheck\n \n bool GetTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes);\n bool GetSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value);\n+bool HashOnchainActive(const uint256 &hash);\n bool GetAddressIndex(uint160 addressHash, int type,\n                      std::vector<std::pair<CAddressIndexKey, CAmount> > &addressIndex,\n                      int start = 0, int end = 0);"
      }
    ]
  },
  {
    "sha": "a74235ac4bacf97ebdad17afc6d0557476fe53a9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNzQyMzVhYzRiYWNmOTdlYmRhZDE3YWZjNmQwNTU3NDc2ZmU1M2E5",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T22:39:13Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "indexes: additional logging and checks for indexes",
      "tree": {
        "sha": "8f9a6344819ea22889c289aa8655bb58a06b23f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f9a6344819ea22889c289aa8655bb58a06b23f0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a74235ac4bacf97ebdad17afc6d0557476fe53a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a74235ac4bacf97ebdad17afc6d0557476fe53a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a74235ac4bacf97ebdad17afc6d0557476fe53a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a74235ac4bacf97ebdad17afc6d0557476fe53a9/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b99ecb09117ba0865737870279d02714d554c0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b99ecb09117ba0865737870279d02714d554c0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b99ecb09117ba0865737870279d02714d554c0c"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 27,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6723b781d4cbe6e99bcfd2544e44d625a5e67c71",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a74235ac4bacf97ebdad17afc6d0557476fe53a9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a74235ac4bacf97ebdad17afc6d0557476fe53a9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=a74235ac4bacf97ebdad17afc6d0557476fe53a9",
        "patch": "@@ -1485,6 +1485,24 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                // Check for changed -addressindex state\n+                if (fAddressIndex != GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -addressindex\");\n+                    break;\n+                }\n+\n+                // Check for changed -spentindex state\n+                if (fSpentIndex != GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -spentindex\");\n+                    break;\n+                }\n+\n+                // Check for changed -timestampindex state\n+                if (fTimestampIndex != GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX)) {\n+                    strLoadError = _(\"You need to rebuild the database using -reindex-chainstate to change -timestampindex\");\n+                    break;\n+                }\n+\n                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n                 // in the past, but is now trying to run unpruned.\n                 if (fHavePruned && !fPruneMode) {"
      },
      {
        "sha": "ec15fbb485e2e733bb7fab3c0cef614b55913f78",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a74235ac4bacf97ebdad17afc6d0557476fe53a9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a74235ac4bacf97ebdad17afc6d0557476fe53a9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a74235ac4bacf97ebdad17afc6d0557476fe53a9",
        "patch": "@@ -1843,6 +1843,7 @@ static int64_t nTimeTotal = 0;\n static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n                   CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false)\n {\n+\n     AssertLockHeld(cs_main);\n     assert(pindex);\n     // pindex->phashBlock can be null if called by CreateNewBlock/TestBlockValidity\n@@ -4098,17 +4099,22 @@ bool InitBlockIndex(const CChainParams& chainparams)\n     // Use the provided setting for -txindex in the new database\n     fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);\n     pblocktree->WriteFlag(\"txindex\", fTxIndex);\n+    LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n     // Use the provided setting for -addressindex in the new database\n     fAddressIndex = GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX);\n     pblocktree->WriteFlag(\"addressindex\", fAddressIndex);\n+    LogPrintf(\"%s: address index %s\\n\", __func__, fAddressIndex ? \"enabled\" : \"disabled\");\n \n     // Use the provided setting for -timestampindex in the new database\n     fTimestampIndex = GetBoolArg(\"-timestampindex\", DEFAULT_TIMESTAMPINDEX);\n     pblocktree->WriteFlag(\"timestampindex\", fTimestampIndex);\n+    LogPrintf(\"%s: timestamp index %s\\n\", __func__, fTimestampIndex ? \"enabled\" : \"disabled\");\n \n+    // Use the provided setting for -spentindex in the new database\n     fSpentIndex = GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX);\n     pblocktree->WriteFlag(\"spentindex\", fSpentIndex);\n+    LogPrintf(\"%s: spent index %s\\n\", __func__, fSpentIndex ? \"enabled\" : \"disabled\");\n \n     LogPrintf(\"Initializing databases...\\n\");\n "
      },
      {
        "sha": "c79c1cc24dfd2f0fdf434fb5372061e1e1d996c2",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a74235ac4bacf97ebdad17afc6d0557476fe53a9/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a74235ac4bacf97ebdad17afc6d0557476fe53a9/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=a74235ac4bacf97ebdad17afc6d0557476fe53a9",
        "patch": "@@ -177,6 +177,9 @@ extern std::atomic_bool fImporting;\n extern bool fReindex;\n extern int nScriptCheckThreads;\n extern bool fTxIndex;\n+extern bool fAddressIndex;\n+extern bool fSpentIndex;\n+extern bool fTimestampIndex;\n extern bool fIsBareMultisigStd;\n extern bool fRequireStandard;\n extern bool fCheckBlockIndex;"
      }
    ]
  },
  {
    "sha": "95d72be5a55c6d1faadeab86b0de51e869b959a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NWQ3MmJlNWE1NWM2ZDFmYWFkZWFiODZiMGRlNTFlODY5Yjk1OWE0",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-05T22:39:57Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "tests: update rpc index tests for 0.13",
      "tree": {
        "sha": "27c08553c1ef25aa29d222bf2d5ebbbaf74bb62b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27c08553c1ef25aa29d222bf2d5ebbbaf74bb62b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95d72be5a55c6d1faadeab86b0de51e869b959a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95d72be5a55c6d1faadeab86b0de51e869b959a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/95d72be5a55c6d1faadeab86b0de51e869b959a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95d72be5a55c6d1faadeab86b0de51e869b959a4/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a74235ac4bacf97ebdad17afc6d0557476fe53a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a74235ac4bacf97ebdad17afc6d0557476fe53a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a74235ac4bacf97ebdad17afc6d0557476fe53a9"
      }
    ],
    "stats": {
      "total": 102,
      "additions": 52,
      "deletions": 50
    },
    "files": [
      {
        "sha": "6968e0dca8133fe91e0f7c81903a72ba3afc0d0d",
        "filename": "qa/rpc-tests/addressindex.py",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95d72be5a55c6d1faadeab86b0de51e869b959a4/qa/rpc-tests/addressindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95d72be5a55c6d1faadeab86b0de51e869b959a4/qa/rpc-tests/addressindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/addressindex.py?ref=95d72be5a55c6d1faadeab86b0de51e869b959a4",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -36,7 +36,7 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining blocks...\"\n+        print(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n \n@@ -50,7 +50,7 @@ def run_test(self):\n         assert_equal(balance0[\"balance\"], 0)\n \n         # Check p2pkh and p2sh address indexes\n-        print \"Testing p2pkh and p2sh address index...\"\n+        print(\"Testing p2pkh and p2sh address index...\")\n \n         txid0 = self.nodes[0].sendtoaddress(\"mo9ncXisMeAoXwqcV5EWuyncbmCcQN4rVs\", 10)\n         self.nodes[0].generate(1)\n@@ -85,7 +85,7 @@ def run_test(self):\n         assert_equal(txidsb[2], txidb2)\n \n         # Check that limiting by height works\n-        print \"Testing querying txids by range of block heights..\"\n+        print(\"Testing querying txids by range of block heights..\")\n         height_txids = self.nodes[1].getaddresstxids({\n             \"addresses\": [\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\"],\n             \"start\": 105,\n@@ -110,8 +110,8 @@ def run_test(self):\n         assert_equal(balance0[\"balance\"], 45 * 100000000)\n \n         # Check that outputs with the same address will only return one txid\n-        print \"Testing for txid uniqueness...\"\n-        addressHash = \"6349a418fc4578d10a372b54b45c280cc8c4382f\".decode(\"hex\")\n+        print(\"Testing for txid uniqueness...\")\n+        addressHash = bytes([99,73,164,24,252,69,120,209,10,55,43,84,180,92,40,12,200,196,56,47])\n         scriptPubKey = CScript([OP_HASH160, addressHash, OP_EQUAL])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n@@ -130,22 +130,22 @@ def run_test(self):\n         assert_equal(txidsmany[3], sent_txid)\n \n         # Check that balances are correct\n-        print \"Testing balances...\"\n+        print(\"Testing balances...\")\n         balance0 = self.nodes[1].getaddressbalance(\"2N2JD6wb56AfK4tfmM6PwdVmoYk2dCKf4Br\")\n         assert_equal(balance0[\"balance\"], 45 * 100000000 + 21)\n \n         # Check that balances are correct after spending\n-        print \"Testing balances after spending...\"\n+        print(\"Testing balances after spending...\")\n         privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash2 = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n         self.nodes[0].importprivkey(privkey2)\n \n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000 - 100000)\n         tx.vout = [CTxOut(amount, scriptPubKey2)]\n         tx.rehash()\n         signed_tx = self.nodes[0].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n@@ -188,13 +188,13 @@ def run_test(self):\n         assert_equal(len(deltas), 1)\n \n         # Check that unspent outputs can be queried\n-        print \"Testing utxos...\"\n+        print(\"Testing utxos...\")\n         utxos = self.nodes[1].getaddressutxos({\"addresses\": [address2]})\n         assert_equal(len(utxos), 1)\n         assert_equal(utxos[0][\"satoshis\"], change_amount)\n \n         # Check that indexes will be updated with a reorg\n-        print \"Testing reorg...\"\n+        print(\"Testing reorg...\")\n \n         best_hash = self.nodes[0].getbestblockhash()\n         self.nodes[0].invalidateblock(best_hash)\n@@ -226,19 +226,19 @@ def run_test(self):\n         assert_equal(utxos3[2][\"height\"], 265)\n \n         # Check mempool indexing\n-        print \"Testing mempool indexing...\"\n+        print(\"Testing mempool indexing...\")\n \n         privKey3 = \"cVfUn53hAbRrDEuMexyfgDpZPhF7KqXpS8UZevsyTDaugB7HZ3CD\"\n         address3 = \"mw4ynwhS7MmrQ27hr82kgqu7zryNDK26JB\"\n-        addressHash3 = \"aa9872b5bbcdb511d89e0e11aa27da73fd2c3f50\".decode(\"hex\")\n+        addressHash3 = bytes([170,152,114,181,187,205,181,17,216,158,14,17,170,39,218,115,253,44,63,80])\n         scriptPubKey3 = CScript([OP_DUP, OP_HASH160, addressHash3, OP_EQUALVERIFY, OP_CHECKSIG])\n         address4 = \"2N8oFVB2vThAKury4vnLquW2zVjsYjjAkYQ\"\n         scriptPubKey4 = CScript([OP_HASH160, addressHash3, OP_EQUAL])\n         unspent = self.nodes[2].listunspent()\n \n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000 - 100000)\n         tx.vout = [CTxOut(amount, scriptPubKey3)]\n         tx.rehash()\n         signed_tx = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n@@ -247,12 +247,12 @@ def run_test(self):\n \n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(COutPoint(int(unspent[1][\"txid\"], 16), unspent[1][\"vout\"]))]\n-        amount = unspent[1][\"amount\"] * 100000000\n+        amount = int(unspent[1][\"amount\"] * 100000000 - 100000)\n         tx2.vout = [\n-            CTxOut(amount / 4, scriptPubKey3),\n-            CTxOut(amount / 4, scriptPubKey3),\n-            CTxOut(amount / 4, scriptPubKey4),\n-            CTxOut(amount / 4, scriptPubKey4)\n+            CTxOut(int(amount / 4), scriptPubKey3),\n+            CTxOut(int(amount / 4), scriptPubKey3),\n+            CTxOut(int(amount / 4), scriptPubKey4),\n+            CTxOut(int(amount / 4), scriptPubKey4)\n         ]\n         tx2.rehash()\n         signed_tx2 = self.nodes[2].signrawtransaction(binascii.hexlify(tx2.serialize()).decode(\"utf-8\"))\n@@ -269,7 +269,7 @@ def run_test(self):\n         assert_equal(mempool[2][\"txid\"], memtxid2)\n         assert_equal(mempool[2][\"index\"], 1)\n \n-        self.nodes[2].generate(1);\n+        blk_hashes = self.nodes[2].generate(1);\n         self.sync_all();\n         mempool2 = self.nodes[2].getaddressmempool({\"addresses\": [address3]})\n         assert_equal(len(mempool2), 0)\n@@ -279,7 +279,7 @@ def run_test(self):\n             CTxIn(COutPoint(int(memtxid2, 16), 0)),\n             CTxIn(COutPoint(int(memtxid2, 16), 1))\n         ]\n-        tx.vout = [CTxOut(amount / 2 - 10000, scriptPubKey2)]\n+        tx.vout = [CTxOut(int(amount / 2 - 10000), scriptPubKey2)]\n         tx.rehash()\n         self.nodes[2].importprivkey(privKey3)\n         signed_tx3 = self.nodes[2].signrawtransaction(binascii.hexlify(tx.serialize()).decode(\"utf-8\"))\n@@ -296,7 +296,7 @@ def run_test(self):\n         # sending and receiving to the same address\n         privkey1 = \"cQY2s58LhzUCmEXN8jtAp1Etnijx78YRZ466w4ikX1V4UpTpbsf8\"\n         address1 = \"myAUWSHnwsQrhuMWv4Br6QsCnpB41vFwHn\"\n-        address1hash = \"c192bff751af8efec15135d42bfeedf91a6f3e34\".decode(\"hex\")\n+        address1hash = bytes([193,146,191,247,81,175,142,254,193,81,53,212,43,254,237,249,26,111,62,52])\n         address1script = CScript([OP_DUP, OP_HASH160, address1hash, OP_EQUALVERIFY, OP_CHECKSIG])\n \n         self.nodes[0].sendtoaddress(address1, 10)\n@@ -310,7 +310,7 @@ def run_test(self):\n         tx.vin = [\n             CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"outputIndex\"]))\n         ]\n-        amount = utxos[0][\"satoshis\"] - 1000\n+        amount = int(utxos[0][\"satoshis\"] - 1000)\n         tx.vout = [CTxOut(amount, address1script)]\n         tx.rehash()\n         self.nodes[0].importprivkey(privkey1)\n@@ -322,7 +322,7 @@ def run_test(self):\n         assert_equal(len(mempool_deltas), 2)\n \n         # Include chaininfo in results\n-        print \"Testing results with chain info...\"\n+        print(\"Testing results with chain info...\")\n \n         deltas_with_info = self.nodes[1].getaddressdeltas({\n             \"addresses\": [address2],\n@@ -342,7 +342,7 @@ def run_test(self):\n         assert_equal(utxos_with_info[\"height\"], 267)\n         assert_equal(utxos_with_info[\"hash\"], expected_tip_block_hash)\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "4119a11aef04ea97a44eaa2a9d2225ef24ae483b",
        "filename": "qa/rpc-tests/spentindex.py",
        "status": "modified",
        "additions": 20,
        "deletions": 18,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95d72be5a55c6d1faadeab86b0de51e869b959a4/qa/rpc-tests/spentindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95d72be5a55c6d1faadeab86b0de51e869b959a4/qa/rpc-tests/spentindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/spentindex.py?ref=95d72be5a55c6d1faadeab86b0de51e869b959a4",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -36,23 +36,24 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining blocks...\"\n+        print(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n \n         chain_height = self.nodes[1].getblockcount()\n         assert_equal(chain_height, 105)\n \n         # Check that\n-        print \"Testing spent index...\"\n+        print(\"Testing spent index...\")\n \n+        feeSatoshis = 10000\n         privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000 - feeSatoshis)\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n         tx.vout = [CTxOut(amount, scriptPubKey)]\n         tx.rehash()\n@@ -62,15 +63,15 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        print \"Testing getspentinfo method...\"\n+        print(\"Testing getspentinfo method...\")\n \n         # Check that the spentinfo works standalone\n         info = self.nodes[1].getspentinfo({\"txid\": unspent[0][\"txid\"], \"index\": unspent[0][\"vout\"]})\n         assert_equal(info[\"txid\"], txid)\n         assert_equal(info[\"index\"], 0)\n         assert_equal(info[\"height\"], 106)\n \n-        print \"Testing getrawtransaction method...\"\n+        print(\"Testing getrawtransaction method...\")\n \n         # Check that verbose raw transaction includes spent info\n         txVerbose = self.nodes[3].getrawtransaction(unspent[0][\"txid\"], 1)\n@@ -80,16 +81,17 @@ def run_test(self):\n \n         # Check that verbose raw transaction includes input values\n         txVerbose2 = self.nodes[3].getrawtransaction(txid, 1)\n-        assert_equal(txVerbose2[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n-        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount)\n+        assert_equal(float(txVerbose2[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+        assert_equal(txVerbose2[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n \n         # Check that verbose raw transaction includes address values and input values\n         privkey2 = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address2 = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash2 = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash2 = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey2 = CScript([OP_DUP, OP_HASH160, addressHash2, OP_EQUALVERIFY, OP_CHECKSIG])\n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(COutPoint(int(txid, 16), 0))]\n+        amount = int(amount - feeSatoshis);\n         tx2.vout = [CTxOut(amount, scriptPubKey2)]\n         tx.rehash()\n         self.nodes[0].importprivkey(privkey)\n@@ -100,21 +102,21 @@ def run_test(self):\n         self.sync_all()\n         txVerbose3 = self.nodes[1].getrawtransaction(txid2, 1)\n         assert_equal(txVerbose3[\"vin\"][0][\"address\"], address2)\n-        assert_equal(txVerbose3[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n-        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount)\n+        assert_equal(txVerbose3[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+        assert_equal(float(txVerbose3[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n+\n \n         # Check the database index\n         block_hash = self.nodes[0].generate(1)\n         self.sync_all()\n \n         txVerbose4 = self.nodes[3].getrawtransaction(txid2, 1)\n         assert_equal(txVerbose4[\"vin\"][0][\"address\"], address2)\n-        assert_equal(txVerbose4[\"vin\"][0][\"value\"], Decimal(unspent[0][\"amount\"]))\n-        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount)\n-\n+        assert_equal(txVerbose4[\"vin\"][0][\"valueSat\"], amount + feeSatoshis)\n+        assert_equal(float(txVerbose4[\"vin\"][0][\"value\"]), (amount + feeSatoshis) / 100000000)\n \n         # Check block deltas\n-        print \"Testing getblockdeltas...\"\n+        print(\"Testing getblockdeltas...\")\n \n         block = self.nodes[3].getblockdeltas(block_hash[0])\n         assert_equal(len(block[\"deltas\"]), 2)\n@@ -125,14 +127,14 @@ def run_test(self):\n         assert_equal(block[\"deltas\"][1][\"txid\"], txid2)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"index\"], 0)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n-        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], amount * -1)\n+        assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"satoshis\"], (amount + feeSatoshis) * -1)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevtxid\"], txid)\n         assert_equal(block[\"deltas\"][1][\"inputs\"][0][\"prevout\"], 0)\n         assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"index\"], 0)\n         assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"address\"], \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\")\n         assert_equal(block[\"deltas\"][1][\"outputs\"][0][\"satoshis\"], amount)\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "85942b7ef6929f2e43d29168815d87ac415d610a",
        "filename": "qa/rpc-tests/timestampindex.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95d72be5a55c6d1faadeab86b0de51e869b959a4/qa/rpc-tests/timestampindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95d72be5a55c6d1faadeab86b0de51e869b959a4/qa/rpc-tests/timestampindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/timestampindex.py?ref=95d72be5a55c6d1faadeab86b0de51e869b959a4",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -35,26 +35,26 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining 25 blocks...\"\n+        print(\"Mining 25 blocks...\")\n         blockhashes = self.nodes[0].generate(25)\n         time.sleep(3)\n-        print \"Mining 25 blocks...\"\n+        print(\"Mining 25 blocks...\")\n         blockhashes.extend(self.nodes[0].generate(25))\n         time.sleep(3)\n-        print \"Mining 25 blocks...\"\n+        print(\"Mining 25 blocks...\")\n         blockhashes.extend(self.nodes[0].generate(25))\n         self.sync_all()\n         low = self.nodes[1].getblock(blockhashes[0])[\"time\"]\n         high = low + 76\n \n-        print \"Checking timestamp index...\"\n+        print(\"Checking timestamp index...\")\n         hashes = self.nodes[1].getblockhashes(high, low)\n \n         assert_equal(len(hashes), len(blockhashes))\n \n         assert_equal(hashes, blockhashes)\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "c7f2d8251862c6b8de5f7463ab858d130973cfbb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjN2YyZDgyNTE4NjJjNmI4ZGU1Zjc0NjNhYjg1OGQxMzA5NzNjZmJi",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-07-13T22:38:04Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "db: add options to configure block index database\n\nThere was a previous assumption that blockindex would be quite small. With addressindex\nand spentindex enabled the blockindex is much larger and the amount of cache allocated for\nit should also increase. Furthermore, enabling compression should decrease the amount of\ndisk space required and less data to write/read. The default leveldb max_open_files is set to\n1000, for the blockindex the default is set to 1000 with compression. The 64 value that is\ncurrent is kept for the utxo database and does not enable compression. Two additional options\nare added here to be able to configure the values for leveldb and the block index:\n\n- `-dbmaxopenfiles` A number of files for leveldb to keep open\n- `-dbcompression` Boolean 0 or 1 to enable snappy leveldb compression\n\nConflicts:\n\tsrc/dbwrapper.cpp\n\tsrc/init.cpp",
      "tree": {
        "sha": "599b7faaf44b561ff0c5f0304181b4f8ae7cc5a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/599b7faaf44b561ff0c5f0304181b4f8ae7cc5a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7f2d8251862c6b8de5f7463ab858d130973cfbb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7f2d8251862c6b8de5f7463ab858d130973cfbb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7f2d8251862c6b8de5f7463ab858d130973cfbb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7f2d8251862c6b8de5f7463ab858d130973cfbb/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "95d72be5a55c6d1faadeab86b0de51e869b959a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95d72be5a55c6d1faadeab86b0de51e869b959a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/95d72be5a55c6d1faadeab86b0de51e869b959a4"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 36,
      "deletions": 17
    },
    "files": [
      {
        "sha": "92851b450b06ec728e44b775f6507c0076e8f94c",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "patch": "@@ -73,14 +73,14 @@ class CBitcoinLevelDBLogger : public leveldb::Logger {\n     }\n };\n \n-static leveldb::Options GetOptions(size_t nCacheSize)\n+static leveldb::Options GetOptions(size_t nCacheSize, bool compression, int maxOpenFiles)\n {\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n-    options.compression = leveldb::kNoCompression;\n-    options.max_open_files = 64;\n+    options.compression = compression ? leveldb::kSnappyCompression : leveldb::kNoCompression;\n+    options.max_open_files = maxOpenFiles;\n     options.info_log = new CBitcoinLevelDBLogger();\n     if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n@@ -90,14 +90,14 @@ static leveldb::Options GetOptions(size_t nCacheSize)\n     return options;\n }\n \n-CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n+CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate, bool compression, int maxOpenFiles)\n {\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n     syncoptions.sync = true;\n-    options = GetOptions(nCacheSize);\n+    options = GetOptions(nCacheSize, compression, maxOpenFiles);\n     options.create_if_missing = true;\n     if (fMemory) {\n         penv = leveldb::NewMemEnv(leveldb::Env::Default());"
      },
      {
        "sha": "bdcf004d0c5c8e7afbd3e3e4814a129ac4d0c9ea",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "patch": "@@ -187,14 +187,16 @@ class CDBWrapper\n \n public:\n     /**\n-     * @param[in] path        Location in the filesystem where leveldb data will be stored.\n-     * @param[in] nCacheSize  Configures various leveldb cache settings.\n-     * @param[in] fMemory     If true, use leveldb's memory environment.\n-     * @param[in] fWipe       If true, remove all existing data.\n-     * @param[in] obfuscate   If true, store data obfuscated via simple XOR. If false, XOR\n-     *                        with a zero'd byte array.\n+     * @param[in] path          Location in the filesystem where leveldb data will be stored.\n+     * @param[in] nCacheSize    Configures various leveldb cache settings.\n+     * @param[in] fMemory       If true, use leveldb's memory environment.\n+     * @param[in] fWipe         If true, remove all existing data.\n+     * @param[in] obfuscate     If true, store data obfuscated via simple XOR. If false, XOR\n+     *                          with a zero'd byte array.\n+     * @param[in] compression   Enable snappy compression for the database\n+     * @param[in] maxOpenFiles  The maximum number of open files for the database\n      */\n-    CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n+    CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false, bool compression = false, int maxOpenFiles = 64);\n     ~CDBWrapper();\n \n     template <typename K, typename V>"
      },
      {
        "sha": "271662c0fd3f2858a7baf25565019e5e47d50924",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "patch": "@@ -1418,19 +1418,33 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     fs::create_directories(GetDataDir() / \"blocks\");\n \n+    // block tree db settings\n+    int dbMaxOpenFiles = GetArg(\"-dbmaxopenfiles\", DEFAULT_DB_MAX_OPEN_FILES);\n+    bool dbCompression = GetBoolArg(\"-dbcompression\", DEFAULT_DB_COMPRESSION);\n+\n+    LogPrintf(\"Block index database configuration:\\n\");\n+    LogPrintf(\"* Using %d max open files\\n\", dbMaxOpenFiles);\n+    LogPrintf(\"* Compression is %s\\n\", dbCompression ? \"enabled\" : \"disabled\");\n+\n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n     nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greater than nMaxDbcache\n     int64_t nBlockTreeDBCache = nTotalCache / 8;\n-    nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    if (GetBoolArg(\"-addressindex\", DEFAULT_ADDRESSINDEX) || GetBoolArg(\"-spentindex\", DEFAULT_SPENTINDEX)) {\n+        // enable 3/4 of the cache if addressindex and/or spentindex is enabled\n+        nBlockTreeDBCache = nTotalCache * 3 / 4;\n+    } else {\n+        nBlockTreeDBCache = std::min(nBlockTreeDBCache, (GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    }\n     nTotalCache -= nBlockTreeDBCache;\n     int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache\n     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache\n     nTotalCache -= nCoinDBCache;\n     nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache\n     int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     LogPrintf(\"Cache configuration:\\n\");\n+    LogPrintf(\"* Max cache setting possible %.1fMiB\\n\", nMaxDbCache);\n     LogPrintf(\"* Using %.1fMiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set (plus up to %.1fMiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n@@ -1451,8 +1465,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 delete pcoinscatcher;\n                 delete pblocktree;\n \n-                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n+                pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex, dbCompression, dbMaxOpenFiles);\n                 pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n+\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n                 pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n "
      },
      {
        "sha": "37067e500996b391dbcd3816f084448799d0cacb",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "patch": "@@ -30,7 +30,7 @@ static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n \n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n+CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true, false, 64)\n {\n }\n \n@@ -72,7 +72,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     return db.WriteBatch(batch);\n }\n \n-CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n+CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe, bool compression, int maxOpenFiles) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe, false, compression, maxOpenFiles) {\n }\n \n bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {"
      },
      {
        "sha": "2ab8253096ffbab2ee45c27d3d030940b08355dc",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "patch": "@@ -112,7 +112,7 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n class CBlockTreeDB : public CDBWrapper\n {\n public:\n-    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    CBlockTreeDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool compression = true, int maxOpenFiles = 1000);\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);"
      },
      {
        "sha": "1a1c0665df384c341061dc369b922726abd8eed9",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7f2d8251862c6b8de5f7463ab858d130973cfbb/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "patch": "@@ -137,6 +137,8 @@ static const bool DEFAULT_TXINDEX = false;\n static const bool DEFAULT_ADDRESSINDEX = false;\n static const bool DEFAULT_TIMESTAMPINDEX = false;\n static const bool DEFAULT_SPENTINDEX = false;\n+static const unsigned int DEFAULT_DB_MAX_OPEN_FILES = 1000;\n+static const bool DEFAULT_DB_COMPRESSION = true;\n static const unsigned int DEFAULT_BANSCORE_THRESHOLD = 100;\n /** Default for -persistmempool */\n static const bool DEFAULT_PERSIST_MEMPOOL = true;"
      }
    ]
  },
  {
    "sha": "bc474a169e299b54cadbcdce3c39ab63d4ef4351",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYzQ3NGExNjllMjk5YjU0Y2FkYmNkY2UzYzM5YWI2M2Q0ZWY0MzUx",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-07-14T20:30:31Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "tests: test dbwrapper options compression and maxopenfiles",
      "tree": {
        "sha": "96f1418b7a92d18b25e8cbbda844a818b19fcef4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96f1418b7a92d18b25e8cbbda844a818b19fcef4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bc474a169e299b54cadbcdce3c39ab63d4ef4351",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc474a169e299b54cadbcdce3c39ab63d4ef4351",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bc474a169e299b54cadbcdce3c39ab63d4ef4351",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc474a169e299b54cadbcdce3c39ab63d4ef4351/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7f2d8251862c6b8de5f7463ab858d130973cfbb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c7f2d8251862c6b8de5f7463ab858d130973cfbb"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 43,
      "deletions": 0
    },
    "files": [
      {
        "sha": "59254aabf3482851eb458d6b210bee697dab0724",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc474a169e299b54cadbcdce3c39ab63d4ef4351/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc474a169e299b54cadbcdce3c39ab63d4ef4351/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=bc474a169e299b54cadbcdce3c39ab63d4ef4351",
        "patch": "@@ -43,6 +43,49 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(dbwrapper_compression)\n+{\n+    // Perform tests both with compression and without\n+    for (int i = 0; i < 2; i++) {\n+        bool compression = (bool)i;\n+        path ph = temp_directory_path() / unique_path();\n+        CDBWrapper dbw(ph, (1 << 20), true, false, false, compression);\n+        char key = 'k';\n+        uint256 in = GetRandHash();\n+        uint256 res;\n+\n+        BOOST_CHECK(dbw.Write(key, in));\n+        BOOST_CHECK(dbw.Read(key, res));\n+        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_64)\n+{\n+    path ph = temp_directory_path() / unique_path();\n+    CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 64);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw.Write(key, in));\n+    BOOST_CHECK(dbw.Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+}\n+\n+BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_1000)\n+{\n+    path ph = temp_directory_path() / unique_path();\n+    CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 1000);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw.Write(key, in));\n+    BOOST_CHECK(dbw.Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+}\n+\n // Test batch operations\n BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n {"
      }
    ]
  },
  {
    "sha": "06726dd4134fc2ce7a9695f85e347dcec72a69ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjcyNmRkNDEzNGZjMmNlN2E5Njk1Zjg1ZTM0N2RjZWM3MmE2OWVj",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "courier@braydon.com",
        "date": "2016-10-07T02:04:59Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "tests: include and fix txindex test with rpc tests",
      "tree": {
        "sha": "5c3ba28815ae58501cfe09166ed732941ee3cb44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c3ba28815ae58501cfe09166ed732941ee3cb44"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/06726dd4134fc2ce7a9695f85e347dcec72a69ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06726dd4134fc2ce7a9695f85e347dcec72a69ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/06726dd4134fc2ce7a9695f85e347dcec72a69ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06726dd4134fc2ce7a9695f85e347dcec72a69ec/comments",
    "author": {
      "login": "braydonf",
      "id": 544777,
      "node_id": "MDQ6VXNlcjU0NDc3Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/544777?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/braydonf",
      "html_url": "https://github.com/braydonf",
      "followers_url": "https://api.github.com/users/braydonf/followers",
      "following_url": "https://api.github.com/users/braydonf/following{/other_user}",
      "gists_url": "https://api.github.com/users/braydonf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/braydonf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/braydonf/subscriptions",
      "organizations_url": "https://api.github.com/users/braydonf/orgs",
      "repos_url": "https://api.github.com/users/braydonf/repos",
      "events_url": "https://api.github.com/users/braydonf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/braydonf/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bc474a169e299b54cadbcdce3c39ab63d4ef4351",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc474a169e299b54cadbcdce3c39ab63d4ef4351",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bc474a169e299b54cadbcdce3c39ab63d4ef4351"
      }
    ],
    "stats": {
      "total": 1211,
      "additions": 6,
      "deletions": 1205
    },
    "files": [
      {
        "sha": "1641e4c531f3cd08a3c89f789c42c44569a1a72b",
        "filename": "src/rpc/misc.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 1199,
        "changes": 1199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bc474a169e299b54cadbcdce3c39ab63d4ef4351/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bc474a169e299b54cadbcdce3c39ab63d4ef4351/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=bc474a169e299b54cadbcdce3c39ab63d4ef4351",
        "patch": "@@ -1,1199 +0,0 @@\n-// Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"base58.h\"\n-#include \"chain.h\"\n-#include \"clientversion.h\"\n-#include \"init.h\"\n-#include \"validation.h\"\n-#include \"httpserver.h\"\n-#include \"net.h\"\n-#include \"netbase.h\"\n-#include \"rpc/blockchain.h\"\n-#include \"rpc/server.h\"\n-#include \"timedata.h\"\n-#include \"txmempool.h\"\n-#include \"util.h\"\n-#include \"utilstrencodings.h\"\n-#ifdef ENABLE_WALLET\n-#include \"wallet/rpcwallet.h\"\n-#include \"wallet/wallet.h\"\n-#include \"wallet/walletdb.h\"\n-#endif\n-\n-#include <stdint.h>\n-#ifdef HAVE_MALLOC_INFO\n-#include <malloc.h>\n-#endif\n-\n-#include <boost/assign/list_of.hpp>\n-\n-#include <univalue.h>\n-\n-/**\n- * @note Do not add or change anything in the information returned by this\n- * method. `getinfo` exists for backwards-compatibility only. It combines\n- * information from wildly different sources in the program, which is a mess,\n- * and is thus planned to be deprecated eventually.\n- *\n- * Based on the source of the information, new information should be added to:\n- * - `getblockchaininfo`,\n- * - `getnetworkinfo` or\n- * - `getwalletinfo`\n- *\n- * Or alternatively, create a specific query method for the information.\n- **/\n-UniValue getinfo(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 0)\n-        throw std::runtime_error(\n-            \"getinfo\\n\"\n-            \"\\nDEPRECATED. Returns an object containing various state info.\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"version\\\": xxxxx,           (numeric) the server version\\n\"\n-            \"  \\\"protocolversion\\\": xxxxx,   (numeric) the protocol version\\n\"\n-            \"  \\\"walletversion\\\": xxxxx,     (numeric) the wallet version\\n\"\n-            \"  \\\"balance\\\": xxxxxxx,         (numeric) the total bitcoin balance of the wallet\\n\"\n-            \"  \\\"blocks\\\": xxxxxx,           (numeric) the current number of blocks processed in the server\\n\"\n-            \"  \\\"timeoffset\\\": xxxxx,        (numeric) the time offset\\n\"\n-            \"  \\\"connections\\\": xxxxx,       (numeric) the number of connections\\n\"\n-            \"  \\\"proxy\\\": \\\"host:port\\\",     (string, optional) the proxy used by the server\\n\"\n-            \"  \\\"difficulty\\\": xxxxxx,       (numeric) the current difficulty\\n\"\n-            \"  \\\"testnet\\\": true|false,      (boolean) if the server is using testnet or not\\n\"\n-            \"  \\\"keypoololdest\\\": xxxxxx,    (numeric) the timestamp (seconds since Unix epoch) of the oldest pre-generated key in the key pool\\n\"\n-            \"  \\\"keypoolsize\\\": xxxx,        (numeric) how many new keys are pre-generated\\n\"\n-            \"  \\\"unlocked_until\\\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\\n\"\n-            \"  \\\"paytxfee\\\": x.xxxx,         (numeric) the transaction fee set in \" + CURRENCY_UNIT + \"/kB\\n\"\n-            \"  \\\"relayfee\\\": x.xxxx,         (numeric) minimum relay fee for transactions in \" + CURRENCY_UNIT + \"/kB\\n\"\n-            \"  \\\"errors\\\": \\\"...\\\"           (string) any error messages\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getinfo\", \"\")\n-            + HelpExampleRpc(\"getinfo\", \"\")\n-        );\n-\n-#ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n-\n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : NULL);\n-#else\n-    LOCK(cs_main);\n-#endif\n-\n-    proxyType proxy;\n-    GetProxy(NET_IPV4, proxy);\n-\n-    UniValue obj(UniValue::VOBJ);\n-    obj.push_back(Pair(\"version\", CLIENT_VERSION));\n-    obj.push_back(Pair(\"protocolversion\", PROTOCOL_VERSION));\n-#ifdef ENABLE_WALLET\n-    if (pwallet) {\n-        obj.push_back(Pair(\"walletversion\", pwallet->GetVersion()));\n-        obj.push_back(Pair(\"balance\",       ValueFromAmount(pwallet->GetBalance())));\n-    }\n-#endif\n-    obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n-    obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n-    if(g_connman)\n-        obj.push_back(Pair(\"connections\",   (int)g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL)));\n-    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : std::string())));\n-    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n-    obj.push_back(Pair(\"testnet\",       Params().NetworkIDString() == CBaseChainParams::TESTNET));\n-#ifdef ENABLE_WALLET\n-    if (pwallet) {\n-        obj.push_back(Pair(\"keypoololdest\", pwallet->GetOldestKeyPoolTime()));\n-        obj.push_back(Pair(\"keypoolsize\",   (int)pwallet->GetKeyPoolSize()));\n-    }\n-    if (pwallet && pwallet->IsCrypted()) {\n-        obj.push_back(Pair(\"unlocked_until\", pwallet->nRelockTime));\n-    }\n-    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n-#endif\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n-    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n-    return obj;\n-}\n-\n-#ifdef ENABLE_WALLET\n-class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n-{\n-public:\n-    CWallet * const pwallet;\n-\n-    DescribeAddressVisitor(CWallet *_pwallet) : pwallet(_pwallet) {}\n-\n-    UniValue operator()(const CNoDestination &dest) const { return UniValue(UniValue::VOBJ); }\n-\n-    UniValue operator()(const CKeyID &keyID) const {\n-        UniValue obj(UniValue::VOBJ);\n-        CPubKey vchPubKey;\n-        obj.push_back(Pair(\"isscript\", false));\n-        if (pwallet && pwallet->GetPubKey(keyID, vchPubKey)) {\n-            obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n-            obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n-        }\n-        return obj;\n-    }\n-\n-    UniValue operator()(const CScriptID &scriptID) const {\n-        UniValue obj(UniValue::VOBJ);\n-        CScript subscript;\n-        obj.push_back(Pair(\"isscript\", true));\n-        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {\n-            std::vector<CTxDestination> addresses;\n-            txnouttype whichType;\n-            int nRequired;\n-            ExtractDestinations(subscript, whichType, addresses, nRequired);\n-            obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n-            obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n-            UniValue a(UniValue::VARR);\n-            BOOST_FOREACH(const CTxDestination& addr, addresses)\n-                a.push_back(CBitcoinAddress(addr).ToString());\n-            obj.push_back(Pair(\"addresses\", a));\n-            if (whichType == TX_MULTISIG)\n-                obj.push_back(Pair(\"sigsrequired\", nRequired));\n-        }\n-        return obj;\n-    }\n-};\n-#endif\n-\n-UniValue validateaddress(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"validateaddress \\\"address\\\"\\n\"\n-            \"\\nReturn information about the given bitcoin address.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"     (string, required) The bitcoin address to validate\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"isvalid\\\" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.\\n\"\n-            \"  \\\"address\\\" : \\\"address\\\", (string) The bitcoin address validated\\n\"\n-            \"  \\\"scriptPubKey\\\" : \\\"hex\\\",       (string) The hex encoded scriptPubKey generated by the address\\n\"\n-            \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n-            \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n-            \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n-            \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string) The hex value of the raw public key\\n\"\n-            \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n-            \"  \\\"account\\\" : \\\"account\\\"         (string) DEPRECATED. The account associated with the address, \\\"\\\" is the default account\\n\"\n-            \"  \\\"timestamp\\\" : timestamp,        (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"  \\\"hdkeypath\\\" : \\\"keypath\\\"       (string, optional) The HD keypath if the key is HD and available\\n\"\n-            \"  \\\"hdmasterkeyid\\\" : \\\"<hash160>\\\" (string, optional) The Hash160 of the HD master pubkey\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n-            + HelpExampleRpc(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n-        );\n-\n-#ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n-\n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : NULL);\n-#else\n-    LOCK(cs_main);\n-#endif\n-\n-    CBitcoinAddress address(request.params[0].get_str());\n-    bool isValid = address.IsValid();\n-\n-    UniValue ret(UniValue::VOBJ);\n-    ret.push_back(Pair(\"isvalid\", isValid));\n-    if (isValid)\n-    {\n-        CTxDestination dest = address.Get();\n-        std::string currentAddress = address.ToString();\n-        ret.push_back(Pair(\"address\", currentAddress));\n-\n-        CScript scriptPubKey = GetScriptForDestination(dest);\n-        ret.push_back(Pair(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n-\n-#ifdef ENABLE_WALLET\n-        isminetype mine = pwallet ? IsMine(*pwallet, dest) : ISMINE_NO;\n-        ret.push_back(Pair(\"ismine\", (mine & ISMINE_SPENDABLE) ? true : false));\n-        ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true: false));\n-        UniValue detail = boost::apply_visitor(DescribeAddressVisitor(pwallet), dest);\n-        ret.pushKVs(detail);\n-        if (pwallet && pwallet->mapAddressBook.count(dest)) {\n-            ret.push_back(Pair(\"account\", pwallet->mapAddressBook[dest].name));\n-        }\n-        CKeyID keyID;\n-        if (pwallet) {\n-            const auto& meta = pwallet->mapKeyMetadata;\n-            auto it = address.GetKeyID(keyID) ? meta.find(keyID) : meta.end();\n-            if (it == meta.end()) {\n-                it = meta.find(CScriptID(scriptPubKey));\n-            }\n-            if (it != meta.end()) {\n-                ret.push_back(Pair(\"timestamp\", it->second.nCreateTime));\n-                if (!it->second.hdKeypath.empty()) {\n-                    ret.push_back(Pair(\"hdkeypath\", it->second.hdKeypath));\n-                    ret.push_back(Pair(\"hdmasterkeyid\", it->second.hdMasterKeyID.GetHex()));\n-                }\n-            }\n-        }\n-#endif\n-    }\n-    return ret;\n-}\n-\n-// Needed even with !ENABLE_WALLET, to pass (ignored) pointers around\n-class CWallet;\n-\n-/**\n- * Used by addmultisigaddress / createmultisig:\n- */\n-CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& params)\n-{\n-    int nRequired = params[0].get_int();\n-    const UniValue& keys = params[1].get_array();\n-\n-    // Gather public keys\n-    if (nRequired < 1)\n-        throw std::runtime_error(\"a multisignature address must require at least one key to redeem\");\n-    if ((int)keys.size() < nRequired)\n-        throw std::runtime_error(\n-            strprintf(\"not enough keys supplied \"\n-                      \"(got %u keys, but need at least %d to redeem)\", keys.size(), nRequired));\n-    if (keys.size() > 16)\n-        throw std::runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n-    std::vector<CPubKey> pubkeys;\n-    pubkeys.resize(keys.size());\n-    for (unsigned int i = 0; i < keys.size(); i++)\n-    {\n-        const std::string& ks = keys[i].get_str();\n-#ifdef ENABLE_WALLET\n-        // Case 1: Bitcoin address and we have full public key:\n-        CBitcoinAddress address(ks);\n-        if (pwallet && address.IsValid()) {\n-            CKeyID keyID;\n-            if (!address.GetKeyID(keyID))\n-                throw std::runtime_error(\n-                    strprintf(\"%s does not refer to a key\",ks));\n-            CPubKey vchPubKey;\n-            if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n-                throw std::runtime_error(\n-                    strprintf(\"no full public key for address %s\",ks));\n-            }\n-            if (!vchPubKey.IsFullyValid())\n-                throw std::runtime_error(\" Invalid public key: \"+ks);\n-            pubkeys[i] = vchPubKey;\n-        }\n-\n-        // Case 2: hex public key\n-        else\n-#endif\n-        if (IsHex(ks))\n-        {\n-            CPubKey vchPubKey(ParseHex(ks));\n-            if (!vchPubKey.IsFullyValid())\n-                throw std::runtime_error(\" Invalid public key: \"+ks);\n-            pubkeys[i] = vchPubKey;\n-        }\n-        else\n-        {\n-            throw std::runtime_error(\" Invalid public key: \"+ks);\n-        }\n-    }\n-    CScript result = GetScriptForMultisig(nRequired, pubkeys);\n-\n-    if (result.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-        throw std::runtime_error(\n-                strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n-\n-    return result;\n-}\n-\n-UniValue createmultisig(const JSONRPCRequest& request)\n-{\n-#ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n-#else\n-    CWallet * const pwallet = NULL;\n-#endif\n-\n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)\n-    {\n-        std::string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n-            \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n-            \"It returns a json object with the address and redeemScript.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. nrequired      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n-            \"2. \\\"keys\\\"       (string, required) A json array of keys which are bitcoin addresses or hex-encoded public keys\\n\"\n-            \"     [\\n\"\n-            \"       \\\"key\\\"    (string) bitcoin address or hex-encoded public key\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new multisig address.\\n\"\n-            \"  \\\"redeemScript\\\":\\\"script\\\"       (string) The string value of the hex-encoded redemption script.\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            \"\\nCreate a multisig address from 2 addresses\\n\"\n-            + HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n-        ;\n-        throw std::runtime_error(msg);\n-    }\n-\n-    // Construct using pay-to-script-hash:\n-    CScript inner = _createmultisig_redeemScript(pwallet, request.params);\n-    CScriptID innerID(inner);\n-    CBitcoinAddress address(innerID);\n-\n-    UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"address\", address.ToString()));\n-    result.push_back(Pair(\"redeemScript\", HexStr(inner.begin(), inner.end())));\n-\n-    return result;\n-}\n-\n-UniValue verifymessage(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 3)\n-        throw std::runtime_error(\n-            \"verifymessage \\\"address\\\" \\\"signature\\\" \\\"message\\\"\\n\"\n-            \"\\nVerify a signed message\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"address\\\"         (string, required) The bitcoin address to use for the signature.\\n\"\n-            \"2. \\\"signature\\\"       (string, required) The signature provided by the signer in base 64 encoding (see signmessage).\\n\"\n-            \"3. \\\"message\\\"         (string, required) The message that was signed.\\n\"\n-            \"\\nResult:\\n\"\n-            \"true|false   (boolean) If the signature is verified or not.\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nUnlock the wallet for 30 seconds\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"mypassphrase\\\" 30\") +\n-            \"\\nCreate the signature\\n\"\n-            + HelpExampleCli(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"my message\\\"\") +\n-            \"\\nVerify the signature\\n\"\n-            + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"signature\\\" \\\"my message\\\"\") +\n-            \"\\nAs json rpc\\n\"\n-            + HelpExampleRpc(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"signature\\\", \\\"my message\\\"\")\n-        );\n-\n-    LOCK(cs_main);\n-\n-    std::string strAddress  = request.params[0].get_str();\n-    std::string strSign     = request.params[1].get_str();\n-    std::string strMessage  = request.params[2].get_str();\n-\n-    CBitcoinAddress addr(strAddress);\n-    if (!addr.IsValid())\n-        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n-\n-    CKeyID keyID;\n-    if (!addr.GetKeyID(keyID))\n-        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n-\n-    bool fInvalid = false;\n-    std::vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n-\n-    if (fInvalid)\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Malformed base64 encoding\");\n-\n-    CHashWriter ss(SER_GETHASH, 0);\n-    ss << strMessageMagic;\n-    ss << strMessage;\n-\n-    CPubKey pubkey;\n-    if (!pubkey.RecoverCompact(ss.GetHash(), vchSig))\n-        return false;\n-\n-    return (pubkey.GetID() == keyID);\n-}\n-\n-UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 2)\n-        throw std::runtime_error(\n-            \"signmessagewithprivkey \\\"privkey\\\" \\\"message\\\"\\n\"\n-            \"\\nSign a message with the private key of an address\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"privkey\\\"         (string, required) The private key to sign the message with.\\n\"\n-            \"2. \\\"message\\\"         (string, required) The message to create a signature of.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nCreate the signature\\n\"\n-            + HelpExampleCli(\"signmessagewithprivkey\", \"\\\"privkey\\\" \\\"my message\\\"\") +\n-            \"\\nVerify the signature\\n\"\n-            + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"signature\\\" \\\"my message\\\"\") +\n-            \"\\nAs json rpc\\n\"\n-            + HelpExampleRpc(\"signmessagewithprivkey\", \"\\\"privkey\\\", \\\"my message\\\"\")\n-        );\n-\n-    std::string strPrivkey = request.params[0].get_str();\n-    std::string strMessage = request.params[1].get_str();\n-\n-    CBitcoinSecret vchSecret;\n-    bool fGood = vchSecret.SetString(strPrivkey);\n-    if (!fGood)\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n-    CKey key = vchSecret.GetKey();\n-    if (!key.IsValid())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n-\n-    CHashWriter ss(SER_GETHASH, 0);\n-    ss << strMessageMagic;\n-    ss << strMessage;\n-\n-    std::vector<unsigned char> vchSig;\n-    if (!key.SignCompact(ss.GetHash(), vchSig))\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n-\n-    return EncodeBase64(&vchSig[0], vchSig.size());\n-}\n-\n-UniValue setmocktime(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"setmocktime timestamp\\n\"\n-            \"\\nSet the local time to given timestamp (-regtest only)\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. timestamp  (integer, required) Unix seconds-since-epoch timestamp\\n\"\n-            \"   Pass 0 to go back to using the system time.\"\n-        );\n-\n-    if (!Params().MineBlocksOnDemand())\n-        throw std::runtime_error(\"setmocktime for regression testing (-regtest mode) only\");\n-\n-    // For now, don't change mocktime if we're in the middle of validation, as\n-    // this could have an effect on mempool time-based eviction, as well as\n-    // IsCurrentForFeeEstimation() and IsInitialBlockDownload().\n-    // TODO: figure out the right way to synchronize around mocktime, and\n-    // ensure all call sites of GetTime() are accessing this safely.\n-    LOCK(cs_main);\n-\n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));\n-    SetMockTime(request.params[0].get_int64());\n-\n-    return NullUniValue;\n-}\n-\n-static UniValue RPCLockedMemoryInfo()\n-{\n-    LockedPool::Stats stats = LockedPoolManager::Instance().stats();\n-    UniValue obj(UniValue::VOBJ);\n-    obj.push_back(Pair(\"used\", uint64_t(stats.used)));\n-    obj.push_back(Pair(\"free\", uint64_t(stats.free)));\n-    obj.push_back(Pair(\"total\", uint64_t(stats.total)));\n-    obj.push_back(Pair(\"locked\", uint64_t(stats.locked)));\n-    obj.push_back(Pair(\"chunks_used\", uint64_t(stats.chunks_used)));\n-    obj.push_back(Pair(\"chunks_free\", uint64_t(stats.chunks_free)));\n-    return obj;\n-}\n-\n-#ifdef HAVE_MALLOC_INFO\n-static std::string RPCMallocInfo()\n-{\n-    char *ptr = nullptr;\n-    size_t size = 0;\n-    FILE *f = open_memstream(&ptr, &size);\n-    if (f) {\n-        malloc_info(0, f);\n-        fclose(f);\n-        if (ptr) {\n-            std::string rv(ptr, size);\n-            free(ptr);\n-            return rv;\n-        }\n-    }\n-    return \"\";\n-}\n-#endif\n-\n-UniValue getmemoryinfo(const JSONRPCRequest& request)\n-{\n-    /* Please, avoid using the word \"pool\" here in the RPC interface or help,\n-     * as users will undoubtedly confuse it with the other \"memory pool\"\n-     */\n-    if (request.fHelp || request.params.size() > 1)\n-        throw std::runtime_error(\n-            \"getmemoryinfo (\\\"mode\\\")\\n\"\n-            \"Returns an object containing information about memory usage.\\n\"\n-            \"Arguments:\\n\"\n-            \"1. \\\"mode\\\" determines what kind of information is returned. This argument is optional, the default mode is \\\"stats\\\".\\n\"\n-            \"  - \\\"stats\\\" returns general statistics about memory usage in the daemon.\\n\"\n-            \"  - \\\"mallocinfo\\\" returns an XML string describing low-level heap state (only available if compiled with glibc 2.10+).\\n\"\n-            \"\\nResult (mode \\\"stats\\\"):\\n\"\n-            \"{\\n\"\n-            \"  \\\"locked\\\": {               (json object) Information about locked memory manager\\n\"\n-            \"    \\\"used\\\": xxxxx,          (numeric) Number of bytes used\\n\"\n-            \"    \\\"free\\\": xxxxx,          (numeric) Number of bytes available in current arenas\\n\"\n-            \"    \\\"total\\\": xxxxxxx,       (numeric) Total number of bytes managed\\n\"\n-            \"    \\\"locked\\\": xxxxxx,       (numeric) Amount of bytes that succeeded locking. If this number is smaller than total, locking pages failed at some point and key data could be swapped to disk.\\n\"\n-            \"    \\\"chunks_used\\\": xxxxx,   (numeric) Number allocated chunks\\n\"\n-            \"    \\\"chunks_free\\\": xxxxx,   (numeric) Number unused chunks\\n\"\n-            \"  }\\n\"\n-            \"}\\n\"\n-            \"\\nResult (mode \\\"mallocinfo\\\"):\\n\"\n-            \"\\\"<malloc version=\\\"1\\\">...\\\"\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getmemoryinfo\", \"\")\n-            + HelpExampleRpc(\"getmemoryinfo\", \"\")\n-        );\n-\n-    std::string mode = (request.params.size() < 1 || request.params[0].isNull()) ? \"stats\" : request.params[0].get_str();\n-    if (mode == \"stats\") {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.push_back(Pair(\"locked\", RPCLockedMemoryInfo()));\n-        return obj;\n-    } else if (mode == \"mallocinfo\") {\n-#ifdef HAVE_MALLOC_INFO\n-        return RPCMallocInfo();\n-#else\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"mallocinfo is only available when compiled with glibc 2.10+\");\n-#endif\n-    } else {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"unknown mode \" + mode);\n-    }\n-}\n-\n-uint32_t getCategoryMask(UniValue cats) {\n-    cats = cats.get_array();\n-    uint32_t mask = 0;\n-    for (unsigned int i = 0; i < cats.size(); ++i) {\n-        uint32_t flag = 0;\n-        std::string cat = cats[i].get_str();\n-        if (!GetLogCategory(&flag, &cat)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"unknown logging category \" + cat);\n-        }\n-        mask |= flag;\n-    }\n-    return mask;\n-}\n-\n-UniValue logging(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() > 2) {\n-        throw std::runtime_error(\n-            \"logging [include,...] <exclude>\\n\"\n-            \"Gets and sets the logging configuration.\\n\"\n-            \"When called without an argument, returns the list of categories that are currently being debug logged.\\n\"\n-            \"When called with arguments, adds or removes categories from debug logging.\\n\"\n-            \"The valid logging categories are: \" + ListLogCategories() + \"\\n\"\n-            \"libevent logging is configured on startup and cannot be modified by this RPC during runtime.\"\n-            \"Arguments:\\n\"\n-            \"1. \\\"include\\\" (array of strings) add debug logging for these categories.\\n\"\n-            \"2. \\\"exclude\\\" (array of strings) remove debug logging for these categories.\\n\"\n-            \"\\nResult: <categories>  (string): a list of the logging categories that are active.\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"logging\", \"\\\"[\\\\\\\"all\\\\\\\"]\\\" \\\"[\\\\\\\"http\\\\\\\"]\\\"\")\n-            + HelpExampleRpc(\"logging\", \"[\\\"all\\\"], \\\"[libevent]\\\"\")\n-        );\n-    }\n-\n-    uint32_t originalLogCategories = logCategories;\n-    if (request.params.size() > 0 && request.params[0].isArray()) {\n-        logCategories |= getCategoryMask(request.params[0]);\n-    }\n-\n-    if (request.params.size() > 1 && request.params[1].isArray()) {\n-        logCategories &= ~getCategoryMask(request.params[1]);\n-    }\n-\n-    // Update libevent logging if BCLog::LIBEVENT has changed.\n-    // If the library version doesn't allow it, UpdateHTTPServerLogging() returns false,\n-    // in which case we should clear the BCLog::LIBEVENT flag.\n-    // Throw an error if the user has explicitly asked to change only the libevent\n-    // flag and it failed.\n-    uint32_t changedLogCategories = originalLogCategories ^ logCategories;\n-    if (changedLogCategories & BCLog::LIBEVENT) {\n-        if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n-            logCategories &= ~BCLog::LIBEVENT;\n-            if (changedLogCategories == BCLog::LIBEVENT) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"libevent logging cannot be updated when using libevent before v2.1.1.\");\n-            }\n-        }\n-    }\n-\n-    UniValue result(UniValue::VOBJ);\n-    std::vector<CLogCategoryActive> vLogCatActive = ListActiveLogCategories();\n-    for (const auto& logCatActive : vLogCatActive) {\n-        result.pushKV(logCatActive.category, logCatActive.active);\n-    }\n-\n-    return result;\n-}\n-\n-UniValue echo(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp)\n-        throw std::runtime_error(\n-            \"echo|echojson \\\"message\\\" ...\\n\"\n-            \"\\nSimply echo back the input arguments. This command is for testing.\\n\"\n-            \"\\nThe difference between echo and echojson is that echojson has argument conversion enabled in the client-side table in\"\n-            \"bitcoin-cli and the GUI. There is no server-side difference.\"\n-        );\n-\n-    return request.params;\n-}\n-\n-static const CRPCCommand commands[] =\n-{ //  category              name                      actor (function)         okSafeMode\n-  //  --------------------- ------------------------  -----------------------  ----------\n-    { \"control\",            \"getinfo\",                &getinfo,                true,  {} }, /* uses wallet if enabled */\n-    { \"control\",            \"getmemoryinfo\",          &getmemoryinfo,          true,  {\"mode\"} },\n-    { \"util\",               \"validateaddress\",        &validateaddress,        true,  {\"address\"} }, /* uses wallet if enabled */\n-    { \"util\",               \"createmultisig\",         &createmultisig,         true,  {\"nrequired\",\"keys\"} },\n-    { \"util\",               \"verifymessage\",          &verifymessage,          true,  {\"address\",\"signature\",\"message\"} },\n-    { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true,  {\"privkey\",\"message\"} },\n-\n-    /* Address index */\n-    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true  },\n-    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false },\n-    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false },\n-    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false },\n-    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false },\n-\n-    /* Blockchain */\n-    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false, {} },\n-\n-    /* Not shown in help */\n-    { \"hidden\",             \"setmocktime\",            &setmocktime,            true,  {\"timestamp\"}},\n-    { \"hidden\",             \"echo\",                   &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n-    { \"hidden\",             \"echojson\",               &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n-    { \"hidden\",             \"logging\",                &logging,                true,  {\"include\", \"exclude\"}},\n-};\n-\n-void RegisterMiscRPCCommands(CRPCTable &t)\n-{\n-    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n-        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n-}\n-\n-bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)\n-{\n-    if (type == 2) {\n-        address = CBitcoinAddress(CScriptID(hash)).ToString();\n-    } else if (type == 1) {\n-        address = CBitcoinAddress(CKeyID(hash)).ToString();\n-    } else {\n-        return false;\n-    }\n-    return true;\n-}\n-\n-bool getAddressesFromParams(const UniValue& params, std::vector<std::pair<uint160, int> > &addresses)\n-{\n-    if (params[0].isStr()) {\n-        CBitcoinAddress address(params[0].get_str());\n-        uint160 hashBytes;\n-        int type = 0;\n-        if (!address.GetIndexKey(hashBytes, type)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-        }\n-        addresses.push_back(std::make_pair(hashBytes, type));\n-    } else if (params[0].isObject()) {\n-\n-        UniValue addressValues = find_value(params[0].get_obj(), \"addresses\");\n-        if (!addressValues.isArray()) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Addresses is expected to be an array\");\n-        }\n-\n-        std::vector<UniValue> values = addressValues.getValues();\n-\n-        for (std::vector<UniValue>::iterator it = values.begin(); it != values.end(); ++it) {\n-\n-            CBitcoinAddress address(it->get_str());\n-            uint160 hashBytes;\n-            int type = 0;\n-            if (!address.GetIndexKey(hashBytes, type)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            addresses.push_back(std::make_pair(hashBytes, type));\n-        }\n-    } else {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-    }\n-\n-    return true;\n-}\n-\n-bool heightSort(std::pair<CAddressUnspentKey, CAddressUnspentValue> a,\n-                std::pair<CAddressUnspentKey, CAddressUnspentValue> b) {\n-    return a.second.blockHeight < b.second.blockHeight;\n-}\n-\n-bool timestampSort(std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> a,\n-                   std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> b) {\n-    return a.second.time < b.second.time;\n-}\n-\n-UniValue getaddressmempool(const UniValue& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaddressmempool\\n\"\n-            \"\\nReturns all mempool deltas for an address (requires addressindex to be enabled).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"{\\n\"\n-            \"  \\\"addresses\\\"\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"}\\n\"\n-            \"\\nResult:\\n\"\n-            \"[\\n\"\n-            \"  {\\n\"\n-            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"    \\\"txid\\\"  (string) The related txid\\n\"\n-            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n-            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n-            \"    \\\"timestamp\\\"  (number) The time the transaction entered the mempool (seconds)\\n\"\n-            \"    \\\"prevtxid\\\"  (string) The previous txid (if spending)\\n\"\n-            \"    \\\"prevout\\\"  (string) The previous transaction output index (if spending)\\n\"\n-            \"  }\\n\"\n-            \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddressmempool\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n-            + HelpExampleRpc(\"getaddressmempool\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n-        );\n-\n-    std::vector<std::pair<uint160, int> > addresses;\n-\n-    if (!getAddressesFromParams(params, addresses)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-    }\n-\n-    std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > indexes;\n-\n-    if (!mempool.getAddressIndex(addresses, indexes)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-    }\n-\n-    std::sort(indexes.begin(), indexes.end(), timestampSort);\n-\n-    UniValue result(UniValue::VARR);\n-\n-    for (std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> >::iterator it = indexes.begin();\n-         it != indexes.end(); it++) {\n-\n-        std::string address;\n-        if (!getAddressFromIndex(it->first.type, it->first.addressBytes, address)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n-        }\n-\n-        UniValue delta(UniValue::VOBJ);\n-        delta.push_back(Pair(\"address\", address));\n-        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n-        delta.push_back(Pair(\"index\", (int)it->first.index));\n-        delta.push_back(Pair(\"satoshis\", it->second.amount));\n-        delta.push_back(Pair(\"timestamp\", it->second.time));\n-        if (it->second.amount < 0) {\n-            delta.push_back(Pair(\"prevtxid\", it->second.prevhash.GetHex()));\n-            delta.push_back(Pair(\"prevout\", (int)it->second.prevout));\n-        }\n-        result.push_back(delta);\n-    }\n-\n-    return result;\n-}\n-\n-UniValue getaddressutxos(const UniValue& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaddressutxos\\n\"\n-            \"\\nReturns all unspent outputs for an address (requires addressindex to be enabled).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"{\\n\"\n-            \"  \\\"addresses\\\"\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"      ,...\\n\"\n-            \"    ],\\n\"\n-            \"  \\\"chainInfo\\\"  (boolean) Include chain info with results\\n\"\n-            \"}\\n\"\n-            \"\\nResult\\n\"\n-            \"[\\n\"\n-            \"  {\\n\"\n-            \"    \\\"address\\\"  (string) The address base58check encoded\\n\"\n-            \"    \\\"txid\\\"  (string) The output txid\\n\"\n-            \"    \\\"height\\\"  (number) The block height\\n\"\n-            \"    \\\"outputIndex\\\"  (number) The output index\\n\"\n-            \"    \\\"script\\\"  (strin) The script hex encoded\\n\"\n-            \"    \\\"satoshis\\\"  (number) The number of satoshis of the output\\n\"\n-            \"  }\\n\"\n-            \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddressutxos\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n-            + HelpExampleRpc(\"getaddressutxos\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n-            );\n-\n-    bool includeChainInfo = false;\n-    if (params[0].isObject()) {\n-        UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n-        if (chainInfo.isBool()) {\n-            includeChainInfo = chainInfo.get_bool();\n-        }\n-    }\n-\n-    std::vector<std::pair<uint160, int> > addresses;\n-\n-    if (!getAddressesFromParams(params, addresses)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-    }\n-\n-    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > unspentOutputs;\n-\n-    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n-        if (!GetAddressUnspent((*it).first, (*it).second, unspentOutputs)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-        }\n-    }\n-\n-    std::sort(unspentOutputs.begin(), unspentOutputs.end(), heightSort);\n-\n-    UniValue utxos(UniValue::VARR);\n-\n-    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=unspentOutputs.begin(); it!=unspentOutputs.end(); it++) {\n-        UniValue output(UniValue::VOBJ);\n-        std::string address;\n-        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n-        }\n-\n-        output.push_back(Pair(\"address\", address));\n-        output.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n-        output.push_back(Pair(\"outputIndex\", (int)it->first.index));\n-        output.push_back(Pair(\"script\", HexStr(it->second.script.begin(), it->second.script.end())));\n-        output.push_back(Pair(\"satoshis\", it->second.satoshis));\n-        output.push_back(Pair(\"height\", it->second.blockHeight));\n-        utxos.push_back(output);\n-    }\n-\n-    if (includeChainInfo) {\n-        UniValue result(UniValue::VOBJ);\n-        result.push_back(Pair(\"utxos\", utxos));\n-\n-        LOCK(cs_main);\n-        result.push_back(Pair(\"hash\", chainActive.Tip()->GetBlockHash().GetHex()));\n-        result.push_back(Pair(\"height\", (int)chainActive.Height()));\n-        return result;\n-    } else {\n-        return utxos;\n-    }\n-}\n-\n-UniValue getaddressdeltas(const UniValue& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1 || !params[0].isObject())\n-        throw runtime_error(\n-            \"getaddressdeltas\\n\"\n-            \"\\nReturns all changes for an address (requires addressindex to be enabled).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"{\\n\"\n-            \"  \\\"addresses\\\"\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"  \\\"start\\\" (number) The start block height\\n\"\n-            \"  \\\"end\\\" (number) The end block height\\n\"\n-            \"  \\\"chainInfo\\\" (boolean) Include chain info in results, only applies if start and end specified\\n\"\n-            \"}\\n\"\n-            \"\\nResult:\\n\"\n-            \"[\\n\"\n-            \"  {\\n\"\n-            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n-            \"    \\\"txid\\\"  (string) The related txid\\n\"\n-            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n-            \"    \\\"height\\\"  (number) The block height\\n\"\n-            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"  }\\n\"\n-            \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddressdeltas\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n-            + HelpExampleRpc(\"getaddressdeltas\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n-        );\n-\n-\n-    UniValue startValue = find_value(params[0].get_obj(), \"start\");\n-    UniValue endValue = find_value(params[0].get_obj(), \"end\");\n-\n-    UniValue chainInfo = find_value(params[0].get_obj(), \"chainInfo\");\n-    bool includeChainInfo = false;\n-    if (chainInfo.isBool()) {\n-        includeChainInfo = chainInfo.get_bool();\n-    }\n-\n-    int start = 0;\n-    int end = 0;\n-\n-    if (startValue.isNum() && endValue.isNum()) {\n-        start = startValue.get_int();\n-        end = endValue.get_int();\n-        if (start <= 0 || end <= 0) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start and end is expected to be greater than zero\");\n-        }\n-        if (end < start) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"End value is expected to be greater than start\");\n-        }\n-    }\n-\n-    std::vector<std::pair<uint160, int> > addresses;\n-\n-    if (!getAddressesFromParams(params, addresses)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-    }\n-\n-    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n-\n-    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n-        if (start > 0 && end > 0) {\n-            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-            }\n-        } else {\n-            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-            }\n-        }\n-    }\n-\n-    UniValue deltas(UniValue::VARR);\n-\n-    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n-        std::string address;\n-        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n-        }\n-\n-        UniValue delta(UniValue::VOBJ);\n-        delta.push_back(Pair(\"satoshis\", it->second));\n-        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n-        delta.push_back(Pair(\"index\", (int)it->first.index));\n-        delta.push_back(Pair(\"blockindex\", (int)it->first.txindex));\n-        delta.push_back(Pair(\"height\", it->first.blockHeight));\n-        delta.push_back(Pair(\"address\", address));\n-        deltas.push_back(delta);\n-    }\n-\n-    UniValue result(UniValue::VOBJ);\n-\n-    if (includeChainInfo && start > 0 && end > 0) {\n-        LOCK(cs_main);\n-\n-        if (start > chainActive.Height() || end > chainActive.Height()) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start or end is outside chain range\");\n-        }\n-\n-        CBlockIndex* startIndex = chainActive[start];\n-        CBlockIndex* endIndex = chainActive[end];\n-\n-        UniValue startInfo(UniValue::VOBJ);\n-        UniValue endInfo(UniValue::VOBJ);\n-\n-        startInfo.push_back(Pair(\"hash\", startIndex->GetBlockHash().GetHex()));\n-        startInfo.push_back(Pair(\"height\", start));\n-\n-        endInfo.push_back(Pair(\"hash\", endIndex->GetBlockHash().GetHex()));\n-        endInfo.push_back(Pair(\"height\", end));\n-\n-        result.push_back(Pair(\"deltas\", deltas));\n-        result.push_back(Pair(\"start\", startInfo));\n-        result.push_back(Pair(\"end\", endInfo));\n-\n-        return result;\n-    } else {\n-        return deltas;\n-    }\n-}\n-\n-UniValue getaddressbalance(const UniValue& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaddressbalance\\n\"\n-            \"\\nReturns the balance for an address(es) (requires addressindex to be enabled).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"{\\n\"\n-            \"  \\\"addresses\\\"\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"}\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"balance\\\"  (string) The current balance in satoshis\\n\"\n-            \"  \\\"received\\\"  (string) The total number of satoshis received (including change)\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddressbalance\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n-            + HelpExampleRpc(\"getaddressbalance\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n-        );\n-\n-    std::vector<std::pair<uint160, int> > addresses;\n-\n-    if (!getAddressesFromParams(params, addresses)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-    }\n-\n-    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n-\n-    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n-        if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-        }\n-    }\n-\n-    CAmount balance = 0;\n-    CAmount received = 0;\n-\n-    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n-        if (it->second > 0) {\n-            received += it->second;\n-        }\n-        balance += it->second;\n-    }\n-\n-    UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"balance\", balance));\n-    result.push_back(Pair(\"received\", received));\n-\n-    return result;\n-\n-}\n-\n-UniValue getaddresstxids(const UniValue& params, bool fHelp)\n-{\n-    if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"getaddresstxids\\n\"\n-            \"\\nReturns the txids for an address(es) (requires addressindex to be enabled).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"{\\n\"\n-            \"  \\\"addresses\\\"\\n\"\n-            \"    [\\n\"\n-            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"  \\\"start\\\" (number) The start block height\\n\"\n-            \"  \\\"end\\\" (number) The end block height\\n\"\n-            \"}\\n\"\n-            \"\\nResult:\\n\"\n-            \"[\\n\"\n-            \"  \\\"transactionid\\\"  (string) The transaction id\\n\"\n-            \"  ,...\\n\"\n-            \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddresstxids\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n-            + HelpExampleRpc(\"getaddresstxids\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n-        );\n-\n-    std::vector<std::pair<uint160, int> > addresses;\n-\n-    if (!getAddressesFromParams(params, addresses)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-    }\n-\n-    int start = 0;\n-    int end = 0;\n-    if (params[0].isObject()) {\n-        UniValue startValue = find_value(params[0].get_obj(), \"start\");\n-        UniValue endValue = find_value(params[0].get_obj(), \"end\");\n-        if (startValue.isNum() && endValue.isNum()) {\n-            start = startValue.get_int();\n-            end = endValue.get_int();\n-        }\n-    }\n-\n-    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n-\n-    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n-        if (start > 0 && end > 0) {\n-            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-            }\n-        } else {\n-            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n-            }\n-        }\n-    }\n-\n-    std::set<std::pair<int, std::string> > txids;\n-    UniValue result(UniValue::VARR);\n-\n-    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n-        int height = it->first.blockHeight;\n-        std::string txid = it->first.txhash.GetHex();\n-\n-        if (addresses.size() > 1) {\n-            txids.insert(std::make_pair(height, txid));\n-        } else {\n-            if (txids.insert(std::make_pair(height, txid)).second) {\n-                result.push_back(txid);\n-            }\n-        }\n-    }\n-\n-    if (addresses.size() > 1) {\n-        for (std::set<std::pair<int, std::string> >::const_iterator it=txids.begin(); it!=txids.end(); it++) {\n-            result.push_back(it->second);\n-        }\n-    }\n-\n-    return result;\n-\n-}\n-\n-UniValue getspentinfo(const UniValue& params, bool fHelp)\n-{\n-\n-    if (fHelp || params.size() != 1 || !params[0].isObject())\n-        throw runtime_error(\n-            \"getspentinfo\\n\"\n-            \"\\nReturns the txid and index where an output is spent.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"{\\n\"\n-            \"  \\\"txid\\\" (string) The hex string of the txid\\n\"\n-            \"  \\\"index\\\" (number) The start block height\\n\"\n-            \"}\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"txid\\\"  (string) The transaction id\\n\"\n-            \"  \\\"index\\\"  (number) The spending input index\\n\"\n-            \"  ,...\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getspentinfo\", \"'{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}'\")\n-            + HelpExampleRpc(\"getspentinfo\", \"{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}\")\n-        );\n-\n-    UniValue txidValue = find_value(params[0].get_obj(), \"txid\");\n-    UniValue indexValue = find_value(params[0].get_obj(), \"index\");\n-\n-    if (!txidValue.isStr() || !indexValue.isNum()) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid txid or index\");\n-    }\n-\n-    uint256 txid = ParseHashV(txidValue, \"txid\");\n-    int outputIndex = indexValue.get_int();\n-\n-    CSpentIndexKey key(txid, outputIndex);\n-    CSpentIndexValue value;\n-\n-    if (!GetSpentIndex(key, value)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unable to get spent info\");\n-    }\n-\n-    UniValue obj(UniValue::VOBJ);\n-    obj.push_back(Pair(\"txid\", value.txid.GetHex()));\n-    obj.push_back(Pair(\"index\", (int)value.inputIndex));\n-    obj.push_back(Pair(\"height\", value.blockHeight));\n-\n-    return obj;\n-}"
      },
      {
        "sha": "6968e0dca8133fe91e0f7c81903a72ba3afc0d0d",
        "filename": "test/functional/addressindex.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/addressindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/addressindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/addressindex.py?ref=06726dd4134fc2ce7a9695f85e347dcec72a69ec",
        "previous_filename": "qa/rpc-tests/addressindex.py"
      },
      {
        "sha": "4119a11aef04ea97a44eaa2a9d2225ef24ae483b",
        "filename": "test/functional/spentindex.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/spentindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/spentindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/spentindex.py?ref=06726dd4134fc2ce7a9695f85e347dcec72a69ec",
        "previous_filename": "qa/rpc-tests/spentindex.py"
      },
      {
        "sha": "85942b7ef6929f2e43d29168815d87ac415d610a",
        "filename": "test/functional/timestampindex.py",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/timestampindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/timestampindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/timestampindex.py?ref=06726dd4134fc2ce7a9695f85e347dcec72a69ec",
        "previous_filename": "qa/rpc-tests/timestampindex.py"
      },
      {
        "sha": "08e176c96bfa9f7bd724911f0b6b9539a074a441",
        "filename": "test/functional/txindex.py",
        "status": "renamed",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/txindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06726dd4134fc2ce7a9695f85e347dcec72a69ec/test/functional/txindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/txindex.py?ref=06726dd4134fc2ce7a9695f85e347dcec72a69ec",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -36,22 +36,22 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print \"Mining blocks...\"\n+        print(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n \n         chain_height = self.nodes[1].getblockcount()\n         assert_equal(chain_height, 105)\n \n-        print \"Testing transaction index...\"\n+        print(\"Testing transaction index...\")\n \n         privkey = \"cSdkPxkAjA4HDr5VHgsebAPDEh9Gyub4HK8UJr2DFGGqKKy4K5sG\"\n         address = \"mgY65WSfEmsyYaYPQaXhmXMeBhwp4EcsQW\"\n-        addressHash = \"0b2f0a0c31bfe0406b0ccc1381fdbe311946dadc\".decode(\"hex\")\n+        addressHash = bytes([11,47,10,12,49,191,224,64,107,12,204,19,129,253,190,49,25,70,218,220])\n         scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n-        amount = unspent[0][\"amount\"] * 100000000\n+        amount = int(unspent[0][\"amount\"] * 100000000)\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n         tx.vout = [CTxOut(amount, scriptPubKey)]\n         tx.rehash()\n@@ -66,7 +66,7 @@ def run_test(self):\n         assert_equal(verbose[\"vout\"][0][\"valueSat\"], 5000000000);\n         assert_equal(verbose[\"vout\"][0][\"value\"], 50);\n \n-        print \"Passed\\n\"\n+        print(\"Passed\\n\")\n \n \n if __name__ == '__main__':",
        "previous_filename": "qa/rpc-tests/txindex.py"
      }
    ]
  },
  {
    "sha": "74a85014d298c15c334d666bce870750d85e79ba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NGE4NTAxNGQyOThjMTVjMzM0ZDY2NmJjZTg3MDc1MGQ4NWU3OWJh",
    "commit": {
      "author": {
        "name": "Braydon Fuller",
        "email": "braydon@bitpay.com",
        "date": "2016-10-07T15:49:40Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:50Z"
      },
      "message": "build: include timestampindex.h in makefile",
      "tree": {
        "sha": "5ef67f5f481ea9aba62b2b78369a703da76ba995",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ef67f5f481ea9aba62b2b78369a703da76ba995"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/74a85014d298c15c334d666bce870750d85e79ba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74a85014d298c15c334d666bce870750d85e79ba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/74a85014d298c15c334d666bce870750d85e79ba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74a85014d298c15c334d666bce870750d85e79ba/comments",
    "author": null,
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06726dd4134fc2ce7a9695f85e347dcec72a69ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06726dd4134fc2ce7a9695f85e347dcec72a69ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06726dd4134fc2ce7a9695f85e347dcec72a69ec"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "08755ee9295297af6e8cee66aad132bfc7b78650",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/74a85014d298c15c334d666bce870750d85e79ba/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/74a85014d298c15c334d666bce870750d85e79ba/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=74a85014d298c15c334d666bce870750d85e79ba",
        "patch": "@@ -79,6 +79,7 @@ BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addressindex.h \\\n   spentindex.h \\\n+  timestampindex.h \\\n   addrman.h \\\n   base58.h \\\n   bloom.h \\"
      }
    ]
  },
  {
    "sha": "7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTRhZDBjNzEwNGYzYTNkMzQxYjRjOGMzNTg5YjVjYWNmZjk2YzI1",
    "commit": {
      "author": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-04-02T00:11:09Z"
      },
      "committer": {
        "name": "Karel Bilek",
        "email": "kb@karelbilek.com",
        "date": "2017-05-09T10:42:51Z"
      },
      "message": "Bitcore 0.14.0 fixes",
      "tree": {
        "sha": "82a214d56320630558db91806fc1cc08b82647d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/82a214d56320630558db91806fc1cc08b82647d2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/comments",
    "author": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "karelbilek",
      "id": 104945,
      "node_id": "MDQ6VXNlcjEwNDk0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/104945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karelbilek",
      "html_url": "https://github.com/karelbilek",
      "followers_url": "https://api.github.com/users/karelbilek/followers",
      "following_url": "https://api.github.com/users/karelbilek/following{/other_user}",
      "gists_url": "https://api.github.com/users/karelbilek/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karelbilek/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karelbilek/subscriptions",
      "organizations_url": "https://api.github.com/users/karelbilek/orgs",
      "repos_url": "https://api.github.com/users/karelbilek/repos",
      "events_url": "https://api.github.com/users/karelbilek/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karelbilek/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "74a85014d298c15c334d666bce870750d85e79ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74a85014d298c15c334d666bce870750d85e79ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/74a85014d298c15c334d666bce870750d85e79ba"
      }
    ],
    "stats": {
      "total": 1334,
      "additions": 1205,
      "deletions": 129
    },
    "files": [
      {
        "sha": "bc10605833bb23a6059f0addf68841713d5db4ee",
        "filename": "src/addressindex.h",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/addressindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/addressindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addressindex.h?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -16,21 +16,21 @@ struct CAddressUnspentKey {\n     uint256 txhash;\n     size_t index;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 57;\n     }\n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n-        txhash.Serialize(s, nType, nVersion);\n+        hashBytes.Serialize(s);\n+        txhash.Serialize(s);\n         ser_writedata32(s, index);\n     }\n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n-        txhash.Unserialize(s, nType, nVersion);\n+        hashBytes.Unserialize(s);\n+        txhash.Unserialize(s);\n         index = ser_readdata32(s);\n     }\n \n@@ -61,7 +61,7 @@ struct CAddressUnspentValue {\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(satoshis);\n         READWRITE(*(CScriptBase*)(&script));\n         READWRITE(blockHeight);\n@@ -97,28 +97,28 @@ struct CAddressIndexKey {\n     size_t index;\n     bool spending;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 66;\n     }\n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n+        hashBytes.Serialize(s);\n         // Heights are stored big-endian for key sorting in LevelDB\n         ser_writedata32be(s, blockHeight);\n         ser_writedata32be(s, txindex);\n-        txhash.Serialize(s, nType, nVersion);\n+        txhash.Serialize(s);\n         ser_writedata32(s, index);\n         char f = spending;\n         ser_writedata8(s, f);\n     }\n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n+        hashBytes.Unserialize(s);\n         blockHeight = ser_readdata32be(s);\n         txindex = ser_readdata32be(s);\n-        txhash.Unserialize(s, nType, nVersion);\n+        txhash.Unserialize(s);\n         index = ser_readdata32(s);\n         char f = ser_readdata8(s);\n         spending = f;\n@@ -155,18 +155,18 @@ struct CAddressIndexIteratorKey {\n     unsigned int type;\n     uint160 hashBytes;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 21;\n     }\n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n+        hashBytes.Serialize(s);\n     }\n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n+        hashBytes.Unserialize(s);\n     }\n \n     CAddressIndexIteratorKey(unsigned int addressType, uint160 addressHash) {\n@@ -189,19 +189,19 @@ struct CAddressIndexIteratorHeightKey {\n     uint160 hashBytes;\n     int blockHeight;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 25;\n     }\n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata8(s, type);\n-        hashBytes.Serialize(s, nType, nVersion);\n+        hashBytes.Serialize(s);\n         ser_writedata32be(s, blockHeight);\n     }\n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         type = ser_readdata8(s);\n-        hashBytes.Unserialize(s, nType, nVersion);\n+        hashBytes.Unserialize(s);\n         blockHeight = ser_readdata32be(s);\n     }\n "
      },
      {
        "sha": "2ab4a5a9170bfff2cf2927e2afb3ee1f66774253",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -127,7 +127,7 @@ UniValue blockToDeltasJSON(const CBlock& block, const CBlockIndex* blockindex)\n     UniValue deltas(UniValue::VARR);\n \n     for (unsigned int i = 0; i < block.vtx.size(); i++) {\n-        const CTransaction &tx = block.vtx[i];\n+        const CTransaction &tx = *(block.vtx[i]);\n         const uint256 txhash = tx.GetHash();\n \n         UniValue entry(UniValue::VOBJ);\n@@ -711,12 +711,12 @@ UniValue getmempoolentry(const JSONRPCRequest& request)\n     return info;\n }\n \n-UniValue getblockdeltas(const UniValue& params, bool fHelp)\n+UniValue getblockdeltas(const JSONRPCRequest& request)\n {\n-    if (fHelp || params.size() != 1)\n+    if (request.fHelp || request.params.size() != 1)\n         throw runtime_error(\"\");\n \n-    std::string strHash = params[0].get_str();\n+    std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n \n     if (mapBlockIndex.count(hash) == 0)\n@@ -734,9 +734,9 @@ UniValue getblockdeltas(const UniValue& params, bool fHelp)\n     return blockToDeltasJSON(block, pblockindex);\n }\n \n-UniValue getblockhashes(const UniValue& params, bool fHelp)\n+UniValue getblockhashes(const JSONRPCRequest& request)\n {\n-    if (fHelp || params.size() < 2)\n+    if (request.fHelp || request.params.size() < 2)\n         throw runtime_error(\n             \"getblockhashes timestamp\\n\"\n             \"\\nReturns array of hashes of blocks within the timestamp range provided.\\n\"\n@@ -764,15 +764,15 @@ UniValue getblockhashes(const UniValue& params, bool fHelp)\n             + HelpExampleCli(\"getblockhashes\", \"1231614698 1231024505 '{\\\"noOrphans\\\":false, \\\"logicalTimes\\\":true}'\")\n             );\n \n-    unsigned int high = params[0].get_int();\n-    unsigned int low = params[1].get_int();\n+    unsigned int high = request.params[0].get_int();\n+    unsigned int low = request.params[1].get_int();\n     bool fActiveOnly = false;\n     bool fLogicalTS = false;\n \n-    if (params.size() > 2) {\n-        if (params[2].isObject()) {\n-            UniValue noOrphans = find_value(params[2].get_obj(), \"noOrphans\");\n-            UniValue returnLogical = find_value(params[2].get_obj(), \"logicalTimes\");\n+    if (request.params.size() > 2) {\n+        if (request.params[2].isObject()) {\n+            UniValue noOrphans = find_value(request.params[2].get_obj(), \"noOrphans\");\n+            UniValue returnLogical = find_value(request.params[2].get_obj(), \"logicalTimes\");\n \n             if (noOrphans.isBool())\n                 fActiveOnly = noOrphans.get_bool();\n@@ -1697,8 +1697,8 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true,  {} },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true,  {} },\n     { \"blockchain\",         \"getblock\",               &getblock,               true,  {\"blockhash\",\"verbose\"} },\n-    { \"blockchain\",         \"getblockdeltas\",         &getblockdeltas,         false },\n-    { \"blockchain\",         \"getblockhashes\",         &getblockhashes,         true  },\n+    { \"blockchain\",         \"getblockdeltas\",         &getblockdeltas,         false, {} },\n+    { \"blockchain\",         \"getblockhashes\",         &getblockhashes,         true,  {}  },\n     { \"blockchain\",         \"getblockhash\",           &getblockhash,           true,  {\"height\"} },\n     { \"blockchain\",         \"getblockheader\",         &getblockheader,         true,  {\"blockhash\",\"verbose\"} },\n     { \"blockchain\",         \"getchaintips\",           &getchaintips,           true,  {} },"
      },
      {
        "sha": "51006f3826a1539ad4c07167d86d900b4c110674",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -113,15 +113,15 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"setnetworkactive\", 0, \"state\" },\n     { \"getmempoolancestors\", 1, \"verbose\" },\n     { \"getmempooldescendants\", 1, \"verbose\" },\n-    { \"getblockhashes\", 0 },\n-    { \"getblockhashes\", 1 },\n-    { \"getblockhashes\", 2 },\n-    { \"getspentinfo\", 0},\n-    { \"getaddresstxids\", 0},\n-    { \"getaddressbalance\", 0},\n-    { \"getaddressdeltas\", 0},\n-    { \"getaddressutxos\", 0},\n-    { \"getaddressmempool\", 0},\n+    { \"getblockhashes\", 0 , \"high\"},\n+    { \"getblockhashes\", 1, \"low\"},\n+    { \"getblockhashes\", 2, \"options\" },\n+    { \"getspentinfo\", 0, \"txid_index\"},\n+    { \"getaddresstxids\", 0, \"addresses\"},\n+    { \"getaddressbalance\", 0, \"addresses\"},\n+    { \"getaddressdeltas\", 0, \"addresses\"},\n+    { \"getaddressutxos\", 0, \"addresses\"},\n+    { \"getaddressmempool\", 0, \"addresses\"},\n     { \"bumpfee\", 1, \"options\" },\n     { \"logging\", 0, \"include\" },\n     { \"logging\", 1, \"exclude\" },"
      },
      {
        "sha": "487fd95f879caf0f8be3177f4ff68496c4d50d10",
        "filename": "src/rpc/misc.cpp",
        "status": "added",
        "additions": 1071,
        "deletions": 0,
        "changes": 1071,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -0,0 +1,1071 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"base58.h\"\n+#include \"clientversion.h\"\n+#include \"init.h\"\n+#include \"validation.h\"\n+#include \"net.h\"\n+#include \"netbase.h\"\n+#include \"rpc/server.h\"\n+#include \"timedata.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#ifdef ENABLE_WALLET\n+#include \"wallet/wallet.h\"\n+#include \"wallet/walletdb.h\"\n+#endif\n+\n+#include <stdint.h>\n+\n+#include <boost/assign/list_of.hpp>\n+\n+#include <univalue.h>\n+\n+using namespace std;\n+\n+/**\n+ * @note Do not add or change anything in the information returned by this\n+ * method. `getinfo` exists for backwards-compatibility only. It combines\n+ * information from wildly different sources in the program, which is a mess,\n+ * and is thus planned to be deprecated eventually.\n+ *\n+ * Based on the source of the information, new information should be added to:\n+ * - `getblockchaininfo`,\n+ * - `getnetworkinfo` or\n+ * - `getwalletinfo`\n+ *\n+ * Or alternatively, create a specific query method for the information.\n+ **/\n+UniValue getinfo(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 0)\n+        throw runtime_error(\n+            \"getinfo\\n\"\n+            \"\\nDEPRECATED. Returns an object containing various state info.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"version\\\": xxxxx,           (numeric) the server version\\n\"\n+            \"  \\\"protocolversion\\\": xxxxx,   (numeric) the protocol version\\n\"\n+            \"  \\\"walletversion\\\": xxxxx,     (numeric) the wallet version\\n\"\n+            \"  \\\"balance\\\": xxxxxxx,         (numeric) the total bitcoin balance of the wallet\\n\"\n+            \"  \\\"blocks\\\": xxxxxx,           (numeric) the current number of blocks processed in the server\\n\"\n+            \"  \\\"timeoffset\\\": xxxxx,        (numeric) the time offset\\n\"\n+            \"  \\\"connections\\\": xxxxx,       (numeric) the number of connections\\n\"\n+            \"  \\\"proxy\\\": \\\"host:port\\\",     (string, optional) the proxy used by the server\\n\"\n+            \"  \\\"difficulty\\\": xxxxxx,       (numeric) the current difficulty\\n\"\n+            \"  \\\"testnet\\\": true|false,      (boolean) if the server is using testnet or not\\n\"\n+            \"  \\\"keypoololdest\\\": xxxxxx,    (numeric) the timestamp (seconds since Unix epoch) of the oldest pre-generated key in the key pool\\n\"\n+            \"  \\\"keypoolsize\\\": xxxx,        (numeric) how many new keys are pre-generated\\n\"\n+            \"  \\\"unlocked_until\\\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\\n\"\n+            \"  \\\"paytxfee\\\": x.xxxx,         (numeric) the transaction fee set in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"  \\\"relayfee\\\": x.xxxx,         (numeric) minimum relay fee for non-free transactions in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"  \\\"errors\\\": \\\"...\\\"           (string) any error messages\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getinfo\", \"\")\n+            + HelpExampleRpc(\"getinfo\", \"\")\n+        );\n+\n+#ifdef ENABLE_WALLET\n+    LOCK2(cs_main, pwalletMain ? &pwalletMain->cs_wallet : NULL);\n+#else\n+    LOCK(cs_main);\n+#endif\n+\n+    proxyType proxy;\n+    GetProxy(NET_IPV4, proxy);\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"version\", CLIENT_VERSION));\n+    obj.push_back(Pair(\"protocolversion\", PROTOCOL_VERSION));\n+#ifdef ENABLE_WALLET\n+    if (pwalletMain) {\n+        obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n+        obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n+    }\n+#endif\n+    obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n+    obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n+    if(g_connman)\n+        obj.push_back(Pair(\"connections\",   (int)g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL)));\n+    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n+    obj.push_back(Pair(\"testnet\",       Params().NetworkIDString() == CBaseChainParams::TESTNET));\n+#ifdef ENABLE_WALLET\n+    if (pwalletMain) {\n+        obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n+        obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain->GetKeyPoolSize()));\n+    }\n+    if (pwalletMain && pwalletMain->IsCrypted())\n+        obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n+    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n+#endif\n+    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n+    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n+    return obj;\n+}\n+\n+#ifdef ENABLE_WALLET\n+class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n+{\n+public:\n+    UniValue operator()(const CNoDestination &dest) const { return UniValue(UniValue::VOBJ); }\n+\n+    UniValue operator()(const CKeyID &keyID) const {\n+        UniValue obj(UniValue::VOBJ);\n+        CPubKey vchPubKey;\n+        obj.push_back(Pair(\"isscript\", false));\n+        if (pwalletMain && pwalletMain->GetPubKey(keyID, vchPubKey)) {\n+            obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n+            obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n+        }\n+        return obj;\n+    }\n+\n+    UniValue operator()(const CScriptID &scriptID) const {\n+        UniValue obj(UniValue::VOBJ);\n+        CScript subscript;\n+        obj.push_back(Pair(\"isscript\", true));\n+        if (pwalletMain && pwalletMain->GetCScript(scriptID, subscript)) {\n+            std::vector<CTxDestination> addresses;\n+            txnouttype whichType;\n+            int nRequired;\n+            ExtractDestinations(subscript, whichType, addresses, nRequired);\n+            obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n+            obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n+            UniValue a(UniValue::VARR);\n+            BOOST_FOREACH(const CTxDestination& addr, addresses)\n+                a.push_back(CBitcoinAddress(addr).ToString());\n+            obj.push_back(Pair(\"addresses\", a));\n+            if (whichType == TX_MULTISIG)\n+                obj.push_back(Pair(\"sigsrequired\", nRequired));\n+        }\n+        return obj;\n+    }\n+};\n+#endif\n+\n+UniValue validateaddress(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"validateaddress \\\"address\\\"\\n\"\n+            \"\\nReturn information about the given bitcoin address.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"     (string, required) The bitcoin address to validate\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"isvalid\\\" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.\\n\"\n+            \"  \\\"address\\\" : \\\"address\\\", (string) The bitcoin address validated\\n\"\n+            \"  \\\"scriptPubKey\\\" : \\\"hex\\\",       (string) The hex encoded scriptPubKey generated by the address\\n\"\n+            \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n+            \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n+            \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n+            \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string) The hex value of the raw public key\\n\"\n+            \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n+            \"  \\\"account\\\" : \\\"account\\\"         (string) DEPRECATED. The account associated with the address, \\\"\\\" is the default account\\n\"\n+            \"  \\\"timestamp\\\" : timestamp,        (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)\\n\"\n+            \"  \\\"hdkeypath\\\" : \\\"keypath\\\"       (string, optional) The HD keypath if the key is HD and available\\n\"\n+            \"  \\\"hdmasterkeyid\\\" : \\\"<hash160>\\\" (string, optional) The Hash160 of the HD master pubkey\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n+            + HelpExampleRpc(\"validateaddress\", \"\\\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\\\"\")\n+        );\n+\n+#ifdef ENABLE_WALLET\n+    LOCK2(cs_main, pwalletMain ? &pwalletMain->cs_wallet : NULL);\n+#else\n+    LOCK(cs_main);\n+#endif\n+\n+    CBitcoinAddress address(request.params[0].get_str());\n+    bool isValid = address.IsValid();\n+\n+    UniValue ret(UniValue::VOBJ);\n+    ret.push_back(Pair(\"isvalid\", isValid));\n+    if (isValid)\n+    {\n+        CTxDestination dest = address.Get();\n+        string currentAddress = address.ToString();\n+        ret.push_back(Pair(\"address\", currentAddress));\n+\n+        CScript scriptPubKey = GetScriptForDestination(dest);\n+        ret.push_back(Pair(\"scriptPubKey\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n+\n+#ifdef ENABLE_WALLET\n+        isminetype mine = pwalletMain ? IsMine(*pwalletMain, dest) : ISMINE_NO;\n+        ret.push_back(Pair(\"ismine\", (mine & ISMINE_SPENDABLE) ? true : false));\n+        ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true: false));\n+        UniValue detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n+        ret.pushKVs(detail);\n+        if (pwalletMain && pwalletMain->mapAddressBook.count(dest))\n+            ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[dest].name));\n+        CKeyID keyID;\n+        if (pwalletMain) {\n+            const auto& meta = pwalletMain->mapKeyMetadata;\n+            auto it = address.GetKeyID(keyID) ? meta.find(keyID) : meta.end();\n+            if (it == meta.end()) {\n+                it = meta.find(CScriptID(scriptPubKey));\n+            }\n+            if (it != meta.end()) {\n+                ret.push_back(Pair(\"timestamp\", it->second.nCreateTime));\n+                if (!it->second.hdKeypath.empty()) {\n+                    ret.push_back(Pair(\"hdkeypath\", it->second.hdKeypath));\n+                    ret.push_back(Pair(\"hdmasterkeyid\", it->second.hdMasterKeyID.GetHex()));\n+                }\n+            }\n+        }\n+#endif\n+    }\n+    return ret;\n+}\n+\n+/**\n+ * Used by addmultisigaddress / createmultisig:\n+ */\n+CScript _createmultisig_redeemScript(const UniValue& params)\n+{\n+    int nRequired = params[0].get_int();\n+    const UniValue& keys = params[1].get_array();\n+\n+    // Gather public keys\n+    if (nRequired < 1)\n+        throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n+    if ((int)keys.size() < nRequired)\n+        throw runtime_error(\n+            strprintf(\"not enough keys supplied \"\n+                      \"(got %u keys, but need at least %d to redeem)\", keys.size(), nRequired));\n+    if (keys.size() > 16)\n+        throw runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n+    std::vector<CPubKey> pubkeys;\n+    pubkeys.resize(keys.size());\n+    for (unsigned int i = 0; i < keys.size(); i++)\n+    {\n+        const std::string& ks = keys[i].get_str();\n+#ifdef ENABLE_WALLET\n+        // Case 1: Bitcoin address and we have full public key:\n+        CBitcoinAddress address(ks);\n+        if (pwalletMain && address.IsValid())\n+        {\n+            CKeyID keyID;\n+            if (!address.GetKeyID(keyID))\n+                throw runtime_error(\n+                    strprintf(\"%s does not refer to a key\",ks));\n+            CPubKey vchPubKey;\n+            if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n+                throw runtime_error(\n+                    strprintf(\"no full public key for address %s\",ks));\n+            if (!vchPubKey.IsFullyValid())\n+                throw runtime_error(\" Invalid public key: \"+ks);\n+            pubkeys[i] = vchPubKey;\n+        }\n+\n+        // Case 2: hex public key\n+        else\n+#endif\n+        if (IsHex(ks))\n+        {\n+            CPubKey vchPubKey(ParseHex(ks));\n+            if (!vchPubKey.IsFullyValid())\n+                throw runtime_error(\" Invalid public key: \"+ks);\n+            pubkeys[i] = vchPubKey;\n+        }\n+        else\n+        {\n+            throw runtime_error(\" Invalid public key: \"+ks);\n+        }\n+    }\n+    CScript result = GetScriptForMultisig(nRequired, pubkeys);\n+\n+    if (result.size() > MAX_SCRIPT_ELEMENT_SIZE)\n+        throw runtime_error(\n+                strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n+\n+    return result;\n+}\n+\n+UniValue createmultisig(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)\n+    {\n+        string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n+            \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n+            \"It returns a json object with the address and redeemScript.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. nrequired      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n+            \"2. \\\"keys\\\"       (string, required) A json array of keys which are bitcoin addresses or hex-encoded public keys\\n\"\n+            \"     [\\n\"\n+            \"       \\\"key\\\"    (string) bitcoin address or hex-encoded public key\\n\"\n+            \"       ,...\\n\"\n+            \"     ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new multisig address.\\n\"\n+            \"  \\\"redeemScript\\\":\\\"script\\\"       (string) The string value of the hex-encoded redemption script.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate a multisig address from 2 addresses\\n\"\n+            + HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n+        ;\n+        throw runtime_error(msg);\n+    }\n+\n+    // Construct using pay-to-script-hash:\n+    CScript inner = _createmultisig_redeemScript(request.params);\n+    CScriptID innerID(inner);\n+    CBitcoinAddress address(innerID);\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"address\", address.ToString()));\n+    result.push_back(Pair(\"redeemScript\", HexStr(inner.begin(), inner.end())));\n+\n+    return result;\n+}\n+\n+UniValue verifymessage(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 3)\n+        throw runtime_error(\n+            \"verifymessage \\\"address\\\" \\\"signature\\\" \\\"message\\\"\\n\"\n+            \"\\nVerify a signed message\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"         (string, required) The bitcoin address to use for the signature.\\n\"\n+            \"2. \\\"signature\\\"       (string, required) The signature provided by the signer in base 64 encoding (see signmessage).\\n\"\n+            \"3. \\\"message\\\"         (string, required) The message that was signed.\\n\"\n+            \"\\nResult:\\n\"\n+            \"true|false   (boolean) If the signature is verified or not.\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nUnlock the wallet for 30 seconds\\n\"\n+            + HelpExampleCli(\"walletpassphrase\", \"\\\"mypassphrase\\\" 30\") +\n+            \"\\nCreate the signature\\n\"\n+            + HelpExampleCli(\"signmessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"my message\\\"\") +\n+            \"\\nVerify the signature\\n\"\n+            + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"signature\\\" \\\"my message\\\"\") +\n+            \"\\nAs json rpc\\n\"\n+            + HelpExampleRpc(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\", \\\"signature\\\", \\\"my message\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    string strAddress  = request.params[0].get_str();\n+    string strSign     = request.params[1].get_str();\n+    string strMessage  = request.params[2].get_str();\n+\n+    CBitcoinAddress addr(strAddress);\n+    if (!addr.IsValid())\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n+\n+    CKeyID keyID;\n+    if (!addr.GetKeyID(keyID))\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n+\n+    bool fInvalid = false;\n+    vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n+\n+    if (fInvalid)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Malformed base64 encoding\");\n+\n+    CHashWriter ss(SER_GETHASH, 0);\n+    ss << strMessageMagic;\n+    ss << strMessage;\n+\n+    CPubKey pubkey;\n+    if (!pubkey.RecoverCompact(ss.GetHash(), vchSig))\n+        return false;\n+\n+    return (pubkey.GetID() == keyID);\n+}\n+\n+UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 2)\n+        throw runtime_error(\n+            \"signmessagewithprivkey \\\"privkey\\\" \\\"message\\\"\\n\"\n+            \"\\nSign a message with the private key of an address\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"privkey\\\"         (string, required) The private key to sign the message with.\\n\"\n+            \"2. \\\"message\\\"         (string, required) The message to create a signature of.\\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate the signature\\n\"\n+            + HelpExampleCli(\"signmessagewithprivkey\", \"\\\"privkey\\\" \\\"my message\\\"\") +\n+            \"\\nVerify the signature\\n\"\n+            + HelpExampleCli(\"verifymessage\", \"\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\" \\\"signature\\\" \\\"my message\\\"\") +\n+            \"\\nAs json rpc\\n\"\n+            + HelpExampleRpc(\"signmessagewithprivkey\", \"\\\"privkey\\\", \\\"my message\\\"\")\n+        );\n+\n+    string strPrivkey = request.params[0].get_str();\n+    string strMessage = request.params[1].get_str();\n+\n+    CBitcoinSecret vchSecret;\n+    bool fGood = vchSecret.SetString(strPrivkey);\n+    if (!fGood)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n+    CKey key = vchSecret.GetKey();\n+    if (!key.IsValid())\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n+\n+    CHashWriter ss(SER_GETHASH, 0);\n+    ss << strMessageMagic;\n+    ss << strMessage;\n+\n+    vector<unsigned char> vchSig;\n+    if (!key.SignCompact(ss.GetHash(), vchSig))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n+\n+    return EncodeBase64(&vchSig[0], vchSig.size());\n+}\n+\n+UniValue setmocktime(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"setmocktime timestamp\\n\"\n+            \"\\nSet the local time to given timestamp (-regtest only)\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. timestamp  (integer, required) Unix seconds-since-epoch timestamp\\n\"\n+            \"   Pass 0 to go back to using the system time.\"\n+        );\n+\n+    if (!Params().MineBlocksOnDemand())\n+        throw runtime_error(\"setmocktime for regression testing (-regtest mode) only\");\n+\n+    // For now, don't change mocktime if we're in the middle of validation, as\n+    // this could have an effect on mempool time-based eviction, as well as\n+    // IsCurrentForFeeEstimation() and IsInitialBlockDownload().\n+    // TODO: figure out the right way to synchronize around mocktime, and\n+    // ensure all callsites of GetTime() are accessing this safely.\n+    LOCK(cs_main);\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));\n+    SetMockTime(request.params[0].get_int64());\n+\n+    return NullUniValue;\n+}\n+\n+static UniValue RPCLockedMemoryInfo()\n+{\n+    LockedPool::Stats stats = LockedPoolManager::Instance().stats();\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"used\", uint64_t(stats.used)));\n+    obj.push_back(Pair(\"free\", uint64_t(stats.free)));\n+    obj.push_back(Pair(\"total\", uint64_t(stats.total)));\n+    obj.push_back(Pair(\"locked\", uint64_t(stats.locked)));\n+    obj.push_back(Pair(\"chunks_used\", uint64_t(stats.chunks_used)));\n+    obj.push_back(Pair(\"chunks_free\", uint64_t(stats.chunks_free)));\n+    return obj;\n+}\n+\n+UniValue getmemoryinfo(const JSONRPCRequest& request)\n+{\n+    /* Please, avoid using the word \"pool\" here in the RPC interface or help,\n+     * as users will undoubtedly confuse it with the other \"memory pool\"\n+     */\n+    if (request.fHelp || request.params.size() != 0)\n+        throw runtime_error(\n+            \"getmemoryinfo\\n\"\n+            \"Returns an object containing information about memory usage.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"locked\\\": {               (json object) Information about locked memory manager\\n\"\n+            \"    \\\"used\\\": xxxxx,          (numeric) Number of bytes used\\n\"\n+            \"    \\\"free\\\": xxxxx,          (numeric) Number of bytes available in current arenas\\n\"\n+            \"    \\\"total\\\": xxxxxxx,       (numeric) Total number of bytes managed\\n\"\n+            \"    \\\"locked\\\": xxxxxx,       (numeric) Amount of bytes that succeeded locking. If this number is smaller than total, locking pages failed at some point and key data could be swapped to disk.\\n\"\n+            \"    \\\"chunks_used\\\": xxxxx,   (numeric) Number allocated chunks\\n\"\n+            \"    \\\"chunks_free\\\": xxxxx,   (numeric) Number unused chunks\\n\"\n+            \"  }\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getmemoryinfo\", \"\")\n+            + HelpExampleRpc(\"getmemoryinfo\", \"\")\n+        );\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"locked\", RPCLockedMemoryInfo()));\n+    return obj;\n+}\n+\n+UniValue echo(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp)\n+        throw runtime_error(\n+            \"echo|echojson \\\"message\\\" ...\\n\"\n+            \"\\nSimply echo back the input arguments. This command is for testing.\\n\"\n+            \"\\nThe difference between echo and echojson is that echojson has argument conversion enabled in the client-side table in\"\n+            \"bitcoin-cli and the GUI. There is no server-side difference.\"\n+        );\n+\n+    return request.params;\n+}\n+\n+bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)\n+{\n+    if (type == 2) {\n+        address = CBitcoinAddress(CScriptID(hash)).ToString();\n+    } else if (type == 1) {\n+        address = CBitcoinAddress(CKeyID(hash)).ToString();\n+    } else {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool getAddressesFromParams(const UniValue& params, std::vector<std::pair<uint160, int> > &addresses)\n+{\n+    if (params[0].isStr()) {\n+        CBitcoinAddress address(params[0].get_str());\n+        uint160 hashBytes;\n+        int type = 0;\n+        if (!address.GetIndexKey(hashBytes, type)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+        }\n+        addresses.push_back(std::make_pair(hashBytes, type));\n+    } else if (params[0].isObject()) {\n+\n+        UniValue addressValues = find_value(params[0].get_obj(), \"addresses\");\n+        if (!addressValues.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Addresses is expected to be an array\");\n+        }\n+\n+        std::vector<UniValue> values = addressValues.getValues();\n+\n+        for (std::vector<UniValue>::iterator it = values.begin(); it != values.end(); ++it) {\n+\n+            CBitcoinAddress address(it->get_str());\n+            uint160 hashBytes;\n+            int type = 0;\n+            if (!address.GetIndexKey(hashBytes, type)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+            }\n+            addresses.push_back(std::make_pair(hashBytes, type));\n+        }\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    return true;\n+}\n+\n+bool heightSort(std::pair<CAddressUnspentKey, CAddressUnspentValue> a,\n+                std::pair<CAddressUnspentKey, CAddressUnspentValue> b) {\n+    return a.second.blockHeight < b.second.blockHeight;\n+}\n+\n+bool timestampSort(std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> a,\n+                   std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> b) {\n+    return a.second.time < b.second.time;\n+}\n+\n+UniValue getaddressmempool(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressmempool\\n\"\n+            \"\\nReturns all mempool deltas for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"timestamp\\\"  (number) The time the transaction entered the mempool (seconds)\\n\"\n+            \"    \\\"prevtxid\\\"  (string) The previous txid (if spending)\\n\"\n+            \"    \\\"prevout\\\"  (string) The previous transaction output index (if spending)\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressmempool\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressmempool\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(request.params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > indexes;\n+\n+    if (!mempool.getAddressIndex(addresses, indexes)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+    }\n+\n+    std::sort(indexes.begin(), indexes.end(), timestampSort);\n+\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> >::iterator it = indexes.begin();\n+         it != indexes.end(); it++) {\n+\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.addressBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"address\", address));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"satoshis\", it->second.amount));\n+        delta.push_back(Pair(\"timestamp\", it->second.time));\n+        if (it->second.amount < 0) {\n+            delta.push_back(Pair(\"prevtxid\", it->second.prevhash.GetHex()));\n+            delta.push_back(Pair(\"prevout\", (int)it->second.prevout));\n+        }\n+        result.push_back(delta);\n+    }\n+\n+    return result;\n+}\n+\n+UniValue getaddressutxos(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressutxos\\n\"\n+            \"\\nReturns all unspent outputs for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ],\\n\"\n+            \"  \\\"chainInfo\\\"  (boolean) Include chain info with results\\n\"\n+            \"}\\n\"\n+            \"\\nResult\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\"  (string) The address base58check encoded\\n\"\n+            \"    \\\"txid\\\"  (string) The output txid\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"outputIndex\\\"  (number) The output index\\n\"\n+            \"    \\\"script\\\"  (strin) The script hex encoded\\n\"\n+            \"    \\\"satoshis\\\"  (number) The number of satoshis of the output\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressutxos\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressutxos\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+            );\n+\n+    bool includeChainInfo = false;\n+    if (request.params[0].isObject()) {\n+        UniValue chainInfo = find_value(request.params[0].get_obj(), \"chainInfo\");\n+        if (chainInfo.isBool()) {\n+            includeChainInfo = chainInfo.get_bool();\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(request.params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > unspentOutputs;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressUnspent((*it).first, (*it).second, unspentOutputs)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    std::sort(unspentOutputs.begin(), unspentOutputs.end(), heightSort);\n+\n+    UniValue utxos(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=unspentOutputs.begin(); it!=unspentOutputs.end(); it++) {\n+        UniValue output(UniValue::VOBJ);\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        output.push_back(Pair(\"address\", address));\n+        output.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        output.push_back(Pair(\"outputIndex\", (int)it->first.index));\n+        output.push_back(Pair(\"script\", HexStr(it->second.script.begin(), it->second.script.end())));\n+        output.push_back(Pair(\"satoshis\", it->second.satoshis));\n+        output.push_back(Pair(\"height\", it->second.blockHeight));\n+        utxos.push_back(output);\n+    }\n+\n+    if (includeChainInfo) {\n+        UniValue result(UniValue::VOBJ);\n+        result.push_back(Pair(\"utxos\", utxos));\n+\n+        LOCK(cs_main);\n+        result.push_back(Pair(\"hash\", chainActive.Tip()->GetBlockHash().GetHex()));\n+        result.push_back(Pair(\"height\", (int)chainActive.Height()));\n+        return result;\n+    } else {\n+        return utxos;\n+    }\n+}\n+\n+UniValue getaddressdeltas(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1 || !request.params[0].isObject())\n+        throw runtime_error(\n+            \"getaddressdeltas\\n\"\n+            \"\\nReturns all changes for an address (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"  \\\"chainInfo\\\" (boolean) Include chain info in results, only applies if start and end specified\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"satoshis\\\"  (number) The difference of satoshis\\n\"\n+            \"    \\\"txid\\\"  (string) The related txid\\n\"\n+            \"    \\\"index\\\"  (number) The related input or output index\\n\"\n+            \"    \\\"height\\\"  (number) The block height\\n\"\n+            \"    \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"  }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressdeltas\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressdeltas\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+\n+    UniValue startValue = find_value(request.params[0].get_obj(), \"start\");\n+    UniValue endValue = find_value(request.params[0].get_obj(), \"end\");\n+\n+    UniValue chainInfo = find_value(request.params[0].get_obj(), \"chainInfo\");\n+    bool includeChainInfo = false;\n+    if (chainInfo.isBool()) {\n+        includeChainInfo = chainInfo.get_bool();\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+\n+    if (startValue.isNum() && endValue.isNum()) {\n+        start = startValue.get_int();\n+        end = endValue.get_int();\n+        if (start <= 0 || end <= 0) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start and end is expected to be greater than zero\");\n+        }\n+        if (end < start) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"End value is expected to be greater than start\");\n+        }\n+    }\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(request.params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    UniValue deltas(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        std::string address;\n+        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unknown address type\");\n+        }\n+\n+        UniValue delta(UniValue::VOBJ);\n+        delta.push_back(Pair(\"satoshis\", it->second));\n+        delta.push_back(Pair(\"txid\", it->first.txhash.GetHex()));\n+        delta.push_back(Pair(\"index\", (int)it->first.index));\n+        delta.push_back(Pair(\"blockindex\", (int)it->first.txindex));\n+        delta.push_back(Pair(\"height\", it->first.blockHeight));\n+        delta.push_back(Pair(\"address\", address));\n+        deltas.push_back(delta);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    if (includeChainInfo && start > 0 && end > 0) {\n+        LOCK(cs_main);\n+\n+        if (start > chainActive.Height() || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Start or end is outside chain range\");\n+        }\n+\n+        CBlockIndex* startIndex = chainActive[start];\n+        CBlockIndex* endIndex = chainActive[end];\n+\n+        UniValue startInfo(UniValue::VOBJ);\n+        UniValue endInfo(UniValue::VOBJ);\n+\n+        startInfo.push_back(Pair(\"hash\", startIndex->GetBlockHash().GetHex()));\n+        startInfo.push_back(Pair(\"height\", start));\n+\n+        endInfo.push_back(Pair(\"hash\", endIndex->GetBlockHash().GetHex()));\n+        endInfo.push_back(Pair(\"height\", end));\n+\n+        result.push_back(Pair(\"deltas\", deltas));\n+        result.push_back(Pair(\"start\", startInfo));\n+        result.push_back(Pair(\"end\", endInfo));\n+\n+        return result;\n+    } else {\n+        return deltas;\n+    }\n+}\n+\n+UniValue getaddressbalance(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"getaddressbalance\\n\"\n+            \"\\nReturns the balance for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"balance\\\"  (string) The current balance in satoshis\\n\"\n+            \"  \\\"received\\\"  (string) The total number of satoshis received (including change)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddressbalance\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddressbalance\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(request.params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+        }\n+    }\n+\n+    CAmount balance = 0;\n+    CAmount received = 0;\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        if (it->second > 0) {\n+            received += it->second;\n+        }\n+        balance += it->second;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"balance\", balance));\n+    result.push_back(Pair(\"received\", received));\n+\n+    return result;\n+\n+}\n+\n+UniValue getaddresstxids(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"getaddresstxids\\n\"\n+            \"\\nReturns the txids for an address(es) (requires addressindex to be enabled).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"addresses\\\"\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"  (string) The base58check encoded address\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"start\\\" (number) The start block height\\n\"\n+            \"  \\\"end\\\" (number) The end block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  \\\"transactionid\\\"  (string) The transaction id\\n\"\n+            \"  ,...\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getaddresstxids\", \"'{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}'\")\n+            + HelpExampleRpc(\"getaddresstxids\", \"{\\\"addresses\\\": [\\\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\\\"]}\")\n+        );\n+\n+    std::vector<std::pair<uint160, int> > addresses;\n+\n+    if (!getAddressesFromParams(request.params, addresses)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    int start = 0;\n+    int end = 0;\n+    if (request.params[0].isObject()) {\n+        UniValue startValue = find_value(request.params[0].get_obj(), \"start\");\n+        UniValue endValue = find_value(request.params[0].get_obj(), \"end\");\n+        if (startValue.isNum() && endValue.isNum()) {\n+            start = startValue.get_int();\n+            end = endValue.get_int();\n+        }\n+    }\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+\n+    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {\n+        if (start > 0 && end > 0) {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        } else {\n+            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available for address\");\n+            }\n+        }\n+    }\n+\n+    std::set<std::pair<int, std::string> > txids;\n+    UniValue result(UniValue::VARR);\n+\n+    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {\n+        int height = it->first.blockHeight;\n+        std::string txid = it->first.txhash.GetHex();\n+\n+        if (addresses.size() > 1) {\n+            txids.insert(std::make_pair(height, txid));\n+        } else {\n+            if (txids.insert(std::make_pair(height, txid)).second) {\n+                result.push_back(txid);\n+            }\n+        }\n+    }\n+\n+    if (addresses.size() > 1) {\n+        for (std::set<std::pair<int, std::string> >::const_iterator it=txids.begin(); it!=txids.end(); it++) {\n+            result.push_back(it->second);\n+        }\n+    }\n+\n+    return result;\n+\n+}\n+\n+UniValue getspentinfo(const JSONRPCRequest& request)\n+{\n+\n+    if (request.fHelp || request.params.size() != 1 || !request.params[0].isObject())\n+        throw runtime_error(\n+            \"getspentinfo\\n\"\n+            \"\\nReturns the txid and index where an output is spent.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\" (string) The hex string of the txid\\n\"\n+            \"  \\\"index\\\" (number) The start block height\\n\"\n+            \"}\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\"  (string) The transaction id\\n\"\n+            \"  \\\"index\\\"  (number) The spending input index\\n\"\n+            \"  ,...\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getspentinfo\", \"'{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}'\")\n+            + HelpExampleRpc(\"getspentinfo\", \"{\\\"txid\\\": \\\"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\\\", \\\"index\\\": 0}\")\n+        );\n+\n+    UniValue txidValue = find_value(request.params[0].get_obj(), \"txid\");\n+    UniValue indexValue = find_value(request.params[0].get_obj(), \"index\");\n+\n+    if (!txidValue.isStr() || !indexValue.isNum()) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid txid or index\");\n+    }\n+\n+    uint256 txid = ParseHashV(txidValue, \"txid\");\n+    int outputIndex = indexValue.get_int();\n+\n+    CSpentIndexKey key(txid, outputIndex);\n+    CSpentIndexValue value;\n+\n+    if (!GetSpentIndex(key, value)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unable to get spent info\");\n+    }\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"txid\", value.txid.GetHex()));\n+    obj.push_back(Pair(\"index\", (int)value.inputIndex));\n+    obj.push_back(Pair(\"height\", value.blockHeight));\n+\n+    return obj;\n+}\n+\n+static const CRPCCommand commands[] =\n+{ //  category              name                      actor (function)         okSafeMode\n+  //  --------------------- ------------------------  -----------------------  ----------\n+    { \"control\",            \"getinfo\",                &getinfo,                true,  {} }, /* uses wallet if enabled */\n+    { \"control\",            \"getmemoryinfo\",          &getmemoryinfo,          true,  {} },\n+    { \"util\",               \"validateaddress\",        &validateaddress,        true,  {\"address\"} }, /* uses wallet if enabled */\n+    { \"util\",               \"createmultisig\",         &createmultisig,         true,  {\"nrequired\",\"keys\"} },\n+    { \"util\",               \"verifymessage\",          &verifymessage,          true,  {\"address\",\"signature\",\"message\"} },\n+    { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true,  {\"privkey\",\"message\"} },\n+\n+    /* Address index */\n+    { \"addressindex\",       \"getaddressmempool\",      &getaddressmempool,      true,  {}},\n+    { \"addressindex\",       \"getaddressutxos\",        &getaddressutxos,        false, {} },\n+    { \"addressindex\",       \"getaddressdeltas\",       &getaddressdeltas,       false, {} },\n+    { \"addressindex\",       \"getaddresstxids\",        &getaddresstxids,        false, {} },\n+    { \"addressindex\",       \"getaddressbalance\",      &getaddressbalance,      false, {} },\n+\n+    /* Blockchain */\n+    { \"blockchain\",         \"getspentinfo\",           &getspentinfo,           false, {} },\n+\n+    /* Not shown in help */\n+    { \"hidden\",             \"setmocktime\",            &setmocktime,            true,  {\"timestamp\"}},\n+    { \"hidden\",             \"echo\",                   &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n+    { \"hidden\",             \"echojson\",               &echo,                  true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n+};\n+\n+void RegisterMiscRPCCommands(CRPCTable &t)\n+{\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n+        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n+}\n+"
      },
      {
        "sha": "b48a1b7c8d229aa76259046e138992b5399d3823",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -74,11 +74,11 @@ void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, UniValue&\n             }\n \n         }\n-        if (!tx.wit.IsNull()) {\n-            if (!tx.wit.vtxinwit[i].IsNull()) {\n+        if (tx.HasWitness()) {\n+            if (!tx.vin[i].scriptWitness.IsNull()) {\n                 UniValue txinwitness(UniValue::VARR);\n-                for (unsigned int j = 0; j < tx.wit.vtxinwit[i].scriptWitness.stack.size(); j++) {\n-                    std::vector<unsigned char> item = tx.wit.vtxinwit[i].scriptWitness.stack[j];\n+                for (unsigned int j = 0; j < tx.vin[i].scriptWitness.stack.size(); j++) {\n+                    std::vector<unsigned char> item = tx.vin[i].scriptWitness.stack[j];\n                     txinwitness.push_back(HexStr(item.begin(), item.end()));\n                 }\n                 in.push_back(Pair(\"txinwitness\", txinwitness));\n@@ -248,7 +248,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n         }\n     }\n \n-    CTransaction tx;\n+    CTransactionRef tx;\n \n     uint256 hashBlock;\n     int nHeight = 0;"
      },
      {
        "sha": "7b9da423bcd9087d60c8f0bae583130814883b55",
        "filename": "src/spentindex.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/spentindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/spentindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/spentindex.h?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -16,7 +16,7 @@ struct CSpentIndexKey {\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(txid);\n         READWRITE(outputIndex);\n     }\n@@ -48,7 +48,7 @@ struct CSpentIndexValue {\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(txid);\n         READWRITE(inputIndex);\n         READWRITE(blockHeight);"
      },
      {
        "sha": "46264e40a28b6ed5857168bde8e7e2642057825f",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -48,7 +48,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_compression)\n     // Perform tests both with compression and without\n     for (int i = 0; i < 2; i++) {\n         bool compression = (bool)i;\n-        path ph = temp_directory_path() / unique_path();\n+        boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, false, compression);\n         char key = 'k';\n         uint256 in = GetRandHash();\n@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_compression)\n \n BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_64)\n {\n-    path ph = temp_directory_path() / unique_path();\n+    boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n     CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 64);\n     char key = 'k';\n     uint256 in = GetRandHash();\n@@ -75,7 +75,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_64)\n \n BOOST_AUTO_TEST_CASE(dbwrapper_maxopenfiles_1000)\n {\n-    path ph = temp_directory_path() / unique_path();\n+    boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n     CDBWrapper dbw(ph, (1 << 20), true, false, false, false, 1000);\n     char key = 'k';\n     uint256 in = GetRandHash();"
      },
      {
        "sha": "cb182a71358b983746863b69353e83341c6da741",
        "filename": "src/timestampindex.h",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/timestampindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/timestampindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timestampindex.h?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -11,15 +11,15 @@\n struct CTimestampIndexIteratorKey {\n     unsigned int timestamp;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 4;\n     }\n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata32be(s, timestamp);\n     }\n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         timestamp = ser_readdata32be(s);\n     }\n \n@@ -40,18 +40,18 @@ struct CTimestampIndexKey {\n     unsigned int timestamp;\n     uint256 blockHash;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 36;\n     }\n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata32be(s, timestamp);\n-        blockHash.Serialize(s, nType, nVersion);\n+        blockHash.Serialize(s);\n     }\n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         timestamp = ser_readdata32be(s);\n-        blockHash.Unserialize(s, nType, nVersion);\n+        blockHash.Unserialize(s);\n     }\n \n     CTimestampIndexKey(unsigned int time, uint256 hash) {\n@@ -72,18 +72,18 @@ struct CTimestampIndexKey {\n struct CTimestampBlockIndexKey {\n     uint256 blockHash;\n \n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 32;\n     }\n \n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n-        blockHash.Serialize(s, nType, nVersion);\n+    void Serialize(Stream& s) const {\n+        blockHash.Serialize(s);\n     }\n \n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n-        blockHash.Unserialize(s, nType, nVersion);\n+    void Unserialize(Stream& s) {\n+        blockHash.Unserialize(s);\n     }\n \n     CTimestampBlockIndexKey(uint256 hash) {\n@@ -101,17 +101,17 @@ struct CTimestampBlockIndexKey {\n \n struct CTimestampBlockIndexValue {\n     unsigned int ltimestamp;\n-    size_t GetSerializeSize(int nType, int nVersion) const {\n+    size_t GetSerializeSize() const {\n         return 4;\n     }\n \n     template<typename Stream>\n-    void Serialize(Stream& s, int nType, int nVersion) const {\n+    void Serialize(Stream& s) const {\n         ser_writedata32be(s, ltimestamp);\n     }\n \n     template<typename Stream>\n-    void Unserialize(Stream& s, int nType, int nVersion) {\n+    void Unserialize(Stream& s) {\n         ltimestamp = ser_readdata32be(s);\n     }\n "
      },
      {
        "sha": "28194738c5141d1dbd28e3fc297ffda704af898e",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 15,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -9,6 +9,7 @@\n #include \"hash.h\"\n #include \"pow.h\"\n #include \"uint256.h\"\n+#include \"validation.h\"\n \n #include <stdint.h>\n \n@@ -163,16 +164,16 @@ bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos>\n }\n \n bool CBlockTreeDB::ReadSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value) {\n-    return Read(make_pair(DB_SPENTINDEX, key), value);\n+    return Read(std::make_pair(DB_SPENTINDEX, key), value);\n }\n \n bool CBlockTreeDB::UpdateSpentIndex(const std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> >&vect) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<CSpentIndexKey,CSpentIndexValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n         if (it->second.IsNull()) {\n-            batch.Erase(make_pair(DB_SPENTINDEX, it->first));\n+            batch.Erase(std::make_pair(DB_SPENTINDEX, it->first));\n         } else {\n-            batch.Write(make_pair(DB_SPENTINDEX, it->first), it->second);\n+            batch.Write(std::make_pair(DB_SPENTINDEX, it->first), it->second);\n         }\n     }\n     return WriteBatch(batch);\n@@ -182,9 +183,9 @@ bool CBlockTreeDB::UpdateAddressUnspentIndex(const std::vector<std::pair<CAddres\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=vect.begin(); it!=vect.end(); it++) {\n         if (it->second.IsNull()) {\n-            batch.Erase(make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n+            batch.Erase(std::make_pair(DB_ADDRESSUNSPENTINDEX, it->first));\n         } else {\n-            batch.Write(make_pair(DB_ADDRESSUNSPENTINDEX, it->first), it->second);\n+            batch.Write(std::make_pair(DB_ADDRESSUNSPENTINDEX, it->first), it->second);\n         }\n     }\n     return WriteBatch(batch);\n@@ -195,15 +196,15 @@ bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n \n     boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n \n-    pcursor->Seek(make_pair(DB_ADDRESSUNSPENTINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+    pcursor->Seek(std::make_pair(DB_ADDRESSUNSPENTINDEX, CAddressIndexIteratorKey(type, addressHash)));\n \n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n         std::pair<char,CAddressUnspentKey> key;\n         if (pcursor->GetKey(key) && key.first == DB_ADDRESSUNSPENTINDEX && key.second.hashBytes == addressHash) {\n             CAddressUnspentValue nValue;\n             if (pcursor->GetValue(nValue)) {\n-                unspentOutputs.push_back(make_pair(key.second, nValue));\n+                unspentOutputs.push_back(std::make_pair(key.second, nValue));\n                 pcursor->Next();\n             } else {\n                 return error(\"failed to get address unspent value\");\n@@ -219,14 +220,14 @@ bool CBlockTreeDB::ReadAddressUnspentIndex(uint160 addressHash, int type,\n bool CBlockTreeDB::WriteAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n-        batch.Write(make_pair(DB_ADDRESSINDEX, it->first), it->second);\n+        batch.Write(std::make_pair(DB_ADDRESSINDEX, it->first), it->second);\n     return WriteBatch(batch);\n }\n \n bool CBlockTreeDB::EraseAddressIndex(const std::vector<std::pair<CAddressIndexKey, CAmount > >&vect) {\n     CDBBatch batch(*this);\n     for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n-        batch.Erase(make_pair(DB_ADDRESSINDEX, it->first));\n+        batch.Erase(std::make_pair(DB_ADDRESSINDEX, it->first));\n     return WriteBatch(batch);\n }\n \n@@ -237,9 +238,9 @@ bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n     boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n \n     if (start > 0 && end > 0) {\n-        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorHeightKey(type, addressHash, start)));\n+        pcursor->Seek(std::make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorHeightKey(type, addressHash, start)));\n     } else {\n-        pcursor->Seek(make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorKey(type, addressHash)));\n+        pcursor->Seek(std::make_pair(DB_ADDRESSINDEX, CAddressIndexIteratorKey(type, addressHash)));\n     }\n \n     while (pcursor->Valid()) {\n@@ -251,7 +252,7 @@ bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n             }\n             CAmount nValue;\n             if (pcursor->GetValue(nValue)) {\n-                addressIndex.push_back(make_pair(key.second, nValue));\n+                addressIndex.push_back(std::make_pair(key.second, nValue));\n                 pcursor->Next();\n             } else {\n                 return error(\"failed to get address index value\");\n@@ -266,15 +267,15 @@ bool CBlockTreeDB::ReadAddressIndex(uint160 addressHash, int type,\n \n bool CBlockTreeDB::WriteTimestampIndex(const CTimestampIndexKey &timestampIndex) {\n     CDBBatch batch(*this);\n-    batch.Write(make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n+    batch.Write(std::make_pair(DB_TIMESTAMPINDEX, timestampIndex), 0);\n     return WriteBatch(batch);\n }\n \n bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned int &low, const bool fActiveOnly, std::vector<std::pair<uint256, unsigned int> > &hashes) {\n \n     boost::scoped_ptr<CDBIterator> pcursor(NewIterator());\n \n-    pcursor->Seek(make_pair(DB_TIMESTAMPINDEX, CTimestampIndexIteratorKey(low)));\n+    pcursor->Seek(std::make_pair(DB_TIMESTAMPINDEX, CTimestampIndexIteratorKey(low)));\n \n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n@@ -299,7 +300,7 @@ bool CBlockTreeDB::ReadTimestampIndex(const unsigned int &high, const unsigned i\n \n bool CBlockTreeDB::WriteTimestampBlockIndex(const CTimestampBlockIndexKey &blockhashIndex, const CTimestampBlockIndexValue &logicalts) {\n     CDBBatch batch(*this);\n-    batch.Write(make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n+    batch.Write(std::make_pair(DB_BLOCKHASHINDEX, blockhashIndex), logicalts);\n     return WriteBatch(batch);\n }\n "
      },
      {
        "sha": "7fee3efb2bbc045a8da636628ac93337edec2a86",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -6,7 +6,6 @@\n #ifndef BITCOIN_TXDB_H\n #define BITCOIN_TXDB_H\n \n-#include \"main.h\"\n #include \"coins.h\"\n #include \"dbwrapper.h\"\n #include \"chain.h\""
      },
      {
        "sha": "8532ea25d8324415076df9094859340869cd371a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -375,7 +375,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     // all the appropriate checks.\n     LOCK(cs);\n     indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n-    mapLinks.insert(make_pair(newit, TxLinks()));\n+    mapLinks.insert(std::make_pair(newit, TxLinks()));\n \n     // Update transaction for any feeDelta created by PrioritiseTransaction\n     // TODO: refactor so that the fee delta is calculated before inserting\n@@ -437,37 +437,37 @@ void CTxMemPool::addAddressIndex(const CTxMemPoolEntry &entry, const CCoinsViewC\n         const CTxIn input = tx.vin[j];\n         const CTxOut &prevout = view.GetOutputFor(input);\n         if (prevout.scriptPubKey.IsPayToScriptHash()) {\n-            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+            std::vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n             CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, j, 1);\n             CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n-            mapAddress.insert(make_pair(key, delta));\n+            mapAddress.insert(std::make_pair(key, delta));\n             inserted.push_back(key);\n         } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n-            vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+            std::vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n             CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, j, 1);\n             CMempoolAddressDelta delta(entry.GetTime(), prevout.nValue * -1, input.prevout.hash, input.prevout.n);\n-            mapAddress.insert(make_pair(key, delta));\n+            mapAddress.insert(std::make_pair(key, delta));\n             inserted.push_back(key);\n         }\n     }\n \n     for (unsigned int k = 0; k < tx.vout.size(); k++) {\n         const CTxOut &out = tx.vout[k];\n         if (out.scriptPubKey.IsPayToScriptHash()) {\n-            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+            std::vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n             CMempoolAddressDeltaKey key(2, uint160(hashBytes), txhash, k, 0);\n-            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            mapAddress.insert(std::make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n             inserted.push_back(key);\n         } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n-            vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+            std::vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n             std::pair<addressDeltaMap::iterator,bool> ret;\n             CMempoolAddressDeltaKey key(1, uint160(hashBytes), txhash, k, 0);\n-            mapAddress.insert(make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n+            mapAddress.insert(std::make_pair(key, CMempoolAddressDelta(entry.GetTime(), out.nValue)));\n             inserted.push_back(key);\n         }\n     }\n \n-    mapAddressInserted.insert(make_pair(txhash, inserted));\n+    mapAddressInserted.insert(std::make_pair(txhash, inserted));\n }\n \n bool CTxMemPool::getAddressIndex(std::vector<std::pair<uint160, int> > &addresses,\n@@ -515,10 +515,10 @@ void CTxMemPool::addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCac\n         int addressType;\n \n         if (prevout.scriptPubKey.IsPayToScriptHash()) {\n-            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+            addressHash = uint160(std::vector<unsigned char> (prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n             addressType = 2;\n         } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n-            addressHash = uint160(vector<unsigned char> (prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+            addressHash = uint160(std::vector<unsigned char> (prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n             addressType = 1;\n         } else {\n             addressHash.SetNull();\n@@ -528,12 +528,12 @@ void CTxMemPool::addSpentIndex(const CTxMemPoolEntry &entry, const CCoinsViewCac\n         CSpentIndexKey key = CSpentIndexKey(input.prevout.hash, input.prevout.n);\n         CSpentIndexValue value = CSpentIndexValue(txhash, j, -1, prevout.nValue, addressType, addressHash);\n \n-        mapSpent.insert(make_pair(key, value));\n+        mapSpent.insert(std::make_pair(key, value));\n         inserted.push_back(key);\n \n     }\n \n-    mapSpentInserted.insert(make_pair(txhash, inserted));\n+    mapSpentInserted.insert(std::make_pair(txhash, inserted));\n }\n \n bool CTxMemPool::getSpentIndex(CSpentIndexKey &key, CSpentIndexValue &value)"
      },
      {
        "sha": "bab4aa078a3f63638409a79014f9bdb299a865c2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 24,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -1642,22 +1642,22 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n                 const CTxOut &out = tx.vout[k];\n \n                 if (out.scriptPubKey.IsPayToScriptHash()) {\n-                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+                    std::vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n \n                     // undo receiving activity\n-                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+                    addressIndex.push_back(std::make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n \n                     // undo unspent index\n-                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+                    addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(2, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n \n                 } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n-                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+                    std::vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n \n                     // undo receiving activity\n-                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n+                    addressIndex.push_back(std::make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, k, false), out.nValue));\n \n                     // undo unspent index\n-                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n+                    addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(1, uint160(hashBytes), hash, k), CAddressUnspentValue()));\n \n                 } else {\n                     continue;\n@@ -1703,29 +1703,29 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n \n                 if (fSpentIndex) {\n                     // undo and delete the spent index\n-                    spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue()));\n+                    spentIndex.push_back(std::make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue()));\n                 }\n \n                 if (fAddressIndex) {\n                     const CTxOut &prevout = view.GetOutputFor(tx.vin[j]);\n                     if (prevout.scriptPubKey.IsPayToScriptHash()) {\n-                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n+                        std::vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22);\n \n                         // undo spending activity\n-                        addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+                        addressIndex.push_back(std::make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n \n                         // restore unspent index\n-                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+                        addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(2, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n \n \n                     } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n-                        vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n+                        std::vector<unsigned char> hashBytes(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23);\n \n                         // undo spending activity\n-                        addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n+                        addressIndex.push_back(std::make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, hash, j, true), prevout.nValue * -1));\n \n                         // restore unspent index\n-                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n+                        addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(1, uint160(hashBytes), input.prevout.hash, input.prevout.n), CAddressUnspentValue(prevout.nValue, prevout.scriptPubKey, undo.nHeight)));\n \n                     } else {\n                         continue;\n@@ -1977,6 +1977,11 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n     std::vector<PrecomputedTransactionData> txdata;\n     txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated\n+\n+    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;\n+    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > addressUnspentIndex;\n+    std::vector<std::pair<CSpentIndexKey, CSpentIndexValue> > spentIndex;\n+\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = *(block.vtx[i]);\n@@ -2013,10 +2018,10 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n                     int addressType;\n \n                     if (prevout.scriptPubKey.IsPayToScriptHash()) {\n-                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n+                        hashBytes = uint160(std::vector <unsigned char>(prevout.scriptPubKey.begin()+2, prevout.scriptPubKey.begin()+22));\n                         addressType = 2;\n                     } else if (prevout.scriptPubKey.IsPayToPublicKeyHash()) {\n-                        hashBytes = uint160(vector <unsigned char>(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n+                        hashBytes = uint160(std::vector <unsigned char>(prevout.scriptPubKey.begin()+3, prevout.scriptPubKey.begin()+23));\n                         addressType = 1;\n                     } else {\n                         hashBytes.SetNull();\n@@ -2025,16 +2030,16 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n                     if (fAddressIndex && addressType > 0) {\n                         // record spending activity\n-                        addressIndex.push_back(make_pair(CAddressIndexKey(addressType, hashBytes, pindex->nHeight, i, txhash, j, true), prevout.nValue * -1));\n+                        addressIndex.push_back(std::make_pair(CAddressIndexKey(addressType, hashBytes, pindex->nHeight, i, txhash, j, true), prevout.nValue * -1));\n \n                         // remove address from unspent index\n-                        addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(addressType, hashBytes, input.prevout.hash, input.prevout.n), CAddressUnspentValue()));\n+                        addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(addressType, hashBytes, input.prevout.hash, input.prevout.n), CAddressUnspentValue()));\n                     }\n \n                     if (fSpentIndex) {\n                         // add the spent index to determine the txid and input that spent an output\n                         // and to find the amount and address from an input\n-                        spentIndex.push_back(make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue(txhash, j, pindex->nHeight, prevout.nValue, addressType, hashBytes)));\n+                        spentIndex.push_back(std::make_pair(CSpentIndexKey(input.prevout.hash, input.prevout.n), CSpentIndexValue(txhash, j, pindex->nHeight, prevout.nValue, addressType, hashBytes)));\n                     }\n                 }\n \n@@ -2068,22 +2073,22 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n                 const CTxOut &out = tx.vout[k];\n \n                 if (out.scriptPubKey.IsPayToScriptHash()) {\n-                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n+                    std::vector<unsigned char> hashBytes(out.scriptPubKey.begin()+2, out.scriptPubKey.begin()+22);\n \n                     // record receiving activity\n-                    addressIndex.push_back(make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+                    addressIndex.push_back(std::make_pair(CAddressIndexKey(2, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n \n                     // record unspent output\n-                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(2, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+                    addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(2, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n \n                 } else if (out.scriptPubKey.IsPayToPublicKeyHash()) {\n-                    vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n+                    std::vector<unsigned char> hashBytes(out.scriptPubKey.begin()+3, out.scriptPubKey.begin()+23);\n \n                     // record receiving activity\n-                    addressIndex.push_back(make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n+                    addressIndex.push_back(std::make_pair(CAddressIndexKey(1, uint160(hashBytes), pindex->nHeight, i, txhash, k, false), out.nValue));\n \n                     // record unspent output\n-                    addressUnspentIndex.push_back(make_pair(CAddressUnspentKey(1, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n+                    addressUnspentIndex.push_back(std::make_pair(CAddressUnspentKey(1, uint160(hashBytes), txhash, k), CAddressUnspentValue(out.nValue, out.scriptPubKey, pindex->nHeight)));\n \n                 } else {\n                     continue;"
      },
      {
        "sha": "49012ccd06ef96b66974840311788582238d0081",
        "filename": "test/functional/txindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/test/functional/txindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25/test/functional/txindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/txindex.py?ref=7a4ad0c7104f3a3d341b4c8c3589b5cacff96c25",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         scriptPubKey = CScript([OP_DUP, OP_HASH160, addressHash, OP_EQUALVERIFY, OP_CHECKSIG])\n         unspent = self.nodes[0].listunspent()\n         tx = CTransaction()\n-        amount = int(unspent[0][\"amount\"] * 100000000)\n+        amount = int(unspent[0][\"amount\"] * 10000000)\n         tx.vin = [CTxIn(COutPoint(int(unspent[0][\"txid\"], 16), unspent[0][\"vout\"]))]\n         tx.vout = [CTxOut(amount, scriptPubKey)]\n         tx.rehash()"
      }
    ]
  }
]