[
  {
    "sha": "b77dfdc9e36e308aa806d63aa3b5628971789d5a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzdkZmRjOWUzNmUzMDhhYTgwNmQ2M2FhM2I1NjI4OTcxNzg5ZDVh",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-01-16T14:52:37Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-01-23T15:05:00Z"
      },
      "message": "Typesafe strprintf/error/LogPrint functions\n\nSwitch to tinyformat-based formatting.\n\nTinyformat is a typesafe drop-in replacement for C99 printf functions:\nhttps://github.com/c42f/tinyformat",
      "tree": {
        "sha": "555894b6364e76c4a5c3d7962f6991de1f5588f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/555894b6364e76c4a5c3d7962f6991de1f5588f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b77dfdc9e36e308aa806d63aa3b5628971789d5a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b77dfdc9e36e308aa806d63aa3b5628971789d5a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b77dfdc9e36e308aa806d63aa3b5628971789d5a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b77dfdc9e36e308aa806d63aa3b5628971789d5a/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "53e9d3aa44e24fecd2d58984baff3cb4af23c12e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/53e9d3aa44e24fecd2d58984baff3cb4af23c12e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/53e9d3aa44e24fecd2d58984baff3cb4af23c12e"
      }
    ],
    "stats": {
      "total": 1165,
      "additions": 1063,
      "deletions": 102
    },
    "files": [
      {
        "sha": "517ab30fecd97c3669bf6bffa9976b8489123efe",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77dfdc9e36e308aa806d63aa3b5628971789d5a/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77dfdc9e36e308aa806d63aa3b5628971789d5a/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "patch": "@@ -189,7 +189,7 @@ case $host in\n        AC_MSG_ERROR(\"windres not found\")\n      fi\n \n-     CPPFLAGS=\"$CPPFLAGS -D_MT -DWIN32 -D_WINDOWS -DBOOST_THREAD_USE_LIB -D__USE_MINGW_ANSI_STDIO\"\n+     CPPFLAGS=\"$CPPFLAGS -D_MT -DWIN32 -D_WINDOWS -DBOOST_THREAD_USE_LIB\"\n      LEVELDB_TARGET_FLAGS=\"TARGET_OS=OS_WINDOWS_CROSSCOMPILE\"\n      if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n        CXXFLAGS=\"$CXXFLAGS -w\""
      },
      {
        "sha": "da842a9e6f9c3a67041efa6adaf46ef7ff2f7d12",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "patch": "@@ -60,6 +60,7 @@ BITCOIN_CORE_H = \\\n   serialize.h \\\n   sync.h \\\n   threadsafety.h \\\n+  tinyformat.h \\\n   txdb.h \\\n   txmempool.h \\\n   ui_interface.h \\"
      },
      {
        "sha": "1f16152785cadba4d04ebfa3236e9ecb8571e917",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "patch": "@@ -1884,7 +1884,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n             pindex = pindex->pprev;\n         }\n         if (nUpgraded > 0)\n-            LogPrintf(\"SetBestChain: %d of last 100 blocks above version %d\\n\", nUpgraded, CBlock::CURRENT_VERSION);\n+            LogPrintf(\"SetBestChain: %d of last 100 blocks above version %d\\n\", nUpgraded, (int)CBlock::CURRENT_VERSION);\n         if (nUpgraded > 100/2)\n             // strMiscWarning is read by GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n             strMiscWarning = _(\"Warning: This version is obsolete, upgrade required!\");"
      },
      {
        "sha": "04b51f0adcd4ec82d9dda535f4bda14602340214",
        "filename": "src/tinyformat.h",
        "status": "added",
        "additions": 1010,
        "deletions": 0,
        "changes": 1010,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/tinyformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/tinyformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tinyformat.h?ref=b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "patch": "@@ -0,0 +1,1010 @@\n+// tinyformat.h\n+// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]\n+//\n+// Boost Software License - Version 1.0\n+//\n+// Permission is hereby granted, free of charge, to any person or organization\n+// obtaining a copy of the software and accompanying documentation covered by\n+// this license (the \"Software\") to use, reproduce, display, distribute,\n+// execute, and transmit the Software, and to prepare derivative works of the\n+// Software, and to permit third-parties to whom the Software is furnished to\n+// do so, all subject to the following:\n+//\n+// The copyright notices in the Software and this entire statement, including\n+// the above license grant, this restriction and the following disclaimer,\n+// must be included in all copies of the Software, in whole or in part, and\n+// all derivative works of the Software, unless such copies or derivative\n+// works are solely in the form of machine-executable object code generated by\n+// a source language processor.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n+// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n+// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+\n+//------------------------------------------------------------------------------\n+// Tinyformat: A minimal type safe printf replacement\n+//\n+// tinyformat.h is a type safe printf replacement library in a single C++\n+// header file.  Design goals include:\n+//\n+// * Type safety and extensibility for user defined types.\n+// * C99 printf() compatibility, to the extent possible using std::ostream\n+// * Simplicity and minimalism.  A single header file to include and distribute\n+//   with your projects.\n+// * Augment rather than replace the standard stream formatting mechanism\n+// * C++98 support, with optional C++11 niceties\n+//\n+//\n+// Main interface example usage\n+// ----------------------------\n+//\n+// To print a date to std::cout:\n+//\n+//   std::string weekday = \"Wednesday\";\n+//   const char* month = \"July\";\n+//   size_t day = 27;\n+//   long hour = 14;\n+//   int min = 44;\n+//\n+//   tfm::printf(\"%s, %s %d, %.2d:%.2d\\n\", weekday, month, day, hour, min);\n+//\n+// The strange types here emphasize the type safety of the interface; it is\n+// possible to print a std::string using the \"%s\" conversion, and a\n+// size_t using the \"%d\" conversion.  A similar result could be achieved\n+// using either of the tfm::format() functions.  One prints on a user provided\n+// stream:\n+//\n+//   tfm::format(std::cerr, \"%s, %s %d, %.2d:%.2d\\n\",\n+//               weekday, month, day, hour, min);\n+//\n+// The other returns a std::string:\n+//\n+//   std::string date = tfm::format(\"%s, %s %d, %.2d:%.2d\\n\",\n+//                                  weekday, month, day, hour, min);\n+//   std::cout << date;\n+//\n+// These are the three primary interface functions.\n+//\n+//\n+// User defined format functions\n+// -----------------------------\n+//\n+// Simulating variadic templates in C++98 is pretty painful since it requires\n+// writing out the same function for each desired number of arguments.  To make\n+// this bearable tinyformat comes with a set of macros which are used\n+// internally to generate the API, but which may also be used in user code.\n+//\n+// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and\n+// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,\n+// type/name pairs and argument names respectively when called with an integer\n+// n between 1 and 16.  We can use these to define a macro which generates the\n+// desired user defined function with n arguments.  To generate all 16 user\n+// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an\n+// example, see the implementation of printf() at the end of the source file.\n+//\n+//\n+// Additional API information\n+// --------------------------\n+//\n+// Error handling: Define TINYFORMAT_ERROR to customize the error handling for\n+// format strings which are unsupported or have the wrong number of format\n+// specifiers (calls assert() by default).\n+//\n+// User defined types: Uses operator<< for user defined types by default.\n+// Overload formatValue() for more control.\n+\n+\n+#ifndef TINYFORMAT_H_INCLUDED\n+#define TINYFORMAT_H_INCLUDED\n+\n+namespace tinyformat {}\n+//------------------------------------------------------------------------------\n+// Config section.  Customize to your liking!\n+\n+// Namespace alias to encourage brevity\n+namespace tfm = tinyformat;\n+\n+// Error handling; calls assert() by default.\n+// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)\n+\n+// Define for C++11 variadic templates which make the code shorter & more\n+// general.  If you don't define this, C++11 support is autodetected below.\n+// #define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+\n+//------------------------------------------------------------------------------\n+// Implementation details.\n+#include <cassert>\n+#include <iostream>\n+#include <sstream>\n+\n+#ifndef TINYFORMAT_ERROR\n+#   define TINYFORMAT_ERROR(reason) assert(0 && reason)\n+#endif\n+\n+#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)\n+#   ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#       define TINYFORMAT_USE_VARIADIC_TEMPLATES\n+#   endif\n+#endif\n+\n+#ifdef __GNUC__\n+#   define TINYFORMAT_NOINLINE __attribute__((noinline))\n+#elif defined(_MSC_VER)\n+#   define TINYFORMAT_NOINLINE __declspec(noinline)\n+#else\n+#   define TINYFORMAT_NOINLINE\n+#endif\n+\n+#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201\n+//  std::showpos is broken on old libstdc++ as provided with OSX.  See\n+//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html\n+#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+#endif\n+\n+namespace tinyformat {\n+\n+//------------------------------------------------------------------------------\n+namespace detail {\n+\n+// Test whether type T1 is convertible to type T2\n+template <typename T1, typename T2>\n+struct is_convertible\n+{\n+    private:\n+        // two types of different size\n+        struct fail { char dummy[2]; };\n+        struct succeed { char dummy; };\n+        // Try to convert a T1 to a T2 by plugging into tryConvert\n+        static fail tryConvert(...);\n+        static succeed tryConvert(const T2&);\n+        static const T1& makeT1();\n+    public:\n+#       ifdef _MSC_VER\n+        // Disable spurious loss of precision warnings in tryConvert(makeT1())\n+#       pragma warning(push)\n+#       pragma warning(disable:4244)\n+#       pragma warning(disable:4267)\n+#       endif\n+        // Standard trick: the (...) version of tryConvert will be chosen from\n+        // the overload set only if the version taking a T2 doesn't match.\n+        // Then we compare the sizes of the return types to check which\n+        // function matched.  Very neat, in a disgusting kind of way :)\n+        static const bool value =\n+            sizeof(tryConvert(makeT1())) == sizeof(succeed);\n+#       ifdef _MSC_VER\n+#       pragma warning(pop)\n+#       endif\n+};\n+\n+\n+// Detect when a type is not a wchar_t string\n+template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };\n+template<> struct is_wchar<wchar_t*> {};\n+template<> struct is_wchar<const wchar_t*> {};\n+template<int n> struct is_wchar<const wchar_t[n]> {};\n+template<int n> struct is_wchar<wchar_t[n]> {};\n+\n+\n+// Format the value by casting to type fmtT.  This default implementation\n+// should never be called.\n+template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>\n+struct formatValueAsType\n+{\n+    static void invoke(std::ostream& /*out*/, const T& /*value*/) { assert(0); }\n+};\n+// Specialized version for types that can actually be converted to fmtT, as\n+// indicated by the \"convertible\" template parameter.\n+template<typename T, typename fmtT>\n+struct formatValueAsType<T,fmtT,true>\n+{\n+    static void invoke(std::ostream& out, const T& value)\n+        { out << static_cast<fmtT>(value); }\n+};\n+\n+#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+template<typename T, bool convertible = is_convertible<T, int>::value>\n+struct formatZeroIntegerWorkaround\n+{\n+    static bool invoke(std::ostream& /**/, const T& /**/) { return false; }\n+};\n+template<typename T>\n+struct formatZeroIntegerWorkaround<T,true>\n+{\n+    static bool invoke(std::ostream& out, const T& value)\n+    {\n+        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos)\n+        {\n+            out << \"+0\";\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+\n+// Convert an arbitrary type to integer.  The version with convertible=false\n+// throws an error.\n+template<typename T, bool convertible = is_convertible<T,int>::value>\n+struct convertToInt\n+{\n+    static int invoke(const T& /*value*/)\n+    {\n+        TINYFORMAT_ERROR(\"tinyformat: Cannot convert from argument type to \"\n+                         \"integer for use as variable width or precision\");\n+        return 0;\n+    }\n+};\n+// Specialization for convertToInt when conversion is possible\n+template<typename T>\n+struct convertToInt<T,true>\n+{\n+    static int invoke(const T& value) { return static_cast<int>(value); }\n+};\n+\n+} // namespace detail\n+\n+\n+//------------------------------------------------------------------------------\n+// Variable formatting functions.  May be overridden for user-defined types if\n+// desired.\n+\n+\n+// Format a value into a stream. Called from format() for all types by default.\n+//\n+// Users may override this for their own types.  When this function is called,\n+// the stream flags will have been modified according to the format string.\n+// The format specification is provided in the range [fmtBegin, fmtEnd).\n+//\n+// By default, formatValue() uses the usual stream insertion operator\n+// operator<< to format the type T, with special cases for the %c and %p\n+// conversions.\n+template<typename T>\n+inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,\n+                        const char* fmtEnd, const T& value)\n+{\n+#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS\n+    // Since we don't support printing of wchar_t using \"%ls\", make it fail at\n+    // compile time in preference to printing as a void* at runtime.\n+    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;\n+    (void) DummyType(); // avoid unused type warning with gcc-4.8\n+#endif\n+    // The mess here is to support the %c and %p conversions: if these\n+    // conversions are active we try to convert the type to a char or const\n+    // void* respectively and format that instead of the value itself.  For the\n+    // %p conversion it's important to avoid dereferencing the pointer, which\n+    // could otherwise lead to a crash when printing a dangling (const char*).\n+    const bool canConvertToChar = detail::is_convertible<T,char>::value;\n+    const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;\n+    if(canConvertToChar && *(fmtEnd-1) == 'c')\n+        detail::formatValueAsType<T, char>::invoke(out, value);\n+    else if(canConvertToVoidPtr && *(fmtEnd-1) == 'p')\n+        detail::formatValueAsType<T, const void*>::invoke(out, value);\n+#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND\n+    else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;\n+#endif\n+    else\n+        out << value;\n+}\n+\n+\n+// Overloaded version for char types to support printing as an integer\n+#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \\\n+inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \\\n+                        const char* fmtEnd, charType value)           \\\n+{                                                                     \\\n+    switch(*(fmtEnd-1))                                               \\\n+    {                                                                 \\\n+        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \\\n+            out << static_cast<int>(value); break;                    \\\n+        default:                                                      \\\n+            out << value;                   break;                    \\\n+    }                                                                 \\\n+}\n+// per 3.9.1: char, signed char and unsigned char are all distinct types\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)\n+TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)\n+#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR\n+\n+\n+//------------------------------------------------------------------------------\n+// Tools for emulating variadic templates in C++98.  The basic idea here is\n+// stolen from the boost preprocessor metaprogramming library and cut down to\n+// be just general enough for what we need.\n+\n+#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n\n+#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n\n+#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n\n+#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n\n+\n+// To keep it as transparent as possible, the macros below have been generated\n+// using python via the excellent cog.py code generation script.  This avoids\n+// the need for a bunch of complex (but more general) preprocessor tricks as\n+// used in boost.preprocessor.\n+//\n+// To rerun the code generation in place, use `cog.py -r tinyformat.h`\n+// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create\n+// extra versions by hand.\n+\n+/*[[[cog\n+maxParams = 16\n+\n+def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):\n+    for j in range(startInd,maxParams+1):\n+        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])\n+        cog.outl(lineTemplate % {'j':j, 'list':list})\n+\n+makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',\n+                  'class T%(i)d')\n+\n+cog.outl()\n+makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',\n+                  'const T%(i)d& v%(i)d')\n+\n+cog.outl()\n+makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')\n+\n+cog.outl()\n+cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')\n+makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',\n+                  'v%(i)d', startInd = 2)\n+\n+cog.outl()\n+cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\\\\n    ' +\n+         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))\n+]]]*/\n+#define TINYFORMAT_ARGTYPES_1 class T1\n+#define TINYFORMAT_ARGTYPES_2 class T1, class T2\n+#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3\n+#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4\n+#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5\n+#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6\n+#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7\n+#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8\n+#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9\n+#define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10\n+#define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11\n+#define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12\n+#define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13\n+#define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14\n+#define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15\n+#define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16\n+\n+#define TINYFORMAT_VARARGS_1 const T1& v1\n+#define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2\n+#define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3\n+#define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4\n+#define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5\n+#define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6\n+#define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7\n+#define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8\n+#define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9\n+#define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10\n+#define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11\n+#define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12\n+#define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13\n+#define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14\n+#define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15\n+#define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16\n+\n+#define TINYFORMAT_PASSARGS_1 v1\n+#define TINYFORMAT_PASSARGS_2 v1, v2\n+#define TINYFORMAT_PASSARGS_3 v1, v2, v3\n+#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4\n+#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5\n+#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6\n+#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7\n+#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8\n+#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9\n+#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10\n+#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n+#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n+#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n+#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n+#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n+#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n+\n+#define TINYFORMAT_PASSARGS_TAIL_1\n+#define TINYFORMAT_PASSARGS_TAIL_2 , v2\n+#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3\n+#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4\n+#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5\n+#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6\n+#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7\n+#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8\n+#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9\n+#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10\n+#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\n+#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\n+#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13\n+#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\n+#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15\n+#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16\n+\n+#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n+    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)\n+//[[[end]]]\n+\n+\n+\n+namespace detail {\n+\n+// Class holding current position in format string and an output stream into\n+// which arguments are formatted.\n+class FormatIterator\n+{\n+    public:\n+        // Flags for features not representable with standard stream state\n+        enum ExtraFormatFlags\n+        {\n+            Flag_None                = 0,\n+            Flag_TruncateToPrecision = 1<<0, // truncate length to stream precision()\n+            Flag_SpacePadPositive    = 1<<1, // pad positive values with spaces\n+            Flag_VariableWidth       = 1<<2, // variable field width in arg list\n+            Flag_VariablePrecision   = 1<<3  // variable field precision in arg list\n+        };\n+\n+        // out is the output stream, fmt is the full format string\n+        FormatIterator(std::ostream& out, const char* fmt)\n+            : m_out(out),\n+            m_fmt(fmt),\n+            m_extraFlags(Flag_None),\n+            m_wantWidth(false),\n+            m_wantPrecision(false),\n+            m_variableWidth(0),\n+            m_variablePrecision(0),\n+            m_origWidth(out.width()),\n+            m_origPrecision(out.precision()),\n+            m_origFlags(out.flags()),\n+            m_origFill(out.fill())\n+        { }\n+\n+        // Print remaining part of format string.\n+        void finish()\n+        {\n+            // It would be nice if we could do this from the destructor, but we\n+            // can't if TINFORMAT_ERROR is used to throw an exception!\n+            m_fmt = printFormatStringLiteral(m_out, m_fmt);\n+            if(*m_fmt != '\\0')\n+                TINYFORMAT_ERROR(\"tinyformat: Too many conversion specifiers in format string\");\n+        }\n+\n+        ~FormatIterator()\n+        {\n+            // Restore stream state\n+            m_out.width(m_origWidth);\n+            m_out.precision(m_origPrecision);\n+            m_out.flags(m_origFlags);\n+            m_out.fill(m_origFill);\n+        }\n+\n+        template<typename T>\n+        void accept(const T& value);\n+\n+    private:\n+        // Parse and return an integer from the string c, as atoi()\n+        // On return, c is set to one past the end of the integer.\n+        static int parseIntAndAdvance(const char*& c)\n+        {\n+            int i = 0;\n+            for(;*c >= '0' && *c <= '9'; ++c)\n+                i = 10*i + (*c - '0');\n+            return i;\n+        }\n+\n+        // Format at most truncLen characters of a C string to the given\n+        // stream.  Return true if formatting proceeded (generic version always\n+        // returns false)\n+        template<typename T>\n+        static bool formatCStringTruncate(std::ostream& /*out*/, const T& /*value*/,\n+                                        std::streamsize /*truncLen*/)\n+        {\n+            return false;\n+        }\n+#       define TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(type)            \\\n+        static bool formatCStringTruncate(std::ostream& out, type* value,  \\\n+                                        std::streamsize truncLen)          \\\n+        {                                                                  \\\n+            std::streamsize len = 0;                                       \\\n+            while(len < truncLen && value[len] != 0)                       \\\n+                ++len;                                                     \\\n+            out.write(value, len);                                         \\\n+            return true;                                                   \\\n+        }\n+        // Overload for const char* and char*.  Could overload for signed &\n+        // unsigned char too, but these are technically unneeded for printf\n+        // compatibility.\n+        TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(const char)\n+        TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE(char)\n+#       undef TINYFORMAT_DEFINE_FORMAT_C_STRING_TRUNCATE\n+\n+        // Print literal part of format string and return next format spec\n+        // position.\n+        //\n+        // Skips over any occurrences of '%%', printing a literal '%' to the\n+        // output.  The position of the first % character of the next\n+        // nontrivial format spec is returned, or the end of string.\n+        static const char* printFormatStringLiteral(std::ostream& out,\n+                                                    const char* fmt)\n+        {\n+            const char* c = fmt;\n+            for(; true; ++c)\n+            {\n+                switch(*c)\n+                {\n+                    case '\\0':\n+                        out.write(fmt, static_cast<std::streamsize>(c - fmt));\n+                        return c;\n+                    case '%':\n+                        out.write(fmt, static_cast<std::streamsize>(c - fmt));\n+                        if(*(c+1) != '%')\n+                            return c;\n+                        // for \"%%\", tack trailing % onto next literal section.\n+                        fmt = ++c;\n+                        break;\n+                }\n+            }\n+        }\n+\n+        static const char* streamStateFromFormat(std::ostream& out,\n+                                                 unsigned int& extraFlags,\n+                                                 const char* fmtStart,\n+                                                 int variableWidth,\n+                                                 int variablePrecision);\n+\n+        // Private copy & assign: Kill gcc warnings with -Weffc++\n+        FormatIterator(const FormatIterator&);\n+        FormatIterator& operator=(const FormatIterator&);\n+\n+        // Stream, current format string & state\n+        std::ostream& m_out;\n+        const char* m_fmt;\n+        unsigned int m_extraFlags;\n+        // State machine info for handling of variable width & precision\n+        bool m_wantWidth;\n+        bool m_wantPrecision;\n+        int m_variableWidth;\n+        int m_variablePrecision;\n+        // Saved stream state\n+        std::streamsize m_origWidth;\n+        std::streamsize m_origPrecision;\n+        std::ios::fmtflags m_origFlags;\n+        char m_origFill;\n+};\n+\n+\n+// Accept a value for formatting into the internal stream.\n+template<typename T>\n+TINYFORMAT_NOINLINE  // < greatly reduces bloat in optimized builds\n+void FormatIterator::accept(const T& value)\n+{\n+    // Parse the format string\n+    const char* fmtEnd = 0;\n+    if(m_extraFlags == Flag_None && !m_wantWidth && !m_wantPrecision)\n+    {\n+        m_fmt = printFormatStringLiteral(m_out, m_fmt);\n+        fmtEnd = streamStateFromFormat(m_out, m_extraFlags, m_fmt, 0, 0);\n+        m_wantWidth     = (m_extraFlags & Flag_VariableWidth) != 0;\n+        m_wantPrecision = (m_extraFlags & Flag_VariablePrecision) != 0;\n+    }\n+    // Consume value as variable width and precision specifier if necessary\n+    if(m_extraFlags & (Flag_VariableWidth | Flag_VariablePrecision))\n+    {\n+        if(m_wantWidth || m_wantPrecision)\n+        {\n+            int v = convertToInt<T>::invoke(value);\n+            if(m_wantWidth)\n+            {\n+                m_variableWidth = v;\n+                m_wantWidth = false;\n+            }\n+            else if(m_wantPrecision)\n+            {\n+                m_variablePrecision = v;\n+                m_wantPrecision = false;\n+            }\n+            return;\n+        }\n+        // If we get here, we've set both the variable precision and width as\n+        // required and we need to rerun the stream state setup to insert these.\n+        fmtEnd = streamStateFromFormat(m_out, m_extraFlags, m_fmt,\n+                                       m_variableWidth, m_variablePrecision);\n+    }\n+\n+    // Format the value into the stream.\n+    if(!(m_extraFlags & (Flag_SpacePadPositive | Flag_TruncateToPrecision)))\n+        formatValue(m_out, m_fmt, fmtEnd, value);\n+    else\n+    {\n+        // The following are special cases where there's no direct\n+        // correspondence between stream formatting and the printf() behaviour.\n+        // Instead, we simulate the behaviour crudely by formatting into a\n+        // temporary string stream and munging the resulting string.\n+        std::ostringstream tmpStream;\n+        tmpStream.copyfmt(m_out);\n+        if(m_extraFlags & Flag_SpacePadPositive)\n+            tmpStream.setf(std::ios::showpos);\n+        // formatCStringTruncate is required for truncating conversions like\n+        // \"%.4s\" where at most 4 characters of the c-string should be read.\n+        // If we didn't include this special case, we might read off the end.\n+        if(!( (m_extraFlags & Flag_TruncateToPrecision) &&\n+             formatCStringTruncate(tmpStream, value, m_out.precision()) ))\n+        {\n+            // Not a truncated c-string; just format normally.\n+            formatValue(tmpStream, m_fmt, fmtEnd, value);\n+        }\n+        std::string result = tmpStream.str(); // allocates... yuck.\n+        if(m_extraFlags & Flag_SpacePadPositive)\n+        {\n+            for(size_t i = 0, iend = result.size(); i < iend; ++i)\n+                if(result[i] == '+')\n+                    result[i] = ' ';\n+        }\n+        if((m_extraFlags & Flag_TruncateToPrecision) &&\n+           (int)result.size() > (int)m_out.precision())\n+            m_out.write(result.c_str(), m_out.precision());\n+        else\n+            m_out << result;\n+    }\n+    m_extraFlags = Flag_None;\n+    m_fmt = fmtEnd;\n+}\n+\n+\n+// Parse a format string and set the stream state accordingly.\n+//\n+// The format mini-language recognized here is meant to be the one from C99,\n+// with the form \"%[flags][width][.precision][length]type\".\n+//\n+// Formatting options which can't be natively represented using the ostream\n+// state are returned in the extraFlags parameter which is a bitwise\n+// combination of values from the ExtraFormatFlags enum.\n+inline const char* FormatIterator::streamStateFromFormat(std::ostream& out,\n+                                                         unsigned int& extraFlags,\n+                                                         const char* fmtStart,\n+                                                         int variableWidth,\n+                                                         int variablePrecision)\n+{\n+    if(*fmtStart != '%')\n+    {\n+        TINYFORMAT_ERROR(\"tinyformat: Not enough conversion specifiers in format string\");\n+        return fmtStart;\n+    }\n+    // Reset stream state to defaults.\n+    out.width(0);\n+    out.precision(6);\n+    out.fill(' ');\n+    // Reset most flags; ignore irrelevant unitbuf & skipws.\n+    out.unsetf(std::ios::adjustfield | std::ios::basefield |\n+               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |\n+               std::ios::showpoint | std::ios::showpos | std::ios::uppercase);\n+    extraFlags = Flag_None;\n+    bool precisionSet = false;\n+    bool widthSet = false;\n+    const char* c = fmtStart + 1;\n+    // 1) Parse flags\n+    for(;; ++c)\n+    {\n+        switch(*c)\n+        {\n+            case '#':\n+                out.setf(std::ios::showpoint | std::ios::showbase);\n+                continue;\n+            case '0':\n+                // overridden by left alignment ('-' flag)\n+                if(!(out.flags() & std::ios::left))\n+                {\n+                    // Use internal padding so that numeric values are\n+                    // formatted correctly, eg -00010 rather than 000-10\n+                    out.fill('0');\n+                    out.setf(std::ios::internal, std::ios::adjustfield);\n+                }\n+                continue;\n+            case '-':\n+                out.fill(' ');\n+                out.setf(std::ios::left, std::ios::adjustfield);\n+                continue;\n+            case ' ':\n+                // overridden by show positive sign, '+' flag.\n+                if(!(out.flags() & std::ios::showpos))\n+                    extraFlags |= Flag_SpacePadPositive;\n+                continue;\n+            case '+':\n+                out.setf(std::ios::showpos);\n+                extraFlags &= ~Flag_SpacePadPositive;\n+                continue;\n+        }\n+        break;\n+    }\n+    // 2) Parse width\n+    if(*c >= '0' && *c <= '9')\n+    {\n+        widthSet = true;\n+        out.width(parseIntAndAdvance(c));\n+    }\n+    if(*c == '*')\n+    {\n+        widthSet = true;\n+        if(variableWidth < 0)\n+        {\n+            // negative widths correspond to '-' flag set\n+            out.fill(' ');\n+            out.setf(std::ios::left, std::ios::adjustfield);\n+            variableWidth = -variableWidth;\n+        }\n+        out.width(variableWidth);\n+        extraFlags |= Flag_VariableWidth;\n+        ++c;\n+    }\n+    // 3) Parse precision\n+    if(*c == '.')\n+    {\n+        ++c;\n+        int precision = 0;\n+        if(*c == '*')\n+        {\n+            ++c;\n+            extraFlags |= Flag_VariablePrecision;\n+            precision = variablePrecision;\n+        }\n+        else\n+        {\n+            if(*c >= '0' && *c <= '9')\n+                precision = parseIntAndAdvance(c);\n+            else if(*c == '-') // negative precisions ignored, treated as zero.\n+                parseIntAndAdvance(++c);\n+        }\n+        out.precision(precision);\n+        precisionSet = true;\n+    }\n+    // 4) Ignore any C99 length modifier\n+    while(*c == 'l' || *c == 'h' || *c == 'L' ||\n+          *c == 'j' || *c == 'z' || *c == 't')\n+        ++c;\n+    // 5) We're up to the conversion specifier character.\n+    // Set stream flags based on conversion specifier (thanks to the\n+    // boost::format class for forging the way here).\n+    bool intConversion = false;\n+    switch(*c)\n+    {\n+        case 'u': case 'd': case 'i':\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'o':\n+            out.setf(std::ios::oct, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'X':\n+            out.setf(std::ios::uppercase);\n+        case 'x': case 'p':\n+            out.setf(std::ios::hex, std::ios::basefield);\n+            intConversion = true;\n+            break;\n+        case 'E':\n+            out.setf(std::ios::uppercase);\n+        case 'e':\n+            out.setf(std::ios::scientific, std::ios::floatfield);\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            break;\n+        case 'F':\n+            out.setf(std::ios::uppercase);\n+        case 'f':\n+            out.setf(std::ios::fixed, std::ios::floatfield);\n+            break;\n+        case 'G':\n+            out.setf(std::ios::uppercase);\n+        case 'g':\n+            out.setf(std::ios::dec, std::ios::basefield);\n+            // As in boost::format, let stream decide float format.\n+            out.flags(out.flags() & ~std::ios::floatfield);\n+            break;\n+        case 'a': case 'A':\n+            TINYFORMAT_ERROR(\"tinyformat: the %a and %A conversion specs \"\n+                             \"are not supported\");\n+            break;\n+        case 'c':\n+            // Handled as special case inside formatValue()\n+            break;\n+        case 's':\n+            if(precisionSet)\n+                extraFlags |= Flag_TruncateToPrecision;\n+            // Make %s print booleans as \"true\" and \"false\"\n+            out.setf(std::ios::boolalpha);\n+            break;\n+        case 'n':\n+            // Not supported - will cause problems!\n+            TINYFORMAT_ERROR(\"tinyformat: %n conversion spec not supported\");\n+            break;\n+        case '\\0':\n+            TINYFORMAT_ERROR(\"tinyformat: Conversion spec incorrectly \"\n+                             \"terminated by end of string\");\n+            return c;\n+    }\n+    if(intConversion && precisionSet && !widthSet)\n+    {\n+        // \"precision\" for integers gives the minimum number of digits (to be\n+        // padded with zeros on the left).  This isn't really supported by the\n+        // iostreams, but we can approximately simulate it with the width if\n+        // the width isn't otherwise used.\n+        out.width(out.precision());\n+        out.setf(std::ios::internal, std::ios::adjustfield);\n+        out.fill('0');\n+    }\n+    return c+1;\n+}\n+\n+\n+\n+//------------------------------------------------------------------------------\n+// Private format function on top of which the public interface is implemented.\n+// We enforce a mimimum of one value to be formatted to prevent bugs looking like\n+//\n+//   const char* myStr = \"100% broken\";\n+//   printf(myStr);   // Parses % as a format specifier\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+template<typename T1>\n+void format(FormatIterator& fmtIter, const T1& value1)\n+{\n+    fmtIter.accept(value1);\n+    fmtIter.finish();\n+}\n+\n+// General version for C++11\n+template<typename T1, typename... Args>\n+void format(FormatIterator& fmtIter, const T1& value1, const Args&... args)\n+{\n+    fmtIter.accept(value1);\n+    format(fmtIter, args...);\n+}\n+\n+#else\n+\n+inline void format(FormatIterator& fmtIter)\n+{\n+    fmtIter.finish();\n+}\n+\n+// General version for C++98\n+#define TINYFORMAT_MAKE_FORMAT_DETAIL(n)                                  \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void format(detail::FormatIterator& fmtIter, TINYFORMAT_VARARGS(n))       \\\n+{                                                                         \\\n+    fmtIter.accept(v1);                                                   \\\n+    format(fmtIter TINYFORMAT_PASSARGS_TAIL(n));                          \\\n+}\n+\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_DETAIL)\n+#undef TINYFORMAT_MAKE_FORMAT_DETAIL\n+\n+#endif // End C++98 variadic template emulation for format()\n+\n+} // namespace detail\n+\n+\n+//------------------------------------------------------------------------------\n+// Implement all the main interface functions here in terms of detail::format()\n+\n+#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES\n+\n+// C++11 - the simple case\n+template<typename T1, typename... Args>\n+void format(std::ostream& out, const char* fmt, const T1& v1, const Args&... args)\n+{\n+    detail::FormatIterator fmtIter(out, fmt);\n+    format(fmtIter, v1, args...);\n+}\n+\n+template<typename T1, typename... Args>\n+std::string format(const char* fmt, const T1& v1, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt, v1, args...);\n+    return oss.str();\n+}\n+\n+template<typename T1, typename... Args>\n+std::string format(const std::string &fmt, const T1& v1, const Args&... args)\n+{\n+    std::ostringstream oss;\n+    format(oss, fmt.c_str(), v1, args...);\n+    return oss.str();\n+}\n+\n+template<typename T1, typename... Args>\n+void printf(const char* fmt, const T1& v1, const Args&... args)\n+{\n+    format(std::cout, fmt, v1, args...);\n+}\n+\n+#else\n+\n+// C++98 - define the interface functions using the wrapping macros\n+#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \\\n+{                                                                         \\\n+    tinyformat::detail::FormatIterator fmtIter(out, fmt);                 \\\n+    tinyformat::detail::format(fmtIter, TINYFORMAT_PASSARGS(n));          \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \\\n+{                                                                         \\\n+    std::ostringstream oss;                                               \\\n+    tinyformat::format(oss, fmt, TINYFORMAT_PASSARGS(n));                 \\\n+    return oss.str();                                                     \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+std::string format(const std::string &fmt, TINYFORMAT_VARARGS(n))         \\\n+{                                                                         \\\n+    std::ostringstream oss;                                               \\\n+    tinyformat::format(oss, fmt.c_str(), TINYFORMAT_PASSARGS(n));         \\\n+    return oss.str();                                                     \\\n+}                                                                         \\\n+                                                                          \\\n+template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \\\n+{                                                                         \\\n+    tinyformat::format(std::cout, fmt, TINYFORMAT_PASSARGS(n));           \\\n+}\n+\n+TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)\n+#undef TINYFORMAT_MAKE_FORMAT_FUNCS\n+#endif\n+\n+\n+//------------------------------------------------------------------------------\n+// Define deprecated wrapping macro for backward compatibility in tinyformat\n+// 1.x.  Will be removed in version 2!\n+#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS\n+#define TINYFORMAT_WRAP_FORMAT_N(n, returnType, funcName, funcDeclSuffix,  \\\n+                                 bodyPrefix, streamName, bodySuffix)       \\\n+template<TINYFORMAT_ARGTYPES(n)>                                           \\\n+returnType funcName(TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS const char* fmt,     \\\n+                    TINYFORMAT_VARARGS(n)) funcDeclSuffix                  \\\n+{                                                                          \\\n+    bodyPrefix                                                             \\\n+    tinyformat::format(streamName, fmt, TINYFORMAT_PASSARGS(n));           \\\n+    bodySuffix                                                             \\\n+}                                                                          \\\n+\n+#define TINYFORMAT_WRAP_FORMAT(returnType, funcName, funcDeclSuffix,       \\\n+                               bodyPrefix, streamName, bodySuffix)         \\\n+inline                                                                     \\\n+returnType funcName(TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS const char* fmt      \\\n+                    ) funcDeclSuffix                                       \\\n+{                                                                          \\\n+    bodyPrefix                                                             \\\n+    tinyformat::detail::FormatIterator(streamName, fmt).finish();          \\\n+    bodySuffix                                                             \\\n+}                                                                          \\\n+TINYFORMAT_WRAP_FORMAT_N(1 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(2 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(3 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(4 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(5 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(6 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(7 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(8 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(9 , returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(10, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(11, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(12, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(13, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(14, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(15, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+TINYFORMAT_WRAP_FORMAT_N(16, returnType, funcName, funcDeclSuffix, bodyPrefix, streamName, bodySuffix) \\\n+\n+\n+} // namespace tinyformat\n+\n+#endif // TINYFORMAT_H_INCLUDED"
      },
      {
        "sha": "dd96ae0d7040c98f6708b453bee34539e1f83516",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 68,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "patch": "@@ -235,12 +235,12 @@ static void DebugPrintInit()\n     mutexDebugLog = new boost::mutex();\n }\n \n-int LogPrint(const char* category, const char* pszFormat, ...)\n+bool LogAcceptCategory(const char* category)\n {\n     if (category != NULL)\n     {\n         if (!fDebug)\n-            return 0;\n+            return false;\n \n         // Give each thread quick access to -debug settings.\n         // This helps prevent issues debugging global destructors,\n@@ -258,17 +258,18 @@ int LogPrint(const char* category, const char* pszFormat, ...)\n         // if not debugging everything and not debugging specific category, LogPrint does nothing.\n         if (setCategories.count(string(\"\")) == 0 &&\n             setCategories.count(string(category)) == 0)\n-            return 0;\n+            return false;\n     }\n+    return true;\n+}\n \n+int LogPrintStr(const std::string &str)\n+{\n     int ret = 0; // Returns total number of characters written\n     if (fPrintToConsole)\n     {\n         // print to console\n-        va_list arg_ptr;\n-        va_start(arg_ptr, pszFormat);\n-        ret += vprintf(pszFormat, arg_ptr);\n-        va_end(arg_ptr);\n+        ret = fwrite(str.data(), 1, str.size(), stdout);\n     }\n     else if (fPrintToDebugLog)\n     {\n@@ -291,76 +292,17 @@ int LogPrint(const char* category, const char* pszFormat, ...)\n         // Debug print useful for profiling\n         if (fLogTimestamps && fStartedNewLine)\n             ret += fprintf(fileout, \"%s \", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()).c_str());\n-        if (pszFormat[strlen(pszFormat) - 1] == '\\n')\n+        if (!str.empty() && str[str.size()-1] == '\\n')\n             fStartedNewLine = true;\n         else\n             fStartedNewLine = false;\n \n-        va_list arg_ptr;\n-        va_start(arg_ptr, pszFormat);\n-        ret += vfprintf(fileout, pszFormat, arg_ptr);\n-        va_end(arg_ptr);\n+        ret = fwrite(str.data(), 1, str.size(), fileout);\n     }\n \n     return ret;\n }\n \n-string vstrprintf(const char *format, va_list ap)\n-{\n-    char buffer[50000];\n-    char* p = buffer;\n-    int limit = sizeof(buffer);\n-    int ret;\n-    while (true)\n-    {\n-        va_list arg_ptr;\n-        va_copy(arg_ptr, ap);\n-        ret = vsnprintf(p, limit, format, arg_ptr);\n-        va_end(arg_ptr);\n-        if (ret >= 0 && ret < limit)\n-            break;\n-        if (p != buffer)\n-            delete[] p;\n-        limit *= 2;\n-        p = new char[limit];\n-        if (p == NULL)\n-            throw std::bad_alloc();\n-    }\n-    string str(p, p+ret);\n-    if (p != buffer)\n-        delete[] p;\n-    return str;\n-}\n-\n-string real_strprintf(const char *format, int dummy, ...)\n-{\n-    va_list arg_ptr;\n-    va_start(arg_ptr, dummy);\n-    string str = vstrprintf(format, arg_ptr);\n-    va_end(arg_ptr);\n-    return str;\n-}\n-\n-string real_strprintf(const std::string &format, int dummy, ...)\n-{\n-    va_list arg_ptr;\n-    va_start(arg_ptr, dummy);\n-    string str = vstrprintf(format.c_str(), arg_ptr);\n-    va_end(arg_ptr);\n-    return str;\n-}\n-\n-bool error(const char *format, ...)\n-{\n-    va_list arg_ptr;\n-    va_start(arg_ptr, format);\n-    std::string str = vstrprintf(format, arg_ptr);\n-    va_end(arg_ptr);\n-    LogPrintf(\"ERROR: %s\\n\", str.c_str());\n-    return false;\n-}\n-\n-\n void ParseString(const string& str, char c, vector<string>& v)\n {\n     if (str.empty())"
      },
      {
        "sha": "63bad61d23e42dbfd1f3ad565aa4d0f28cf02b7b",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 40,
        "deletions": 32,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b77dfdc9e36e308aa806d63aa3b5628971789d5a/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "patch": "@@ -12,6 +12,7 @@\n \n #include \"compat.h\"\n #include \"serialize.h\"\n+#include \"tinyformat.h\"\n \n #include <cstdio>\n #include <exception>\n@@ -99,21 +100,6 @@ inline void MilliSleep(int64_t n)\n #endif\n }\n \n-/* This GNU C extension enables the compiler to check the format string against the parameters provided.\n- * X is the number of the \"format string\" parameter, and Y is the number of the first variadic parameter.\n- * Parameters count from 1.\n- */\n-#ifdef __GNUC__\n-#define ATTR_WARN_PRINTF(X,Y) __attribute__((format(gnu_printf,X,Y)))\n-#else\n-#define ATTR_WARN_PRINTF(X,Y)\n-#endif\n-\n-\n-\n-\n-\n-\n \n \n extern std::map<std::string, std::string> mapArgs;\n@@ -130,27 +116,49 @@ extern volatile bool fReopenDebugLog;\n void RandAddSeed();\n void RandAddSeedPerfmon();\n \n-// Print to debug.log if -debug=category switch is given OR category is NULL.\n-int ATTR_WARN_PRINTF(2,3) LogPrint(const char* category, const char* pszFormat, ...);\n+/* Return true if log accepts specified category */\n+bool LogAcceptCategory(const char* category);\n+/* Send a string to the log output */\n+int LogPrintStr(const std::string &str);\n+\n+#define strprintf tfm::format\n #define LogPrintf(...) LogPrint(NULL, __VA_ARGS__)\n \n-/*\n-  Rationale for the real_strprintf / strprintf construction:\n-    It is not allowed to use va_start with a pass-by-reference argument.\n-    (C++ standard, 18.7, paragraph 3). Use a dummy argument to work around this, and use a\n-    macro to keep similar semantics.\n-*/\n-\n-/** Overload strprintf for char*, so that GCC format type warnings can be given */\n-std::string ATTR_WARN_PRINTF(1,3) real_strprintf(const char *format, int dummy, ...);\n-/** Overload strprintf for std::string, to be able to use it with _ (translation).\n- * This will not support GCC format type warnings (-Wformat) so be careful.\n+/* When we switch to C++11, this can be switched to variadic templates instead\n+ * of this macro-based construction (see tinyformat.h).\n+ */\n+#define MAKE_ERROR_AND_LOG_FUNC(n)                                        \\\n+    /*   Print to debug.log if -debug=category switch is given OR category is NULL. */ \\\n+    template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+    static inline int LogPrint(const char* category, const char* format, TINYFORMAT_VARARGS(n))  \\\n+    {                                                                         \\\n+        if(!LogAcceptCategory(category)) return 0;                            \\\n+        return LogPrintStr(tfm::format(format, TINYFORMAT_PASSARGS(n))); \\\n+    }                                                                         \\\n+    /*   Log error and return false */                                        \\\n+    template<TINYFORMAT_ARGTYPES(n)>                                          \\\n+    static inline bool error(const char* format, TINYFORMAT_VARARGS(n))                     \\\n+    {                                                                         \\\n+        LogPrintStr(\"ERROR: \" + tfm::format(format, TINYFORMAT_PASSARGS(n))); \\\n+        return false;                                                         \\\n+    }\n+\n+TINYFORMAT_FOREACH_ARGNUM(MAKE_ERROR_AND_LOG_FUNC)\n+\n+/* Zero-arg versions of logging and error, these are not covered by\n+ * TINYFORMAT_FOREACH_ARGNUM\n  */\n-std::string real_strprintf(const std::string &format, int dummy, ...);\n-#define strprintf(format, ...) real_strprintf(format, 0, __VA_ARGS__)\n-std::string vstrprintf(const char *format, va_list ap);\n+static inline int LogPrint(const char* category, const char* format)\n+{\n+    if(!LogAcceptCategory(category)) return 0;\n+    return LogPrintStr(format);\n+}\n+static inline bool error(const char* format)\n+{\n+    LogPrintStr(std::string(\"ERROR: \") + format);\n+    return false;\n+}\n \n-bool ATTR_WARN_PRINTF(1,2) error(const char *format, ...);\n \n void LogException(std::exception* pex, const char* pszThread);\n void PrintException(std::exception* pex, const char* pszThread);"
      }
    ]
  },
  {
    "sha": "7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDlkMTM0YmY5NWNiNmEyY2U5NjIzYzdlNmEzNTM1NDMyYTYxYWYy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-01-16T15:15:27Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-01-23T15:05:01Z"
      },
      "message": "Remove redundant .c_str()s\n\nAfter the tinyformat switch sprintf() family functions support passing\nactual std::string objects.\n\nRemove unnecessary c_str calls (236 of them) in logging and formatting.",
      "tree": {
        "sha": "eeca53e065947846648d9373f240d593c0c0ecfc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eeca53e065947846648d9373f240d593c0c0ecfc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
      "comment_count": 11,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b77dfdc9e36e308aa806d63aa3b5628971789d5a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b77dfdc9e36e308aa806d63aa3b5628971789d5a"
      }
    ],
    "stats": {
      "total": 472,
      "additions": 236,
      "deletions": 236
    },
    "files": [
      {
        "sha": "3628af2eab7ea7c7eb7608a1a43f013778281616",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -304,7 +304,7 @@ void CAddrMan::Good_(const CService &addr, int64_t nTime)\n     // TODO: maybe re-add the node, but for now, just bail out\n     if (nUBucket == -1) return;\n \n-    LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString().c_str());\n+    LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n \n     // move nId to the tried tables\n     MakeTried(info, nId, nUBucket);"
      },
      {
        "sha": "f9cd58d38b85cf0b1eec9fb5cbbe9def619fd0a0",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -69,18 +69,18 @@ std::string CUnsignedAlert::ToString() const\n         nExpiration,\n         nID,\n         nCancel,\n-        strSetCancel.c_str(),\n+        strSetCancel,\n         nMinVer,\n         nMaxVer,\n-        strSetSubVer.c_str(),\n+        strSetSubVer,\n         nPriority,\n-        strComment.c_str(),\n-        strStatusBar.c_str());\n+        strComment,\n+        strStatusBar);\n }\n \n void CUnsignedAlert::print() const\n {\n-    LogPrintf(\"%s\", ToString().c_str());\n+    LogPrintf(\"%s\", ToString());\n }\n \n void CAlert::SetNull()"
      },
      {
        "sha": "57e72489a1f0be951c597213ac5d6d591de01352",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -9,12 +9,12 @@\n \n std::string COutPoint::ToString() const\n {\n-    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10).c_str(), n);\n+    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10), n);\n }\n \n void COutPoint::print() const\n {\n-    LogPrintf(\"%s\\n\", ToString().c_str());\n+    LogPrintf(\"%s\\n\", ToString());\n }\n \n CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, unsigned int nSequenceIn)\n@@ -37,9 +37,9 @@ std::string CTxIn::ToString() const\n     str += \"CTxIn(\";\n     str += prevout.ToString();\n     if (prevout.IsNull())\n-        str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n+        str += strprintf(\", coinbase %s\", HexStr(scriptSig));\n     else\n-        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n+        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24));\n     if (nSequence != std::numeric_limits<unsigned int>::max())\n         str += strprintf(\", nSequence=%u\", nSequence);\n     str += \")\";\n@@ -48,7 +48,7 @@ std::string CTxIn::ToString() const\n \n void CTxIn::print() const\n {\n-    LogPrintf(\"%s\\n\", ToString().c_str());\n+    LogPrintf(\"%s\\n\", ToString());\n }\n \n CTxOut::CTxOut(int64_t nValueIn, CScript scriptPubKeyIn)\n@@ -64,12 +64,12 @@ uint256 CTxOut::GetHash() const\n \n std::string CTxOut::ToString() const\n {\n-    return strprintf(\"CTxOut(nValue=%\"PRId64\".%08\"PRId64\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n+    return strprintf(\"CTxOut(nValue=%\"PRId64\".%08\"PRId64\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30));\n }\n \n void CTxOut::print() const\n {\n-    LogPrintf(\"%s\\n\", ToString().c_str());\n+    LogPrintf(\"%s\\n\", ToString());\n }\n \n uint256 CTransaction::GetHash() const\n@@ -141,7 +141,7 @@ std::string CTransaction::ToString() const\n {\n     std::string str;\n     str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%\"PRIszu\", vout.size=%\"PRIszu\", nLockTime=%u)\\n\",\n-        GetHash().ToString().substr(0,10).c_str(),\n+        GetHash().ToString().substr(0,10),\n         nVersion,\n         vin.size(),\n         vout.size(),\n@@ -155,7 +155,7 @@ std::string CTransaction::ToString() const\n \n void CTransaction::print() const\n {\n-    LogPrintf(\"%s\", ToString().c_str());\n+    LogPrintf(\"%s\", ToString());\n }\n \n // Amount compression:\n@@ -270,10 +270,10 @@ uint256 CBlock::CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMer\n void CBlock::print() const\n {\n     LogPrintf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%\"PRIszu\")\\n\",\n-        GetHash().ToString().c_str(),\n+        GetHash().ToString(),\n         nVersion,\n-        hashPrevBlock.ToString().c_str(),\n-        hashMerkleRoot.ToString().c_str(),\n+        hashPrevBlock.ToString(),\n+        hashMerkleRoot.ToString(),\n         nTime, nBits, nNonce,\n         vtx.size());\n     for (unsigned int i = 0; i < vtx.size(); i++)\n@@ -283,6 +283,6 @@ void CBlock::print() const\n     }\n     LogPrintf(\"  vMerkleTree: \");\n     for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n-        LogPrintf(\"%s \", vMerkleTree[i].ToString().c_str());\n+        LogPrintf(\"%s \", vMerkleTree[i].ToString());\n     LogPrintf(\"\\n\");\n }"
      },
      {
        "sha": "51c28cda692c2dbee156f8523a7e4da21654461b",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -75,7 +75,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n     filesystem::path pathLogDir = path / \"database\";\n     filesystem::create_directory(pathLogDir);\n     filesystem::path pathErrorFile = path / \"db.log\";\n-    LogPrintf(\"dbenv.open LogDir=%s ErrorFile=%s\\n\", pathLogDir.string().c_str(), pathErrorFile.string().c_str());\n+    LogPrintf(\"dbenv.open LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n \n     unsigned int nEnvFlags = 0;\n     if (GetBoolArg(\"-privdb\", true))\n@@ -353,7 +353,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                 bitdb.mapFileUseCount.erase(strFile);\n \n                 bool fSuccess = true;\n-                LogPrintf(\"Rewriting %s...\\n\", strFile.c_str());\n+                LogPrintf(\"Rewriting %s...\\n\", strFile);\n                 string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n                     CDB db(strFile.c_str(), \"r\");\n@@ -367,7 +367,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                                             0);\n                     if (ret > 0)\n                     {\n-                        LogPrintf(\"Cannot create database file %s\\n\", strFileRes.c_str());\n+                        LogPrintf(\"Cannot create database file %s\\n\", strFileRes);\n                         fSuccess = false;\n                     }\n \n@@ -423,7 +423,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                         fSuccess = false;\n                 }\n                 if (!fSuccess)\n-                    LogPrintf(\"Rewriting of %s FAILED!\\n\", strFileRes.c_str());\n+                    LogPrintf(\"Rewriting of %s FAILED!\\n\", strFileRes);\n                 return fSuccess;\n             }\n         }\n@@ -448,17 +448,17 @@ void CDBEnv::Flush(bool fShutdown)\n         {\n             string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n-            LogPrint(\"db\", \"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n+            LogPrint(\"db\", \"%s refcount=%d\\n\", strFile, nRefCount);\n             if (nRefCount == 0)\n             {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n-                LogPrint(\"db\", \"%s checkpoint\\n\", strFile.c_str());\n+                LogPrint(\"db\", \"%s checkpoint\\n\", strFile);\n                 dbenv.txn_checkpoint(0, 0, 0);\n-                LogPrint(\"db\", \"%s detach\\n\", strFile.c_str());\n+                LogPrint(\"db\", \"%s detach\\n\", strFile);\n                 if (!fMockDb)\n                     dbenv.lsn_reset(strFile.c_str(), 0);\n-                LogPrint(\"db\", \"%s closed\\n\", strFile.c_str());\n+                LogPrint(\"db\", \"%s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n             }\n             else"
      },
      {
        "sha": "7213477b22c885a7f1b496b4bed37fc5cd8773e3",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -344,7 +344,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n         FILE *file = fopen(path.string().c_str(), \"rb\");\n         if (file) {\n             CImportingNow imp;\n-            LogPrintf(\"Importing %s...\\n\", path.string().c_str());\n+            LogPrintf(\"Importing %s...\\n\", path.string());\n             LoadExternalBlockFile(file);\n         }\n     }\n@@ -512,22 +512,22 @@ bool AppInit2(boost::thread_group& threadGroup)\n         if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n             CTransaction::nMinTxFee = n;\n         else\n-            return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"].c_str()));\n+            return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n     }\n     if (mapArgs.count(\"-minrelaytxfee\"))\n     {\n         int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n             CTransaction::nMinRelayTxFee = n;\n         else\n-            return InitError(strprintf(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\"), mapArgs[\"-minrelaytxfee\"].c_str()));\n+            return InitError(strprintf(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\"), mapArgs[\"-minrelaytxfee\"]));\n     }\n \n #ifdef ENABLE_WALLET\n     if (mapArgs.count(\"-paytxfee\"))\n     {\n         if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n-            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"].c_str()));\n+            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]));\n         if (nTransactionFee > 0.25 * COIN)\n             InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n     }\n@@ -540,25 +540,25 @@ bool AppInit2(boost::thread_group& threadGroup)\n #ifdef ENABLE_WALLET\n     // Wallet file must be a plain filename without a directory\n     if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n-        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s\"), strWalletFile.c_str(), strDataDir.c_str()));\n+        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s\"), strWalletFile, strDataDir));\n #endif\n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n     if (file) fclose(file);\n     static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n     if (!lock.try_lock())\n-        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin is probably already running.\"), strDataDir.c_str()));\n+        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin is probably already running.\"), strDataDir));\n \n     if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n         ShrinkDebugFile();\n     LogPrintf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n-    LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n+    LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion(), CLIENT_DATE);\n     LogPrintf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n     if (!fLogTimestamps)\n-        LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()).c_str());\n-    LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n-    LogPrintf(\"Using data directory %s\\n\", strDataDir.c_str());\n+        LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()));\n+    LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n+    LogPrintf(\"Using data directory %s\\n\", strDataDir);\n     LogPrintf(\"Using at most %i connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n     std::ostringstream strErrors;\n \n@@ -582,15 +582,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n             boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%\"PRId64\".bak\", GetTime());\n             try {\n                 boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n-                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string().c_str(), pathDatabaseBak.string().c_str());\n+                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n             } catch(boost::filesystem::filesystem_error &error) {\n                  // failure is ok (well, not really, but it's not worse than what we started with)\n             }\n \n             // try again\n             if (!bitdb.Open(GetDataDir())) {\n                 // if it still fails, it probably means we can't even create the database env\n-                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir.c_str());\n+                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir);\n                 return InitError(msg);\n             }\n         }\n@@ -610,7 +610,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n                 string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                          \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                          \" your balance or transactions are incorrect you should\"\n-                                         \" restore from a backup.\"), strDataDir.c_str());\n+                                         \" restore from a backup.\"), strDataDir);\n                 InitWarning(msg);\n             }\n             if (r == CDBEnv::RECOVER_FAIL)\n@@ -631,7 +631,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n         BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n-                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet.c_str()));\n+                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n             nets.insert(net);\n         }\n         for (int n = 0; n < NET_MAX; n++) {\n@@ -652,7 +652,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (mapArgs.count(\"-proxy\")) {\n         addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n         if (!addrProxy.IsValid())\n-            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n+            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"]));\n \n         if (!IsLimited(NET_IPV4))\n             SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n@@ -679,7 +679,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n         else\n             addrOnion = mapArgs.count(\"-onion\")?CService(mapArgs[\"-onion\"], 9050):CService(mapArgs[\"-tor\"], 9050);\n         if (!addrOnion.IsValid())\n-            return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs.count(\"-onion\")?mapArgs[\"-onion\"].c_str():mapArgs[\"-tor\"].c_str()));\n+            return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs.count(\"-onion\")?mapArgs[\"-onion\"]:mapArgs[\"-tor\"]));\n         SetProxy(NET_TOR, addrOnion, 5);\n         SetReachable(NET_TOR);\n     }\n@@ -695,7 +695,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n-                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind.c_str()));\n+                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind));\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n         }\n@@ -715,7 +715,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n         BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n             CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n             if (!addrLocal.IsValid())\n-                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr.c_str()));\n+                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr));\n             AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n         }\n     }\n@@ -739,7 +739,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             filesystem::path dest = blocksDir / strprintf(\"blk%05u.dat\", i-1);\n             try {\n                 filesystem::create_hard_link(source, dest);\n-                LogPrintf(\"Hardlinked %s -> %s\\n\", source.string().c_str(), dest.string().c_str());\n+                LogPrintf(\"Hardlinked %s -> %s\\n\", source.string(), dest.string());\n                 linked = true;\n             } catch (filesystem::filesystem_error & e) {\n                 // Note: hardlink creation failing is not a disaster, it just means\n@@ -879,7 +879,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             }\n         }\n         if (nFound == 0)\n-            LogPrintf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n+            LogPrintf(\"No blocks matching %s were found\\n\", strMatch);\n         return false;\n     }\n \n@@ -910,7 +910,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             else if (nLoadWalletRet == DB_NEED_REWRITE)\n             {\n                 strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin to complete\") << \"\\n\";\n-                LogPrintf(\"%s\", strErrors.str().c_str());\n+                LogPrintf(\"%s\", strErrors.str());\n                 return InitError(strErrors.str());\n             }\n             else\n@@ -948,7 +948,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             pwalletMain->SetBestChain(chainActive.GetLocator());\n         }\n \n-        LogPrintf(\"%s\", strErrors.str().c_str());\n+        LogPrintf(\"%s\", strErrors.str());\n         LogPrintf(\" wallet      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n \n         RegisterWallet(pwalletMain);"
      },
      {
        "sha": "c2935ed017240d54b8fbb8866e74cc73711b2535",
        "filename": "src/leveldbwrapper.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/leveldbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/leveldbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -15,7 +15,7 @@\n void HandleError(const leveldb::Status &status) throw(leveldb_error) {\n     if (status.ok())\n         return;\n-    LogPrintf(\"%s\\n\", status.ToString().c_str());\n+    LogPrintf(\"%s\\n\", status.ToString());\n     if (status.IsCorruption())\n         throw leveldb_error(\"Database corrupted\");\n     if (status.IsIOError())\n@@ -48,11 +48,11 @@ CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path &path, size_t nCa\n         options.env = penv;\n     } else {\n         if (fWipe) {\n-            LogPrintf(\"Wiping LevelDB in %s\\n\", path.string().c_str());\n+            LogPrintf(\"Wiping LevelDB in %s\\n\", path.string());\n             leveldb::DestroyDB(path.string(), options);\n         }\n         boost::filesystem::create_directory(path);\n-        LogPrintf(\"Opening LevelDB in %s\\n\", path.string().c_str());\n+        LogPrintf(\"Opening LevelDB in %s\\n\", path.string());\n     }\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     HandleError(status);"
      },
      {
        "sha": "efc70af90859e6fb77cf5254aec69443c94f6011",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 74,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -309,15 +309,15 @@ bool AddOrphanTx(const CTransaction& tx)\n     unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n     if (sz > 5000)\n     {\n-        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString().c_str());\n+        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n     }\n \n     mapOrphanTransactions[hash] = tx;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n \n-    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().c_str(),\n+    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString(),\n         mapOrphanTransactions.size());\n     return true;\n }\n@@ -693,7 +693,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     string reason;\n     if (Params().NetworkID() == CChainParams::MAIN && !IsStandardTx(tx, reason))\n         return state.DoS(0,\n-                         error(\"AcceptToMemoryPool : nonstandard transaction: %s\", reason.c_str()),\n+                         error(\"AcceptToMemoryPool : nonstandard transaction: %s\", reason),\n                          REJECT_NONSTANDARD, reason);\n \n     // is it already in the memory pool?\n@@ -771,7 +771,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         int64_t txMinFee = GetMinFee(tx, nSize, true, GMF_RELAY);\n         if (fLimitFree && nFees < txMinFee)\n             return state.DoS(0, error(\"AcceptToMemoryPool : not enough fees %s, %\"PRId64\" < %\"PRId64,\n-                                      hash.ToString().c_str(), nFees, txMinFee),\n+                                      hash.ToString(), nFees, txMinFee),\n                              REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n \n         // Continuously rate-limit free transactions\n@@ -800,14 +800,14 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n         if (fRejectInsaneFee && nFees > CTransaction::nMinRelayTxFee * 10000)\n             return error(\"AcceptToMemoryPool: : insane fees %s, %\"PRId64\" > %\"PRId64,\n-                         hash.ToString().c_str(),\n+                         hash.ToString(),\n                          nFees, CTransaction::nMinRelayTxFee * 10000);\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC))\n         {\n-            return error(\"AcceptToMemoryPool: : ConnectInputs failed %s\", hash.ToString().c_str());\n+            return error(\"AcceptToMemoryPool: : ConnectInputs failed %s\", hash.ToString());\n         }\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry);\n@@ -1101,8 +1101,8 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n     /// debug print\n     LogPrintf(\"GetNextWorkRequired RETARGET\\n\");\n     LogPrintf(\"nTargetTimespan = %\"PRId64\"    nActualTimespan = %\"PRId64\"\\n\", nTargetTimespan, nActualTimespan);\n-    LogPrintf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());\n-    LogPrintf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n+    LogPrintf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString());\n+    LogPrintf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString());\n \n     return bnNew.GetCompact();\n }\n@@ -1176,8 +1176,8 @@ void CheckForkWarningConditions()\n         if (pindexBestForkTip)\n         {\n             LogPrintf(\"CheckForkWarningConditions: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\",\n-                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString().c_str(),\n-                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString().c_str());\n+                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),\n+                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString());\n             fLargeWorkForkFound = true;\n         }\n         else\n@@ -1237,12 +1237,12 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n         uiInterface.NotifyBlocksChanged();\n     }\n     LogPrintf(\"InvalidChainFound: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      pindexNew->GetBlockHash().ToString().c_str(), pindexNew->nHeight,\n+      pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,\n       log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n-      pindexNew->GetBlockTime()).c_str());\n+      pindexNew->GetBlockTime()));\n     LogPrintf(\"InvalidChainFound:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0),\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());\n+      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0),\n+      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()));\n     CheckForkWarningConditions();\n }\n \n@@ -1350,7 +1350,7 @@ void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n bool CScriptCheck::operator()() const {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     if (!VerifyScript(scriptSig, scriptPubKey, *ptxTo, nIn, nFlags, nHashType))\n-        return error(\"CScriptCheck() : %s VerifySignature failed\", ptxTo->GetHash().ToString().c_str());\n+        return error(\"CScriptCheck() : %s VerifySignature failed\", ptxTo->GetHash().ToString());\n     return true;\n }\n \n@@ -1369,7 +1369,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n         // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n         // for an attacker to attempt to split the network.\n         if (!inputs.HaveInputs(tx))\n-            return state.Invalid(error(\"CheckInputs() : %s inputs unavailable\", tx.GetHash().ToString().c_str()));\n+            return state.Invalid(error(\"CheckInputs() : %s inputs unavailable\", tx.GetHash().ToString()));\n \n         // While checking, GetBestBlock() refers to the parent block.\n         // This is also true for mempool checks.\n@@ -1399,13 +1399,13 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n         }\n \n         if (nValueIn < tx.GetValueOut())\n-            return state.DoS(100, error(\"CheckInputs() : %s value in < value out\", tx.GetHash().ToString().c_str()),\n+            return state.DoS(100, error(\"CheckInputs() : %s value in < value out\", tx.GetHash().ToString()),\n                              REJECT_INVALID, \"in < out\");\n \n         // Tally transaction fees\n         int64_t nTxFee = nValueIn - tx.GetValueOut();\n         if (nTxFee < 0)\n-            return state.DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", tx.GetHash().ToString().c_str()),\n+            return state.DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", tx.GetHash().ToString()),\n                              REJECT_INVALID, \"fee < 0\");\n         nFees += nTxFee;\n         if (!MoneyRange(nFees))\n@@ -1766,8 +1766,8 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     reverse(vConnect.begin(), vConnect.end());\n \n     if (vDisconnect.size() > 0) {\n-        LogPrintf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s...\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().c_str());\n-        LogPrintf(\"REORGANIZE: Connect %\"PRIszu\" blocks; ...%s\\n\", vConnect.size(), pindexNew->GetBlockHash().ToString().c_str());\n+        LogPrintf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s...\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString());\n+        LogPrintf(\"REORGANIZE: Connect %\"PRIszu\" blocks; ...%s\\n\", vConnect.size(), pindexNew->GetBlockHash().ToString());\n     }\n \n     // Disconnect shorter branch\n@@ -1778,7 +1778,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n             return state.Abort(_(\"Failed to read block\"));\n         int64_t nStart = GetTimeMicros();\n         if (!DisconnectBlock(block, state, pindex, view))\n-            return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().c_str());\n+            return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString());\n         if (fBenchmark)\n             LogPrintf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n@@ -1802,7 +1802,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n                 InvalidChainFound(pindexNew);\n                 InvalidBlockFound(pindex);\n             }\n-            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().c_str());\n+            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString());\n         }\n         if (fBenchmark)\n             LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n@@ -1868,8 +1868,8 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     nTimeBestReceived = GetTime();\n     mempool.AddTransactionsUpdated(1);\n     LogPrintf(\"SetBestChain: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n-      chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str(),\n+      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n+      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n       Checkpoints::GuessVerificationProgress(chainActive.Tip()));\n \n     // Check the version of the last 100 blocks to see if we need to upgrade:\n@@ -1907,7 +1907,7 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AddToBlockIndex() : %s already exists\", hash.ToString().c_str()));\n+        return state.Invalid(error(\"AddToBlockIndex() : %s already exists\", hash.ToString()));\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n@@ -1970,7 +1970,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n         }\n     } else {\n         while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n-            LogPrintf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n+            LogPrintf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString());\n             FlushBlockFile(true);\n             nLastBlockFile++;\n             infoLastBlockFile.SetNull();\n@@ -2252,9 +2252,9 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n     // Check for duplicate\n     uint256 hash = pblock->GetHash();\n     if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().c_str()));\n+        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString()));\n     if (mapOrphanBlocks.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().c_str()));\n+        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString()));\n \n     // Preliminary checks\n     if (!CheckBlock(*pblock, state))\n@@ -2285,7 +2285,7 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n     // If we don't already have its previous block, shunt it off to holding area until we get it\n     if (pblock->hashPrevBlock != 0 && !mapBlockIndex.count(pblock->hashPrevBlock))\n     {\n-        LogPrintf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().c_str());\n+        LogPrintf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString());\n \n         // Accept orphans as long as there is a node to request its parents from\n         if (pfrom) {\n@@ -2502,7 +2502,7 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n \n bool AbortNode(const std::string &strMessage) {\n     strMiscWarning = strMessage;\n-    LogPrintf(\"*** %s\\n\", strMessage.c_str());\n+    LogPrintf(\"*** %s\\n\", strMessage);\n     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_ERROR);\n     StartShutdown();\n     return false;\n@@ -2529,12 +2529,12 @@ FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n     if (!file && !fReadOnly)\n         file = fopen(path.string().c_str(), \"wb+\");\n     if (!file) {\n-        LogPrintf(\"Unable to open file %s\\n\", path.string().c_str());\n+        LogPrintf(\"Unable to open file %s\\n\", path.string());\n         return NULL;\n     }\n     if (pos.nPos) {\n         if (fseek(file, pos.nPos, SEEK_SET)) {\n-            LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string().c_str());\n+            LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string());\n             fclose(file);\n             return NULL;\n         }\n@@ -2601,7 +2601,7 @@ bool static LoadBlockIndexDB()\n     pblocktree->ReadLastBlockFile(nLastBlockFile);\n     LogPrintf(\"LoadBlockIndexDB(): last block file = %i\\n\", nLastBlockFile);\n     if (pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        LogPrintf(\"LoadBlockIndexDB(): last block file info: %s\\n\", infoLastBlockFile.ToString().c_str());\n+        LogPrintf(\"LoadBlockIndexDB(): last block file info: %s\\n\", infoLastBlockFile.ToString());\n \n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n@@ -2618,8 +2618,8 @@ bool static LoadBlockIndexDB()\n         return true;\n     chainActive.SetTip(it->second);\n     LogPrintf(\"LoadBlockIndexDB(): hashBestChain=%s  height=%d date=%s\\n\",\n-        chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(),\n-        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());\n+        chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n+        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()));\n \n     return true;\n }\n@@ -2649,24 +2649,24 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n         CBlock block;\n         // check level 0: read from disk\n         if (!ReadBlockFromDisk(block, pindex))\n-            return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+            return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         // check level 1: verify block validity\n         if (nCheckLevel >= 1 && !CheckBlock(block, state))\n-            return error(\"VerifyDB() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+            return error(\"VerifyDB() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         // check level 2: verify undo validity\n         if (nCheckLevel >= 2 && pindex) {\n             CBlockUndo undo;\n             CDiskBlockPos pos = pindex->GetUndoPos();\n             if (!pos.IsNull()) {\n                 if (!undo.ReadFromDisk(pos, pindex->pprev->GetBlockHash()))\n-                    return error(\"VerifyDB() : *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                    return error(\"VerifyDB() : *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             }\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.GetCacheSize() + pcoinsTip->GetCacheSize()) <= 2*nCoinCacheSize + 32000) {\n             bool fClean = true;\n             if (!DisconnectBlock(block, state, pindex, coins, &fClean))\n-                return error(\"VerifyDB() : *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                return error(\"VerifyDB() : *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             pindexState = pindex->pprev;\n             if (!fClean) {\n                 nGoodTransactions = 0;\n@@ -2686,9 +2686,9 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n             pindex = chainActive.Next(pindex);\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex))\n-                return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             if (!ConnectBlock(block, state, pindex, coins))\n-                return error(\"VerifyDB() : *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                return error(\"VerifyDB() : *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         }\n     }\n \n@@ -2796,7 +2796,7 @@ void PrintBlockTree()\n         LogPrintf(\"%d (blk%05u.dat:0x%x)  %s  tx %\"PRIszu\"\",\n             pindex->nHeight,\n             pindex->GetBlockPos().nFile, pindex->GetBlockPos().nPos,\n-            DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", block.GetBlockTime()).c_str(),\n+            DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", block.GetBlockTime()),\n             block.vtx.size());\n \n         // put the main time-chain first\n@@ -2999,10 +2999,10 @@ void Misbehaving(NodeId pnode, int howmuch)\n     state->nMisbehavior += howmuch;\n     if (state->nMisbehavior >= GetArg(\"-banscore\", 100))\n     {\n-        LogPrintf(\"Misbehaving: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", state->name.c_str(), state->nMisbehavior-howmuch, state->nMisbehavior);\n+        LogPrintf(\"Misbehaving: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n         state->fShouldBan = true;\n     } else\n-        LogPrintf(\"Misbehaving: %s (%d -> %d)\\n\", state->name.c_str(), state->nMisbehavior-howmuch, state->nMisbehavior);\n+        LogPrintf(\"Misbehaving: %s (%d -> %d)\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n }\n \n void static ProcessGetData(CNode* pfrom)\n@@ -3120,7 +3120,7 @@ void static ProcessGetData(CNode* pfrom)\n bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n {\n     RandAddSeedPerfmon();\n-    LogPrint(\"net\", \"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n+    LogPrint(\"net\", \"received: %s (%\"PRIszu\" bytes)\\n\", strCommand, vRecv.size());\n     if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -3149,7 +3149,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n+            LogPrintf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString(), pfrom->nVersion);\n             pfrom->PushMessage(\"reject\", strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION));\n             pfrom->fDisconnect = true;\n@@ -3180,7 +3180,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         // Disconnect if we connected to ourself\n         if (nNonce == nLocalHostNonce && nNonce > 1)\n         {\n-            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n+            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString());\n             pfrom->fDisconnect = true;\n             return true;\n         }\n@@ -3230,7 +3230,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->cleanSubVer.c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n+        LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->cleanSubVer, pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString(), addrFrom.ToString(), pfrom->addr.ToString());\n \n         AddTimeData(pfrom->addr, nTime);\n \n@@ -3349,7 +3349,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pfrom->AddInventoryKnown(inv);\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(\"net\", \"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n+            LogPrint(\"net\", \"  got inventory: %s  %s\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\");\n \n             if (!fAlreadyHave) {\n                 if (!fImporting && !fReindex)\n@@ -3362,7 +3362,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 // this situation and push another getblocks to continue.\n                 PushGetBlocks(pfrom, mapBlockIndex[inv.hash], uint256(0));\n                 if (fDebug)\n-                    LogPrintf(\"force request: %s\\n\", inv.ToString().c_str());\n+                    LogPrintf(\"force request: %s\\n\", inv.ToString());\n             }\n \n             // Track requests for our stuff\n@@ -3385,7 +3385,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             LogPrint(\"net\", \"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n \n         if ((fDebug && vInv.size() > 0) || (vInv.size() == 1))\n-            LogPrint(\"net\", \"received getdata for: %s\\n\", vInv[0].ToString().c_str());\n+            LogPrint(\"net\", \"received getdata for: %s\\n\", vInv[0].ToString());\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom);\n@@ -3407,20 +3407,20 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(\"net\", \"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str(), nLimit);\n+        LogPrint(\"net\", \"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString(), nLimit);\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n-                LogPrint(\"net\", \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                LogPrint(\"net\", \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n             }\n             pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n             if (--nLimit <= 0)\n             {\n                 // When this block is requested, we'll send an inv that'll make them\n                 // getblocks the next batch of inventory.\n-                LogPrint(\"net\", \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                LogPrint(\"net\", \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 pfrom->hashContinue = pindex->GetBlockHash();\n                 break;\n             }\n@@ -3456,7 +3456,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n         int nLimit = 2000;\n-        LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str());\n+        LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -3491,8 +3491,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n \n             LogPrint(\"mempool\", \"AcceptToMemoryPool: %s %s : accepted %s (poolsz %\"PRIszu\")\\n\",\n-                pfrom->addr.ToString().c_str(), pfrom->cleanSubVer.c_str(),\n-                tx.GetHash().ToString().c_str(),\n+                pfrom->addr.ToString(), pfrom->cleanSubVer,\n+                tx.GetHash().ToString(),\n                 mempool.mapTx.size());\n \n             // Recursively process any orphan transactions that depended on this one\n@@ -3513,7 +3513,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n                     if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))\n                     {\n-                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString().c_str());\n+                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx, orphanHash);\n                         mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanHash));\n                         vWorkQueue.push_back(orphanHash);\n@@ -3523,7 +3523,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     {\n                         // invalid or too-little-fee orphan\n                         vEraseQueue.push_back(orphanHash);\n-                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString().c_str());\n+                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                     }\n                     mempool.check(pcoinsTip);\n                 }\n@@ -3544,9 +3544,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n         { \n-            LogPrint(\"mempool\", \"%s from %s %s was not accepted into the memory pool: %s\\n\", tx.GetHash().ToString().c_str(), \n-                pfrom->addr.ToString().c_str(), pfrom->cleanSubVer.c_str(),\n-                state.GetRejectReason().c_str());\n+            LogPrint(\"mempool\", \"%s from %s %s was not accepted into the memory pool: %s\\n\", tx.GetHash().ToString(),\n+                pfrom->addr.ToString(), pfrom->cleanSubVer,\n+                state.GetRejectReason());\n             pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),\n                                state.GetRejectReason(), inv.hash);\n             if (nDoS > 0)\n@@ -3560,7 +3560,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CBlock block;\n         vRecv >> block;\n \n-        LogPrint(\"net\", \"received block %s\\n\", block.GetHash().ToString().c_str());\n+        LogPrint(\"net\", \"received block %s\\n\", block.GetHash().ToString());\n         // block.print();\n \n         CInv inv(MSG_BLOCK, block.GetHash());\n@@ -3682,9 +3682,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         if (!(sProblem.empty())) {\n             LogPrint(\"net\", \"pong %s %s: %s, %\"PRIx64\" expected, %\"PRIx64\" received, %\"PRIszu\" bytes\\n\",\n-                pfrom->addr.ToString().c_str(),\n-                pfrom->cleanSubVer.c_str(),\n-                sProblem.c_str(),\n+                pfrom->addr.ToString(),\n+                pfrom->cleanSubVer,\n+                sProblem,\n                 pfrom->nPingNonceSent,\n                 nonce,\n                 nAvail);\n@@ -3793,7 +3793,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             // Truncate to reasonable length and sanitize before printing:\n             string s = ss.str();\n             if (s.size() > 111) s.erase(111, string::npos);\n-            LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(s).c_str());\n+            LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(s));\n         }\n     }\n \n@@ -3866,7 +3866,7 @@ bool ProcessMessages(CNode* pfrom)\n         CMessageHeader& hdr = msg.hdr;\n         if (!hdr.IsValid())\n         {\n-            LogPrintf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n+            LogPrintf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand());\n             continue;\n         }\n         string strCommand = hdr.GetCommand();\n@@ -3882,7 +3882,7 @@ bool ProcessMessages(CNode* pfrom)\n         if (nChecksum != hdr.nChecksum)\n         {\n             LogPrintf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n-               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n+               strCommand, nMessageSize, nChecksum, hdr.nChecksum);\n             continue;\n         }\n \n@@ -3899,12 +3899,12 @@ bool ProcessMessages(CNode* pfrom)\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n-                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n+                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand, nMessageSize, e.what());\n             }\n             else if (strstr(e.what(), \"size too large\"))\n             {\n                 // Allow exceptions from over-long size\n-                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n+                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand, nMessageSize, e.what());\n             }\n             else\n             {\n@@ -3921,7 +3921,7 @@ bool ProcessMessages(CNode* pfrom)\n         }\n \n         if (!fRet)\n-            LogPrintf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n+            LogPrintf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand, nMessageSize);\n \n         break;\n     }\n@@ -4027,7 +4027,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n         if (State(pto->GetId())->fShouldBan) {\n             if (pto->addr.IsLocal())\n-                LogPrintf(\"Warning: not banning local node %s!\\n\", pto->addr.ToString().c_str());\n+                LogPrintf(\"Warning: not banning local node %s!\\n\", pto->addr.ToString());\n             else {\n                 pto->fDisconnect = true;\n                 CNode::Ban(pto->addr);\n@@ -4109,7 +4109,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             if (!AlreadyHave(inv))\n             {\n                 if (fDebug)\n-                    LogPrint(\"net\", \"sending getdata: %s\\n\", inv.ToString().c_str());\n+                    LogPrint(\"net\", \"sending getdata: %s\\n\", inv.ToString());\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "ca3b65a11ad02e4cd2fc5ee84d56ec81f1ca7cb4",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -70,9 +70,9 @@ class COrphan\n     void print() const\n     {\n         LogPrintf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n-               ptx->GetHash().ToString().c_str(), dPriority, dFeePerKb);\n+               ptx->GetHash().ToString(), dPriority, dFeePerKb);\n         BOOST_FOREACH(uint256 hash, setDependsOn)\n-            LogPrintf(\"   setDependsOn %s\\n\", hash.ToString().c_str());\n+            LogPrintf(\"   setDependsOn %s\\n\", hash.ToString());\n     }\n };\n \n@@ -296,7 +296,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             if (fPrintPriority)\n             {\n                 LogPrintf(\"priority %.1f feeperkb %.1f txid %s\\n\",\n-                       dPriority, dFeePerKb, tx.GetHash().ToString().c_str());\n+                       dPriority, dFeePerKb, tx.GetHash().ToString());\n             }\n \n             // Add transactions that depend on this one to the priority queue\n@@ -470,9 +470,9 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n \n     //// debug print\n     LogPrintf(\"BitcoinMiner:\\n\");\n-    LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n+    LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex(), hashTarget.GetHex());\n     pblock->print();\n-    LogPrintf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n+    LogPrintf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue));\n \n     // Found a solution\n     {"
      },
      {
        "sha": "3d967004c539fa2b28cdcd4cad5829bbf9b8db28",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -227,7 +227,7 @@ bool AddLocal(const CService& addr, int nScore)\n     if (IsLimited(addr))\n         return false;\n \n-    LogPrintf(\"AddLocal(%s,%i)\\n\", addr.ToString().c_str(), nScore);\n+    LogPrintf(\"AddLocal(%s,%i)\\n\", addr.ToString(), nScore);\n \n     {\n         LOCK(cs_mapLocalHost);\n@@ -304,7 +304,7 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n {\n     SOCKET hSocket;\n     if (!ConnectSocket(addrConnect, hSocket))\n-        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n+        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString());\n \n     send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n \n@@ -335,7 +335,7 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n             while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                 strLine.resize(strLine.size()-1);\n             CService addr(strLine,0,true);\n-            LogPrintf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n+            LogPrintf(\"GetMyExternalIP() received [%s] %s\\n\", strLine, addr.ToString());\n             if (!addr.IsValid() || !addr.IsRoutable())\n                 return false;\n             ipRet.SetIP(addr);\n@@ -410,7 +410,7 @@ void ThreadGetMyExternalIP()\n     CNetAddr addrLocalHost;\n     if (GetMyExternalIP(addrLocalHost))\n     {\n-        LogPrintf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n+        LogPrintf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP());\n         AddLocal(addrLocalHost, LOCAL_HTTP);\n     }\n }\n@@ -477,7 +477,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n \n     /// debug print\n     LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\",\n-        pszDest ? pszDest : addrConnect.ToString().c_str(),\n+        pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n     // Connect\n@@ -486,7 +486,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n     {\n         addrman.Attempt(addrConnect);\n \n-        LogPrint(\"net\", \"connected %s\\n\", pszDest ? pszDest : addrConnect.ToString().c_str());\n+        LogPrint(\"net\", \"connected %s\\n\", pszDest ? pszDest : addrConnect.ToString());\n \n         // Set to non-blocking\n #ifdef WIN32\n@@ -521,7 +521,7 @@ void CNode::CloseSocketDisconnect()\n     fDisconnect = true;\n     if (hSocket != INVALID_SOCKET)\n     {\n-        LogPrint(\"net\", \"disconnecting node %s\\n\", addrName.c_str());\n+        LogPrint(\"net\", \"disconnecting node %s\\n\", addrName);\n         closesocket(hSocket);\n         hSocket = INVALID_SOCKET;\n     }\n@@ -550,7 +550,7 @@ void CNode::PushVersion()\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n     RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n-    LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n+    LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), addr.ToString());\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                 nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n }\n@@ -952,12 +952,12 @@ void ThreadSocketHandler()\n             }\n             else if (CNode::IsBanned(addr))\n             {\n-                LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString().c_str());\n+                LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n                 closesocket(hSocket);\n             }\n             else\n             {\n-                LogPrint(\"net\", \"accepted connection %s\\n\", addr.ToString().c_str());\n+                LogPrint(\"net\", \"accepted connection %s\\n\", addr.ToString());\n                 CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                 pnode->AddRef();\n                 {\n@@ -1138,7 +1138,7 @@ void ThreadMapPort()\n \n                 if(r!=UPNPCOMMAND_SUCCESS)\n                     LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n-                        port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n+                        port, port, lanaddr, r, strupnperror(r));\n                 else\n                     LogPrintf(\"UPnP Port Mapping successful.\\n\");;\n \n@@ -1592,16 +1592,16 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     socklen_t len = sizeof(sockaddr);\n     if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n     {\n-        strError = strprintf(\"Error: bind address family for %s not supported\", addrBind.ToString().c_str());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        strError = strprintf(\"Error: bind address family for %s not supported\", addrBind.ToString());\n+        LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n     SOCKET hListenSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n     if (hListenSocket == INVALID_SOCKET)\n     {\n         strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n@@ -1625,7 +1625,7 @@ bool BindListenPort(const CService &addrBind, string& strError)\n #endif\n     {\n         strError = strprintf(\"Error: Couldn't set properties on socket for incoming connections (error %d)\", WSAGetLastError());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n@@ -1653,19 +1653,19 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n-            strError = strprintf(_(\"Unable to bind to %s on this computer. Bitcoin is probably already running.\"), addrBind.ToString().c_str());\n+            strError = strprintf(_(\"Unable to bind to %s on this computer. Bitcoin is probably already running.\"), addrBind.ToString());\n         else\n-            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %d, %s)\"), addrBind.ToString().c_str(), nErr, strerror(nErr));\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %d, %s)\"), addrBind.ToString(), nErr, strerror(nErr));\n+        LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n-    LogPrintf(\"Bound to %s\\n\", addrBind.ToString().c_str());\n+    LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n \n     // Listen for incoming connections\n     if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n     {\n         strError = strprintf(\"Error: Listening for incoming connections failed (listen returned error %d)\", WSAGetLastError());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n \n@@ -1712,15 +1712,15 @@ void static Discover(boost::thread_group& threadGroup)\n                 struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                 CNetAddr addr(s4->sin_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n-                    LogPrintf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n+                    LogPrintf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString());\n             }\n #ifdef USE_IPV6\n             else if (ifa->ifa_addr->sa_family == AF_INET6)\n             {\n                 struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                 CNetAddr addr(s6->sin6_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n-                    LogPrintf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n+                    LogPrintf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString());\n             }\n #endif\n         }"
      },
      {
        "sha": "5ec760be3809e0fecc7b0f7b816ba5557f8e26a3",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -171,7 +171,7 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n \n bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n {\n-    LogPrintf(\"SOCKS4 connecting %s\\n\", addrDest.ToString().c_str());\n+    LogPrintf(\"SOCKS4 connecting %s\\n\", addrDest.ToString());\n     if (!addrDest.IsIPv4())\n     {\n         closesocket(hSocket);\n@@ -209,13 +209,13 @@ bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n             LogPrintf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n         return false;\n     }\n-    LogPrintf(\"SOCKS4 connected %s\\n\", addrDest.ToString().c_str());\n+    LogPrintf(\"SOCKS4 connected %s\\n\", addrDest.ToString());\n     return true;\n }\n \n bool static Socks5(string strDest, int port, SOCKET& hSocket)\n {\n-    LogPrintf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n+    LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n     if (strDest.size() > 255)\n     {\n         closesocket(hSocket);\n@@ -311,7 +311,7 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         closesocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    LogPrintf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n+    LogPrintf(\"SOCKS5 connected %s\\n\", strDest);\n     return true;\n }\n \n@@ -326,7 +326,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n #endif\n     socklen_t len = sizeof(sockaddr);\n     if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n-        LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString().c_str());\n+        LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString());\n         return false;\n     }\n \n@@ -365,13 +365,13 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n             if (nRet == 0)\n             {\n-                LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString().c_str());\n+                LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString());\n                 closesocket(hSocket);\n                 return false;\n             }\n             if (nRet == SOCKET_ERROR)\n             {\n-                LogPrintf(\"select() for %s failed: %i\\n\", addrConnect.ToString().c_str(), WSAGetLastError());\n+                LogPrintf(\"select() for %s failed: %i\\n\", addrConnect.ToString(), WSAGetLastError());\n                 closesocket(hSocket);\n                 return false;\n             }\n@@ -382,13 +382,13 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, &nRet, &nRetSize) == SOCKET_ERROR)\n #endif\n             {\n-                LogPrintf(\"getsockopt() for %s failed: %i\\n\", addrConnect.ToString().c_str(), WSAGetLastError());\n+                LogPrintf(\"getsockopt() for %s failed: %i\\n\", addrConnect.ToString(), WSAGetLastError());\n                 closesocket(hSocket);\n                 return false;\n             }\n             if (nRet != 0)\n             {\n-                LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString().c_str(), strerror(nRet));\n+                LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString(), strerror(nRet));\n                 closesocket(hSocket);\n                 return false;\n             }\n@@ -399,7 +399,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n         else\n #endif\n         {\n-            LogPrintf(\"connect() to %s failed: %i\\n\", addrConnect.ToString().c_str(), WSAGetLastError());\n+            LogPrintf(\"connect() to %s failed: %i\\n\", addrConnect.ToString(), WSAGetLastError());\n             closesocket(hSocket);\n             return false;\n         }\n@@ -895,7 +895,7 @@ uint64_t CNetAddr::GetHash() const\n \n void CNetAddr::print() const\n {\n-    LogPrintf(\"CNetAddr(%s)\\n\", ToString().c_str());\n+    LogPrintf(\"CNetAddr(%s)\\n\", ToString());\n }\n \n // private extensions to enum Network, only returned by GetExtNetwork,\n@@ -1136,7 +1136,7 @@ std::string CService::ToString() const\n \n void CService::print() const\n {\n-    LogPrintf(\"CService(%s)\\n\", ToString().c_str());\n+    LogPrintf(\"CService(%s)\\n\", ToString());\n }\n \n void CService::SetPort(unsigned short portIn)"
      },
      {
        "sha": "f176e0eb59a46f337d6e3887f8af97f3c1d5f71d",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -29,14 +29,14 @@ static bool noui_ThreadSafeMessageBox(const std::string& message, const std::str\n         strCaption += caption; // Use supplied caption (can be empty)\n     }\n \n-    LogPrintf(\"%s: %s\\n\", strCaption.c_str(), message.c_str());\n+    LogPrintf(\"%s: %s\\n\", strCaption, message);\n     fprintf(stderr, \"%s: %s\\n\", strCaption.c_str(), message.c_str());\n     return false;\n }\n \n static void noui_InitMessage(const std::string &message)\n {\n-    LogPrintf(\"init message: %s\\n\", message.c_str());\n+    LogPrintf(\"init message: %s\\n\", message);\n }\n \n void noui_connect()"
      },
      {
        "sha": "cc98e7e40c5d9b59e15c51c0d06a8748910f4498",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -67,7 +67,7 @@ bool CMessageHeader::IsValid() const\n     // Message size\n     if (nMessageSize > MAX_SIZE)\n     {\n-        LogPrintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n+        LogPrintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand(), nMessageSize);\n         return false;\n     }\n \n@@ -118,7 +118,7 @@ CInv::CInv(const std::string& strType, const uint256& hashIn)\n         }\n     }\n     if (i == ARRAYLEN(ppszTypeName))\n-        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n+        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType));\n     hash = hashIn;\n }\n \n@@ -141,11 +141,11 @@ const char* CInv::GetCommand() const\n \n std::string CInv::ToString() const\n {\n-    return strprintf(\"%s %s\", GetCommand(), hash.ToString().c_str());\n+    return strprintf(\"%s %s\", GetCommand(), hash.ToString());\n }\n \n void CInv::print() const\n {\n-    LogPrintf(\"CInv(%s)\\n\", ToString().c_str());\n+    LogPrintf(\"CInv(%s)\\n\", ToString());\n }\n "
      },
      {
        "sha": "e274b7626a419a1f12d0d347d8948b5f33c86995",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -62,7 +62,7 @@ Q_DECLARE_METATYPE(bool*)\n \n static void InitMessage(const std::string &message)\n {\n-    LogPrintf(\"init message: %s\\n\", message.c_str());\n+    LogPrintf(\"init message: %s\\n\", message);\n }\n \n /*"
      },
      {
        "sha": "726f23011bca116d987e4eaa3ebb27e84907c283",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -178,7 +178,7 @@ Value importwallet(const Array& params, bool fHelp)\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID keyid = pubkey.GetID();\n         if (pwalletMain->HaveKey(keyid)) {\n-            LogPrintf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString().c_str());\n+            LogPrintf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString());\n             continue;\n         }\n         int64_t nTime = DecodeDumpTime(vstr[1]);\n@@ -196,7 +196,7 @@ Value importwallet(const Array& params, bool fHelp)\n                 fLabel = true;\n             }\n         }\n-        LogPrintf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString().c_str());\n+        LogPrintf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString());\n         if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n             fGood = false;\n             continue;\n@@ -290,10 +290,10 @@ Value dumpwallet(const Array& params, bool fHelp)\n     std::sort(vKeyBirth.begin(), vKeyBirth.end());\n \n     // produce output\n-    file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD.c_str(), CLIENT_DATE.c_str());\n-    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()).c_str());\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString().c_str());\n-    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->nTime).c_str());\n+    file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD, CLIENT_DATE);\n+    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()));\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n+    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->nTime));\n     file << \"\\n\";\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;\n@@ -302,11 +302,11 @@ Value dumpwallet(const Array& params, bool fHelp)\n         CKey key;\n         if (pwalletMain->GetKey(keyid, key)) {\n             if (pwalletMain->mapAddressBook.count(keyid)) {\n-                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString().c_str(), strTime.c_str(), EncodeDumpString(pwalletMain->mapAddressBook[keyid].name).c_str(), strAddr.c_str());\n+                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, EncodeDumpString(pwalletMain->mapAddressBook[keyid].name), strAddr);\n             } else if (setKeyPool.count(keyid)) {\n-                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(key).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n+                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n             } else {\n-                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(key).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n+                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(key).ToString(), strTime, strAddr);\n             }\n         }\n     }"
      },
      {
        "sha": "1d3237dfc134786cfa9e66310e58e7059b423d94",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -199,11 +199,11 @@ CScript _createmultisig(const Array& params)\n             CKeyID keyID;\n             if (!address.GetKeyID(keyID))\n                 throw runtime_error(\n-                    strprintf(\"%s does not refer to a key\",ks.c_str()));\n+                    strprintf(\"%s does not refer to a key\",ks));\n             CPubKey vchPubKey;\n             if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n                 throw runtime_error(\n-                    strprintf(\"no full public key for address %s\",ks.c_str()));\n+                    strprintf(\"no full public key for address %s\",ks));\n             if (!vchPubKey.IsFullyValid())\n                 throw runtime_error(\" Invalid public key: \"+ks);\n             pubkeys[i] = vchPubKey;"
      },
      {
        "sha": "0632bdae6fb91b288ec74b45f7f2c47a65f635ab",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -81,7 +81,7 @@ string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n             \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n             \"</HEAD>\\r\\n\"\n             \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n-            \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n+            \"</HTML>\\r\\n\", rfc1123Time(), FormatFullVersion());\n     const char *cStatus;\n          if (nStatus == HTTP_OK) cStatus = \"OK\";\n     else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n@@ -100,11 +100,11 @@ string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n             \"%s\",\n         nStatus,\n         cStatus,\n-        rfc1123Time().c_str(),\n+        rfc1123Time(),\n         keepalive ? \"keep-alive\" : \"close\",\n         strMsg.size(),\n-        FormatFullVersion().c_str(),\n-        strMsg.c_str());\n+        FormatFullVersion(),\n+        strMsg);\n }\n \n bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,"
      },
      {
        "sha": "ef43ecdeb10b5774b9d72c5b00c0749dea16a855",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -69,12 +69,12 @@ void RPCTypeCheck(const Object& o,\n     {\n         const Value& v = find_value(o, t.first);\n         if (!fAllowNull && v.type() == null_type)\n-            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first.c_str()));\n+            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first));\n \n         if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n         {\n             string err = strprintf(\"Expected type %s for %s, got %s\",\n-                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n+                                   Value_type_name[t.second], t.first, Value_type_name[v.type()]);\n             throw JSONRPCError(RPC_TYPE_ERROR, err);\n         }\n     }\n@@ -176,7 +176,7 @@ string CRPCTable::help(string strCommand) const\n         }\n     }\n     if (strRet == \"\")\n-        strRet = strprintf(\"help: unknown command: %s\\n\", strCommand.c_str());\n+        strRet = strprintf(\"help: unknown command: %s\\n\", strCommand);\n     strRet = strRet.substr(0,strRet.size()-1);\n     return strRet;\n }\n@@ -513,9 +513,9 @@ void StartRPCThreads()\n               \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"\n               \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n               \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n-                strWhatAmI.c_str(),\n-                GetConfigFile().string().c_str(),\n-                EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32).c_str()),\n+                strWhatAmI,\n+                GetConfigFile().string(),\n+                EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32)),\n                 \"\", CClientUIInterface::MSG_ERROR);\n         StartShutdown();\n         return;\n@@ -534,12 +534,12 @@ void StartRPCThreads()\n         filesystem::path pathCertFile(GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\"));\n         if (!pathCertFile.is_complete()) pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;\n         if (filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string().c_str());\n+        else LogPrintf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string());\n \n         filesystem::path pathPKFile(GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\"));\n         if (!pathPKFile.is_complete()) pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;\n         if (filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string().c_str());\n+        else LogPrintf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string());\n \n         string strCiphers = GetArg(\"-rpcsslciphers\", \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\");\n         SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n@@ -683,7 +683,7 @@ void JSONRequest::parse(const Value& valRequest)\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n     if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n-        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n+        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", strMethod);\n \n     // Parse params\n     Value valParams = find_value(request, \"params\");\n@@ -758,7 +758,7 @@ void ServiceConnection(AcceptedConnection *conn)\n         }\n         if (!HTTPAuthorized(mapHeaders))\n         {\n-            LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string().c_str());\n+            LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string());\n             /* Deter brute-forcing short passwords.\n                If this results in a DoS the user really\n                shouldn't have their RPC port exposed. */"
      },
      {
        "sha": "8f713807f7f864973b815a7ad4fbf988966d3042",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -65,14 +65,14 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n     {\n         if (i.first == mismatch.first) LogPrintf(\" (1)\");\n         if (i.first == mismatch.second) LogPrintf(\" (2)\");\n-        LogPrintf(\" %s\\n\", i.second.ToString().c_str());\n+        LogPrintf(\" %s\\n\", i.second.ToString());\n     }\n     LogPrintf(\"Current lock order is:\\n\");\n     BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s1)\n     {\n         if (i.first == mismatch.first) LogPrintf(\" (1)\");\n         if (i.first == mismatch.second) LogPrintf(\" (2)\");\n-        LogPrintf(\" %s\\n\", i.second.ToString().c_str());\n+        LogPrintf(\" %s\\n\", i.second.ToString());\n     }\n }\n \n@@ -81,7 +81,7 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n     if (lockstack.get() == NULL)\n         lockstack.reset(new LockStack);\n \n-    LogPrint(\"lock\", \"Locking: %s\\n\", locklocation.ToString().c_str());\n+    LogPrint(\"lock\", \"Locking: %s\\n\", locklocation.ToString());\n     dd_mutex.lock();\n \n     (*lockstack).push_back(std::make_pair(c, locklocation));\n@@ -111,7 +111,7 @@ static void pop_lock()\n     if (fDebug)\n     {\n         const CLockLocation& locklocation = (*lockstack).rbegin()->second;\n-        LogPrint(\"lock\", \"Unlocked: %s\\n\", locklocation.ToString().c_str());\n+        LogPrint(\"lock\", \"Unlocked: %s\\n\", locklocation.ToString());\n     }\n     dd_mutex.lock();\n     (*lockstack).pop_back();\n@@ -140,7 +140,7 @@ void AssertLockHeldInternal(const char *pszName, const char* pszFile, int nLine,\n {\n     BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)&i, *lockstack)\n         if (i.first == cs) return;\n-    LogPrintf(\"Lock %s not held in %s:%i; locks held:\\n%s\", pszName, pszFile, nLine, LocksHeld().c_str());\n+    LogPrintf(\"Lock %s not held in %s:%i; locks held:\\n%s\", pszName, pszFile, nLine, LocksHeld());\n     assert(0);\n }\n "
      },
      {
        "sha": "bd6dae0f6ea7ca8e78afdcd24d9cf8ce2cd977fc",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -219,7 +219,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 pindexNew->nTx            = diskindex.nTx;\n \n                 if (!pindexNew->CheckIndex())\n-                    return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n+                    return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString());\n \n                 pcursor->Next();\n             } else {"
      },
      {
        "sha": "255226ea1ea31122f0db37e1439a368511a83e91",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -945,13 +945,13 @@ static std::string FormatException(std::exception* pex, const char* pszThread)\n void LogException(std::exception* pex, const char* pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n-    LogPrintf(\"\\n%s\", message.c_str());\n+    LogPrintf(\"\\n%s\", message);\n }\n \n void PrintException(std::exception* pex, const char* pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n-    LogPrintf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n+    LogPrintf(\"\\n\\n************************\\n%s\\n\", message);\n     fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n     strMiscWarning = message;\n     throw;\n@@ -960,7 +960,7 @@ void PrintException(std::exception* pex, const char* pszThread)\n void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n-    LogPrintf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n+    LogPrintf(\"\\n\\n************************\\n%s\\n\", message);\n     fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n     strMiscWarning = message;\n }\n@@ -1305,7 +1305,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n                     fDone = true;\n                     string strMessage = _(\"Warning: Please check that your computer's date and time are correct! If your clock is wrong Bitcoin will not work properly.\");\n                     strMiscWarning = strMessage;\n-                    LogPrintf(\"*** %s\\n\", strMessage.c_str());\n+                    LogPrintf(\"*** %s\\n\", strMessage);\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n                 }\n             }\n@@ -1408,7 +1408,7 @@ void runCommand(std::string strCommand)\n {\n     int nErr = ::system(strCommand.c_str());\n     if (nErr)\n-        LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n+        LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n void RenameThread(const char* name)"
      },
      {
        "sha": "9648f6f88ded9f362caf30368b0f1e90995eafc9",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -381,10 +381,10 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n             {\n                 CWalletTx& wtx = (*mi).second;\n                 if (txin.prevout.n >= wtx.vout.size())\n-                    LogPrintf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n+                    LogPrintf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString());\n                 else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                 {\n-                    LogPrintf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                    LogPrintf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()), wtx.GetHash().ToString());\n                     wtx.MarkSpent(txin.prevout.n);\n                     wtx.WriteToDisk();\n                     NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n@@ -460,8 +460,8 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n                 }\n                 else\n                     LogPrintf(\"AddToWallet() : found %s in block %s not in index\\n\",\n-                             wtxIn.GetHash().ToString().c_str(),\n-                             wtxIn.hashBlock.ToString().c_str());\n+                             wtxIn.GetHash().ToString(),\n+                             wtxIn.hashBlock.ToString());\n             }\n         }\n \n@@ -489,7 +489,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n         }\n \n         //// debug print\n-        LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n+        LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n \n         // Write to disk\n         if (fInsertedNew || fUpdated)\n@@ -690,7 +690,7 @@ void CWalletTx::GetAmounts(list<pair<CTxDestination, int64_t> >& listReceived,\n         if (!ExtractDestination(txout.scriptPubKey, address))\n         {\n             LogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n-                     this->GetHash().ToString().c_str());\n+                     this->GetHash().ToString());\n             address = CNoDestination();\n         }\n \n@@ -883,7 +883,7 @@ void CWallet::ReacceptWalletTransactions()\n                 }\n                 if (fUpdated)\n                 {\n-                    LogPrintf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                    LogPrintf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()), wtx.GetHash().ToString());\n                     wtx.MarkDirty();\n                     wtx.WriteToDisk();\n                 }\n@@ -919,7 +919,7 @@ void CWalletTx::RelayWalletTransaction()\n     {\n         if (GetDepthInMainChain() == 0) {\n             uint256 hash = GetHash();\n-            LogPrintf(\"Relaying wtx %s\\n\", hash.ToString().c_str());\n+            LogPrintf(\"Relaying wtx %s\\n\", hash.ToString());\n             RelayTransaction((CTransaction)*this, hash);\n         }\n     }\n@@ -1186,8 +1186,8 @@ bool CWallet::SelectCoinsMinConf(int64_t nTargetValue, int nConfMine, int nConfT\n         LogPrint(\"selectcoins\", \"SelectCoins() best subset: \");\n         for (unsigned int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n-                LogPrint(\"selectcoins\", \"%s \", FormatMoney(vValue[i].first).c_str());\n-        LogPrint(\"selectcoins\", \"total %s\\n\", FormatMoney(nBest).c_str());\n+                LogPrint(\"selectcoins\", \"%s \", FormatMoney(vValue[i].first));\n+        LogPrint(\"selectcoins\", \"total %s\\n\", FormatMoney(nBest));\n     }\n \n     return true;\n@@ -1396,7 +1396,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n {\n     {\n         LOCK2(cs_main, cs_wallet);\n-        LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n+        LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.ToString());\n         {\n             // This is only to keep the database open to defeat the auto-flush for the\n             // duration of this scope.  This is the only place where this optimization\n@@ -1451,15 +1451,15 @@ string CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNe\n     if (IsLocked())\n     {\n         string strError = _(\"Error: Wallet locked, unable to create transaction!\");\n-        LogPrintf(\"SendMoney() : %s\", strError.c_str());\n+        LogPrintf(\"SendMoney() : %s\", strError);\n         return strError;\n     }\n     string strError;\n     if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired, strError))\n     {\n         if (nValue + nFeeRequired > GetBalance())\n-            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\"), FormatMoney(nFeeRequired).c_str());\n-        LogPrintf(\"SendMoney() : %s\\n\", strError.c_str());\n+            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\"), FormatMoney(nFeeRequired));\n+        LogPrintf(\"SendMoney() : %s\\n\", strError);\n         return strError;\n     }\n "
      },
      {
        "sha": "d912317a558397187211875442b73625e0236c78",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9d134bf95cb6a2ce9623c7e6a3535432a61af2/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=7d9d134bf95cb6a2ce9623c7e6a3535432a61af2",
        "patch": "@@ -374,12 +374,12 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                     char fUnused;\n                     ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                     strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n-                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n+                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount, hash.ToString());\n                     wtx.fTimeReceivedIsTxTime = fTmp;\n                 }\n                 else\n                 {\n-                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n+                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString());\n                     wtx.fTimeReceivedIsTxTime = 0;\n                 }\n                 wss.vWalletUpgrade.push_back(hash);\n@@ -390,12 +390,12 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n \n             pwallet->mapWallet[hash] = wtx;\n             //// debug print\n-            //LogPrintf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n+            //LogPrintf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString());\n             //LogPrintf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n             //    wtx.vout[0].nValue,\n-            //    DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n-            //    wtx.hashBlock.ToString().c_str(),\n-            //    wtx.mapValue[\"message\"].c_str());\n+            //    DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", wtx.GetBlockTime()),\n+            //    wtx.hashBlock.ToString(),\n+            //    wtx.mapValue[\"message\"]);\n         }\n         else if (strType == \"acentry\")\n         {\n@@ -646,7 +646,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n                 }\n             }\n             if (!strErr.empty())\n-                LogPrintf(\"%s\\n\", strErr.c_str());\n+                LogPrintf(\"%s\\n\", strErr);\n         }\n         pcursor->close();\n     }\n@@ -779,10 +779,10 @@ bool BackupWallet(const CWallet& wallet, const string& strDest)\n #else\n                     filesystem::copy_file(pathSrc, pathDest);\n #endif\n-                    LogPrintf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n+                    LogPrintf(\"copied wallet.dat to %s\\n\", pathDest.string());\n                     return true;\n                 } catch(const filesystem::filesystem_error &e) {\n-                    LogPrintf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string().c_str(), e.what());\n+                    LogPrintf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string(), e.what());\n                     return false;\n                 }\n             }\n@@ -810,18 +810,18 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n     int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                       newFilename.c_str(), DB_AUTO_COMMIT);\n     if (result == 0)\n-        LogPrintf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n+        LogPrintf(\"Renamed %s to %s\\n\", filename, newFilename);\n     else\n     {\n-        LogPrintf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n+        LogPrintf(\"Failed to rename %s to %s\\n\", filename, newFilename);\n         return false;\n     }\n \n     std::vector<CDBEnv::KeyValPair> salvagedData;\n     bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n     if (salvagedData.empty())\n     {\n-        LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n+        LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename);\n         return false;\n     }\n     LogPrintf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n@@ -836,7 +836,7 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n                             0);\n     if (ret > 0)\n     {\n-        LogPrintf(\"Cannot create database file %s\\n\", filename.c_str());\n+        LogPrintf(\"Cannot create database file %s\\n\", filename);\n         return false;\n     }\n     CWallet dummyWallet;\n@@ -856,7 +856,7 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n                 continue;\n             if (!fReadOK)\n             {\n-                LogPrintf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n+                LogPrintf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType, strErr);\n                 continue;\n             }\n         }"
      }
    ]
  }
]