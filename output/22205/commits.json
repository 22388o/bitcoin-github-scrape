[
  {
    "sha": "cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZjExMGQyYjlmNWFhNzJhODhkMWMyNmVkZmRkY2Q0MmFiMGNiNmI2",
    "commit": {
      "author": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T00:03:11Z"
      },
      "committer": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T00:03:11Z"
      },
      "message": "condensed main page into toc, added separate testing doc",
      "tree": {
        "sha": "42b279be97e8b1e580ca20bc2d46bf984b5d0329",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42b279be97e8b1e580ca20bc2d46bf984b5d0329"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6/comments",
    "author": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "46424e943c0b2e9d006ade6bfe3dc02f19c1d5c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46424e943c0b2e9d006ade6bfe3dc02f19c1d5c0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/46424e943c0b2e9d006ade6bfe3dc02f19c1d5c0"
      }
    ],
    "stats": {
      "total": 87,
      "additions": 30,
      "deletions": 57
    },
    "files": [
      {
        "sha": "62a70ee5a35f93804b33f03b646f33ce4604f023",
        "filename": "README.md",
        "status": "modified",
        "additions": 14,
        "deletions": 57,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
        "patch": "@@ -1,14 +1,12 @@\n-Bitcoin Core integration/staging tree\n+**Bitcoin Core Integration/Staging Tree**\n =====================================\n \n https://bitcoincore.org\n \n For an immediately usable, binary version of the Bitcoin Core software, see\n https://bitcoincore.org/en/download/.\n \n-Further information about Bitcoin Core is available in the [doc folder](/doc).\n-\n-What is Bitcoin?\n+**What is Bitcoin?**\n ----------------\n \n Bitcoin is an experimental digital currency that enables instant payments to\n@@ -17,66 +15,25 @@ with no central authority: managing transactions and issuing money are carried\n out collectively by the network. Bitcoin Core is the name of open source\n software which enables the use of this currency.\n \n-For more information read the original Bitcoin whitepaper.\n-\n-License\n--------\n-\n-Bitcoin Core is released under the terms of the MIT license. See [COPYING](COPYING) for more\n-information or see https://opensource.org/licenses/MIT.\n-\n-Development Process\n--------------------\n-\n-The `master` branch is regularly built (see `doc/build-*.md` for instructions) and tested, but it is not guaranteed to be\n-completely stable. [Tags](https://github.com/bitcoin/bitcoin/tags) are created\n-regularly from release branches to indicate new official, stable release versions of Bitcoin Core.\n-\n-The https://github.com/bitcoin-core/gui repository is used exclusively for the\n-development of the GUI. Its master branch is identical in all monotree\n-repositories. Release branches and tags do not exist, so please do not fork\n-that repository unless it is for development reasons.\n-\n-The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md)\n-and useful hints for developers can be found in [doc/developer-notes.md](doc/developer-notes.md).\n-\n-Testing\n--------\n-\n-Testing and code review is the bottleneck for development; we get more pull\n-requests than we can review and test on short notice. Please be patient and help out by testing\n-other people's pull requests, and remember this is a security-critical project where any mistake might cost people\n-lots of money.\n+For more information, read the original Bitcoin whitepaper.\n \n-### Automated Testing\n+[**Documents**](/doc) - Bitcoin Core Documentation \n \n-Developers are strongly encouraged to write [unit tests](src/test/README.md) for new code, and to\n-submit new unit tests for old code. Unit tests can be compiled and run\n-(assuming they weren't disabled in configure) with: `make check`. Further details on running\n-and extending unit tests can be found in [/src/test/README.md](/src/test/README.md).\n+[**License Information**](COPYING) - MIT License Permissions/Limitations/Conditions\n \n-There are also [regression and integration tests](/test), written\n-in Python.\n-These tests can be run (if the [test dependencies](/test) are installed) with: `test/functional/test_runner.py`\n+[**Tags**](https://github.com/bitcoin/bitcoin/tags) - Newest stable release versions\n \n-The CI (Continuous Integration) systems make sure that every pull request is built for Windows, Linux, and macOS,\n-and that unit/sanity tests are run automatically.\n+[**GUI**](https://github.com/bitcoin-core/gui) - Separate repo exclusively for GUI development\n+(**Please don't fork unless for development reasons**)\n \n-### Manual Quality Assurance (QA) Testing\n+[**Contributing Workflow**](CONTRIBUTING.md) - Process/guidelines for contributing \n+(Newcomers are welcome)\n \n-Changes should be tested by somebody other than the developer who wrote the\n-code. This is especially important for large or high-risk changes. It is useful\n-to add a test plan to the pull request description if testing the changes is\n-not straightforward.\n+[**Developer Notes**](doc/developer-notes.md) - Useful hints on development process Bitcoin Core integration/staging tree\n \n-Translations\n-------------\n+[**Testing**](/doc/testing.md) - Developers are strongly encouraged to write unit tests for new code and to submit new [unit tests](/src/test/README.md) for old code. [Integration tests](https://github.com/bitcoin/bitcoin/blob/master/test) are written in Python.\n \n-Changes to translations as well as new translations can be submitted to\n-[Bitcoin Core's Transifex page](https://www.transifex.com/bitcoin/bitcoin/).\n+[**Bitcoin Core's Transifex Page**](https://www.transifex.com/bitcoin/bitcoin/) - Changes to translations as well as new translations can be submitted here\n \n-Translations are periodically pulled from Transifex and merged into the git repository. See the\n-[translation process](doc/translation_process.md) for details on how this works.\n+[**Translation Process**](doc/translation_process.md) - Documentation on how translations are pulled from [Transifex](https://www.transifex.com/bitcoin/bitcoin/) and merged into git repository. (**Important**: We do not accept translation changes as pull requests because the next pull from Transifex would automatically overwrite them.)\n \n-**Important**: We do not accept translation changes as GitHub pull requests because the next\n-pull from Transifex would automatically overwrite them again."
      },
      {
        "sha": "c10c1a8a1c1ac9cb2ea053732b2df96793efb56e",
        "filename": "doc/testing.md",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6/doc/testing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6/doc/testing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/testing.md?ref=cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
        "patch": "@@ -0,0 +1,16 @@\n+**Testing**\n+--------------\n+\n+Testing and code review is the bottleneck for development; we get more pull requests than we can review and test on short notice. Please be patient and help out by testing other people's pull requests, and remember this is a security-critical project where any mistake might cost people lots of money.\n+\n+**Automated Testing**\n+\n+Developers are strongly encouraged to write [**unit tests**](/src/test/README.md) for new code, and to submit new unit tests for old code. Unit tests can be compiled and run (assuming they weren't disabled in configure) with: make check. Further details on running and extending unit tests can be found in /src/test/README.md.\n+\n+There are also [regression and integration tests](https://github.com/bitcoin/bitcoin/blob/master/test), written in Python. These tests can be run (if the test dependencies are installed) with: test/functional/test_runner.py\n+\n+The CI (Continuous Integration) systems make sure that every pull request is built for Windows, Linux, and macOS, and that unit/sanity tests are run automatically.\n+\n+**Manual Quality Assurance (QA) Testing**\n+\n+Changes should be tested by somebody other than the developer who wrote the code. This is especially important for large or high-risk changes. It is useful to add a test plan to the pull request description if testing the changes is not straightforward."
      }
    ]
  },
  {
    "sha": "2728b136830e3b6544a780c0e500882bf91055e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNzI4YjEzNjgzMGUzYjY1NDRhNzgwYzBlNTAwODgyYmY5MTA1NWUy",
    "commit": {
      "author": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T00:09:42Z"
      },
      "committer": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T00:09:42Z"
      },
      "message": "removed redundant Transifex url",
      "tree": {
        "sha": "e300322c6437de57429cdab001d4a57dfdeedfd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e300322c6437de57429cdab001d4a57dfdeedfd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2728b136830e3b6544a780c0e500882bf91055e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2728b136830e3b6544a780c0e500882bf91055e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2728b136830e3b6544a780c0e500882bf91055e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2728b136830e3b6544a780c0e500882bf91055e2/comments",
    "author": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cf110d2b9f5aa72a88d1c26edfddcd42ab0cb6b6"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "77c429b470c40f62892e6b650a8ba4b5b337dac0",
        "filename": "README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2728b136830e3b6544a780c0e500882bf91055e2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2728b136830e3b6544a780c0e500882bf91055e2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=2728b136830e3b6544a780c0e500882bf91055e2",
        "patch": "@@ -35,5 +35,5 @@ For more information, read the original Bitcoin whitepaper.\n \n [**Bitcoin Core's Transifex Page**](https://www.transifex.com/bitcoin/bitcoin/) - Changes to translations as well as new translations can be submitted here\n \n-[**Translation Process**](doc/translation_process.md) - Documentation on how translations are pulled from [Transifex](https://www.transifex.com/bitcoin/bitcoin/) and merged into git repository. (**Important**: We do not accept translation changes as pull requests because the next pull from Transifex would automatically overwrite them.)\n+[**Translation Process**](doc/translation_process.md) - Documentation on how translations are pulled from Transifex and merged into git repository. (**Important**: We do not accept translation changes as pull requests because the next pull from Transifex would automatically overwrite them.)\n "
      }
    ]
  },
  {
    "sha": "157964f60c02eb7af9701de0ca6169d2817aecb2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNTc5NjRmNjBjMDJlYjdhZjk3MDFkZTBjYTYxNjlkMjgxN2FlY2Iy",
    "commit": {
      "author": {
        "name": "brownit89",
        "email": "35484067+brownit89@users.noreply.github.com",
        "date": "2021-06-10T18:51:40Z"
      },
      "committer": {
        "name": "brownit89",
        "email": "35484067+brownit89@users.noreply.github.com",
        "date": "2021-06-10T18:51:40Z"
      },
      "message": "Merge branch 'bitcoin:master' into master",
      "tree": {
        "sha": "8b0a878a436e4d255590c1fba6c82105f0ec688c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b0a878a436e4d255590c1fba6c82105f0ec688c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/157964f60c02eb7af9701de0ca6169d2817aecb2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/157964f60c02eb7af9701de0ca6169d2817aecb2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/157964f60c02eb7af9701de0ca6169d2817aecb2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/157964f60c02eb7af9701de0ca6169d2817aecb2/comments",
    "author": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2728b136830e3b6544a780c0e500882bf91055e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2728b136830e3b6544a780c0e500882bf91055e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2728b136830e3b6544a780c0e500882bf91055e2"
      },
      {
        "sha": "1704bbf2263f16c720604cfab4ccb775315df690",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1704bbf2263f16c720604cfab4ccb775315df690",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1704bbf2263f16c720604cfab4ccb775315df690"
      }
    ],
    "stats": {
      "total": 385,
      "additions": 234,
      "deletions": 151
    },
    "files": [
      {
        "sha": "e048036e4236d8f7f321eea8501fd12af3ed78ce",
        "filename": "REVIEWERS",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/REVIEWERS",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/REVIEWERS",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/REVIEWERS?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -57,8 +57,6 @@\n /src/util/settings.*                        @ryanofsky\n \n # Fuzzing\n-/src/test/fuzz/                             @practicalswift\n-/doc/fuzzing.md                             @practicalswift\n \n # Tests\n /src/test/net_peer_eviction_tests.cpp       @jonatack\n@@ -117,7 +115,6 @@\n /src/dbwrapper.*                            @jamesob\n \n # Linter\n-/test/lint/                                 @practicalswift\n /test/lint/lint-shell.sh                    @hebasto\n \n # Bech32"
      },
      {
        "sha": "165c27f5e3cc4947dccf03dddf4bb39cb0bc9a4c",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -10,7 +10,7 @@ $(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_no_printer.patch no\n $(package)_patches+= fix_android_qmake_conf.patch fix_android_jni_static.patch dont_hardcode_pwd.patch\n $(package)_patches+= drop_lrelease_dependency.patch no_sdk_version_check.patch\n $(package)_patches+= fix_lib_paths.patch fix_android_pch.patch\n-$(package)_patches+= qtbase-moc-ignore-gcc-macro.patch\n+$(package)_patches+= qtbase-moc-ignore-gcc-macro.patch fix_limits_header.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n $(package)_qttranslations_sha256_hash=577b0668a777eb2b451c61e8d026d79285371597ce9df06b6dee6c814164b7c3\n@@ -231,6 +231,7 @@ define $(package)_preprocess_cmds\n   patch -p1 -i $($(package)_patch_dir)/no_sdk_version_check.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_lib_paths.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/qtbase-moc-ignore-gcc-macro.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/fix_limits_header.patch && \\\n   sed -i.old \"s|updateqm.commands = \\$$$$\\$$$$LRELEASE|updateqm.commands = $($(package)_extract_dir)/qttools/bin/lrelease|\" qttranslations/translations/translations.pro && \\\n   mkdir -p qtbase/mkspecs/macx-clang-linux &&\\\n   cp -f qtbase/mkspecs/macx-clang/qplatformdefs.h qtbase/mkspecs/macx-clang-linux/ &&\\"
      },
      {
        "sha": "e4313770e5a8b9c12bbebbc8bb75b8a7585a1992",
        "filename": "depends/patches/qt/fix_limits_header.patch",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/depends/patches/qt/fix_limits_header.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/depends/patches/qt/fix_limits_header.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_limits_header.patch?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -0,0 +1,44 @@\n+Fix compiling with GCC 11\n+\n+See: https://bugreports.qt.io/browse/QTBUG-90395.\n+\n+Upstream commits:\n+ - Qt 5.15 -- unavailable as open source\n+ - Qt 6.0: b2af6332ea37e45ab230a7a5d2d278f86d961b83\n+ - Qt 6.1: 9c56d4da2ff631a8c1c30475bd792f6c86bda53c\n+\n+--- old/qtbase/src/corelib/global/qendian.h\n++++ new/qtbase/src/corelib/global/qendian.h\n+@@ -44,6 +44,8 @@\n+ #include <QtCore/qfloat16.h>\n+ #include <QtCore/qglobal.h>\n+ \n++#include <limits>\n++\n+ // include stdlib.h and hope that it defines __GLIBC__ for glibc-based systems\n+ #include <stdlib.h>\n+ #include <string.h>\n+\n+--- old/qtbase/src/corelib/tools/qbytearraymatcher.h\n++++ new/qtbase/src/corelib/tools/qbytearraymatcher.h\n+@@ -42,6 +42,8 @@\n+ \n+ #include <QtCore/qbytearray.h>\n+ \n++#include <limits>\n++\n+ QT_BEGIN_NAMESPACE\n+ \n+ \n+\n+--- old/qtbase/src/tools/moc/generator.cpp\n++++ new/qtbase/src/tools/moc/generator.cpp\n+@@ -40,6 +40,8 @@\n+ #include <QtCore/qplugin.h>\n+ #include <QtCore/qstringview.h>\n+ \n++#include <limits>\n++\n+ #include <math.h>\n+ #include <stdio.h>\n+ "
      },
      {
        "sha": "c3a63b3523812bb3a2f2d5ca476d445589f662ee",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -1160,13 +1160,6 @@ A few guidelines for introducing and reviewing new RPC interfaces:\n \n   - *Rationale*: If not, the call can not be used with name-based arguments.\n \n-- Set okSafeMode in the RPC command table to a sensible value: safe mode is when the\n-  blockchain is regarded to be in a confused state, and the client deems it unsafe to\n-  do anything irreversible such as send. Anything that just queries should be permitted.\n-\n-  - *Rationale*: Troubleshooting a node in safe mode is difficult if half the\n-    RPCs don't work.\n-\n - Add every non-string RPC argument `(method, idx, name)` to the table `vRPCConvertParams` in `rpc/client.cpp`.\n \n   - *Rationale*: `bitcoin-cli` and the GUI debug console use this table to determine how to"
      },
      {
        "sha": "e2ed70556d9eb40b002e00226cb86c79ad39c024",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -351,6 +351,7 @@ libbitcoin_server_a_SOURCES = \\\n   node/ui_interface.cpp \\\n   noui.cpp \\\n   policy/fees.cpp \\\n+  policy/packages.cpp \\\n   policy/rbf.cpp \\\n   policy/settings.cpp \\\n   pow.cpp \\"
      },
      {
        "sha": "c5a389f228abf83b338fa1c73ca3b3bf2d7e580e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 56,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -159,10 +159,10 @@ static constexpr size_t MAX_ADDR_TO_SEND{1000};\n namespace {\n /** Blocks that are in flight, and that are in the queue to be downloaded. */\n struct QueuedBlock {\n-    uint256 hash;\n-    const CBlockIndex* pindex;                               //!< Optional.\n-    bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n-    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n+    /** BlockIndex. We must have this since we only request blocks when we've already validated the header. */\n+    const CBlockIndex* pindex;\n+    /** Optional, used for CMPCTBLOCK downloads */\n+    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;\n };\n \n /**\n@@ -463,16 +463,20 @@ class PeerManagerImpl final : public PeerManager\n     Mutex m_recent_confirmed_transactions_mutex;\n     std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n \n-    /* Returns a bool indicating whether we requested this block.\n-     * Also used if a block was /not/ received and timed out or started with another peer\n+    /** Have we requested this block from a peer */\n+    bool IsBlockRequested(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Remove this block from our tracked requested blocks. Called if:\n+     *  - the block has been recieved from a peer\n+     *  - the request for the block has timed out\n      */\n-    bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void RemoveBlockRequest(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /* Mark a block as in flight\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n      * pit will only be valid as long as the same cs_main lock is being held\n      */\n-    bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool BlockRequested(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     bool TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -512,7 +516,7 @@ class PeerManagerImpl final : public PeerManager\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n \n     /** Number of peers from which we're downloading blocks. */\n-    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n+    int m_peers_downloading_from GUARDED_BY(cs_main) = 0;\n \n     /** Storage for orphan information */\n     TxOrphanage m_orphanage;\n@@ -627,7 +631,6 @@ struct CNodeState {\n     //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n     std::chrono::microseconds m_downloading_since{0us};\n     int nBlocksInFlight{0};\n-    int nBlocksInFlightValidHeaders{0};\n     //! Whether we consider this a preferred download peer.\n     bool fPreferredDownload{false};\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n@@ -758,32 +761,43 @@ static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUS\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n+bool PeerManagerImpl::IsBlockRequested(const uint256& hash)\n {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n-        assert(state != nullptr);\n-        state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n-        if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n-            // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n-        }\n-        if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n-            // First block on the queue was received, update the start download time for the next one\n-            state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n-        }\n-        state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n-        state->m_stalling_since = 0us;\n-        mapBlocksInFlight.erase(itInFlight);\n-        return true;\n+    return mapBlocksInFlight.find(hash) != mapBlocksInFlight.end();\n+}\n+\n+void PeerManagerImpl::RemoveBlockRequest(const uint256& hash)\n+{\n+    auto it = mapBlocksInFlight.find(hash);\n+    if (it == mapBlocksInFlight.end()) {\n+        // Block was not requested\n+        return;\n     }\n-    return false;\n+\n+    auto [node_id, list_it] = it->second;\n+    CNodeState *state = State(node_id);\n+    assert(state != nullptr);\n+\n+    if (state->vBlocksInFlight.begin() == list_it) {\n+        // First block on the queue was received, update the start download time for the next one\n+        state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n+    }\n+    state->vBlocksInFlight.erase(list_it);\n+\n+    state->nBlocksInFlight--;\n+    if (state->nBlocksInFlight == 0) {\n+        // Last validated block on the queue was received.\n+        m_peers_downloading_from--;\n+    }\n+    state->m_stalling_since = 0us;\n+    mapBlocksInFlight.erase(it);\n }\n \n-bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n+bool PeerManagerImpl::BlockRequested(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n {\n+    assert(pindex);\n+    const uint256& hash{pindex->GetBlockHash()};\n+\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -797,18 +811,15 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n     }\n \n     // Make sure it's not listed somewhere already.\n-    MarkBlockAsReceived(hash);\n+    RemoveBlockRequest(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n+            {pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n-    state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->m_downloading_since = GetTime<std::chrono::microseconds>();\n-    }\n-    if (state->nBlocksInFlightValidHeaders == 1 && pindex != nullptr) {\n-        nPeersWithValidatedDownloads++;\n+        m_peers_downloading_from++;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n     if (pit)\n@@ -978,7 +989,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n             if (pindex->nStatus & BLOCK_HAVE_DATA || m_chainman.ActiveChain().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (!IsBlockRequested(pindex->GetBlockHash())) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n@@ -1129,13 +1140,13 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         nSyncStarted--;\n \n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        mapBlocksInFlight.erase(entry.pindex->GetBlockHash());\n     }\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n+    m_peers_downloading_from -= (state->nBlocksInFlight != 0);\n+    assert(m_peers_downloading_from >= 0);\n     m_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(m_outbound_peers_with_protect_from_disconnect >= 0);\n     m_wtxid_relay_peers -= state->m_wtxid_relay;\n@@ -1147,7 +1158,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n+        assert(m_peers_downloading_from == 0);\n         assert(m_outbound_peers_with_protect_from_disconnect == 0);\n         assert(m_wtxid_relay_peers == 0);\n         assert(m_txrequest.Size() == 0);\n@@ -2056,7 +2067,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !m_chainman.ActiveChain().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !IsBlockRequested(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -2081,7 +2092,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex);\n+                    BlockRequested(pfrom.GetId(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom.GetId());\n                 }\n@@ -2827,7 +2838,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 UpdateBlockAvailability(pfrom.GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                if (!fAlreadyHave && !fImporting && !fReindex && !IsBlockRequested(inv.hash)) {\n                     // Headers-first is the primary method of announcement on\n                     // the network. If a node fell back to sending blocks by inv,\n                     // it's probably for a re-org. The final block hash\n@@ -3384,7 +3395,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!BlockRequested(pfrom.GetId(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n                     else {\n@@ -3397,7 +3408,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n+                    RemoveBlockRequest(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                     Misbehaving(pfrom.GetId(), 100, \"invalid compact block\");\n                     return;\n                 } else if (status == READ_STATUS_FAILED) {\n@@ -3492,7 +3503,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // process from some other peer.  We do this after calling\n                 // ProcessNewBlock so that a malleated cmpctblock announcement\n                 // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n+                RemoveBlockRequest(pblock->GetHash());\n             }\n         }\n         return;\n@@ -3524,7 +3535,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n+                RemoveBlockRequest(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                 Misbehaving(pfrom.GetId(), 100, \"invalid compact block/non-matching block transactions\");\n                 return;\n             } else if (status == READ_STATUS_FAILED) {\n@@ -3550,7 +3561,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n+                RemoveBlockRequest(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is used for potentially punishing peers and\n                 // updating which peers send us compact blocks, so the race\n@@ -3615,9 +3626,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);\n-            // Also always process if we requested the block explicitly, as we may\n-            // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            // Always process the block if we requested it, since we may\n+            // need it even when it's not a candidate for a new best tip.\n+            forceProcessing = IsBlockRequested(hash);\n+            RemoveBlockRequest(hash);\n             // mapBlockSource is only used for punishing peers and setting\n             // which peers send us compact blocks, so the race between here and\n             // cs_main in ProcessNewBlock is fine.\n@@ -4712,9 +4724,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // to unreasonably increase our timeout.\n         if (state.vBlocksInFlight.size() > 0) {\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n+            int nOtherPeersWithValidatedDownloads = m_peers_downloading_from - 1;\n             if (current_time > state.m_downloading_since + std::chrono::seconds{consensusParams.nPowTargetSpacing} * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.pindex->GetBlockHash().ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }\n@@ -4767,7 +4779,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(*pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                BlockRequested(pto->GetId(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }"
      },
      {
        "sha": "cfd05399655d07f93494b959463d83f7d471df0d",
        "filename": "src/policy/packages.cpp",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/policy/packages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/policy/packages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/packages.cpp?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -0,0 +1,62 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <policy/packages.h>\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+#include <util/hasher.h>\n+\n+#include <numeric>\n+#include <unordered_set>\n+\n+bool CheckPackage(const Package& txns, PackageValidationState& state)\n+{\n+    const unsigned int package_count = txns.size();\n+\n+    if (package_count > MAX_PACKAGE_COUNT) {\n+        return state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-many-transactions\");\n+    }\n+\n+    const int64_t total_size = std::accumulate(txns.cbegin(), txns.cend(), 0,\n+                               [](int64_t sum, const auto& tx) { return sum + GetVirtualTransactionSize(*tx); });\n+    // If the package only contains 1 tx, it's better to report the policy violation on individual tx size.\n+    if (package_count > 1 && total_size > MAX_PACKAGE_SIZE * 1000) {\n+        return state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-large\");\n+    }\n+\n+    // Require the package to be sorted in order of dependency, i.e. parents appear before children.\n+    // An unsorted package will fail anyway on missing-inputs, but it's better to quit earlier and\n+    // fail on something less ambiguous (missing-inputs could also be an orphan or trying to\n+    // spend nonexistent coins).\n+    std::unordered_set<uint256, SaltedTxidHasher> later_txids;\n+    std::transform(txns.cbegin(), txns.cend(), std::inserter(later_txids, later_txids.end()),\n+                   [](const auto& tx) { return tx->GetHash(); });\n+    for (const auto& tx : txns) {\n+        for (const auto& input : tx->vin) {\n+            if (later_txids.find(input.prevout.hash) != later_txids.end()) {\n+                // The parent is a subsequent transaction in the package.\n+                return state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-not-sorted\");\n+            }\n+        }\n+        later_txids.erase(tx->GetHash());\n+    }\n+\n+    // Don't allow any conflicting transactions, i.e. spending the same inputs, in a package.\n+    std::unordered_set<COutPoint, SaltedOutpointHasher> inputs_seen;\n+    for (const auto& tx : txns) {\n+        for (const auto& input : tx->vin) {\n+            if (inputs_seen.find(input.prevout) != inputs_seen.end()) {\n+                // This input is also present in another tx in the package.\n+                return state.Invalid(PackageValidationResult::PCKG_POLICY, \"conflict-in-package\");\n+            }\n+        }\n+        // Batch-add all the inputs for a tx at a time. If we added them 1 at a time, we could\n+        // catch duplicate inputs within a single tx.  This is a more severe, consensus error,\n+        // and we want to report that from CheckTransaction instead.\n+        std::transform(tx->vin.cbegin(), tx->vin.cend(), std::inserter(inputs_seen, inputs_seen.end()),\n+                       [](const auto& input) { return input.prevout; });\n+    }\n+    return true;\n+}"
      },
      {
        "sha": "6b7ac3e450ebcfe58d18c0bf070e061030ad8199",
        "filename": "src/policy/packages.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/policy/packages.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/policy/packages.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/packages.h?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_POLICY_PACKAGES_H\n \n #include <consensus/validation.h>\n+#include <policy/policy.h>\n #include <primitives/transaction.h>\n \n #include <vector>\n@@ -14,6 +15,7 @@\n static constexpr uint32_t MAX_PACKAGE_COUNT{25};\n /** Default maximum total virtual size of transactions in a package in KvB. */\n static constexpr uint32_t MAX_PACKAGE_SIZE{101};\n+static_assert(MAX_PACKAGE_SIZE * WITNESS_SCALE_FACTOR * 1000 >= MAX_STANDARD_TX_WEIGHT);\n \n /** A \"reason\" why a package was invalid. It may be that one or more of the included\n  * transactions is invalid or the package itself violates our rules.\n@@ -31,4 +33,12 @@ using Package = std::vector<CTransactionRef>;\n \n class PackageValidationState : public ValidationState<PackageValidationResult> {};\n \n+/** Context-free package policy checks:\n+ * 1. The number of transactions cannot exceed MAX_PACKAGE_COUNT.\n+ * 2. The total virtual size cannot exceed MAX_PACKAGE_SIZE.\n+ * 3. If any dependencies exist between transactions, parents must appear before children.\n+ * 4. Transactions cannot conflict, i.e., spend the same inputs.\n+ */\n+bool CheckPackage(const Package& txns, PackageValidationState& state);\n+\n #endif // BITCOIN_POLICY_PACKAGES_H"
      },
      {
        "sha": "414c6637a52bb96782a834b1ef801297cdad8af3",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -889,7 +889,7 @@ static RPCHelpMan testmempoolaccept()\n                 \"\\nReturns result of mempool acceptance tests indicating if raw transaction(s) (serialized, hex-encoded) would be accepted by mempool.\\n\"\n                 \"\\nIf multiple transactions are passed in, parents must come before children and package policies apply: the transactions cannot conflict with any mempool transactions or each other.\\n\"\n                 \"\\nIf one transaction fails, other transactions may not be fully validated (the 'allowed' key will be blank).\\n\"\n-                \"\\nThe maximum number of transactions allowed is 25 (MAX_PACKAGE_COUNT)\\n\"\n+                \"\\nThe maximum number of transactions allowed is \" + ToString(MAX_PACKAGE_COUNT) + \".\\n\"\n                 \"\\nThis checks if transactions violate the consensus or policy rules.\\n\"\n                 \"\\nSee sendrawtransaction call.\\n\",\n                 {\n@@ -905,7 +905,7 @@ static RPCHelpMan testmempoolaccept()\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n                         \"Returns results for each transaction in the same order they were passed in.\\n\"\n-                        \"It is possible for transactions to not be fully validated ('allowed' unset) if an earlier transaction failed.\\n\",\n+                        \"It is possible for transactions to not be fully validated ('allowed' unset) if another transaction failed.\\n\",\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n@@ -939,7 +939,6 @@ static RPCHelpMan testmempoolaccept()\n         UniValue::VARR,\n         UniValueType(), // VNUM or VSTR, checked inside AmountFromValue()\n     });\n-\n     const UniValue raw_transactions = request.params[0].get_array();\n     if (raw_transactions.size() < 1 || raw_transactions.size() > MAX_PACKAGE_COUNT) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER,\n@@ -951,6 +950,7 @@ static RPCHelpMan testmempoolaccept()\n                                              CFeeRate(AmountFromValue(request.params[1]));\n \n     std::vector<CTransactionRef> txns;\n+    txns.reserve(raw_transactions.size());\n     for (const auto& rawtx : raw_transactions.getValues()) {\n         CMutableTransaction mtx;\n         if (!DecodeHexTx(mtx, rawtx.get_str())) {\n@@ -971,8 +971,8 @@ static RPCHelpMan testmempoolaccept()\n     }();\n \n     UniValue rpc_result(UniValue::VARR);\n-    // We will check transaction fees we iterate through txns in order. If any transaction fee\n-    // exceeds maxfeerate, we will keave the rest of the validation results blank, because it\n+    // We will check transaction fees while we iterate through txns in order. If any transaction fee\n+    // exceeds maxfeerate, we will leave the rest of the validation results blank, because it\n     // doesn't make sense to return a validation result for a transaction if its ancestor(s) would\n     // not be submitted.\n     bool exit_early{false};"
      },
      {
        "sha": "e54948a8407945158aa8ed41e476326beaa5678a",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -28,8 +28,8 @@ struct MinerTestingSetup : public TestingSetup {\n     void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n     bool TestSequenceLocks(const CTransaction& tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs)\n     {\n-        CCoinsViewMemPool viewMempool(&m_node.chainman->ActiveChainstate().CoinsTip(), *m_node.mempool);\n-        return CheckSequenceLocks(m_node.chainman->ActiveChain().Tip(), viewMempool, tx, flags);\n+        CCoinsViewMemPool view_mempool(&m_node.chainman->ActiveChainstate().CoinsTip(), *m_node.mempool);\n+        return CheckSequenceLocks(m_node.chainman->ActiveChain().Tip(), view_mempool, tx, flags);\n     }\n     BlockAssembler AssemblerForTest(const CChainParams& params);\n };"
      },
      {
        "sha": "7c73a2d78d2b1a27d9a65ac1e5882f7af328060b",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -515,9 +515,9 @@ void CTxMemPool::removeForReorg(CChainState& active_chainstate, int flags)\n         LockPoints lp = it->GetLockPoints();\n         assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n         bool validLP =  TestLockPointValidity(active_chainstate.m_chain, &lp);\n-        CCoinsViewMemPool viewMempool(&active_chainstate.CoinsTip(), *this);\n+        CCoinsViewMemPool view_mempool(&active_chainstate.CoinsTip(), *this);\n         if (!CheckFinalTx(active_chainstate.m_chain.Tip(), tx, flags)\n-            || !CheckSequenceLocks(active_chainstate.m_chain.Tip(), viewMempool, tx, flags, &lp, validLP)) {\n+            || !CheckSequenceLocks(active_chainstate.m_chain.Tip(), view_mempool, tx, flags, &lp, validLP)) {\n             // Note if CheckSequenceLocks fails the LockPoints may still be invalid\n             // So it's critical that we remove the tx and not depend on the LockPoints.\n             txToRemove.insert(it);"
      },
      {
        "sha": "ae4b16d3779196e83e2345cab2bd496c89117398",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -874,7 +874,8 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n-    /** Add the coins created by this transaction. */\n+    /** Add the coins created by this transaction. These coins are only temporarily stored in\n+     * m_temp_added and cannot be flushed to the back end. Only used for package validation. */\n     void PackageAddTransaction(const CTransactionRef& tx);\n };\n "
      },
      {
        "sha": "d5c4be6811e5fb9586f4ff0cc239343c247f0bcd",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 66,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -472,8 +472,10 @@ class MemPoolAccept\n          */\n         std::vector<COutPoint>& m_coins_to_uncache;\n         const bool m_test_accept;\n-        /** Disable BIP125 RBFing; disallow all conflicts with mempool transactions. */\n-        const bool disallow_mempool_conflicts;\n+        /** Whether we allow transactions to replace mempool transactions by BIP125 rules. If false,\n+         * any transaction spending the same inputs as a transaction in the mempool is considered\n+         * a conflict. */\n+        const bool m_allow_bip125_replacement{true};\n     };\n \n     // Single transaction acceptance\n@@ -482,7 +484,7 @@ class MemPoolAccept\n     /**\n     * Multiple transaction acceptance. Transactions may or may not be interdependent,\n     * but must not conflict with each other. Parents must come before children if any\n-    * dependencies exist, otherwise a TX_MISSING_INPUTS error will be returned.\n+    * dependencies exist.\n     */\n     PackageMempoolAcceptResult AcceptMultipleTransactions(const std::vector<CTransactionRef>& txns, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -619,6 +621,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     {\n         const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);\n         if (ptxConflicting) {\n+            if (!args.m_allow_bip125_replacement) {\n+                // Transaction conflicts with a mempool tx, but we're not allowing replacements.\n+                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"bip125-replacement-disallowed\");\n+            }\n             if (!setConflicts.count(ptxConflicting->GetHash()))\n             {\n                 // Allow opt-out of transaction replacement by setting\n@@ -645,7 +651,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                         break;\n                     }\n                 }\n-                if (fReplacementOptOut || args.disallow_mempool_conflicts) {\n+                if (fReplacementOptOut) {\n                     return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"txn-mempool-conflict\");\n                 }\n \n@@ -1080,65 +1086,15 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n {\n     AssertLockHeld(cs_main);\n \n+    // These context-free package limits can be done before taking the mempool lock.\n     PackageValidationState package_state;\n-    const unsigned int package_count = txns.size();\n-\n-    // These context-free package limits can be checked before taking the mempool lock.\n-    if (package_count > MAX_PACKAGE_COUNT) {\n-        package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-many-transactions\");\n-        return PackageMempoolAcceptResult(package_state, {});\n-    }\n-\n-    const int64_t total_size = std::accumulate(txns.cbegin(), txns.cend(), 0,\n-                               [](int64_t sum, const auto& tx) { return sum + GetVirtualTransactionSize(*tx); });\n-    // If the package only contains 1 tx, it's better to report the policy violation on individual tx size.\n-    if (package_count > 1 && total_size > MAX_PACKAGE_SIZE * 1000) {\n-        package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-large\");\n-        return PackageMempoolAcceptResult(package_state, {});\n-    }\n+    if (!CheckPackage(txns, package_state)) return PackageMempoolAcceptResult(package_state, {});\n \n-    // Construct workspaces and check package policies.\n     std::vector<Workspace> workspaces{};\n-    workspaces.reserve(package_count);\n-    {\n-        std::unordered_set<uint256, SaltedTxidHasher> later_txids;\n-        std::transform(txns.cbegin(), txns.cend(), std::inserter(later_txids, later_txids.end()),\n-                       [](const auto& tx) { return tx->GetHash(); });\n-        // Require the package to be sorted in order of dependency, i.e. parents appear before children.\n-        // An unsorted package will fail anyway on missing-inputs, but it's better to quit earlier and\n-        // fail on something less ambiguous (missing-inputs could also be an orphan or trying to\n-        // spend nonexistent coins).\n-        for (const auto& tx : txns) {\n-            for (const auto& input : tx->vin) {\n-                if (later_txids.find(input.prevout.hash) != later_txids.end()) {\n-                    // The parent is a subsequent transaction in the package.\n-                    package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-not-sorted\");\n-                    return PackageMempoolAcceptResult(package_state, {});\n-                }\n-            }\n-            later_txids.erase(tx->GetHash());\n-            workspaces.emplace_back(Workspace(tx));\n-        }\n-    }\n+    workspaces.reserve(txns.size());\n+    std::transform(txns.cbegin(), txns.cend(), std::back_inserter(workspaces),\n+                   [](const auto& tx) { return Workspace(tx); });\n     std::map<const uint256, const MempoolAcceptResult> results;\n-    {\n-        // Don't allow any conflicting transactions, i.e. spending the same inputs, in a package.\n-        std::unordered_set<COutPoint, SaltedOutpointHasher> inputs_seen;\n-        for (const auto& tx : txns) {\n-            for (const auto& input : tx->vin) {\n-                if (inputs_seen.find(input.prevout) != inputs_seen.end()) {\n-                    // This input is also present in another tx in the package.\n-                    package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"conflict-in-package\");\n-                    return PackageMempoolAcceptResult(package_state, {});\n-                }\n-            }\n-            // Batch-add all the inputs for a tx at a time. If we added them 1 at a time, we could\n-            // catch duplicate inputs within a single tx.  This is a more severe, consensus error,\n-            // and we want to report that from CheckTransaction instead.\n-            std::transform(tx->vin.cbegin(), tx->vin.cend(), std::inserter(inputs_seen, inputs_seen.end()),\n-                           [](const auto& input) { return input.prevout; });\n-        }\n-    }\n \n     LOCK(m_pool.cs);\n \n@@ -1151,10 +1107,10 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n             return PackageMempoolAcceptResult(package_state, std::move(results));\n         }\n         // Make the coins created by this transaction available for subsequent transactions in the\n-        // package to spend. Since we already checked conflicts in the package and RBFs are\n-        // impossible, we don't need to track the coins spent. Note that this logic will need to be\n-        // updated if RBFs in packages are allowed in the future.\n-        assert(args.disallow_mempool_conflicts);\n+        // package to spend. Since we already checked conflicts in the package and we don't allow\n+        // replacements, we don't need to track the coins spent. Note that this logic will need to be\n+        // updated if package replace-by-fee is allowed in the future.\n+        assert(!args.m_allow_bip125_replacement);\n         m_viewmempool.PackageAddTransaction(ws.m_ptx);\n     }\n \n@@ -1188,7 +1144,7 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n {\n     std::vector<COutPoint> coins_to_uncache;\n     MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits, coins_to_uncache,\n-                                   test_accept, /* disallow_mempool_conflicts */ false };\n+                                   test_accept, /* m_allow_bip125_replacement */ true };\n \n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);\n@@ -1225,12 +1181,11 @@ PackageMempoolAcceptResult ProcessNewPackage(CChainState& active_chainstate, CTx\n     std::vector<COutPoint> coins_to_uncache;\n     const CChainParams& chainparams = Params();\n     MemPoolAccept::ATMPArgs args { chainparams, GetTime(), /* bypass_limits */ false, coins_to_uncache,\n-                                   test_accept, /* disallow_mempool_conflicts */ true };\n+                                   test_accept, /* m_allow_bip125_replacement */ false };\n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const PackageMempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptMultipleTransactions(package, args);\n \n     // Uncache coins pertaining to transactions that were not submitted to the mempool.\n-    // Ensure the cache is still within its size limits.\n     for (const COutPoint& hashTx : coins_to_uncache) {\n         active_chainstate.CoinsTip().Uncache(hashTx);\n     }"
      },
      {
        "sha": "0c396c92ee3640569b8dbb0ab7cd2cd07439f446",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -234,11 +234,13 @@ MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPoo\n                                        bool bypass_limits, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /**\n-* Atomically test acceptance of a package. If the package only contains one tx, package rules still apply.\n+* Atomically test acceptance of a package. If the package only contains one tx, package rules still\n+* apply. Package validation does not allow BIP125 replacements, so the transaction(s) cannot spend\n+* the same inputs as any transaction in the mempool.\n * @param[in]    txns                Group of transactions which may be independent or contain\n-*                                   parent-child dependencies. The transactions must not conflict, i.e.\n-*                                   must not spend the same inputs, even if it would be a valid BIP125\n-*                                   replace-by-fee. Parents must appear before children.\n+*                                   parent-child dependencies. The transactions must not conflict\n+*                                   with each other, i.e., must not spend the same inputs. If any\n+*                                   dependencies exist, parents must appear before children.\n * @returns a PackageMempoolAcceptResult which includes a MempoolAcceptResult for each transaction.\n * If a transaction fails, validation will exit early and some results may be missing.\n */\n@@ -269,9 +271,13 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints* lp) EXCLUSIVE\n  * Check if transaction will be BIP68 final in the next block to be created on top of tip.\n  * @param[in]   tip             Chain tip to check tx sequence locks against. For example,\n  *                              the tip of the current active chain.\n- * @param[in]   coins_view      Any CCoinsView that provides access to the relevant coins\n- *                              for checking sequence locks. Any CCoinsView can be passed in;\n- *                              it is assumed to be consistent with the tip.\n+ * @param[in]   coins_view      Any CCoinsView that provides access to the relevant coins for\n+ *                              checking sequence locks. For example, it can be a CCoinsViewCache\n+ *                              that isn't connected to anything but contains all the relevant\n+ *                              coins, or a CCoinsViewMemPool that is connected to the\n+ *                              mempool and chainstate UTXO set. In the latter case, the caller is\n+ *                              responsible for holding the appropriate locks to ensure that\n+ *                              calls to GetCoin() return correct coins.\n  * Simulates calling SequenceLocks() with data from the tip passed in.\n  * Optionally stores in LockPoints the resulting height and time calculated and the hash\n  * of the block needed for calculation or skips the calculation and uses the LockPoints"
      },
      {
        "sha": "d0848d9bd6698ccea54bd4712c6bad1e028ccecc",
        "filename": "test/functional/rpc_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157964f60c02eb7af9701de0ca6169d2817aecb2/test/functional/rpc_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157964f60c02eb7af9701de0ca6169d2817aecb2/test/functional/rpc_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_packages.py?ref=157964f60c02eb7af9701de0ca6169d2817aecb2",
        "patch": "@@ -354,7 +354,8 @@ def test_rbf(self):\n         # This transaction is a valid BIP125 replace-by-fee\n         assert testres_rbf_single[0][\"allowed\"]\n         testres_rbf_package = self.independent_txns_testres_blank + [{\n-            \"txid\": replacement_tx.rehash(), \"wtxid\": replacement_tx.getwtxid(), \"allowed\": False, \"reject-reason\": \"txn-mempool-conflict\"\n+            \"txid\": replacement_tx.rehash(), \"wtxid\": replacement_tx.getwtxid(), \"allowed\": False,\n+            \"reject-reason\": \"bip125-replacement-disallowed\"\n         }]\n         self.assert_testres_equal(self.independent_txns_hex + [signed_replacement_tx[\"hex\"]], testres_rbf_package)\n "
      }
    ]
  },
  {
    "sha": "d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNWVhMmE5YmY1YzY0ODdjOThjOGYzMzUyYTYyNDc0NDEyMzllZjJh",
    "commit": {
      "author": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T19:40:22Z"
      },
      "committer": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T19:40:22Z"
      },
      "message": "removed bolds, added testing section",
      "tree": {
        "sha": "2bd0a514d3ba97756af1e82a0fd96bb4351f8f93",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2bd0a514d3ba97756af1e82a0fd96bb4351f8f93"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a/comments",
    "author": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2728b136830e3b6544a780c0e500882bf91055e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2728b136830e3b6544a780c0e500882bf91055e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2728b136830e3b6544a780c0e500882bf91055e2"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 33,
      "deletions": 27
    },
    "files": [
      {
        "sha": "0ae7d44347edcc7663ab66f35c88bc04b38e858f",
        "filename": "README.md",
        "status": "modified",
        "additions": 33,
        "deletions": 11,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
        "patch": "@@ -1,12 +1,12 @@\n-**Bitcoin Core Integration/Staging Tree**\n+Bitcoin Core Integration/Staging Tree\n =====================================\n \n https://bitcoincore.org\n \n For an immediately usable, binary version of the Bitcoin Core software, see\n https://bitcoincore.org/en/download/.\n \n-**What is Bitcoin?**\n+What is Bitcoin?\n ----------------\n \n Bitcoin is an experimental digital currency that enables instant payments to\n@@ -17,23 +17,45 @@ software which enables the use of this currency.\n \n For more information, read the original Bitcoin whitepaper.\n \n-[**Documents**](/doc) - Bitcoin Core Documentation \n+[License Information](COPYING) - MIT License Permissions/Limitations/Conditions\n \n-[**License Information**](COPYING) - MIT License Permissions/Limitations/Conditions\n+[Documents](/doc) - Bitcoin Core Documentation (see `doc/build-*.md` for instructions) \n \n-[**Tags**](https://github.com/bitcoin/bitcoin/tags) - Newest stable release versions\n+[Tags](https://github.com/bitcoin/bitcoin/tags) - Newest stable release versions\n \n-[**GUI**](https://github.com/bitcoin-core/gui) - Separate repo exclusively for GUI development\n+[GUI](https://github.com/bitcoin-core/gui) - Separate repository exclusively for GUI development\n (**Please don't fork unless for development reasons**)\n \n-[**Contributing Workflow**](CONTRIBUTING.md) - Process/guidelines for contributing \n+[Contributing Workflow](CONTRIBUTING.md) - Process/guidelines for contributing \n (Newcomers are welcome)\n \n-[**Developer Notes**](doc/developer-notes.md) - Useful hints on development process Bitcoin Core integration/staging tree\n+[Developer Notes](doc/developer-notes.md) - Useful hints on development process Bitcoin Core integration/staging tree\n \n-[**Testing**](/doc/testing.md) - Developers are strongly encouraged to write unit tests for new code and to submit new [unit tests](/src/test/README.md) for old code. [Integration tests](https://github.com/bitcoin/bitcoin/blob/master/test) are written in Python.\n+Testing\n+-------\n \n-[**Bitcoin Core's Transifex Page**](https://www.transifex.com/bitcoin/bitcoin/) - Changes to translations as well as new translations can be submitted here\n+Testing and code review is the bottleneck for development; we get more pull\n+requests than we can review and test on short notice. Please be patient and help out by testing\n+other people's pull requests, and remember this is a security-critical project where any mistake might cost people\n+lots of money.\n \n-[**Translation Process**](doc/translation_process.md) - Documentation on how translations are pulled from Transifex and merged into git repository. (**Important**: We do not accept translation changes as pull requests because the next pull from Transifex would automatically overwrite them.)\n+### Automated Testing\n+\n+[Unit Tests](/src/test/README.md) - Developers are strongly encouraged to write unit tests for new code and to submit new unit tests for old code. Unit tests can be compiled and run (assuming they weren't disabled in configure) with: `make check`. \n+\n+[Regression and Integration Tests](/test) are written in Python. Run with `test/functional/test_runner.py`\n+\n+### Manual Quality Assurance (QA) Testing\n+\n+Changes should be tested by somebody other than the developer who wrote the\n+code. This is especially important for large or high-risk changes. It is useful\n+to add a test plan to the pull request description if testing the changes is\n+not straightforward.\n+\n+Translations\n+------------\n+\n+[Bitcoin Core's Transifex Page](https://www.transifex.com/bitcoin/bitcoin/) - Changes to translations as well as new translations can be submitted here\n+\n+[Translation Process](doc/translation_process.md) - Documentation on how translations are pulled from Transifex and merged into git repository. (**Important**: We do not accept translation changes as pull requests because the next pull from Transifex would automatically overwrite them.)\n "
      },
      {
        "sha": "c10c1a8a1c1ac9cb2ea053732b2df96793efb56e",
        "filename": "doc/testing.md",
        "status": "removed",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2728b136830e3b6544a780c0e500882bf91055e2/doc/testing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2728b136830e3b6544a780c0e500882bf91055e2/doc/testing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/testing.md?ref=2728b136830e3b6544a780c0e500882bf91055e2",
        "patch": "@@ -1,16 +0,0 @@\n-**Testing**\n---------------\n-\n-Testing and code review is the bottleneck for development; we get more pull requests than we can review and test on short notice. Please be patient and help out by testing other people's pull requests, and remember this is a security-critical project where any mistake might cost people lots of money.\n-\n-**Automated Testing**\n-\n-Developers are strongly encouraged to write [**unit tests**](/src/test/README.md) for new code, and to submit new unit tests for old code. Unit tests can be compiled and run (assuming they weren't disabled in configure) with: make check. Further details on running and extending unit tests can be found in /src/test/README.md.\n-\n-There are also [regression and integration tests](https://github.com/bitcoin/bitcoin/blob/master/test), written in Python. These tests can be run (if the test dependencies are installed) with: test/functional/test_runner.py\n-\n-The CI (Continuous Integration) systems make sure that every pull request is built for Windows, Linux, and macOS, and that unit/sanity tests are run automatically.\n-\n-**Manual Quality Assurance (QA) Testing**\n-\n-Changes should be tested by somebody other than the developer who wrote the code. This is especially important for large or high-risk changes. It is useful to add a test plan to the pull request description if testing the changes is not straightforward."
      }
    ]
  },
  {
    "sha": "6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZWVjNjJmOTMyY2EzNjJhN2Y5YzExNDY1N2MzYjBlNWE2Yjc3OWY3",
    "commit": {
      "author": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T19:41:17Z"
      },
      "committer": {
        "name": "brownit89",
        "email": "brownit89@gmail.com",
        "date": "2021-06-10T19:41:17Z"
      },
      "message": "Merge branch 'master' of https://github.com/brownit89/bitcoin-1",
      "tree": {
        "sha": "7201f88f9fd6289a688836ca972089e8d26e8a56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7201f88f9fd6289a688836ca972089e8d26e8a56"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/comments",
    "author": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brownit89",
      "id": 35484067,
      "node_id": "MDQ6VXNlcjM1NDg0MDY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/35484067?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brownit89",
      "html_url": "https://github.com/brownit89",
      "followers_url": "https://api.github.com/users/brownit89/followers",
      "following_url": "https://api.github.com/users/brownit89/following{/other_user}",
      "gists_url": "https://api.github.com/users/brownit89/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brownit89/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brownit89/subscriptions",
      "organizations_url": "https://api.github.com/users/brownit89/orgs",
      "repos_url": "https://api.github.com/users/brownit89/repos",
      "events_url": "https://api.github.com/users/brownit89/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brownit89/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d5ea2a9bf5c6487c98c8f3352a6247441239ef2a"
      },
      {
        "sha": "157964f60c02eb7af9701de0ca6169d2817aecb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/157964f60c02eb7af9701de0ca6169d2817aecb2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/157964f60c02eb7af9701de0ca6169d2817aecb2"
      }
    ],
    "stats": {
      "total": 385,
      "additions": 234,
      "deletions": 151
    },
    "files": [
      {
        "sha": "e048036e4236d8f7f321eea8501fd12af3ed78ce",
        "filename": "REVIEWERS",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/REVIEWERS",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/REVIEWERS",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/REVIEWERS?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -57,8 +57,6 @@\n /src/util/settings.*                        @ryanofsky\n \n # Fuzzing\n-/src/test/fuzz/                             @practicalswift\n-/doc/fuzzing.md                             @practicalswift\n \n # Tests\n /src/test/net_peer_eviction_tests.cpp       @jonatack\n@@ -117,7 +115,6 @@\n /src/dbwrapper.*                            @jamesob\n \n # Linter\n-/test/lint/                                 @practicalswift\n /test/lint/lint-shell.sh                    @hebasto\n \n # Bech32"
      },
      {
        "sha": "165c27f5e3cc4947dccf03dddf4bb39cb0bc9a4c",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -10,7 +10,7 @@ $(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_no_printer.patch no\n $(package)_patches+= fix_android_qmake_conf.patch fix_android_jni_static.patch dont_hardcode_pwd.patch\n $(package)_patches+= drop_lrelease_dependency.patch no_sdk_version_check.patch\n $(package)_patches+= fix_lib_paths.patch fix_android_pch.patch\n-$(package)_patches+= qtbase-moc-ignore-gcc-macro.patch\n+$(package)_patches+= qtbase-moc-ignore-gcc-macro.patch fix_limits_header.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n $(package)_qttranslations_sha256_hash=577b0668a777eb2b451c61e8d026d79285371597ce9df06b6dee6c814164b7c3\n@@ -231,6 +231,7 @@ define $(package)_preprocess_cmds\n   patch -p1 -i $($(package)_patch_dir)/no_sdk_version_check.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/fix_lib_paths.patch && \\\n   patch -p1 -i $($(package)_patch_dir)/qtbase-moc-ignore-gcc-macro.patch && \\\n+  patch -p1 -i $($(package)_patch_dir)/fix_limits_header.patch && \\\n   sed -i.old \"s|updateqm.commands = \\$$$$\\$$$$LRELEASE|updateqm.commands = $($(package)_extract_dir)/qttools/bin/lrelease|\" qttranslations/translations/translations.pro && \\\n   mkdir -p qtbase/mkspecs/macx-clang-linux &&\\\n   cp -f qtbase/mkspecs/macx-clang/qplatformdefs.h qtbase/mkspecs/macx-clang-linux/ &&\\"
      },
      {
        "sha": "e4313770e5a8b9c12bbebbc8bb75b8a7585a1992",
        "filename": "depends/patches/qt/fix_limits_header.patch",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/depends/patches/qt/fix_limits_header.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/depends/patches/qt/fix_limits_header.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/fix_limits_header.patch?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -0,0 +1,44 @@\n+Fix compiling with GCC 11\n+\n+See: https://bugreports.qt.io/browse/QTBUG-90395.\n+\n+Upstream commits:\n+ - Qt 5.15 -- unavailable as open source\n+ - Qt 6.0: b2af6332ea37e45ab230a7a5d2d278f86d961b83\n+ - Qt 6.1: 9c56d4da2ff631a8c1c30475bd792f6c86bda53c\n+\n+--- old/qtbase/src/corelib/global/qendian.h\n++++ new/qtbase/src/corelib/global/qendian.h\n+@@ -44,6 +44,8 @@\n+ #include <QtCore/qfloat16.h>\n+ #include <QtCore/qglobal.h>\n+ \n++#include <limits>\n++\n+ // include stdlib.h and hope that it defines __GLIBC__ for glibc-based systems\n+ #include <stdlib.h>\n+ #include <string.h>\n+\n+--- old/qtbase/src/corelib/tools/qbytearraymatcher.h\n++++ new/qtbase/src/corelib/tools/qbytearraymatcher.h\n+@@ -42,6 +42,8 @@\n+ \n+ #include <QtCore/qbytearray.h>\n+ \n++#include <limits>\n++\n+ QT_BEGIN_NAMESPACE\n+ \n+ \n+\n+--- old/qtbase/src/tools/moc/generator.cpp\n++++ new/qtbase/src/tools/moc/generator.cpp\n+@@ -40,6 +40,8 @@\n+ #include <QtCore/qplugin.h>\n+ #include <QtCore/qstringview.h>\n+ \n++#include <limits>\n++\n+ #include <math.h>\n+ #include <stdio.h>\n+ "
      },
      {
        "sha": "c3a63b3523812bb3a2f2d5ca476d445589f662ee",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -1160,13 +1160,6 @@ A few guidelines for introducing and reviewing new RPC interfaces:\n \n   - *Rationale*: If not, the call can not be used with name-based arguments.\n \n-- Set okSafeMode in the RPC command table to a sensible value: safe mode is when the\n-  blockchain is regarded to be in a confused state, and the client deems it unsafe to\n-  do anything irreversible such as send. Anything that just queries should be permitted.\n-\n-  - *Rationale*: Troubleshooting a node in safe mode is difficult if half the\n-    RPCs don't work.\n-\n - Add every non-string RPC argument `(method, idx, name)` to the table `vRPCConvertParams` in `rpc/client.cpp`.\n \n   - *Rationale*: `bitcoin-cli` and the GUI debug console use this table to determine how to"
      },
      {
        "sha": "e2ed70556d9eb40b002e00226cb86c79ad39c024",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -351,6 +351,7 @@ libbitcoin_server_a_SOURCES = \\\n   node/ui_interface.cpp \\\n   noui.cpp \\\n   policy/fees.cpp \\\n+  policy/packages.cpp \\\n   policy/rbf.cpp \\\n   policy/settings.cpp \\\n   pow.cpp \\"
      },
      {
        "sha": "c5a389f228abf83b338fa1c73ca3b3bf2d7e580e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 56,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -159,10 +159,10 @@ static constexpr size_t MAX_ADDR_TO_SEND{1000};\n namespace {\n /** Blocks that are in flight, and that are in the queue to be downloaded. */\n struct QueuedBlock {\n-    uint256 hash;\n-    const CBlockIndex* pindex;                               //!< Optional.\n-    bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n-    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n+    /** BlockIndex. We must have this since we only request blocks when we've already validated the header. */\n+    const CBlockIndex* pindex;\n+    /** Optional, used for CMPCTBLOCK downloads */\n+    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;\n };\n \n /**\n@@ -463,16 +463,20 @@ class PeerManagerImpl final : public PeerManager\n     Mutex m_recent_confirmed_transactions_mutex;\n     std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n \n-    /* Returns a bool indicating whether we requested this block.\n-     * Also used if a block was /not/ received and timed out or started with another peer\n+    /** Have we requested this block from a peer */\n+    bool IsBlockRequested(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Remove this block from our tracked requested blocks. Called if:\n+     *  - the block has been recieved from a peer\n+     *  - the request for the block has timed out\n      */\n-    bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void RemoveBlockRequest(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /* Mark a block as in flight\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n      * pit will only be valid as long as the same cs_main lock is being held\n      */\n-    bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool BlockRequested(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     bool TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -512,7 +516,7 @@ class PeerManagerImpl final : public PeerManager\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n \n     /** Number of peers from which we're downloading blocks. */\n-    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n+    int m_peers_downloading_from GUARDED_BY(cs_main) = 0;\n \n     /** Storage for orphan information */\n     TxOrphanage m_orphanage;\n@@ -627,7 +631,6 @@ struct CNodeState {\n     //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n     std::chrono::microseconds m_downloading_since{0us};\n     int nBlocksInFlight{0};\n-    int nBlocksInFlightValidHeaders{0};\n     //! Whether we consider this a preferred download peer.\n     bool fPreferredDownload{false};\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n@@ -758,32 +761,43 @@ static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUS\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n+bool PeerManagerImpl::IsBlockRequested(const uint256& hash)\n {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n-        assert(state != nullptr);\n-        state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n-        if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n-            // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n-        }\n-        if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n-            // First block on the queue was received, update the start download time for the next one\n-            state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n-        }\n-        state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n-        state->m_stalling_since = 0us;\n-        mapBlocksInFlight.erase(itInFlight);\n-        return true;\n+    return mapBlocksInFlight.find(hash) != mapBlocksInFlight.end();\n+}\n+\n+void PeerManagerImpl::RemoveBlockRequest(const uint256& hash)\n+{\n+    auto it = mapBlocksInFlight.find(hash);\n+    if (it == mapBlocksInFlight.end()) {\n+        // Block was not requested\n+        return;\n     }\n-    return false;\n+\n+    auto [node_id, list_it] = it->second;\n+    CNodeState *state = State(node_id);\n+    assert(state != nullptr);\n+\n+    if (state->vBlocksInFlight.begin() == list_it) {\n+        // First block on the queue was received, update the start download time for the next one\n+        state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n+    }\n+    state->vBlocksInFlight.erase(list_it);\n+\n+    state->nBlocksInFlight--;\n+    if (state->nBlocksInFlight == 0) {\n+        // Last validated block on the queue was received.\n+        m_peers_downloading_from--;\n+    }\n+    state->m_stalling_since = 0us;\n+    mapBlocksInFlight.erase(it);\n }\n \n-bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n+bool PeerManagerImpl::BlockRequested(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n {\n+    assert(pindex);\n+    const uint256& hash{pindex->GetBlockHash()};\n+\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -797,18 +811,15 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n     }\n \n     // Make sure it's not listed somewhere already.\n-    MarkBlockAsReceived(hash);\n+    RemoveBlockRequest(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n+            {pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n-    state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->m_downloading_since = GetTime<std::chrono::microseconds>();\n-    }\n-    if (state->nBlocksInFlightValidHeaders == 1 && pindex != nullptr) {\n-        nPeersWithValidatedDownloads++;\n+        m_peers_downloading_from++;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n     if (pit)\n@@ -978,7 +989,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n             if (pindex->nStatus & BLOCK_HAVE_DATA || m_chainman.ActiveChain().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (!IsBlockRequested(pindex->GetBlockHash())) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n@@ -1129,13 +1140,13 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         nSyncStarted--;\n \n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        mapBlocksInFlight.erase(entry.pindex->GetBlockHash());\n     }\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n+    m_peers_downloading_from -= (state->nBlocksInFlight != 0);\n+    assert(m_peers_downloading_from >= 0);\n     m_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(m_outbound_peers_with_protect_from_disconnect >= 0);\n     m_wtxid_relay_peers -= state->m_wtxid_relay;\n@@ -1147,7 +1158,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n+        assert(m_peers_downloading_from == 0);\n         assert(m_outbound_peers_with_protect_from_disconnect == 0);\n         assert(m_wtxid_relay_peers == 0);\n         assert(m_txrequest.Size() == 0);\n@@ -2056,7 +2067,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !m_chainman.ActiveChain().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !IsBlockRequested(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -2081,7 +2092,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex);\n+                    BlockRequested(pfrom.GetId(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom.GetId());\n                 }\n@@ -2827,7 +2838,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 UpdateBlockAvailability(pfrom.GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                if (!fAlreadyHave && !fImporting && !fReindex && !IsBlockRequested(inv.hash)) {\n                     // Headers-first is the primary method of announcement on\n                     // the network. If a node fell back to sending blocks by inv,\n                     // it's probably for a re-org. The final block hash\n@@ -3384,7 +3395,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!BlockRequested(pfrom.GetId(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n                     else {\n@@ -3397,7 +3408,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n+                    RemoveBlockRequest(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                     Misbehaving(pfrom.GetId(), 100, \"invalid compact block\");\n                     return;\n                 } else if (status == READ_STATUS_FAILED) {\n@@ -3492,7 +3503,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // process from some other peer.  We do this after calling\n                 // ProcessNewBlock so that a malleated cmpctblock announcement\n                 // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n+                RemoveBlockRequest(pblock->GetHash());\n             }\n         }\n         return;\n@@ -3524,7 +3535,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n+                RemoveBlockRequest(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                 Misbehaving(pfrom.GetId(), 100, \"invalid compact block/non-matching block transactions\");\n                 return;\n             } else if (status == READ_STATUS_FAILED) {\n@@ -3550,7 +3561,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n+                RemoveBlockRequest(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is used for potentially punishing peers and\n                 // updating which peers send us compact blocks, so the race\n@@ -3615,9 +3626,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);\n-            // Also always process if we requested the block explicitly, as we may\n-            // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            // Always process the block if we requested it, since we may\n+            // need it even when it's not a candidate for a new best tip.\n+            forceProcessing = IsBlockRequested(hash);\n+            RemoveBlockRequest(hash);\n             // mapBlockSource is only used for punishing peers and setting\n             // which peers send us compact blocks, so the race between here and\n             // cs_main in ProcessNewBlock is fine.\n@@ -4712,9 +4724,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // to unreasonably increase our timeout.\n         if (state.vBlocksInFlight.size() > 0) {\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n+            int nOtherPeersWithValidatedDownloads = m_peers_downloading_from - 1;\n             if (current_time > state.m_downloading_since + std::chrono::seconds{consensusParams.nPowTargetSpacing} * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.pindex->GetBlockHash().ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }\n@@ -4767,7 +4779,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(*pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                BlockRequested(pto->GetId(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }"
      },
      {
        "sha": "cfd05399655d07f93494b959463d83f7d471df0d",
        "filename": "src/policy/packages.cpp",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/policy/packages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/policy/packages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/packages.cpp?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -0,0 +1,62 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <policy/packages.h>\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+#include <util/hasher.h>\n+\n+#include <numeric>\n+#include <unordered_set>\n+\n+bool CheckPackage(const Package& txns, PackageValidationState& state)\n+{\n+    const unsigned int package_count = txns.size();\n+\n+    if (package_count > MAX_PACKAGE_COUNT) {\n+        return state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-many-transactions\");\n+    }\n+\n+    const int64_t total_size = std::accumulate(txns.cbegin(), txns.cend(), 0,\n+                               [](int64_t sum, const auto& tx) { return sum + GetVirtualTransactionSize(*tx); });\n+    // If the package only contains 1 tx, it's better to report the policy violation on individual tx size.\n+    if (package_count > 1 && total_size > MAX_PACKAGE_SIZE * 1000) {\n+        return state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-large\");\n+    }\n+\n+    // Require the package to be sorted in order of dependency, i.e. parents appear before children.\n+    // An unsorted package will fail anyway on missing-inputs, but it's better to quit earlier and\n+    // fail on something less ambiguous (missing-inputs could also be an orphan or trying to\n+    // spend nonexistent coins).\n+    std::unordered_set<uint256, SaltedTxidHasher> later_txids;\n+    std::transform(txns.cbegin(), txns.cend(), std::inserter(later_txids, later_txids.end()),\n+                   [](const auto& tx) { return tx->GetHash(); });\n+    for (const auto& tx : txns) {\n+        for (const auto& input : tx->vin) {\n+            if (later_txids.find(input.prevout.hash) != later_txids.end()) {\n+                // The parent is a subsequent transaction in the package.\n+                return state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-not-sorted\");\n+            }\n+        }\n+        later_txids.erase(tx->GetHash());\n+    }\n+\n+    // Don't allow any conflicting transactions, i.e. spending the same inputs, in a package.\n+    std::unordered_set<COutPoint, SaltedOutpointHasher> inputs_seen;\n+    for (const auto& tx : txns) {\n+        for (const auto& input : tx->vin) {\n+            if (inputs_seen.find(input.prevout) != inputs_seen.end()) {\n+                // This input is also present in another tx in the package.\n+                return state.Invalid(PackageValidationResult::PCKG_POLICY, \"conflict-in-package\");\n+            }\n+        }\n+        // Batch-add all the inputs for a tx at a time. If we added them 1 at a time, we could\n+        // catch duplicate inputs within a single tx.  This is a more severe, consensus error,\n+        // and we want to report that from CheckTransaction instead.\n+        std::transform(tx->vin.cbegin(), tx->vin.cend(), std::inserter(inputs_seen, inputs_seen.end()),\n+                       [](const auto& input) { return input.prevout; });\n+    }\n+    return true;\n+}"
      },
      {
        "sha": "6b7ac3e450ebcfe58d18c0bf070e061030ad8199",
        "filename": "src/policy/packages.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/policy/packages.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/policy/packages.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/packages.h?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_POLICY_PACKAGES_H\n \n #include <consensus/validation.h>\n+#include <policy/policy.h>\n #include <primitives/transaction.h>\n \n #include <vector>\n@@ -14,6 +15,7 @@\n static constexpr uint32_t MAX_PACKAGE_COUNT{25};\n /** Default maximum total virtual size of transactions in a package in KvB. */\n static constexpr uint32_t MAX_PACKAGE_SIZE{101};\n+static_assert(MAX_PACKAGE_SIZE * WITNESS_SCALE_FACTOR * 1000 >= MAX_STANDARD_TX_WEIGHT);\n \n /** A \"reason\" why a package was invalid. It may be that one or more of the included\n  * transactions is invalid or the package itself violates our rules.\n@@ -31,4 +33,12 @@ using Package = std::vector<CTransactionRef>;\n \n class PackageValidationState : public ValidationState<PackageValidationResult> {};\n \n+/** Context-free package policy checks:\n+ * 1. The number of transactions cannot exceed MAX_PACKAGE_COUNT.\n+ * 2. The total virtual size cannot exceed MAX_PACKAGE_SIZE.\n+ * 3. If any dependencies exist between transactions, parents must appear before children.\n+ * 4. Transactions cannot conflict, i.e., spend the same inputs.\n+ */\n+bool CheckPackage(const Package& txns, PackageValidationState& state);\n+\n #endif // BITCOIN_POLICY_PACKAGES_H"
      },
      {
        "sha": "414c6637a52bb96782a834b1ef801297cdad8af3",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -889,7 +889,7 @@ static RPCHelpMan testmempoolaccept()\n                 \"\\nReturns result of mempool acceptance tests indicating if raw transaction(s) (serialized, hex-encoded) would be accepted by mempool.\\n\"\n                 \"\\nIf multiple transactions are passed in, parents must come before children and package policies apply: the transactions cannot conflict with any mempool transactions or each other.\\n\"\n                 \"\\nIf one transaction fails, other transactions may not be fully validated (the 'allowed' key will be blank).\\n\"\n-                \"\\nThe maximum number of transactions allowed is 25 (MAX_PACKAGE_COUNT)\\n\"\n+                \"\\nThe maximum number of transactions allowed is \" + ToString(MAX_PACKAGE_COUNT) + \".\\n\"\n                 \"\\nThis checks if transactions violate the consensus or policy rules.\\n\"\n                 \"\\nSee sendrawtransaction call.\\n\",\n                 {\n@@ -905,7 +905,7 @@ static RPCHelpMan testmempoolaccept()\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n                         \"Returns results for each transaction in the same order they were passed in.\\n\"\n-                        \"It is possible for transactions to not be fully validated ('allowed' unset) if an earlier transaction failed.\\n\",\n+                        \"It is possible for transactions to not be fully validated ('allowed' unset) if another transaction failed.\\n\",\n                     {\n                         {RPCResult::Type::OBJ, \"\", \"\",\n                         {\n@@ -939,7 +939,6 @@ static RPCHelpMan testmempoolaccept()\n         UniValue::VARR,\n         UniValueType(), // VNUM or VSTR, checked inside AmountFromValue()\n     });\n-\n     const UniValue raw_transactions = request.params[0].get_array();\n     if (raw_transactions.size() < 1 || raw_transactions.size() > MAX_PACKAGE_COUNT) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER,\n@@ -951,6 +950,7 @@ static RPCHelpMan testmempoolaccept()\n                                              CFeeRate(AmountFromValue(request.params[1]));\n \n     std::vector<CTransactionRef> txns;\n+    txns.reserve(raw_transactions.size());\n     for (const auto& rawtx : raw_transactions.getValues()) {\n         CMutableTransaction mtx;\n         if (!DecodeHexTx(mtx, rawtx.get_str())) {\n@@ -971,8 +971,8 @@ static RPCHelpMan testmempoolaccept()\n     }();\n \n     UniValue rpc_result(UniValue::VARR);\n-    // We will check transaction fees we iterate through txns in order. If any transaction fee\n-    // exceeds maxfeerate, we will keave the rest of the validation results blank, because it\n+    // We will check transaction fees while we iterate through txns in order. If any transaction fee\n+    // exceeds maxfeerate, we will leave the rest of the validation results blank, because it\n     // doesn't make sense to return a validation result for a transaction if its ancestor(s) would\n     // not be submitted.\n     bool exit_early{false};"
      },
      {
        "sha": "e54948a8407945158aa8ed41e476326beaa5678a",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -28,8 +28,8 @@ struct MinerTestingSetup : public TestingSetup {\n     void TestPackageSelection(const CChainParams& chainparams, const CScript& scriptPubKey, const std::vector<CTransactionRef>& txFirst) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs);\n     bool TestSequenceLocks(const CTransaction& tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_node.mempool->cs)\n     {\n-        CCoinsViewMemPool viewMempool(&m_node.chainman->ActiveChainstate().CoinsTip(), *m_node.mempool);\n-        return CheckSequenceLocks(m_node.chainman->ActiveChain().Tip(), viewMempool, tx, flags);\n+        CCoinsViewMemPool view_mempool(&m_node.chainman->ActiveChainstate().CoinsTip(), *m_node.mempool);\n+        return CheckSequenceLocks(m_node.chainman->ActiveChain().Tip(), view_mempool, tx, flags);\n     }\n     BlockAssembler AssemblerForTest(const CChainParams& params);\n };"
      },
      {
        "sha": "7c73a2d78d2b1a27d9a65ac1e5882f7af328060b",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -515,9 +515,9 @@ void CTxMemPool::removeForReorg(CChainState& active_chainstate, int flags)\n         LockPoints lp = it->GetLockPoints();\n         assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n         bool validLP =  TestLockPointValidity(active_chainstate.m_chain, &lp);\n-        CCoinsViewMemPool viewMempool(&active_chainstate.CoinsTip(), *this);\n+        CCoinsViewMemPool view_mempool(&active_chainstate.CoinsTip(), *this);\n         if (!CheckFinalTx(active_chainstate.m_chain.Tip(), tx, flags)\n-            || !CheckSequenceLocks(active_chainstate.m_chain.Tip(), viewMempool, tx, flags, &lp, validLP)) {\n+            || !CheckSequenceLocks(active_chainstate.m_chain.Tip(), view_mempool, tx, flags, &lp, validLP)) {\n             // Note if CheckSequenceLocks fails the LockPoints may still be invalid\n             // So it's critical that we remove the tx and not depend on the LockPoints.\n             txToRemove.insert(it);"
      },
      {
        "sha": "ae4b16d3779196e83e2345cab2bd496c89117398",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -874,7 +874,8 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n-    /** Add the coins created by this transaction. */\n+    /** Add the coins created by this transaction. These coins are only temporarily stored in\n+     * m_temp_added and cannot be flushed to the back end. Only used for package validation. */\n     void PackageAddTransaction(const CTransactionRef& tx);\n };\n "
      },
      {
        "sha": "d5c4be6811e5fb9586f4ff0cc239343c247f0bcd",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 66,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -472,8 +472,10 @@ class MemPoolAccept\n          */\n         std::vector<COutPoint>& m_coins_to_uncache;\n         const bool m_test_accept;\n-        /** Disable BIP125 RBFing; disallow all conflicts with mempool transactions. */\n-        const bool disallow_mempool_conflicts;\n+        /** Whether we allow transactions to replace mempool transactions by BIP125 rules. If false,\n+         * any transaction spending the same inputs as a transaction in the mempool is considered\n+         * a conflict. */\n+        const bool m_allow_bip125_replacement{true};\n     };\n \n     // Single transaction acceptance\n@@ -482,7 +484,7 @@ class MemPoolAccept\n     /**\n     * Multiple transaction acceptance. Transactions may or may not be interdependent,\n     * but must not conflict with each other. Parents must come before children if any\n-    * dependencies exist, otherwise a TX_MISSING_INPUTS error will be returned.\n+    * dependencies exist.\n     */\n     PackageMempoolAcceptResult AcceptMultipleTransactions(const std::vector<CTransactionRef>& txns, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -619,6 +621,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     {\n         const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);\n         if (ptxConflicting) {\n+            if (!args.m_allow_bip125_replacement) {\n+                // Transaction conflicts with a mempool tx, but we're not allowing replacements.\n+                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"bip125-replacement-disallowed\");\n+            }\n             if (!setConflicts.count(ptxConflicting->GetHash()))\n             {\n                 // Allow opt-out of transaction replacement by setting\n@@ -645,7 +651,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                         break;\n                     }\n                 }\n-                if (fReplacementOptOut || args.disallow_mempool_conflicts) {\n+                if (fReplacementOptOut) {\n                     return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"txn-mempool-conflict\");\n                 }\n \n@@ -1080,65 +1086,15 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n {\n     AssertLockHeld(cs_main);\n \n+    // These context-free package limits can be done before taking the mempool lock.\n     PackageValidationState package_state;\n-    const unsigned int package_count = txns.size();\n-\n-    // These context-free package limits can be checked before taking the mempool lock.\n-    if (package_count > MAX_PACKAGE_COUNT) {\n-        package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-many-transactions\");\n-        return PackageMempoolAcceptResult(package_state, {});\n-    }\n-\n-    const int64_t total_size = std::accumulate(txns.cbegin(), txns.cend(), 0,\n-                               [](int64_t sum, const auto& tx) { return sum + GetVirtualTransactionSize(*tx); });\n-    // If the package only contains 1 tx, it's better to report the policy violation on individual tx size.\n-    if (package_count > 1 && total_size > MAX_PACKAGE_SIZE * 1000) {\n-        package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-too-large\");\n-        return PackageMempoolAcceptResult(package_state, {});\n-    }\n+    if (!CheckPackage(txns, package_state)) return PackageMempoolAcceptResult(package_state, {});\n \n-    // Construct workspaces and check package policies.\n     std::vector<Workspace> workspaces{};\n-    workspaces.reserve(package_count);\n-    {\n-        std::unordered_set<uint256, SaltedTxidHasher> later_txids;\n-        std::transform(txns.cbegin(), txns.cend(), std::inserter(later_txids, later_txids.end()),\n-                       [](const auto& tx) { return tx->GetHash(); });\n-        // Require the package to be sorted in order of dependency, i.e. parents appear before children.\n-        // An unsorted package will fail anyway on missing-inputs, but it's better to quit earlier and\n-        // fail on something less ambiguous (missing-inputs could also be an orphan or trying to\n-        // spend nonexistent coins).\n-        for (const auto& tx : txns) {\n-            for (const auto& input : tx->vin) {\n-                if (later_txids.find(input.prevout.hash) != later_txids.end()) {\n-                    // The parent is a subsequent transaction in the package.\n-                    package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package-not-sorted\");\n-                    return PackageMempoolAcceptResult(package_state, {});\n-                }\n-            }\n-            later_txids.erase(tx->GetHash());\n-            workspaces.emplace_back(Workspace(tx));\n-        }\n-    }\n+    workspaces.reserve(txns.size());\n+    std::transform(txns.cbegin(), txns.cend(), std::back_inserter(workspaces),\n+                   [](const auto& tx) { return Workspace(tx); });\n     std::map<const uint256, const MempoolAcceptResult> results;\n-    {\n-        // Don't allow any conflicting transactions, i.e. spending the same inputs, in a package.\n-        std::unordered_set<COutPoint, SaltedOutpointHasher> inputs_seen;\n-        for (const auto& tx : txns) {\n-            for (const auto& input : tx->vin) {\n-                if (inputs_seen.find(input.prevout) != inputs_seen.end()) {\n-                    // This input is also present in another tx in the package.\n-                    package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"conflict-in-package\");\n-                    return PackageMempoolAcceptResult(package_state, {});\n-                }\n-            }\n-            // Batch-add all the inputs for a tx at a time. If we added them 1 at a time, we could\n-            // catch duplicate inputs within a single tx.  This is a more severe, consensus error,\n-            // and we want to report that from CheckTransaction instead.\n-            std::transform(tx->vin.cbegin(), tx->vin.cend(), std::inserter(inputs_seen, inputs_seen.end()),\n-                           [](const auto& input) { return input.prevout; });\n-        }\n-    }\n \n     LOCK(m_pool.cs);\n \n@@ -1151,10 +1107,10 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n             return PackageMempoolAcceptResult(package_state, std::move(results));\n         }\n         // Make the coins created by this transaction available for subsequent transactions in the\n-        // package to spend. Since we already checked conflicts in the package and RBFs are\n-        // impossible, we don't need to track the coins spent. Note that this logic will need to be\n-        // updated if RBFs in packages are allowed in the future.\n-        assert(args.disallow_mempool_conflicts);\n+        // package to spend. Since we already checked conflicts in the package and we don't allow\n+        // replacements, we don't need to track the coins spent. Note that this logic will need to be\n+        // updated if package replace-by-fee is allowed in the future.\n+        assert(!args.m_allow_bip125_replacement);\n         m_viewmempool.PackageAddTransaction(ws.m_ptx);\n     }\n \n@@ -1188,7 +1144,7 @@ static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainp\n {\n     std::vector<COutPoint> coins_to_uncache;\n     MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits, coins_to_uncache,\n-                                   test_accept, /* disallow_mempool_conflicts */ false };\n+                                   test_accept, /* m_allow_bip125_replacement */ true };\n \n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const MempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptSingleTransaction(tx, args);\n@@ -1225,12 +1181,11 @@ PackageMempoolAcceptResult ProcessNewPackage(CChainState& active_chainstate, CTx\n     std::vector<COutPoint> coins_to_uncache;\n     const CChainParams& chainparams = Params();\n     MemPoolAccept::ATMPArgs args { chainparams, GetTime(), /* bypass_limits */ false, coins_to_uncache,\n-                                   test_accept, /* disallow_mempool_conflicts */ true };\n+                                   test_accept, /* m_allow_bip125_replacement */ false };\n     assert(std::addressof(::ChainstateActive()) == std::addressof(active_chainstate));\n     const PackageMempoolAcceptResult result = MemPoolAccept(pool, active_chainstate).AcceptMultipleTransactions(package, args);\n \n     // Uncache coins pertaining to transactions that were not submitted to the mempool.\n-    // Ensure the cache is still within its size limits.\n     for (const COutPoint& hashTx : coins_to_uncache) {\n         active_chainstate.CoinsTip().Uncache(hashTx);\n     }"
      },
      {
        "sha": "0c396c92ee3640569b8dbb0ab7cd2cd07439f446",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -234,11 +234,13 @@ MempoolAcceptResult AcceptToMemoryPool(CChainState& active_chainstate, CTxMemPoo\n                                        bool bypass_limits, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /**\n-* Atomically test acceptance of a package. If the package only contains one tx, package rules still apply.\n+* Atomically test acceptance of a package. If the package only contains one tx, package rules still\n+* apply. Package validation does not allow BIP125 replacements, so the transaction(s) cannot spend\n+* the same inputs as any transaction in the mempool.\n * @param[in]    txns                Group of transactions which may be independent or contain\n-*                                   parent-child dependencies. The transactions must not conflict, i.e.\n-*                                   must not spend the same inputs, even if it would be a valid BIP125\n-*                                   replace-by-fee. Parents must appear before children.\n+*                                   parent-child dependencies. The transactions must not conflict\n+*                                   with each other, i.e., must not spend the same inputs. If any\n+*                                   dependencies exist, parents must appear before children.\n * @returns a PackageMempoolAcceptResult which includes a MempoolAcceptResult for each transaction.\n * If a transaction fails, validation will exit early and some results may be missing.\n */\n@@ -269,9 +271,13 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints* lp) EXCLUSIVE\n  * Check if transaction will be BIP68 final in the next block to be created on top of tip.\n  * @param[in]   tip             Chain tip to check tx sequence locks against. For example,\n  *                              the tip of the current active chain.\n- * @param[in]   coins_view      Any CCoinsView that provides access to the relevant coins\n- *                              for checking sequence locks. Any CCoinsView can be passed in;\n- *                              it is assumed to be consistent with the tip.\n+ * @param[in]   coins_view      Any CCoinsView that provides access to the relevant coins for\n+ *                              checking sequence locks. For example, it can be a CCoinsViewCache\n+ *                              that isn't connected to anything but contains all the relevant\n+ *                              coins, or a CCoinsViewMemPool that is connected to the\n+ *                              mempool and chainstate UTXO set. In the latter case, the caller is\n+ *                              responsible for holding the appropriate locks to ensure that\n+ *                              calls to GetCoin() return correct coins.\n  * Simulates calling SequenceLocks() with data from the tip passed in.\n  * Optionally stores in LockPoints the resulting height and time calculated and the hash\n  * of the block needed for calculation or skips the calculation and uses the LockPoints"
      },
      {
        "sha": "d0848d9bd6698ccea54bd4712c6bad1e028ccecc",
        "filename": "test/functional/rpc_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/test/functional/rpc_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6eec62f932ca362a7f9c114657c3b0e5a6b779f7/test/functional/rpc_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_packages.py?ref=6eec62f932ca362a7f9c114657c3b0e5a6b779f7",
        "patch": "@@ -354,7 +354,8 @@ def test_rbf(self):\n         # This transaction is a valid BIP125 replace-by-fee\n         assert testres_rbf_single[0][\"allowed\"]\n         testres_rbf_package = self.independent_txns_testres_blank + [{\n-            \"txid\": replacement_tx.rehash(), \"wtxid\": replacement_tx.getwtxid(), \"allowed\": False, \"reject-reason\": \"txn-mempool-conflict\"\n+            \"txid\": replacement_tx.rehash(), \"wtxid\": replacement_tx.getwtxid(), \"allowed\": False,\n+            \"reject-reason\": \"bip125-replacement-disallowed\"\n         }]\n         self.assert_testres_equal(self.independent_txns_hex + [signed_replacement_tx[\"hex\"]], testres_rbf_package)\n "
      }
    ]
  }
]