[
  {
    "sha": "6e182686163ce3c15b878bd78c41d8d18db344f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZTE4MjY4NjE2M2NlM2MxNWI4NzhiZDc4YzQxZDhkMThkYjM0NGYx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-07-28T18:11:20Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-15T15:06:57Z"
      },
      "message": "Switch to libsecp256k1-based validation for ECDSA",
      "tree": {
        "sha": "d4e0997b1459def528557d640a480937ffc207fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d4e0997b1459def528557d640a480937ffc207fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e182686163ce3c15b878bd78c41d8d18db344f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e182686163ce3c15b878bd78c41d8d18db344f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6e182686163ce3c15b878bd78c41d8d18db344f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e182686163ce3c15b878bd78c41d8d18db344f1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b632145edeb376b4d1597f192ca00634f7d2866c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b632145edeb376b4d1597f192ca00634f7d2866c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b632145edeb376b4d1597f192ca00634f7d2866c"
      }
    ],
    "stats": {
      "total": 689,
      "additions": 291,
      "deletions": 398
    },
    "files": [
      {
        "sha": "7db27f9facf563c6494c6a3bdfe470f474fb7e83",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -190,6 +190,21 @@ calculating the target.\n A more detailed documentation about keeping traffic low can be found in\n [/doc/reducetraffic.md](/doc/reducetraffic.md).\n \n+Signature validation using libsecp256k1\n+---------------------------------------\n+\n+ECDSA signatures inside Bitcoin transactions now use validation using\n+[https://github.com/bitcoin/secp256k1](libsecp256k1) instead of OpenSSL.\n+\n+Depending on the platform, this means a significant speedup for raw signature\n+validation speed. The advantage is largest on x86_64, where validation is over\n+five times faster. In practice, this translates to a raw reindexing and new\n+block validation times that are less than half of what it was before.\n+\n+Libsecp256k1 has undergone very extensive testing and validation.\n+\n+A side effect of this change is that libconsensus no longer depends on OpenSSL.\n+\n 0.12.0 Change log\n =================\n "
      },
      {
        "sha": "f1e98dabdedd6be00057a8f197861273c48ff101",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -104,8 +104,6 @@ BITCOIN_CORE_H = \\\n   consensus/validation.h \\\n   core_io.h \\\n   core_memusage.h \\\n-  eccryptoverify.h \\\n-  ecwrapper.h \\\n   hash.h \\\n   httprpc.h \\\n   httpserver.h \\\n@@ -272,8 +270,6 @@ libbitcoin_common_a_SOURCES = \\\n   compressor.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\\n-  eccryptoverify.cpp \\\n-  ecwrapper.cpp \\\n   hash.cpp \\\n   key.cpp \\\n   keystore.cpp \\\n@@ -404,8 +400,6 @@ libbitcoinconsensus_la_SOURCES = \\\n   crypto/sha1.cpp \\\n   crypto/sha256.cpp \\\n   crypto/sha512.cpp \\\n-  eccryptoverify.cpp \\\n-  ecwrapper.cpp \\\n   hash.cpp \\\n   primitives/transaction.cpp \\\n   pubkey.cpp \\\n@@ -420,8 +414,8 @@ if GLIBC_BACK_COMPAT\n endif\n \n libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\n-libbitcoinconsensus_la_LIBADD = $(CRYPTO_LIBS)\n-libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) $(CRYPTO_CFLAGS) -I$(builddir)/obj -DBUILD_BITCOIN_INTERNAL\n+libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\n+libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL\n libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n endif"
      },
      {
        "sha": "9f8b2b98af490148c62128ec3e45d8680c698b28",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -477,9 +477,15 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n \n class Secp256k1Init\n {\n+    ECCVerifyHandle globalVerifyHandle;\n+\n public:\n-    Secp256k1Init() { ECC_Start(); }\n-    ~Secp256k1Init() { ECC_Stop(); }\n+    Secp256k1Init() {\n+        ECC_Start();\n+    }\n+    ~Secp256k1Init() {\n+        ECC_Stop();\n+    }\n };\n \n static void MutateTx(CMutableTransaction& tx, const string& command,"
      },
      {
        "sha": "e894e1122c56894b176ae853040040c1de1f2432",
        "filename": "src/eccryptoverify.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 68,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b632145edeb376b4d1597f192ca00634f7d2866c/src/eccryptoverify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b632145edeb376b4d1597f192ca00634f7d2866c/src/eccryptoverify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eccryptoverify.cpp?ref=b632145edeb376b4d1597f192ca00634f7d2866c",
        "patch": "@@ -1,68 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"eccryptoverify.h\"\n-\n-namespace {\n-\n-int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char *c2, size_t c2len) {\n-    while (c1len > c2len) {\n-        if (*c1)\n-            return 1;\n-        c1++;\n-        c1len--;\n-    }\n-    while (c2len > c1len) {\n-        if (*c2)\n-            return -1;\n-        c2++;\n-        c2len--;\n-    }\n-    while (c1len > 0) {\n-        if (*c1 > *c2)\n-            return 1;\n-        if (*c2 > *c1)\n-            return -1;\n-        c1++;\n-        c2++;\n-        c1len--;\n-    }\n-    return 0;\n-}\n-\n-/** Order of secp256k1's generator minus 1. */\n-const unsigned char vchMaxModOrder[32] = {\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n-    0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n-    0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x40\n-};\n-\n-/** Half of the order of secp256k1's generator minus 1. */\n-const unsigned char vchMaxModHalfOrder[32] = {\n-    0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n-    0x5D,0x57,0x6E,0x73,0x57,0xA4,0x50,0x1D,\n-    0xDF,0xE9,0x2F,0x46,0x68,0x1B,0x20,0xA0\n-};\n-\n-const unsigned char vchZero[1] = {0};\n-} // anon namespace\n-\n-namespace eccrypto {\n-\n-bool Check(const unsigned char *vch) {\n-    return vch &&\n-           CompareBigEndian(vch, 32, vchZero, 0) > 0 &&\n-           CompareBigEndian(vch, 32, vchMaxModOrder, 32) <= 0;\n-}\n-\n-bool CheckSignatureElement(const unsigned char *vch, int len, bool half) {\n-    return vch &&\n-           CompareBigEndian(vch, len, vchZero, 0) > 0 &&\n-           CompareBigEndian(vch, len, half ? vchMaxModHalfOrder : vchMaxModOrder, 32) <= 0;\n-}\n-\n-} // namespace eccrypto"
      },
      {
        "sha": "c67c1e44fce878a07385089c9783c50a5f30707e",
        "filename": "src/eccryptoverify.h",
        "status": "removed",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b632145edeb376b4d1597f192ca00634f7d2866c/src/eccryptoverify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b632145edeb376b4d1597f192ca00634f7d2866c/src/eccryptoverify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eccryptoverify.h?ref=b632145edeb376b4d1597f192ca00634f7d2866c",
        "patch": "@@ -1,21 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_ECCRYPTOVERIFY_H\n-#define BITCOIN_ECCRYPTOVERIFY_H\n-\n-#include <vector>\n-#include <cstdlib>\n-\n-class uint256;\n-\n-namespace eccrypto {\n-\n-bool Check(const unsigned char *vch);\n-bool CheckSignatureElement(const unsigned char *vch, int len, bool half);\n-\n-} // eccrypto namespace\n-\n-#endif // BITCOIN_ECCRYPTOVERIFY_H"
      },
      {
        "sha": "f94bc954fd124c3a3428759b8b61ad9b14d77d9e",
        "filename": "src/ecwrapper.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 218,
        "changes": 218,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b632145edeb376b4d1597f192ca00634f7d2866c/src/ecwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b632145edeb376b4d1597f192ca00634f7d2866c/src/ecwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.cpp?ref=b632145edeb376b4d1597f192ca00634f7d2866c",
        "patch": "@@ -1,218 +0,0 @@\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"ecwrapper.h\"\n-\n-#include \"serialize.h\"\n-#include \"uint256.h\"\n-\n-#include <openssl/bn.h>\n-#include <openssl/ecdsa.h>\n-#include <openssl/obj_mac.h>\n-\n-namespace {\n-\n-class ecgroup_order\n-{\n-public:\n-  static const EC_GROUP* get()\n-  {\n-      static const ecgroup_order wrapper;\n-      return wrapper.pgroup;\n-  }\n-\n-private:\n-  ecgroup_order()\n-  : pgroup(EC_GROUP_new_by_curve_name(NID_secp256k1))\n-  {\n-  }\n-\n-  ~ecgroup_order()\n-  {\n-    EC_GROUP_free(pgroup);\n-  }\n-\n-  EC_GROUP* pgroup;\n-};\n-\n-/**\n- * Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n- * recid selects which key is recovered\n- * if check is non-zero, additional checks are performed\n- */\n-int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n-{\n-    if (!eckey) return 0;\n-\n-    int ret = 0;\n-    BN_CTX *ctx = NULL;\n-\n-    BIGNUM *x = NULL;\n-    BIGNUM *e = NULL;\n-    BIGNUM *order = NULL;\n-    BIGNUM *sor = NULL;\n-    BIGNUM *eor = NULL;\n-    BIGNUM *field = NULL;\n-    EC_POINT *R = NULL;\n-    EC_POINT *O = NULL;\n-    EC_POINT *Q = NULL;\n-    BIGNUM *rr = NULL;\n-    BIGNUM *zero = NULL;\n-    int n = 0;\n-    int i = recid / 2;\n-\n-    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n-    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n-    BN_CTX_start(ctx);\n-    order = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n-    x = BN_CTX_get(ctx);\n-    if (!BN_copy(x, order)) { ret=-1; goto err; }\n-    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n-    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n-    field = BN_CTX_get(ctx);\n-    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n-    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n-    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n-    if (check)\n-    {\n-        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n-        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n-    }\n-    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n-    n = EC_GROUP_get_degree(group);\n-    e = BN_CTX_get(ctx);\n-    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n-    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n-    zero = BN_CTX_get(ctx);\n-    if (!BN_zero(zero)) { ret=-1; goto err; }\n-    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n-    rr = BN_CTX_get(ctx);\n-    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n-    sor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n-    eor = BN_CTX_get(ctx);\n-    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n-    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n-    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n-\n-    ret = 1;\n-\n-err:\n-    if (ctx) {\n-        BN_CTX_end(ctx);\n-        BN_CTX_free(ctx);\n-    }\n-    if (R != NULL) EC_POINT_free(R);\n-    if (O != NULL) EC_POINT_free(O);\n-    if (Q != NULL) EC_POINT_free(Q);\n-    return ret;\n-}\n-\n-} // anon namespace\n-\n-CECKey::CECKey() {\n-    pkey = EC_KEY_new();\n-    assert(pkey != NULL);\n-    int result = EC_KEY_set_group(pkey, ecgroup_order::get());\n-    assert(result);\n-}\n-\n-CECKey::~CECKey() {\n-    EC_KEY_free(pkey);\n-}\n-\n-void CECKey::GetPubKey(std::vector<unsigned char> &pubkey, bool fCompressed) {\n-    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n-    int nSize = i2o_ECPublicKey(pkey, NULL);\n-    assert(nSize);\n-    assert(nSize <= 65);\n-    pubkey.clear();\n-    pubkey.resize(nSize);\n-    unsigned char *pbegin(begin_ptr(pubkey));\n-    int nSize2 = i2o_ECPublicKey(pkey, &pbegin);\n-    assert(nSize == nSize2);\n-}\n-\n-bool CECKey::SetPubKey(const unsigned char* pubkey, size_t size) {\n-    return o2i_ECPublicKey(&pkey, &pubkey, size) != NULL;\n-}\n-\n-bool CECKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n-    if (vchSig.empty())\n-        return false;\n-\n-    // New versions of OpenSSL will reject non-canonical DER signatures. de/re-serialize first.\n-    unsigned char *norm_der = NULL;\n-    ECDSA_SIG *norm_sig = ECDSA_SIG_new();\n-    const unsigned char* sigptr = &vchSig[0];\n-    assert(norm_sig);\n-    if (d2i_ECDSA_SIG(&norm_sig, &sigptr, vchSig.size()) == NULL)\n-    {\n-        /* As of OpenSSL 1.0.0p d2i_ECDSA_SIG frees and nulls the pointer on\n-         * error. But OpenSSL's own use of this function redundantly frees the\n-         * result. As ECDSA_SIG_free(NULL) is a no-op, and in the absence of a\n-         * clear contract for the function behaving the same way is more\n-         * conservative.\n-         */\n-        ECDSA_SIG_free(norm_sig);\n-        return false;\n-    }\n-    int derlen = i2d_ECDSA_SIG(norm_sig, &norm_der);\n-    ECDSA_SIG_free(norm_sig);\n-    if (derlen <= 0)\n-        return false;\n-\n-    // -1 = error, 0 = bad sig, 1 = good\n-    bool ret = ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), norm_der, derlen, pkey) == 1;\n-    OPENSSL_free(norm_der);\n-    return ret;\n-}\n-\n-bool CECKey::Recover(const uint256 &hash, const unsigned char *p64, int rec)\n-{\n-    if (rec<0 || rec>=3)\n-        return false;\n-    ECDSA_SIG *sig = ECDSA_SIG_new();\n-    BN_bin2bn(&p64[0],  32, sig->r);\n-    BN_bin2bn(&p64[32], 32, sig->s);\n-    bool ret = ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), rec, 0) == 1;\n-    ECDSA_SIG_free(sig);\n-    return ret;\n-}\n-\n-bool CECKey::TweakPublic(const unsigned char vchTweak[32]) {\n-    bool ret = true;\n-    BN_CTX *ctx = BN_CTX_new();\n-    BN_CTX_start(ctx);\n-    BIGNUM *bnTweak = BN_CTX_get(ctx);\n-    BIGNUM *bnOrder = BN_CTX_get(ctx);\n-    BIGNUM *bnOne = BN_CTX_get(ctx);\n-    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n-    EC_GROUP_get_order(group, bnOrder, ctx); // what a grossly inefficient way to get the (constant) group order...\n-    BN_bin2bn(vchTweak, 32, bnTweak);\n-    if (BN_cmp(bnTweak, bnOrder) >= 0)\n-        ret = false; // extremely unlikely\n-    EC_POINT *point = EC_POINT_dup(EC_KEY_get0_public_key(pkey), group);\n-    BN_one(bnOne);\n-    EC_POINT_mul(group, point, bnTweak, point, bnOne, ctx);\n-    if (EC_POINT_is_at_infinity(group, point))\n-        ret = false; // ridiculously unlikely\n-    EC_KEY_set_public_key(pkey, point);\n-    EC_POINT_free(point);\n-    BN_CTX_end(ctx);\n-    BN_CTX_free(ctx);\n-    return ret;\n-}\n-\n-bool CECKey::SanityCheck()\n-{\n-    const EC_GROUP *pgroup = ecgroup_order::get();\n-    if(pgroup == NULL)\n-        return false;\n-    // TODO Is there more EC functionality that could be missing?\n-    return true;\n-}"
      },
      {
        "sha": "efb6cd18a775f11420f305e116168b58e1c264e5",
        "filename": "src/ecwrapper.h",
        "status": "removed",
        "additions": 0,
        "deletions": 40,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b632145edeb376b4d1597f192ca00634f7d2866c/src/ecwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b632145edeb376b4d1597f192ca00634f7d2866c/src/ecwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecwrapper.h?ref=b632145edeb376b4d1597f192ca00634f7d2866c",
        "patch": "@@ -1,40 +0,0 @@\n-// Copyright (c) 2009-2014 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_ECWRAPPER_H\n-#define BITCOIN_ECWRAPPER_H\n-\n-#include <cstddef>\n-#include <vector>\n-\n-#include <openssl/ec.h>\n-\n-class uint256;\n-\n-/** RAII Wrapper around OpenSSL's EC_KEY */\n-class CECKey {\n-private:\n-    EC_KEY *pkey;\n-\n-public:\n-    CECKey();\n-    ~CECKey();\n-\n-    void GetPubKey(std::vector<unsigned char>& pubkey, bool fCompressed);\n-    bool SetPubKey(const unsigned char* pubkey, size_t size);\n-    bool Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig);\n-\n-    /**\n-     * reconstruct public key from a compact signature\n-     * This is only slightly more CPU intensive than just verifying it.\n-     * If this function succeeds, the recovered public key is guaranteed to be valid\n-     * (the signature is a valid signature of the given data for that key)\n-     */\n-    bool Recover(const uint256 &hash, const unsigned char *p64, int rec);\n-\n-    bool TweakPublic(const unsigned char vchTweak[32]);\n-    static bool SanityCheck();\n-};\n-\n-#endif // BITCOIN_ECWRAPPER_H"
      },
      {
        "sha": "d768c4837ee987bf808eab129dc6f91eefed4399",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -154,6 +154,7 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n \n static CCoinsViewDB *pcoinsdbview = NULL;\n static CCoinsViewErrorCatcher *pcoinscatcher = NULL;\n+static boost::scoped_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n void Interrupt(boost::thread_group& threadGroup)\n {\n@@ -243,6 +244,7 @@ void Shutdown()\n     delete pwalletMain;\n     pwalletMain = NULL;\n #endif\n+    globalVerifyHandle.reset();\n     ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n@@ -649,8 +651,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n bool InitSanityCheck(void)\n {\n     if(!ECC_InitSanityCheck()) {\n-        InitError(\"OpenSSL appears to lack support for elliptic curve cryptography. For more \"\n-                  \"information, visit https://en.bitcoin.it/wiki/OpenSSL_and_EC_Libraries\");\n+        InitError(\"Elliptic curve cryptography sanity check failure. Aborting.\");\n         return false;\n     }\n     if (!glibc_sanity_test() || !glibcxx_sanity_test())\n@@ -991,6 +992,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // Initialize elliptic curve code\n     ECC_Start();\n+    globalVerifyHandle.reset(new ECCVerifyHandle());\n \n     // Sanity check\n     if (!InitSanityCheck())"
      },
      {
        "sha": "6ebb152c75cf0ca01cdccb51b3a6fc658cffb1c4",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 233,
        "deletions": 27,
        "changes": 260,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -4,53 +4,224 @@\n \n #include \"pubkey.h\"\n \n-#include \"eccryptoverify.h\"\n+#include <secp256k1.h>\n+#include <secp256k1_recovery.h>\n \n-#include \"ecwrapper.h\"\n+namespace\n+{\n+/* Global secp256k1_context object used for verification. */\n+secp256k1_context* secp256k1_context_verify = NULL;\n+}\n+\n+/** This function is taken from the libsecp256k1 distribution and implements\n+ *  DER parsing for ECDSA signatures, while supporting an arbitrary subset of\n+ *  format violations.\n+ *\n+ *  Supported violations include negative integers, excessive padding, garbage\n+ *  at the end, and overly long length descriptors. This is safe to use in\n+ *  Bitcoin because since the activation of BIP66, signatures are verified to be\n+ *  strict DER before being passed to this module, and we know it supports all\n+ *  violations present in the blockchain before that point.\n+ */\n+static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {\n+    size_t rpos, rlen, spos, slen;\n+    size_t pos = 0;\n+    size_t lenbyte;\n+    unsigned char tmpsig[64] = {0};\n+    int overflow = 0;\n+\n+    /* Hack to initialize sig with a correctly-parsed but invalid signature. */\n+    secp256k1_ecdsa_signature_parse_compact(ctx, sig, tmpsig);\n+\n+    /* Sequence tag byte */\n+    if (pos == inputlen || input[pos] != 0x30) {\n+        return 0;\n+    }\n+    pos++;\n+\n+    /* Sequence length bytes */\n+    if (pos == inputlen) {\n+        return 0;\n+    }\n+    lenbyte = input[pos++];\n+    if (lenbyte & 0x80) {\n+        lenbyte -= 0x80;\n+        if (pos + lenbyte > inputlen) {\n+            return 0;\n+        }\n+        pos += lenbyte;\n+    }\n+\n+    /* Integer tag byte for R */\n+    if (pos == inputlen || input[pos] != 0x02) {\n+        return 0;\n+    }\n+    pos++;\n+\n+    /* Integer length for R */\n+    if (pos == inputlen) {\n+        return 0;\n+    }\n+    lenbyte = input[pos++];\n+    if (lenbyte & 0x80) {\n+        lenbyte -= 0x80;\n+        if (pos + lenbyte > inputlen) {\n+            return 0;\n+        }\n+        while (lenbyte > 0 && input[pos] == 0) {\n+            pos++;\n+            lenbyte--;\n+        }\n+        if (lenbyte >= sizeof(size_t)) {\n+            return 0;\n+        }\n+        rlen = 0;\n+        while (lenbyte > 0) {\n+            rlen = (rlen << 8) + input[pos];\n+            pos++;\n+            lenbyte--;\n+        }\n+    } else {\n+        rlen = lenbyte;\n+    }\n+    if (rlen > inputlen - pos) {\n+        return 0;\n+    }\n+    rpos = pos;\n+    pos += rlen;\n+\n+    /* Integer tag byte for S */\n+    if (pos == inputlen || input[pos] != 0x02) {\n+        return 0;\n+    }\n+    pos++;\n+\n+    /* Integer length for S */\n+    if (pos == inputlen) {\n+        return 0;\n+    }\n+    lenbyte = input[pos++];\n+    if (lenbyte & 0x80) {\n+        lenbyte -= 0x80;\n+        if (pos + lenbyte > inputlen) {\n+            return 0;\n+        }\n+        while (lenbyte > 0 && input[pos] == 0) {\n+            pos++;\n+            lenbyte--;\n+        }\n+        if (lenbyte >= sizeof(size_t)) {\n+            return 0;\n+        }\n+        slen = 0;\n+        while (lenbyte > 0) {\n+            slen = (slen << 8) + input[pos];\n+            pos++;\n+            lenbyte--;\n+        }\n+    } else {\n+        slen = lenbyte;\n+    }\n+    if (slen > inputlen - pos) {\n+        return 0;\n+    }\n+    spos = pos;\n+    pos += slen;\n+\n+    /* Ignore leading zeroes in R */\n+    while (rlen > 0 && input[rpos] == 0) {\n+        rlen--;\n+        rpos++;\n+    }\n+    /* Copy R value */\n+    if (rlen > 32) {\n+        overflow = 1;\n+    } else {\n+        memcpy(tmpsig + 32 - rlen, input + rpos, rlen);\n+    }\n+\n+    /* Ignore leading zeroes in S */\n+    while (slen > 0 && input[spos] == 0) {\n+        slen--;\n+        spos++;\n+    }\n+    /* Copy S value */\n+    if (slen > 32) {\n+        overflow = 1;\n+    } else {\n+        memcpy(tmpsig + 64 - slen, input + spos, slen);\n+    }\n+\n+    if (!overflow) {\n+        overflow = !secp256k1_ecdsa_signature_parse_compact(ctx, sig, tmpsig);\n+    }\n+    if (overflow) {\n+        /* Overwrite the result again with a correctly-parsed but invalid\n+           signature if parsing failed. */\n+        memset(tmpsig, 0, 64);\n+        secp256k1_ecdsa_signature_parse_compact(ctx, sig, tmpsig);\n+    }\n+    return 1;\n+}\n \n bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n     if (!IsValid())\n         return false;\n-    CECKey key;\n-    if (!key.SetPubKey(begin(), size()))\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ecdsa_signature sig;\n+    if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, &(*this)[0], size())) {\n         return false;\n-    if (!key.Verify(hash, vchSig))\n+    }\n+    if (vchSig.size() == 0) {\n         return false;\n-    return true;\n+    }\n+    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, &vchSig[0], vchSig.size())) {\n+        return false;\n+    }\n+    /* libsecp256k1's ECDSA verification requires lower-S signatures, which have\n+     * not historically been enforced in Bitcoin, so normalize them first. */\n+    secp256k1_ecdsa_signature_normalize(secp256k1_context_verify, &sig, &sig);\n+    return secp256k1_ecdsa_verify(secp256k1_context_verify, &sig, hash.begin(), &pubkey);\n }\n \n bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n     if (vchSig.size() != 65)\n         return false;\n     int recid = (vchSig[0] - 27) & 3;\n     bool fComp = ((vchSig[0] - 27) & 4) != 0;\n-    CECKey key;\n-    if (!key.Recover(hash, &vchSig[1], recid))\n+    secp256k1_pubkey pubkey;\n+    secp256k1_ecdsa_recoverable_signature sig;\n+    if (!secp256k1_ecdsa_recoverable_signature_parse_compact(secp256k1_context_verify, &sig, &vchSig[1], recid)) {\n         return false;\n-    std::vector<unsigned char> pubkey;\n-    key.GetPubKey(pubkey, fComp);\n-    Set(pubkey.begin(), pubkey.end());\n+    }\n+    if (!secp256k1_ecdsa_recover(secp256k1_context_verify, &pubkey, &sig, hash.begin())) {\n+        return false;\n+    }\n+    unsigned char pub[65];\n+    size_t publen = 65;\n+    secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &publen, &pubkey, fComp ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n+    Set(pub, pub + publen);\n     return true;\n }\n \n bool CPubKey::IsFullyValid() const {\n     if (!IsValid())\n         return false;\n-    CECKey key;\n-    if (!key.SetPubKey(begin(), size()))\n-        return false;\n-    return true;\n+    secp256k1_pubkey pubkey;\n+    return secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, &(*this)[0], size());\n }\n \n bool CPubKey::Decompress() {\n     if (!IsValid())\n         return false;\n-    CECKey key;\n-    if (!key.SetPubKey(begin(), size()))\n+    secp256k1_pubkey pubkey;\n+    if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, &(*this)[0], size())) {\n         return false;\n-    std::vector<unsigned char> pubkey;\n-    key.GetPubKey(pubkey, false);\n-    Set(pubkey.begin(), pubkey.end());\n+    }\n+    unsigned char pub[65];\n+    size_t publen = 65;\n+    secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &publen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    Set(pub, pub + publen);\n     return true;\n }\n \n@@ -61,13 +232,18 @@ bool CPubKey::Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChi\n     unsigned char out[64];\n     BIP32Hash(cc, nChild, *begin(), begin()+1, out);\n     memcpy(ccChild.begin(), out+32, 32);\n-    CECKey key;\n-    bool ret = key.SetPubKey(begin(), size());\n-    ret &= key.TweakPublic(out);\n-    std::vector<unsigned char> pubkey;\n-    key.GetPubKey(pubkey, true);\n-    pubkeyChild.Set(pubkey.begin(), pubkey.end());\n-    return ret;\n+    secp256k1_pubkey pubkey;\n+    if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, &(*this)[0], size())) {\n+        return false;\n+    }\n+    if (!secp256k1_ec_pubkey_tweak_add(secp256k1_context_verify, &pubkey, out)) {\n+        return false;\n+    }\n+    unsigned char pub[33];\n+    size_t publen = 33;\n+    secp256k1_ec_pubkey_serialize(secp256k1_context_verify, pub, &publen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    pubkeyChild.Set(pub, pub + publen);\n+    return true;\n }\n \n void CExtPubKey::Encode(unsigned char code[74]) const {\n@@ -95,3 +271,33 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int nChild) const {\n     out.nChild = nChild;\n     return pubkey.Derive(out.pubkey, out.chaincode, nChild, chaincode);\n }\n+\n+/* static */ bool CPubKey::CheckLowS(const std::vector<unsigned char>& vchSig) {\n+    secp256k1_ecdsa_signature sig;\n+    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, &vchSig[0], vchSig.size())) {\n+        return false;\n+    }\n+    return (!secp256k1_ecdsa_signature_normalize(secp256k1_context_verify, NULL, &sig));\n+}\n+\n+/* static */ int ECCVerifyHandle::refcount = 0;\n+\n+ECCVerifyHandle::ECCVerifyHandle()\n+{\n+    if (refcount == 0) {\n+        assert(secp256k1_context_verify == NULL);\n+        secp256k1_context_verify = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+        assert(secp256k1_context_verify != NULL);\n+    }\n+    refcount++;\n+}\n+\n+ECCVerifyHandle::~ECCVerifyHandle()\n+{\n+    refcount--;\n+    if (refcount == 0) {\n+        assert(secp256k1_context_verify != NULL);\n+        secp256k1_context_destroy(secp256k1_context_verify);\n+        secp256k1_context_verify = NULL;\n+    }\n+}"
      },
      {
        "sha": "a1d437e706e5cca5bcbe1a9523d356c882a95e04",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -177,6 +177,11 @@ class CPubKey\n      */\n     bool Verify(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\n \n+    /**\n+     * Check whether a signature is normalized (lower-S).\n+     */\n+    static bool CheckLowS(const std::vector<unsigned char>& vchSig);\n+\n     //! Recover a public key from a compact signature.\n     bool RecoverCompact(const uint256& hash, const std::vector<unsigned char>& vchSig);\n \n@@ -205,4 +210,15 @@ struct CExtPubKey {\n     bool Derive(CExtPubKey& out, unsigned int nChild) const;\n };\n \n+/** Users of this module must hold an ECCVerifyHandle. The constructor and\n+ *  destructor of these are not allowed to run in parallel, though. */\n+class ECCVerifyHandle\n+{\n+    static int refcount;\n+\n+public:\n+    ECCVerifyHandle();\n+    ~ECCVerifyHandle();\n+};\n+\n #endif // BITCOIN_PUBKEY_H"
      },
      {
        "sha": "79504f6ad369245c01d4fb9483b187f9964db041",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -6,6 +6,7 @@\n #include \"bitcoinconsensus.h\"\n \n #include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n #include \"script/interpreter.h\"\n #include \"version.h\"\n \n@@ -60,7 +61,13 @@ inline int set_error(bitcoinconsensus_error* ret, bitcoinconsensus_error serror)\n     return 0;\n }\n \n-} // anon namespace\n+struct ECCryptoClosure\n+{\n+    ECCVerifyHandle handle;\n+};\n+\n+ECCryptoClosure instance_of_eccryptoclosure;\n+}\n \n int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n                                     const unsigned char *txTo        , unsigned int txToLen,"
      },
      {
        "sha": "8dcab832cb7099ea5686628f86014e62f57e6504",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 11,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -9,7 +9,6 @@\n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n #include \"crypto/sha256.h\"\n-#include \"eccryptoverify.h\"\n #include \"pubkey.h\"\n #include \"script/script.h\"\n #include \"uint256.h\"\n@@ -165,16 +164,8 @@ bool static IsLowDERSignature(const valtype &vchSig, ScriptError* serror) {\n     if (!IsValidSignatureEncoding(vchSig)) {\n         return set_error(serror, SCRIPT_ERR_SIG_DER);\n     }\n-    unsigned int nLenR = vchSig[3];\n-    unsigned int nLenS = vchSig[5+nLenR];\n-    const unsigned char *S = &vchSig[6+nLenR];\n-    // If the S value is above the order of the curve divided by two, its\n-    // complement modulo the order could have been used instead, which is\n-    // one byte shorter when encoded correctly.\n-    if (!eccrypto::CheckSignatureElement(S, nLenS, true))\n-        return set_error(serror, SCRIPT_ERR_SIG_HIGH_S);\n-\n-    return true;\n+    std::vector<unsigned char> vchSigCopy(vchSig.begin(), vchSig.begin() + vchSig.size() - 1);\n+    return CPubKey::CheckLowS(vchSigCopy);\n }\n \n bool static IsDefinedHashtypeSignature(const valtype &vchSig) {"
      },
      {
        "sha": "f657d720381f9197a74139918ae8b5b9bce3a3e3",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e182686163ce3c15b878bd78c41d8d18db344f1/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e182686163ce3c15b878bd78c41d8d18db344f1/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=6e182686163ce3c15b878bd78c41d8d18db344f1",
        "patch": "@@ -3,6 +3,7 @@\n \n #include \"chainparamsbase.h\"\n #include \"key.h\"\n+#include \"pubkey.h\"\n #include \"txdb.h\"\n \n #include <boost/filesystem.hpp>\n@@ -12,6 +13,8 @@\n  * This just configures logging and chain parameters.\n  */\n struct BasicTestingSetup {\n+    ECCVerifyHandle globalVerifyHandle;\n+\n     BasicTestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~BasicTestingSetup();\n };"
      }
    ]
  }
]