ajtowns,2021-02-18 14:48:49,"> This PR halts the processing of unrequested transactions in Bitcoin at TX message reception. An unrequested transaction is one defined by which a ""getdata"" message for its specific identifier (either txid or wtxid) has not been previously issued by the node.\n\nI don't see the point of this? An attacker with valid utxos can generate invalid txs that are costly to reject, and simply announce th",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781395303,781395303,
DrahtBot,2021-02-18 14:57:32,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21160 (Net/Net processing: Move tx inventory into net_processing by jnewbery)\n* #21148 (Split orphan handling from net_p",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781401545,781401545,
ariard,2021-02-18 18:18:46,"@ajtowns \n\n>  I don't see the point of this? An attacker with valid utxos can generate invalid txs that are costly to reject, and simply announce their txids and wait for a request. That's limited to 5000 txs in a batc>h (    MAX_PEER_TX_ANNOUNCEMENTS), and I think each batch would have at least a 4s window (NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_TX_DELAY). \n\nAre you saying this change is",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781541708,781541708,
sdaftuar,2021-02-18 19:01:38,"@ajtowns I think not processing unrequested transactions is a first step towards being able to protect the node from transaction-based CPU DoS; it's of course not helpful on its own.  I think as a next step we could consider keeping some sort of score on peers based on how many slow-to-validate transactions they've relayed to us that were not accepted to the mempool, and for badly scoring peers (o",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781567152,781567152,
ajtowns,2021-02-19 01:05:38,"If a single tx can take 1s to validate and fail for policy reasons to avoid getting disconnected/banned, then a single peer can generate a backlog of about 1h20m (5000 seconds) of processing, beginning only 2s after getting connected using INV/GETDATA rather than just using TX, so this doesn't seem like a big help?\n\nI think an attacker could also queue ~50 slow orphan txs, have them all downlo",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781741925,781741925,
sdaftuar,2021-02-19 14:17:03,"> If a single tx can take 1s to validate and fail for policy reasons to avoid getting disconnected/banned, then a single peer can generate a backlog of about 1h20m (5000 seconds) of processing, beginning only 2s after getting connected using INV/GETDATA rather than just using TX, so this doesn't seem like a big help?\n\nThat assumes that we don't limit the number of transactions in flight to eac",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-782102604,782102604,
ajtowns,2021-02-19 16:18:31,"Rearranging:\n\n> Getting back to this proposal: what do you think the downside is of adopting this change, and not processing unrequested transactions? If it breaks a lot of existing software, [...]\n\nI don't think it solves the problem -- `INV/GETDATA` needs to be able to feed us ~7 tx/s to us just to keep up with block capacity and RBF, and if we receive 7 tx's that take 1s to validate eac",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-782178622,782178622,
sdaftuar,2021-02-19 18:25:02,"@ajtowns (Perhaps this would be better for us to discuss on IRC or something, but timezones...! ) I'll try to focus my reply on the most relevant point (in my mind) to this PR, though there's certainly a lot more to talk about as well:\n\n>>Getting back to this proposal: what do you think the downside is of adopting this change, and not processing unrequested transactions? If it breaks a lot of ",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-782254440,782254440,
ajtowns,2021-02-20 04:22:07,"@sdaftuar Maybe we should at least move to the mailing list at least?\n\nI think as long as `PF_RELAY` bypasses the INV/GETDATA requirement, forbidding TX's that we haven't asked for via GETDATA is fine on the current network (provided that doesn't make tests slower) -- I might think the only value is in deduping tx relay, but that's still valuable enough on the live network that everyone should",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-782557211,782557211,
jnewbery,2021-02-20 10:25:50,"I don't have anything specific to add to the excellent points made by @sdaftuar and @ajtowns. I share aj's scepticism that this is a beneficial change. I think this is the crucial point:\n\n> I don't think it solves the problem -- INV/GETDATA needs to be able to feed us ~7 tx/s to us just to keep up with block capacity and RBF, and if we receive 7 tx's that take 1s to validate each second, we al",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-782601983,782601983,
ariard,2021-02-20 18:05:18,"@ajtowns, Thanks for all the great points. While working on this, I became skeptical of naive\ntime-based approach for rate-limiting as much from drop-on-the-floor abundant `TX` messages for the \nfollowing reasons :\n\n* We have a heterogeneity of hosts deployed on the network. If we rely on hardcoded time-bounds, \ntransaction X might be classified as expensive-to-validate by node A while b",https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-782724922,782724922,
pinheadmz,2021-02-24 14:52:33,"I'm just trying to understand the boost multi-index data structure, and want to do due diligence whenever I see a `while` loop: This will iterate only as many times as we have actively requested a given TX, correct? So the most number of iterations possible is the total number of peers we have? Because the TX hash is specified, so it's not like we run through the entire data structure.",https://github.com/bitcoin/bitcoin/pull/21224#discussion_r582024593,582024593,src/txrequest.cpp
