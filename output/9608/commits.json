[
  {
    "sha": "27239258111e52ee9e4ea7ad606fb43f08a86459",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNzIzOTI1ODExMWU1MmVlOWU0ZWE3YWQ2MDZmYjQzZjA4YTg2NDU5",
    "commit": {
      "author": {
        "name": "Jorge Tim\u00f3n",
        "email": "jtimon@jtimon.cc",
        "date": "2017-01-21T03:52:32Z"
      },
      "committer": {
        "name": "Jorge Tim\u00f3n",
        "email": "jtimon@jtimon.cc",
        "date": "2017-09-23T06:51:46Z"
      },
      "message": "Net: Divide ProcessMessage into smaller functions",
      "tree": {
        "sha": "1ed76703653b9b7edbf1b378fb47fe64baa6b2dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ed76703653b9b7edbf1b378fb47fe64baa6b2dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27239258111e52ee9e4ea7ad606fb43f08a86459",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJZxgSEAAoJEIhmwY6hyUSiGVoP/1mcApDqsQ0WCEo3ish5BvaN\n6NYYvc6lJoE7BiacZwswH5YWihPlOCkMUD8R+8fSYEGU5rvLyd1YIYXxEB08uzmE\nvt4rGkD/NCLdgn5BFjfukpAnqUGGabfCnH7aAmgz5nwObV7uZO3Y1jwRTfeWmgnR\nmpU0Yj0MrowlSZ4c70D7NqjcqOSZEasay3ljCEmAYSft7kKcCyHgYQfs+uWWiPNT\nxO06g3WsUxEWa3SLMDa26Gn2wOIyGHJ41bBnrQMbpkc7yMZNVAMY9BokfmoL5QX8\nV5M3ugjxNFOcXDog/Rg+IqIAnGBMpCNkQpXyTGlD1fpIrhZrRwZAIVHbEuGAzJ/Z\nRsjrkb26BjNXOXidylZaKvAA0cUTdbfXsAhXmd7EEBRpMI9/HjOWyO3XhUwwN7xA\nF2PMpnVOzMvR7HFYCZRiDwuF2pux+oqPpXqXbw/ZzK1SySQiFudLTNzj042Jo2t8\nyDzmtxIzG/eVnaAA7q+MRDMRn4PxispGDOVpF9RUJ7RoUbGZ9F53TUx5GevG5kC8\n+J0yiQCfhD5NTjr/TvIL9gZv6/CYYTvFWlRlSezY2zS2qAFasWKMIBI07LMqnCiv\nezI31bBjCNh+LfuSDA9z0be3ijeBTl7Z97u4etzNjAYTcrkAj9GgQr0J1V2WnGor\n50fh+j4Tt1bTj95gYp9P\n=4nQL\n-----END PGP SIGNATURE-----",
        "payload": "tree 1ed76703653b9b7edbf1b378fb47fe64baa6b2dc\nparent 551d7bf604fb4615d64b8b644aefa160dadc34c4\nauthor Jorge Tim\u00f3n <jtimon@jtimon.cc> 1484970752 +0100\ncommitter Jorge Tim\u00f3n <jtimon@jtimon.cc> 1506149506 +0200\n\nNet: Divide ProcessMessage into smaller functions\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27239258111e52ee9e4ea7ad606fb43f08a86459",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27239258111e52ee9e4ea7ad606fb43f08a86459",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27239258111e52ee9e4ea7ad606fb43f08a86459/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "551d7bf604fb4615d64b8b644aefa160dadc34c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/551d7bf604fb4615d64b8b644aefa160dadc34c4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/551d7bf604fb4615d64b8b644aefa160dadc34c4"
      }
    ],
    "stats": {
      "total": 340,
      "additions": 218,
      "deletions": 122
    },
    "files": [
      {
        "sha": "d8458361639dd3cc843dbe22ea6e2296f212ad4f",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 218,
        "deletions": 122,
        "changes": 340,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27239258111e52ee9e4ea7ad606fb43f08a86459/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27239258111e52ee9e4ea7ad606fb43f08a86459/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=27239258111e52ee9e4ea7ad606fb43f08a86459",
        "patch": "@@ -1153,32 +1153,8 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+static bool ProcessMsgReject(CDataStream& vRecv)\n {\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n-    if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n-    {\n-        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n-        return true;\n-    }\n-\n-\n-    if (!(pfrom->GetLocalServices() & NODE_BLOOM) &&\n-              (strCommand == NetMsgType::FILTERLOAD ||\n-               strCommand == NetMsgType::FILTERADD))\n-    {\n-        if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n-            return false;\n-        } else {\n-            pfrom->fDisconnect = true;\n-            return false;\n-        }\n-    }\n-\n-    if (strCommand == NetMsgType::REJECT)\n-    {\n         if (LogAcceptCategory(BCLog::NET)) {\n             try {\n                 std::string strMsg; unsigned char ccode; std::string strReason;\n@@ -1199,10 +1175,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");\n             }\n         }\n-    }\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::VERSION)\n-    {\n+static bool ProcessMsgVersion(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, CConnman* connman)\n+{\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n@@ -1376,22 +1353,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->fDisconnect = true;\n         }\n         return true;\n-    }\n-\n-\n-    else if (pfrom->nVersion == 0)\n-    {\n-        // Must have a version message before anything else\n-        LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n-        return false;\n-    }\n-\n-    // At this point, the outgoing message serialization version can't change.\n-    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+}\n \n-    if (strCommand == NetMsgType::VERACK)\n-    {\n+static bool ProcessMsgVerack(CNode* pfrom, CConnman* connman, const CNetMsgMaker& msgMaker)\n+{\n         pfrom->SetRecvVersion(std::min(pfrom->nVersion.load(), PROTOCOL_VERSION));\n \n         if (!pfrom->fInbound) {\n@@ -1421,18 +1386,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n         pfrom->fSuccessfullyConnected = true;\n-    }\n \n-    else if (!pfrom->fSuccessfullyConnected)\n-    {\n-        // Must have a verack message before anything else\n-        LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n-        return false;\n-    }\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::ADDR)\n-    {\n+static bool ProcessMsgAddr(CNode* pfrom, CDataStream& vRecv, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+{\n         std::vector<CAddress> vAddr;\n         vRecv >> vAddr;\n \n@@ -1476,16 +1435,19 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->fGetAddr = false;\n         if (pfrom->fOneShot)\n             pfrom->fDisconnect = true;\n-    }\n \n-    else if (strCommand == NetMsgType::SENDHEADERS)\n-    {\n+    return true;\n+}\n+\n+static bool ProcessMsgSendheaders(const CNode* pfrom)\n+{\n         LOCK(cs_main);\n         State(pfrom->GetId())->fPreferHeaders = true;\n-    }\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::SENDCMPCT)\n-    {\n+static bool ProcessMsgSendcmpct(const CNode* pfrom, CDataStream& vRecv)\n+{\n         bool fAnnounceUsingCMPCTBLOCK = false;\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n@@ -1505,11 +1467,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n             }\n         }\n-    }\n-\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::INV)\n-    {\n+static bool ProcessMsgInv(CNode* pfrom, CDataStream& vRecv, const Consensus::Params& consensusParams, CConnman* connman, const CNetMsgMaker& msgMaker, const std::atomic<bool>& interruptMsgProc)\n+{\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n@@ -1566,11 +1528,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Track requests for our stuff\n             GetMainSignals().Inventory(inv.hash);\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::GETDATA)\n-    {\n+static bool ProcessMsgGetdata(CNode* pfrom, CDataStream& vRecv, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+{\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n@@ -1587,12 +1550,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n-        ProcessGetData(pfrom, chainparams.GetConsensus(), connman, interruptMsgProc);\n-    }\n+        ProcessGetData(pfrom, consensusParams, connman, interruptMsgProc);\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::GETBLOCKS)\n-    {\n+static bool ProcessMsgGetblocks(CNode* pfrom, CDataStream& vRecv, const Consensus::Params& consensusParams)\n+{\n         CBlockLocator locator;\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n@@ -1633,7 +1597,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n-            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;\n+            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / consensusParams.nPowTargetSpacing;\n             if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))\n             {\n                 LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n@@ -1649,11 +1613,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 break;\n             }\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::GETBLOCKTXN)\n-    {\n+static bool ProcessMsgGetblocktxn(CNode* pfrom, CDataStream& vRecv, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+{\n         BlockTransactionsRequest req;\n         vRecv >> req;\n \n@@ -1690,20 +1655,21 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n             pfrom->vRecvGetData.push_back(inv);\n-            ProcessGetData(pfrom, chainparams.GetConsensus(), connman, interruptMsgProc);\n+            ProcessGetData(pfrom, consensusParams, connman, interruptMsgProc);\n             return true;\n         }\n \n         CBlock block;\n-        bool ret = ReadBlockFromDisk(block, it->second, chainparams.GetConsensus());\n+        bool ret = ReadBlockFromDisk(block, it->second, consensusParams);\n         assert(ret);\n \n         SendBlockTransactions(block, req, pfrom, connman);\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::GETHEADERS)\n-    {\n+static bool ProcessMsgGetheaders(CNode* pfrom, CDataStream& vRecv, CConnman* connman, const CNetMsgMaker& msgMaker)\n+{\n         CBlockLocator locator;\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n@@ -1756,11 +1722,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // in the SendMessages logic.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n         connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::TX)\n-    {\n+static bool ProcessMsgTx(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, const CChainParams& chainparams, CConnman* connman, const CNetMsgMaker& msgMaker)\n+{\n         // Stop processing the transaction early if\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n@@ -1942,11 +1909,15 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n-    {\n+// Declaration of ProcessMessage is needed before defining MsgCmpctblock (both static) for recursion\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc);\n+\n+static bool ProcessMsgCmpctblock(CNode* pfrom, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman,  const std::atomic<bool>& interruptMsgProc, const CNetMsgMaker& msgMaker)\n+{\n         CBlockHeaderAndShortTxIDs cmpctblock;\n         vRecv >> cmpctblock;\n \n@@ -2142,10 +2113,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         }\n \n-    }\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n-    {\n+static bool ProcessMsgBlocktxn(CNode* pfrom, CDataStream& vRecv, const CChainParams& chainparams, CConnman* connman, const CNetMsgMaker& msgMaker)\n+{\n         BlockTransactions resp;\n         vRecv >> resp;\n \n@@ -2213,11 +2185,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::HEADERS && !fImporting && !fReindex) // Ignore headers received while importing\n-    {\n+static bool ProcessMsgHeaders(CNode* pfrom, CDataStream& vRecv, const CChainParams& chainparams, CConnman* connman, const CNetMsgMaker& msgMaker)\n+{\n         std::vector<CBlockHeader> headers;\n \n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n@@ -2363,10 +2336,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         }\n         }\n-    }\n \n-    else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n-    {\n+    return true;\n+}\n+\n+static bool ProcessMsgBlock(CNode* pfrom, CDataStream& vRecv, const CChainParams& chainparams)\n+{\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n@@ -2395,11 +2370,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             mapBlockSource.erase(pblock->GetHash());\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::GETADDR)\n-    {\n+static bool ProcessMsgGetaddr(CNode* pfrom, CConnman* connman)\n+{\n         // This asymmetric behavior for inbound and outbound connections was introduced\n         // to prevent a fingerprinting attack: an attacker can send specific fake addresses\n         // to users' AddrMan and later request them by sending getaddr messages.\n@@ -2423,11 +2399,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::MEMPOOL)\n-    {\n+static bool ProcessMsgMempool(CNode* pfrom, CConnman* connman)\n+{\n         if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)\n         {\n             LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n@@ -2444,11 +2421,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(pfrom->cs_inventory);\n         pfrom->fSendMempool = true;\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::PING)\n-    {\n+static bool ProcessMsgPing(CNode* pfrom, CDataStream& vRecv, CConnman* connman, const CNetMsgMaker& msgMaker)\n+{\n         if (pfrom->nVersion > BIP0031_VERSION)\n         {\n             uint64_t nonce = 0;\n@@ -2466,11 +2444,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // return very quickly.\n             connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n-    }\n-\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::PONG)\n-    {\n+static bool ProcessMsgPong(CNode* pfrom, CDataStream& vRecv, const int64_t nTimeReceived)\n+{\n         int64_t pingUsecEnd = nTimeReceived;\n         uint64_t nonce = 0;\n         size_t nAvail = vRecv.in_avail();\n@@ -2523,11 +2501,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (bPingFinished) {\n             pfrom->nPingNonceSent = 0;\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::FILTERLOAD)\n-    {\n+static bool ProcessMsgFilterload(CNode* pfrom, CDataStream& vRecv)\n+{\n         CBloomFilter filter;\n         vRecv >> filter;\n \n@@ -2545,11 +2524,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             pfrom->pfilter->UpdateEmptyFull();\n             pfrom->fRelayTxes = true;\n         }\n-    }\n \n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::FILTERADD)\n-    {\n+static bool ProcessMsgFilteradd(CNode* pfrom, CDataStream& vRecv)\n+{\n         std::vector<unsigned char> vData;\n         vRecv >> vData;\n \n@@ -2570,20 +2550,23 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n-    }\n-\n+    return true;\n+}\n \n-    else if (strCommand == NetMsgType::FILTERCLEAR)\n-    {\n+static bool ProcessMsgFilterclear(CNode* pfrom)\n+{\n         LOCK(pfrom->cs_filter);\n         if (pfrom->GetLocalServices() & NODE_BLOOM) {\n             delete pfrom->pfilter;\n             pfrom->pfilter = new CBloomFilter();\n         }\n         pfrom->fRelayTxes = true;\n-    }\n \n-    else if (strCommand == NetMsgType::FEEFILTER) {\n+    return true;\n+}\n+\n+static bool ProcessMsgFeefilter(CNode* pfrom, CDataStream& vRecv)\n+{\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n@@ -2593,20 +2576,133 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n+    return true;\n+}\n+\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+{\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n+    if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n+    {\n+        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n+        return true;\n+    }\n+\n+\n+    if (!(pfrom->GetLocalServices() & NODE_BLOOM) &&\n+              (strCommand == NetMsgType::FILTERLOAD ||\n+               strCommand == NetMsgType::FILTERADD))\n+    {\n+        if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n+            LOCK(cs_main);\n+            Misbehaving(pfrom->GetId(), 100);\n+            return false;\n+        } else {\n+            pfrom->fDisconnect = true;\n+            return false;\n+        }\n+    }\n+\n+    if (strCommand == NetMsgType::REJECT)\n+    {\n+        return ProcessMsgReject(vRecv);\n+    }\n+    if (strCommand == NetMsgType::VERSION) {\n+        return ProcessMsgVersion(pfrom, strCommand, vRecv, connman);\n+    }\n+    else if (pfrom->nVersion == 0) {\n+        // Must have a version message before anything else\n+        LOCK(cs_main);\n+        Misbehaving(pfrom->GetId(), 1);\n+        return false;\n+    }\n+\n+    // At this point, the outgoing message serialization version can't change.\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+\n+    if (strCommand == NetMsgType::VERACK) {\n+        return ProcessMsgVerack(pfrom, connman, msgMaker);\n+    }\n+    else if (!pfrom->fSuccessfullyConnected)\n+    {\n+        // Must have a verack message before anything else\n+        LOCK(cs_main);\n+        Misbehaving(pfrom->GetId(), 1);\n+        return false;\n+    }\n+    else if (strCommand == NetMsgType::ADDR) {\n+        return ProcessMsgAddr(pfrom, vRecv, connman, interruptMsgProc);\n+    }\n+    else if (strCommand == NetMsgType::SENDHEADERS) {\n+        return ProcessMsgSendheaders(pfrom);\n+    }\n+    else if (strCommand == NetMsgType::SENDCMPCT) {\n+        return ProcessMsgSendcmpct(pfrom, vRecv);\n+    }\n+    else if (strCommand == NetMsgType::INV) {\n+        return ProcessMsgInv(pfrom, vRecv, chainparams.GetConsensus(), connman, msgMaker, interruptMsgProc);\n+    }\n+    else if (strCommand == NetMsgType::GETDATA) {\n+        return ProcessMsgGetdata(pfrom, vRecv, chainparams.GetConsensus(), connman, interruptMsgProc);\n+    }\n+    else if (strCommand == NetMsgType::GETBLOCKS) {\n+        return ProcessMsgGetblocks(pfrom, vRecv, chainparams.GetConsensus());\n+    }\n+    else if (strCommand == NetMsgType::GETBLOCKTXN) {\n+        return ProcessMsgGetblocktxn(pfrom, vRecv, chainparams.GetConsensus(), connman, interruptMsgProc);\n+    }\n+    else if (strCommand == NetMsgType::GETHEADERS) {\n+        return ProcessMsgGetheaders(pfrom, vRecv, connman, msgMaker);\n+    }\n+    else if (strCommand == NetMsgType::TX) {\n+        return ProcessMsgTx(pfrom, strCommand, vRecv, chainparams, connman, msgMaker);\n+    }\n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) { // Ignore blocks received while importing\n+        return ProcessMsgCmpctblock(pfrom, vRecv, nTimeReceived, chainparams, connman, interruptMsgProc, msgMaker);\n+    }\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) { // Ignore blocks received while importing\n+        return ProcessMsgBlocktxn(pfrom, vRecv, chainparams, connman, msgMaker);\n+    }\n+    else if (strCommand == NetMsgType::HEADERS && !fImporting && !fReindex) { // Ignore headers received while importing\n+        return ProcessMsgHeaders(pfrom, vRecv, chainparams, connman, msgMaker);\n+    }\n+    else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) { // Ignore blocks received while importing\n+        return ProcessMsgBlock(pfrom, vRecv, chainparams);\n+    }\n+    else if (strCommand == NetMsgType::GETADDR) {\n+        return ProcessMsgGetaddr(pfrom, connman);\n+    }\n+    else if (strCommand == NetMsgType::MEMPOOL) {\n+        return ProcessMsgMempool(pfrom, connman);\n+    }\n+    else if (strCommand == NetMsgType::PING) {\n+        return ProcessMsgPing(pfrom, vRecv, connman, msgMaker);\n+    }\n+    else if (strCommand == NetMsgType::PONG) {\n+        return ProcessMsgPong(pfrom, vRecv, nTimeReceived);\n+    }\n+    else if (strCommand == NetMsgType::FILTERLOAD) {\n+        return ProcessMsgFilterload(pfrom, vRecv);\n+    }\n+    else if (strCommand == NetMsgType::FILTERADD) {\n+        return ProcessMsgFilteradd(pfrom, vRecv);\n+    }\n+    else if (strCommand == NetMsgType::FILTERCLEAR) {\n+        return ProcessMsgFilterclear(pfrom);\n+    }\n+    else if (strCommand == NetMsgType::FEEFILTER) {\n+        return ProcessMsgFeefilter(pfrom, vRecv);\n     }\n \n     else if (strCommand == NetMsgType::NOTFOUND) {\n         // We do not care about the NOTFOUND message, but logging an Unknown Command\n         // message would be undesirable as we transmit it ourselves.\n     }\n-\n     else {\n         // Ignore unknown commands for extensibility\n         LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n     }\n \n-\n-\n     return true;\n }\n "
      }
    ]
  }
]