[
  {
    "sha": "7897338918dac072e788b8ab2919d4559f311bef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODk3MzM4OTE4ZGFjMDcyZTc4OGI4YWIyOTE5ZDQ1NTlmMzExYmVm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-02T18:30:36Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-08-15T17:12:15Z"
      },
      "message": "[tests] Introduce TestNode\n\nTestNode is a class responsible for all state related to a bitcoind node\nunder test. It stores local state, is responsible for tracking the\nbitcoind process and delegates unrecognised messages to the RPC\nconnection.\n\nThis commit changes start_nodes and stop_nodes to start and stop the\nbitcoind nodes in parallel, making test setup and teardown much faster.",
      "tree": {
        "sha": "e514317914448eaf783a2b5b980ba9339895bbdb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e514317914448eaf783a2b5b980ba9339895bbdb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7897338918dac072e788b8ab2919d4559f311bef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7897338918dac072e788b8ab2919d4559f311bef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7897338918dac072e788b8ab2919d4559f311bef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7897338918dac072e788b8ab2919d4559f311bef/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e526ca6284b9e13be1b912b80dd73a34e739b539",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e526ca6284b9e13be1b912b80dd73a34e739b539",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e526ca6284b9e13be1b912b80dd73a34e739b539"
      }
    ],
    "stats": {
      "total": 290,
      "additions": 193,
      "deletions": 97
    },
    "files": [
      {
        "sha": "0812e1b0df90932d24a208f77621116523ff7bf7",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -139,13 +139,13 @@ def _test_stopatheight(self):\n         self.nodes[0].generate(6)\n         assert_equal(self.nodes[0].getblockcount(), 206)\n         self.log.debug('Node should not stop at this height')\n-        assert_raises(subprocess.TimeoutExpired, lambda: self.bitcoind_processes[0].wait(timeout=3))\n+        assert_raises(subprocess.TimeoutExpired, lambda: self.nodes[0].process.wait(timeout=3))\n         try:\n             self.nodes[0].generate(1)\n         except (ConnectionError, http.client.BadStatusLine):\n             pass  # The node already shut down before response\n         self.log.debug('Node should stop at this height...')\n-        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.nodes[0].process.wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n         assert_equal(self.nodes[0].getblockcount(), 207)\n "
      },
      {
        "sha": "3c488f609a3e0cdf8cf8b229206132dec1cb12b6",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -41,8 +41,7 @@ def setup_network(self, split=False):\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n         # Encrypt wallet for test_locked_wallet_fails test\n-        self.nodes[1].encryptwallet(WALLET_PASSPHRASE)\n-        self.bitcoind_processes[1].wait()\n+        self.nodes[1].node_encrypt_wallet(WALLET_PASSPHRASE)\n         self.nodes[1] = self.start_node(1, self.options.tmpdir, extra_args[1])\n         self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n "
      },
      {
        "sha": "f2f4efcf28f14ace9753329d335a141fb5c8cb2b",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -451,8 +451,7 @@ def run_test(self):\n         self.stop_node(0)\n         self.stop_node(2)\n         self.stop_node(3)\n-        self.nodes[1].encryptwallet(\"test\")\n-        self.bitcoind_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.nodes[1].node_encrypt_wallet(\"test\")\n \n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n         # This test is not meant to test fee estimation and we'd like"
      },
      {
        "sha": "cca30e2688e4d8ad8ba551520bfafe6bafbdafb7",
        "filename": "test/functional/getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/getblocktemplate_longpoll.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -17,7 +17,7 @@ def __init__(self, node):\n         self.longpollid = templat['longpollid']\n         # create a new connection to the node, we can't use the same\n         # connection from two threads\n-        self.node = get_rpc_proxy(node.url, 1, timeout=600)\n+        self.node = get_rpc_proxy(node.url, 1, timeout=600, coveragedir=node.coverage_dir)\n \n     def run(self):\n         self.node.getblocktemplate({'longpollid':self.longpollid})"
      },
      {
        "sha": "3e7bb0ee072057f463d195847e066c387c4d12a0",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -17,8 +17,7 @@ def run_test(self):\n         assert(addr_before_encrypting_data['hdmasterkeyid'] == wallet_info_old['hdmasterkeyid'])\n         \n         # Encrypt wallet and wait to terminate\n-        nodes[0].encryptwallet('test')\n-        self.bitcoind_processes[0].wait()\n+        nodes[0].node_encrypt_wallet('test')\n         # Restart node 0\n         nodes[0] = self.start_node(0, self.options.tmpdir)\n         # Keep creating keys"
      },
      {
        "sha": "fc6e8e325f605f5d494580551747b70ade4e9fc3",
        "filename": "test/functional/multiwallet.py",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multiwallet.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -35,11 +35,15 @@ def run_test(self):\n \n         self.nodes[0] = self.start_node(0, self.options.tmpdir, self.extra_args[0])\n \n-        w1 = self.nodes[0] / \"wallet/w1\"\n+        w1 = self.nodes[0].get_wallet_rpc(\"w1\")\n+        w2 = self.nodes[0].get_wallet_rpc(\"w2\")\n+        w3 = self.nodes[0].get_wallet_rpc(\"w3\")\n+        wallet_bad = self.nodes[0].get_wallet_rpc(\"bad\")\n+\n         w1.generate(1)\n \n         # accessing invalid wallet fails\n-        assert_raises_jsonrpc(-18, \"Requested wallet does not exist or is not loaded\", (self.nodes[0] / \"wallet/bad\").getwalletinfo)\n+        assert_raises_jsonrpc(-18, \"Requested wallet does not exist or is not loaded\", wallet_bad.getwalletinfo)\n \n         # accessing wallet RPC without using wallet endpoint fails\n         assert_raises_jsonrpc(-19, \"Wallet file not specified\", self.nodes[0].getwalletinfo)\n@@ -50,14 +54,12 @@ def run_test(self):\n         w1_name = w1_info['walletname']\n         assert_equal(w1_name, \"w1\")\n \n-        # check w1 wallet balance\n-        w2 = self.nodes[0] / \"wallet/w2\"\n+        # check w2 wallet balance\n         w2_info = w2.getwalletinfo()\n         assert_equal(w2_info['immature_balance'], 0)\n         w2_name = w2_info['walletname']\n         assert_equal(w2_name, \"w2\")\n \n-        w3 = self.nodes[0] / \"wallet/w3\"\n         w3_name = w3.getwalletinfo()['walletname']\n         assert_equal(w3_name, \"w3\")\n "
      },
      {
        "sha": "20808207b2bc80729f99d94872fdaa5da300c01a",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -37,7 +37,7 @@ def run_bind_test(self, allow_ips, connect_to, addresses, expected):\n             base_args += ['-rpcallowip=' + x for x in allow_ips]\n         binds = ['-rpcbind='+addr for addr in addresses]\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n-        pid = self.bitcoind_processes[0].pid\n+        pid = self.nodes[0].process.pid\n         assert_equal(set(get_bind_addrs(pid)), set(expected))\n         self.stop_nodes()\n \n@@ -49,7 +49,7 @@ def run_allowip_test(self, allow_ips, rpchost, rpcport):\n         base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args])\n         # connect to node through non-loopback interface\n-        node = get_rpc_proxy(rpc_url(get_datadir_path(self.options.tmpdir, 0), 0, \"%s:%d\" % (rpchost, rpcport)), 0)\n+        node = get_rpc_proxy(rpc_url(get_datadir_path(self.options.tmpdir, 0), 0, \"%s:%d\" % (rpchost, rpcport)), 0, coveragedir=self.options.coveragedir)\n         node.getnetworkinfo()\n         self.stop_nodes()\n "
      },
      {
        "sha": "d8a8b56f929662a21c8e0ee8b3a1a084bc0b3f42",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 40,
        "deletions": 75,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -5,34 +5,29 @@\n \"\"\"Base class for RPC testing.\"\"\"\n \n from collections import deque\n-import errno\n from enum import Enum\n-import http.client\n import logging\n import optparse\n import os\n import shutil\n-import subprocess\n import sys\n import tempfile\n import time\n import traceback\n \n from .authproxy import JSONRPCException\n from . import coverage\n+from .test_node import TestNode\n from .util import (\n     MAX_NODES,\n     PortSeed,\n     assert_equal,\n     check_json_precision,\n     connect_nodes_bi,\n     disconnect_nodes,\n-    get_rpc_proxy,\n     initialize_datadir,\n-    get_datadir_path,\n     log_filename,\n     p2p_port,\n-    rpc_url,\n     set_node_times,\n     sync_blocks,\n     sync_mempools,\n@@ -69,7 +64,6 @@ def __init__(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = False\n         self.nodes = []\n-        self.bitcoind_processes = {}\n         self.mocktime = 0\n \n     def add_options(self, parser):\n@@ -206,64 +200,62 @@ def main(self):\n     def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n         \"\"\"Start a bitcoind and return RPC connection to it\"\"\"\n \n-        datadir = os.path.join(dirname, \"node\" + str(i))\n+        if extra_args is None:\n+            extra_args = []\n         if binary is None:\n             binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-        args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(self.mocktime), \"-uacomment=testnode%d\" % i]\n-        if extra_args is not None:\n-            args.extend(extra_args)\n-        self.bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n-        self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-        self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i, rpchost)\n-        self.log.debug(\"initialize_chain: RPC successfully started\")\n-        proxy = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, timeout=timewait)\n+        node = TestNode(i, dirname, extra_args, rpchost, timewait, binary, stderr, self.mocktime, coverage_dir=self.options.coveragedir)\n+        node.start()\n+        node.wait_for_rpc_connection()\n \n-        if self.options.coveragedir:\n-            coverage.write_all_rpc_commands(self.options.coveragedir, proxy)\n+        if self.options.coveragedir is not None:\n+            coverage.write_all_rpc_commands(self.options.coveragedir, node.rpc)\n \n-        return proxy\n+        return node\n \n     def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n         \"\"\"Start multiple bitcoinds, return RPC connections to them\"\"\"\n \n         if extra_args is None:\n-            extra_args = [None] * num_nodes\n+            extra_args = [[]] * num_nodes\n         if binary is None:\n             binary = [None] * num_nodes\n         assert_equal(len(extra_args), num_nodes)\n         assert_equal(len(binary), num_nodes)\n-        rpcs = []\n+        nodes = []\n         try:\n             for i in range(num_nodes):\n-                rpcs.append(self.start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n+                nodes.append(TestNode(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i], stderr=None, mocktime=self.mocktime, coverage_dir=self.options.coveragedir))\n+                nodes[i].start()\n+            for node in nodes:\n+                node.wait_for_rpc_connection()\n         except:\n             # If one node failed to start, stop the others\n-            # TODO: abusing self.nodes in this way is a little hacky.\n-            # Eventually we should do a better job of tracking nodes\n-            self.nodes.extend(rpcs)\n             self.stop_nodes()\n-            self.nodes = []\n             raise\n-        return rpcs\n+\n+        if self.options.coveragedir is not None:\n+            for node in nodes:\n+                coverage.write_all_rpc_commands(self.options.coveragedir, node.rpc)\n+\n+        return nodes\n \n     def stop_node(self, i):\n         \"\"\"Stop a bitcoind test node\"\"\"\n-\n-        self.log.debug(\"Stopping node %d\" % i)\n-        try:\n-            self.nodes[i].stop()\n-        except http.client.CannotSendRequest as e:\n-            self.log.exception(\"Unable to stop node\")\n-        return_code = self.bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n-        del self.bitcoind_processes[i]\n-        assert_equal(return_code, 0)\n+        self.nodes[i].stop_node()\n+        while not self.nodes[i].is_node_stopped():\n+            time.sleep(0.1)\n \n     def stop_nodes(self):\n         \"\"\"Stop multiple bitcoind test nodes\"\"\"\n+        for node in self.nodes:\n+            # Issue RPC to stop nodes\n+            node.stop_node()\n \n-        for i in range(len(self.nodes)):\n-            self.stop_node(i)\n-        assert not self.bitcoind_processes.values()  # All connections must be gone now\n+        for node in self.nodes:\n+            # Wait for nodes to stop\n+            while not node.is_node_stopped():\n+                time.sleep(0.1)\n \n     def assert_start_raises_init_error(self, i, dirname, extra_args=None, expected_msg=None):\n         with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n@@ -272,6 +264,8 @@ def assert_start_raises_init_error(self, i, dirname, extra_args=None, expected_m\n                 self.stop_node(i)\n             except Exception as e:\n                 assert 'bitcoind exited' in str(e)  # node must have shutdown\n+                self.nodes[i].running = False\n+                self.nodes[i].process = None\n                 if expected_msg is not None:\n                     log_stderr.seek(0)\n                     stderr = log_stderr.read().decode('utf-8')\n@@ -285,7 +279,7 @@ def assert_start_raises_init_error(self, i, dirname, extra_args=None, expected_m\n                 raise AssertionError(assert_msg)\n \n     def wait_for_node_exit(self, i, timeout):\n-        self.bitcoind_processes[i].wait(timeout)\n+        self.nodes[i].process.wait(timeout)\n \n     def split_network(self):\n         \"\"\"\n@@ -382,18 +376,13 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n                 args = [os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\" + datadir, \"-discover=0\"]\n                 if i > 0:\n                     args.append(\"-connect=127.0.0.1:\" + str(p2p_port(0)))\n-                self.bitcoind_processes[i] = subprocess.Popen(args)\n-                self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-                self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i)\n-                self.log.debug(\"initialize_chain: RPC successfully started\")\n+                self.nodes.append(TestNode(i, cachedir, extra_args=[], rpchost=None, timewait=None, binary=None, stderr=None, mocktime=self.mocktime, coverage_dir=None))\n+                self.nodes[i].args = args\n+                self.nodes[i].start()\n \n-            self.nodes = []\n-            for i in range(MAX_NODES):\n-                try:\n-                    self.nodes.append(get_rpc_proxy(rpc_url(get_datadir_path(cachedir, i), i), i))\n-                except:\n-                    self.log.exception(\"Error connecting to node %d\" % i)\n-                    sys.exit(1)\n+            # Wait for RPC connections to be ready\n+            for node in self.nodes:\n+                node.wait_for_rpc_connection()\n \n             # Create a 200-block-long chain; each of the 4 first nodes\n             # gets 25 mature blocks and 25 immature.\n@@ -437,30 +426,6 @@ def _initialize_chain_clean(self, test_dir, num_nodes):\n         for i in range(num_nodes):\n             initialize_datadir(test_dir, i)\n \n-    def _wait_for_bitcoind_start(self, process, datadir, i, rpchost=None):\n-        \"\"\"Wait for bitcoind to start.\n-\n-        This means that RPC is accessible and fully initialized.\n-        Raise an exception if bitcoind exits during initialization.\"\"\"\n-        while True:\n-            if process.poll() is not None:\n-                raise Exception('bitcoind exited with status %i during initialization' % process.returncode)\n-            try:\n-                # Check if .cookie file to be created\n-                rpc = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, coveragedir=self.options.coveragedir)\n-                rpc.getblockcount()\n-                break  # break out of loop on success\n-            except IOError as e:\n-                if e.errno != errno.ECONNREFUSED:  # Port not yet open?\n-                    raise  # unknown IO error\n-            except JSONRPCException as e:  # Initialization phase\n-                if e.error['code'] != -28:  # RPC in warmup?\n-                    raise  # unknown JSON RPC exception\n-            except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n-                if \"No RPC credentials\" not in str(e):\n-                    raise\n-            time.sleep(0.25)\n-\n class ComparisonTestFramework(BitcoinTestFramework):\n     \"\"\"Test framework for doing p2p comparison testing\n "
      },
      {
        "sha": "66f89d43f4fcbcac6c0d3676fdc16fdeadeacd1c",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -0,0 +1,134 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for bitcoind node under test\"\"\"\n+\n+import errno\n+import http.client\n+import logging\n+import os\n+import subprocess\n+import time\n+\n+from .util import (\n+    assert_equal,\n+    get_rpc_proxy,\n+    rpc_url,\n+)\n+from .authproxy import JSONRPCException\n+\n+class TestNode():\n+    \"\"\"A class for representing a bitcoind node under test.\n+\n+    This class contains:\n+\n+    - state about the node (whether it's running, etc)\n+    - a Python subprocess.Popen object representing the running process\n+    - an RPC connection to the node\n+\n+    To make things easier for the test writer, a bit of magic is happening under the covers.\n+    Any unrecognised messages will be dispatched to the RPC connection.\"\"\"\n+\n+    def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mocktime, coverage_dir):\n+        self.index = i\n+        self.datadir = os.path.join(dirname, \"node\" + str(i))\n+        self.rpchost = rpchost\n+        self.rpc_timeout = timewait\n+        if binary is None:\n+            self.binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n+        else:\n+            self.binary = binary\n+        self.stderr = stderr\n+        self.coverage_dir = coverage_dir\n+        # Most callers will just need to add extra args to the standard list below. For those callers that need more flexibity, they can just set the args property directly.\n+        self.extra_args = extra_args\n+        self.args = [self.binary, \"-datadir=\" + self.datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(mocktime), \"-uacomment=testnode%d\" % i]\n+\n+        self.running = False\n+        self.process = None\n+        self.rpc_connected = False\n+        self.rpc = None\n+        self.url = None\n+        self.log = logging.getLogger('TestFramework.node%d' % i)\n+\n+    def __getattr__(self, *args, **kwargs):\n+        \"\"\"Dispatches any unrecognised messages to the RPC connection.\"\"\"\n+        assert self.rpc_connected and self.rpc is not None, \"Error: no RPC connection\"\n+        return self.rpc.__getattr__(*args, **kwargs)\n+\n+    def start(self):\n+        \"\"\"Start the node.\"\"\"\n+        self.process = subprocess.Popen(self.args + self.extra_args, stderr=self.stderr)\n+        self.running = True\n+        self.log.debug(\"bitcoind started, waiting for RPC to come up\")\n+\n+    def wait_for_rpc_connection(self):\n+        \"\"\"Sets up an RPC connection to the bitcoind process. Returns False if unable to connect.\"\"\"\n+\n+        # Wait for up to 10 seconds for the RPC server to respond\n+        for _ in range(40):\n+            assert not self.process.poll(), \"bitcoind exited with status %i during initialization\" % self.process.returncode\n+            try:\n+                self.rpc = get_rpc_proxy(rpc_url(self.datadir, self.index, self.rpchost), self.index, coveragedir=self.coverage_dir)\n+                self.rpc.getblockcount()\n+                # If the call to getblockcount() succeeds then the RPC connection is up\n+                self.rpc_connected = True\n+                self.url = self.rpc.url\n+                self.log.debug(\"RPC successfully started\")\n+                return\n+            except IOError as e:\n+                if e.errno != errno.ECONNREFUSED:  # Port not yet open?\n+                    raise  # unknown IO error\n+            except JSONRPCException as e:  # Initialization phase\n+                if e.error['code'] != -28:  # RPC in warmup?\n+                    raise  # unknown JSON RPC exception\n+            except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n+                if \"No RPC credentials\" not in str(e):\n+                    raise\n+            time.sleep(0.25)\n+        raise AssertionError(\"Unable to connect to bitcoind\")\n+\n+    def get_wallet_rpc(self, wallet_name):\n+        assert self.rpc_connected\n+        assert self.rpc\n+        wallet_path = \"wallet/%s\" % wallet_name\n+        return self.rpc / wallet_path\n+\n+    def stop_node(self):\n+        \"\"\"Stop the node.\"\"\"\n+        if not self.running:\n+            return\n+        self.log.debug(\"Stopping node\")\n+        try:\n+            self.stop()\n+        except http.client.CannotSendRequest:\n+            self.log.exception(\"Unable to stop node.\")\n+\n+    def is_node_stopped(self):\n+        \"\"\"Checks whether the node has stopped.\n+\n+        Returns True if the node has stopped. False otherwise.\n+        This method is responsible for freeing resources (self.process).\"\"\"\n+        if not self.running:\n+            return True\n+        return_code = self.process.poll()\n+        if return_code is not None:\n+            # process has stopped. Assert that it didn't return an error code.\n+            assert_equal(return_code, 0)\n+            self.running = False\n+            self.process = None\n+            self.log.debug(\"Node stopped\")\n+            return True\n+        return False\n+\n+    def node_encrypt_wallet(self, passphrase):\n+        \"\"\"\"Encrypts the wallet.\n+\n+        This causes bitcoind to shutdown, so this method takes\n+        care of cleaning up resources.\"\"\"\n+        self.encryptwallet(passphrase)\n+        while not self.is_node_stopped():\n+            time.sleep(0.1)\n+        self.rpc = None\n+        self.rpc_connected = False"
      },
      {
        "sha": "4098fd86152acd44f77df05c6ba56bec908a18bb",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -204,7 +204,7 @@ def rpc_port(n):\n     return PORT_MIN + PORT_RANGE + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n def rpc_url(datadir, i, rpchost=None):\n-    rpc_u, rpc_p = get_auth_cookie(datadir, i)\n+    rpc_u, rpc_p = get_auth_cookie(datadir)\n     host = '127.0.0.1'\n     port = rpc_port(i)\n     if rpchost:\n@@ -232,7 +232,7 @@ def initialize_datadir(dirname, n):\n def get_datadir_path(dirname, n):\n     return os.path.join(dirname, \"node\" + str(n))\n \n-def get_auth_cookie(datadir, n):\n+def get_auth_cookie(datadir):\n     user = None\n     password = None\n     if os.path.isfile(os.path.join(datadir, \"bitcoin.conf\")):"
      },
      {
        "sha": "61ad00330bd74225714c0b7f6e5384990679d2e9",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -94,8 +94,7 @@ def run_test (self):\n         assert_equal(found_addr_rsv, 90*2) # 90 keys plus 100% internal keys\n \n         #encrypt wallet, restart, unlock and dump\n-        self.nodes[0].encryptwallet('test')\n-        self.bitcoind_processes[0].wait()\n+        self.nodes[0].node_encrypt_wallet('test')\n         self.nodes[0] = self.start_node(0, self.options.tmpdir, self.extra_args[0])\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:"
      },
      {
        "sha": "8fea4140db7591b32800de4e82471fcd44fe9228",
        "filename": "test/functional/wallet-encryption.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7897338918dac072e788b8ab2919d4559f311bef/test/functional/wallet-encryption.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7897338918dac072e788b8ab2919d4559f311bef/test/functional/wallet-encryption.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-encryption.py?ref=7897338918dac072e788b8ab2919d4559f311bef",
        "patch": "@@ -30,8 +30,7 @@ def run_test(self):\n         assert_equal(len(privkey), 52)\n \n         # Encrypt the wallet\n-        self.nodes[0].encryptwallet(passphrase)\n-        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.nodes[0].node_encrypt_wallet(passphrase)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n \n         # Test that the wallet is encrypted"
      }
    ]
  }
]