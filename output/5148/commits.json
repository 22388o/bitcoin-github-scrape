[
  {
    "sha": "ffd8eddab540a9692bef681f2637f757d84e28a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZmQ4ZWRkYWI1NDBhOTY5MmJlZjY4MWYyNjM3Zjc1N2Q4NGUyOGEy",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-26T08:33:52Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-28T04:02:25Z"
      },
      "message": "Update comments in key to be doxygen compatible",
      "tree": {
        "sha": "aacdfe4508c2641b3bdf334c66fca1c5d92954da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aacdfe4508c2641b3bdf334c66fca1c5d92954da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffd8eddab540a9692bef681f2637f757d84e28a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffd8eddab540a9692bef681f2637f757d84e28a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ffd8eddab540a9692bef681f2637f757d84e28a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffd8eddab540a9692bef681f2637f757d84e28a2/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "068b7f8ee23f4557d356db30b4cbbd98065bd27c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/068b7f8ee23f4557d356db30b4cbbd98065bd27c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/068b7f8ee23f4557d356db30b4cbbd98065bd27c"
      }
    ],
    "stats": {
      "total": 147,
      "additions": 82,
      "deletions": 65
    },
    "files": [
      {
        "sha": "48431f3dc57f2b35560f0c84cf23c1caf1086188",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffd8eddab540a9692bef681f2637f757d84e28a2/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffd8eddab540a9692bef681f2637f757d84e28a2/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=ffd8eddab540a9692bef681f2637f757d84e28a2",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2014 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"key.h\"\n@@ -13,7 +13,7 @@\n #include \"ecwrapper.h\"\n #endif\n \n-// anonymous namespace\n+//! anonymous namespace with local implementation code (OpenSSL interaction)\n namespace {\n \n #ifdef USE_SECP256K1\n@@ -56,15 +56,15 @@ int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char\n     return 0;\n }\n \n-// Order of secp256k1's generator minus 1.\n+/** Order of secp256k1's generator minus 1. */\n const unsigned char vchMaxModOrder[32] = {\n     0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n     0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n     0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n     0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x40\n };\n \n-// Half of the order of secp256k1's generator minus 1.\n+/** Half of the order of secp256k1's generator minus 1. */\n const unsigned char vchMaxModHalfOrder[32] = {\n     0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n     0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,"
      },
      {
        "sha": "b4cb64768115af7a86f2b8901c8e09ec45a18ca6",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 78,
        "deletions": 61,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ffd8eddab540a9692bef681f2637f757d84e28a2/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ffd8eddab540a9692bef681f2637f757d84e28a2/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=ffd8eddab540a9692bef681f2637f757d84e28a2",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_KEY_H\n@@ -14,13 +14,15 @@\n #include <stdexcept>\n #include <vector>\n \n-// secp256k1:\n-// const unsigned int PRIVATE_KEY_SIZE = 279;\n-// const unsigned int PUBLIC_KEY_SIZE  = 65;\n-// const unsigned int SIGNATURE_SIZE   = 72;\n-//\n-// see www.keylength.com\n-// script supports up to 75 for single byte push\n+/** \n+ * secp256k1:\n+ * const unsigned int PRIVATE_KEY_SIZE = 279;\n+ * const unsigned int PUBLIC_KEY_SIZE  = 65;\n+ * const unsigned int SIGNATURE_SIZE   = 72;\n+ *\n+ * see www.keylength.com\n+ * script supports up to 75 for single byte push\n+ */\n \n /** A reference to a CKey: the Hash160 of its serialized public key */\n class CKeyID : public uint160\n@@ -34,11 +36,14 @@ class CKeyID : public uint160\n class CPubKey\n {\n private:\n-    // Just store the serialized data.\n-    // Its length can very cheaply be computed from the first byte.\n+\n+    /**\n+     * Just store the serialized data.\n+     * Its length can very cheaply be computed from the first byte.\n+     */\n     unsigned char vch[65];\n \n-    // Compute the length of a pubkey with a given first byte.\n+    //! Compute the length of a pubkey with a given first byte.\n     unsigned int static GetLen(unsigned char chHeader)\n     {\n         if (chHeader == 2 || chHeader == 3)\n@@ -48,20 +53,20 @@ class CPubKey\n         return 0;\n     }\n \n-    // Set this key data to be invalid\n+    //! Set this key data to be invalid\n     void Invalidate()\n     {\n         vch[0] = 0xFF;\n     }\n \n public:\n-    // Construct an invalid public key.\n+    //! Construct an invalid public key.\n     CPubKey()\n     {\n         Invalidate();\n     }\n \n-    // Initialize a public key using begin/end iterators to byte data.\n+    //! Initialize a public key using begin/end iterators to byte data.\n     template <typename T>\n     void Set(const T pbegin, const T pend)\n     {\n@@ -72,26 +77,26 @@ class CPubKey\n             Invalidate();\n     }\n \n-    // Construct a public key using begin/end iterators to byte data.\n+    //! Construct a public key using begin/end iterators to byte data.\n     template <typename T>\n     CPubKey(const T pbegin, const T pend)\n     {\n         Set(pbegin, pend);\n     }\n \n-    // Construct a public key from a byte vector.\n+    //! Construct a public key from a byte vector.\n     CPubKey(const std::vector<unsigned char>& vch)\n     {\n         Set(vch.begin(), vch.end());\n     }\n \n-    // Simple read-only vector-like interface to the pubkey data.\n+    //! Simple read-only vector-like interface to the pubkey data.\n     unsigned int size() const { return GetLen(vch[0]); }\n     const unsigned char* begin() const { return vch; }\n     const unsigned char* end() const { return vch + size(); }\n     const unsigned char& operator[](unsigned int pos) const { return vch[pos]; }\n \n-    // Comparator implementation.\n+    //! Comparator implementation.\n     friend bool operator==(const CPubKey& a, const CPubKey& b)\n     {\n         return a.vch[0] == b.vch[0] &&\n@@ -107,7 +112,7 @@ class CPubKey\n                (a.vch[0] == b.vch[0] && memcmp(a.vch, b.vch, a.size()) < 0);\n     }\n \n-    // Implement serialization, as if this was a byte vector.\n+    //! Implement serialization, as if this was a byte vector.\n     unsigned int GetSerializeSize(int nType, int nVersion) const\n     {\n         return size() + 1;\n@@ -134,86 +139,92 @@ class CPubKey\n         }\n     }\n \n-    // Get the KeyID of this public key (hash of its serialization)\n+    //! Get the KeyID of this public key (hash of its serialization)\n     CKeyID GetID() const\n     {\n         return CKeyID(Hash160(vch, vch + size()));\n     }\n \n-    // Get the 256-bit hash of this public key.\n+    //! Get the 256-bit hash of this public key.\n     uint256 GetHash() const\n     {\n         return Hash(vch, vch + size());\n     }\n \n-    // Check syntactic correctness.\n-    //\n-    // Note that this is consensus critical as CheckSig() calls it!\n+    /*\n+     * Check syntactic correctness.\n+     * \n+     * Note that this is consensus critical as CheckSig() calls it!\n+     */\n     bool IsValid() const\n     {\n         return size() > 0;\n     }\n \n-    // fully validate whether this is a valid public key (more expensive than IsValid())\n+    //! fully validate whether this is a valid public key (more expensive than IsValid())\n     bool IsFullyValid() const;\n \n-    // Check whether this is a compressed public key.\n+    //! Check whether this is a compressed public key.\n     bool IsCompressed() const\n     {\n         return size() == 33;\n     }\n \n-    // Verify a DER signature (~72 bytes).\n-    // If this public key is not fully valid, the return value will be false.\n+    /**\n+     * Verify a DER signature (~72 bytes).\n+     * If this public key is not fully valid, the return value will be false.\n+     */\n     bool Verify(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\n \n-    // Recover a public key from a compact signature.\n+    //! Recover a public key from a compact signature.\n     bool RecoverCompact(const uint256& hash, const std::vector<unsigned char>& vchSig);\n \n-    // Turn this public key into an uncompressed public key.\n+    //! Turn this public key into an uncompressed public key.\n     bool Decompress();\n \n-    // Derive BIP32 child pubkey.\n+    //! Derive BIP32 child pubkey.\n     bool Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n };\n \n \n-// secure_allocator is defined in allocators.h\n-// CPrivKey is a serialized private key, with all parameters included (279 bytes)\n+/**\n+ * secure_allocator is defined in allocators.h\n+ * CPrivKey is a serialized private key, with all parameters included (279 bytes)\n+ */\n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CPrivKey;\n \n /** An encapsulated private key. */\n class CKey\n {\n private:\n-    // Whether this private key is valid. We check for correctness when modifying the key\n-    // data, so fValid should always correspond to the actual state.\n+    //! Whether this private key is valid. We check for correctness when modifying the key\n+    //! data, so fValid should always correspond to the actual state.\n     bool fValid;\n \n-    // Whether the public key corresponding to this private key is (to be) compressed.\n+    //! Whether the public key corresponding to this private key is (to be) compressed.\n     bool fCompressed;\n \n-    // The actual byte data\n+    //! The actual byte data\n     unsigned char vch[32];\n \n-    // Check whether the 32-byte array pointed to be vch is valid keydata.\n+    //! Check whether the 32-byte array pointed to be vch is valid keydata.\n     bool static Check(const unsigned char* vch);\n \n public:\n-    // Construct an invalid private key.\n+    //! Construct an invalid private key.\n     CKey() : fValid(false), fCompressed(false)\n     {\n         LockObject(vch);\n     }\n \n-    // Copy constructor. This is necessary because of memlocking.\n+    //! Copy constructor. This is necessary because of memlocking.\n     CKey(const CKey& secret) : fValid(secret.fValid), fCompressed(secret.fCompressed)\n     {\n         LockObject(vch);\n         memcpy(vch, secret.vch, sizeof(vch));\n     }\n \n-    // Destructor (again necessary because of memlocking).\n+    //! Destructor (again necessary because of memlocking).\n     ~CKey()\n     {\n         UnlockObject(vch);\n@@ -225,7 +236,7 @@ class CKey\n                memcmp(&a.vch[0], &b.vch[0], a.size()) == 0;\n     }\n \n-    // Initialize using begin and end iterators to byte data.\n+    //! Initialize using begin and end iterators to byte data.\n     template <typename T>\n     void Set(const T pbegin, const T pend, bool fCompressedIn)\n     {\n@@ -242,48 +253,54 @@ class CKey\n         }\n     }\n \n-    // Simple read-only vector-like interface.\n+    //! Simple read-only vector-like interface.\n     unsigned int size() const { return (fValid ? 32 : 0); }\n     const unsigned char* begin() const { return vch; }\n     const unsigned char* end() const { return vch + size(); }\n \n-    // Check whether this private key is valid.\n+    //! Check whether this private key is valid.\n     bool IsValid() const { return fValid; }\n \n-    // Check whether the public key corresponding to this private key is (to be) compressed.\n+    //! Check whether the public key corresponding to this private key is (to be) compressed.\n     bool IsCompressed() const { return fCompressed; }\n \n-    // Initialize from a CPrivKey (serialized OpenSSL private key data).\n+    //! Initialize from a CPrivKey (serialized OpenSSL private key data).\n     bool SetPrivKey(const CPrivKey& vchPrivKey, bool fCompressed);\n \n-    // Generate a new private key using a cryptographic PRNG.\n+    //! Generate a new private key using a cryptographic PRNG.\n     void MakeNewKey(bool fCompressed);\n \n-    // Convert the private key to a CPrivKey (serialized OpenSSL private key data).\n-    // This is expensive.\n+    /**\n+     * Convert the private key to a CPrivKey (serialized OpenSSL private key data).\n+     * This is expensive. \n+     */\n     CPrivKey GetPrivKey() const;\n \n-    // Compute the public key from a private key.\n-    // This is expensive.\n+    /**\n+     * Compute the public key from a private key.\n+     * This is expensive.\n+     */\n     CPubKey GetPubKey() const;\n \n-    // Create a DER-serialized signature.\n+    //! Create a DER-serialized signature.\n     bool Sign(const uint256& hash, std::vector<unsigned char>& vchSig, bool lowS = true) const;\n \n-    // Create a compact signature (65 bytes), which allows reconstructing the used public key.\n-    // The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n-    // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n-    //                  0x1D = second key with even y, 0x1E = second key with odd y,\n-    //                  add 0x04 for compressed keys.\n+    /**\n+     * Create a compact signature (65 bytes), which allows reconstructing the used public key.\n+     * The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n+     * The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n+     *                  0x1D = second key with even y, 0x1E = second key with odd y,\n+     *                  add 0x04 for compressed keys.\n+     */\n     bool SignCompact(const uint256& hash, std::vector<unsigned char>& vchSig) const;\n \n-    // Derive BIP32 child key.\n+    //! Derive BIP32 child key.\n     bool Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const;\n \n-    // Load private key and check that public key matches.\n+    //! Load private key and check that public key matches.\n     bool Load(CPrivKey& privkey, CPubKey& vchPubKey, bool fSkipCheck);\n \n-    // Check whether an element of a signature (r or s) is valid.\n+    //! Check whether an element of a signature (r or s) is valid.\n     static bool CheckSignatureElement(const unsigned char* vch, int len, bool half);\n };\n "
      }
    ]
  },
  {
    "sha": "2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYjE3M2QzYmNjYThmZGQ4OWE5MmViMjA1OGJlMzQxYjNhNjFhMWM4",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-26T08:35:06Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-10-28T04:06:59Z"
      },
      "message": "Update comments in keystore to be doxygen compatible",
      "tree": {
        "sha": "54425fb51cf5882671d38c111c8decb594870493",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/54425fb51cf5882671d38c111c8decb594870493"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ffd8eddab540a9692bef681f2637f757d84e28a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ffd8eddab540a9692bef681f2637f757d84e28a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ffd8eddab540a9692bef681f2637f757d84e28a2"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 9,
      "deletions": 9
    },
    "files": [
      {
        "sha": "c466e84f2691acf236993e1d2fd473eb8276aca7",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
        "patch": "@@ -13,7 +13,7 @@\n #include \"ecwrapper.h\"\n #endif\n \n-//! anonymous namespace with local implementation code (OpenSSL interaction)\n+//! anonymous namespace\n namespace {\n \n #ifdef USE_SECP256K1"
      },
      {
        "sha": "879f09972014c3dfc9c45cd533456a22d6970718",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"keystore.h\""
      },
      {
        "sha": "66f8771d4a80eeec1237dedc62cf1e4bc5608445",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b173d3bcca8fdd89a92eb2058be341b3a61a1c8/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=2b173d3bcca8fdd89a92eb2058be341b3a61a1c8",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_KEYSTORE_H\n@@ -24,22 +24,22 @@ class CKeyStore\n public:\n     virtual ~CKeyStore() {}\n \n-    // Add a key to the store.\n+    //! Add a key to the store.\n     virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) =0;\n     virtual bool AddKey(const CKey &key);\n \n-    // Check whether a key corresponding to a given address is present in the store.\n+    //! Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CKeyID &address) const =0;\n     virtual bool GetKey(const CKeyID &address, CKey& keyOut) const =0;\n     virtual void GetKeys(std::set<CKeyID> &setAddress) const =0;\n     virtual bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n \n-    // Support for BIP 0013 : see https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki\n+    //! Support for BIP 0013 : see https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki\n     virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const CScriptID &hash) const =0;\n     virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n \n-    // Support for Watch-only addresses\n+    //! Support for Watch-only addresses\n     virtual bool AddWatchOnly(const CScript &dest) =0;\n     virtual bool RemoveWatchOnly(const CScript &dest) =0;\n     virtual bool HaveWatchOnly(const CScript &dest) const =0;"
      }
    ]
  }
]