[
  {
    "sha": "caad33fb232b7d217a3f218ba50f8dd299cd41a6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYWFkMzNmYjIzMmI3ZDIxN2EzZjIxOGJhNTBmOGRkMjk5Y2Q0MWE2",
    "commit": {
      "author": {
        "name": "EthanHeilman",
        "email": "ethan.r.heilman@gmail.com",
        "date": "2015-06-19T18:54:36Z"
      },
      "committer": {
        "name": "EthanHeilman",
        "email": "ethan.r.heilman@gmail.com",
        "date": "2015-06-29T21:44:19Z"
      },
      "message": "Added test-before-evict discipline in Addrman, feeler connections.\n\nChanges addrman to use the test-before-evict discipline in which an\naddress is to be evicted from the tried table is first tested and if\nit is still online it is not evicted.\n\nCreates a new thread which tests if addresses are online or offline by\nbriefly connecting to them. These short lived connections are referred\nto as feeler connections. Feeler connections have two purposes:\nFirst, to increase the number of addresses in tried, by selecting and\nconnecting to addresses in new. Second, to implement the testing stage\nof the test-before-evict discipline.\n\nAdds tests to provide test coverage for these changes.\n\nThis change was suggested as Countermeasure 3 and 4 in\nEclipse Attacks on Bitcoin\u2019s Peer-to-Peer Network, Ethan Heilman,\nAlison Kendler, Aviv Zohar, Sharon Goldberg. ePrint Archive Report\n2015/263. March 2015.",
      "tree": {
        "sha": "42f1cc40faa61d285efb0df6947e4c8f5742f4a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42f1cc40faa61d285efb0df6947e4c8f5742f4a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/caad33fb232b7d217a3f218ba50f8dd299cd41a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/caad33fb232b7d217a3f218ba50f8dd299cd41a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/caad33fb232b7d217a3f218ba50f8dd299cd41a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/caad33fb232b7d217a3f218ba50f8dd299cd41a6/comments",
    "author": {
      "login": "EthanHeilman",
      "id": 274814,
      "node_id": "MDQ6VXNlcjI3NDgxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/274814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthanHeilman",
      "html_url": "https://github.com/EthanHeilman",
      "followers_url": "https://api.github.com/users/EthanHeilman/followers",
      "following_url": "https://api.github.com/users/EthanHeilman/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthanHeilman/subscriptions",
      "organizations_url": "https://api.github.com/users/EthanHeilman/orgs",
      "repos_url": "https://api.github.com/users/EthanHeilman/repos",
      "events_url": "https://api.github.com/users/EthanHeilman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthanHeilman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "EthanHeilman",
      "id": 274814,
      "node_id": "MDQ6VXNlcjI3NDgxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/274814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthanHeilman",
      "html_url": "https://github.com/EthanHeilman",
      "followers_url": "https://api.github.com/users/EthanHeilman/followers",
      "following_url": "https://api.github.com/users/EthanHeilman/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthanHeilman/subscriptions",
      "organizations_url": "https://api.github.com/users/EthanHeilman/orgs",
      "repos_url": "https://api.github.com/users/EthanHeilman/repos",
      "events_url": "https://api.github.com/users/EthanHeilman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthanHeilman/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24f24896d602bef3323c5ff66bbccc92448e89d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24f24896d602bef3323c5ff66bbccc92448e89d5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24f24896d602bef3323c5ff66bbccc92448e89d5"
      }
    ],
    "stats": {
      "total": 418,
      "additions": 400,
      "deletions": 18
    },
    "files": [
      {
        "sha": "2d926d3cf6c091e8ca2f463c4cdd78278d3991ce",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -34,6 +34,7 @@ GENERATED_TEST_FILES = $(JSON_TEST_FILES:.json=.json.h) $(RAW_TEST_FILES:.raw=.r\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n   test/bignum.h \\\n+  test/addrman_tests.cpp \\\n   test/alert_tests.cpp \\\n   test/allocator_tests.cpp \\\n   test/base32_tests.cpp \\"
      },
      {
        "sha": "f1b12baee497a93b689d0250c6b57c4a69067f1f",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 7,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -147,6 +147,8 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n \n void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n {\n+    LogPrint(\"addrman\", \"Moving %s to tried\\n\", info.ToString());\n+\n     // remove the entry from all new buckets\n     for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n         int pos = info.GetBucketPosition(nKey, true, bucket);\n@@ -193,7 +195,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, int64_t nTime)\n+void CAddrMan::Good_(const CService& addr, bool bTestBeforeEvict, int64_t nTime)\n {\n     int nId;\n     CAddrInfo* pinfo = Find(addr, &nId);\n@@ -236,10 +238,18 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     if (nUBucket == -1)\n         return;\n \n-    LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n+    // which tried bucket to move the entry to\n+    int nKBucket = info.GetTriedBucket(nKey);\n+    int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n \n-    // move nId to the tried tables\n-    MakeTried(info, nId);\n+    // Will moving this address into tried evict another entry?\n+    if (bTestBeforeEvict && (vvTried[nKBucket][nKBucketPos] != -1)) {\n+        if (setTriedCollisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) \n+            setTriedCollisions.insert(nId);\n+    } else {\n+        // move nId to the tried tables\n+        MakeTried(info, nId);\n+    }\n }\n \n bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n@@ -329,14 +339,14 @@ void CAddrMan::Attempt_(const CService& addr, int64_t nTime)\n     info.nAttempts++;\n }\n \n-CAddrInfo CAddrMan::Select_()\n+CAddrInfo CAddrMan::Select_(bool newOnly)\n {\n     if (size() == 0)\n         return CAddrInfo();\n \n     // Use a 50% chance for choosing between tried and new table entries.\n-    if (nTried > 0 && (nNew == 0 || GetRandInt(2) == 0)) {\n-        // use a tried node\n+    if (!newOnly &&\n+       (nTried > 0 && (nNew == 0 || GetRandInt(2) == 0))) { // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n             int nKBucket = GetRandInt(ADDRMAN_TRIED_BUCKET_COUNT);\n@@ -486,3 +496,70 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n     if (nTime - info.nTime > nUpdateInterval)\n         info.nTime = nTime;\n }\n+\n+void CAddrMan::ResolveCollisions_()\n+{\n+    for (std::set<int>::iterator it = setTriedCollisions.begin(); it != setTriedCollisions.end();)\n+    {\n+            int nIdnew = (int)*it;\n+            CAddrInfo& infoNew = mapInfo[nIdnew];\n+\n+            // Which tried bucket to move the entry to.\n+            int nKBucket = infoNew.GetTriedBucket(nKey);\n+            int nKBucketPos = infoNew.GetBucketPosition(nKey, false, nKBucket);\n+\n+            bool eraseCollision = false;\n+\n+            if (! infoNew.IsValid()) { // nIdnew may no longer map to a valid address\n+                eraseCollision = true;\n+            } else if (vvTried[nKBucket][nKBucketPos] != -1) { // The position in the tried bucket is not empty\n+                // Get the to-be-evicted address that is being tested.\n+                int nIdold = vvTried[nKBucket][nKBucketPos];\n+                CAddrInfo& infoOld = mapInfo[nIdold];\n+\n+                if (GetAdjustedTime() - infoOld.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) { // Has successfully connected in last X hours\n+                    eraseCollision = true;\n+                } else if (GetAdjustedTime() - infoOld.nLastTry < ADDRMAN_REPLACEMENT_HOURS*(60*60)) { // Has attempted to connect and failed in last X hours\n+                    LogPrint(\"addrman\", \"Swapping %s for %s in tried table\\n\", infoNew.ToString(), infoOld.ToString());\n+                    // Replaces an existing address already in the tried table with the new address\n+                    Good(infoNew, false);\n+                    eraseCollision = true;\n+                }\n+            } else { // Collision is not actually a collison anymore\n+                Good(infoNew, false);\n+                eraseCollision = true;\n+            }\n+\n+            if (eraseCollision){\n+                setTriedCollisions.erase(it++);\n+            } else {\n+                it++;\n+            }\n+    }\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision_()\n+{\n+    int nRnd = GetRandInt(setTriedCollisions.size());\n+\n+    int i = 0;\n+    // Selects a random element from setTriedCollisions. \n+    for (std::set<int>::iterator it = setTriedCollisions.begin(); it != setTriedCollisions.end(); it++) {\n+        if (nRnd == i) {\n+            int nIdnew = (int)*it;\n+\n+            CAddrInfo& newInfo = mapInfo[nIdnew];\n+\n+            // which tried bucket to move the entry to\n+            int nKBucket = newInfo.GetTriedBucket(nKey);\n+            int nKBucketPos = newInfo.GetBucketPosition(nKey, false, nKBucket);\n+\n+            int nIdold = vvTried[nKBucket][nKBucketPos];\n+            CAddrInfo& infoOld = mapInfo[nIdold];\n+\n+            return infoOld;\n+        }\n+        i++;\n+    }\n+    return CAddrInfo(); // Should only reach this point if setTriedCollisions is empty.\n+}"
      },
      {
        "sha": "296a9979ad2048698931e2ac98555411f54dcd37",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 52,
        "deletions": 7,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -158,12 +158,17 @@ class CAddrInfo : public CAddress\n //! ... in at least this many days\n #define ADDRMAN_MIN_FAIL_DAYS 7\n \n+//! how recent a successful connection should be before we allow an address to be evicted from tried\n+#define ADDRMAN_REPLACEMENT_HOURS 4 \n+\n //! the maximum percentage of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX_PCT 23\n \n //! the maximum number of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX 2500\n \n+#define ADDRMAN_SET_TRIED_COLLISION_SIZE 10\n+\n /** \n  * Stochastical (IP) address manager \n  */\n@@ -200,6 +205,9 @@ class CAddrMan\n     //! list of \"new\" buckets\n     int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE];\n \n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discpline used to resolve these collisions.\n+    std::set<int> setTriedCollisions;\n+\n protected:\n \n     //! Find an entry.\n@@ -222,16 +230,22 @@ class CAddrMan\n     void ClearNew(int nUBucket, int nUBucketPos);\n \n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, int64_t nTime);\n+    void Good_(const CService &addr, bool bTestBeforeEvict, int64_t nTime);\n \n     //! Add an entry to the \"new\" table.\n     bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty);\n \n     //! Mark an entry as attempted to connect.\n     void Attempt_(const CService &addr, int64_t nTime);\n \n-    //! Select an address to connect to.\n-    CAddrInfo Select_();\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_();\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_();\n \n #ifdef DEBUG_ADDRMAN\n     //! Perform consistency check. Returns an error code or zero.\n@@ -508,12 +522,12 @@ class CAddrMan\n     }\n \n     //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n+    void Good(const CService &addr, bool bTestBeforeEvict = true, int64_t nTime = GetAdjustedTime())\n     {\n         {\n             LOCK(cs);\n             Check();\n-            Good_(addr, nTime);\n+            Good_(addr, bTestBeforeEvict, nTime);\n             Check();\n         }\n     }\n@@ -529,16 +543,39 @@ class CAddrMan\n         }\n     }\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions(){\n+         {\n+            LOCK(cs);\n+            Check();\n+            ResolveCollisions_();\n+            Check();\n+        }       \n+    }\n+\n+    //! Randomly select an address in tried that another address is attempting to evict. \n+    CAddrInfo SelectTriedCollision(){\n+        CAddrInfo addrRet;\n+        {\n+            LOCK(cs);\n+            Check();\n+            addrRet = SelectTriedCollision_();\n+            Check();\n+        }\n+        return addrRet;\n+    }\n+\n     /**\n      * Choose an address to connect to.\n+     * If newOnly is set to true, only the new table is selected from.\n      */\n-    CAddrInfo Select()\n+    CAddrInfo Select(bool newOnly = false)\n     {\n         CAddrInfo addrRet;\n         {\n             LOCK(cs);\n             Check();\n-            addrRet = Select_();\n+            addrRet = Select_(newOnly);\n             Check();\n         }\n         return addrRet;\n@@ -567,6 +604,14 @@ class CAddrMan\n             Check();\n         }\n     }\n+\n+#ifdef __ADDRMAN_TEST__\n+    void MakeDeterministic(){\n+        // Ensure that bucket placement is always the same for testing purposes.\n+        nKey.SetNull();\n+    }\n+#endif\n+\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "54cb05a34a96b150bc8f898de3bdf16eac3835f5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -3960,6 +3960,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return false;\n         }\n \n+        if (pfrom->fFeeler) // Feeler connections exist only to verify address is online.\n+            pfrom->fDisconnect = true;\n+\n         int64_t nTime;\n         CAddress addrMe;\n         CAddress addrFrom;"
      },
      {
        "sha": "9bbdce148b3c12a9f1d10e4f6c5c2c52b2c7e3d2",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 3,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -36,6 +36,9 @@\n // Dump addresses to peers.dat every 15 minutes (900s)\n #define DUMP_ADDRESSES_INTERVAL 900\n \n+// We add a random period time (0 to 3 seconds) before the feeler thread makes a connection to prevent synchronization. \n+#define FEELER_SLEEP_WINDOW 3\n+\n #if !defined(HAVE_MSG_NOSIGNAL) && !defined(MSG_NOSIGNAL)\n #define MSG_NOSIGNAL 0\n #endif\n@@ -55,6 +58,7 @@ using namespace std;\n \n namespace {\n     const int MAX_OUTBOUND_CONNECTIONS = 8;\n+    const int MAX_FEELER_CONNECTIONS = 1;\n \n     struct ListenSocket {\n         SOCKET socket;\n@@ -101,6 +105,7 @@ NodeId nLastNodeId = 0;\n CCriticalSection cs_nLastNodeId;\n \n static CSemaphore *semOutbound = NULL;\n+static CSemaphore *semFeeler = NULL;\n boost::condition_variable messageHandlerCondition;\n \n // Signals for message handling\n@@ -896,7 +901,7 @@ void ThreadSocketHandler()\n                     if (nErr != WSAEWOULDBLOCK)\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n                 }\n-                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n+                else if (nInbound >= nMaxConnections - (MAX_OUTBOUND_CONNECTIONS + MAX_FEELER_CONNECTIONS))\n                 {\n                     CloseSocket(hSocket);\n                 }\n@@ -1230,6 +1235,51 @@ void static ProcessOneShot()\n     }\n }\n \n+\n+/** Feeler Connections\n+ *\n+ * Design goals:\n+ *  * Increase the number of connectable addresses in the tried table.\n+ *  * Ensure that good addresses are hard to evicted from the tried table.\n+ *\n+ * To that end:\n+ *  * When an address inserted into tried would evict an existing address,\n+ *    * test the to-be-evicted address using a feeler connection.\n+ *    * if the to-be-evicted address is still online, do not evict it, otherwise replace it.\n+ *  * When there are no tried collisions to resolve, choose a random address from new and attempt to connect to it.\n+ *\n+ */\n+void ThreadFeelerConnection()\n+{\n+    while(true) {\n+        MilliSleep(FEELER_INTERVAL * 1000);\n+\n+        CSemaphoreGrant grant(*semFeeler);\n+        boost::this_thread::interruption_point();\n+\n+        addrman.ResolveCollisions();\n+        CAddress addr = addrman.SelectTriedCollision();\n+\n+        // SelectTriedCollision returns an invalid address if it is empty.\n+        if (! addr.IsValid()) {\n+            bool onlyNew = true;\n+            addr = addrman.Select(onlyNew);\n+        } \n+\n+        // Add small amount of random noise before connection to prevent syncronization.\n+        int randsleep = GetRandInt(FEELER_SLEEP_WINDOW*1000);\n+        MilliSleep(randsleep);\n+\n+        // If we selected an invalid address, restart.\n+        if (!addr.IsValid() || IsLocal(addr) || IsLimited(addr))\n+            continue;\n+\n+        bool fFeeler = true;\n+        if (addr.IsValid())\n+            OpenNetworkConnection(addr, &grant, NULL, false, fFeeler);\n+    }\n+}\n+\n void ThreadOpenConnections()\n {\n     // Connect to specific addresses\n@@ -1401,7 +1451,7 @@ void ThreadOpenAddedConnections()\n }\n \n // if successful, this moves the passed grant to the constructed node\n-bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot)\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler)\n {\n     //\n     // Initiate outbound network connection\n@@ -1425,6 +1475,8 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n     pnode->fNetworkNode = true;\n     if (fOneShot)\n         pnode->fOneShot = true;\n+    if (fFeeler)\n+        pnode->fFeeler = true;\n \n     return true;\n }\n@@ -1656,8 +1708,15 @@ void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     if (semOutbound == NULL) {\n         // initialize semaphore\n-        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, nMaxConnections);\n+        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, nMaxConnections-MAX_FEELER_CONNECTIONS); \n         semOutbound = new CSemaphore(nMaxOutbound);\n+        assert(nMaxOutbound >= 0);\n+    }\n+\n+    if (semFeeler == NULL){\n+        int nMaxFeeler = min(MAX_FEELER_CONNECTIONS, nMaxConnections-MAX_OUTBOUND_CONNECTIONS);\n+        semFeeler = new CSemaphore(nMaxFeeler);\n+        assert(nMaxFeeler >= 0);\n     }\n \n     if (pnodeLocalHost == NULL)\n@@ -1683,6 +1742,9 @@ void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler)\n     // Initiate outbound connections from -addnode\n     threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"addcon\", &ThreadOpenAddedConnections));\n \n+    // Initiate feeler connections\n+    threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"openfeel\", &ThreadFeelerConnection));\n+\n     // Initiate outbound connections\n     threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"opencon\", &ThreadOpenConnections));\n \n@@ -1701,6 +1763,10 @@ bool StopNode()\n         for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n             semOutbound->post();\n \n+    if (semFeeler)\n+        for (int i=0; i<MAX_FEELER_CONNECTIONS; i++)\n+            semFeeler->post();\n+\n     if (fAddressesInitialized)\n     {\n         DumpAddresses();\n@@ -1736,6 +1802,8 @@ class CNetCleanup\n         vhListenSocket.clear();\n         delete semOutbound;\n         semOutbound = NULL;\n+        delete semFeeler;\n+        semFeeler = NULL;\n         delete pnodeLocalHost;\n         pnodeLocalHost = NULL;\n \n@@ -1974,6 +2042,7 @@ CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNa\n     nVersion = 0;\n     strSubVer = \"\";\n     fWhitelisted = false;\n+    fFeeler = false;\n     fOneShot = false;\n     fClient = false; // set by version message\n     fInbound = fInboundIn;"
      },
      {
        "sha": "f1614eb3de34d9d446865b7ed7ea7be71df83a68",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -49,6 +49,8 @@ static const unsigned int MAX_INV_SZ = 50000;\n static const unsigned int MAX_ADDR_TO_SEND = 1000;\n /** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n+/** Run the feeler connection loop once every 2 minutes or 120 seconds. **/\n+static const int FEELER_INTERVAL = 120;\n /** -listen default */\n static const bool DEFAULT_LISTEN = true;\n /** -upnp default */\n@@ -70,7 +72,7 @@ CNode* FindNode(const CSubNet& subNet);\n CNode* FindNode(const std::string& addrName);\n CNode* FindNode(const CService& ip);\n CNode* ConnectNode(CAddress addrConnect, const char *pszDest = NULL);\n-bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false, bool fFeeler = false);\n void MapPort(bool fUseUPnP);\n unsigned short GetListenPort();\n bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n@@ -266,6 +268,7 @@ class CNode\n     std::string strSubVer, cleanSubVer;\n     bool fWhitelisted; // This peer can bypass DoS banning.\n     bool fOneShot;\n+    bool fFeeler; // If true this node is being used as a short lived feeler connection.\n     bool fClient;\n     bool fInbound;\n     bool fNetworkNode;"
      },
      {
        "sha": "45a3d05e4a84e022ad83c15a0918007441a42b12",
        "filename": "src/test/addrman_tests.cpp",
        "status": "added",
        "additions": 184,
        "deletions": 0,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caad33fb232b7d217a3f218ba50f8dd299cd41a6/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=caad33fb232b7d217a3f218ba50f8dd299cd41a6",
        "patch": "@@ -0,0 +1,184 @@\n+// Copyright (c) 2012-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define __ADDRMAN_TEST__\n+\n+#include \"addrman.h\"\n+#include \"test/test_bitcoin.h\"\n+#include <string>\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"random.h\"\n+\n+using namespace std;\n+\n+class CAddrManTest : public CAddrMan\n+{\n+    public:\n+        // Simulates a conneciton failure.\n+        void SimConnFail(CService& addr){\n+            int64_t nTime = 1; \n+            Good_(addr, true, nTime); // Set last good connection in the deep past.\n+            Attempt(addr); \n+        }\n+};\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n+\n+\n+BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    // Empty addrman should return blank addrman info.\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++){\n+        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+        addrman.Add(CAddress(addr), source);\n+        addrman.Good(addr);\n+\n+        // No collisions yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Ensure Good handles duplicates well.\n+    for (unsigned int i = 1; i < 23; i++){\n+        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+        addrman.Good(addr);\n+\n+        BOOST_CHECK(addrman.size() == 22);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_noevict)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++){\n+        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+        addrman.Add(CAddress(addr), source);\n+        addrman.Good(addr);\n+\n+        // No collision yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Collision between 23 and 19.\n+    CService addr23 = CService(\"250.1.1.23\");\n+    addrman.Add(CAddress(addr23), source);\n+    addrman.Good(addr23);\n+\n+    BOOST_CHECK(addrman.size() == 23);\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.19:0\");\n+\n+    // 23 should be discarded and 19 not evicted.\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Lets create two collisions.\n+    for (unsigned int i = 24; i < 33; i++){\n+        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+        addrman.Add(CAddress(addr), source);\n+        addrman.Good(addr);\n+\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Cause a collision.\n+    CService addr33 = CService(\"250.1.1.33\");\n+    addrman.Add(CAddress(addr33), source);\n+    addrman.Good(addr33);\n+    BOOST_CHECK(addrman.size() == 33);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.27:0\");\n+\n+    // Cause a second collision.\n+    addrman.Add(CAddress(addr23), source);\n+    addrman.Good(addr23);\n+    BOOST_CHECK(addrman.size() == 33);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    // Empty addrman should return blank addrman info.\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // Add twenty two addresses.\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    for (unsigned int i = 1; i < 23; i++){\n+        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+        addrman.Add(CAddress(addr), source);\n+        addrman.Good(addr);\n+\n+        // No collision yet.\n+        BOOST_CHECK(addrman.size() == i);\n+        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    }\n+\n+    // Collision between 23 and 19.\n+    CService addr = CService(\"250.1.1.23\");\n+    addrman.Add(CAddress(addr), source);\n+    addrman.Good(addr);\n+\n+    BOOST_CHECK(addrman.size() == 23);\n+    CAddrInfo info = addrman.SelectTriedCollision();\n+    BOOST_CHECK(info.ToString() == \"250.1.1.19:0\");\n+\n+    // Ensure test of address fails, so that it is evicted.\n+    addrman.SimConnFail(info);\n+\n+    // Should swap 23 for 19.\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // If 23 was swapped for 19, then this should cause no collisions.\n+    addrman.Add(CAddress(addr), source);\n+    addrman.Good(addr);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+    // If we insert 19 is should collide with 23.\n+    CService addr19 = CService(\"250.1.1.19\");\n+    addrman.Add(CAddress(addr19), source);\n+    addrman.Good(addr19);\n+\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"250.1.1.23:0\");\n+\n+    addrman.ResolveCollisions();\n+    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+\n+}\n+\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]