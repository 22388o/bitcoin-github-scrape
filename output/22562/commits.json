[
  {
    "sha": "366e95b0aa31d1d73fa7ff38a39b4eef89733517",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNjZlOTViMGFhMzFkMWQ3M2ZhN2ZmMzhhMzliNGVlZjg5NzMzNTE3",
    "commit": {
      "author": {
        "name": "Fuzzbawls",
        "email": "fuzzbawls@gmail.com",
        "date": "2021-07-27T10:45:51Z"
      },
      "committer": {
        "name": "Fuzzbawls",
        "email": "fuzzbawls@gmail.com",
        "date": "2021-07-27T10:45:51Z"
      },
      "message": "[Refactor] Apply clang-format to netaddress.h\n\nThis brings the entirety of netaddress.h into styling compliance\nwith regard to the indentation of `public`/`private`/`protected`\nclass blocks, per the styling guidelines.",
      "tree": {
        "sha": "78f38a1f46db62bf0a571f334401f27ec60445c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78f38a1f46db62bf0a571f334401f27ec60445c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/366e95b0aa31d1d73fa7ff38a39b4eef89733517",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEb5k7JQVX57AWreVxO9zaLYeogdkFAmD/4+gACgkQO9zaLYeo\ngdncIQ//edRl5Z2KIb9KYfLhR3Zxp7ugwdZrR8Si8P3hCUAKph1L0NhbT7OkmdNL\n6uK5aYYZ3U45aaR9DuOHvW/W86GfQr1AR7ecCBgJzNi64ixFp+0s4W+dDru+SGo4\nZ2CZamLuHbPlnbqiiQh7HmACUtnZxt+MmQr+rAP22PiKE5s0sPe9pkl/TxiJ5X2x\nQIBcNvaPywaPZnnmveKW7xQtlbC4M6uYhgKy3TEa1uPPU6ql7d0a3ivY/XTqUY2G\nsoFb1wBLarvVlDFRMkADmrArbfFHdn85d7gxDxFsnUgO4UJJPGVMmrv22W4OFFls\nkW9wqAMeDVmOEFVnF0oGrnDoAH16WgAQqiaZYxFFQxqMYjrVNhyWTp71UcXgq+9k\nhCdOg5d0rEDf4ZYP3pMm69O8nq/31tPrP8HWCH5B6Fct6Cjgyh+NPIfz1YUYR59D\nU2K6DZWBjJmQl5EpL2SG22eEu8zyxu4HlBUQse/Ia2iI5b9ZTM4x9ehi3ga0h6dR\n7a/Soakt/g/ZSNxfjiEAmpJs63d2lbWgLHPEu4/Di8dUajlzXX+3It4lP2IOZvJz\nYj2ZtPE3W10y4Ufkve9TaRVBPkc0OxCR8Rrn26S8deqah8ooYyWqK292J9hA50On\nGsU8ItQ4SdkGg8b3U1PNvuXD009lzkg3+Gs5AhANVOm19/HHV6g=\n=Lm2S\n-----END PGP SIGNATURE-----",
        "payload": "tree 78f38a1f46db62bf0a571f334401f27ec60445c2\nparent 1488f55fa57a1400a57be837b574183f019c7855\nauthor Fuzzbawls <fuzzbawls@gmail.com> 1627382751 -0700\ncommitter Fuzzbawls <fuzzbawls@gmail.com> 1627382751 -0700\n\n[Refactor] Apply clang-format to netaddress.h\n\nThis brings the entirety of netaddress.h into styling compliance\nwith regard to the indentation of `public`/`private`/`protected`\nclass blocks, per the styling guidelines.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/366e95b0aa31d1d73fa7ff38a39b4eef89733517",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/366e95b0aa31d1d73fa7ff38a39b4eef89733517",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/366e95b0aa31d1d73fa7ff38a39b4eef89733517/comments",
    "author": {
      "login": "Fuzzbawls",
      "id": 7393257,
      "node_id": "MDQ6VXNlcjczOTMyNTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7393257?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Fuzzbawls",
      "html_url": "https://github.com/Fuzzbawls",
      "followers_url": "https://api.github.com/users/Fuzzbawls/followers",
      "following_url": "https://api.github.com/users/Fuzzbawls/following{/other_user}",
      "gists_url": "https://api.github.com/users/Fuzzbawls/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Fuzzbawls/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Fuzzbawls/subscriptions",
      "organizations_url": "https://api.github.com/users/Fuzzbawls/orgs",
      "repos_url": "https://api.github.com/users/Fuzzbawls/repos",
      "events_url": "https://api.github.com/users/Fuzzbawls/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Fuzzbawls/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Fuzzbawls",
      "id": 7393257,
      "node_id": "MDQ6VXNlcjczOTMyNTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7393257?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Fuzzbawls",
      "html_url": "https://github.com/Fuzzbawls",
      "followers_url": "https://api.github.com/users/Fuzzbawls/followers",
      "following_url": "https://api.github.com/users/Fuzzbawls/following{/other_user}",
      "gists_url": "https://api.github.com/users/Fuzzbawls/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Fuzzbawls/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Fuzzbawls/subscriptions",
      "organizations_url": "https://api.github.com/users/Fuzzbawls/orgs",
      "repos_url": "https://api.github.com/users/Fuzzbawls/repos",
      "events_url": "https://api.github.com/users/Fuzzbawls/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Fuzzbawls/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1488f55fa57a1400a57be837b574183f019c7855",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1488f55fa57a1400a57be837b574183f019c7855",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1488f55fa57a1400a57be837b574183f019c7855"
      }
    ],
    "stats": {
      "total": 818,
      "additions": 409,
      "deletions": 409
    },
    "files": [
      {
        "sha": "bbb300d9ca6619e2698234f48bef93595bf5350e",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 409,
        "deletions": 409,
        "changes": 818,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/366e95b0aa31d1d73fa7ff38a39b4eef89733517/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/366e95b0aa31d1d73fa7ff38a39b4eef89733517/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=366e95b0aa31d1d73fa7ff38a39b4eef89733517",
        "patch": "@@ -120,354 +120,354 @@ static constexpr uint16_t I2P_SAM31_PORT{0};\n  */\n class CNetAddr\n {\n-    protected:\n-        /**\n-         * Raw representation of the network address.\n-         * In network byte order (big endian) for IPv4 and IPv6.\n-         */\n-        prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n-\n-        /**\n-         * Network to which this address belongs.\n-         */\n-        Network m_net{NET_IPV6};\n-\n-        /**\n-         * Scope id if scoped/link-local IPV6 address.\n-         * See https://tools.ietf.org/html/rfc4007\n-         */\n-        uint32_t m_scope_id{0};\n-\n-    public:\n-        CNetAddr();\n-        explicit CNetAddr(const struct in_addr& ipv4Addr);\n-        void SetIP(const CNetAddr& ip);\n-\n-        /**\n-         * Set from a legacy IPv6 address.\n-         * Legacy IPv6 address may be a normal IPv6 address, or another address\n-         * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n-         * `addr` encoding.\n-         */\n-        void SetLegacyIPv6(Span<const uint8_t> ipv6);\n-\n-        bool SetInternal(const std::string& name);\n+protected:\n+    /**\n+     * Raw representation of the network address.\n+     * In network byte order (big endian) for IPv4 and IPv6.\n+     */\n+    prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n+\n+    /**\n+     * Network to which this address belongs.\n+     */\n+    Network m_net{NET_IPV6};\n+\n+    /**\n+     * Scope id if scoped/link-local IPV6 address.\n+     * See https://tools.ietf.org/html/rfc4007\n+     */\n+    uint32_t m_scope_id{0};\n \n-        /**\n-         * Parse a Tor or I2P address and set this object to it.\n-         * @param[in] addr Address to parse, for example\n-         * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or\n-         * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n-         */\n-        bool SetSpecial(const std::string& addr);\n-\n-        bool IsBindAny() const; // INADDR_ANY equivalent\n-        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n-        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n-        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n-        bool IsRFC2544() const; // IPv4 inter-network communications (198.18.0.0/15)\n-        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n-        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n-        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n-        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n-        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n-        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n-        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n-        bool IsRFC4843() const; // IPv6 ORCHID (deprecated) (2001:10::/28)\n-        bool IsRFC7343() const; // IPv6 ORCHIDv2 (2001:20::/28)\n-        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n-        bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n-        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n-        bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n-        bool IsTor() const;\n-        bool IsI2P() const;\n-        bool IsCJDNS() const;\n-        bool IsLocal() const;\n-        bool IsRoutable() const;\n-        bool IsInternal() const;\n-        bool IsValid() const;\n-\n-        /**\n-         * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n-         */\n-        bool IsAddrV1Compatible() const;\n-\n-        enum Network GetNetwork() const;\n-        std::string ToString() const;\n-        std::string ToStringIP() const;\n-        uint64_t GetHash() const;\n-        bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        Network GetNetClass() const;\n-\n-        //! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32.\n-        uint32_t GetLinkedIPv4() const;\n-        //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n-        bool HasLinkedIPv4() const;\n-\n-        // The AS on the BGP path to the node we use to diversify\n-        // peers in AddrMan bucketing based on the AS infrastructure.\n-        // The ip->AS mapping depends on how asmap is constructed.\n-        uint32_t GetMappedAS(const std::vector<bool> &asmap) const;\n-\n-        std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n-        std::vector<unsigned char> GetAddrBytes() const;\n-        int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n-\n-        explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n-        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n-\n-        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n-        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n-\n-        /**\n-         * Whether this address should be relayed to other peers even if we can't reach it ourselves.\n-         */\n-        bool IsRelayable() const\n-        {\n-            return IsIPv4() || IsIPv6() || IsTor() || IsI2P();\n-        }\n+public:\n+    CNetAddr();\n+    explicit CNetAddr(const struct in_addr& ipv4Addr);\n+    void SetIP(const CNetAddr& ip);\n+\n+    /**\n+     * Set from a legacy IPv6 address.\n+     * Legacy IPv6 address may be a normal IPv6 address, or another address\n+     * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n+     * `addr` encoding.\n+     */\n+    void SetLegacyIPv6(Span<const uint8_t> ipv6);\n+\n+    bool SetInternal(const std::string& name);\n+\n+    /**\n+     * Parse a Tor or I2P address and set this object to it.\n+     * @param[in] addr Address to parse, for example\n+     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or\n+     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n+     */\n+    bool SetSpecial(const std::string& addr);\n+\n+    bool IsBindAny() const; // INADDR_ANY equivalent\n+    bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n+    bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n+    bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n+    bool IsRFC2544() const; // IPv4 inter-network communications (198.18.0.0/15)\n+    bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n+    bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n+    bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n+    bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n+    bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n+    bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n+    bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n+    bool IsRFC4843() const; // IPv6 ORCHID (deprecated) (2001:10::/28)\n+    bool IsRFC7343() const; // IPv6 ORCHIDv2 (2001:20::/28)\n+    bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n+    bool IsRFC6052() const; // IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)\n+    bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n+    bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n+    bool IsTor() const;\n+    bool IsI2P() const;\n+    bool IsCJDNS() const;\n+    bool IsLocal() const;\n+    bool IsRoutable() const;\n+    bool IsInternal() const;\n+    bool IsValid() const;\n+\n+    /**\n+     * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n+     */\n+    bool IsAddrV1Compatible() const;\n+\n+    enum Network GetNetwork() const;\n+    std::string ToString() const;\n+    std::string ToStringIP() const;\n+    uint64_t GetHash() const;\n+    bool GetInAddr(struct in_addr* pipv4Addr) const;\n+    Network GetNetClass() const;\n+\n+    //! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32.\n+    uint32_t GetLinkedIPv4() const;\n+    //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n+    bool HasLinkedIPv4() const;\n+\n+    // The AS on the BGP path to the node we use to diversify\n+    // peers in AddrMan bucketing based on the AS infrastructure.\n+    // The ip->AS mapping depends on how asmap is constructed.\n+    uint32_t GetMappedAS(const std::vector<bool> &asmap) const;\n+\n+    std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n+    std::vector<unsigned char> GetAddrBytes() const;\n+    int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n+\n+    explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n+    bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n+\n+    friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n+    friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n+    friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n+\n+    /**\n+     * Whether this address should be relayed to other peers even if we can't reach it ourselves.\n+     */\n+    bool IsRelayable() const\n+    {\n+        return IsIPv4() || IsIPv6() || IsTor() || IsI2P();\n+    }\n \n-        /**\n+    /**\n          * Serialize to a stream.\n          */\n-        template <typename Stream>\n-        void Serialize(Stream& s) const\n-        {\n-            if (s.GetVersion() & ADDRV2_FORMAT) {\n-                SerializeV2Stream(s);\n-            } else {\n-                SerializeV1Stream(s);\n-            }\n+    template <typename Stream>\n+    void Serialize(Stream& s) const\n+    {\n+        if (s.GetVersion() & ADDRV2_FORMAT) {\n+            SerializeV2Stream(s);\n+        } else {\n+            SerializeV1Stream(s);\n         }\n+    }\n \n-        /**\n-         * Unserialize from a stream.\n-         */\n-        template <typename Stream>\n-        void Unserialize(Stream& s)\n-        {\n-            if (s.GetVersion() & ADDRV2_FORMAT) {\n-                UnserializeV2Stream(s);\n-            } else {\n-                UnserializeV1Stream(s);\n-            }\n+    /**\n+     * Unserialize from a stream.\n+     */\n+    template <typename Stream>\n+    void Unserialize(Stream& s)\n+    {\n+        if (s.GetVersion() & ADDRV2_FORMAT) {\n+            UnserializeV2Stream(s);\n+        } else {\n+            UnserializeV1Stream(s);\n         }\n+    }\n \n-        friend class CNetAddrHash;\n-        friend class CSubNet;\n+    friend class CNetAddrHash;\n+    friend class CSubNet;\n \n-    private:\n-        /**\n-         * Parse a Tor address and set this object to it.\n-         * @param[in] addr Address to parse, must be a valid C string, for example\n-         * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsTor()\n-         */\n-        bool SetTor(const std::string& addr);\n-\n-        /**\n-         * Parse an I2P address and set this object to it.\n-         * @param[in] addr Address to parse, must be a valid C string, for example\n-         * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n-         * @returns Whether the operation was successful.\n-         * @see CNetAddr::IsI2P()\n-         */\n-        bool SetI2P(const std::string& addr);\n+private:\n+    /**\n+     * Parse a Tor address and set this object to it.\n+     * @param[in] addr Address to parse, must be a valid C string, for example\n+     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsTor()\n+     */\n+    bool SetTor(const std::string& addr);\n+\n+    /**\n+     * Parse an I2P address and set this object to it.\n+     * @param[in] addr Address to parse, must be a valid C string, for example\n+     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n+     * @returns Whether the operation was successful.\n+     * @see CNetAddr::IsI2P()\n+     */\n+    bool SetI2P(const std::string& addr);\n+\n+    /**\n+     * BIP155 network ids recognized by this software.\n+     */\n+    enum BIP155Network : uint8_t {\n+        IPV4 = 1,\n+        IPV6 = 2,\n+        TORV2 = 3,\n+        TORV3 = 4,\n+        I2P = 5,\n+        CJDNS = 6,\n+    };\n+\n+    /**\n+     * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n+     */\n+    static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n+\n+    /**\n+     * Maximum size of an address as defined in BIP155 (in bytes).\n+     * This is only the size of the address, not the entire CNetAddr object\n+     * when serialized.\n+     */\n+    static constexpr size_t MAX_ADDRV2_SIZE = 512;\n+\n+    /**\n+     * Get the BIP155 network id of this address.\n+     * Must not be called for IsInternal() objects.\n+     * @returns BIP155 network id, except TORV2 which is no longer supported.\n+     */\n+    BIP155Network GetBIP155Network() const;\n+\n+    /**\n+     * Set `m_net` from the provided BIP155 network id and size after validation.\n+     * @retval true the network was recognized, is valid and `m_net` was set\n+     * @retval false not recognised (from future?) and should be silently ignored\n+     * @throws std::ios_base::failure if the network is one of the BIP155 founding\n+     * networks (id 1..6) with wrong address size.\n+     */\n+    bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n+\n+    /**\n+     * Serialize in pre-ADDRv2/BIP155 format to an array.\n+     */\n+    void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n+    {\n+        size_t prefix_size;\n+\n+        switch (m_net) {\n+        case NET_IPV6:\n+            assert(m_addr.size() == sizeof(arr));\n+            memcpy(arr, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_IPV4:\n+            prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n+            assert(prefix_size + m_addr.size() == sizeof(arr));\n+            memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n+            memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_INTERNAL:\n+            prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n+            assert(prefix_size + m_addr.size() == sizeof(arr));\n+            memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n+            memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+            return;\n+        case NET_ONION:\n+        case NET_I2P:\n+        case NET_CJDNS:\n+            break;\n+        case NET_UNROUTABLE:\n+        case NET_MAX:\n+            assert(false);\n+        } // no default case, so the compiler can warn about missing cases\n+\n+        // Serialize ONION, I2P and CJDNS as all-zeros.\n+        memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n+    }\n \n-        /**\n-         * BIP155 network ids recognized by this software.\n-         */\n-        enum BIP155Network : uint8_t {\n-            IPV4 = 1,\n-            IPV6 = 2,\n-            TORV2 = 3,\n-            TORV3 = 4,\n-            I2P = 5,\n-            CJDNS = 6,\n-        };\n-\n-        /**\n-         * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n-         */\n-        static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n+    /**\n+     * Serialize in pre-ADDRv2/BIP155 format to a stream.\n+     */\n+    template <typename Stream>\n+    void SerializeV1Stream(Stream& s) const\n+    {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n \n-        /**\n-         * Maximum size of an address as defined in BIP155 (in bytes).\n-         * This is only the size of the address, not the entire CNetAddr object\n-         * when serialized.\n-         */\n-        static constexpr size_t MAX_ADDRV2_SIZE = 512;\n+        SerializeV1Array(serialized);\n \n-        /**\n-         * Get the BIP155 network id of this address.\n-         * Must not be called for IsInternal() objects.\n-         * @returns BIP155 network id, except TORV2 which is no longer supported.\n-         */\n-        BIP155Network GetBIP155Network() const;\n-\n-        /**\n-         * Set `m_net` from the provided BIP155 network id and size after validation.\n-         * @retval true the network was recognized, is valid and `m_net` was set\n-         * @retval false not recognised (from future?) and should be silently ignored\n-         * @throws std::ios_base::failure if the network is one of the BIP155 founding\n-         * networks (id 1..6) with wrong address size.\n-         */\n-        bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n+        s << serialized;\n+    }\n \n-        /**\n-         * Serialize in pre-ADDRv2/BIP155 format to an array.\n-         */\n-        void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n-        {\n-            size_t prefix_size;\n-\n-            switch (m_net) {\n-            case NET_IPV6:\n-                assert(m_addr.size() == sizeof(arr));\n-                memcpy(arr, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_IPV4:\n-                prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n-                assert(prefix_size + m_addr.size() == sizeof(arr));\n-                memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n-                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_INTERNAL:\n-                prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n-                assert(prefix_size + m_addr.size() == sizeof(arr));\n-                memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n-                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n-                return;\n-            case NET_ONION:\n-            case NET_I2P:\n-            case NET_CJDNS:\n-                break;\n-            case NET_UNROUTABLE:\n-            case NET_MAX:\n-                assert(false);\n-            } // no default case, so the compiler can warn about missing cases\n-\n-            // Serialize ONION, I2P and CJDNS as all-zeros.\n-            memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n+    /**\n+     * Serialize as ADDRv2 / BIP155.\n+     */\n+    template <typename Stream>\n+    void SerializeV2Stream(Stream& s) const\n+    {\n+        if (IsInternal()) {\n+            // Serialize NET_INTERNAL as embedded in IPv6. We need to\n+            // serialize such addresses from addrman.\n+            s << static_cast<uint8_t>(BIP155Network::IPV6);\n+            s << COMPACTSIZE(ADDR_IPV6_SIZE);\n+            SerializeV1Stream(s);\n+            return;\n         }\n \n-        /**\n-         * Serialize in pre-ADDRv2/BIP155 format to a stream.\n-         */\n-        template <typename Stream>\n-        void SerializeV1Stream(Stream& s) const\n-        {\n-            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+        s << static_cast<uint8_t>(GetBIP155Network());\n+        s << m_addr;\n+    }\n \n-            SerializeV1Array(serialized);\n+    /**\n+     * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n+     */\n+    void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n+    {\n+        // Use SetLegacyIPv6() so that m_net is set correctly. For example\n+        // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n+        SetLegacyIPv6(arr);\n+    }\n \n-            s << serialized;\n-        }\n+    /**\n+     * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n+     */\n+    template <typename Stream>\n+    void UnserializeV1Stream(Stream& s)\n+    {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n \n-        /**\n-         * Serialize as ADDRv2 / BIP155.\n-         */\n-        template <typename Stream>\n-        void SerializeV2Stream(Stream& s) const\n-        {\n-            if (IsInternal()) {\n-                // Serialize NET_INTERNAL as embedded in IPv6. We need to\n-                // serialize such addresses from addrman.\n-                s << static_cast<uint8_t>(BIP155Network::IPV6);\n-                s << COMPACTSIZE(ADDR_IPV6_SIZE);\n-                SerializeV1Stream(s);\n-                return;\n-            }\n+        s >> serialized;\n \n-            s << static_cast<uint8_t>(GetBIP155Network());\n-            s << m_addr;\n-        }\n+        UnserializeV1Array(serialized);\n+    }\n \n-        /**\n-         * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n-         */\n-        void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n-        {\n-            // Use SetLegacyIPv6() so that m_net is set correctly. For example\n-            // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n-            SetLegacyIPv6(arr);\n+    /**\n+     * Unserialize from a ADDRv2 / BIP155 format.\n+     */\n+    template <typename Stream>\n+    void UnserializeV2Stream(Stream& s)\n+    {\n+        uint8_t bip155_net;\n+        s >> bip155_net;\n+\n+        size_t address_size;\n+        s >> COMPACTSIZE(address_size);\n+\n+        if (address_size > MAX_ADDRV2_SIZE) {\n+            throw std::ios_base::failure(strprintf(\n+                \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n         }\n \n-        /**\n-         * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n-         */\n-        template <typename Stream>\n-        void UnserializeV1Stream(Stream& s)\n-        {\n-            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+        m_scope_id = 0;\n \n-            s >> serialized;\n+        if (SetNetFromBIP155Network(bip155_net, address_size)) {\n+            m_addr.resize(address_size);\n+            s >> MakeSpan(m_addr);\n \n-            UnserializeV1Array(serialized);\n-        }\n+            if (m_net != NET_IPV6) {\n+                return;\n+            }\n \n-        /**\n-         * Unserialize from a ADDRv2 / BIP155 format.\n-         */\n-        template <typename Stream>\n-        void UnserializeV2Stream(Stream& s)\n-        {\n-            uint8_t bip155_net;\n-            s >> bip155_net;\n-\n-            size_t address_size;\n-            s >> COMPACTSIZE(address_size);\n-\n-            if (address_size > MAX_ADDRV2_SIZE) {\n-                throw std::ios_base::failure(strprintf(\n-                    \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n+            // Do some special checks on IPv6 addresses.\n+\n+            // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n+            // gossiped but could be coming from addrman, when unserializing from\n+            // disk.\n+            if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n+                m_net = NET_INTERNAL;\n+                memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n+                        ADDR_INTERNAL_SIZE);\n+                m_addr.resize(ADDR_INTERNAL_SIZE);\n+                return;\n             }\n \n-            m_scope_id = 0;\n-\n-            if (SetNetFromBIP155Network(bip155_net, address_size)) {\n-                m_addr.resize(address_size);\n-                s >> MakeSpan(m_addr);\n-\n-                if (m_net != NET_IPV6) {\n-                    return;\n-                }\n-\n-                // Do some special checks on IPv6 addresses.\n-\n-                // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n-                // gossiped but could be coming from addrman, when unserializing from\n-                // disk.\n-                if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n-                    m_net = NET_INTERNAL;\n-                    memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n-                            ADDR_INTERNAL_SIZE);\n-                    m_addr.resize(ADDR_INTERNAL_SIZE);\n-                    return;\n-                }\n-\n-                if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n-                    !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n-                    return;\n-                }\n-\n-                // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n-                // encoding). Unserialize as !IsValid(), thus ignoring them.\n-            } else {\n-                // If we receive an unknown BIP155 network id (from the future?) then\n-                // ignore the address - unserialize as !IsValid().\n-                s.ignore(address_size);\n+            if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n+                !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n+                return;\n             }\n \n-            // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n-            // will not be gossiped, but continue reading next addresses from the stream.\n-            m_net = NET_IPV6;\n-            m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+            // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n+            // encoding). Unserialize as !IsValid(), thus ignoring them.\n+        } else {\n+            // If we receive an unknown BIP155 network id (from the future?) then\n+            // ignore the address - unserialize as !IsValid().\n+            s.ignore(address_size);\n         }\n+\n+        // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n+        // will not be gossiped, but continue reading next addresses from the stream.\n+        m_net = NET_IPV6;\n+        m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+    }\n };\n \n class CNetAddrHash\n@@ -488,104 +488,104 @@ class CNetAddrHash\n \n class CSubNet\n {\n-    protected:\n-        /// Network (base) address\n-        CNetAddr network;\n-        /// Netmask, in network byte order\n-        uint8_t netmask[16];\n-        /// Is this value valid? (only used to signal parse errors)\n-        bool valid;\n-\n-        bool SanityCheck() const;\n-\n-    public:\n-        /**\n-         * Construct an invalid subnet (empty, `Match()` always returns false).\n-         */\n-        CSubNet();\n-\n-        /**\n-         * Construct from a given network start and number of bits (CIDR mask).\n-         * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n-         * created.\n-         * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for\n-         * IPv6 addresses. Otherwise an invalid subnet is created.\n-         */\n-        CSubNet(const CNetAddr& addr, uint8_t mask);\n-\n-        /**\n-         * Construct from a given network start and mask.\n-         * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n-         * created.\n-         * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits\n-         * followed by 1-bits. Otherwise an invalid subnet is created.\n-         */\n-        CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n+protected:\n+    /// Network (base) address\n+    CNetAddr network;\n+    /// Netmask, in network byte order\n+    uint8_t netmask[16];\n+    /// Is this value valid? (only used to signal parse errors)\n+    bool valid;\n \n-        /**\n-         * Construct a single-host subnet.\n-         * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].\n-         */\n-        explicit CSubNet(const CNetAddr& addr);\n-\n-        bool Match(const CNetAddr &addr) const;\n-\n-        std::string ToString() const;\n-        bool IsValid() const;\n-\n-        friend bool operator==(const CSubNet& a, const CSubNet& b);\n-        friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n-        friend bool operator<(const CSubNet& a, const CSubNet& b);\n-\n-        SERIALIZE_METHODS(CSubNet, obj)\n-        {\n-            READWRITE(obj.network);\n-            if (obj.network.IsIPv4()) {\n-                // Before commit 102867c587f5f7954232fb8ed8e85cda78bb4d32, CSubNet used the last 4 bytes of netmask\n-                // to store the relevant bytes for an IPv4 mask. For compatibility reasons, keep doing so in\n-                // serialized form.\n-                unsigned char dummy[12] = {0};\n-                READWRITE(dummy);\n-                READWRITE(MakeSpan(obj.netmask).first(4));\n-            } else {\n-                READWRITE(obj.netmask);\n-            }\n-            READWRITE(obj.valid);\n-            // Mark invalid if the result doesn't pass sanity checking.\n-            SER_READ(obj, if (obj.valid) obj.valid = obj.SanityCheck());\n+    bool SanityCheck() const;\n+\n+public:\n+    /**\n+     * Construct an invalid subnet (empty, `Match()` always returns false).\n+     */\n+    CSubNet();\n+\n+    /**\n+     * Construct from a given network start and number of bits (CIDR mask).\n+     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n+     * created.\n+     * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for\n+     * IPv6 addresses. Otherwise an invalid subnet is created.\n+     */\n+    CSubNet(const CNetAddr& addr, uint8_t mask);\n+\n+    /**\n+     * Construct from a given network start and mask.\n+     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is\n+     * created.\n+     * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits\n+     * followed by 1-bits. Otherwise an invalid subnet is created.\n+     */\n+    CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n+\n+    /**\n+     * Construct a single-host subnet.\n+     * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].\n+     */\n+    explicit CSubNet(const CNetAddr& addr);\n+\n+    bool Match(const CNetAddr &addr) const;\n+\n+    std::string ToString() const;\n+    bool IsValid() const;\n+\n+    friend bool operator==(const CSubNet& a, const CSubNet& b);\n+    friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n+    friend bool operator<(const CSubNet& a, const CSubNet& b);\n+\n+    SERIALIZE_METHODS(CSubNet, obj)\n+    {\n+        READWRITE(obj.network);\n+        if (obj.network.IsIPv4()) {\n+            // Before commit 102867c587f5f7954232fb8ed8e85cda78bb4d32, CSubNet used the last 4 bytes of netmask\n+            // to store the relevant bytes for an IPv4 mask. For compatibility reasons, keep doing so in\n+            // serialized form.\n+            unsigned char dummy[12] = {0};\n+            READWRITE(dummy);\n+            READWRITE(MakeSpan(obj.netmask).first(4));\n+        } else {\n+            READWRITE(obj.netmask);\n         }\n+        READWRITE(obj.valid);\n+        // Mark invalid if the result doesn't pass sanity checking.\n+        SER_READ(obj, if (obj.valid) obj.valid = obj.SanityCheck());\n+    }\n };\n \n /** A combination of a network address (CNetAddr) and a (TCP) port */\n class CService : public CNetAddr\n {\n-    protected:\n-        uint16_t port; // host order\n-\n-    public:\n-        CService();\n-        CService(const CNetAddr& ip, uint16_t port);\n-        CService(const struct in_addr& ipv4Addr, uint16_t port);\n-        explicit CService(const struct sockaddr_in& addr);\n-        uint16_t GetPort() const;\n-        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n-        bool SetSockAddr(const struct sockaddr* paddr);\n-        friend bool operator==(const CService& a, const CService& b);\n-        friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n-        friend bool operator<(const CService& a, const CService& b);\n-        std::vector<unsigned char> GetKey() const;\n-        std::string ToString() const;\n-        std::string ToStringPort() const;\n-        std::string ToStringIPPort() const;\n-\n-        CService(const struct in6_addr& ipv6Addr, uint16_t port);\n-        explicit CService(const struct sockaddr_in6& addr);\n-\n-        SERIALIZE_METHODS(CService, obj)\n-        {\n-            READWRITEAS(CNetAddr, obj);\n-            READWRITE(Using<BigEndianFormatter<2>>(obj.port));\n-        }\n+protected:\n+    uint16_t port; // host order\n+\n+public:\n+    CService();\n+    CService(const CNetAddr& ip, uint16_t port);\n+    CService(const struct in_addr& ipv4Addr, uint16_t port);\n+    explicit CService(const struct sockaddr_in& addr);\n+    uint16_t GetPort() const;\n+    bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n+    bool SetSockAddr(const struct sockaddr* paddr);\n+    friend bool operator==(const CService& a, const CService& b);\n+    friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n+    friend bool operator<(const CService& a, const CService& b);\n+    std::vector<unsigned char> GetKey() const;\n+    std::string ToString() const;\n+    std::string ToStringPort() const;\n+    std::string ToStringIPPort() const;\n+\n+    CService(const struct in6_addr& ipv6Addr, uint16_t port);\n+    explicit CService(const struct sockaddr_in6& addr);\n+\n+    SERIALIZE_METHODS(CService, obj)\n+    {\n+        READWRITEAS(CNetAddr, obj);\n+        READWRITE(Using<BigEndianFormatter<2>>(obj.port));\n+    }\n };\n \n bool SanityCheckASMap(const std::vector<bool>& asmap);"
      }
    ]
  }
]