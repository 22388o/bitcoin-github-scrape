[
  {
    "sha": "352310ebdca7e35c59c346d1de49e91c4fa05d2a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTIzMTBlYmRjYTdlMzVjNTljMzQ2ZDFkZTQ5ZTkxYzRmYTA1ZDJh",
    "commit": {
      "author": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-04-22T14:43:30Z"
      },
      "committer": {
        "name": "Luke Dashjr",
        "email": "luke-jr+git@utopios.org",
        "date": "2012-04-22T14:43:30Z"
      },
      "message": "Change all post-increments to pre-increments, where it doesn't affect the result",
      "tree": {
        "sha": "e9cbb5c4830cadcfc2f7b511f4d2e43578157c1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e9cbb5c4830cadcfc2f7b511f4d2e43578157c1b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/352310ebdca7e35c59c346d1de49e91c4fa05d2a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/352310ebdca7e35c59c346d1de49e91c4fa05d2a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/352310ebdca7e35c59c346d1de49e91c4fa05d2a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/352310ebdca7e35c59c346d1de49e91c4fa05d2a/comments",
    "author": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following{/other_user}",
      "gists_url": "https://api.github.com/users/luke-jr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "457661f6400030f5979564462e8c625840cc5e58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/457661f6400030f5979564462e8c625840cc5e58",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/457661f6400030f5979564462e8c625840cc5e58"
      }
    ],
    "stats": {
      "total": 736,
      "additions": 368,
      "deletions": 368
    },
    "files": [
      {
        "sha": "e567702131b12f9d83afe19c4371449c1f6b0986",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -71,7 +71,7 @@ double CAddrInfo::GetChance(int64 nNow) const\n         fChance *= 0.01;\n \n     // deprioritize 50% after each failed attempt\n-    for (int n=0; n<nAttempts; n++)\n+    for (int n = 0; n < nAttempts; ++n)\n         fChance /= 1.5;\n \n     return fChance;\n@@ -124,7 +124,7 @@ int CAddrMan::SelectTried(int nKBucket)\n     // random shuffle the first few elements (using the entire list)\n     // find the least recently tried among them\n     int64 nOldest = -1;\n-    for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n+    for (unsigned int i = 0; i < ADDRMAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); ++i)\n     {\n         int nPos = GetRandInt(vTried.size() - i) + i;\n         int nTemp = vTried[nPos];\n@@ -142,7 +142,7 @@ int CAddrMan::ShrinkNew(int nUBucket)\n     std::set<int> &vNew = vvNew[nUBucket];\n \n     // first look for deletable items\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n+    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); ++it)\n     {\n         CAddrInfo &info = mapInfo[*it];\n         if (info.IsTerrible())\n@@ -153,7 +153,7 @@ int CAddrMan::ShrinkNew(int nUBucket)\n                 vRandom.pop_back();\n                 mapAddr.erase(info);\n                 mapInfo.erase(*it);\n-                nNew--;\n+                --nNew;\n             }\n             vNew.erase(it);\n             return 0;\n@@ -164,14 +164,14 @@ int CAddrMan::ShrinkNew(int nUBucket)\n     int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n     int nI = 0;\n     int nOldest = -1;\n-    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n+    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); ++it)\n     {\n         if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n         {\n             if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n                 nOldest = *it;\n         }\n-        nI++;\n+        ++nI;\n     }\n     CAddrInfo &info = mapInfo[nOldest];\n     if (--info.nRefCount == 0) \n@@ -180,7 +180,7 @@ int CAddrMan::ShrinkNew(int nUBucket)\n         vRandom.pop_back();\n         mapAddr.erase(info);\n         mapInfo.erase(nOldest);\n-        nNew--;\n+        --nNew;\n     }\n     vNew.erase(nOldest);\n \n@@ -190,12 +190,12 @@ int CAddrMan::ShrinkNew(int nUBucket)\n void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n {\n     // remove the entry from all new buckets\n-    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n+    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); ++it)\n     {\n         if ((*it).erase(nId))\n-            info.nRefCount--;\n+            --info.nRefCount;\n     }\n-    nNew--;\n+    --nNew;\n \n     // what tried bucket to move the entry to\n     int nKBucket = info.GetTriedBucket(nKey);\n@@ -205,7 +205,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n     if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n     {\n         vTried.push_back(nId);\n-        nTried++;\n+        ++nTried;\n         info.fInTried = true;\n         return;\n     }\n@@ -232,7 +232,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n         // otherwise, move it to the new bucket nId came from (there is certainly place there)\n         vvNew[nOrigin].insert(vTried[nPos]);\n     }\n-    nNew++;\n+    ++nNew;\n \n     vTried[nPos] = nId;\n     // we just overwrote an entry in vTried; no need to update nTried\n@@ -270,7 +270,7 @@ void CAddrMan::Good_(const CService &addr, int64 nTime)\n     // find a bucket it is in now\n     int nRnd = GetRandInt(vvNew.size());\n     int nUBucket = -1;\n-    for (unsigned int n = 0; n < vvNew.size(); n++)\n+    for (unsigned int n = 0; n < vvNew.size(); ++n)\n     {\n         int nB = (n+nRnd) % vvNew.size();\n         std::set<int> &vNew = vvNew[nB];\n@@ -325,23 +325,23 @@ bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64 nTimePen\n \n         // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n         int nFactor = 1;\n-        for (int n=0; n<pinfo->nRefCount; n++)\n+        for (int n = 0; n < pinfo->nRefCount; ++n)\n             nFactor *= 2;\n         if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n             return false;\n     } else {\n         pinfo = Create(addr, source, &nId);\n         pinfo->nTime = max((int64)0, (int64)pinfo->nTime - nTimePenalty);\n //        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n-        nNew++;\n+        ++nNew;\n         fNew = true;\n     }\n \n     int nUBucket = pinfo->GetNewBucket(nKey, source);\n     std::set<int> &vNew = vvNew[nUBucket];\n     if (!vNew.count(nId))\n     {\n-        pinfo->nRefCount++;\n+        ++(pinfo->nRefCount);\n         if (vNew.size() == ADDRMAN_NEW_BUCKET_SIZE)\n             ShrinkNew(nUBucket);\n         vvNew[nUBucket].insert(nId);\n@@ -365,7 +365,7 @@ void CAddrMan::Attempt_(const CService &addr, int64 nTime)\n \n     // update info\n     info.nLastTry = nTime;\n-    info.nAttempts++;\n+    ++info.nAttempts;\n }\n \n CAddress CAddrMan::Select_(int nUnkBias)\n@@ -401,7 +401,7 @@ CAddress CAddrMan::Select_(int nUnkBias)\n             int nPos = GetRandInt(vNew.size());\n             std::set<int>::iterator it = vNew.begin();\n             while (nPos--)\n-                it++;\n+                ++it;\n             CAddrInfo &info = mapInfo[*it];\n             if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                 return info;\n@@ -418,7 +418,7 @@ int CAddrMan::Check_()\n \n     if (vRandom.size() != nTried + nNew) return -7;\n \n-    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n+    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); ++it)\n     {\n         int n = (*it).first;\n         CAddrInfo &info = (*it).second;\n@@ -442,20 +442,20 @@ int CAddrMan::Check_()\n     if (setTried.size() != nTried) return -9;\n     if (mapNew.size() != nNew) return -10;\n \n-    for (int n=0; n<vvTried.size(); n++)\n+    for (int n = 0; n < vvTried.size(); ++n)\n     {\n         std::vector<int> &vTried = vvTried[n];\n-        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n+        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); ++it)\n         {\n             if (!setTried.count(*it)) return -11;\n             setTried.erase(*it);\n         }\n     }\n \n-    for (int n=0; n<vvNew.size(); n++)\n+    for (int n = 0; n < vvNew.size(); ++n)\n     {\n         std::set<int> &vNew = vvNew[n];\n-        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n+        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); ++it)\n         {\n             if (!mapNew.count(*it)) return -12;\n             if (--mapNew[*it] == 0)\n@@ -477,7 +477,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n         nNodes = ADDRMAN_GETADDR_MAX;\n \n     // perform a random shuffle over the first nNodes elements of vRandom (selecting from all)\n-    for (int n = 0; n<nNodes; n++)\n+    for (int n = 0; n<nNodes; ++n)\n     {\n         int nRndPos = GetRandInt(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);"
      },
      {
        "sha": "48a40f98942b2f9dc6e06c64793233b93b2cec14",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -281,34 +281,34 @@ class CAddrMan\n                 READWRITE(nUBuckets);\n                 std::map<int, int> mapUnkIds;\n                 int nIds = 0;\n-                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n+                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); ++it)\n                 {\n                     if (nIds == nNew) break; // this means nNew was wrong, oh ow\n                     mapUnkIds[(*it).first] = nIds;\n                     CAddrInfo &info = (*it).second;\n                     if (info.nRefCount)\n                     {\n                         READWRITE(info);\n-                        nIds++;\n+                        ++nIds;\n                     }\n                 }\n                 nIds = 0;\n-                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n+                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); ++it)\n                 {\n                     if (nIds == nTried) break; // this means nTried was wrong, oh ow\n                     CAddrInfo &info = (*it).second;\n                     if (info.fInTried)\n                     {\n                         READWRITE(info);\n-                        nIds++;\n+                        ++nIds;\n                     }\n                 }\n-                for (std::vector<std::set<int> >::iterator it = am->vvNew.begin(); it != am->vvNew.end(); it++)\n+                for (std::vector<std::set<int> >::iterator it = am->vvNew.begin(); it != am->vvNew.end(); ++it)\n                 {\n                     const std::set<int> &vNew = (*it);\n                     int nSize = vNew.size();\n                     READWRITE(nSize);\n-                    for (std::set<int>::iterator it2 = vNew.begin(); it2 != vNew.end(); it2++)\n+                    for (std::set<int>::iterator it2 = vNew.begin(); it2 != vNew.end(); ++it2)\n                     {\n                         int nIndex = mapUnkIds[*it2];\n                         READWRITE(nIndex);\n@@ -323,7 +323,7 @@ class CAddrMan\n                 am->vRandom.clear();\n                 am->vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n                 am->vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n-                for (int n = 0; n < am->nNew; n++)\n+                for (int n = 0; n < am->nNew; ++n)\n                 {\n                     CAddrInfo &info = am->mapInfo[n];\n                     READWRITE(info);\n@@ -333,12 +333,12 @@ class CAddrMan\n                     if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT)\n                     {\n                         am->vvNew[info.GetNewBucket(am->nKey)].insert(n);\n-                        info.nRefCount++;\n+                        ++info.nRefCount;\n                     }\n                 }\n                 am->nIdCount = am->nNew;\n                 int nLost = 0;\n-                for (int n = 0; n < am->nTried; n++)\n+                for (int n = 0; n < am->nTried; ++n)\n                 {\n                     CAddrInfo info;\n                     READWRITE(info);\n@@ -351,25 +351,25 @@ class CAddrMan\n                         am->mapInfo[am->nIdCount] = info;\n                         am->mapAddr[info] = am->nIdCount;\n                         vTried.push_back(am->nIdCount);\n-                        am->nIdCount++;\n+                        ++am->nIdCount;\n                     } else {\n-                        nLost++;\n+                        ++nLost;\n                     }\n                 }\n                 am->nTried -= nLost;\n-                for (int b = 0; b < nUBuckets; b++)\n+                for (int b = 0; b < nUBuckets; ++b)\n                 {\n                     std::set<int> &vNew = am->vvNew[b];\n                     int nSize = 0;\n                     READWRITE(nSize);\n-                    for (int n = 0; n < nSize; n++)\n+                    for (int n = 0; n < nSize; ++n)\n                     {\n                         int nIndex = 0;\n                         READWRITE(nIndex);\n                         CAddrInfo &info = am->mapInfo[nIndex];\n                         if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n                         {\n-                            info.nRefCount++;\n+                            ++info.nRefCount;\n                             vNew.insert(nIndex);\n                         }\n                     }\n@@ -429,7 +429,7 @@ class CAddrMan\n         {\n             LOCK(cs);\n             Check();\n-            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); ++it)\n                 nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n             Check();\n         }"
      },
      {
        "sha": "4a7e92f5056acbad6f18f4a8e25ab474594ce88c",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -55,7 +55,7 @@ inline std::string EncodeBase58(const unsigned char* pbegin, const unsigned char\n     }\n \n     // Leading zeroes encoded as base58 zeros\n-    for (const unsigned char* p = pbegin; p < pend && *p == 0; p++)\n+    for (const unsigned char* p = pbegin; p < pend && *p == 0; ++p)\n         str += pszBase58[0];\n \n     // Convert little endian std::string to big endian\n@@ -79,16 +79,16 @@ inline bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet)\n     CBigNum bn = 0;\n     CBigNum bnChar;\n     while (isspace(*psz))\n-        psz++;\n+        ++psz;\n \n     // Convert big endian string to bignum\n-    for (const char* p = psz; *p; p++)\n+    for (const char* p = psz; *p; ++p)\n     {\n         const char* p1 = strchr(pszBase58, *p);\n         if (p1 == NULL)\n         {\n             while (isspace(*p))\n-                p++;\n+                ++p;\n             if (*p != '\\0')\n                 return false;\n             break;\n@@ -108,8 +108,8 @@ inline bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet)\n \n     // Restore leading zeros\n     int nLeadingZeros = 0;\n-    for (const char* p = psz; *p == pszBase58[0]; p++)\n-        nLeadingZeros++;\n+    for (const char* p = psz; *p == pszBase58[0]; ++p)\n+        ++nLeadingZeros;\n     vchRet.assign(nLeadingZeros + vchTmp.size(), 0);\n \n     // Convert little endian data to big endian"
      },
      {
        "sha": "9047ac989a5327fd6735b788fc3b418dbed2421f",
        "filename": "src/bignum.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/bignum.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/bignum.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bignum.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -133,7 +133,7 @@ class CBigNum : public BIGNUM\n             fNegative = true;\n         }\n         bool fLeadingZeroes = true;\n-        for (int i = 0; i < 8; i++)\n+        for (int i = 0; i < 8; ++i)\n         {\n             unsigned char c = (n >> 56) & 0xff;\n             n <<= 8;\n@@ -162,7 +162,7 @@ class CBigNum : public BIGNUM\n         unsigned char pch[sizeof(n) + 6];\n         unsigned char* p = pch + 4;\n         bool fLeadingZeroes = true;\n-        for (int i = 0; i < 8; i++)\n+        for (int i = 0; i < 8; ++i)\n         {\n             unsigned char c = (n >> 56) & 0xff;\n             n <<= 8;\n@@ -222,7 +222,7 @@ class CBigNum : public BIGNUM\n         if (vch.size() > 4)\n             vch[4] &= 0x7f;\n         uint256 n = 0;\n-        for (int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n+        for (int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; ++i, --j)\n             ((unsigned char*)&n)[i] = vch[j];\n         return n;\n     }\n@@ -284,17 +284,17 @@ class CBigNum : public BIGNUM\n         // skip 0x\n         const char* psz = str.c_str();\n         while (isspace(*psz))\n-            psz++;\n+            ++psz;\n         bool fNegative = false;\n         if (*psz == '-')\n         {\n             fNegative = true;\n-            psz++;\n+            ++psz;\n         }\n         if (psz[0] == '0' && tolower(psz[1]) == 'x')\n             psz += 2;\n         while (isspace(*psz))\n-            psz++;\n+            ++psz;\n \n         // hex string to bignum\n         static signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };"
      },
      {
        "sha": "72b59476ba81854fd499fabab46772e19a13cb88",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -72,12 +72,12 @@ double GetDifficulty(const CBlockIndex* blockindex = NULL)\n     while (nShift < 29)\n     {\n         dDiff *= 256.0;\n-        nShift++;\n+        ++nShift;\n     }\n     while (nShift > 29)\n     {\n         dDiff /= 256.0;\n-        nShift--;\n+        --nShift;\n     }\n \n     return dDiff;\n@@ -1005,7 +1005,7 @@ Value addmultisigaddress(const Array& params, bool fHelp)\n                       \"(got %d, need at least %d)\", keys.size(), nRequired));\n     std::vector<CKey> pubkeys;\n     pubkeys.resize(keys.size());\n-    for (unsigned int i = 0; i < keys.size(); i++)\n+    for (unsigned int i = 0; i < keys.size(); ++i)\n     {\n         const std::string& ks = keys[i].get_str();\n \n@@ -1427,7 +1427,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n \n     Array transactions;\n \n-    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); it++)\n+    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         CWalletTx tx = (*it).second;\n \n@@ -1848,7 +1848,7 @@ Value getwork(const Array& params, bool fHelp)\n         CBlock* pdata = (CBlock*)&vchData[0];\n \n         // Byte reverse\n-        for (int i = 0; i < 128/4; i++)\n+        for (int i = 0; i < 128/4; ++i)\n             ((unsigned int*)pdata)[i] = ByteReverse(((unsigned int*)pdata)[i]);\n \n         // Get saved block\n@@ -2059,7 +2059,7 @@ static const CRPCCommand vRPCCommands[] =\n CRPCTable::CRPCTable()\n {\n     unsigned int vcidx;\n-    for (vcidx = 0; vcidx < (sizeof(vRPCCommands) / sizeof(vRPCCommands[0])); vcidx++)\n+    for (vcidx = 0; vcidx < (sizeof(vRPCCommands) / sizeof(vRPCCommands[0])); ++vcidx)\n     {\n         const CRPCCommand *pcmd;\n \n@@ -2336,15 +2336,15 @@ void ThreadRPCServer(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadRPCServer(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_RPCSERVER]++;\n+        ++vnThreadsRunning[THREAD_RPCSERVER];\n         ThreadRPCServer2(parg);\n-        vnThreadsRunning[THREAD_RPCSERVER]--;\n+        --vnThreadsRunning[THREAD_RPCSERVER];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_RPCSERVER]--;\n+        --vnThreadsRunning[THREAD_RPCSERVER];\n         PrintException(&e, \"ThreadRPCServer()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_RPCSERVER]--;\n+        --vnThreadsRunning[THREAD_RPCSERVER];\n         PrintException(NULL, \"ThreadRPCServer()\");\n     }\n     printf(\"ThreadRPCServer exiting\\n\");\n@@ -2427,9 +2427,9 @@ void ThreadRPCServer2(void* parg)\n         iostreams::stream<SSLIOStreamDevice> stream(d);\n \n         ip::tcp::endpoint peer;\n-        vnThreadsRunning[THREAD_RPCSERVER]--;\n+        --vnThreadsRunning[THREAD_RPCSERVER];\n         acceptor.accept(sslStream.lowest_layer(), peer);\n-        vnThreadsRunning[4]++;\n+        ++vnThreadsRunning[4];\n         if (fShutdown)\n             return;\n \n@@ -2627,8 +2627,8 @@ int CommandLineRPC(int argc, char *argv[])\n         // Skip switches\n         while (argc > 1 && IsSwitchChar(argv[1][0]))\n         {\n-            argc--;\n-            argv++;\n+            --argc;\n+            ++argv;\n         }\n \n         // Method\n@@ -2638,7 +2638,7 @@ int CommandLineRPC(int argc, char *argv[])\n \n         // Parameters default to strings\n         Array params;\n-        for (int i = 2; i < argc; i++)\n+        for (int i = 2; i < argc; ++i)\n             params.push_back(argv[i]);\n         int n = params.size();\n "
      },
      {
        "sha": "3c38c0a0c59e777e41d3988698c8e3b2f947f5d1",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -313,7 +313,7 @@ void DBFlush(bool fShutdown)\n                 mapFileUseCount.erase(mi++);\n             }\n             else\n-                mi++;\n+                ++mi;\n         }\n         if (fShutdown)\n         {\n@@ -689,7 +689,7 @@ bool CTxDB::LoadBlockIndex()\n                                     }\n                                 }\n                             }\n-                            nOutput++;\n+                            ++nOutput;\n                         }\n                     }\n                 }"
      },
      {
        "sha": "5c3eaa368b8e4d6f1d851943b5cc3612ed92128e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -53,7 +53,7 @@ void Shutdown(void* parg)\n     if (fFirstThread)\n     {\n         fShutdown = true;\n-        nTransactionsUpdated++;\n+        ++nTransactionsUpdated;\n         DBFlush(false);\n         StopNode();\n         DBFlush(true);\n@@ -275,7 +275,7 @@ bool AppInit2(int argc, char* argv[])\n     fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n \n #ifndef QT_GUI\n-    for (int i = 1; i < argc; i++)\n+    for (int i = 1; i < argc; ++i)\n         if (!IsSwitchChar(argv[i][0]) && !(strlen(argv[i]) > 7 && strncasecmp(argv[i], \"bitcoin:\", 8) == 0))\n             fCommandLine = true;\n \n@@ -494,7 +494,7 @@ bool AppInit2(int argc, char* argv[])\n                 block.BuildMerkleTree();\n                 block.print();\n                 printf(\"\\n\");\n-                nFound++;\n+                ++nFound;\n             }\n         }\n         if (nFound == 0)"
      },
      {
        "sha": "0ce84881ef42d415d216517a1bbb95a4d4df55b6",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -124,7 +124,7 @@ bool Wait(int nSeconds)\n     if (fShutdown)\n         return false;\n     printf(\"IRC waiting %d seconds to reconnect\\n\", nSeconds);\n-    for (int i = 0; i < nSeconds; i++)\n+    for (int i = 0; i < nSeconds; ++i)\n     {\n         if (fShutdown)\n             return false;\n@@ -343,7 +343,7 @@ void ThreadIRCSeed2(void* parg)\n                     addr.nTime = GetAdjustedTime();\n                     if (addrman.Add(addr, addrConnect, 51 * 60))\n                         printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n-                    nGotIRCAddresses++;\n+                    ++nGotIRCAddresses;\n                 }\n                 else\n                 {"
      },
      {
        "sha": "9fad65cbb1a9769d0a589e83c27d6b99eefabd00",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -236,7 +236,7 @@ class CKey\n         if (nBitsR <= 256 && nBitsS <= 256)\n         {\n             int nRecId = -1;\n-            for (int i=0; i<4; i++)\n+            for (int i=0; i<4; ++i)\n             {\n                 CKey keyRec;\n                 keyRec.fSet = true;"
      },
      {
        "sha": "46b5c1c86664979df494409fe612b5268157404d",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -74,7 +74,7 @@ class CBasicKeyStore : public CKeyStore\n             while (mi != mapKeys.end())\n             {\n                 setAddress.insert((*mi).first);\n-                mi++;\n+                ++mi;\n             }\n         }\n     }\n@@ -182,7 +182,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n         while (mi != mapCryptedKeys.end())\n         {\n             setAddress.insert((*mi).first);\n-            mi++;\n+            ++mi;\n         }\n     }\n };"
      },
      {
        "sha": "95cb8156ebb3b51aa7def68f9c9afc1f62fd90a7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 41,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -188,7 +188,7 @@ void static EraseOrphanTx(uint256 hash)\n             if ((*mi).second == pvMsg)\n                 mapOrphanTransactionsByPrev.erase(mi++);\n             else\n-                mi++;\n+                ++mi;\n         }\n     }\n     delete pvMsg;\n@@ -286,7 +286,7 @@ bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n     if (IsCoinBase())\n         return true; // Coinbases don't use vin normally\n \n-    for (unsigned int i = 0; i < vin.size(); i++)\n+    for (unsigned int i = 0; i < vin.size(); ++i)\n     {\n         const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n \n@@ -369,7 +369,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n         hashBlock = pblock->GetHash();\n \n         // Locate the transaction\n-        for (nIndex = 0; nIndex < pblock->vtx.size(); nIndex++)\n+        for (nIndex = 0; nIndex < pblock->vtx.size(); ++nIndex)\n             if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                 break;\n         if (nIndex == pblock->vtx.size())\n@@ -483,7 +483,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n \n     // Check for conflicts with in-memory transactions\n     CTransaction* ptxOld = NULL;\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    for (unsigned int i = 0; i < tx.vin.size(); ++i)\n     {\n         COutPoint outpoint = tx.vin[i].prevout;\n         if (mapNextTx.count(outpoint))\n@@ -499,7 +499,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                 return false;\n             if (!tx.IsNewerThan(*ptxOld))\n                 return false;\n-            for (unsigned int i = 0; i < tx.vin.size(); i++)\n+            for (unsigned int i = 0; i < tx.vin.size(); ++i)\n             {\n                 COutPoint outpoint = tx.vin[i].prevout;\n                 if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n@@ -605,9 +605,9 @@ bool CTxMemPool::addUnchecked(CTransaction &tx)\n         LOCK(cs);\n         uint256 hash = tx.GetHash();\n         mapTx[hash] = tx;\n-        for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        for (unsigned int i = 0; i < tx.vin.size(); ++i)\n             mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n-        nTransactionsUpdated++;\n+        ++nTransactionsUpdated;\n     }\n     return true;\n }\n@@ -624,7 +624,7 @@ bool CTxMemPool::remove(CTransaction &tx)\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n             mapTx.erase(hash);\n-            nTransactionsUpdated++;\n+            ++nTransactionsUpdated;\n         }\n     }\n     return true;\n@@ -841,7 +841,7 @@ unsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBl\n \n     // Go back by what we want to be 14 days worth of blocks\n     const CBlockIndex* pindexFirst = pindexLast;\n-    for (int i = 0; pindexFirst && i < nInterval-1; i++)\n+    for (int i = 0; pindexFirst && i < nInterval-1; ++i)\n         pindexFirst = pindexFirst->pprev;\n     assert(pindexFirst);\n \n@@ -989,7 +989,7 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n     if (IsCoinBase())\n         return true; // Coinbase transactions have no inputs to fetch.\n \n-    for (unsigned int i = 0; i < vin.size(); i++)\n+    for (unsigned int i = 0; i < vin.size(); ++i)\n     {\n         COutPoint prevout = vin[i].prevout;\n         if (inputsRet.count(prevout.hash))\n@@ -1034,7 +1034,7 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n     }\n \n     // Make sure all prevout.n's are valid:\n-    for (unsigned int i = 0; i < vin.size(); i++)\n+    for (unsigned int i = 0; i < vin.size(); ++i)\n     {\n         const COutPoint prevout = vin[i].prevout;\n         assert(inputsRet.count(prevout.hash) != 0);\n@@ -1071,7 +1071,7 @@ int64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n         return 0;\n \n     int64 nResult = 0;\n-    for (unsigned int i = 0; i < vin.size(); i++)\n+    for (unsigned int i = 0; i < vin.size(); ++i)\n     {\n         nResult += GetOutputFor(vin[i], inputs).nValue;\n     }\n@@ -1085,7 +1085,7 @@ int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n         return 0;\n \n     int nSigOps = 0;\n-    for (unsigned int i = 0; i < vin.size(); i++)\n+    for (unsigned int i = 0; i < vin.size(); ++i)\n     {\n         const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n@@ -1106,7 +1106,7 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n     {\n         int64 nValueIn = 0;\n         int64 nFees = 0;\n-        for (unsigned int i = 0; i < vin.size(); i++)\n+        for (unsigned int i = 0; i < vin.size(); ++i)\n         {\n             COutPoint prevout = vin[i].prevout;\n             assert(inputs.count(prevout.hash) > 0);\n@@ -1185,7 +1185,7 @@ bool CTransaction::ClientConnectInputs()\n     {\n         LOCK(mempool.cs);\n         int64 nValueIn = 0;\n-        for (unsigned int i = 0; i < vin.size(); i++)\n+        for (unsigned int i = 0; i < vin.size(); ++i)\n         {\n             // Get prev tx from single transactions in memory\n             COutPoint prevout = vin[i].prevout;\n@@ -1228,7 +1228,7 @@ bool CTransaction::ClientConnectInputs()\n bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n {\n     // Disconnect in reverse order\n-    for (int i = vtx.size()-1; i >= 0; i--)\n+    for (int i = vtx.size()-1; i >= 0; --i)\n         if (!vtx[i].DisconnectInputs(txdb))\n             return false;\n \n@@ -1397,7 +1397,7 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n \n     // Connect longer branch\n     vector<CTransaction> vDelete;\n-    for (unsigned int i = 0; i < vConnect.size(); i++)\n+    for (unsigned int i = 0; i < vConnect.size(); ++i)\n     {\n         CBlockIndex* pindex = vConnect[i];\n         CBlock block;\n@@ -1552,7 +1552,7 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n     nBestHeight = pindexBest->nHeight;\n     bnBestChainWork = pindexNew->bnChainWork;\n     nTimeBestReceived = GetTime();\n-    nTransactionsUpdated++;\n+    ++nTransactionsUpdated;\n     printf(\"SetBestChain: new best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n \n     std::string strCmd = GetArg(\"-blocknotify\", \"\");\n@@ -1636,7 +1636,7 @@ bool CBlock::CheckBlock() const\n     // First transaction must be coinbase, the rest must not be\n     if (vtx.empty() || !vtx[0].IsCoinBase())\n         return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n-    for (unsigned int i = 1; i < vtx.size(); i++)\n+    for (unsigned int i = 1; i < vtx.size(); ++i)\n         if (vtx[i].IsCoinBase())\n             return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n \n@@ -1772,7 +1772,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n     // Recursively process any orphan blocks that depended on this one\n     vector<uint256> vWorkQueue;\n     vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+    for (unsigned int i = 0; i < vWorkQueue.size(); ++i)\n     {\n         uint256 hashPrev = vWorkQueue[i];\n         for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n@@ -1854,7 +1854,7 @@ FILE* AppendBlockFile(unsigned int& nFileRet)\n             return file;\n         }\n         fclose(file);\n-        nCurrentBlockFile++;\n+        ++nCurrentBlockFile;\n     }\n }\n \n@@ -1965,20 +1965,20 @@ void PrintBlockTree()\n         // print split or gap\n         if (nCol > nPrevCol)\n         {\n-            for (int i = 0; i < nCol-1; i++)\n+            for (int i = 0; i < nCol-1; ++i)\n                 printf(\"| \");\n             printf(\"|\\\\\\n\");\n         }\n         else if (nCol < nPrevCol)\n         {\n-            for (int i = 0; i < nCol; i++)\n+            for (int i = 0; i < nCol; ++i)\n                 printf(\"| \");\n             printf(\"|\\n\");\n        }\n         nPrevCol = nCol;\n \n         // print columns\n-        for (int i = 0; i < nCol; i++)\n+        for (int i = 0; i < nCol; ++i)\n             printf(\"| \");\n \n         // print item\n@@ -1996,7 +1996,7 @@ void PrintBlockTree()\n \n         // put the main timechain first\n         vector<CBlockIndex*>& vNext = mapNext[pindex];\n-        for (unsigned int i = 0; i < vNext.size(); i++)\n+        for (unsigned int i = 0; i < vNext.size(); ++i)\n         {\n             if (vNext[i]->pnext)\n             {\n@@ -2006,7 +2006,7 @@ void PrintBlockTree()\n         }\n \n         // iterate children\n-        for (unsigned int i = 0; i < vNext.size(); i++)\n+        for (unsigned int i = 0; i < vNext.size(); ++i)\n             vStack.push_back(make_pair(nCol+i, vNext[i]));\n     }\n }\n@@ -2096,7 +2096,7 @@ bool CAlert::ProcessAlert()\n                 mapAlerts.erase(mi++);\n             }\n             else\n-                mi++;\n+                ++mi;\n         }\n \n         // Check if this alert has been cancelled\n@@ -2268,7 +2268,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n              pfrom->nVersion >= NOBLKS_VERSION_END) &&\n              (nAskedForBlocks < 1 || vNodes.size() <= 1))\n         {\n-            nAskedForBlocks++;\n+            ++nAskedForBlocks;\n             pfrom->PushGetBlocks(pindexBest, uint256(0));\n         }\n \n@@ -2375,7 +2375,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         CTxDB txdb(\"r\");\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n+        for (unsigned int nInv = 0; nInv < vInv.size(); ++nInv)\n         {\n             const CInv &inv = vInv[nInv];\n \n@@ -2551,7 +2551,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             vWorkQueue.push_back(inv.hash);\n \n             // Recursively process any orphan transactions that depended on this one\n-            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+            for (unsigned int i = 0; i < vWorkQueue.size(); ++i)\n             {\n                 uint256 hashPrev = vWorkQueue[i];\n                 for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);\n@@ -3038,14 +3038,14 @@ void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n \n     SHA256_Init(&ctx);\n \n-    for (int i = 0; i < 16; i++)\n+    for (int i = 0; i < 16; ++i)\n         ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n \n-    for (int i = 0; i < 8; i++)\n+    for (int i = 0; i < 8; ++i)\n         ctx.h[i] = ((uint32_t*)pinit)[i];\n \n     SHA256_Update(&ctx, data, sizeof(data));\n-    for (int i = 0; i < 8; i++) \n+    for (int i = 0; i < 8; ++i)\n         ((uint32_t*)pstate)[i] = ctx.h[i];\n }\n \n@@ -3064,7 +3064,7 @@ unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1\n         // Crypto++ SHA-256\n         // Hash pdata using pmidstate as the starting state into\n         // preformatted buffer phash1, then hash phash1 into phash\n-        nNonce++;\n+        ++nNonce;\n         SHA256Transform(phash1, pdata, pmidstate);\n         SHA256Transform(phash, phash1, pSHA256InitState);\n \n@@ -3331,7 +3331,7 @@ void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash\n     FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));\n \n     // Byte swap all the input buffer\n-    for (unsigned int i = 0; i < sizeof(tmp)/4; i++)\n+    for (unsigned int i = 0; i < sizeof(tmp)/4; ++i)\n         ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);\n \n     // Precalc the first half of the first hash, which stays constant\n@@ -3456,7 +3456,7 @@ void static BitcoinMiner(CWallet *pwallet)\n             // Check if something found\n             if (nNonceFound != -1)\n             {\n-                for (unsigned int i = 0; i < sizeof(hash)/4; i++)\n+                for (unsigned int i = 0; i < sizeof(hash)/4; ++i)\n                     ((unsigned int*)&hash)[i] = ByteReverse(((unsigned int*)&hash)[i]);\n \n                 if (hash <= hashTarget)\n@@ -3536,15 +3536,15 @@ void static ThreadBitcoinMiner(void* parg)\n     CWallet* pwallet = (CWallet*)parg;\n     try\n     {\n-        vnThreadsRunning[THREAD_MINER]++;\n+        ++vnThreadsRunning[THREAD_MINER];\n         BitcoinMiner(pwallet);\n-        vnThreadsRunning[THREAD_MINER]--;\n+        --vnThreadsRunning[THREAD_MINER];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_MINER]--;\n+        --vnThreadsRunning[THREAD_MINER];\n         PrintException(&e, \"ThreadBitcoinMiner()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_MINER]--;\n+        --vnThreadsRunning[THREAD_MINER];\n         PrintException(NULL, \"ThreadBitcoinMiner()\");\n     }\n     nHPSTimerStart = 0;\n@@ -3572,7 +3572,7 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n             nProcessors = nLimitProcessors;\n         int nAddThreads = nProcessors - vnThreadsRunning[THREAD_MINER];\n         printf(\"Starting %d BitcoinMiner threads\\n\", nAddThreads);\n-        for (int i = 0; i < nAddThreads; i++)\n+        for (int i = 0; i < nAddThreads; ++i)\n         {\n             if (!CreateThread(ThreadBitcoinMiner, pwallet))\n                 printf(\"Error: CreateThread(ThreadBitcoinMiner) failed\\n\");"
      },
      {
        "sha": "bf9cbbe47ad3a64f82c972fb2d9ea8aa54397d3c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -449,13 +449,13 @@ class CTransaction\n     {\n         if (vin.size() != old.vin.size())\n             return false;\n-        for (unsigned int i = 0; i < vin.size(); i++)\n+        for (unsigned int i = 0; i < vin.size(); ++i)\n             if (vin[i].prevout != old.vin[i].prevout)\n                 return false;\n \n         bool fNewer = false;\n         unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n-        for (unsigned int i = 0; i < vin.size(); i++)\n+        for (unsigned int i = 0; i < vin.size(); ++i)\n         {\n             if (vin[i].nSequence != old.vin[i].nSequence)\n             {\n@@ -629,9 +629,9 @@ class CTransaction\n             vin.size(),\n             vout.size(),\n             nLockTime);\n-        for (unsigned int i = 0; i < vin.size(); i++)\n+        for (unsigned int i = 0; i < vin.size(); ++i)\n             str += \"    \" + vin[i].ToString() + \"\\n\";\n-        for (unsigned int i = 0; i < vout.size(); i++)\n+        for (unsigned int i = 0; i < vout.size(); ++i)\n             str += \"    \" + vout[i].ToString() + \"\\n\";\n         return str;\n     }\n@@ -995,13 +995,13 @@ class CBlock\n             hashMerkleRoot.ToString().substr(0,10).c_str(),\n             nTime, nBits, nNonce,\n             vtx.size());\n-        for (unsigned int i = 0; i < vtx.size(); i++)\n+        for (unsigned int i = 0; i < vtx.size(); ++i)\n         {\n             printf(\"  \");\n             vtx[i].print();\n         }\n         printf(\"  vMerkleTree: \");\n-        for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n+        for (unsigned int i = 0; i < vMerkleTree.size(); ++i)\n             printf(\"%s \", vMerkleTree[i].ToString().substr(0,10).c_str());\n         printf(\"\\n\");\n     }\n@@ -1150,7 +1150,7 @@ class CBlockIndex\n         int64* pend = &pmedian[nMedianTimeSpan];\n \n         const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n+        for (int i = 0; i < nMedianTimeSpan && pindex; ++i, pindex = pindex->pprev)\n             *(--pbegin) = pindex->GetBlockTime();\n \n         std::sort(pbegin, pend);\n@@ -1160,7 +1160,7 @@ class CBlockIndex\n     int64 GetMedianTime() const\n     {\n         const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan/2; i++)\n+        for (int i = 0; i < nMedianTimeSpan/2; ++i)\n         {\n             if (!pindex->pnext)\n                 return GetBlockTime();\n@@ -1319,7 +1319,7 @@ class CBlockLocator\n             vHave.push_back(pindex->GetBlockHash());\n \n             // Exponentially larger steps back\n-            for (int i = 0; pindex && i < nStep; i++)\n+            for (int i = 0; pindex && i < nStep; ++i)\n                 pindex = pindex->pprev;\n             if (vHave.size() > 10)\n                 nStep *= 2;"
      },
      {
        "sha": "ef038f679709cda7eb232a578dd746dacd7ad0b1",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 58,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -196,8 +196,8 @@ bool GetMyExternalIP(CNetAddr& ipRet)\n     if (fNoListen||fUseProxy)\n         return false;\n \n-    for (int nLookup = 0; nLookup <= 1; nLookup++)\n-    for (int nHost = 1; nHost <= 2; nHost++)\n+    for (int nLookup = 0; nLookup <= 1; ++nLookup)\n+    for (int nHost = 1; nHost <= 2; ++nHost)\n     {\n         // We should be phasing out our use of sites like these.  If we need\n         // replacements, we should ask for volunteers to put this simple\n@@ -254,7 +254,7 @@ void ThreadGetMyExternalIP(void* parg)\n     // Wait for IRC to get it first\n     if (GetBoolArg(\"-irc\", false))\n     {\n-        for (int i = 0; i < 2 * 60; i++)\n+        for (int i = 0; i < 2 * 60; ++i)\n         {\n             Sleep(1000);\n             if (fGotExternalIP || fShutdown)\n@@ -370,7 +370,7 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n         }\n         {\n             WAITABLE_LOCK(csOutbound);\n-            nOutbound++;\n+            ++nOutbound;\n         }\n \n         pnode->nTimeConnected = GetTime();\n@@ -480,15 +480,15 @@ void ThreadSocketHandler(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadSocketHandler(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n+        ++vnThreadsRunning[THREAD_SOCKETHANDLER];\n         ThreadSocketHandler2(parg);\n-        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n+        --vnThreadsRunning[THREAD_SOCKETHANDLER];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n+        --vnThreadsRunning[THREAD_SOCKETHANDLER];\n         PrintException(&e, \"ThreadSocketHandler()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n+        --vnThreadsRunning[THREAD_SOCKETHANDLER];\n         throw; // support pthread_cancel()\n     }\n     printf(\"ThreadSocketHandler exiting\\n\");\n@@ -520,7 +520,7 @@ void ThreadSocketHandler2(void* parg)\n                     if (!pnode->fInbound)\n                         {\n                             WAITABLE_LOCK(csOutbound);\n-                            nOutbound--;\n+                            --nOutbound;\n \n                             // Connection slot(s) were removed, notify connection creator(s)\n                             NOTIFY(condOutbound);\n@@ -613,9 +613,9 @@ void ThreadSocketHandler2(void* parg)\n             }\n         }\n \n-        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n+        --vnThreadsRunning[THREAD_SOCKETHANDLER];\n         int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n+        ++vnThreadsRunning[THREAD_SOCKETHANDLER];\n         if (fShutdown)\n             return;\n         if (nSelect == SOCKET_ERROR)\n@@ -624,7 +624,7 @@ void ThreadSocketHandler2(void* parg)\n             if (hSocketMax > -1)\n             {\n                 printf(\"socket select error %d\\n\", nErr);\n-                for (unsigned int i = 0; i <= hSocketMax; i++)\n+                for (unsigned int i = 0; i <= hSocketMax; ++i)\n                     FD_SET(i, &fdsetRecv);\n             }\n             FD_ZERO(&fdsetSend);\n@@ -651,7 +651,7 @@ void ThreadSocketHandler2(void* parg)\n                 LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n                     if (pnode->fInbound)\n-                        nInbound++;\n+                        ++nInbound;\n             }\n \n             if (hSocket == INVALID_SOCKET)\n@@ -836,15 +836,15 @@ void ThreadMapPort(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadMapPort(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_UPNP]++;\n+        ++vnThreadsRunning[THREAD_UPNP];\n         ThreadMapPort2(parg);\n-        vnThreadsRunning[THREAD_UPNP]--;\n+        --vnThreadsRunning[THREAD_UPNP];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_UPNP]--;\n+        --vnThreadsRunning[THREAD_UPNP];\n         PrintException(&e, \"ThreadMapPort()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_UPNP]--;\n+        --vnThreadsRunning[THREAD_UPNP];\n         PrintException(NULL, \"ThreadMapPort()\");\n     }\n     printf(\"ThreadMapPort exiting\\n\");\n@@ -943,7 +943,7 @@ void ThreadMapPort2(void* parg)\n                     printf(\"UPnP Port Mapping successful.\\n\");;\n             }\n             Sleep(2000);\n-            i++;\n+            ++i;\n         }\n     } else {\n         printf(\"No valid UPnP IGDs found\\n\");\n@@ -1001,15 +1001,15 @@ void ThreadDNSAddressSeed(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadDNSAddressSeed(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_DNSSEED]++;\n+        ++vnThreadsRunning[THREAD_DNSSEED];\n         ThreadDNSAddressSeed2(parg);\n-        vnThreadsRunning[THREAD_DNSSEED]--;\n+        --vnThreadsRunning[THREAD_DNSSEED];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_DNSSEED]--;\n+        --vnThreadsRunning[THREAD_DNSSEED];\n         PrintException(&e, \"ThreadDNSAddressSeed()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_DNSSEED]--;\n+        --vnThreadsRunning[THREAD_DNSSEED];\n         throw; // support pthread_cancel()\n     }\n     printf(\"ThreadDNSAddressSeed exiting\\n\");\n@@ -1024,7 +1024,7 @@ void ThreadDNSAddressSeed2(void* parg)\n     {\n         printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n-        for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n+        for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); ++seed_idx) {\n             vector<CNetAddr> vaddr;\n             vector<CAddress> vAdd;\n             if (LookupHost(strDNSSeed[seed_idx][1], vaddr))\n@@ -1035,7 +1035,7 @@ void ThreadDNSAddressSeed2(void* parg)\n                     CAddress addr = CAddress(CService(ip, GetDefaultPort()));\n                     addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n-                    found++;\n+                    ++found;\n                 }\n             }\n             addrman.Add(vAdd, CNetAddr(strDNSSeed[seed_idx][0], true));\n@@ -1145,15 +1145,15 @@ void DumpAddresses()\n \n void ThreadDumpAddress2(void* parg)\n {\n-    vnThreadsRunning[THREAD_DUMPADDRESS]++;\n+    ++vnThreadsRunning[THREAD_DUMPADDRESS];\n     while (!fShutdown)\n     {\n         DumpAddresses();\n-        vnThreadsRunning[THREAD_DUMPADDRESS]--;\n+        --vnThreadsRunning[THREAD_DUMPADDRESS];\n         Sleep(100000);\n-        vnThreadsRunning[THREAD_DUMPADDRESS]++;\n+        ++vnThreadsRunning[THREAD_DUMPADDRESS];\n     }\n-    vnThreadsRunning[THREAD_DUMPADDRESS]--;\n+    --vnThreadsRunning[THREAD_DUMPADDRESS];\n }\n \n void ThreadDumpAddress(void* parg)\n@@ -1174,15 +1174,15 @@ void ThreadOpenConnections(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadOpenConnections(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n+        ++vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         ThreadOpenConnections2(parg);\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_OPENCONNECTIONS];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         PrintException(&e, \"ThreadOpenConnections()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         PrintException(NULL, \"ThreadOpenConnections()\");\n     }\n     printf(\"ThreadOpenConnections exiting\\n\");\n@@ -1195,14 +1195,14 @@ void ThreadOpenConnections2(void* parg)\n     // Connect to specific addresses\n     if (mapArgs.count(\"-connect\"))\n     {\n-        for (int64 nLoop = 0;; nLoop++)\n+        for (int64 nLoop = 0;; ++nLoop)\n         {\n             BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n             {\n                 CAddress addr(CService(strAddr, GetDefaultPort(), fAllowDNS));\n                 if (addr.IsValid())\n                     OpenNetworkConnection(addr);\n-                for (int i = 0; i < 10 && i < nLoop; i++)\n+                for (int i = 0; i < 10 && i < nLoop; ++i)\n                 {\n                     Sleep(500);\n                     if (fShutdown)\n@@ -1216,20 +1216,20 @@ void ThreadOpenConnections2(void* parg)\n     int64 nStart = GetTime();\n     loop\n     {\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         Sleep(500);\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n+        ++vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         if (fShutdown)\n             return;\n \n         // Limit outbound connections\n         int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         {\n             WAITABLE_LOCK(csOutbound);\n             WAIT(condOutbound, fShutdown || nOutbound < nMaxOutbound);\n         }\n-        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n+        ++vnThreadsRunning[THREAD_OPENCONNECTIONS];\n         if (fShutdown)\n             return;\n \n@@ -1238,7 +1238,7 @@ void ThreadOpenConnections2(void* parg)\n         if (addrman.size()==0 && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n         {\n             std::vector<CAddress> vAdd;\n-            for (unsigned int i = 0; i < ARRAYLEN(pnSeed); i++)\n+            for (unsigned int i = 0; i < ARRAYLEN(pnSeed); ++i)\n             {\n                 // It'll only connect to one or two seed nodes because once it connects,\n                 // it'll get a pile of addresses with newer timestamps.\n@@ -1280,7 +1280,7 @@ void ThreadOpenConnections2(void* parg)\n             if (!addr.IsIPv4() || !addr.IsValid() || setConnected.count(addr.GetGroup()) || addr == addrLocalHost)\n                 break;\n \n-            nTries++;\n+            ++nTries;\n \n             // only consider very recently tried nodes after 30 failed attempts\n             if (nANow - addr.nLastTry < 600 && nTries < 30)\n@@ -1304,15 +1304,15 @@ void ThreadOpenAddedConnections(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadOpenAddedConnections(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n+        ++vnThreadsRunning[THREAD_ADDEDCONNECTIONS];\n         ThreadOpenAddedConnections2(parg);\n-        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_ADDEDCONNECTIONS];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_ADDEDCONNECTIONS];\n         PrintException(&e, \"ThreadOpenAddedConnections()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_ADDEDCONNECTIONS];\n         PrintException(NULL, \"ThreadOpenAddedConnections()\");\n     }\n     printf(\"ThreadOpenAddedConnections exiting\\n\");\n@@ -1347,12 +1347,12 @@ void ThreadOpenAddedConnections2(void* parg)\n         {\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes)\n-                for (vector<vector<CService> >::iterator it = vservConnectAddresses.begin(); it != vservConnectAddresses.end(); it++)\n+                for (vector<vector<CService> >::iterator it = vservConnectAddresses.begin(); it != vservConnectAddresses.end(); ++it)\n                     BOOST_FOREACH(CService& addrNode, *(it))\n                         if (pnode->addr == addrNode)\n                         {\n                             it = vservConnectAddresses.erase(it);\n-                            it--;\n+                            --it;\n                             break;\n                         }\n         }\n@@ -1365,9 +1365,9 @@ void ThreadOpenAddedConnections2(void* parg)\n         }\n         if (fShutdown)\n             return;\n-        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n+        --vnThreadsRunning[THREAD_ADDEDCONNECTIONS];\n         Sleep(120000); // Retry every 2 minutes\n-        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n+        ++vnThreadsRunning[THREAD_ADDEDCONNECTIONS];\n         if (fShutdown)\n             return;\n     }\n@@ -1384,9 +1384,9 @@ bool OpenNetworkConnection(const CAddress& addrConnect)\n         FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect))\n         return false;\n \n-    vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+    --vnThreadsRunning[THREAD_OPENCONNECTIONS];\n     CNode* pnode = ConnectNode(addrConnect);\n-    vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n+    ++vnThreadsRunning[THREAD_OPENCONNECTIONS];\n     if (fShutdown)\n         return false;\n     if (!pnode)\n@@ -1408,15 +1408,15 @@ void ThreadMessageHandler(void* parg)\n     IMPLEMENT_RANDOMIZE_STACK(ThreadMessageHandler(parg));\n     try\n     {\n-        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n+        ++vnThreadsRunning[THREAD_MESSAGEHANDLER];\n         ThreadMessageHandler2(parg);\n-        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n+        --vnThreadsRunning[THREAD_MESSAGEHANDLER];\n     }\n     catch (std::exception& e) {\n-        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n+        --vnThreadsRunning[THREAD_MESSAGEHANDLER];\n         PrintException(&e, \"ThreadMessageHandler()\");\n     } catch (...) {\n-        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n+        --vnThreadsRunning[THREAD_MESSAGEHANDLER];\n         PrintException(NULL, \"ThreadMessageHandler()\");\n     }\n     printf(\"ThreadMessageHandler exiting\\n\");\n@@ -1470,11 +1470,11 @@ void ThreadMessageHandler2(void* parg)\n         // Wait and allow messages to bunch up.\n         // Reduce vnThreadsRunning so StopNode has permission to exit while\n         // we're sleeping, but we must always check fShutdown after doing this.\n-        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n+        --vnThreadsRunning[THREAD_MESSAGEHANDLER];\n         Sleep(100);\n         if (fRequestShutdown)\n             Shutdown(NULL);\n-        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n+        ++vnThreadsRunning[THREAD_MESSAGEHANDLER];\n         if (fShutdown)\n             return;\n     }\n@@ -1687,13 +1687,13 @@ bool StopNode()\n {\n     printf(\"StopNode()\\n\");\n     fShutdown = true;\n-    nTransactionsUpdated++;\n+    ++nTransactionsUpdated;\n     int64 nStart = GetTime();\n     NOTIFY_ALL(condOutbound);\n     do\n     {\n         int nThreadsRunning = 0;\n-        for (int n = 0; n < THREAD_MAX; n++)\n+        for (int n = 0; n < THREAD_MAX; ++n)\n             nThreadsRunning += vnThreadsRunning[n];\n         if (nThreadsRunning == 0)\n             break;"
      },
      {
        "sha": "4a4fd2bdbe0803d394e70a1611399c3498c75dd9",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -215,13 +215,13 @@ class CNode\n         if (nTimeout != 0)\n             nReleaseTime = std::max(nReleaseTime, GetTime() + nTimeout);\n         else\n-            nRefCount++;\n+            ++nRefCount;\n         return this;\n     }\n \n     void Release()\n     {\n-        nRefCount--;\n+        --nRefCount;\n     }\n \n "
      },
      {
        "sha": "dc5405bab2633012930b3a0334a9749a6fb530c5",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -136,7 +136,7 @@ bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault,\n     if (!fRet)\n         return false;\n     vAddr.resize(vIP.size());\n-    for (unsigned int i = 0; i < vIP.size(); i++)\n+    for (unsigned int i = 0; i < vIP.size(); ++i)\n         vAddr[i] = CService(vIP[i], port);\n     return true;\n }\n@@ -568,7 +568,7 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n     while (nBits >= 8)\n     {\n         vchRet.push_back(GetByte(15 - nStartByte));\n-        nStartByte++;\n+        ++nStartByte;\n         nBits -= 8;\n     }\n     if (nBits > 0)"
      },
      {
        "sha": "b6c1c55f820a064d7a4bc6c1c59bded32a8f6f0b",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -50,12 +50,12 @@ bool CMessageHeader::IsValid() const\n         return false;\n \n     // Check the command string for errors\n-    for (const char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n+    for (const char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; ++p1)\n     {\n         if (*p1 == 0)\n         {\n             // Must be all zeros after the first zero\n-            for (; p1 < pchCommand + COMMAND_SIZE; p1++)\n+            for (; p1 < pchCommand + COMMAND_SIZE; ++p1)\n                 if (*p1 != 0)\n                     return false;\n         }\n@@ -108,7 +108,7 @@ CInv::CInv(int typeIn, const uint256& hashIn)\n CInv::CInv(const std::string& strType, const uint256& hashIn)\n {\n     unsigned int i;\n-    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n+    for (i = 1; i < ARRAYLEN(ppszTypeName); ++i)\n     {\n         if (strType == ppszTypeName[i])\n         {"
      },
      {
        "sha": "6f62a698944bfd71e3e527f0468b419113f00bff",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -138,7 +138,7 @@ int main(int argc, char *argv[])\n // TODO: implement qtipcserver.cpp for Mac and Windows\n \n     // Do this early as we don't want to bother initializing if we are just calling IPC\n-    for (int i = 1; i < argc; i++)\n+    for (int i = 1; i < argc; ++i)\n     {\n         if (strlen(argv[i]) > 7 && strncasecmp(argv[i], \"bitcoin:\", 8) == 0)\n         {\n@@ -264,7 +264,7 @@ int main(int argc, char *argv[])\n // TODO: implement qtipcserver.cpp for Mac and Windows\n \n                 // Check for URI in argv\n-                for (int i = 1; i < argc; i++)\n+                for (int i = 1; i < argc; ++i)\n                 {\n                     if (strlen(argv[i]) > 7 && strncasecmp(argv[i], \"bitcoin:\", 8) == 0)\n                     {"
      },
      {
        "sha": "5704b8735726b659601c340a30f6e5e30d00617f",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -61,7 +61,7 @@ bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n     rv.address = uri.path();\n     rv.amount = 0;\n     QList<QPair<QString, QString> > items = uri.queryItems();\n-    for (QList<QPair<QString, QString> >::iterator i = items.begin(); i != items.end(); i++)\n+    for (QList<QPair<QString, QString> >::iterator i = items.begin(); i != items.end(); ++i)\n     {\n         bool fShouldReturnFalse = false;\n         if (i->first.startsWith(\"req-\"))"
      },
      {
        "sha": "f7c0610cadef88f686e5184220210e81e254fe10",
        "filename": "src/qt/qrcodedialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/qrcodedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/qrcodedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qrcodedialog.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -49,12 +49,12 @@ void QRCodeDialog::genCode()\n         myImage = QImage(code->width + 8, code->width + 8, QImage::Format_RGB32);\n         myImage.fill(0xffffff);\n         unsigned char *p = code->data;\n-        for (int y = 0; y < code->width; y++)\n+        for (int y = 0; y < code->width; ++y)\n         {\n-            for (int x = 0; x < code->width; x++)\n+            for (int x = 0; x < code->width; ++x)\n             {\n                 myImage.setPixel(x + 4, y + 4, ((*p & 1) ? 0x0 : 0xffffff));\n-                p++;\n+                ++p;\n             }\n         }\n         QRcode_free(code);\n@@ -76,22 +76,22 @@ QString QRCodeDialog::getURI()\n         if (ok)\n         {\n             ret += QString(\"?amount=%1\").arg(ui->lnReqAmount->text());\n-            paramCount++;\n+            ++paramCount;\n         }\n     }\n \n     if (!ui->lnLabel->text().isEmpty())\n     {\n         QString lbl(QUrl::toPercentEncoding(ui->lnLabel->text()));\n         ret += QString(\"%1label=%2\").arg(paramCount == 0 ? \"?\" : \"&\").arg(lbl);\n-        paramCount++;\n+        ++paramCount;\n     }\n \n     if (!ui->lnMessage->text().isEmpty())\n     {\n         QString msg(QUrl::toPercentEncoding(ui->lnMessage->text()));\n         ret += QString(\"%1message=%2\").arg(paramCount == 0 ? \"?\" : \"&\").arg(msg);\n-        paramCount++;\n+        ++paramCount;\n     }\n \n     // limit URI length to 255 chars, to prevent a DoS against the QR-Code dialog"
      },
      {
        "sha": "40e08e9fde5eeab380bdd0c904b8246f8a90c991",
        "filename": "src/qt/qtipcserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/qtipcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/qtipcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qtipcserver.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -65,7 +65,7 @@ void ipcInit()\n         mq = new message_queue(open_or_create, BITCOINURI_QUEUE_NAME, 2, 256);\n \n         // Make sure we don't lose any bitcoin: URIs\n-        for (int i = 0; i < 2; i++)\n+        for (int i = 0; i < 2; ++i)\n         {\n             ptime d = boost::posix_time::microsec_clock::universal_time() + millisec(1);\n             if(mq->timed_receive(&strBuf, sizeof(strBuf), nSize, nPriority, d))"
      },
      {
        "sha": "f758d2e6308808cf7e48a152f14b24938802408b",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -102,7 +102,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n                 //\n                 int64 nTxFee = nDebit - wtx.GetValueOut();\n \n-                for (int nOut = 0; nOut < wtx.vout.size(); nOut++)\n+                for (int nOut = 0; nOut < wtx.vout.size(); ++nOut)\n                 {\n                     const CTxOut& txout = wtx.vout[nOut];\n                     TransactionRecord sub(hash, nTime);"
      },
      {
        "sha": "4b49cdb0cfdd6c7a55db65a9458f7d2c3177bef0",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -38,7 +38,7 @@ CBigNum CastToBigNum(const valtype& vch)\n \n bool CastToBool(const valtype& vch)\n {\n-    for (int i = 0; i < vch.size(); i++)\n+    for (int i = 0; i < vch.size(); ++i)\n     {\n         if (vch[i] != 0)\n         {\n@@ -655,7 +655,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     if (stack.size() < 1)\n                         return false;\n                     valtype& vch = stacktop(-1);\n-                    for (int i = 0; i < vch.size(); i++)\n+                    for (int i = 0; i < vch.size(); ++i)\n                         vch[i] = ~vch[i];\n                 }\n                 break;\n@@ -672,17 +672,17 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     MakeSameSize(vch1, vch2);\n                     if (opcode == OP_AND)\n                     {\n-                        for (int i = 0; i < vch1.size(); i++)\n+                        for (int i = 0; i < vch1.size(); ++i)\n                             vch1[i] &= vch2[i];\n                     }\n                     else if (opcode == OP_OR)\n                     {\n-                        for (int i = 0; i < vch1.size(); i++)\n+                        for (int i = 0; i < vch1.size(); ++i)\n                             vch1[i] |= vch2[i];\n                     }\n                     else if (opcode == OP_XOR)\n                     {\n-                        for (int i = 0; i < vch1.size(); i++)\n+                        for (int i = 0; i < vch1.size(); ++i)\n                             vch1[i] ^= vch2[i];\n                     }\n                     popstack(stack);\n@@ -966,7 +966,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signatures, since there's no way for a signature to sign itself\n-                    for (int k = 0; k < nSigsCount; k++)\n+                    for (int k = 0; k < nSigsCount; ++k)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n                         scriptCode.FindAndDelete(CScript(vchSig));\n@@ -981,11 +981,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                         // Check signature\n                         if (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n                         {\n-                            isig++;\n-                            nSigsCount--;\n+                            ++isig;\n+                            --nSigsCount;\n                         }\n-                        ikey++;\n-                        nKeysCount--;\n+                        ++ikey;\n+                        --nKeysCount;\n \n                         // If there are more signatures left than keys left,\n                         // then too many signatures have failed\n@@ -1050,7 +1050,7 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n     scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n \n     // Blank out other inputs' signatures\n-    for (int i = 0; i < txTmp.vin.size(); i++)\n+    for (int i = 0; i < txTmp.vin.size(); ++i)\n         txTmp.vin[i].scriptSig = CScript();\n     txTmp.vin[nIn].scriptSig = scriptCode;\n \n@@ -1061,7 +1061,7 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n         txTmp.vout.clear();\n \n         // Let the others update at will\n-        for (int i = 0; i < txTmp.vin.size(); i++)\n+        for (int i = 0; i < txTmp.vin.size(); ++i)\n             if (i != nIn)\n                 txTmp.vin[i].nSequence = 0;\n     }\n@@ -1075,11 +1075,11 @@ uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int\n             return 1;\n         }\n         txTmp.vout.resize(nOut+1);\n-        for (int i = 0; i < nOut; i++)\n+        for (int i = 0; i < nOut; ++i)\n             txTmp.vout[i].SetNull();\n \n         // Let the others update at will\n-        for (int i = 0; i < txTmp.vin.size(); i++)\n+        for (int i = 0; i < txTmp.vin.size(); ++i)\n             if (i != nIn)\n                 txTmp.vin[i].nSequence = 0;\n     }\n@@ -1260,7 +1260,7 @@ bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint2\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n-    for (vector<valtype>::const_iterator it = multisigdata.begin()+1; it != multisigdata.begin()+multisigdata.size()-1; it++)\n+    for (vector<valtype>::const_iterator it = multisigdata.begin()+1; it != multisigdata.begin()+multisigdata.size()-1; ++it)\n     {\n         const valtype& pubkey = *it;\n         CBitcoinAddress address;\n@@ -1449,7 +1449,7 @@ bool ExtractAddresses(const CScript& scriptPubKey, txnouttype& typeRet, vector<C\n     if (typeRet == TX_MULTISIG)\n     {\n         nRequiredRet = vSolutions.front()[0];\n-        for (int i = 1; i < vSolutions.size()-1; i++)\n+        for (int i = 1; i < vSolutions.size()-1; ++i)\n         {\n             CBitcoinAddress address;\n             address.SetPubKey(vSolutions[i]);\n@@ -1577,7 +1577,7 @@ int CScript::GetSigOpCount(bool fAccurate) const\n         if (!GetOp(pc, opcode))\n             break;\n         if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n-            n++;\n+            ++n;\n         else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n         {\n             if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)"
      },
      {
        "sha": "5130b60413abd50c6938d9502a6408fddd33606c",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -462,7 +462,7 @@ void Unserialize_impl(Stream& is, std::vector<T, A>& v, int nType, int nVersion,\n         if (nMid > nSize)\n             nMid = nSize;\n         v.resize(nMid);\n-        for (; i < nMid; i++)\n+        for (; i < nMid; ++i)\n             Unserialize(is, v[i], nType, nVersion);\n     }\n }\n@@ -613,7 +613,7 @@ void Unserialize(Stream& is, std::map<K, T, Pred, A>& m, int nType, int nVersion\n     m.clear();\n     unsigned int nSize = ReadCompactSize(is);\n     typename std::map<K, T, Pred, A>::iterator mi = m.begin();\n-    for (unsigned int i = 0; i < nSize; i++)\n+    for (unsigned int i = 0; i < nSize; ++i)\n     {\n         std::pair<K, T> item;\n         Unserialize(is, item, nType, nVersion);\n@@ -649,7 +649,7 @@ void Unserialize(Stream& is, std::set<K, Pred, A>& m, int nType, int nVersion)\n     m.clear();\n     unsigned int nSize = ReadCompactSize(is);\n     typename std::set<K, Pred, A>::iterator it = m.begin();\n-    for (unsigned int i = 0; i < nSize; i++)\n+    for (unsigned int i = 0; i < nSize; ++i)\n     {\n         K key;\n         Unserialize(is, key, nType, nVersion);\n@@ -1042,7 +1042,7 @@ int main(int argc, char *argv[])\n     {\n         CDataStream ss;\n         time_t nStart = time(NULL);\n-        for (int i = 0; i < n; i++)\n+        for (int i = 0; i < n; ++i)\n             ss.write((char*)&vch[0], vch.size());\n         printf(\"n=%-10d %d seconds\\n\", n, time(NULL) - nStart);\n     }\n@@ -1051,7 +1051,7 @@ int main(int argc, char *argv[])\n     {\n         stringstream ss;\n         time_t nStart = time(NULL);\n-        for (int i = 0; i < n; i++)\n+        for (int i = 0; i < n; ++i)\n             ss.write((char*)&vch[0], vch.size());\n         printf(\"n=%-10d %d seconds\\n\", n, time(NULL) - nStart);\n     }"
      },
      {
        "sha": "db112e89b9e117af29ac391facee62e2e97d38ba",
        "filename": "src/strlcpy.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/strlcpy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/strlcpy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/strlcpy.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -68,7 +68,7 @@ inline size_t strlcat(char *dst, const char *src, size_t siz)\n \n     /* Find the end of dst and adjust bytes left but don't go past end */\n     while (n-- != 0 && *d != '\\0')\n-        d++;\n+        ++d;\n     dlen = d - dst;\n     n = siz - dlen;\n \n@@ -79,9 +79,9 @@ inline size_t strlcat(char *dst, const char *src, size_t siz)\n         if (n != 1)\n         {\n             *d++ = *s;\n-            n--;\n+            --n;\n         }\n-        s++;\n+        ++s;\n     }\n     *d = '\\0';\n "
      },
      {
        "sha": "d1c10aca5f07cf0a4515e38e0a9dc077775b95a3",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -157,7 +157,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     keystore.AddKey(key);\n \n     // 50 orphan transactions:\n-    for (int i = 0; i < 50; i++)\n+    for (int i = 0; i < 50; ++i)\n     {\n         CTransaction tx;\n         tx.vin.resize(1);\n@@ -174,7 +174,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     }\n \n     // ... and 50 that depend on other orphans:\n-    for (int i = 0; i < 50; i++)\n+    for (int i = 0; i < 50; ++i)\n     {\n         CTransaction txPrev = RandomOrphan();\n "
      },
      {
        "sha": "14b9e046f615af9421c3fad1d4815a71a503f4ad",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -67,7 +67,7 @@ const char *vstrOut[] = {\n \n BOOST_AUTO_TEST_CASE(base58_EncodeBase58)\n {\n-    for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n+    for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); ++i)\n     {\n         BOOST_CHECK_EQUAL(EncodeBase58(vstrIn[i].data, vstrIn[i].data + vstrIn[i].size), vstrOut[i]);\n     }\n@@ -76,7 +76,7 @@ BOOST_AUTO_TEST_CASE(base58_EncodeBase58)\n BOOST_AUTO_TEST_CASE(base58_DecodeBase58)\n {\n     std::vector<unsigned char> result;\n-    for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n+    for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); ++i)\n     {\n         std::vector<unsigned char> expected(vstrIn[i].data, vstrIn[i].data + vstrIn[i].size);\n         BOOST_CHECK(DecodeBase58(vstrOut[i], result));"
      },
      {
        "sha": "993c8d8514f9cef3105d65679fdf507ee34032ce",
        "filename": "src/test/base64_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/base64_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/base64_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base64_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -10,7 +10,7 @@ BOOST_AUTO_TEST_CASE(base64_testvectors)\n {\n     static const std::string vstrIn[]  = {\"\",\"f\",\"fo\",\"foo\",\"foob\",\"fooba\",\"foobar\"};\n     static const std::string vstrOut[] = {\"\",\"Zg==\",\"Zm8=\",\"Zm9v\",\"Zm9vYg==\",\"Zm9vYmE=\",\"Zm9vYmFy\"};\n-    for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n+    for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); ++i)\n     {\n         std::string strEnc = EncodeBase64(vstrIn[i]);\n         BOOST_CHECK(strEnc == vstrOut[i]);"
      },
      {
        "sha": "9c113a331449cc69495ee804d0bbc3da19da138b",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -27,7 +27,7 @@ void dumpKeyInfo(uint256 privkey)\n     memcpy(&sec[0], &secret[0], 32);\n     printf(\"  * secret (hex): %s\\n\", HexStr(sec).c_str());\n \n-    for (int nCompressed=0; nCompressed<2; nCompressed++)\n+    for (int nCompressed=0; nCompressed<2; ++nCompressed)\n     {\n         bool fCompressed = nCompressed == 1;\n         printf(\"  * %s:\\n\", fCompressed ? \"compressed\" : \"uncompressed\");\n@@ -79,7 +79,7 @@ BOOST_AUTO_TEST_CASE(key_test1)\n     BOOST_CHECK(CBitcoinAddress(key1C.GetPubKey()).ToString() == \"1NoJrossxPBKfCHuJXT4HadJrXRE9Fxiqs\");\n     BOOST_CHECK(CBitcoinAddress(key2C.GetPubKey()).ToString() == \"1CRj2HyM1CXWzHAXLQtiGLyggNT9WQqsDs\");\n \n-    for (int n=0; n<16; n++)\n+    for (int n=0; n<16; ++n)\n     {\n         string strMsg = strprintf(\"Very secret message %i: 11\", n);\n         uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());"
      },
      {
        "sha": "e2276a720f8231c948f8ebfc85d6a5b612cdf6ed",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -17,7 +17,7 @@ BOOST_AUTO_TEST_CASE(sha256transform_equality)\n \n     int i;\n \n-    for (i = 0; i < 32; i++) {\n+    for (i = 0; i < 32; ++i) {\n         pinput[i] = i;\n         pinput[i+32] = 0;\n     }"
      },
      {
        "sha": "be0108daa1891cb1c34c64b02f4220a0163903a5",
        "filename": "src/test/mruset_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/mruset_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/mruset_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mruset_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -32,7 +32,7 @@ BOOST_AUTO_TEST_SUITE(mruset_tests)\n BOOST_AUTO_TEST_CASE(mruset_like_set)\n {\n \n-    for (int nTest=0; nTest<NUM_TESTS; nTest++)\n+    for (int nTest=0; nTest<NUM_TESTS; ++nTest)\n     {\n         mrutester tester;\n         while (tester.size() < MAX_SIZE)\n@@ -44,10 +44,10 @@ BOOST_AUTO_TEST_CASE(mruset_like_set)\n // Test that an mruset's size never exceeds its max_size\n BOOST_AUTO_TEST_CASE(mruset_limited_size)\n {\n-    for (int nTest=0; nTest<NUM_TESTS; nTest++)\n+    for (int nTest=0; nTest<NUM_TESTS; ++nTest)\n     {\n         mruset<int> mru(MAX_SIZE);\n-        for (int nAction=0; nAction<3*MAX_SIZE; nAction++)\n+        for (int nAction=0; nAction<3*MAX_SIZE; ++nAction)\n         {\n             int n = GetRandInt(2 * MAX_SIZE);\n             mru.insert(n);\n@@ -64,7 +64,7 @@ int static permute(int n)\n                                   0xA409, 0x3822, 0x299F, 0x31D0, 0x082E, 0xFA98, 0xEC4E, 0x6C89};\n \n     int ret = 0;\n-    for (int bit=0; bit<16; bit++)\n+    for (int bit=0; bit<16; ++bit)\n          if (n & (1<<bit))\n              ret ^= table[bit];\n \n@@ -75,12 +75,12 @@ int static permute(int n)\n BOOST_AUTO_TEST_CASE(mruset_window)\n {\n     mruset<int> mru(MAX_SIZE);\n-    for (int n=0; n<10*MAX_SIZE; n++)\n+    for (int n=0; n<10*MAX_SIZE; ++n)\n     {\n         mru.insert(permute(n));\n \n         set<int> tester;\n-        for (int m=max(0,n-MAX_SIZE+1); m<=n; m++)\n+        for (int m=max(0,n-MAX_SIZE+1); m<=n; ++m)\n             tester.insert(permute(m));\n \n         BOOST_CHECK(mru == tester);"
      },
      {
        "sha": "4bf12184df71c1dcdf79890c9fbb5a6462c7a7d7",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -45,7 +45,7 @@ sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction,\n BOOST_AUTO_TEST_CASE(multisig_verify)\n {\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n         key[i].MakeNewKey(true);\n \n     CScript a_and_b;\n@@ -64,7 +64,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     txFrom.vout[2].scriptPubKey = escrow;\n \n     CTransaction txTo[3]; // Spending transaction\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n@@ -82,7 +82,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n     BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, true, 0));\n \n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         keys.clear();\n         keys += key[i];\n@@ -96,7 +96,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     }\n \n     // Test a OR b:\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         keys.clear();\n         keys += key[i];\n@@ -114,8 +114,8 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n \n \n-    for (int i = 0; i < 4; i++)\n-        for (int j = 0; j < 4; j++)\n+    for (int i = 0; i < 4; ++i)\n+        for (int j = 0; j < 4; ++j)\n         {\n             keys.clear();\n             keys += key[i],key[j];\n@@ -130,7 +130,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n {\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n         key[i].MakeNewKey(true);\n \n     CScript a_and_b;\n@@ -157,7 +157,7 @@ BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n     malformed[4] << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_CHECKMULTISIG;\n     malformed[5] << OP_1 << key[0].GetPubKey() << key[1].GetPubKey();\n \n-    for (int i = 0; i < 6; i++)\n+    for (int i = 0; i < 6; ++i)\n         BOOST_CHECK(!::IsStandard(malformed[i]));\n }\n \n@@ -176,7 +176,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     CBasicKeyStore keystore, emptykeystore, partialkeystore;\n     CKey key[3];\n     CBitcoinAddress keyaddr[3];\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n@@ -255,7 +255,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n     CBasicKeyStore keystore;\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n@@ -277,7 +277,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     txFrom.vout[2].scriptPubKey = escrow;\n \n     CTransaction txTo[3]; // Spending transaction\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n@@ -286,7 +286,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n         txTo[i].vout[0].nValue = 1;\n     }\n \n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n     }"
      },
      {
        "sha": "4493da034aeb6fa47ee93cfb074dca6a2e75babe",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -55,7 +55,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n     CBasicKeyStore keystore;\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n@@ -69,23 +69,23 @@ BOOST_AUTO_TEST_CASE(sign)\n     standardScripts[2] << key[1].GetPubKey() << OP_CHECKSIG;\n     standardScripts[3].SetBitcoinAddress(key[2].GetPubKey());\n     CScript evalScripts[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         keystore.AddCScript(standardScripts[i]);\n         evalScripts[i].SetPayToScriptHash(standardScripts[i]);\n     }\n \n     CTransaction txFrom;  // Funding transaction:\n     txFrom.vout.resize(8);\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         txFrom.vout[i].scriptPubKey = evalScripts[i];\n         txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n     }\n     BOOST_CHECK(txFrom.IsStandard());\n \n     CTransaction txTo[8]; // Spending transactions\n-    for (int i = 0; i < 8; i++)\n+    for (int i = 0; i < 8; ++i)\n     {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n@@ -94,14 +94,14 @@ BOOST_AUTO_TEST_CASE(sign)\n         txTo[i].vout[0].nValue = 1;\n         BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n     }\n-    for (int i = 0; i < 8; i++)\n+    for (int i = 0; i < 8; ++i)\n     {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n     }\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n-    for (int i = 0; i < 8; i++)\n-        for (int j = 0; j < 8; j++)\n+    for (int i = 0; i < 8; ++i)\n+        for (int j = 0; j < 8; ++j)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n@@ -146,7 +146,7 @@ BOOST_AUTO_TEST_CASE(set)\n     CBasicKeyStore keystore;\n     CKey key[4];\n     std::vector<CKey> keys;\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n@@ -160,22 +160,22 @@ BOOST_AUTO_TEST_CASE(set)\n     inner[3].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+3));\n \n     CScript outer[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         outer[i].SetPayToScriptHash(inner[i]);\n         keystore.AddCScript(inner[i]);\n     }\n \n     CTransaction txFrom;  // Funding transaction:\n     txFrom.vout.resize(4);\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         txFrom.vout[i].scriptPubKey = outer[i];\n     }\n     BOOST_CHECK(txFrom.IsStandard());\n \n     CTransaction txTo[4]; // Spending transactions\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         txTo[i].vin.resize(1);\n         txTo[i].vout.resize(1);\n@@ -185,7 +185,7 @@ BOOST_AUTO_TEST_CASE(set)\n         txTo[i].vout[0].scriptPubKey = inner[i];\n         BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n     }\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n         BOOST_CHECK_MESSAGE(txTo[i].IsStandard(), strprintf(\"txTo[%d].IsStandard\", i));\n@@ -247,7 +247,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     CBasicKeyStore keystore;\n     CKey key[3];\n     vector<CKey> keys;\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n@@ -275,7 +275,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[4].scriptPubKey << OP_HASH160 << Hash160(empty) << OP_EQUAL;\n     CScript oneOfEleven;\n     oneOfEleven << OP_1;\n-    for (int i = 0; i < 11; i++)\n+    for (int i = 0; i < 11; ++i)\n         oneOfEleven << key[0].GetPubKey();\n     oneOfEleven << OP_11 << OP_CHECKMULTISIG;\n     txFrom.vout[5].scriptPubKey.SetPayToScriptHash(oneOfEleven);\n@@ -301,7 +301,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     BOOST_CHECK_EQUAL(txTo.GetP2SHSigOpCount(mapInputs), 1);\n \n     // Make sure adding crap to the scriptSigs makes them non-standard:\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         CScript t = txTo.vin[i].scriptSig;\n         txTo.vin[i].scriptSig = (CScript() << 11) + t;"
      },
      {
        "sha": "f3e566be7c633c185db2081277170cf8ca59e3d2",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -31,7 +31,7 @@ ParseScript(string s)\n \n     if (mapOpNames.size() == 0)\n     {\n-        for (int op = OP_NOP; op <= OP_NOP10; op++)\n+        for (int op = OP_NOP; op <= OP_NOP10; ++op)\n         {\n             const char* name = GetOpName((opcodetype)op);\n             if (strcmp(name, \"OP_UNKNOWN\") == 0)"
      },
      {
        "sha": "10dcdfa463bc4b54c0268dfc0e7ea28935610cdc",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -38,7 +38,7 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n     BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig), 3);\n \n     std::vector<CKey> keys;\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 3; ++i)\n     {\n         CKey k;\n         k.MakeNewKey(true);"
      },
      {
        "sha": "ca6fb785ad0ad87dfcd93c91f84889c62598255f",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -36,7 +36,7 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, MapPrevTx& inputsRet)\n \n     // Add some keys to the keystore:\n     CKey key[4];\n-    for (int i = 0; i < 4; i++)\n+    for (int i = 0; i < 4; ++i)\n     {\n         key[i].MakeNewKey(i % 2);\n         keystoreRet.AddKey(key[i]);"
      },
      {
        "sha": "7e40f4ce9b5dd00f9dca13afa7ab0f8bdf81bd68",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 55,
        "deletions": 55,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -32,7 +32,7 @@ class base_uint\n \n     bool operator!() const\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             if (pn[i] != 0)\n                 return false;\n         return true;\n@@ -41,17 +41,17 @@ class base_uint\n     const base_uint operator~() const\n     {\n         base_uint ret;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             ret.pn[i] = ~pn[i];\n         return ret;\n     }\n \n     const base_uint operator-() const\n     {\n         base_uint ret;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             ret.pn[i] = ~pn[i];\n-        ret++;\n+        ++ret;\n         return ret;\n     }\n \n@@ -60,28 +60,28 @@ class base_uint\n     {\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n         return *this;\n     }\n \n     base_uint& operator^=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] ^= b.pn[i];\n         return *this;\n     }\n \n     base_uint& operator&=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] &= b.pn[i];\n         return *this;\n     }\n \n     base_uint& operator|=(const base_uint& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] |= b.pn[i];\n         return *this;\n     }\n@@ -103,11 +103,11 @@ class base_uint\n     base_uint& operator<<=(unsigned int shift)\n     {\n         base_uint a(*this);\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = 0;\n         int k = shift / 32;\n         shift = shift % 32;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n         {\n             if (i+k+1 < WIDTH && shift != 0)\n                 pn[i+k+1] |= (a.pn[i] >> (32-shift));\n@@ -120,11 +120,11 @@ class base_uint\n     base_uint& operator>>=(unsigned int shift)\n     {\n         base_uint a(*this);\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = 0;\n         int k = shift / 32;\n         shift = shift % 32;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n         {\n             if (i-k-1 >= 0 && shift != 0)\n                 pn[i-k-1] |= (a.pn[i] << (32-shift));\n@@ -137,7 +137,7 @@ class base_uint\n     base_uint& operator+=(const base_uint& b)\n     {\n         uint64 carry = 0;\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n         {\n             uint64 n = carry + pn[i] + b.pn[i];\n             pn[i] = n & 0xffffffff;\n@@ -174,7 +174,7 @@ class base_uint\n         // prefix operator\n         int i = 0;\n         while (++pn[i] == 0 && i < WIDTH-1)\n-            i++;\n+            ++i;\n         return *this;\n     }\n \n@@ -191,7 +191,7 @@ class base_uint\n         // prefix operator\n         int i = 0;\n         while (--pn[i] == -1 && i < WIDTH-1)\n-            i++;\n+            ++i;\n         return *this;\n     }\n \n@@ -206,7 +206,7 @@ class base_uint\n \n     friend inline bool operator<(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n+        for (int i = base_uint::WIDTH-1; i >= 0; --i)\n         {\n             if (a.pn[i] < b.pn[i])\n                 return true;\n@@ -218,7 +218,7 @@ class base_uint\n \n     friend inline bool operator<=(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n+        for (int i = base_uint::WIDTH-1; i >= 0; --i)\n         {\n             if (a.pn[i] < b.pn[i])\n                 return true;\n@@ -230,7 +230,7 @@ class base_uint\n \n     friend inline bool operator>(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n+        for (int i = base_uint::WIDTH-1; i >= 0; --i)\n         {\n             if (a.pn[i] > b.pn[i])\n                 return true;\n@@ -242,7 +242,7 @@ class base_uint\n \n     friend inline bool operator>=(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--)\n+        for (int i = base_uint::WIDTH-1; i >= 0; --i)\n         {\n             if (a.pn[i] > b.pn[i])\n                 return true;\n@@ -254,7 +254,7 @@ class base_uint\n \n     friend inline bool operator==(const base_uint& a, const base_uint& b)\n     {\n-        for (int i = 0; i < base_uint::WIDTH; i++)\n+        for (int i = 0; i < base_uint::WIDTH; ++i)\n             if (a.pn[i] != b.pn[i])\n                 return false;\n         return true;\n@@ -266,7 +266,7 @@ class base_uint\n             return false;\n         if (a.pn[1] != (unsigned int)(b >> 32))\n             return false;\n-        for (int i = 2; i < base_uint::WIDTH; i++)\n+        for (int i = 2; i < base_uint::WIDTH; ++i)\n             if (a.pn[i] != 0)\n                 return false;\n         return true;\n@@ -287,19 +287,19 @@ class base_uint\n     std::string GetHex() const\n     {\n         char psz[sizeof(pn)*2 + 1];\n-        for (unsigned int i = 0; i < sizeof(pn); i++)\n+        for (unsigned int i = 0; i < sizeof(pn); ++i)\n             sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n         return std::string(psz, psz + sizeof(pn)*2);\n     }\n \n     void SetHex(const char* psz)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = 0;\n \n         // skip leading spaces\n         while (isspace(*psz))\n-            psz++;\n+            ++psz;\n \n         // skip 0x\n         if (psz[0] == '0' && tolower(psz[1]) == 'x')\n@@ -309,8 +309,8 @@ class base_uint\n         static unsigned char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n         const char* pbegin = psz;\n         while (phexdigit[(unsigned char)*psz] || *psz == '0')\n-            psz++;\n-        psz--;\n+            ++psz;\n+        --psz;\n         unsigned char* p1 = (unsigned char*)pn;\n         unsigned char* pend = p1 + WIDTH * 4;\n         while (psz >= pbegin && p1 < pend)\n@@ -319,7 +319,7 @@ class base_uint\n             if (psz >= pbegin)\n             {\n                 *p1 |= (phexdigit[(unsigned char)*psz--] << 4);\n-                p1++;\n+                ++p1;\n             }\n         }\n     }\n@@ -405,19 +405,19 @@ class uint160 : public base_uint160\n \n     uint160()\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = 0;\n     }\n \n     uint160(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = b.pn[i];\n     }\n \n     uint160& operator=(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = b.pn[i];\n         return *this;\n     }\n@@ -426,15 +426,15 @@ class uint160 : public base_uint160\n     {\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n     }\n \n     uint160& operator=(uint64 b)\n     {\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n         return *this;\n     }\n@@ -520,19 +520,19 @@ class uint256 : public base_uint256\n \n     uint256()\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = 0;\n     }\n \n     uint256(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = b.pn[i];\n     }\n \n     uint256& operator=(const basetype& b)\n     {\n-        for (int i = 0; i < WIDTH; i++)\n+        for (int i = 0; i < WIDTH; ++i)\n             pn[i] = b.pn[i];\n         return *this;\n     }\n@@ -541,15 +541,15 @@ class uint256 : public base_uint256\n     {\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n     }\n \n     uint256& operator=(uint64 b)\n     {\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n-        for (int i = 2; i < WIDTH; i++)\n+        for (int i = 2; i < WIDTH; ++i)\n             pn[i] = 0;\n         return *this;\n     }\n@@ -634,17 +634,17 @@ inline int Testuint256AdHoc(std::vector<std::string> vArg)\n \n \n     printf(\"%s\\n\", g.ToString().c_str());\n-    g--;  printf(\"g--\\n\");\n+    --g;  printf(\"--g\\n\");\n     printf(\"%s\\n\", g.ToString().c_str());\n-    g--;  printf(\"g--\\n\");\n+    --g;  printf(\"--g\\n\");\n     printf(\"%s\\n\", g.ToString().c_str());\n-    g++;  printf(\"g++\\n\");\n+    ++g;  printf(\"++g\\n\");\n     printf(\"%s\\n\", g.ToString().c_str());\n-    g++;  printf(\"g++\\n\");\n+    ++g;  printf(\"++g\\n\");\n     printf(\"%s\\n\", g.ToString().c_str());\n-    g++;  printf(\"g++\\n\");\n+    ++g;  printf(\"++g\\n\");\n     printf(\"%s\\n\", g.ToString().c_str());\n-    g++;  printf(\"g++\\n\");\n+    ++g;  printf(\"++g\\n\");\n     printf(\"%s\\n\", g.ToString().c_str());\n \n \n@@ -685,33 +685,33 @@ inline int Testuint256AdHoc(std::vector<std::string> vArg)\n     a.pn[4] = 9;\n \n     printf(\"%s\\n\", a.ToString().c_str());\n-    a++;\n+    ++a;\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a++;\n+    ++a;\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a++;\n+    ++a;\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a++;\n+    ++a;\n     printf(\"%s\\n\", a.ToString().c_str());\n \n-    a--;\n+    --a;\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a--;\n+    --a;\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a--;\n+    --a;\n     printf(\"%s\\n\", a.ToString().c_str());\n     uint256 d = a--;\n     printf(\"%s\\n\", d.ToString().c_str());\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a--;\n+    --a;\n     printf(\"%s\\n\", a.ToString().c_str());\n-    a--;\n+    --a;\n     printf(\"%s\\n\", a.ToString().c_str());\n \n     d = a;\n \n     printf(\"%s\\n\", d.ToString().c_str());\n-    for (int i = uint256::WIDTH-1; i >= 0; i--) printf(\"%08x\", d.pn[i]); printf(\"\\n\");\n+    for (int i = uint256::WIDTH-1; i >= 0; --i) printf(\"%08x\", d.pn[i]); printf(\"\\n\");\n \n     uint256 neg = d;\n     neg = ~neg;\n@@ -743,13 +743,13 @@ inline int Testuint256AdHoc(std::vector<std::string> vArg)\n     }\n \n \n-    for (int i = 0; i < 100; i++)\n+    for (int i = 0; i < 100; ++i)\n     {\n         uint256 k = (~uint256(0) >> i);\n         printf(\"%s\\n\", k.ToString().c_str());\n     }\n \n-    for (int i = 0; i < 100; i++)\n+    for (int i = 0; i < 100; ++i)\n     {\n         uint256 k = (~uint256(0) << i);\n         printf(\"%s\\n\", k.ToString().c_str());"
      },
      {
        "sha": "93d000405c7b0542249a1cce5c754375c6711181",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -89,7 +89,7 @@ class CInit\n     {\n         // Init openssl library multithreading support\n         ppmutexOpenSSL = (boost::interprocess::interprocess_mutex**)OPENSSL_malloc(CRYPTO_num_locks() * sizeof(boost::interprocess::interprocess_mutex*));\n-        for (int i = 0; i < CRYPTO_num_locks(); i++)\n+        for (int i = 0; i < CRYPTO_num_locks(); ++i)\n             ppmutexOpenSSL[i] = new boost::interprocess::interprocess_mutex();\n         CRYPTO_set_locking_callback(locking_callback);\n \n@@ -105,7 +105,7 @@ class CInit\n     {\n         // Shutdown openssl library multithreading support\n         CRYPTO_set_locking_callback(NULL);\n-        for (int i = 0; i < CRYPTO_num_locks(); i++)\n+        for (int i = 0; i < CRYPTO_num_locks(); ++i)\n             delete ppmutexOpenSSL[i];\n         OPENSSL_free(ppmutexOpenSSL);\n     }\n@@ -254,7 +254,7 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n             char* p2;\n             while (p2 = strchr(p1, '\\n'))\n             {\n-                p2++;\n+                ++p2;\n                 char c = *p2;\n                 *p2 = '\\0';\n                 OutputDebugStringA(p1);\n@@ -390,12 +390,12 @@ bool ParseMoney(const char* pszIn, int64& nRet)\n     int64 nUnits = 0;\n     const char* p = pszIn;\n     while (isspace(*p))\n-        p++;\n-    for (; *p; p++)\n+        ++p;\n+    for (; *p; ++p)\n     {\n         if (*p == '.')\n         {\n-            p++;\n+            ++p;\n             int64 nMult = CENT*10;\n             while (isdigit(*p) && (nMult > 0))\n             {\n@@ -410,7 +410,7 @@ bool ParseMoney(const char* pszIn, int64& nRet)\n             return false;\n         strWhole.insert(strWhole.end(), *p);\n     }\n-    for (; *p; p++)\n+    for (; *p; ++p)\n         if (!isspace(*p))\n             return false;\n     if (strWhole.size() > 10) // guard against 63 bit overflow\n@@ -460,7 +460,7 @@ vector<unsigned char> ParseHex(const char* psz)\n     loop\n     {\n         while (isspace(*psz))\n-            psz++;\n+            ++psz;\n         signed char c = phexdigit[(unsigned char)*psz++];\n         if (c == (signed char)-1)\n             break;\n@@ -498,7 +498,7 @@ void ParseParameters(int argc, const char*const argv[])\n {\n     mapArgs.clear();\n     mapMultiArgs.clear();\n-    for (int i = 1; i < argc; i++)\n+    for (int i = 1; i < argc; ++i)\n     {\n         char psz[10000];\n         strlcpy(psz, argv[i], sizeof(psz));\n@@ -664,7 +664,7 @@ vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n     {\n          int dec = decode64_table[(unsigned char)*p];\n          if (dec == -1) break;\n-         p++;\n+         ++p;\n          switch (mode)\n          {\n              case 0: // we have no bits and get 6\n@@ -741,8 +741,8 @@ bool WildcardMatch(const char* psz, const char* mask)\n                 return false;\n             break;\n         }\n-        psz++;\n-        mask++;\n+        ++psz;\n+        ++mask;\n     }\n }\n "
      },
      {
        "sha": "601c603e3b9b515ee737227f60c4e3b86b6f07b0",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -621,7 +621,7 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n             LOCK(pwallet->cs_wallet);\n             map<uint256, const CMerkleTx*> mapWalletPrev;\n             set<uint256> setAlreadyDone;\n-            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+            for (unsigned int i = 0; i < vWorkQueue.size(); ++i)\n             {\n                 uint256 hash = vWorkQueue[i];\n                 if (setAlreadyDone.count(hash))\n@@ -687,7 +687,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n             BOOST_FOREACH(CTransaction& tx, block.vtx)\n             {\n                 if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n-                    ret++;\n+                    ++ret;\n             }\n             pindex = pindex->pnext;\n         }\n@@ -729,7 +729,7 @@ void CWallet::ReacceptWalletTransactions()\n                     printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %d != wtx.vout.size() %d\\n\", txindex.vSpent.size(), wtx.vout.size());\n                     continue;\n                 }\n-                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n+                for (unsigned int i = 0; i < txindex.vSpent.size(); ++i)\n                 {\n                     if (wtx.IsSpent(i))\n                         continue;\n@@ -908,7 +908,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n             if (nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n                 continue;\n \n-            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n+            for (unsigned int i = 0; i < pcoin->vout.size(); ++i)\n             {\n                 if (pcoin->IsSpent(i) || !IsMine(pcoin->vout[i]))\n                     continue;\n@@ -967,14 +967,14 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n     vector<char> vfBest(vValue.size(), true);\n     int64 nBest = nTotalLower;\n \n-    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)\n+    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; ++nRep)\n     {\n         vfIncluded.assign(vValue.size(), false);\n         int64 nTotal = 0;\n         bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; ++nPass)\n         {\n-            for (unsigned int i = 0; i < vValue.size(); i++)\n+            for (unsigned int i = 0; i < vValue.size(); ++i)\n             {\n                 if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                 {\n@@ -1003,7 +1003,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n         nValueRet += coinLowestLarger.first;\n     }\n     else {\n-        for (unsigned int i = 0; i < vValue.size(); i++)\n+        for (unsigned int i = 0; i < vValue.size(); ++i)\n             if (vfBest[i])\n             {\n                 setCoinsRet.insert(vValue[i].second);\n@@ -1012,7 +1012,7 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n \n         //// debug print\n         printf(\"SelectCoins() best subset: \");\n-        for (unsigned int i = 0; i < vValue.size(); i++)\n+        for (unsigned int i = 0; i < vValue.size(); ++i)\n             if (vfBest[i])\n                 printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n         printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n@@ -1118,7 +1118,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CW\n                 // Sign\n                 int nIn = 0;\n                 BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n-                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n+                    if (!SignSignature(*this, *coin.first, wtxNew, ++nIn))\n                         return false;\n \n                 // Limit size\n@@ -1369,7 +1369,7 @@ bool CWallet::NewKeyPool()\n             return false;\n \n         int64 nKeys = max(GetArg(\"-keypool\", 100), (int64)0);\n-        for (int i = 0; i < nKeys; i++)\n+        for (int i = 0; i < nKeys; ++i)\n         {\n             int64 nIndex = i+1;\n             walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));"
      },
      {
        "sha": "0aba1895041b280109f586b746a48d34af6e74ed",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -249,7 +249,7 @@ class CWallet : public CCryptoKeyStore\n             LOCK(cs_wallet);\n             std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n             if (mi != mapRequestCount.end())\n-                (*mi).second++;\n+                ++(*mi).second;\n         }\n     }\n \n@@ -418,7 +418,7 @@ class CWalletTx : public CMerkleTx\n     bool UpdateSpent(const std::vector<char>& vfNewSpent)\n     {\n         bool fReturn = false;\n-        for (unsigned int i = 0; i < vfNewSpent.size(); i++)\n+        for (unsigned int i = 0; i < vfNewSpent.size(); ++i)\n         {\n             if (i == vfSpent.size())\n                 break;\n@@ -504,7 +504,7 @@ class CWalletTx : public CMerkleTx\n             return nAvailableCreditCached;\n \n         int64 nCredit = 0;\n-        for (unsigned int i = 0; i < vout.size(); i++)\n+        for (unsigned int i = 0; i < vout.size(); ++i)\n         {\n             if (!IsSpent(i))\n             {\n@@ -557,7 +557,7 @@ class CWalletTx : public CMerkleTx\n         std::vector<const CMerkleTx*> vWorkQueue;\n         vWorkQueue.reserve(vtxPrev.size()+1);\n         vWorkQueue.push_back(this);\n-        for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+        for (unsigned int i = 0; i < vWorkQueue.size(); ++i)\n         {\n             const CMerkleTx* ptx = vWorkQueue[i];\n "
      },
      {
        "sha": "592318ce88d2b6bdd15a7ea8c1b9ac3505c2d51f",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -23,15 +23,15 @@ extern void CloseDb(const string& strFile);\n \n bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n {\n-    nWalletDBUpdated++;\n+    ++nWalletDBUpdated;\n     return Write(make_pair(string(\"name\"), strAddress), strName);\n }\n \n bool CWalletDB::EraseName(const string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n-    nWalletDBUpdated++;\n+    ++nWalletDBUpdated;\n     return Erase(make_pair(string(\"name\"), strAddress));\n }\n \n@@ -359,7 +359,7 @@ void ThreadFlushWalletDB(void* parg)\n                 while (mi != mapFileUseCount.end())\n                 {\n                     nRefCount += (*mi).second;\n-                    mi++;\n+                    ++mi;\n                 }\n \n                 if (nRefCount == 0 && !fShutdown)"
      },
      {
        "sha": "6113f7d2a1c8969863945201229a10d36942d46b",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/352310ebdca7e35c59c346d1de49e91c4fa05d2a/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=352310ebdca7e35c59c346d1de49e91c4fa05d2a",
        "patch": "@@ -49,13 +49,13 @@ class CWalletDB : public CDB\n \n     bool WriteTx(uint256 hash, const CWalletTx& wtx)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n     }\n \n     bool EraseTx(uint256 hash)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Erase(std::make_pair(std::string(\"tx\"), hash));\n     }\n \n@@ -67,13 +67,13 @@ class CWalletDB : public CDB\n \n     bool WriteKey(const std::vector<unsigned char>& vchPubKey, const CPrivKey& vchPrivKey)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::make_pair(std::string(\"key\"), vchPubKey), vchPrivKey, false);\n     }\n \n     bool WriteCryptedKey(const std::vector<unsigned char>& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, bool fEraseUnencryptedKey = true)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false))\n             return false;\n         if (fEraseUnencryptedKey)\n@@ -86,7 +86,7 @@ class CWalletDB : public CDB\n \n     bool WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n     }\n \n@@ -99,13 +99,13 @@ class CWalletDB : public CDB\n \n     bool WriteCScript(const uint160& hash, const CScript& redeemScript)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n     }\n \n     bool WriteBestBlock(const CBlockLocator& locator)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::string(\"bestblock\"), locator);\n     }\n \n@@ -122,7 +122,7 @@ class CWalletDB : public CDB\n \n     bool WriteDefaultKey(const std::vector<unsigned char>& vchPubKey)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::string(\"defaultkey\"), vchPubKey);\n     }\n \n@@ -133,13 +133,13 @@ class CWalletDB : public CDB\n \n     bool WritePool(int64 nPool, const CKeyPool& keypool)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n     }\n \n     bool ErasePool(int64 nPool)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Erase(std::make_pair(std::string(\"pool\"), nPool));\n     }\n \n@@ -153,12 +153,12 @@ class CWalletDB : public CDB\n     template<typename T>\n     bool WriteSetting(const std::string& strKey, const T& value)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n     }\n     bool EraseSetting(const std::string& strKey)\n     {\n-        nWalletDBUpdated++;\n+        ++nWalletDBUpdated;\n         return Erase(std::make_pair(std::string(\"setting\"), strKey));\n     }\n "
      }
    ]
  }
]