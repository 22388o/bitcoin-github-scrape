[
  {
    "sha": "9668666b27a9e828c6593cf51b0a1e50a819e08c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjY4NjY2YjI3YTllODI4YzY1OTNjZjUxYjBhMWU1MGE4MTllMDhj",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-03-29T18:26:09Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:07Z"
      },
      "message": "Implement a thread-safe FIFO (producer/consumer style) queue",
      "tree": {
        "sha": "79c2ba4a3aafcfb49c5c457ae032e27cfd7b1d6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79c2ba4a3aafcfb49c5c457ae032e27cfd7b1d6f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX9cACgkQg1TZSXEC\nj8ZNtg/+ICcF7GYBLT7CvFRbj1oRZigHa+lP/pxXN5g0T7ysWkBjylFpBzZIs9uB\n7Vkpago+Zpa2l1JEhHBxWhSAeT9CgZsaMf0826kw2QXu+ADrMjZFefWUpzb6ygW+\nMC2Gzb9OxKfPBN6oKy2VdlKbCHdgfxWgQcOT6j4iMACId+r0r80PUq9D6SzvFtnc\nRB5kYhyd2Vz0PWOeq/qnFZmDWGY42Bw18Z6mhVbI9Cj3xPHGa6C3GpShYs8Ponnx\nLfvlTN3S6+aMqtHbq/UaCIh9k/X181uhReR1j/mBlqlvkISstkAVpifjl0sqwAfV\nDBVsYe4RdDQF6XSFEn0evK8KfSD4tXOgOhHGuRI9xlrGiNMBOxZz+c8Zpz6it37E\nRlysUqmx/8LYc19rGfcQAnTZY/NmhAvIv6t0DmuJ7vg/HRprg2V3IREk+8+dDtiL\nycIpjxfuXXgxYQSw6xC0ugaEdx8Ve0F70VZ7ABWz5EidqS8VLLj87X8ipTF+9Jby\nI9xuAyBoNSt8GcrqOk3A6qmPTrVXmwTPymKPT/oWzfl6LAsv0qxLsjNKqEZx9/fR\nOhukR7xsLxnxxBADiE0aOF2uB9U9bVxCXRVyWtPc6v888YZWhyCMQZxXTwI0uCD8\n9KSFzGiaeR9GALM7sANGvO9TPM/cBnjWx3+8z7oIGd7FCgSLhuM=\n=PmJm\n-----END PGP SIGNATURE-----",
        "payload": "tree 79c2ba4a3aafcfb49c5c457ae032e27cfd7b1d6f\nparent 3f398d7a17f136cd4a67998406ca41a124ae2966\nauthor Jesse Cohen <jc@jc.lol> 1522347969 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438167 -0400\n\nImplement a thread-safe FIFO (producer/consumer style) queue\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9668666b27a9e828c6593cf51b0a1e50a819e08c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9668666b27a9e828c6593cf51b0a1e50a819e08c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9668666b27a9e828c6593cf51b0a1e50a819e08c/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3f398d7a17f136cd4a67998406ca41a124ae2966",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f398d7a17f136cd4a67998406ca41a124ae2966",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3f398d7a17f136cd4a67998406ca41a124ae2966"
      }
    ],
    "stats": {
      "total": 157,
      "additions": 157,
      "deletions": 0
    },
    "files": [
      {
        "sha": "291801e52552af3414ef8f97d5526969ca4a95c4",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9668666b27a9e828c6593cf51b0a1e50a819e08c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9668666b27a9e828c6593cf51b0a1e50a819e08c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9668666b27a9e828c6593cf51b0a1e50a819e08c",
        "patch": "@@ -140,6 +140,7 @@ BITCOIN_CORE_H = \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n+  core/producerconsumerqueue.h \\\n   protocol.h \\\n   random.h \\\n   reverse_iterator.h \\"
      },
      {
        "sha": "534b5145f6aa265072d3624bcec2d267ee5d936c",
        "filename": "src/core/producerconsumerqueue.h",
        "status": "added",
        "additions": 156,
        "deletions": 0,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9668666b27a9e828c6593cf51b0a1e50a819e08c/src/core/producerconsumerqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9668666b27a9e828c6593cf51b0a1e50a819e08c/src/core/producerconsumerqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/producerconsumerqueue.h?ref=9668666b27a9e828c6593cf51b0a1e50a819e08c",
        "patch": "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");\n+\n+        T ret;\n+\n+        // use a temporary so theres no side effecting code inside an assert which could be disabled\n+        bool success = Pop(ret);\n+        assert(success);\n+\n+        return ret;\n+    }\n+\n+    typename std::deque<T>::size_type size()\n+    {\n+        std::unique_lock<std::mutex> l(m_queue_lock);\n+        return m_data.size();\n+    }\n+    unsigned int GetCapacity() const { return m_capacity; }\n+    static constexpr WorkerMode GetProducerMode() { return m_producer_mode; }\n+    static constexpr WorkerMode GetConsumerMode() { return m_consumer_mode; }\n+\n+private:\n+    unsigned int m_capacity; //!< maximum capacity the queue can hold above which pushes will block or fail\n+    std::deque<T> m_data;    //!< the data currently in the queue\n+\n+    std::mutex m_queue_lock;          //!< synchronizes access to m_data\n+    CConditionVariable m_consumer_cv; //!< consumers waiting for m_data to become non-empty\n+    CConditionVariable m_producer_cv; //!< producers waiting for available space in m_data\n+};\n+\n+template <typename T, WorkerMode consumer_mode>\n+using BlockingConsumerQueue = ProducerConsumerQueue<T, WorkerMode::BLOCKING, consumer_mode>;\n+\n+#endif // BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H"
      }
    ]
  },
  {
    "sha": "52ac3b5469e514f9288683bcb944e58c02606346",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MmFjM2I1NDY5ZTUxNGY5Mjg4NjgzYmNiOTQ0ZTU4YzAyNjA2MzQ2",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-03-29T18:45:14Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:08Z"
      },
      "message": "Unit tests for ProducerConsumerQueue",
      "tree": {
        "sha": "49a7d02ca08d91721d6bd826ef345ecc7c86d406",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49a7d02ca08d91721d6bd826ef345ecc7c86d406"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52ac3b5469e514f9288683bcb944e58c02606346",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX9gACgkQg1TZSXEC\nj8auzBAAi22rAuy1bJumpfkvrrzEKocWTJYlqw4UG10Wq/nk+D9QZyD6ImQtEOxW\nXdE4/Hi9Ximlqr7CfNbV7CbkdLmxJcAmRT4cnVehOcJCd33oTWnPfOJjkza/TboV\nTjN8tBLqP3K+gUL4Qk9qK3IWJsC+fA2gMVjw4foqSiOb4+qFVa0PPyt+64S/EGuo\nHXNl6pcYH/bZJx1cAPXUTYQz3bwi6daMs9v4jcXwsXPgXbdvUlBLhGisiGDirr0j\nhNvLZK/OwtfpLR1k+Pb5MB5RKRvdeFV1aOE/116LjNQUv+tIf1Ta7NZzoUHdHHlD\nxs2gptQrdKlEURI+L2/sOIXpF7gJx34wACZuuElhePo375v5D4lsfsMZ9ZI9wyst\ngk9c1Cm9bgLRwrjtM+GBU2Lps34+YapMmVKGWq319wCUE5z/Cp+tcR/3bXnjc1wt\nW3wkyVSFvRt39Z0Zt0Y3AgFUPLzm6ZNWnY6TuE/wVf9XJbOnCBgMT+3PaovxTncO\nR7CJR51K/BTUx7EJ+ZmvkDeC62mpbNGdPen5YewRZTOlEbtD5HgnQRwhxw2BGD31\nzsNoYOHaOs9cipIGZH4Af0imOjU8PlUH/lc8yTadxgLvwNrtem+6HwDjgi4ds69F\n5Sap1dSVcL/co9DUIaJPX8qBhnsy8Ly/GK+XAfyz72U/3+jsa6M=\n=+9AA\n-----END PGP SIGNATURE-----",
        "payload": "tree 49a7d02ca08d91721d6bd826ef345ecc7c86d406\nparent 9668666b27a9e828c6593cf51b0a1e50a819e08c\nauthor Jesse Cohen <jc@jc.lol> 1522349114 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438168 -0400\n\nUnit tests for ProducerConsumerQueue\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52ac3b5469e514f9288683bcb944e58c02606346",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/52ac3b5469e514f9288683bcb944e58c02606346",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52ac3b5469e514f9288683bcb944e58c02606346/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9668666b27a9e828c6593cf51b0a1e50a819e08c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9668666b27a9e828c6593cf51b0a1e50a819e08c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9668666b27a9e828c6593cf51b0a1e50a819e08c"
      }
    ],
    "stats": {
      "total": 179,
      "additions": 179,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7723bcb7428271e1e797dde15c5cbb6f9ce5ebdd",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52ac3b5469e514f9288683bcb944e58c02606346/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52ac3b5469e514f9288683bcb944e58c02606346/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=52ac3b5469e514f9288683bcb944e58c02606346",
        "patch": "@@ -65,6 +65,7 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/prevector_tests.cpp \\\n+  test/producerconsumerqueue_tests.cpp \\\n   test/raii_event_tests.cpp \\\n   test/random_tests.cpp \\\n   test/reverselock_tests.cpp \\"
      },
      {
        "sha": "9fa49654360e592a4a85e7e3bd75bffe72ac6997",
        "filename": "src/test/producerconsumerqueue_tests.cpp",
        "status": "added",
        "additions": 178,
        "deletions": 0,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52ac3b5469e514f9288683bcb944e58c02606346/src/test/producerconsumerqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52ac3b5469e514f9288683bcb944e58c02606346/src/test/producerconsumerqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/producerconsumerqueue_tests.cpp?ref=52ac3b5469e514f9288683bcb944e58c02606346",
        "patch": "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;\n+    for (int i = 0; i < n_producers; i++)\n+        pull.push_back(new Q(bucket_size));\n+\n+    boost::thread_group test_threads;\n+\n+    for (int i = 0; i < n_producers; i++) {\n+        test_threads.create_thread([&, i] { Producer(push, *(pull[i]), i, bucket_size); });\n+    }\n+\n+    for (int i = 0; i < n_consumers; i++) {\n+        test_threads.create_thread([&, i] { Consumer(push, pull, i, n_producers, bucket_size, n_elements / n_consumers); });\n+    }\n+\n+    test_threads.join_all();\n+\n+    // queue should be empty\n+    BOOST_CHECK_EQUAL(push.size(), 0);\n+    for (int i = 0; i < n_producers; i++) {\n+        BOOST_CHECK_EQUAL(pull[i]->size(), 0);\n+        delete pull[i];\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(invalid_queue, Q, queue_types)\n+{\n+    Q q;\n+    BOOST_CHECK(q.GetCapacity() == 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(basic_operation)\n+{\n+    int n = 10;\n+    QueueBB qBB(n);\n+    QueueBN qBN(n);\n+    QueueNB qNB(n);\n+    QueueNN qNN(n);\n+\n+    BOOST_CHECK((int)qBB.GetCapacity() == n);\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK(qBB.Push(i));\n+        BOOST_CHECK(qBN.Push(i));\n+        BOOST_CHECK(qNB.Push(i));\n+        BOOST_CHECK(qNN.Push(i));\n+    }\n+\n+    BOOST_CHECK(!qNB.Push(0));\n+    BOOST_CHECK(!qNN.Push(0));\n+\n+    int t;\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK_EQUAL(qBB.Pop(), i);\n+\n+        BOOST_CHECK(qBN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+\n+        BOOST_CHECK_EQUAL(qNB.Pop(), i);\n+\n+        BOOST_CHECK(qNN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+    }\n+\n+    int ret;\n+    BOOST_CHECK(!qBN.Pop(ret));\n+    BOOST_CHECK(!qNN.Pop(ret));\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(multithreaded_operation, Q, queue_types)\n+{\n+    QueueTest<Q>(1000, 100, 1, 1);\n+    QueueTest<Q>(100, 1000, 1, 1);\n+\n+    QueueTest<Q>(1000, 100, 1, 10);\n+    QueueTest<Q>(100, 1000, 1, 10);\n+\n+    QueueTest<Q>(1000, 100, 10, 1);\n+    QueueTest<Q>(100, 1000, 10, 1);\n+\n+    QueueTest<Q>(1000, 100, 10, 10);\n+    QueueTest<Q>(100, 1000, 10, 10);\n+\n+    QueueTest<Q>(1000, 100, 10, 5);\n+    QueueTest<Q>(100, 1000, 10, 5);\n+\n+    QueueTest<Q>(1000, 100, 5, 10);\n+    QueueTest<Q>(100, 1000, 5, 10);\n+};\n+\n+BOOST_AUTO_TEST_SUITE_END();"
      }
    ]
  },
  {
    "sha": "6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YzYyNDIzMmE3MWNmYjNiN2I0ZGUwNTQwYjgzZDViMGRkMDhjN2Q3",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-03T15:45:38Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:09Z"
      },
      "message": "Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue",
      "tree": {
        "sha": "7398ed0ba0cf4dfb8ef2433cc6a990f3cfa800f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7398ed0ba0cf4dfb8ef2433cc6a990f3cfa800f9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX9kACgkQg1TZSXEC\nj8YaWw//ZTrPPHsTZ7fZpjREmErzzIgN37vh+xqyzKHmUZjXDqUXFnvUdLc5T5X/\nAT40Xx4M0GmSSEL8VHFz4rnJq9ycowGqNlrSWdBkWdLqRXPWrI+0zLYgOAb3c0t8\nAki1BKayT7IZsDuVGwZBVFZXVu5QupBXWLdOyvaKOcRDY/NeuEWa+KyI1JatyfHk\n28TEbUG6VhswKor/3cVe2dJ3cAG//tGgLoykwMp1bCgUCvt53J0dEXmXezIvMTPt\n+4I4RZPnziEHB50J1nk1Pw+Trw8mgHSRhVUyF0nqQdQIp8HxOmCN5chyEse77ZrR\ne3G4ZHHbgBw1sJ+U+n2i4V0pABHPRJj2+EFeOKetP0kuFeDJUr8vB+Nu/ia5wKPP\nSezee2exdfP1wumtraJQzVJUpuof+KAO1Ubj6/XaCgHvLUKwaoIEvXQcxVI1JthZ\ntm9r907nimzPVx8Pnry/S5C6TrV4mpehKn8vsxiSEMC4+sTcTGaPB2UVXj5P6U5r\nwSq2dCOfBQmkEPkH81Dzvkl4ilQaGTuxy+eeM2bI7dQaQuEyr2D4Z9chCxA7/TWH\n99TKOHKC+zYUZ91fPhnuLytgNmedIvg3BlX7sA4CAp3N6FozvEoa8IrZc7sR+2ne\n5X0S3SiDzELHz5NRxWoRBmU0Xhlhm4XPzK74NRaYHcWo1rQVZ70=\n=LAeP\n-----END PGP SIGNATURE-----",
        "payload": "tree 7398ed0ba0cf4dfb8ef2433cc6a990f3cfa800f9\nparent 52ac3b5469e514f9288683bcb944e58c02606346\nauthor Jesse Cohen <jc@jc.lol> 1522770338 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438169 -0400\n\nAdd ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "52ac3b5469e514f9288683bcb944e58c02606346",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52ac3b5469e514f9288683bcb944e58c02606346",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52ac3b5469e514f9288683bcb944e58c02606346"
      }
    ],
    "stats": {
      "total": 200,
      "additions": 199,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5e1a8a272ee3e7c2cad0908aa191ee86844238cd",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
        "patch": "@@ -107,6 +107,8 @@ BITCOIN_CORE_H = \\\n   compressor.h \\\n   consensus/consensus.h \\\n   consensus/tx_verify.h \\\n+  core/consumerthread.h \\\n+  core/producerconsumerqueue.h \\\n   core_io.h \\\n   core_memusage.h \\\n   cuckoocache.h \\\n@@ -140,7 +142,6 @@ BITCOIN_CORE_H = \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n-  core/producerconsumerqueue.h \\\n   protocol.h \\\n   random.h \\\n   reverse_iterator.h \\"
      },
      {
        "sha": "cbb37037fe5b5bcc619e82f0f8695753fb01abaa",
        "filename": "src/core/consumerthread.h",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7/src/core/consumerthread.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7/src/core/consumerthread.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/consumerthread.h?ref=6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
        "patch": "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>\n+{\n+public:\n+    WorkQueue(int capacity) :BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>(capacity) {}\n+\n+    //! Blocks until everything pushed to the queue prior to this call has been dequeued by a worker\n+    void Sync()\n+    {\n+        std::promise<void> barrier;\n+        this->Push(MakeUnique<GenericWorkItem<PRODUCER_MODE>>([&barrier](){ barrier.set_value(); }), WorkerMode::BLOCKING);\n+        barrier.get_future().wait();\n+    }\n+};\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template <WorkerMode PRODUCER_POLICY>\n+class ConsumerThread\n+{\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() : m_active(false){};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"worker\")\n+        : m_id(id), m_queue(queue), m_active(true)\n+    {\n+        m_thread = std::thread(&TraceThread<std::function<void()>>, id.c_str(), std::function<void()>(std::bind(&ConsumerThread<PRODUCER_POLICY>::Loop, this)));\n+    };\n+\n+    //! Terminates a running consumer thread\n+    //! Blocks until the thread joins\n+    //! Repeated calls are no-ops\n+    void Terminate()\n+    {\n+        RequestTermination();\n+        Join();\n+    }\n+\n+    //! Requests termination of a running consumer thread\n+    //! Does not wait for the thread to terminate\n+    //! Repeated calls are no-ops\n+    void RequestTermination()\n+    {\n+        // locked only so that repeated calls do not push extra ShutdownPills\n+        std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown);\n+        if (m_active) {\n+            m_active = false;\n+\n+            // push an empty WorkItem so that we wake the thread up if it is blocking on an empty queue\n+            // there is no easy way to determine if this consumer is blocked on the queue without introducing\n+            // additional synchronization, but there is little downside to pushing this unnecessarily:\n+            // either this is the last active thread on the queue in which case this will be destroyed if/when\n+            // the queue (and any other work that may remain is destroyed)\n+            // or there are other threads on the queue - in which case this pill will be discarded after any\n+            // of the other threads observe it more than once\n+            m_queue->Push(std::unique_ptr<ShutdownPill<PRODUCER_POLICY>>(new ShutdownPill<PRODUCER_POLICY>(*this)), WorkerMode::NONBLOCKING);\n+        }\n+    }\n+\n+    //! Waits until this thread terminates\n+    //! RequestTerminate() must have been previously called or be called by a different thread\n+    void Join()\n+    {\n+        m_thread.join();\n+    }\n+\n+    bool IsActive() const { std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown); return m_active; }\n+\n+    const std::string m_id;\n+\n+private:\n+    //! the queue of work that this thread should consume from\n+    const std::shared_ptr<WorkQueue<PRODUCER_POLICY>> m_queue;\n+\n+    //! the thread that this class wraps\n+    std::thread m_thread;\n+\n+    //! whether this thread should continue running: behaves like a latch\n+    //! initialized to true in the constructor\n+    //! can be set to false by calling Terminate()\n+    volatile bool m_active;\n+\n+    //! protects Terminate()\n+    mutable CWaitableCriticalSection m_cs_shutdown;\n+\n+    //! the body of this thread\n+    //! Receives WorkItem() elements from m_queue and executes them until Terminate() is called\n+    void Loop()\n+    {\n+        while (m_active) {\n+            Process(m_queue->Pop());\n+        }\n+    }\n+\n+    void Process(const std::unique_ptr<WorkItem<PRODUCER_POLICY>> work) const\n+    {\n+        (*work)();\n+    }\n+};\n+\n+#endif // BITCOIN_CORE_CONSUMERTHREAD_H"
      }
    ]
  },
  {
    "sha": "fb022e3850fb1c145bd813d0f57169296f3248a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYjAyMmUzODUwZmIxYzE0NWJkODEzZDBmNTcxNjkyOTZmMzI0OGE0",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-03T15:46:00Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:10Z"
      },
      "message": "ConsumerThread unit tests",
      "tree": {
        "sha": "00fc58fabb72f042517f30cc137703547a14345e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00fc58fabb72f042517f30cc137703547a14345e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fb022e3850fb1c145bd813d0f57169296f3248a4",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX9oACgkQg1TZSXEC\nj8YGZRAAsKZ9roB5JtNfwtua5znVB+6oysMi5TBmm9WHU8b9q+4yjRocEBX9EFL0\nXcrx4M5IeCaSom1XTljQym7NZwb39c0NIzE2HVGHboVlMmXwawdkUxfj81GtNILZ\nGyVBGWlenmYf9iFseNbojCkYf9vPCh2kN9dlSLw+mI8tWx6xEqmGOmWCYosaNnIp\nkD6q2INpFlMivjgeU4CYNKBNOamC3cC3mmpmAEtToAM4U1r0q8dZVL6sEQsaLDap\nGBTKbKGt4SsxRngRwX5QTDm5IDdGBfke9xrg/3IYcnUZV9zh0PEvKtpmO9+CaYHL\n1NB2DtMs7K5f0SDCojdte/mKLOl5gMjIco6wAA4gbs5JTRZaWnUXN9HlZU7JDkT1\ncyduxR8RQm/mE1OprIBSPwkGrSxtC1wB0aDmKucRiNHCkOOII7eJu7fowQvbZpkS\nZUYRVFEZknID5Fo77UEsxLXSL2EvPQJcOANkKGkqFIFJmU9Z1seT21vgmilCbv2U\nSwkmGLCiNmYivho63JtKf2ZBIBQJbGz9zp03AaHm87Jysm8FSJeLqA0auCCzYLJp\n9yVRvuiWHB8iPpwZrdeZAX/kqtYSueGdso9K9qH1lZnLdrfyAVzLI/PX8JbggbyB\n821bMvGa5xfAxmlm16zSqXA18Jy3sZb87p3S+0BnqSTV9G2F9rc=\n=fCFW\n-----END PGP SIGNATURE-----",
        "payload": "tree 00fc58fabb72f042517f30cc137703547a14345e\nparent 6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7\nauthor Jesse Cohen <jc@jc.lol> 1522770360 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438170 -0400\n\nConsumerThread unit tests\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb022e3850fb1c145bd813d0f57169296f3248a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fb022e3850fb1c145bd813d0f57169296f3248a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb022e3850fb1c145bd813d0f57169296f3248a4/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 89,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e6d6904fce363a1e50ff15a21e18ab2ae6965b1a",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb022e3850fb1c145bd813d0f57169296f3248a4/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb022e3850fb1c145bd813d0f57169296f3248a4/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=fb022e3850fb1c145bd813d0f57169296f3248a4",
        "patch": "@@ -44,6 +44,7 @@ BITCOIN_TESTS =\\\n   test/checkqueue_tests.cpp \\\n   test/coins_tests.cpp \\\n   test/compress_tests.cpp \\\n+  test/consumerthread_tests.cpp \\\n   test/crypto_tests.cpp \\\n   test/cuckoocache_tests.cpp \\\n   test/denialofservice_tests.cpp \\"
      },
      {
        "sha": "65ff3e8c7eb5653f1e8204cad40aadbab53c76cc",
        "filename": "src/test/consumerthread_tests.cpp",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb022e3850fb1c145bd813d0f57169296f3248a4/src/test/consumerthread_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb022e3850fb1c145bd813d0f57169296f3248a4/src/test/consumerthread_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/consumerthread_tests.cpp?ref=fb022e3850fb1c145bd813d0f57169296f3248a4",
        "patch": "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        work[i] = i;\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = 0; i < n_threads / 2; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 2);\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = n_threads / 2; i < n_threads; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 4);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(foo)\n+{\n+    ConsumerThreadTest(100, 1);\n+    ConsumerThreadTest(100, 10);\n+    ConsumerThreadTest(0, 10);\n+    ConsumerThreadTest(3, 10);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END();"
      }
    ]
  },
  {
    "sha": "5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDQwYWE4ZTk2MDdjYThkZDM1Y2VkMjkxNTdmMjhkOTYwMmQ1ZDU1",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-10T18:28:05Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:11Z"
      },
      "message": "ValidationLayer() - interface for calls into block validation",
      "tree": {
        "sha": "d7ff5e0bd64daee32a07e73dfa4ca90c484c785b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d7ff5e0bd64daee32a07e73dfa4ca90c484c785b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX9sACgkQg1TZSXEC\nj8YL+BAAk4W86yiUDGp/X9cYY+T0q0D1cBDBEaGT6+oFRSjFRlwne2iZyk10BQzQ\noyOH2Z/kEk82RlRGH8WaPm7TH3xt5Q4I5IGv7Vvoi5WK6fC2od/FoMlQvZu40OSM\naQ6aOhxRI4COr/2YzfTV1TNgBJ5YrYXnN+oLKVmnAzPtEJgsjsNxQXF/HeOzimXh\n9SJ5vB/ikvbksccxUI+S+wP0KO8pOqEFQ/HKlQmb5EPW25FfpfcjyVPgzn6e8Fg4\njfwhEq3ESUuCtISuGg86QjpeybkLQ9D3+rPlTWT8y/ZDhLSAys9xH8jwyrSft6K9\n0yp2nx+4n5OR5OMTnzpm0k9XFl1aKEg0mKn/yQsAVrP1VE9PyFk5e1m/pL14uVeg\nJ+H+B0kJlIe+D9bJiTgNG7yDKaj+wB7TfWFHZ/SiSNnn1z6ehBZpevlphhqPJpfs\niS7LEWrKWU8HOcKsuSzC6X5SO+aaqMld8hlvbbmXaOgkhxIJOzEFvslznG1js7wO\nQlE3bphXtgHwm9xwtbXrlR0o5Nht/Do7B28g/J907jJRJhzRvd9VZreD4JnkI6xp\nbh8zgDSO9DnJqczKdkMg7efEp9TP+J47D6ImcoHfUtqt+irraa2iiFWn8gvA3HVj\nfDxfNV82Rl7oc5JaYTWNwLr/4/xmXO3p3KDNWy5rIssdvTQfI8k=\n=IBj2\n-----END PGP SIGNATURE-----",
        "payload": "tree d7ff5e0bd64daee32a07e73dfa4ca90c484c785b\nparent fb022e3850fb1c145bd813d0f57169296f3248a4\nauthor Jesse Cohen <jc@jc.lol> 1523384885 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438171 -0400\n\nValidationLayer() - interface for calls into block validation\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb022e3850fb1c145bd813d0f57169296f3248a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb022e3850fb1c145bd813d0f57169296f3248a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb022e3850fb1c145bd813d0f57169296f3248a4"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 202,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a2bb2f1a25b12395ae719acc94173d580db1cbd5",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "patch": "@@ -178,6 +178,7 @@ BITCOIN_CORE_H = \\\n   utilmoneystr.h \\\n   utiltime.h \\\n   validation.h \\\n+  validation_layer.h \\\n   validationinterface.h \\\n   versionbits.h \\\n   walletinitinterface.h \\\n@@ -244,6 +245,7 @@ libbitcoin_server_a_SOURCES = \\\n   txmempool.cpp \\\n   ui_interface.cpp \\\n   validation.cpp \\\n+  validation_layer.cpp \\\n   validationinterface.cpp \\\n   versionbits.cpp \\\n   $(BITCOIN_CORE_H)"
      },
      {
        "sha": "5fe236beab4e1d8a670932f2da01f4d937294eac",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "patch": "@@ -119,6 +119,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::COINDB, \"coindb\"},\n     {BCLog::QT, \"qt\"},\n     {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::VALIDATION, \"validation\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "edeaccd3efb88e25e268200d86bdcb33f90e1183",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "patch": "@@ -53,6 +53,7 @@ namespace BCLog {\n         COINDB      = (1 << 18),\n         QT          = (1 << 19),\n         LEVELDB     = (1 << 20),\n+        VALIDATION  = (1 << 21),\n         ALL         = ~(uint32_t)0,\n     };\n "
      },
      {
        "sha": "2dc54b5b738b0f6c1691839e8448343045742839",
        "filename": "src/validation_layer.cpp",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <validation_layer.h>\n+#include <validation.h>\n+\n+void BlockValidationRequest::operator()()\n+{\n+    LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n+    auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n+    LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n+        __func__, GetId(), res.block_valid, res.is_new);\n+\n+    m_promise.set_value(res);\n+    if (m_on_ready) {\n+        m_on_ready();\n+    }\n+}\n+\n+std::string BlockValidationRequest::GetId() const\n+{\n+    return strprintf(\"BlockValidationRequest[%s]\", m_block->GetHash().ToString());\n+}\n+\n+void ValidationLayer::Start()\n+{\n+    assert(!m_thread || !m_thread->IsActive());\n+    m_thread = std::unique_ptr<ValidationThread>(new ValidationThread(m_validation_queue));\n+}\n+\n+void ValidationLayer::Stop()\n+{\n+    assert(m_thread && m_thread->IsActive());\n+    m_thread->Terminate();\n+}\n+\n+std::future<BlockValidationResponse> ValidationLayer::SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready)\n+{\n+    BlockValidationRequest* req = new BlockValidationRequest(*this, block, force_processing, on_ready);\n+    return SubmitForValidation<BlockValidationResponse>(req);\n+}\n+\n+BlockValidationResponse ValidationLayer::Validate(const std::shared_ptr<const CBlock> block, bool force_processing)\n+{\n+    return SubmitForValidation(block, force_processing).get();\n+}\n+\n+BlockValidationResponse ValidationLayer::ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const\n+{\n+    bool is_new = false;\n+    bool block_valid = ProcessNewBlock(m_chainparams, block, force_processing, &is_new);\n+    return BlockValidationResponse(block_valid, is_new);\n+};"
      },
      {
        "sha": "c580a3fe6b2d92df0cf1afcd6309858526022175",
        "filename": "src/validation_layer.h",
        "status": "added",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/validation_layer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d40aa8e9607ca8dd35ced29157f28d9602d5d55/src/validation_layer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.h?ref=5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "patch": "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;\n+\n+    BlockValidationResponse(bool _block_valid, bool _is_new)\n+        : is_new(_is_new), block_valid(_block_valid){};\n+};\n+\n+/**\n+ * Encapsulates a request to validate a block\n+ */\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+\n+    //! Does the validation\n+    void operator()() override;\n+\n+    //! Returns a block hash\n+    std::string GetId() const override;\n+\n+    const ValidationLayer& m_validation_layer;\n+\n+    //! The block to be validated\n+    const std::shared_ptr<const CBlock> m_block;\n+\n+    //! Was this block explicitly requested (currently required by ProcessNewBlock)\n+    const bool m_force_processing;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: SubmitForValidation(object) -> future<Response>\n+ *  - synchronous:  Validate(object) -> Response (just calls SubmitForValidation and blocks on the response)\n+ *\n+ * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n+ * with the result of validation.\n+ */\n+class ValidationLayer\n+{\n+    friend BlockValidationRequest;\n+\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+    ~ValidationLayer(){};\n+\n+    //! Starts the validation layer (creating the validation thread)\n+    void Start();\n+\n+    //! Stops the validation layer (stopping the validation thread)\n+    void Stop();\n+\n+    //! Submit a block for asynchronous validation\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready = []() {});\n+\n+    //! Submit a block for validation and block on the response\n+    BlockValidationResponse Validate(const std::shared_ptr<const CBlock> block, bool force_processing);\n+\n+private:\n+    //! Internal utility method - sets up and calls ProcessNewBlock\n+    BlockValidationResponse ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const;\n+\n+    //! Internal utility method that wraps a request in a unique pointer and deposits it on the validation queue\n+    template <typename RESPONSE>\n+    std::future<RESPONSE> SubmitForValidation(ValidationRequest<RESPONSE>* request)\n+    {\n+        LogPrint(BCLog::VALIDATION, \"%s<%s>: submitting request=%s\\n\", __func__, typeid(RESPONSE).name(), request->GetId());\n+\n+        auto ret = request->m_promise.get_future();\n+        m_validation_queue->Push(std::unique_ptr<ValidationRequest<RESPONSE>>(request));\n+        return ret;\n+    };\n+\n+    const CChainParams& m_chainparams;\n+\n+    //! a queue that holds validation requests that are sequentially processed by m_thread\n+    const std::shared_ptr<ValidationQueue> m_validation_queue;\n+\n+    //! the validation thread - sequentially processes validation requests from m_validation_queue\n+    std::unique_ptr<ValidationThread> m_thread;\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "8f0d086d5362de18539471fcfe8f048f8b0c9600",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjBkMDg2ZDUzNjJkZTE4NTM5NDcxZmNmZThmMDQ4ZjhiMGM5NjAw",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-10T21:20:47Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:12Z"
      },
      "message": "Call ProcessNewBlock() asynchronously in a separate thread from p2p layer",
      "tree": {
        "sha": "d65620597bf320ba70c6cd4fb9a2e547cd7591f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d65620597bf320ba70c6cd4fb9a2e547cd7591f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f0d086d5362de18539471fcfe8f048f8b0c9600",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX9wACgkQg1TZSXEC\nj8ZdcQ//d58q3PfmLZ1EBZnfV0smaUZysL+rdCToxPPN70Joz2YB1ay33Kta3TaZ\nJQ9I8gqU3Ak+pKGdIoqgdE7CpldmreFB3/HSdzHScRMLn4EslJXI37kQDy4rbSpv\n4Hw0OdJVyNcWhcOXNPnroJs8WxqQ+//l7UaoYbpG7IY1mE3YjT1RNunDsb47sSh4\nM47oz4c7V5NDAyBSKq5AcBT4kNBaX+93MyNO+tNpGjlbMyKIIqFBpLJYRHD1Kdp/\nHB2E943Fd76y3wShL7yKZ5tRIJ7KU+4I0HGF5i3j7HJJjy/NANxm86DEIvioea34\nprYVhwMQkgyBLRGQ52m17YVDXNDFNW0i5a5hm0f1ozPr+4UfNxe6c7t7qAxOHWhz\ndbRrzaY9RsP4UV3R123CHK8Xs4sCNBjWsoAKuQyRRuTtsmpVemaWHw7sERKo3zVA\nUv8OHjic4iqMjALcXjWFNmRqSlTI+04NeetPc3IDXvgzNT3dYWFW4p9F+q1GBc3E\n1+JEnfqQL359JA08mn7e89KmlRsBVj/4f77wskCwys1hczAJ8vY6shlmsp/cmMlW\nyPgiw2all7xEXBrRhYwWmkFQnpFr2aSefYtH7zUTqSNUM8b4RrtK7Q+9qBWZamnM\nKOu6IWSz3pUC8hrhcJnaI1QGLrEakBHwflNm+8yueFKo54ak0c0=\n=1hho\n-----END PGP SIGNATURE-----",
        "payload": "tree d65620597bf320ba70c6cd4fb9a2e547cd7591f4\nparent 5d40aa8e9607ca8dd35ced29157f28d9602d5d55\nauthor Jesse Cohen <jc@jc.lol> 1523395247 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438172 -0400\n\nCall ProcessNewBlock() asynchronously in a separate thread from p2p layer\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f0d086d5362de18539471fcfe8f048f8b0c9600",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f0d086d5362de18539471fcfe8f048f8b0c9600",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f0d086d5362de18539471fcfe8f048f8b0c9600/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5d40aa8e9607ca8dd35ced29157f28d9602d5d55"
      }
    ],
    "stats": {
      "total": 206,
      "additions": 151,
      "deletions": 55
    },
    "files": [
      {
        "sha": "a2da140ebc116fb99766b042c1da71fd288661c3",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -47,6 +47,7 @@\n #include <walletinitinterface.h>\n #include <stdint.h>\n #include <stdio.h>\n+#include <validation_layer.h>\n \n #ifndef WIN32\n #include <signal.h>\n@@ -71,6 +72,7 @@ static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;\n \n std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<PeerLogicValidation> peerLogic;\n+std::unique_ptr<ValidationLayer> g_validation_layer;\n \n #if !(ENABLE_WALLET)\n class DummyWalletInit : public WalletInitInterface {\n@@ -222,6 +224,7 @@ void Shutdown()\n     // using the other before destroying them.\n     if (peerLogic) UnregisterValidationInterface(peerLogic.get());\n     if (g_connman) g_connman->Stop();\n+    if (g_validation_layer) g_validation_layer->Stop();\n     peerLogic.reset();\n     g_connman.reset();\n     if (g_txindex) {\n@@ -1319,7 +1322,10 @@ bool AppInitMain()\n     g_connman = std::unique_ptr<CConnman>(new CConnman(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max())));\n     CConnman& connman = *g_connman;\n \n-    peerLogic.reset(new PeerLogicValidation(&connman, scheduler));\n+    g_validation_layer.reset(new ValidationLayer(chainparams));\n+    g_validation_layer->Start();\n+\n+    peerLogic.reset(new PeerLogicValidation(&connman, *g_validation_layer, scheduler));\n     RegisterValidationInterface(peerLogic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "2d629a0f34b367fb14e31dbab69d51252577a2b6",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 4,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -14,11 +14,12 @@\n #include <consensus/consensus.h>\n #include <crypto/common.h>\n #include <crypto/sha256.h>\n-#include <primitives/transaction.h>\n #include <netbase.h>\n+#include <primitives/transaction.h>\n #include <scheduler.h>\n #include <ui_interface.h>\n #include <utilstrencodings.h>\n+#include <validation_layer.h>\n \n #ifdef WIN32\n #include <string.h>\n@@ -2034,11 +2035,28 @@ void CConnman::ThreadMessageHandler()\n             if (pnode->fDisconnect)\n                 continue;\n \n-            // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n-            fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n+            bool request_was_queued = pnode->IsAwaitingInternalRequest();\n+\n+            // If an internal request was queued and it's not done yet, skip this node\n+            if (request_was_queued && !pnode->ProcessInternalRequestResults(m_msgproc))\n+                continue;\n+\n+            // If no internal request was queued receive messages\n+            if (!request_was_queued) {\n+                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n+                request_was_queued = pnode->IsAwaitingInternalRequest();\n+\n+                fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend && !request_was_queued);\n+            } else {\n+                request_was_queued = false;\n+            }\n+\n             if (flagInterruptMsgProc)\n                 return;\n+\n+            if (request_was_queued)\n+                continue;\n+\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n@@ -2809,6 +2827,37 @@ void CNode::AskFor(const CInv& inv)\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n+bool CNode::IsAwaitingInternalRequest()\n+{\n+    return m_block_validation_response.valid();\n+}\n+\n+bool CNode::ProcessInternalRequestResults(NetEventsInterface* peerlogic)\n+{\n+    bool all_cleared = true;\n+\n+    if (m_block_validation_response.valid()) {\n+        if (m_block_validation_response.wait_for(std::chrono::milliseconds::zero()) == std::future_status::ready) {\n+            peerlogic->ProcessBlockValidationResponse(this, m_block_validating, m_block_validating_index, m_block_validation_response.get());\n+\n+            m_block_validating = nullptr;\n+            m_block_validating_index = nullptr;\n+            m_block_validation_response = std::future<BlockValidationResponse>();\n+        } else {\n+            all_cleared = false;\n+        }\n+    }\n+\n+    return all_cleared;\n+}\n+\n+void CNode::SetPendingInternalRequest(const std::shared_ptr<const CBlock> block, std::future<BlockValidationResponse>&& pending_response, const CBlockIndex* pindex)\n+{\n+    m_block_validating = block;\n+    m_block_validating_index = pindex;\n+    m_block_validation_response = std::move(pending_response);\n+}\n+\n bool CConnman::NodeFullyConnected(const CNode* pnode)\n {\n     return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;"
      },
      {
        "sha": "a2ed496e0e8918e1351b7ca6cbdf1d856074bd48",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 25,
        "deletions": 3,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -23,19 +23,23 @@\n #include <threadinterrupt.h>\n \n #include <atomic>\n+#include <chrono>\n+#include <condition_variable>\n #include <deque>\n+#include <future>\n+#include <memory>\n #include <stdint.h>\n #include <thread>\n-#include <memory>\n-#include <condition_variable>\n \n #ifndef WIN32\n #include <arpa/inet.h>\n #endif\n \n-\n+struct BlockValidationResponse;\n class CScheduler;\n class CNode;\n+class CBlock;\n+class CBlockIndex;\n \n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n static const int PING_INTERVAL = 2 * 60;\n@@ -469,6 +473,7 @@ class NetEventsInterface\n     virtual bool SendMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n     virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n+    virtual void ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response) = 0;\n \n protected:\n     /**\n@@ -746,6 +751,13 @@ class CNode\n     // Our address, as reported by the peer\n     CService addrLocal;\n     mutable CCriticalSection cs_addrLocal;\n+\n+    // If an asynchronous request to validate a block received over the network is pending\n+    // these members hold details of that request\n+    std::future<BlockValidationResponse> m_block_validation_response;\n+    std::shared_ptr<const CBlock> m_block_validating;\n+    const CBlockIndex* m_block_validating_index;\n+\n public:\n \n     NodeId GetId() const {\n@@ -856,6 +868,16 @@ class CNode\n     std::string GetAddrName() const;\n     //! Sets the addrName only if it was not previously set\n     void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    //! Is an asynchronous internal request pending\n+    bool IsAwaitingInternalRequest();\n+\n+    //! If a result from an asynchronous internal request is ready, process the results\n+    bool ProcessInternalRequestResults(NetEventsInterface*);\n+\n+    //! Mark this node as waiting for an asynchronous internal request to complete\n+    //! before any further processing of this node may occurb\n+    void SetPendingInternalRequest(const std::shared_ptr<const CBlock> block, std::future<BlockValidationResponse>&& pending_response, const CBlockIndex* pindex = nullptr);\n };\n \n "
      },
      {
        "sha": "b30b7c3c38147a7af669cf53617523b20f119389",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 43,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -12,10 +12,9 @@\n #include <consensus/validation.h>\n #include <hash.h>\n #include <init.h>\n-#include <validation.h>\n #include <merkleblock.h>\n-#include <netmessagemaker.h>\n #include <netbase.h>\n+#include <netmessagemaker.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <primitives/block.h>\n@@ -29,6 +28,8 @@\n #include <util.h>\n #include <utilmoneystr.h>\n #include <utilstrencodings.h>\n+#include <validation.h>\n+#include <validation_layer.h>\n \n #include <memory>\n \n@@ -810,7 +811,9 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &scheduler) : connman(connmanIn), m_stale_tip_check_time(0) {\n+PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, ValidationLayer& validation_layer, CScheduler& scheduler)\n+    : connman(connmanIn), m_validation_layer(validation_layer), m_stale_tip_check_time(0)\n+{\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n \n@@ -867,7 +870,7 @@ static uint256 most_recent_block_hash;\n static bool fWitnessesPresentInMostRecentCompactBlock;\n \n /**\n- * Maintain state about the best-seen block and fast-announce a compact block \n+ * Maintain state about the best-seen block and fast-announce a compact block\n  * to compatible peers.\n  */\n void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n@@ -912,7 +915,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n }\n \n /**\n- * Update our best height and announce any block hashes which weren't previously \n+ * Update our best height and announce any block hashes which weren't previously\n  * in chainActive to our peers.\n  */\n void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {\n@@ -948,7 +951,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n }\n \n /**\n- * Handle invalid block rejection and consequent peer banning, maintain which \n+ * Handle invalid block rejection and consequent peer banning, maintain which\n  * peers announce compact blocks.\n  */\n void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {\n@@ -1226,6 +1229,12 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n     }\n }\n \n+void SubmitBlock(CConnman* connman, ValidationLayer& validation_layer, CNode* pfrom, const std::shared_ptr<const CBlock> pblock, bool force_processing, const CBlockIndex* pindex = nullptr)\n+{\n+    std::future<BlockValidationResponse> result = validation_layer.SubmitForValidation(pblock, force_processing, std::bind(&CConnman::WakeMessageHandler, connman));\n+    pfrom->SetPendingInternalRequest(pblock, std::move(result), pindex);\n+}\n+\n void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     AssertLockNotHeld(cs_main);\n@@ -1538,7 +1547,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, ValidationLayer& validation_layer, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2532,7 +2541,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n+            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, validation_layer, interruptMsgProc);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n@@ -2550,7 +2559,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_main);\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n-            bool fNewBlock = false;\n+\n             // Setting fForceProcessing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n             // unrequested blocks that might be trying to waste our resources\n@@ -2560,21 +2569,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n-                // Clear download state for this block, which is in\n-                // process from some other peer.  We do this after calling\n-                // ProcessNewBlock so that a malleated cmpctblock announcement\n-                // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n-            }\n+            SubmitBlock(connman, validation_layer, pfrom, pblock, /*fForceProcessing*/ true, pindex);\n         }\n \n     }\n@@ -2625,7 +2620,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is only used for sending reject messages and DoS scores,\n                 // so the race between here and cs_main in ProcessNewBlock is fine.\n@@ -2636,20 +2630,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n-            bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n+            SubmitBlock(connman, validation_layer, pfrom, pblock, /*fForceProcessing*/ true);\n         }\n     }\n \n@@ -2692,19 +2679,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            forceProcessing = mapBlocksInFlight.count(hash);\n+\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n-        bool fNewBlock = false;\n-        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n-        if (fNewBlock) {\n-            pfrom->nLastBlockTime = GetTime();\n-        } else {\n-            LOCK(cs_main);\n-            mapBlockSource.erase(pblock->GetHash());\n-        }\n+        SubmitBlock(connman, validation_layer, pfrom, pblock, forceProcessing);\n     }\n \n \n@@ -3025,7 +3006,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, m_validation_layer, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3072,6 +3053,26 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response)\n+{\n+    LOCK(cs_main);\n+\n+    // If we've reconstructed this block via compactblocks then\n+    // Clear download state for this block, which is in\n+    // process from some other peer.  We do this after calling\n+    // ProcessNewBlock so that a malleated cmpctblock announcement\n+    // can't be used to interfere with block relay.\n+    if (!pindex || pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n+        MarkBlockAsReceived(pblock->GetHash());\n+    }\n+\n+    if (validation_response.is_new) {\n+        pfrom->nLastBlockTime = GetTime();\n+    } else {\n+        mapBlockSource.erase(pblock->GetHash());\n+    }\n+}\n+\n void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);"
      },
      {
        "sha": "8a8ba27349df0d63a53457a298a22035f3cae7b9",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -10,6 +10,9 @@\n #include <validationinterface.h>\n #include <consensus/params.h>\n \n+struct BlockValidationResponse;\n+class ValidationLayer;\n+\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Expiration time for orphan transactions in seconds */\n@@ -43,9 +46,10 @@ extern bool g_enable_bip61;\n class PeerLogicValidation final : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* const connman;\n+    ValidationLayer& m_validation_layer;\n \n public:\n-    explicit PeerLogicValidation(CConnman* connman, CScheduler &scheduler);\n+    explicit PeerLogicValidation(CConnman* connman, ValidationLayer& validation_layer, CScheduler& scheduler);\n \n     /**\n      * Overridden from CValidationInterface.\n@@ -86,6 +90,8 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n     void EvictExtraOutboundPeers(int64_t time_in_seconds);\n \n+    void ProcessBlockValidationResponse(CNode*, std::shared_ptr<const CBlock>, const CBlockIndex*, const BlockValidationResponse&) override;\n+\n private:\n     int64_t m_stale_tip_check_time; //! Next time to check for stale tip\n };"
      },
      {
        "sha": "d875332b45f77fe17955d717ccca6f4b7cf38ff1",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -17,6 +17,7 @@\n #include <rpc/server.h>\n #include <rpc/register.h>\n #include <script/sigcache.h>\n+#include <validation_layer.h>\n \n void CConnmanTest::AddNode(CNode& node)\n {\n@@ -99,7 +100,11 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             threadGroup.create_thread(&ThreadScriptCheck);\n         g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n         connman = g_connman.get();\n-        peerLogic.reset(new PeerLogicValidation(connman, scheduler));\n+\n+        g_validation_layer.reset(new ValidationLayer(Params()));\n+        g_validation_layer->Start();\n+\n+        peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler));\n }\n \n TestingSetup::~TestingSetup()\n@@ -110,6 +115,8 @@ TestingSetup::~TestingSetup()\n         GetMainSignals().UnregisterBackgroundSignalScheduler();\n         g_connman.reset();\n         peerLogic.reset();\n+        if (g_validation_layer) g_validation_layer->Stop();\n+        g_validation_layer.reset();\n         UnloadBlockIndex();\n         pcoinsTip.reset();\n         pcoinsdbview.reset();\n@@ -119,6 +126,7 @@ TestingSetup::~TestingSetup()\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)\n {\n+\n     // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.\n     // TODO: fix the code to support SegWit blocks.\n     UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);\n@@ -158,7 +166,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n+    g_validation_layer->Validate(shared_pblock, true);\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "5656e3ba4183f9a8b33b793ad84f05d859369d1b",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -18,6 +18,8 @@\n \n #include <boost/thread.hpp>\n \n+class ValidationLayer;\n+\n extern uint256 insecure_rand_seed;\n extern FastRandomContext insecure_rand_ctx;\n "
      },
      {
        "sha": "f28a6620afa6521ff9c06c87d5e7f5e1cb868ab0",
        "filename": "src/test/test_bitcoin_main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/test/test_bitcoin_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/test/test_bitcoin_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_main.cpp?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -5,12 +5,14 @@\n #define BOOST_TEST_MODULE Bitcoin Test Suite\n \n #include <net.h>\n+#include <validation_layer.h>\n \n #include <memory>\n \n #include <boost/test/unit_test.hpp>\n \n std::unique_ptr<CConnman> g_connman;\n+std::unique_ptr<ValidationLayer> g_validation_layer;\n \n [[noreturn]] void Shutdown(void* parg)\n {"
      },
      {
        "sha": "6e51bd783119457eb7d4e7253a547309812d5bab",
        "filename": "src/validation_layer.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f0d086d5362de18539471fcfe8f048f8b0c9600/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "patch": "@@ -10,7 +10,7 @@ void BlockValidationRequest::operator()()\n     LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n     auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n     LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n-        __func__, GetId(), res.block_valid, res.is_new);\n+             __func__, GetId(), res.block_valid, res.is_new);\n \n     m_promise.set_value(res);\n     if (m_on_ready) {"
      }
    ]
  },
  {
    "sha": "0428d43f150ef7207c87d4913914d627d8a4eb1b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNDI4ZDQzZjE1MGVmNzIwN2M4N2Q0OTEzOTE0ZDYyN2Q4YTRlYjFi",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-05-08T20:21:51Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:13Z"
      },
      "message": "Replace all instances of ProcessNewBlock() with ValidationLayer.Validate()",
      "tree": {
        "sha": "7eb79f7bbee5e579746e89dbcc90e923fcba82b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7eb79f7bbee5e579746e89dbcc90e923fcba82b6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0428d43f150ef7207c87d4913914d627d8a4eb1b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX90ACgkQg1TZSXEC\nj8ZgwQ//fpYv1k8AMy7meaZA8lRollFZWe5RSQ0WNq5JMI+O1anQhK1kEjUcc6n6\nBrTGz7kC74nM8IFZZA/2Q6RsR+l4TogWh9yOAXQKeUHc1BvfiIJPwrTgfS77Y668\nJUdat1ZJxZ+CdcgKveXCgWMcNUjXuq8i6RnOlD5NY1I4eq6wFfpSvMw+DtfeUYGs\n2GShzb4QqpzeUQcHnNDz3bDhsq1q3QvdUMFy9nwUi9UUaQwThf3ggZCNrUwyTDsM\nU136f3xSFOLjiU3/kHo5A24KazyGIoueHL91bgZyf/NT6Je+e008Zq+0crH8R5a0\n2mx4ztI3Y6U5zJfLzXLUE8c//kpCyzoBAPfaZj1oE0Cjo/aBzJpDDLF2H8d3BdkO\nI/4tZ/BZP5gH5sbhPeQodGpnNMjIeLIuJUE81K/0GDNQ1Q3N2F+0H4vCFwi62/3N\ntvD0KxYb3fc7Xry2h4qh/m+GIQekH/5mP15j0aGn4Le8qc3xqcogxceZ+PVmFYG9\nCpgf6ouVhSvxPvy3OKnwzAVCTkI02TvtF74lK6m7ARmufAA+eLy7S9LPrsy5FMyf\nxeoNSQmJou9s8RadM6sdT4G32cOBE0mnbZ8xaGnF3Zrpt5YvxxMdvEnbMwogczA2\nmBmTWN1Cel0I41T1f/pJnVNgtvUQ8oaKCVsf7UgIWWU29OtESJU=\n=KpwC\n-----END PGP SIGNATURE-----",
        "payload": "tree 7eb79f7bbee5e579746e89dbcc90e923fcba82b6\nparent 8f0d086d5362de18539471fcfe8f048f8b0c9600\nauthor Jesse Cohen <jc@jc.lol> 1525810911 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438173 -0400\n\nReplace all instances of ProcessNewBlock() with ValidationLayer.Validate()\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0428d43f150ef7207c87d4913914d627d8a4eb1b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0428d43f150ef7207c87d4913914d627d8a4eb1b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0428d43f150ef7207c87d4913914d627d8a4eb1b/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f0d086d5362de18539471fcfe8f048f8b0c9600",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f0d086d5362de18539471fcfe8f048f8b0c9600"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 13,
      "deletions": 12
    },
    "files": [
      {
        "sha": "aa0d7dbd5c6311a9a0f10a71da87020d0271eacf",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0428d43f150ef7207c87d4913914d627d8a4eb1b/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0428d43f150ef7207c87d4913914d627d8a4eb1b/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=0428d43f150ef7207c87d4913914d627d8a4eb1b",
        "patch": "@@ -23,6 +23,7 @@\n #include <txmempool.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <validation_layer.h>\n #include <validationinterface.h>\n #include <warnings.h>\n \n@@ -137,7 +138,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n             continue;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n+        if (!g_validation_layer->Validate(shared_pblock, true).block_valid)\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -749,10 +750,10 @@ static UniValue submitblock(const JSONRPCRequest& request)\n     bool new_block;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool accepted = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n+    BlockValidationResponse resp = g_validation_layer->Validate(blockptr, true);\n     UnregisterValidationInterface(&sc);\n-    if (!new_block) {\n-        if (!accepted) {\n+    if (!resp.is_new) {\n+        if (!resp.block_valid) {\n             // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?\n             return \"invalid\";\n         }"
      },
      {
        "sha": "d2b23184a7d9e5317ff8d5da6d59c14defaa76a3",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0428d43f150ef7207c87d4913914d627d8a4eb1b/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0428d43f150ef7207c87d4913914d627d8a4eb1b/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=0428d43f150ef7207c87d4913914d627d8a4eb1b",
        "patch": "@@ -17,6 +17,7 @@\n #include <uint256.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <validation_layer.h>\n \n #include <test/test_bitcoin.h>\n \n@@ -207,6 +208,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // Note that by default, these tests run with size accounting enabled.\n     const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     const CChainParams& chainparams = *chainParams;\n+\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     std::unique_ptr<CBlockTemplate> pblocktemplate;\n     CMutableTransaction tx,tx2;\n@@ -248,7 +250,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n             pblock->nNonce = blockinfo[i].nonce;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n+        BOOST_CHECK(g_validation_layer->Validate(shared_pblock, true).block_valid);\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n "
      },
      {
        "sha": "3803bbc63bbf51c7d84c39ca54a6c54f2bd8ecb8",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0428d43f150ef7207c87d4913914d627d8a4eb1b/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0428d43f150ef7207c87d4913914d627d8a4eb1b/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=0428d43f150ef7207c87d4913914d627d8a4eb1b",
        "patch": "@@ -11,7 +11,7 @@\n #include <pow.h>\n #include <random.h>\n #include <test/test_bitcoin.h>\n-#include <validation.h>\n+#include <validation_layer.h>\n #include <validationinterface.h>\n \n struct RegtestingSetup : public TestingSetup {\n@@ -128,7 +128,6 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n         BuildChain(Params().GenesisBlock().GetHash(), 100, 15, 10, 500, blocks);\n     }\n \n-    bool ignored;\n     CValidationState state;\n     std::vector<CBlockHeader> headers;\n     std::transform(blocks.begin(), blocks.end(), std::back_inserter(headers), [](std::shared_ptr<const CBlock> b) { return b->GetBlockHeader(); });\n@@ -137,7 +136,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     BOOST_CHECK(ProcessNewBlockHeaders(headers, state, Params()));\n \n     // Connect the genesis block and drain any outstanding events\n-    ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored);\n+    g_validation_layer->Validate(std::make_shared<CBlock>(Params().GenesisBlock()), true);\n     SyncWithValidationInterfaceQueue();\n \n     // subscribe to events (this subscriber will validate event ordering)\n@@ -154,17 +153,16 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     // will subscribe to events generated during block validation and assert on ordering invariance\n     boost::thread_group threads;\n     for (int i = 0; i < 10; i++) {\n-        threads.create_thread([&blocks]() {\n-            bool ignored;\n+        threads.create_thread([this, &blocks]() {\n             for (int i = 0; i < 1000; i++) {\n                 auto block = blocks[GetRand(blocks.size() - 1)];\n-                ProcessNewBlock(Params(), block, true, &ignored);\n+                g_validation_layer->SubmitForValidation(block, true);\n             }\n \n             // to make sure that eventually we process the full chain - do it here\n             for (auto block : blocks) {\n                 if (block->vtx.size() == 1) {\n-                    bool processed = ProcessNewBlock(Params(), block, true, &ignored);\n+                    bool processed = g_validation_layer->Validate(block, true).block_valid;\n                     assert(processed);\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "f31b45484234bbff662ddd0020da3b11a3927449",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzFiNDU0ODQyMzRiYmZmNjYyZGRkMDAyMGRhM2IxMWEzOTI3NDQ5",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-05-08T19:06:36Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:14Z"
      },
      "message": "Limit available scope of ProcessNewBlock to ValidationLayer (move-only)",
      "tree": {
        "sha": "b93b223206f6e876e375246a8ad490192193d983",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b93b223206f6e876e375246a8ad490192193d983"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f31b45484234bbff662ddd0020da3b11a3927449",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX94ACgkQg1TZSXEC\nj8akYA//Vitwok4dz5dXZbwEniqONkyPPjrfmSkaovZEwvj3hau50GnJz/rYUfPp\nRgzhqdO5wMRwomyobo2LGBWgKokBaM4CdIpsviIRmmDbrf/yXuA2eJQZvBe31fwI\n6S9G8h0mo4Ndw6Vq3aOMIwkGpuCg1EioGYa1wFsXnbqahQpjbSl206MtKrsA3ULo\nfH/Yd2EP/6wPu8ZO9ny7i+M3e6y+CXt+9u62g6XJfyNGVBI6WSZKBDbSIEglglE/\nmdotONV46Y0A0GT+jxNFxiptJ6NOQj+7yyG68X9nbRGEBED8amZRA8dtKTm5E/jy\nVqXBCVAAGsXO6M+dpNLKJ420a5Ofr2TkWOzGmkISjUIPEe2pr/ChSM52bIXEUSEE\njCk/Maq1Zq06mFd9a0f8RmMqNkjoSwi4/6ZVo4lViExAJJN8ixa11UPcjrxY3Jf5\niDIDvcqrr56TsrlxIymHJLZ1JvvPqU6dGO84sssZxBSdPy4uHHYRBBiZYd7S1ojI\nfBT40b6fQnTifGtNWVwn3G7bFLYtjCWdScC3E1/Kbg6m4mR2eijOePEMb/BZaXoS\nKo9hIGDi4cRg0EFAZHeW+ay+n0EkxHsGRNUf52VVqguyFTnew/pop92p++6lAQB2\nsr+pnB18l4SshISvI1kCIBrDgkGGYcyUXHKOAJawdCIkApZYMgU=\n=x0Dk\n-----END PGP SIGNATURE-----",
        "payload": "tree b93b223206f6e876e375246a8ad490192193d983\nparent 0428d43f150ef7207c87d4913914d627d8a4eb1b\nauthor Jesse Cohen <jc@jc.lol> 1525806396 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438174 -0400\n\nLimit available scope of ProcessNewBlock to ValidationLayer (move-only)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f31b45484234bbff662ddd0020da3b11a3927449",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f31b45484234bbff662ddd0020da3b11a3927449",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f31b45484234bbff662ddd0020da3b11a3927449/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0428d43f150ef7207c87d4913914d627d8a4eb1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0428d43f150ef7207c87d4913914d627d8a4eb1b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0428d43f150ef7207c87d4913914d627d8a4eb1b"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 22,
      "deletions": 24
    },
    "files": [
      {
        "sha": "d01c06ab4ea5ecee64ebb9f118f80dcb3d3e55e8",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 23,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f31b45484234bbff662ddd0020da3b11a3927449/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f31b45484234bbff662ddd0020da3b11a3927449/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=f31b45484234bbff662ddd0020da3b11a3927449",
        "patch": "@@ -221,28 +221,6 @@ static const unsigned int DEFAULT_CHECKLEVEL = 3;\n // Setting the target to > than 550MB will make it likely we can respect the target.\n static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n \n-/** \n- * Process an incoming block. This only returns after the best known valid\n- * block is made active. Note that it does not, however, guarantee that the\n- * specific block passed to it has been checked for validity!\n- *\n- * If you want to *possibly* get feedback on whether pblock is valid, you must\n- * install a CValidationInterface (see validationinterface.h) - this will have\n- * its BlockChecked method called whenever *any* block completes validation.\n- *\n- * Note that we guarantee that either the proof-of-work is valid on pblock, or\n- * (and possibly also) BlockChecked will have been called.\n- * \n- * May not be called with cs_main held. May not be called in a\n- * validationinterface callback.\n- *\n- * @param[in]   pblock  The block we want to process.\n- * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n- * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n- * @return True if state.IsValid()\n- */\n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock);\n-\n /**\n  * Process incoming block headers.\n  *\n@@ -365,7 +343,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp = null\n \n /**\n  * Closure representing one script verification\n- * Note that this stores references to the spending transaction \n+ * Note that this stores references to the spending transaction\n  */\n class CScriptCheck\n {"
      },
      {
        "sha": "79377b96f8200f6415fd398ada2ca67084d53b69",
        "filename": "src/validation_layer.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 1,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f31b45484234bbff662ddd0020da3b11a3927449/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f31b45484234bbff662ddd0020da3b11a3927449/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=f31b45484234bbff662ddd0020da3b11a3927449",
        "patch": "@@ -3,7 +3,27 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <validation_layer.h>\n-#include <validation.h>\n+\n+/**\n+ * Process an incoming block. This only returns after the best known valid\n+ * block is made active. Note that it does not, however, guarantee that the\n+ * specific block passed to it has been checked for validity!\n+ *\n+ * If you want to *possibly* get feedback on whether pblock is valid, you must\n+ * install a CValidationInterface (see validationinterface.h) - this will have\n+ * its BlockChecked method called whenever *any* block completes validation.\n+ *\n+ * Note that we guarantee that either the proof-of-work is valid on pblock, or\n+ * (and possibly also) BlockChecked will have been called.\n+ *\n+ * Call without cs_main held.\n+ *\n+ * @param[in]   pblock  The block we want to process.\n+ * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n+ * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n+ * @return True if state.IsValid()\n+ */\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock);\n \n void BlockValidationRequest::operator()()\n {"
      }
    ]
  },
  {
    "sha": "65ae792d78eb24d8572237d301a04a1cbeaadae3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NWFlNzkyZDc4ZWIyNGQ4NTcyMjM3ZDMwMWEwNGExY2JlYWFkYWUz",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-05-09T15:08:28Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:15Z"
      },
      "message": "Fix whitespace in test_bitcoin.cpp (whitespace,move-only)",
      "tree": {
        "sha": "a5f7df9f6db88eaf911c63422610698861e3679e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5f7df9f6db88eaf911c63422610698861e3679e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX98ACgkQg1TZSXEC\nj8YV7Q/8CIalCEthH3UTmiZAWQTVkogsIpwuFvwf2td1I3qmAPCPpvmAn3qscKVa\n0O+8vTSLtZVUxlMQW0wjyyfkjTF9tF8xmAoZO/zkzgRGX5ucQK+NtaxAVhUxiSp0\n2MU4gQPfCrRllIC6Kkc8D1qcjW+NDCXrqmdzmeUfq0+LmvzGSZT2++ATWwzU2e9B\nzL+fsT7D0jmZRYvTHvV63BHqRwWmV1kOZT0hnbHpAicHaQ2R7Y253JCnevSb6q7y\n8tEBTNsopPGs0S2vf2BMDbWwdQ7Gj37jYQ7xcpAjznPj5cJkaFPXx/FcwpVJCIA5\nrk3lpulQYCuGIvU3nTFlRN17QUSD3mxIuC4kSnszXoERd2IE16SXv2ZDq/o17Zkn\nKokXrOIb+ISbmow9yjRkL8LMF+zi9H2iifqdXruFt8SJSfP7gJs377kJTM/Q46Kp\niy1mpcW/SkzmvzjoyVOblZ8enuzUvXVAQ5lJ8OT/8bdbDdb12tpH0FQ5p86mW2GL\noUZT/RAAxja2K7htQm8Dc5bN7aRR64DhvAyN8LrBovFGBhdUiSq9Qs4r2+Wcn/gd\nKILtBuBnNGXhyvk2MOXUk+aFIHO317gAKTw8PwmDq6Cp/zJAtX9JoU022KPUtv82\nk9IiQza+d5jvpVusNQInRiv1rCeYV8esF6pzaCdQ9o1DuAefXOw=\n=tg+1\n-----END PGP SIGNATURE-----",
        "payload": "tree a5f7df9f6db88eaf911c63422610698861e3679e\nparent f31b45484234bbff662ddd0020da3b11a3927449\nauthor Jesse Cohen <jc@jc.lol> 1525878508 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438175 -0400\n\nFix whitespace in test_bitcoin.cpp (whitespace,move-only)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65ae792d78eb24d8572237d301a04a1cbeaadae3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/65ae792d78eb24d8572237d301a04a1cbeaadae3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65ae792d78eb24d8572237d301a04a1cbeaadae3/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f31b45484234bbff662ddd0020da3b11a3927449",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f31b45484234bbff662ddd0020da3b11a3927449",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f31b45484234bbff662ddd0020da3b11a3927449"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 59,
      "deletions": 58
    },
    "files": [
      {
        "sha": "c56f97383cdff5d3b247a2a8e501e1c51883a40c",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 58,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65ae792d78eb24d8572237d301a04a1cbeaadae3/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65ae792d78eb24d8572237d301a04a1cbeaadae3/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=65ae792d78eb24d8572237d301a04a1cbeaadae3",
        "patch": "@@ -48,80 +48,81 @@ std::ostream& operator<<(std::ostream& os, const uint256& num)\n \n BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n {\n-        SHA256AutoDetect();\n-        RandomInit();\n-        ECC_Start();\n-        SetupEnvironment();\n-        SetupNetworking();\n-        InitSignatureCache();\n-        InitScriptExecutionCache();\n-        fCheckBlockIndex = true;\n-        SelectParams(chainName);\n-        noui_connect();\n+    SHA256AutoDetect();\n+    RandomInit();\n+    ECC_Start();\n+    SetupEnvironment();\n+    SetupNetworking();\n+    InitSignatureCache();\n+    InitScriptExecutionCache();\n+    fCheckBlockIndex = true;\n+    SelectParams(chainName);\n+    noui_connect();\n }\n \n BasicTestingSetup::~BasicTestingSetup()\n {\n-        ECC_Stop();\n+    ECC_Stop();\n }\n \n TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\n {\n     const CChainParams& chainparams = Params();\n-        // Ideally we'd move all the RPC tests to the functional testing framework\n-        // instead of unit tests, but for now we need these here.\n-\n-        RegisterAllCoreRPCCommands(tableRPC);\n-        ClearDatadirCache();\n-        pathTemp = fs::temp_directory_path() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(1 << 30)));\n-        fs::create_directories(pathTemp);\n-        gArgs.ForceSetArg(\"-datadir\", pathTemp.string());\n-\n-        // We have to run a scheduler thread to prevent ActivateBestChain\n-        // from blocking due to queue overrun.\n-        threadGroup.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n-        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n-\n-        mempool.setSanityCheck(1.0);\n-        pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-        pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-        pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-        if (!LoadGenesisBlock(chainparams)) {\n-            throw std::runtime_error(\"LoadGenesisBlock failed.\");\n-        }\n-        {\n-            CValidationState state;\n-            if (!ActivateBestChain(state, chainparams)) {\n-                throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n-            }\n+\n+    // Ideally we'd move all the RPC tests to the functional testing framework\n+    // instead of unit tests, but for now we need these here.\n+\n+    RegisterAllCoreRPCCommands(tableRPC);\n+    ClearDatadirCache();\n+    pathTemp = fs::temp_directory_path() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(1 << 30)));\n+    fs::create_directories(pathTemp);\n+    gArgs.ForceSetArg(\"-datadir\", pathTemp.string());\n+\n+    // We have to run a scheduler thread to prevent ActivateBestChain\n+    // from blocking due to queue overrun.\n+    threadGroup.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+\n+    mempool.setSanityCheck(1.0);\n+    pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n+    pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n+    pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+    if (!LoadGenesisBlock(chainparams)) {\n+        throw std::runtime_error(\"LoadGenesisBlock failed.\");\n+    }\n+    {\n+        CValidationState state;\n+        if (!ActivateBestChain(state, chainparams)) {\n+            throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n         }\n-        nScriptCheckThreads = 3;\n-        for (int i=0; i < nScriptCheckThreads-1; i++)\n-            threadGroup.create_thread(&ThreadScriptCheck);\n-        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n-        connman = g_connman.get();\n+    }\n+    nScriptCheckThreads = 3;\n+    for (int i=0; i < nScriptCheckThreads-1; i++)\n+        threadGroup.create_thread(&ThreadScriptCheck);\n+    g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n+    connman = g_connman.get();\n \n-        g_validation_layer.reset(new ValidationLayer(Params()));\n-        g_validation_layer->Start();\n+    g_validation_layer.reset(new ValidationLayer(Params()));\n+    g_validation_layer->Start();\n \n-        peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler));\n+    peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler));\n }\n \n TestingSetup::~TestingSetup()\n {\n-        threadGroup.interrupt_all();\n-        threadGroup.join_all();\n-        GetMainSignals().FlushBackgroundCallbacks();\n-        GetMainSignals().UnregisterBackgroundSignalScheduler();\n-        g_connman.reset();\n-        peerLogic.reset();\n-        if (g_validation_layer) g_validation_layer->Stop();\n-        g_validation_layer.reset();\n-        UnloadBlockIndex();\n-        pcoinsTip.reset();\n-        pcoinsdbview.reset();\n-        pblocktree.reset();\n-        fs::remove_all(pathTemp);\n+    threadGroup.interrupt_all();\n+    threadGroup.join_all();\n+    GetMainSignals().FlushBackgroundCallbacks();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n+    g_connman.reset();\n+    peerLogic.reset();\n+    if (g_validation_layer) g_validation_layer->Stop();\n+    g_validation_layer.reset();\n+    UnloadBlockIndex();\n+    pcoinsTip.reset();\n+    pcoinsdbview.reset();\n+    pblocktree.reset();\n+    fs::remove_all(pathTemp);\n }\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)"
      }
    ]
  },
  {
    "sha": "d110d264c8238ebdecf0804ee23b3ae354b7f33b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMTEwZDI2NGM4MjM4ZWJkZWNmMDgwNGVlMjNiM2FlMzU0YjdmMzNi",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-06T17:06:48Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:16Z"
      },
      "message": "[refactor, move-only-ish] Refactor mempool accept/reject logic\n\nCreate separate functions to handle responses when a transaction\nreceived from a peer is accepted or rejected.\n\nThis commit introduces one behavior change:\n   Currently, if -promiscuousmempool is set (only allowed on regtest\n   and testnet), it is possible for AcceptToMemoryPool() to return\n   true, but for the CValidationState() to contain DoS points if the\n   transaction failed validation with policy standard script flags\n   but then passed with promiscuous flags. This will cause you to ban\n   the peer who sent the transaction. This commit fixes this behavior\n   by reseting the validation state in that one situation.",
      "tree": {
        "sha": "02c25cee7504ddb580bcd6a2cdbf6ea9b8e99417",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02c25cee7504ddb580bcd6a2cdbf6ea9b8e99417"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d110d264c8238ebdecf0804ee23b3ae354b7f33b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX+AACgkQg1TZSXEC\nj8aOHQ/+O02YC9iZ5PK7VSiZAiT6P+vtxOZV3wwQTNYL6uDFhLIS5GK6tE9bX68d\nss5ugAeniC/ApUVGWTsYtdbR4QRdLpdXIQAyh0n4UGsvGNTZBlM7Wi9HMI5e+RsJ\n8SUviv0Msq0bIad3RQRC4YwGFRpx95N4Y+Q2+hTdmpf5Hjb1L1HPsxhzANE++AYb\n3/u0ctfOBja2ZjJD4PbIZq9+nkhkZFipoBpGnDj2ttH/rbEuRDUG8+9R3wLxwZEz\nZ2XYHjFrmsOhRWpbLbtjbbPbPX8UsFFnQeeugaGBs08dteg9xlinsiFwfQq43YJQ\nj7i/xr/5iM6BVjpz4xAzBMehCDDkgnQYXf4ILR07wspW33DMWUfWWXo5gmRfrFs4\nOreVjKDIbF0ZG+sLCzwf3kDW1gLGP42VwHxVsjhAsfJbFhzWPpNku5hTG3Tu0bNO\nYu1FIcTUKaHCP6sEB2ESZxrUZAmVrAU4p+LvAXiK9AO6ISDpwqljooqyvLLvjMOg\n+3qeEr1qc1M+PleMVL2nrphJmS55a+ftGOifYtw+WDyJFv6yBE7aCFrEpHqfwWiF\nkCXQ5TtIlZkxUSm9jQqtiCdMXMLscfsd9CuKOz1pSYGSMuyoUI4EeXk0HIiYJq4H\nm41JoUy9mcm863GaZPluoI3YqhKjW+C0ZzMQHtk90g+FWxRHadY=\n=Alt6\n-----END PGP SIGNATURE-----",
        "payload": "tree 02c25cee7504ddb580bcd6a2cdbf6ea9b8e99417\nparent 65ae792d78eb24d8572237d301a04a1cbeaadae3\nauthor Jesse Cohen <jc@jc.lol> 1528304808 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438176 -0400\n\n[refactor, move-only-ish] Refactor mempool accept/reject logic\n\nCreate separate functions to handle responses when a transaction\nreceived from a peer is accepted or rejected.\n\nThis commit introduces one behavior change:\n   Currently, if -promiscuousmempool is set (only allowed on regtest\n   and testnet), it is possible for AcceptToMemoryPool() to return\n   true, but for the CValidationState() to contain DoS points if the\n   transaction failed validation with policy standard script flags\n   but then passed with promiscuous flags. This will cause you to ban\n   the peer who sent the transaction. This commit fixes this behavior\n   by reseting the validation state in that one situation.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d110d264c8238ebdecf0804ee23b3ae354b7f33b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d110d264c8238ebdecf0804ee23b3ae354b7f33b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d110d264c8238ebdecf0804ee23b3ae354b7f33b/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "65ae792d78eb24d8572237d301a04a1cbeaadae3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65ae792d78eb24d8572237d301a04a1cbeaadae3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65ae792d78eb24d8572237d301a04a1cbeaadae3"
      }
    ],
    "stats": {
      "total": 344,
      "additions": 189,
      "deletions": 155
    },
    "files": [
      {
        "sha": "bf12199c629269de8613b67424845486befea880",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 185,
        "deletions": 155,
        "changes": 340,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d110d264c8238ebdecf0804ee23b3ae354b7f33b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d110d264c8238ebdecf0804ee23b3ae354b7f33b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d110d264c8238ebdecf0804ee23b3ae354b7f33b",
        "patch": "@@ -59,6 +59,11 @@ static CCriticalSection g_cs_orphans;\n std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n void EraseOrphansFor(NodeId peer);\n+static void ProcessMempoolAccept(CConnman *, CNode *, const CTransaction&, std::list<CTransactionRef>&) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n+                                 const CNetMsgMaker msgMaker, const std::string& strCommand,\n+                                 const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n \n static size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n@@ -2189,8 +2194,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        std::deque<COutPoint> vWorkQueue;\n-        std::vector<uint256> vEraseQueue;\n         CTransactionRef ptx;\n         vRecv >> ptx;\n         const CTransaction& tx = *ptx;\n@@ -2208,160 +2211,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n-        if (!AlreadyHave(inv) &&\n-            AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-            mempool.check(pcoinsTip.get());\n-            RelayTransaction(tx, connman);\n-            for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                vWorkQueue.emplace_back(inv.hash, i);\n-            }\n-\n-            pfrom->nLastTXTime = GetTime();\n-\n-            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->GetId(),\n-                tx.GetHash().ToString(),\n-                mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n-\n-            // Recursively process any orphan transactions that depended on this one\n-            std::set<NodeId> setMisbehaving;\n-            while (!vWorkQueue.empty()) {\n-                auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());\n-                vWorkQueue.pop_front();\n-                if (itByPrev == mapOrphanTransactionsByPrev.end())\n-                    continue;\n-                for (auto mi = itByPrev->second.begin();\n-                     mi != itByPrev->second.end();\n-                     ++mi)\n-                {\n-                    const CTransactionRef& porphanTx = (*mi)->second.tx;\n-                    const CTransaction& orphanTx = *porphanTx;\n-                    const uint256& orphanHash = orphanTx.GetHash();\n-                    NodeId fromPeer = (*mi)->second.fromPeer;\n-                    bool fMissingInputs2 = false;\n-                    // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n-                    // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n-                    // anyone relaying LegitTxX banned)\n-                    CValidationState stateDummy;\n-\n-\n-                    if (setMisbehaving.count(fromPeer))\n-                        continue;\n-                    if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-                        LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-                        RelayTransaction(orphanTx, connman);\n-                        for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n-                            vWorkQueue.emplace_back(orphanHash, i);\n-                        }\n-                        vEraseQueue.push_back(orphanHash);\n-                    }\n-                    else if (!fMissingInputs2)\n-                    {\n-                        int nDos = 0;\n-                        if (stateDummy.IsInvalid(nDos) && nDos > 0)\n-                        {\n-                            // Punish peer that gave us an invalid orphan tx\n-                            Misbehaving(fromPeer, nDos);\n-                            setMisbehaving.insert(fromPeer);\n-                            LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n-                        }\n-                        // Has inputs but not accepted to mempool\n-                        // Probably non-standard or insufficient fee\n-                        LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n-                        vEraseQueue.push_back(orphanHash);\n-                        if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n-                            // Do not use rejection cache for witness transactions or\n-                            // witness-stripped transactions, as they can have been malleated.\n-                            // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                            assert(recentRejects);\n-                            recentRejects->insert(orphanHash);\n-                        }\n-                    }\n-                    mempool.check(pcoinsTip.get());\n-                }\n-            }\n-\n-            for (uint256 hash : vEraseQueue)\n-                EraseOrphanTx(hash);\n-        }\n-        else if (fMissingInputs)\n-        {\n-            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n-            for (const CTxIn& txin : tx.vin) {\n-                if (recentRejects->contains(txin.prevout.hash)) {\n-                    fRejectedParents = true;\n-                    break;\n-                }\n-            }\n-            if (!fRejectedParents) {\n-                uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                for (const CTxIn& txin : tx.vin) {\n-                    CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n-                    pfrom->AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n-                }\n-                AddOrphanTx(ptx, pfrom->GetId());\n-\n-                // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n-                unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n-                unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n-                if (nEvicted > 0) {\n-                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n-                }\n+        if (!AlreadyHave(inv)) {\n+            if(AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+                assert(!state.IsInvalid());\n+                ProcessMempoolAccept(connman, pfrom, tx, lRemovedTxn);\n             } else {\n-                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n-                // We will continue to reject this tx since it has rejected\n-                // parents so avoid re-requesting it from other peers.\n-                recentRejects->insert(tx.GetHash());\n-            }\n-        } else {\n-            if (!tx.HasWitness() && !state.CorruptionPossible()) {\n-                // Do not use rejection cache for witness transactions or\n-                // witness-stripped transactions, as they can have been malleated.\n-                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                assert(recentRejects);\n-                recentRejects->insert(tx.GetHash());\n-                if (RecursiveDynamicUsage(*ptx) < 100000) {\n-                    AddToCompactExtraTransactions(ptx);\n-                }\n-            } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {\n-                AddToCompactExtraTransactions(ptx);\n-            }\n-\n-            if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n-                // Always relay transactions received from whitelisted peers, even\n-                // if they were already in the mempool or rejected from it due\n-                // to policy, allowing the node to function as a gateway for\n-                // nodes hidden behind it.\n-                //\n-                // Never relay transactions that we would assign a non-zero DoS\n-                // score for, as we expect peers to do the same with us in that\n-                // case.\n-                int nDoS = 0;\n-                if (!state.IsInvalid(nDoS) || nDoS == 0) {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n-                    RelayTransaction(tx, connman);\n-                } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n-                }\n-            }\n-        }\n-\n-        for (const CTransactionRef& removedTx : lRemovedTxn)\n-            AddToCompactExtraTransactions(removedTx);\n-\n-        int nDoS = 0;\n-        if (state.IsInvalid(nDoS))\n-        {\n-            LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->GetId(),\n-                FormatStateMessage(state));\n-            if (g_enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n-                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n-            }\n-            if (nDoS > 0) {\n-                Misbehaving(pfrom->GetId(), nDoS);\n+                assert(lRemovedTxn.empty());\n+                ProcessMempoolReject(connman, pfrom, msgMaker, strCommand, ptx, state, fMissingInputs);\n             }\n         }\n     }\n@@ -3073,6 +2929,180 @@ void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std\n     }\n }\n \n+static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTransaction& tx, std::list<CTransactionRef>& lRemovedTxn) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+{\n+    std::deque<COutPoint> vWorkQueue;\n+    std::vector<uint256> vEraseQueue;\n+\n+    mempool.check(pcoinsTip.get());\n+    RelayTransaction(tx, connman);\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        vWorkQueue.emplace_back(tx.GetHash(), i);\n+    }\n+\n+    pfrom->nLastTXTime = GetTime();\n+\n+    LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+             pfrom->GetId(),\n+             tx.GetHash().ToString(),\n+             mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n+\n+    // Recursively process any orphan transactions that depended on this one\n+    std::set<NodeId> setMisbehaving;\n+    while (!vWorkQueue.empty()) {\n+        auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());\n+        vWorkQueue.pop_front();\n+        if (itByPrev == mapOrphanTransactionsByPrev.end())\n+            continue;\n+        for (auto mi = itByPrev->second.begin();\n+             mi != itByPrev->second.end();\n+             ++mi)\n+        {\n+            const CTransactionRef& porphanTx = (*mi)->second.tx;\n+            const CTransaction& orphanTx = *porphanTx;\n+            const uint256& orphanHash = orphanTx.GetHash();\n+            NodeId fromPeer = (*mi)->second.fromPeer;\n+            bool fMissingInputs2 = false;\n+            // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan\n+            // resolution (that is, feeding people an invalid transaction based on LegitTxX in order to get\n+            // anyone relaying LegitTxX banned)\n+            CValidationState stateDummy;\n+\n+\n+            if (setMisbehaving.count(fromPeer))\n+                continue;\n+            if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+                LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+                RelayTransaction(orphanTx, connman);\n+                for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n+                    vWorkQueue.emplace_back(orphanHash, i);\n+                }\n+                vEraseQueue.push_back(orphanHash);\n+            }\n+            else if (!fMissingInputs2)\n+            {\n+                int nDos = 0;\n+                if (stateDummy.IsInvalid(nDos) && nDos > 0)\n+                {\n+                    // Punish peer that gave us an invalid orphan tx\n+                    Misbehaving(fromPeer, nDos);\n+                    setMisbehaving.insert(fromPeer);\n+                    LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n+                }\n+                // Has inputs but not accepted to mempool\n+                // Probably non-standard or insufficient fee\n+                LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+                vEraseQueue.push_back(orphanHash);\n+                if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n+                    // Do not use rejection cache for witness transactions or\n+                    // witness-stripped transactions, as they can have been malleated.\n+                    // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+                    assert(recentRejects);\n+                    recentRejects->insert(orphanHash);\n+                }\n+            }\n+            mempool.check(pcoinsTip.get());\n+        }\n+    }\n+\n+    for (uint256 hash : vEraseQueue)\n+        EraseOrphanTx(hash);\n+\n+    for (const CTransactionRef& removedTx : lRemovedTxn)\n+        AddToCompactExtraTransactions(removedTx);\n+}\n+\n+static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n+                                 const CNetMsgMaker msgMaker, const std::string& strCommand,\n+                                 const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+{\n+    const CTransaction& tx = *ptx;\n+\n+    if (missing_inputs) {\n+        ProcessMempoolMissingInputs(pfrom, ptx);\n+    } else {\n+        if (!tx.HasWitness() && !state.CorruptionPossible()) {\n+            // Do not use rejection cache for witness transactions or\n+            // witness-stripped transactions, as they can have been malleated.\n+            // See https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+            assert(recentRejects);\n+            recentRejects->insert(tx.GetHash());\n+            if (RecursiveDynamicUsage(*ptx) < 100000) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+        } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {\n+            AddToCompactExtraTransactions(ptx);\n+        }\n+\n+        if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n+            // Always relay transactions received from whitelisted peers, even\n+            // if they were already in the mempool or rejected from it due\n+            // to policy, allowing the node to function as a gateway for\n+            // nodes hidden behind it.\n+            //\n+            // Never relay transactions that we would assign a non-zero DoS\n+            // score for, as we expect peers to do the same with us in that\n+            // case.\n+            int nDoS = 0;\n+            if (!state.IsInvalid(nDoS) || nDoS == 0) {\n+                LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n+                RelayTransaction(tx, connman);\n+            } else {\n+                LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n+            }\n+        }\n+    }\n+\n+    int nDoS = 0;\n+    if (state.IsInvalid(nDoS))\n+    {\n+        LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n+                 pfrom->GetId(),\n+                 FormatStateMessage(state));\n+        if (g_enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                                      state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), tx.GetHash()));\n+        }\n+        if (nDoS > 0) {\n+            Misbehaving(pfrom->GetId(), nDoS);\n+        }\n+    }\n+}\n+\n+static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+{\n+    const CTransaction& tx = *ptx;\n+\n+    bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n+    for (const CTxIn& txin : tx.vin) {\n+        if (recentRejects->contains(txin.prevout.hash)) {\n+            fRejectedParents = true;\n+            break;\n+        }\n+    }\n+    if (!fRejectedParents) {\n+        uint32_t nFetchFlags = GetFetchFlags(pfrom);\n+        for (const CTxIn& txin : tx.vin) {\n+            CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n+            pfrom->AddInventoryKnown(_inv);\n+            if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n+        }\n+        AddOrphanTx(ptx, pfrom->GetId());\n+\n+        // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n+        unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+        unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n+        if (nEvicted > 0) {\n+            LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+        }\n+    } else {\n+        LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n+        // We will continue to reject this tx since it has rejected\n+        // parents so avoid re-requesting it from other peers.\n+        recentRejects->insert(tx.GetHash());\n+    }\n+}\n+\n void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);"
      },
      {
        "sha": "5b957b63f2ce53741ff3165d4afbedaeac985b2b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d110d264c8238ebdecf0804ee23b3ae354b7f33b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d110d264c8238ebdecf0804ee23b3ae354b7f33b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d110d264c8238ebdecf0804ee23b3ae354b7f33b",
        "patch": "@@ -947,6 +947,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                         __func__, hash.ToString(), FormatStateMessage(state));\n                 } else {\n                     LogPrintf(\"Warning: -promiscuousmempool flags set to not include currently enforced soft forks, this may break mining or otherwise cause instability!\\n\");\n+\n+                    // reset the validation state here as it was made invalid by the failure of CheckInputsFromMempoolAndCache\n+                    // but we're choosing to ignore/override this validation failure\n+                    state = CValidationState();\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "38f649a01592bbf841ba7b860d7a4730896599ba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOGY2NDlhMDE1OTJiYmY4NDFiYTdiODYwZDdhNDczMDg5NjU5OWJh",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-06T20:36:38Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:17Z"
      },
      "message": "[refactor] extract reusable logic in ValidationLayer into AsyncLayer",
      "tree": {
        "sha": "fad6aa4645bef86944134a375626a6a5de67d093",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fad6aa4645bef86944134a375626a6a5de67d093"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38f649a01592bbf841ba7b860d7a4730896599ba",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX+EACgkQg1TZSXEC\nj8YR8A//UxMAnInfOZQ/PlEkEDHeRZvBZJxoAZonDOZQjMTPip8GB8tmqOcG5Oi7\nG/Wm/jzeGSXD8hzSVEmPKOBtCzJPGuWeAb8oF664UY1ra2wZ8pYk/GQKOfthwtbI\n9MIbQnGb2EgSsZymEXtROh67PB8aqSzM1QfwgwMbLRJGb8vhEmMJoNOPfEuZzqGi\nKoUVpPXmM+2mM4fsju3/6iRb5PB0nqgMQmOT43dU7Ya4yDGMLGQtYDSsxhasEjCp\nxGDkPgS3OZlVON8Pg6ReZreHrUBIyhBquhIUQzEbfXqrVftP2ns6B7O+vX0hjTlJ\nFmJ2VffAIEC9gdWVyiMYmCneHw7G0MBZSz/b1ozXu71fwAthjn00lUsttaWR/vDs\nDHS6iE0gXlVTR8/jE6duvt7b8Sxb9klUZCK1m8x9J3PbPYD1sOTwpWkdIgHZcyvI\nYvxgUrlwDOth7JD8udNEEI1J0eIvwF3awlvnv8isj/l0ct8LP1ya84PVc+4CFIwr\nCtIYCTAnR5rbt2IdgflIHvMYmvHOKISB5z0Nnurze6zj1Qzr1vpG+h1yPkvkzBX2\ndoiql6X8aI6CLXNLurzQo/yCNVJDBPMuvO3KOUwYSR+NPx9xhaLL/nVeAmjh4L+z\n+FFZNUkCXoettLAPVva8ZNwbgnutO/q+IQ8gYSaQUWNx9R/PEgs=\n=5gyo\n-----END PGP SIGNATURE-----",
        "payload": "tree fad6aa4645bef86944134a375626a6a5de67d093\nparent d110d264c8238ebdecf0804ee23b3ae354b7f33b\nauthor Jesse Cohen <jc@jc.lol> 1528317398 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438177 -0400\n\n[refactor] extract reusable logic in ValidationLayer into AsyncLayer\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38f649a01592bbf841ba7b860d7a4730896599ba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/38f649a01592bbf841ba7b860d7a4730896599ba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38f649a01592bbf841ba7b860d7a4730896599ba/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d110d264c8238ebdecf0804ee23b3ae354b7f33b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d110d264c8238ebdecf0804ee23b3ae354b7f33b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d110d264c8238ebdecf0804ee23b3ae354b7f33b"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 90,
      "deletions": 0
    },
    "files": [
      {
        "sha": "07dffbf28c653efbba1e9966464100f611434d01",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38f649a01592bbf841ba7b860d7a4730896599ba/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38f649a01592bbf841ba7b860d7a4730896599ba/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=38f649a01592bbf841ba7b860d7a4730896599ba",
        "patch": "@@ -107,6 +107,7 @@ BITCOIN_CORE_H = \\\n   compressor.h \\\n   consensus/consensus.h \\\n   consensus/tx_verify.h \\\n+  core/async_layer.h \\\n   core/consumerthread.h \\\n   core/producerconsumerqueue.h \\\n   core_io.h \\\n@@ -216,6 +217,7 @@ libbitcoin_server_a_SOURCES = \\\n   chain.cpp \\\n   checkpoints.cpp \\\n   consensus/tx_verify.cpp \\\n+  core/async_layer.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n   index/base.cpp \\"
      },
      {
        "sha": "ccd82a9245e53e52e2d5fcd5c596fd24db672efb",
        "filename": "src/core/async_layer.cpp",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38f649a01592bbf841ba7b860d7a4730896599ba/src/core/async_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38f649a01592bbf841ba7b860d7a4730896599ba/src/core/async_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/async_layer.cpp?ref=38f649a01592bbf841ba7b860d7a4730896599ba",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <core/async_layer.h>\n+\n+void AsyncLayer::Start()\n+{\n+    assert(!m_thread || !m_thread->IsActive());\n+    m_thread = std::unique_ptr<WorkerThread>(new WorkerThread(m_request_queue));\n+}\n+\n+void AsyncLayer::Stop()\n+{\n+    assert(m_thread && m_thread->IsActive());\n+    m_thread->Terminate();\n+}"
      },
      {
        "sha": "d6ca8d88eccc105807343fcb34495f4dead2d6dd",
        "filename": "src/core/async_layer.h",
        "status": "added",
        "additions": 69,
        "deletions": 0,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38f649a01592bbf841ba7b860d7a4730896599ba/src/core/async_layer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38f649a01592bbf841ba7b860d7a4730896599ba/src/core/async_layer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/async_layer.h?ref=38f649a01592bbf841ba7b860d7a4730896599ba",
        "patch": "@@ -0,0 +1,69 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_ASYNC_LAYER_H\n+#define BITCOIN_CORE_ASYNC_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/async_layer.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+/**\n+ * Encapsulates a request to validate an object\n+ *\n+ * @see AsyncLayer\n+ */\n+template <typename RESPONSE>\n+class AsyncRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend class AsyncLayer;\n+\n+public:\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+class AsyncLayer\n+{\n+    typedef WorkQueue<WorkerMode::BLOCKING> RequestQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> WorkerThread;\n+\n+public:\n+    AsyncLayer(unsigned int capacity) : m_request_queue(std::make_shared<RequestQueue>(capacity)) {}\n+\n+    void Start();\n+    void Stop();\n+\n+protected:\n+    //! Internal utility method that wraps a request in a unique pointer and deposits it on the validation queue\n+    template <typename REQUEST, typename RESPONSE>\n+    std::future<RESPONSE> AddToQueue(REQUEST* request)\n+    {\n+        LogPrint(BCLog::ASYNC, \"%s<%s>: submitting request=%s\\n\", __func__, typeid(RESPONSE).name(), request->GetId());\n+\n+        auto ret = request->m_promise.get_future();\n+        m_request_queue->Push(std::unique_ptr<REQUEST>(request));\n+        return ret;\n+    };\n+\n+private:\n+    //! a queue that holds validation requests that are sequentially processed by m_thread\n+    const std::shared_ptr<RequestQueue> m_request_queue;\n+\n+    //! the validation thread - sequentially processes validation requests from m_validation_queue\n+    std::unique_ptr<WorkerThread> m_thread;\n+};\n+\n+#endif // BITCOIN_CORE_ASYNC_LAYER_H"
      },
      {
        "sha": "b5ad8787a51537c4b1d983abe65a6d2eef513476",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38f649a01592bbf841ba7b860d7a4730896599ba/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38f649a01592bbf841ba7b860d7a4730896599ba/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=38f649a01592bbf841ba7b860d7a4730896599ba",
        "patch": "@@ -120,6 +120,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::QT, \"qt\"},\n     {BCLog::LEVELDB, \"leveldb\"},\n     {BCLog::VALIDATION, \"validation\"},\n+    {BCLog::ASYNC, \"async\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "f6dd902eedf50c1bbfa2cafea8eabaa3ba26600b",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38f649a01592bbf841ba7b860d7a4730896599ba/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38f649a01592bbf841ba7b860d7a4730896599ba/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=38f649a01592bbf841ba7b860d7a4730896599ba",
        "patch": "@@ -54,6 +54,7 @@ namespace BCLog {\n         QT          = (1 << 19),\n         LEVELDB     = (1 << 20),\n         VALIDATION  = (1 << 21),\n+        ASYNC       = (1 << 22),\n         ALL         = ~(uint32_t)0,\n     };\n "
      }
    ]
  },
  {
    "sha": "523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjNkMzlmOTQ3NmFkZWQ3YjExZDg5YmEzYzllZWYwZGRlYmE3YmNj",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-06T20:39:10Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:18Z"
      },
      "message": "ValidationLayer uses AsyncLayer",
      "tree": {
        "sha": "864086628cb23149f50ffc80652960f62e49660c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/864086628cb23149f50ffc80652960f62e49660c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX+IACgkQg1TZSXEC\nj8aZUxAAmDaGiBFGrLdr+lHaERGcS7H6ghYgrbjXezhAfYrynryI2hjrwk1mfi+4\ng1gCmb3vIqQnmuz5I6gUBj7LoEwMyv3olPXdExAutjqO4FgnamxLvyBMmfF84K3U\nUXgoCEx24vyHXSEHBjobyobwYPIQHwnwX4D0BqBfe0G2rkjt4g3/HWK4piaXqWw4\nW0q+8ZlVhd1WS6mgce9IN59t+b+e1QGlFFYSZpkehSyEV1CYBsbHl7/RgRVALljl\neKbTfea0TMM+UQkBlEObYPmkSWtpeGX3A3+ulmY4951w7gSKUn2XvAPQv1wiYmFO\nlhbT5PnWrg6JHWRypot9lYgUb9CxxvZqbPd/ixSlQvcWAYrYBJkUCPl3zncaPp2m\nONVkvyO1uD3bWD7OXKmUWsuRxfIndZvpPxp9x3gdcEc2UjbD2RSO9x7Pe58QRecK\nfiYPRezytYMLjzr/6KMO2cczBhfudOz4r1+Sjvw/vWVCtoQ0oezFAXlvP+X/6LFj\n1yu48tsRJUx3jsC0SDDUxY+yJbHYluM1kRhovVb7cQjqqogKMzNlDc9khkk2Jo+U\nVfBeLvh1PF1gqPsRyunEV9xoB58KHFLFjM8spaz/amWS57/rUZUo4ntU28m5IUXy\n3mU3MoNkQl3R4zTNnZYDJcmhQED990RHhQpgfhoxY8vG7IMep2w=\n=ZwLd\n-----END PGP SIGNATURE-----",
        "payload": "tree 864086628cb23149f50ffc80652960f62e49660c\nparent 38f649a01592bbf841ba7b860d7a4730896599ba\nauthor Jesse Cohen <jc@jc.lol> 1528317550 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438178 -0400\n\nValidationLayer uses AsyncLayer\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "38f649a01592bbf841ba7b860d7a4730896599ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38f649a01592bbf841ba7b860d7a4730896599ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/38f649a01592bbf841ba7b860d7a4730896599ba"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 19,
      "deletions": 57
    },
    "files": [
      {
        "sha": "0b43e08d9df050dd4f5f8fb21c36d7ea5d5746b2",
        "filename": "src/validation_layer.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 16,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
        "patch": "@@ -27,10 +27,10 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n \n void BlockValidationRequest::operator()()\n {\n-    LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n+    LogPrint(BCLog::ASYNC, \"%s: validating request=%s\\n\", __func__, GetId());\n     auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n-    LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n-             __func__, GetId(), res.block_valid, res.is_new);\n+    LogPrint(BCLog::ASYNC, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n+        __func__, GetId(), res.block_valid, res.is_new);\n \n     m_promise.set_value(res);\n     if (m_on_ready) {\n@@ -43,22 +43,10 @@ std::string BlockValidationRequest::GetId() const\n     return strprintf(\"BlockValidationRequest[%s]\", m_block->GetHash().ToString());\n }\n \n-void ValidationLayer::Start()\n-{\n-    assert(!m_thread || !m_thread->IsActive());\n-    m_thread = std::unique_ptr<ValidationThread>(new ValidationThread(m_validation_queue));\n-}\n-\n-void ValidationLayer::Stop()\n-{\n-    assert(m_thread && m_thread->IsActive());\n-    m_thread->Terminate();\n-}\n-\n std::future<BlockValidationResponse> ValidationLayer::SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready)\n {\n     BlockValidationRequest* req = new BlockValidationRequest(*this, block, force_processing, on_ready);\n-    return SubmitForValidation<BlockValidationResponse>(req);\n+    return AddToQueue<BlockValidationRequest, BlockValidationResponse>(req);\n }\n \n BlockValidationResponse ValidationLayer::Validate(const std::shared_ptr<const CBlock> block, bool force_processing)"
      },
      {
        "sha": "9ea9d2c8f5cb221f084ca232a4a3a1ee96716e7e",
        "filename": "src/validation_layer.h",
        "status": "modified",
        "additions": 15,
        "deletions": 41,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc/src/validation_layer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc/src/validation_layer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.h?ref=523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
        "patch": "@@ -8,6 +8,7 @@\n #include <future>\n \n #include <chainparams.h>\n+#include <core/async_layer.h>\n #include <core/consumerthread.h>\n #include <core/producerconsumerqueue.h>\n #include <util.h>\n@@ -22,20 +23,17 @@ extern std::unique_ptr<ValidationLayer> g_validation_layer;\n  * @see ValidationLayer\n  */\n template <typename RESPONSE>\n-class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+class ValidationRequest : public AsyncRequest<RESPONSE>\n {\n     friend ValidationLayer;\n \n-private:\n-    //! Guts of the validation\n-    virtual void operator()() = 0;\n-\n+public:\n     //! Returns a string identifier (for logging)\n-    virtual std::string GetId() const = 0;\n+    virtual std::string GetId() const override = 0;\n \n protected:\n-    //! Promise that will deliver the validation result to the caller who generated this request\n-    std::promise<RESPONSE> m_promise;\n+    //! Guts of the validation\n+    virtual void operator()() override = 0;\n };\n \n /**\n@@ -59,15 +57,17 @@ class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n {\n     friend ValidationLayer;\n \n-private:\n-    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n-        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+public:\n+    //! Returns a block hash\n+    std::string GetId() const override;\n \n+protected:\n     //! Does the validation\n     void operator()() override;\n \n-    //! Returns a block hash\n-    std::string GetId() const override;\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n \n     const ValidationLayer& m_validation_layer;\n \n@@ -93,24 +93,15 @@ class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n  * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n  * with the result of validation.\n  */\n-class ValidationLayer\n+class ValidationLayer : public AsyncLayer\n {\n     friend BlockValidationRequest;\n \n-    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n-    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n-\n public:\n     ValidationLayer(const CChainParams& chainparams)\n-        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+        : AsyncLayer(100), m_chainparams(chainparams) {}\n     ~ValidationLayer(){};\n \n-    //! Starts the validation layer (creating the validation thread)\n-    void Start();\n-\n-    //! Stops the validation layer (stopping the validation thread)\n-    void Stop();\n-\n     //! Submit a block for asynchronous validation\n     std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready = []() {});\n \n@@ -121,24 +112,7 @@ class ValidationLayer\n     //! Internal utility method - sets up and calls ProcessNewBlock\n     BlockValidationResponse ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const;\n \n-    //! Internal utility method that wraps a request in a unique pointer and deposits it on the validation queue\n-    template <typename RESPONSE>\n-    std::future<RESPONSE> SubmitForValidation(ValidationRequest<RESPONSE>* request)\n-    {\n-        LogPrint(BCLog::VALIDATION, \"%s<%s>: submitting request=%s\\n\", __func__, typeid(RESPONSE).name(), request->GetId());\n-\n-        auto ret = request->m_promise.get_future();\n-        m_validation_queue->Push(std::unique_ptr<ValidationRequest<RESPONSE>>(request));\n-        return ret;\n-    };\n-\n     const CChainParams& m_chainparams;\n-\n-    //! a queue that holds validation requests that are sequentially processed by m_thread\n-    const std::shared_ptr<ValidationQueue> m_validation_queue;\n-\n-    //! the validation thread - sequentially processes validation requests from m_validation_queue\n-    std::unique_ptr<ValidationThread> m_thread;\n };\n \n #endif"
      }
    ]
  },
  {
    "sha": "bd24661d9fa536817860bb26f950e1cbf8635153",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZDI0NjYxZDlmYTUzNjgxNzg2MGJiMjZmOTUwZTFjYmY4NjM1MTUz",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-06T21:30:54Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-19T19:56:19Z"
      },
      "message": "Add MempoolLayer() for async invocation of AcceptToMemoryPool()",
      "tree": {
        "sha": "c65c702506f57de4454422e0ef085eee44827dd8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c65c702506f57de4454422e0ef085eee44827dd8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd24661d9fa536817860bb26f950e1cbf8635153",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIYWkmH/KGrdSf1LBg1TZSXECj8YFAlspX+MACgkQg1TZSXEC\nj8YzexAArCJNRHoCMOF7hSxi128DQBIGsd4DR2Arrv6do59BWgKsXuH85R1OPqYK\nx7tqlTZGwn/Tc7gKbSVviIYM/Ko84PvIMdT+CLYbV6mPf2n1UNNqH85TXC8KyhVY\nDAbgxn5wI/DJL6k4aZbYH4ihx7Xby9pgQLjGeMOzOAAfBN36425KTaaO96t2Z4Ic\n1bYDT+0JMdjvS6mdkpsJZc2YaGHS9DgwrqGuaCwg11t50xvHy4iOxWIkuinCjtmo\nqAEbXneVzMnv+DaUprK42OGBMC/rxaNGVeFOJvbQZO9NJmVCySWYXaJEbGQBfGHD\nUjtgx9dvdQAUiz1XMRYrQ9qODNlPt09s0zv2wtqzbTpfwKCIBJSJcw2omW5fxVn3\nLJ1FewwTxfMH4vN3d7jNMPEX5DjUitIRjlkukdl2ynIf6yzv8TNcmnYKIDYIXQwP\nITOgZ+oKwZ7Nf7gVRVIEEIvJYDzRGFRgeEUrgBI7HcFf3UWiZiImtTGYGww30gxu\nlLfR4zJpoYFRVZn6YzdbFuVuLpGEW4YuNJQdWJogtz5/WWi2fzD9I2bKdmua+OBU\nNtRYjGikkIGktW4STqUqhOo9X0BLpQSK3ACKQvhCB3aIy1XduMI3eG9ivsnga0E9\nZhMtv1gO3T4E8japg67q81+p3yeydkYv5w0/UmF4FWDmHzWpV1Y=\n=2BCM\n-----END PGP SIGNATURE-----",
        "payload": "tree c65c702506f57de4454422e0ef085eee44827dd8\nparent 523d39f9476aded7b11d89ba3c9eef0ddeba7bcc\nauthor Jesse Cohen <jc@jc.lol> 1528320654 -0400\ncommitter Jesse Cohen <jc@jc.lol> 1529438179 -0400\n\nAdd MempoolLayer() for async invocation of AcceptToMemoryPool()\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd24661d9fa536817860bb26f950e1cbf8635153",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd24661d9fa536817860bb26f950e1cbf8635153",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd24661d9fa536817860bb26f950e1cbf8635153/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/523d39f9476aded7b11d89ba3c9eef0ddeba7bcc"
      }
    ],
    "stats": {
      "total": 148,
      "additions": 148,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e55952ff94b97b2ecfc4d76bfacadeddffcd40c7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd24661d9fa536817860bb26f950e1cbf8635153/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd24661d9fa536817860bb26f950e1cbf8635153/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=bd24661d9fa536817860bb26f950e1cbf8635153",
        "patch": "@@ -130,6 +130,7 @@ BITCOIN_CORE_H = \\\n   limitedmap.h \\\n   logging.h \\\n   memusage.h \\\n+  mempool_layer.h \\\n   merkleblock.h \\\n   miner.h \\\n   net.h \\\n@@ -224,6 +225,7 @@ libbitcoin_server_a_SOURCES = \\\n   index/txindex.cpp \\\n   init.cpp \\\n   dbwrapper.cpp \\\n+  mempool_layer.cpp \\\n   merkleblock.cpp \\\n   miner.cpp \\\n   net.cpp \\"
      },
      {
        "sha": "91bf049db5482e6f5c36897f952a877254f46886",
        "filename": "src/mempool_layer.cpp",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd24661d9fa536817860bb26f950e1cbf8635153/src/mempool_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd24661d9fa536817860bb26f950e1cbf8635153/src/mempool_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mempool_layer.cpp?ref=bd24661d9fa536817860bb26f950e1cbf8635153",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <mempool_layer.h>\n+#include <validation.h>\n+\n+void TransactionSubmissionRequest::operator()()\n+{\n+    LogPrint(BCLog::ASYNC, \"%s: validating request=%s\\n\", __func__, GetId());\n+    auto res = m_mempool_layer.ValidateInternal(m_transaction, m_bypass_limits, m_absurd_fee, m_test_only);\n+    LogPrint(BCLog::ASYNC, \"%s: validation result request=%s accepted=%d\\n\",\n+        __func__, GetId(), res.accepted);\n+\n+    m_promise.set_value(res);\n+    if (m_on_ready) {\n+        m_on_ready();\n+    }\n+}\n+\n+std::string TransactionSubmissionRequest::GetId() const\n+{\n+    return strprintf(\"TransactionRequest[%s]\", m_transaction->GetWitnessHash().ToString());\n+}\n+\n+std::future<TransactionSubmissionResponse> MempoolLayer::SubmitForValidation(\n+    const CTransactionRef& transaction,\n+    const bool bypass_limits,\n+    const CAmount absurd_fee,\n+    const bool test_only,\n+    std::function<void()> on_ready)\n+{\n+    TransactionSubmissionRequest* req = new TransactionSubmissionRequest(*this, transaction,\n+        bypass_limits, absurd_fee, test_only,\n+        on_ready);\n+    return AddToQueue<TransactionSubmissionRequest, TransactionSubmissionResponse>(req);\n+}\n+\n+TransactionSubmissionResponse MempoolLayer::Validate(\n+    const CTransactionRef& transaction,\n+    const bool bypass_limits,\n+    const CAmount absurd_fee,\n+    const bool test_only)\n+{\n+    return SubmitForValidation(transaction, bypass_limits, absurd_fee, test_only).get();\n+}\n+\n+TransactionSubmissionResponse MempoolLayer::ValidateInternal(const CTransactionRef& tx, bool bypass_limits, CAmount absurd_fee, bool test_only) const\n+{\n+    bool missing;\n+    CValidationState state{};\n+    std::list<CTransactionRef> removed;\n+\n+    LOCK(cs_main);\n+    bool accepted = AcceptToMemoryPool(m_mempool, state, tx, &missing, &removed, bypass_limits, absurd_fee, test_only);\n+\n+    return TransactionSubmissionResponse{accepted, missing, std::move(removed), state};\n+};"
      },
      {
        "sha": "8820d9b46cea1799d70c7fd79bf235c21b6c0d74",
        "filename": "src/mempool_layer.h",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd24661d9fa536817860bb26f950e1cbf8635153/src/mempool_layer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd24661d9fa536817860bb26f950e1cbf8635153/src/mempool_layer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mempool_layer.h?ref=bd24661d9fa536817860bb26f950e1cbf8635153",
        "patch": "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MEMPOOL_LAYER_H\n+#define BITCOIN_MEMPOOL_LAYER_H\n+\n+#include <consensus/validation.h>\n+#include <core/async_layer.h>\n+#include <txmempool.h>\n+\n+class MempoolLayer;\n+\n+struct TransactionSubmissionResponse {\n+    const bool accepted;\n+    const bool missing_inputs;\n+    const std::list<CTransactionRef> removed_transactions;\n+    CValidationState status;\n+};\n+\n+class TransactionSubmissionRequest : public AsyncRequest<TransactionSubmissionResponse>\n+{\n+    friend MempoolLayer;\n+\n+public:\n+    //! Returns a transaction witness hash\n+    std::string GetId() const override;\n+\n+protected:\n+    //! Adds this transaction to the mempool\n+    void operator()() override;\n+\n+private:\n+    TransactionSubmissionRequest(MempoolLayer& mempool_layer, const CTransactionRef transaction, const bool bypass_limits, const CAmount absurd_fee, const bool test_only, const std::function<void()> on_ready)\n+        : m_mempool_layer(mempool_layer), m_transaction(transaction),\n+          m_bypass_limits(bypass_limits), m_absurd_fee(absurd_fee), m_test_only(test_only),\n+          m_on_ready(on_ready){};\n+\n+    //! The mempool\n+    const MempoolLayer& m_mempool_layer;\n+\n+    //! Parameters for AcceptToMemoryPool()\n+    const CTransactionRef m_transaction;\n+    const bool m_bypass_limits;\n+    const CAmount m_absurd_fee;\n+    const bool m_test_only;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+class MempoolLayer : public AsyncLayer\n+{\n+    friend TransactionSubmissionRequest;\n+\n+public:\n+    MempoolLayer(CTxMemPool& mempool)\n+        : AsyncLayer(1000), m_mempool(mempool) {}\n+\n+    //! Submit a transaction for asynchronous validation\n+    std::future<TransactionSubmissionResponse> SubmitForValidation(\n+        const CTransactionRef& transaction,\n+        const bool bypass_limits,\n+        const CAmount absurd_fee,\n+        const bool test_only,\n+        std::function<void()> on_ready = []() {});\n+\n+    //! Submit a transaction for asynchronous validation\n+    TransactionSubmissionResponse Validate(\n+        const CTransactionRef& transaction,\n+        const bool bypass_limits,\n+        const CAmount absurd_fee,\n+        const bool test_only);\n+\n+private:\n+    //! Internal utility method - sets up and calls AcceptToMemoryPool\n+    TransactionSubmissionResponse ValidateInternal(\n+        const CTransactionRef& transaction,\n+        const bool bypass_limits,\n+        const CAmount absurd_fee,\n+        const bool test_only) const;\n+\n+    CTxMemPool& m_mempool;\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNzExODNiMWIwNjFlZDNiZjVmY2UyODExMTM2YjE5NWZmZTljZTNh",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-07T03:34:05Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-06-20T13:28:46Z"
      },
      "message": "Call AcceptToMemoryPool() asynchronously in net_processing",
      "tree": {
        "sha": "cc258a132e1252c484c26c9663d3f3e11bbecf16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc258a132e1252c484c26c9663d3f3e11bbecf16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd24661d9fa536817860bb26f950e1cbf8635153",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd24661d9fa536817860bb26f950e1cbf8635153",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd24661d9fa536817860bb26f950e1cbf8635153"
      }
    ],
    "stats": {
      "total": 151,
      "additions": 96,
      "deletions": 55
    },
    "files": [
      {
        "sha": "bfe557ab217807b53115cbda4861afdf52e4c1a9",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -22,6 +22,7 @@\n #include <index/txindex.h>\n #include <key.h>\n #include <validation.h>\n+#include <mempool_layer.h>\n #include <miner.h>\n #include <netbase.h>\n #include <net.h>\n@@ -73,6 +74,7 @@ static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;\n std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<PeerLogicValidation> peerLogic;\n std::unique_ptr<ValidationLayer> g_validation_layer;\n+std::unique_ptr<MempoolLayer> g_mempool_layer;\n \n #if !(ENABLE_WALLET)\n class DummyWalletInit : public WalletInitInterface {\n@@ -225,6 +227,7 @@ void Shutdown()\n     if (peerLogic) UnregisterValidationInterface(peerLogic.get());\n     if (g_connman) g_connman->Stop();\n     if (g_validation_layer) g_validation_layer->Stop();\n+    if (g_mempool_layer) g_mempool_layer->Stop();\n     peerLogic.reset();\n     g_connman.reset();\n     if (g_txindex) {\n@@ -1325,7 +1328,10 @@ bool AppInitMain()\n     g_validation_layer.reset(new ValidationLayer(chainparams));\n     g_validation_layer->Start();\n \n-    peerLogic.reset(new PeerLogicValidation(&connman, *g_validation_layer, scheduler));\n+    g_mempool_layer.reset(new MempoolLayer(mempool));\n+    g_mempool_layer->Start();\n+\n+    peerLogic.reset(new PeerLogicValidation(&connman, *g_validation_layer, *g_mempool_layer, scheduler));\n     RegisterValidationInterface(peerLogic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "c6792aee9a0d1c39a900817104172c77d0f3bfd3",
        "filename": "src/mempool_layer.h",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/mempool_layer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/mempool_layer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/mempool_layer.h?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -10,11 +10,19 @@\n #include <txmempool.h>\n \n class MempoolLayer;\n+extern std::unique_ptr<MempoolLayer> g_mempool_layer;\n \n struct TransactionSubmissionResponse {\n+    //! was the transaction accepted\n     const bool accepted;\n+\n+    //! if rejected, was it rejected because it was missing inputs\n     const bool missing_inputs;\n+\n+    //! if accepted, a list of transactions evicted\n     const std::list<CTransactionRef> removed_transactions;\n+\n+    //! validation state, contains reject reason\n     CValidationState status;\n };\n \n@@ -67,7 +75,7 @@ class MempoolLayer : public AsyncLayer\n         const bool test_only,\n         std::function<void()> on_ready = []() {});\n \n-    //! Submit a transaction for asynchronous validation\n+    //! Submit a transaction for synchronous validation\n     TransactionSubmissionResponse Validate(\n         const CTransactionRef& transaction,\n         const bool bypass_limits,"
      },
      {
        "sha": "570da31033629facf104c0a496cff742f373e5da",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 4,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -14,6 +14,7 @@\n #include <consensus/consensus.h>\n #include <crypto/common.h>\n #include <crypto/sha256.h>\n+#include <mempool_layer.h>\n #include <netbase.h>\n #include <primitives/transaction.h>\n #include <scheduler.h>\n@@ -2038,7 +2039,7 @@ void CConnman::ThreadMessageHandler()\n             bool request_was_queued = pnode->IsAwaitingInternalRequest();\n \n             // If an internal request was queued and it's not done yet, skip this node\n-            if (request_was_queued && !pnode->ProcessInternalRequestResults(m_msgproc))\n+            if (request_was_queued && !pnode->ProcessInternalRequestResults(this, m_msgproc))\n                 continue;\n \n             // If no internal request was queued receive messages\n@@ -2829,13 +2830,12 @@ void CNode::AskFor(const CInv& inv)\n \n bool CNode::IsAwaitingInternalRequest()\n {\n-    return m_block_validation_response.valid();\n+    return m_block_validation_response.valid() || m_transaction_submission_response.valid();\n }\n \n-bool CNode::ProcessInternalRequestResults(NetEventsInterface* peerlogic)\n+bool CNode::ProcessInternalRequestResults(CConnman* connman, NetEventsInterface* peerlogic)\n {\n     bool all_cleared = true;\n-\n     if (m_block_validation_response.valid()) {\n         if (m_block_validation_response.wait_for(std::chrono::milliseconds::zero()) == std::future_status::ready) {\n             peerlogic->ProcessBlockValidationResponse(this, m_block_validating, m_block_validating_index, m_block_validation_response.get());\n@@ -2848,6 +2848,17 @@ bool CNode::ProcessInternalRequestResults(NetEventsInterface* peerlogic)\n         }\n     }\n \n+    if (m_transaction_submission_response.valid()) {\n+        if (m_transaction_submission_response.wait_for(std::chrono::milliseconds::zero()) == std::future_status::ready) {\n+            peerlogic->ProcessMempoolValidationResponse(connman, this, m_transaction_validating, m_transaction_submission_response.get());\n+\n+            m_transaction_validating = nullptr;\n+            m_transaction_submission_response = std::future<TransactionSubmissionResponse>();\n+        } else {\n+            all_cleared = false;\n+        }\n+    }\n+\n     return all_cleared;\n }\n \n@@ -2858,6 +2869,12 @@ void CNode::SetPendingInternalRequest(const std::shared_ptr<const CBlock> block,\n     m_block_validation_response = std::move(pending_response);\n }\n \n+void CNode::SetPendingInternalRequest(const CTransactionRef tx, std::future<TransactionSubmissionResponse>&& pending_response)\n+{\n+    m_transaction_validating = tx;\n+    m_transaction_submission_response = std::move(pending_response);\n+}\n+\n bool CConnman::NodeFullyConnected(const CNode* pnode)\n {\n     return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;"
      },
      {
        "sha": "db2dd0642e3f89784db37a0f3807c14c66313f3d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -15,12 +15,13 @@\n #include <limitedmap.h>\n #include <netaddress.h>\n #include <policy/feerate.h>\n+#include <primitives/transaction.h>\n #include <protocol.h>\n #include <random.h>\n #include <streams.h>\n #include <sync.h>\n-#include <uint256.h>\n #include <threadinterrupt.h>\n+#include <uint256.h>\n \n #include <atomic>\n #include <chrono>\n@@ -36,6 +37,8 @@\n #endif\n \n struct BlockValidationResponse;\n+struct TransactionSubmissionResponse;\n+\n class CScheduler;\n class CNode;\n class CBlock;\n@@ -474,6 +477,7 @@ class NetEventsInterface\n     virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n     virtual void ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response) = 0;\n+    virtual void ProcessMempoolValidationResponse(CConnman* connman, CNode* pfrom, const CTransactionRef& transaction, const TransactionSubmissionResponse& response) = 0;\n \n protected:\n     /**\n@@ -758,6 +762,9 @@ class CNode\n     std::shared_ptr<const CBlock> m_block_validating;\n     const CBlockIndex* m_block_validating_index;\n \n+    std::future<TransactionSubmissionResponse> m_transaction_submission_response;\n+    CTransactionRef m_transaction_validating;\n+\n public:\n \n     NodeId GetId() const {\n@@ -873,11 +880,12 @@ class CNode\n     bool IsAwaitingInternalRequest();\n \n     //! If a result from an asynchronous internal request is ready, process the results\n-    bool ProcessInternalRequestResults(NetEventsInterface*);\n+    bool ProcessInternalRequestResults(CConnman*, NetEventsInterface*);\n \n     //! Mark this node as waiting for an asynchronous internal request to complete\n     //! before any further processing of this node may occurb\n     void SetPendingInternalRequest(const std::shared_ptr<const CBlock> block, std::future<BlockValidationResponse>&& pending_response, const CBlockIndex* pindex = nullptr);\n+    void SetPendingInternalRequest(const CTransactionRef tx, std::future<TransactionSubmissionResponse>&& pending_resposne);\n };\n \n "
      },
      {
        "sha": "c29a4c9faa6fbfceff967c9b5bbdd8b6dec88825",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 45,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -12,6 +12,7 @@\n #include <consensus/validation.h>\n #include <hash.h>\n #include <init.h>\n+#include <mempool_layer.h>\n #include <merkleblock.h>\n #include <netbase.h>\n #include <netmessagemaker.h>\n@@ -59,11 +60,9 @@ static CCriticalSection g_cs_orphans;\n std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);\n std::map<COutPoint, std::set<std::map<uint256, COrphanTx>::iterator, IteratorComparator>> mapOrphanTransactionsByPrev GUARDED_BY(g_cs_orphans);\n void EraseOrphansFor(NodeId peer);\n-static void ProcessMempoolAccept(CConnman *, CNode *, const CTransaction&, std::list<CTransactionRef>&) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n-static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n-                                 const CNetMsgMaker msgMaker, const std::string& strCommand,\n-                                 const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n-static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+static void ProcessMempoolAccept(CConnman*, CNode*, const CTransaction&, std::list<CTransactionRef>&) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans);\n+static void ProcessMempoolReject(CConnman* connman, CNode* pfrom, const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+static void ProcessMempoolMissingInputs(CNode* pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n \n static size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;\n static std::vector<std::pair<uint256, CTransactionRef>> vExtraTxnForCompact GUARDED_BY(g_cs_orphans);\n@@ -816,8 +815,8 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, ValidationLayer& validation_layer, CScheduler& scheduler)\n-    : connman(connmanIn), m_validation_layer(validation_layer), m_stale_tip_check_time(0)\n+PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, ValidationLayer& validation_layer, MempoolLayer& mempool_layer, CScheduler& scheduler)\n+    : connman(connmanIn), m_validation_layer(validation_layer), m_mempool_layer(mempool_layer), m_stale_tip_check_time(0)\n {\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n@@ -1552,7 +1551,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, ValidationLayer& validation_layer, const std::atomic<bool>& interruptMsgProc)\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, ValidationLayer& validation_layer, MempoolLayer& mempool_layer, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2201,24 +2200,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n-        LOCK2(cs_main, g_cs_orphans);\n-\n-        bool fMissingInputs = false;\n-        CValidationState state;\n+        LOCK(cs_main);\n \n         pfrom->setAskFor.erase(inv.hash);\n         mapAlreadyAskedFor.erase(inv.hash);\n \n-        std::list<CTransactionRef> lRemovedTxn;\n-\n         if (!AlreadyHave(inv)) {\n-            if(AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n-                assert(!state.IsInvalid());\n-                ProcessMempoolAccept(connman, pfrom, tx, lRemovedTxn);\n-            } else {\n-                assert(lRemovedTxn.empty());\n-                ProcessMempoolReject(connman, pfrom, msgMaker, strCommand, ptx, state, fMissingInputs);\n-            }\n+            std::future<TransactionSubmissionResponse> resp = mempool_layer.SubmitForValidation(ptx, false, 0, false, std::bind(&CConnman::WakeMessageHandler, connman));\n+            pfrom->SetPendingInternalRequest(ptx, std::move(resp));\n         }\n     }\n \n@@ -2397,7 +2386,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, validation_layer, interruptMsgProc);\n+            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, validation_layer, mempool_layer, interruptMsgProc);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n@@ -2862,7 +2851,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, m_validation_layer, interruptMsgProc);\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, m_validation_layer, m_mempool_layer, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -2929,7 +2918,21 @@ void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std\n     }\n }\n \n-static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTransaction& tx, std::list<CTransactionRef>& lRemovedTxn) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+void PeerLogicValidation::ProcessMempoolValidationResponse(CConnman* connman, CNode* pfrom, const CTransactionRef& transaction, const TransactionSubmissionResponse& response)\n+{\n+    LOCK2(cs_main, g_cs_orphans);\n+    if (response.accepted) {\n+        assert(!response.status.IsInvalid());\n+\n+        auto copy = response.removed_transactions;\n+        ProcessMempoolAccept(connman, pfrom, *transaction, copy);\n+    } else {\n+        assert(response.removed_transactions.empty());\n+        ProcessMempoolReject(connman, pfrom, transaction, response.status, response.missing_inputs);\n+    }\n+}\n+\n+static void ProcessMempoolAccept(CConnman* connman, CNode* pfrom, const CTransaction& tx, std::list<CTransactionRef>& lRemovedTxn) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n     std::deque<COutPoint> vWorkQueue;\n     std::vector<uint256> vEraseQueue;\n@@ -2943,9 +2946,9 @@ static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTrans\n     pfrom->nLastTXTime = GetTime();\n \n     LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-             pfrom->GetId(),\n-             tx.GetHash().ToString(),\n-             mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n+        pfrom->GetId(),\n+        tx.GetHash().ToString(),\n+        mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n     // Recursively process any orphan transactions that depended on this one\n     std::set<NodeId> setMisbehaving;\n@@ -2956,8 +2959,7 @@ static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTrans\n             continue;\n         for (auto mi = itByPrev->second.begin();\n              mi != itByPrev->second.end();\n-             ++mi)\n-        {\n+             ++mi) {\n             const CTransactionRef& porphanTx = (*mi)->second.tx;\n             const CTransaction& orphanTx = *porphanTx;\n             const uint256& orphanHash = orphanTx.GetHash();\n@@ -2978,12 +2980,9 @@ static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTrans\n                     vWorkQueue.emplace_back(orphanHash, i);\n                 }\n                 vEraseQueue.push_back(orphanHash);\n-            }\n-            else if (!fMissingInputs2)\n-            {\n+            } else if (!fMissingInputs2) {\n                 int nDos = 0;\n-                if (stateDummy.IsInvalid(nDos) && nDos > 0)\n-                {\n+                if (stateDummy.IsInvalid(nDos) && nDos > 0) {\n                     // Punish peer that gave us an invalid orphan tx\n                     Misbehaving(fromPeer, nDos);\n                     setMisbehaving.insert(fromPeer);\n@@ -3012,9 +3011,7 @@ static void ProcessMempoolAccept(CConnman * connman, CNode * pfrom, const CTrans\n         AddToCompactExtraTransactions(removedTx);\n }\n \n-static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n-                                 const CNetMsgMaker msgMaker, const std::string& strCommand,\n-                                 const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+static void ProcessMempoolReject(CConnman* connman, CNode* pfrom, const CTransactionRef& ptx, const CValidationState& state, bool missing_inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n {\n     const CTransaction& tx = *ptx;\n \n@@ -3054,22 +3051,22 @@ static void ProcessMempoolReject(CConnman * connman, CNode * pfrom,\n     }\n \n     int nDoS = 0;\n-    if (state.IsInvalid(nDoS))\n-    {\n+    if (state.IsInvalid(nDoS)) {\n         LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                 pfrom->GetId(),\n-                 FormatStateMessage(state));\n+            pfrom->GetId(),\n+            FormatStateMessage(state));\n         if (g_enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n-                                                      state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), tx.GetHash()));\n+            const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, std::string(NetMsgType::TX), (unsigned char)state.GetRejectCode(),\n+                                            state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), tx.GetHash()));\n         }\n         if (nDoS > 0) {\n             Misbehaving(pfrom->GetId(), nDoS);\n         }\n     }\n }\n \n-static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+static void ProcessMempoolMissingInputs(CNode* pfrom, const CTransactionRef& ptx) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n {\n     const CTransaction& tx = *ptx;\n \n@@ -3096,7 +3093,7 @@ static void ProcessMempoolMissingInputs(CNode * pfrom, const CTransactionRef& pt\n             LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n         }\n     } else {\n-        LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n+        LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\", tx.GetHash().ToString());\n         // We will continue to reject this tx since it has rejected\n         // parents so avoid re-requesting it from other peers.\n         recentRejects->insert(tx.GetHash());"
      },
      {
        "sha": "88a92a0eba7fe382640f63caf434ca34a8d5d1c3",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -11,6 +11,7 @@\n #include <consensus/params.h>\n \n struct BlockValidationResponse;\n+class MempoolLayer;\n class ValidationLayer;\n \n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n@@ -47,9 +48,10 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n private:\n     CConnman* const connman;\n     ValidationLayer& m_validation_layer;\n+    MempoolLayer& m_mempool_layer;\n \n public:\n-    explicit PeerLogicValidation(CConnman* connman, ValidationLayer& validation_layer, CScheduler& scheduler);\n+    explicit PeerLogicValidation(CConnman* connman, ValidationLayer& validation_layer, MempoolLayer& mempool_layer, CScheduler& scheduler);\n \n     /**\n      * Overridden from CValidationInterface.\n@@ -91,6 +93,7 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     void EvictExtraOutboundPeers(int64_t time_in_seconds);\n \n     void ProcessBlockValidationResponse(CNode*, std::shared_ptr<const CBlock>, const CBlockIndex*, const BlockValidationResponse&) override;\n+    void ProcessMempoolValidationResponse(CConnman* connman, CNode* pfrom, const CTransactionRef& transaction, const TransactionSubmissionResponse& response) override;\n \n private:\n     int64_t m_stale_tip_check_time; //! Next time to check for stale tip"
      },
      {
        "sha": "58ec0ed01ad18adc67f162c3482dced3dfa35cc3",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -10,6 +10,7 @@\n #include <crypto/sha256.h>\n #include <validation.h>\n #include <miner.h>\n+#include <mempool_layer.h>\n #include <net_processing.h>\n #include <pow.h>\n #include <ui_interface.h>\n@@ -105,7 +106,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     g_validation_layer.reset(new ValidationLayer(Params()));\n     g_validation_layer->Start();\n \n-    peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler));\n+    peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, *g_mempool_layer, scheduler));\n }\n \n TestingSetup::~TestingSetup()"
      },
      {
        "sha": "f8c33c31fc4db8ff30d659b21629ed5e1843a73e",
        "filename": "src/test/test_bitcoin_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/test/test_bitcoin_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a71183b1b061ed3bf5fce2811136b195ffe9ce3a/src/test/test_bitcoin_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_main.cpp?ref=a71183b1b061ed3bf5fce2811136b195ffe9ce3a",
        "patch": "@@ -13,6 +13,7 @@\n \n std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<ValidationLayer> g_validation_layer;\n+std::unique_ptr<ValidationLayer> g_mempool_layer;\n \n [[noreturn]] void Shutdown(void* parg)\n {"
      }
    ]
  }
]