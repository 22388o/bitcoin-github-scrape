[
  {
    "sha": "d6815a2313158862d448733954a73520f223deb6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjgxNWEyMzEzMTU4ODYyZDQ0ODczMzk1NGE3MzUyMGYyMjNkZWI2",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-04-04T15:44:39Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-04-04T15:44:39Z"
      },
      "message": "refactor: drop boost::signals2 in validationinterface\n\nStop using boost::signals2 internally in validationinterface. Replace with\nstd::list and Add/Remove/Clear/Iterate helper functions.\n\nMotivation for change is to reduce dependencies and avoid issues happening with\nboost versions before 1.59:\n\nhttps://github.com/bitcoin/bitcoin/issues/18517\nhttps://github.com/bitcoin/bitcoin/pull/18471",
      "tree": {
        "sha": "f3e77851ecc37d8823109f6fdaefc207e516dcc9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3e77851ecc37d8823109f6fdaefc207e516dcc9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6815a2313158862d448733954a73520f223deb6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6815a2313158862d448733954a73520f223deb6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6815a2313158862d448733954a73520f223deb6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6815a2313158862d448733954a73520f223deb6/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c8971547d9c9460fcbec6f54888df83f002c3dfd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8971547d9c9460fcbec6f54888df83f002c3dfd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c8971547d9c9460fcbec6f54888df83f002c3dfd"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 74,
      "deletions": 45
    },
    "files": [
      {
        "sha": "c06647cb0d3a4c2f25564dc12a29366e35394976",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 42,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6815a2313158862d448733954a73520f223deb6/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6815a2313158862d448733954a73520f223deb6/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=d6815a2313158862d448733954a73520f223deb6",
        "patch": "@@ -16,36 +16,75 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+private:\n+    Mutex m_mutex;\n+    //! List entries consist of a callback pointer and reference count. The\n+    //! count is equal to the number of current executions of that entry, plus 1\n+    //! if it's registered. It cannot be 0 because that would imply it is\n+    //! unregistered and also not being executed (so shouldn't exist).\n+    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<ListEntry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<ListEntry>::iterator> m_map GUARDED_BY(m_mutex);\n+\n+public:\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Register(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) inserted.first->second = m_list.emplace(m_list.end());\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Unregister(CValidationInterface* callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(callbacks);\n+        if (it != m_map.end()) {\n+            if (!--it->second->count) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    //! Clear unregisters every previously registered callback, erasing every\n+    //! map entry. After this call, the list may still contain callbacks that\n+    //! are currently executing, but it will be cleared when they are done\n+    //! executing.\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            it = --it->count ? std::next(it) : m_list.erase(it);\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            ++it->count;\n+            {\n+                REVERSE_LOCK(lock);\n+                f(*it->callbacks);\n+            }\n+            it = --it->count ? std::next(it) : m_list.erase(it);\n+        }\n+    }\n };\n \n static CMainSignals g_signals;\n@@ -78,15 +117,7 @@ CMainSignals& GetMainSignals()\n void RegisterSharedValidationInterface(std::shared_ptr<CValidationInterface> pwalletIn) {\n     // Each connection captures pwalletIn to ensure that each callback is\n     // executed before pwalletIn is destroyed. For more details see #18338.\n-    ValidationInterfaceConnections& conns = g_signals.m_internals->m_connMainSignals[pwalletIn.get()];\n-    conns.UpdatedBlockTip = g_signals.m_internals->UpdatedBlockTip.connect(std::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n-    conns.TransactionAddedToMempool = g_signals.m_internals->TransactionAddedToMempool.connect(std::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, std::placeholders::_1));\n-    conns.BlockConnected = g_signals.m_internals->BlockConnected.connect(std::bind(&CValidationInterface::BlockConnected, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n-    conns.BlockDisconnected = g_signals.m_internals->BlockDisconnected.connect(std::bind(&CValidationInterface::BlockDisconnected, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n-    conns.TransactionRemovedFromMempool = g_signals.m_internals->TransactionRemovedFromMempool.connect(std::bind(&CValidationInterface::TransactionRemovedFromMempool, pwalletIn, std::placeholders::_1));\n-    conns.ChainStateFlushed = g_signals.m_internals->ChainStateFlushed.connect(std::bind(&CValidationInterface::ChainStateFlushed, pwalletIn, std::placeholders::_1));\n-    conns.BlockChecked = g_signals.m_internals->BlockChecked.connect(std::bind(&CValidationInterface::BlockChecked, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n-    conns.NewPoWValidBlock = g_signals.m_internals->NewPoWValidBlock.connect(std::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, std::placeholders::_1, std::placeholders::_2));\n+    g_signals.m_internals->Register(std::move(pwalletIn));\n }\n \n void RegisterValidationInterface(CValidationInterface* callbacks)\n@@ -103,15 +134,15 @@ void UnregisterSharedValidationInterface(std::shared_ptr<CValidationInterface> c\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n     if (g_signals.m_internals) {\n-        g_signals.m_internals->m_connMainSignals.erase(pwalletIn);\n+        g_signals.m_internals->Unregister(pwalletIn);\n     }\n }\n \n void UnregisterAllValidationInterfaces() {\n     if (!g_signals.m_internals) {\n         return;\n     }\n-    g_signals.m_internals->m_connMainSignals.clear();\n+    g_signals.m_internals->Clear();\n }\n \n void CallFunctionInValidationInterfaceQueue(std::function<void ()> func) {\n@@ -151,7 +182,7 @@ void CMainSignals::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockInd\n     // in the same critical section where the chain is updated\n \n     auto event = [pindexNew, pindexFork, fInitialDownload, this] {\n-        m_internals->UpdatedBlockTip(pindexNew, pindexFork, fInitialDownload);\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.UpdatedBlockTip(pindexNew, pindexFork, fInitialDownload); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: new block hash=%s fork block hash=%s (in IBD=%s)\", __func__,\n                           pindexNew->GetBlockHash().ToString(),\n@@ -161,7 +192,7 @@ void CMainSignals::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockInd\n \n void CMainSignals::TransactionAddedToMempool(const CTransactionRef &ptx) {\n     auto event = [ptx, this] {\n-        m_internals->TransactionAddedToMempool(ptx);\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionAddedToMempool(ptx); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: txid=%s wtxid=%s\", __func__,\n                           ptx->GetHash().ToString(),\n@@ -170,7 +201,7 @@ void CMainSignals::TransactionAddedToMempool(const CTransactionRef &ptx) {\n \n void CMainSignals::TransactionRemovedFromMempool(const CTransactionRef &ptx) {\n     auto event = [ptx, this] {\n-        m_internals->TransactionRemovedFromMempool(ptx);\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionRemovedFromMempool(ptx); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: txid=%s wtxid=%s\", __func__,\n                           ptx->GetHash().ToString(),\n@@ -179,7 +210,7 @@ void CMainSignals::TransactionRemovedFromMempool(const CTransactionRef &ptx) {\n \n void CMainSignals::BlockConnected(const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) {\n     auto event = [pblock, pindex, this] {\n-        m_internals->BlockConnected(pblock, pindex);\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.BlockConnected(pblock, pindex); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: block hash=%s block height=%d\", __func__,\n                           pblock->GetHash().ToString(),\n@@ -189,7 +220,7 @@ void CMainSignals::BlockConnected(const std::shared_ptr<const CBlock> &pblock, c\n void CMainSignals::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex)\n {\n     auto event = [pblock, pindex, this] {\n-        m_internals->BlockDisconnected(pblock, pindex);\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.BlockDisconnected(pblock, pindex); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: block hash=%s block height=%d\", __func__,\n                           pblock->GetHash().ToString(),\n@@ -198,7 +229,7 @@ void CMainSignals::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock\n \n void CMainSignals::ChainStateFlushed(const CBlockLocator &locator) {\n     auto event = [locator, this] {\n-        m_internals->ChainStateFlushed(locator);\n+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.ChainStateFlushed(locator); });\n     };\n     ENQUEUE_AND_LOG_EVENT(event, \"%s: block hash=%s\", __func__,\n                           locator.IsNull() ? \"null\" : locator.vHave.front().ToString());\n@@ -207,10 +238,10 @@ void CMainSignals::ChainStateFlushed(const CBlockLocator &locator) {\n void CMainSignals::BlockChecked(const CBlock& block, const BlockValidationState& state) {\n     LOG_EVENT(\"%s: block hash=%s state=%s\", __func__,\n               block.GetHash().ToString(), state.ToString());\n-    m_internals->BlockChecked(block, state);\n+    m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.BlockChecked(block, state); });\n }\n \n void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {\n     LOG_EVENT(\"%s: block hash=%s\", __func__, block->GetHash().ToString());\n-    m_internals->NewPoWValidBlock(pindex, block);\n+    m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.NewPoWValidBlock(pindex, block); });\n }"
      },
      {
        "sha": "cb0204a555d34e34b8fc531963dd33d61ecb51d9",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6815a2313158862d448733954a73520f223deb6/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6815a2313158862d448733954a73520f223deb6/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=d6815a2313158862d448733954a73520f223deb6",
        "patch": "@@ -171,9 +171,7 @@ class CValidationInterface {\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */\n     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n-    friend void ::RegisterSharedValidationInterface(std::shared_ptr<CValidationInterface>);\n-    friend void ::UnregisterValidationInterface(CValidationInterface*);\n-    friend void ::UnregisterAllValidationInterfaces();\n+    friend class CMainSignals;\n };\n \n struct MainSignalsInstance;"
      }
    ]
  }
]