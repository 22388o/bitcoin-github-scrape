practicalswift,2020-04-04 16:37:44,Concept ACK: less boost is better,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609054980,609054980,
naumenkogs,2020-04-04 16:39:07,Concept ACK: it solved [the issue](https://github.com/bitcoin/bitcoin/issues/18517) I had.,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609055282,609055282,
hebasto,2020-04-04 16:40:04,Concept ACK.,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609055471,609055471,
ryanofsky,2020-04-04 16:55:00,"Updated ba8312c7dca427463c83acd490281bc35dde34b7 -> ad067a98ea1ca383898bf26d4abd00981246471f ([`pr/nosig.1`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.1) -> [`pr/nosig.2`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.2), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.1..pr/nosig.2)) avoiding unneeded shared_ptr copies and cleaning up typedefs\nUpdated ad067a9",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609057547,609057547,
ryanofsky,2020-04-05 12:33:20,"Updated 3d463addfe2859bc55916f61086aaab624132411 -> b5fea244e5ac38758d295203209b66bd5905d714 ([`pr/nosig.4`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.4) -> [`pr/nosig.5`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.5), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.4..pr/nosig.5)) to destroy scheduler before callback list (no real change but makes more sense",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609409312,609409312,
MarcoFalke,2020-04-05 22:33:11,ACK b5fea244e5ac38758d295203209b66bd5905d714,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609495700,609495700,
ryanofsky,2020-04-05 23:25:36,"One way to test this change is to load and unload wallets repeatedly like in #18362. Each time a wallet is loaded and unloaded, a CValidationInterface instance gets registered and unregistered. If this is done during a sync when there are lots of UpdateTip and BlockConnected callbacks, it can be a good way to mix registrations with notifications and try to trigger deadlocks & segfaults we've previ",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609502600,609502600,
promag,2020-04-05 23:39:55,"Out of curiosity, have you considered a read write lock?",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609504395,609504395,
sipa,2020-04-06 02:43:11,ACK 96176004a39c63fdd4ada1f07e55bc62ca0c447b,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609537335,609537335,
MarcoFalke,2020-04-06 12:57:16,ACK d6815a2313158862d448733954a73520f223deb6,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609777505,609777505,
promag,2020-04-06 13:05:33,"> Curious what the boost behavior is when registrations change during a call. Seems like it would have to make a snapshot copy or use a kind of versioning to be able to ignore additions / removals\n\nYes, that's the case, slots are called without any lock using a local list.",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609781612,609781612,
laanwj,2020-04-06 14:25:34,"ACK d6815a2313158862d448733954a73520f223deb6\n\nI like the general direction of this (to move away from boost::signals2), and as it works around a problem with boost I think this is the preferable way to fix this (both in 0.20 and master).\n\n> While reviewing I thought it could make sense to define MainSignalsInstance destructor that would assert nothing is registered.\n\nFWIW asserts in de",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609827781,609827781,
hebasto,2020-04-06 14:29:48,re-ACK d6815a2313158862d448733954a73520f223deb6,https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609830139,609830139,
MarcoFalke,2020-04-06 14:53:42,"> FWIW asserts in destructors have turned out to be pretty terrible in generating shutdown crashes in unexpected conditions such as errors. So I'm not sure I like this.\n\nIt could be something that is only enabled on `--enable-debug` for tests, something like #16136 ",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609844047,609844047,
ryanofsky,2020-04-06 15:31:52,"Thanks for suggestions and reviews! I was pushing back on some suggestions that would have expanded scope of this PR or prevented it from being a refactor, but I'm working on a followup PR to implement these.",https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609866730,609866730,
promag,2020-04-04 17:15:53,So we add the same twice?,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465,403493465,src/validationinterface.cpp
promag,2020-04-04 17:16:57,How about local copy and then iterate it lock free?,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569,403493569,src/validationinterface.cpp
MarcoFalke,2020-04-04 20:31:17,"I think some C++ compilers don't allow to use `auto` in combination with C++11 list initialization for non-primitive types. You might have to write \n```suggestion\n        for (auto it = m_list.begin(), prev{m_list.end()};; prev = it++) {\n```",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585,403513585,src/validationinterface.cpp
hebasto,2020-04-04 20:38:31,"> I think some C++ compilers don't allow to use `auto` in combination with C++11 list initialization for non-primitive types.\n\nI think they allow to do it, but the [deducted type](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts) is `std::initializer_list` in this case, which is not what we want here.",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403514268,403514268,src/validationinterface.cpp
ryanofsky,2020-04-04 23:13:39,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465\n\n> So we add the same twice?\n\nThere's two emplaces because of the map and list (if that's the question)",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403565141,403565141,src/validationinterface.cpp
ryanofsky,2020-04-04 23:25:24,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569\n\n> How about local copy and then iterate it lock free?\n\nI'm not sure what approach could be entirely lock free since the list is global and can be modified from any thread.\n\nI just implemented something simple that can be changed and optimized in the future. The lock is not held when calling CValidation interface m",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570017,403570017,src/validationinterface.cpp
ryanofsky,2020-04-04 23:27:41,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585\n\n> I think they allow to do it, but the [deducted type](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts) is `std::initializer_list` in this case, which is not what we want here.\n\nThis seems to be causing compile errors on centos 7:\n\nhttps://travis-ci.org/github/bitcoin/bitcoin/",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570978,403570978,src/validationinterface.cpp
promag,2020-04-04 23:42:29,I mean this is allowing adding the same callbacks. Why not `assert(inserted.second)`?,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403577276,403577276,src/validationinterface.cpp
promag,2020-04-04 23:46:55,So at best case it would be lock free I think.,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403579194,403579194,src/validationinterface.cpp
sipa,2020-04-04 23:49:35,"Oops, I wanted to delete my own comment, but it seems I misclicked and deleted @promag's. Restoring from mail:\n\n> > Assumption is that the list is iterated frequently and modified infrequently\n>\n> Right. What I had in mind is 2 lists and an atomic book list_changed. On iterating it would then sync the list with the mutex locked.",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403580354,403580354,src/validationinterface.cpp
promag,2020-04-04 23:55:32,":) I was wondering what happened. So draft:\n```\nif (list_changed) {\n  lock;\n  iterate_list = list;\n  list_changed = false\n}\nfor (f : iterate_list) f()\n```\n ",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403582919,403582919,src/validationinterface.cpp
ryanofsky,2020-04-05 00:08:38,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465\n\n> I mean this is allowing adding the same callbacks. Why not `assert(inserted.second)`?\n\nUnit tests fail if the unregister function is not idempotent, so it seems good to me that the register function is idempotent as well. I could imagine an idempotent API here making calling code simpler, even though I could also im",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403588495,403588495,src/validationinterface.cpp
ryanofsky,2020-04-05 00:23:32,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569\n\n> Right. What I had in mind is 2 lists and an atomic book list_changed. On iterating it would then sync the list with the mutex locked.\n\nI don't understand the suggestion from the pseudocode. I don't love the idea of having multiple lists, but even if you have them, I don't see how you avoid locks copying the list if ",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403594731,403594731,src/validationinterface.cpp
sipa,2020-04-05 00:37:04,Is it not possible that there are two invocations of Iterate simultaneously?,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366,403600366,src/validationinterface.cpp
ryanofsky,2020-04-05 00:49:38,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366\n\n> Is it not possible that there are two invocations of Iterate simultaneously?\n\nIt shouldn't be the most common thing but should be possible because notifications like CMainSignals::BlockChecked and CMainSignals::NewPoWValidBlock run on calling thread. Other notifications are sent from the scheduler so shouldn't happe",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403605613,403605613,src/validationinterface.cpp
hebasto,2020-04-05 11:18:57,"It follows from the code of the `Clear()` function that `m_list` could be non-empty when the function returns.\n\nIs it consistent state if `m_list.empty() == false` and `m_map.empty() == true` ?",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403687245,403687245,src/validationinterface.cpp
ryanofsky,2020-04-05 12:15:47,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403687245\n\n> It follows from the code of the `Clear()` function that `m_list` could be non-empty when the function returns.\n> \n> Is it consistent state if `m_list.empty() == false` and `m_map.empty() == true` ?\n\nYes, this happens when the reference count of one or more callbacks in the list is nonzero, which means they are c",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403693635,403693635,src/validationinterface.cpp
hebasto,2020-04-05 13:37:08,"Why `callbacks` are moved into the `m_list` always, but not only when an insertion into `m_map` occurs?",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403702991,403702991,src/validationinterface.cpp
ryanofsky,2020-04-05 15:33:40,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403702991\n\n> Why `callbacks` are moved into the `m_list` always, but not only when an insertion into `m_map` occurs?\n\nShouldn't make a difference in practice, but it seemed better to me to call operator=(&&) and do empty destroy on the RHS object consistently instead of having different call sequences depending on a basically un",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403717827,403717827,src/validationinterface.cpp
sipa,2020-04-05 23:23:24,"Am I correct in stating the invariants here?\n* There are two types of callbacks, ones that are registered (in m_map) and ones that are not (because they're still being executed while being deleted).\n* m_list contains all callbacks of both types\n* entry.count is equal to the number of current executions of that entry, plus 1 if it's registered. It cannot be 0 (because that would imply being u",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403771944,403771944,src/validationinterface.cpp
ryanofsky,2020-04-05 23:28:01,"> Am I correct in stating the invariants here?\n\nYes, that's all correct and well stated. I'll add this as a comment",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403772517,403772517,src/validationinterface.cpp
sipa,2020-04-05 23:29:13,Nit: I think `else` on the same line like this without braces is hard to read (and easily changed into something with different semantics).,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403772689,403772689,src/validationinterface.cpp
promag,2020-04-05 23:39:39,"> Is it not possible that there are two invocations of Iterate simultaneously?\n\nMy previous suggestion isn't possible in this case.",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403773935,403773935,src/validationinterface.cpp
ryanofsky,2020-04-05 23:48:44,"> Nit: I think `else` on the same line like this without braces is hard to read (and easily changed into something with different semantics).\n\nChanged to assign statement here. You're right the else is easy to miss",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403775079,403775079,src/validationinterface.cpp
sipa,2020-04-06 00:10:20,"Is this loop equivalent to the following?\n\n```c++\nWAIT_LOCK(m_mutex, lock);\nfor (auto it = m_list.begin(); it != m_list.end();) {\n    ++it->count;\n    {\n        REVERSE_LOCK(lock);\n        f(*it->callbacks);\n    }\n    it = (--it->count) ? std::next(it) : m_list.erase(it);\n}\n```",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403777744,403777744,src/validationinterface.cpp
ryanofsky,2020-04-06 00:20:58,"> Is this loop equivalent to the following?\n\nYes and that's more straightforward. Updated",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403779135,403779135,src/validationinterface.cpp
sipa,2020-04-06 00:46:39,I think these lines can be combined into `inserted.first->second = m_list.emplace(m_list.end());`.,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403782623,403782623,src/validationinterface.cpp
sipa,2020-04-06 00:49:40,Do all of these member variables/types need to be public?,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403783002,403783002,src/validationinterface.cpp
promag,2020-04-06 09:07:44,"Personally I think these shouldn't be idempotent because makes sense to call just once. For instance `std::fstream::open` is not idempotent, fails if file is already opened. I'd rather fix unit tests. Just an opinion and should not prevent this change going forward.",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403938401,403938401,src/validationinterface.cpp
ryanofsky,2020-04-06 12:19:51,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403783002\n\n> Do all of these member variables/types need to be public?\n\nNo none do, added private/public sections",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046688,404046688,src/validationinterface.cpp
ryanofsky,2020-04-06 12:20:03,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403938401\n\n> Personally I think these shouldn't be idempotent because makes sense to call just once. For instance `std::fstream::open` is not idempotent, fails if file is already opened. I'd rather fix unit tests. Just an opinion and should not prevent this change going forward.\n\nFeel free to open a followup. If I wanted to chan",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046788,404046788,src/validationinterface.cpp
ryanofsky,2020-04-06 12:20:11,"re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403782623\n\n> I think these lines can be combined into `inserted.first->second = m_list.emplace(m_list.end());`.\n\nThanks, switched to this",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046859,404046859,src/validationinterface.cpp
promag,2020-04-06 13:43:07,"nit, could avoid incrementing usage count - receive reference.",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404100268,404100268,src/validationinterface.cpp
promag,2020-04-06 13:45:12,nit `int count{1};` ,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404101889,404101889,src/validationinterface.cpp
promag,2020-04-06 13:46:16,"nit, `== 0`.",https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404102580,404102580,src/validationinterface.cpp
sipa,2020-04-06 21:21:04,Is it correct that this iterates over the entire list? I think it should only iterate over entries that are in the map (the count of those that are already unregistered shouldn't be decremented further).,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404395685,404395685,src/validationinterface.cpp
sipa,2020-04-07 02:20:07,Suggested fix here: https://github.com/bitcoin/bitcoin/pull/18551,https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404497756,404497756,src/validationinterface.cpp
