[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864585675",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-864585675",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
    "id": 864585675,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg2NDU4NTY3NQ==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-20T17:19:13Z",
    "updated_at": "2021-09-25T23:00:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#22981](https://github.com/bitcoin/bitcoin/pull/22981) (doc: Fix incorrect C++ named args by MarcoFalke)\n* [#22976](https://github.com/bitcoin/bitcoin/pull/22976) (scripted-diff: Rename overloaded int GetArg to GetIntArg by ryanofsky)\n* [#22901](https://github.com/bitcoin/bitcoin/pull/22901) (Improve mempool_package_limits.py by naiza2000)\n* [#22674](https://github.com/bitcoin/bitcoin/pull/22674) (validation: mempool validation and submission for packages of 1 child + parents by glozow)\n* [#22539](https://github.com/bitcoin/bitcoin/pull/22539) (Re-include RBF replacement txs in fee estimation by darosior)\n* [#22097](https://github.com/bitcoin/bitcoin/pull/22097) (validation: Move package acceptance size limit from KvB to WU by ariard)\n* [#21515](https://github.com/bitcoin/bitcoin/pull/21515) (Erlay: bandwidth-efficient transaction relay protocol by naumenkogs)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864585675/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865208890",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-865208890",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
    "id": 865208890,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg2NTIwODg5MA==",
    "user": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-21T17:17:59Z",
    "updated_at": "2021-06-21T17:17:59Z",
    "author_association": "MEMBER",
    "body": "I have some concerns around what semantics are desired for bypassing the fee rate checks for a single transaction and using a notion of package fee rate instead.\r\n\r\nI think the logic here \u2014 of using the descendant fee rate as an alternate to the transaction\u2019s fee rate \u2014 is insufficient for preventing free relay.  Consider a 3 transaction package where one child transaction C has two parents, A and B, all of equal size.  Suppose A and B are zero-fee transactions and C has a fee rate of 2.  Then each of A and B would evaluate to having a fee rate of 1 (with C), but as a package the fee rate would be just 2/3.  If the mempool min fee or min relay fee is 1, then this package would make it in despite being below the required fee rate.\r\n\r\nI think this type of issue may be somewhat difficult to avoid if we don\u2019t tailor our semantics to the use case(s) we are trying to support.  Right now, if I understand correctly, we don\u2019t enforce any particular topology on the packages we accept \u2014 in fact I think the package acceptance logic would even accept unrelated transactions as well?  One idea I had was to require the whole package\u2019s fee rate to be above the min relay and mempool min fee as well, but that doesn\u2019t work very well if we allow someone to bundle in an unrelated high fee transaction to \u201cpay\u201d for some low fee rate package.\r\n\r\nWe could check that a package is connected (from a graph theory perspective) as a condition for acceptance, but that is also not quite sufficient for achieving the semantics that I think we want.  For instance, if we are processing some package that has a sub graph of transactions which would not make it in on its own, we probably wouldn\u2019t want to admit that whole graph?  I\u2019m not quite sure.  It seems like if there is a detachable sub graph that would get evicted shortly after acceptance because it\u2019s below the mempool min fee, that might still admit some kind of free relay problem, similar to the issue with unrelated transactions.\r\n\r\nMy previous approach to the package relay problem was to define packages in a future p2p protocol extension as being the set of unconfirmed ancestors of a single target transaction.  If that is sufficient for the use cases we are currently trying to support, then I think that simplifies the concerns a great deal \u2014 in this simple case I believe we could just look at two things: (a) check the target transaction\u2019s own fee rate is sufficient to get in, and (b) check that the entire ancestor package for that target transaction also has a total fee rate sufficient to get in.  (Of course we\u2019d have to add a check that validates a package only contains ancestor transactions of the target, too.)\r\n\r\nThe other benefit of using a target transaction\u2019s ancestors as how we define a package is that it lines up better with how the mining algorithm currently works.\r\n\r\nIf multiple children paying for multiple parents is some desired use case, I\u2019m not sure the mempool and mining code are set up well enough to support that, so it would be helpful to analyze those use cases better to make sure our implementation will work okay.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865208890/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865362039",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-865362039",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
    "id": 865362039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg2NTM2MjAzOQ==",
    "user": {
      "login": "Rspigler",
      "id": 24482484,
      "node_id": "MDQ6VXNlcjI0NDgyNDg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/24482484?u=7354800fee53a3db4ba3c6aa40de4ea8c3bf58f0&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Rspigler",
      "html_url": "https://github.com/Rspigler",
      "followers_url": "https://api.github.com/users/Rspigler/followers",
      "following_url": "https://api.github.com/users/Rspigler/following{/other_user}",
      "gists_url": "https://api.github.com/users/Rspigler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Rspigler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Rspigler/subscriptions",
      "organizations_url": "https://api.github.com/users/Rspigler/orgs",
      "repos_url": "https://api.github.com/users/Rspigler/repos",
      "events_url": "https://api.github.com/users/Rspigler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Rspigler/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-21T21:37:34Z",
    "updated_at": "2021-06-21T21:37:34Z",
    "author_association": "NONE",
    "body": "> in this simple case I believe we could just look at two things: (a) check the target transaction\u2019s own fee rate is sufficient to get in, and (b) check that the entire ancestor package for that target transaction also has a total fee rate sufficient to get in.\r\n\r\nThis seems reasonable.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865362039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865887922",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-865887922",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
    "id": 865887922,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg2NTg4NzkyMg==",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?u=3e27bc6589085f3450be1b0e969d04008cc77565&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-22T11:05:30Z",
    "updated_at": "2021-06-22T11:05:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thank you for the thoughtful review @sdaftuar!\r\n\r\n> I think the logic here \u2014 of using the descendant fee rate as an alternate to the transaction\u2019s fee rate \u2014 is insufficient for preventing free relay. Consider a 3 transaction package where one child transaction C has two parents, A and B, all of equal size. Suppose A and B are zero-fee transactions and C has a fee rate of 2. Then each of A and B would evaluate to having a fee rate of 1 (with C), but as a package the fee rate would be just 2/3. If the mempool min fee or min relay fee is 1, then this package would make it in despite being below the required fee rate.\r\n\r\nGreat point. I had been thinking of descendant feerate as a good marker since that's how we evict from mempool, but it is imperfect: I think we already have the case where a transaction's ancestor score is too low to be mined, but descendant score too high to be evicted. And it's additionally problematic with package relay.\r\n\r\nA proposal: if the mempool is intended to store the best candidates for mining, then we should evict in the opposite order we include in blocks, which is ancestor score.\r\nSo a transaction's `minerscore = max([ancestorfeerate(tx) for tx in {itself, all its descendants}])`. (This is with the current mining code - I suppose the definition of `minerscore` would be updated if/when block template creation changes).\r\n\r\nIf we replaced descendant feerate with `minerscore`, would that solve this problem? We go through the package, calculate everyone's ancestor feerate (including in-package and in-mempool ancestors), then we calculate everyone's `minerscore` based on that? Everyone's `minerscore` must surpass the min mempool/relay feerate. I think, then, it might not be necessary to specify/figure out which transactions are sponsees and which ones are sponsors?\r\n\r\n(Very far down the line, but just throwing a thought out there: considering feefilters with package relay, I think we would also want to use [unmodified] `minerscore` for feefiltering as well).",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865887922/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/866347317",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-866347317",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
    "id": 866347317,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg2NjM0NzMxNw==",
    "user": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-22T21:29:26Z",
    "updated_at": "2021-06-23T02:15:06Z",
    "author_association": "MEMBER",
    "body": "> A proposal: if the mempool is intended to store the best candidates for mining, then we should evict in the opposite order we include in blocks, which is ancestor score.\r\nSo a transaction's minerscore = max([ancestorfeerate(tx) for tx in {itself, all its descendants}]). (This is with the current mining code - I suppose the definition of minerscore would be updated if/when block template creation changes).\r\n\r\n> If we replaced descendant feerate with minerscore, would that solve this problem? \r\n\r\nI think we should consider these two things separately: (1) whether to change the eviction algorithm used by the mempool, and (2) whether to change the fee rate heuristic used to evaluate transaction / package acceptance.\r\n\r\n---\r\nRegarding the use of the miner score based on maximum-ancestor-feerate-of-descendants, I think that heuristic doesn't work very well for eviction.  Imagine this scenario: the mempool has a very large, very low fee rate transaction A, with children B and C.  C also is a child of another low feerate parent D.\r\n\r\nIt is possible then that B has such a high feerate that A and B would be selected for the next block, and then that C and D would be selected as well (once A is paid for by B, C's ancestor feerate score would go up).  However, if A is in fact very large, then C's own ancestor fee rate could be quite low, so that D's `minerscore` could be very small.  This might mean that D and C could be evicted if the mempool were full, even if they would be selected for the next block!\r\n\r\n(As an aside I think the worst-case computation required to maintain this score would be worse than the status quo, too -- going from O(n) to O(n^2) to update statistics in the mempool when transactions are added/removed, where n = ancestor/descendant count.)\r\n\r\n---\r\nHowever regarding the heuristic we use for admitting a package to the mempool, I think using this max-ancestor-feerate-of-descendants as an additional check that we compare to the min-relay-fee and mempool-min-fee probably does work.  It might mean that packages which include a transaction that would be relying on some in-mempool-sibling to pay for a low fee parent might not make it in, but if that's not a use case we're worried about then probably this is fine (if conservative)?\r\n\r\nThat seems to be a generalization of what I had proposed; I had suggested requiring a single ancestor-package that passes the fee rate check in total, while you're saying we can just require that every transaction in the package be part of some ancestor package that would pass the fee rate check.  I'll give that more thought but it seems like a plausible solution.\r\n\r\nEDIT: One additional thought, assuming this idea works at all I think it ought to be sufficient to restrict the calculation of the score to the package transactions alone.  That is, for each transaction, calculate its fee rate for mempool acceptance as `max([in-package-ancestor-fee-rate(tx) for tx in {itself, descendants}]`, where the `in-package-ancestor-fee-rate(tx)` is defined to be the `min(tx fee rate, tx's fee rate including in-package ancestors)`.  And then for each transaction in the package, evaluate that fee rate against the mempool min fee and the min relay fee.  The idea is that we only need to ensure that we're paying enough to justify relay of the transactions -- when the network gets busier, the mempool min fee goes up so as long as the new transaction packages being relayed are continuing to have their fee rates go up too, that should be good enough to prevent free relay.  There shouldn't be any need to look at the fee rates of the transactions that are already in the mempool.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/866347317/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/866963503",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-866963503",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
    "id": 866963503,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg2Njk2MzUwMw==",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?u=3e27bc6589085f3450be1b0e969d04008cc77565&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-06-23T15:58:10Z",
    "updated_at": "2021-08-10T12:02:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "Right, I agree with the separation between mempool eviction policy and evaluation of package transactions. Won't pursue the former much further here... \r\n\r\n~My plan of attack after the IRC [discussion](https://gist.github.com/glozow/d362100715e9a3e2e61cb4b600663377) last night is going to be 1 parent + 1 child packages (perhaps these can also be thought of as 1 sponsee + 1 sponsor) and I think checking everyone's max-ancestor-feerate-of-descendants or descendant feerate of sponsee & ancestor feerate of sponsor would all work.~\r\n\r\nEdit: I'm going for 1 child + multiple parents instead, so package feerate is what I'll use.\r\n\r\n> One additional thought, assuming this idea works at all I think it ought to be sufficient to restrict the calculation of the score to the package transactions alone. That is, for each transaction, calculate its fee rate for mempool acceptance as max([in-package-ancestor-fee-rate(tx) for tx in {itself, descendants}], where the in-package-ancestor-fee-rate(tx) is defined to be the min(tx fee rate, tx's fee rate including in-package ancestors). And then for each transaction in the package, evaluate that fee rate against the mempool min fee and the min relay fee. The idea is that we only need to ensure that we're paying enough to justify relay of the transactions -- when the network gets busier, the mempool min fee goes up so as long as the new transaction packages being relayed are continuing to have their fee rates go up too, that should be good enough to prevent free relay. There shouldn't be any need to look at the fee rates of the transactions that are already in the mempool.\r\n\r\nGood point!!!",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/866963503/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]