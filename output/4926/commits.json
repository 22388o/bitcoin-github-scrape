[
  {
    "sha": "584a358997e52a87e8c5402269c7fb3784ed2065",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODRhMzU4OTk3ZTUyYTg3ZThjNTQwMjI2OWM3ZmIzNzg0ZWQyMDY1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-09-15T22:30:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-09-24T17:17:02Z"
      },
      "message": "Do merkle root and txid duplicates check simultaneously\n\nMove the txid duplicates check into BuildMerkleTree, where it can be done\nmuch more efficiently (without needing to build a full txid set to detect\nduplicates).\n\nThe previous version (using the std::set<uint256> to detect duplicates) was\nalso slightly too weak. A block mined with actual duplicate transactions\n(which is invalid, due to the inputs of the duplicated transactions being\nseen as double spends) would trigger the duplicates logic, resulting in the\nblock not being stored on disk, and rerequested. This change fixes that by\nonly triggering in the case of duplicated transactions that can actually\nresult in an identical merkle root.",
      "tree": {
        "sha": "72cb1589072c23bded2737f1fdf9b9fb0c3e0680",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/72cb1589072c23bded2737f1fdf9b9fb0c3e0680"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/584a358997e52a87e8c5402269c7fb3784ed2065",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/584a358997e52a87e8c5402269c7fb3784ed2065",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/584a358997e52a87e8c5402269c7fb3784ed2065",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/584a358997e52a87e8c5402269c7fb3784ed2065/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a04f3d708faab4af1f1a6aeddc5a6a4db3849a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a04f3d708faab4af1f1a6aeddc5a6a4db3849a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a04f3d708faab4af1f1a6aeddc5a6a4db3849a5"
      }
    ],
    "stats": {
      "total": 74,
      "additions": 57,
      "deletions": 17
    },
    "files": [
      {
        "sha": "85cca1ebf0aa0ad4f405f5be333f9c37550b39bf",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 8,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/584a358997e52a87e8c5402269c7fb3784ed2065/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/584a358997e52a87e8c5402269c7fb3784ed2065/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=584a358997e52a87e8c5402269c7fb3784ed2065",
        "patch": "@@ -224,29 +224,66 @@ uint256 CBlockHeader::GetHash() const\n     return Hash(BEGIN(nVersion), END(nNonce));\n }\n \n-uint256 CBlock::BuildMerkleTree() const\n+uint256 CBlock::BuildMerkleTree(bool* fMutated) const\n {\n-    // WARNING! If you're reading this because you're learning about crypto\n-    // and/or designing a new system that will use merkle trees, keep in mind\n-    // that the following merkle tree algorithm has a serious flaw related to\n-    // duplicate txids, resulting in a vulnerability. (CVE-2012-2459) Bitcoin\n-    // has since worked around the flaw, but for new applications you should\n-    // use something different; don't just copy-and-paste this code without\n-    // understanding the problem first.\n+    /* WARNING! If you're reading this because you're learning about crypto\n+       and/or designing a new system that will use merkle trees, keep in mind\n+       that the following merkle tree algorithm has a serious flaw related to\n+       duplicate txids, resulting in a vulnerability (CVE-2012-2459).\n+\n+       The reason is that if the number of hashes in the list at a given time\n+       is odd, the last one is duplicated before computing the next level (which\n+       is unusual in Merkle trees). This results in certain sequences of\n+       transactions leading to the same merkle root. For example, these two\n+       trees:\n+\n+                    A               A\n+                  /  \\            /   \\\n+                B     C         B       C\n+               / \\    |        / \\     / \\\n+              D   E   F       D   E   F   F\n+             / \\ / \\ / \\     / \\ / \\ / \\ / \\\n+             1 2 3 4 5 6     1 2 3 4 5 6 5 6\n+\n+       for transaction lists [1,2,3,4,5,6] and [1,2,3,4,5,6,5,6] (where 5 and\n+       6 are repeated) result in the same root hash A (because the hash of both\n+       of (F) and (F,F) is C).\n+\n+       The vulnerability results from being able to send a block with such a\n+       transaction list, with the same merkle root, and the same block hash as\n+       the original without duplication, resulting in failed validation. If the\n+       receiving node proceeds to mark that block as permanently invalid\n+       however, it will fail to accept further unmodified (and thus potentially\n+       valid) versions of the same block. We defend against this by detecting\n+       the case where we would hash two identical hashes at the end of the list\n+       together, and treating that identically to the block having an invalid\n+       merkle root. Assuming no double-SHA256 collisions, this will detect all\n+       known ways of changing the transactions without affecting the merkle\n+       root.\n+    */\n     vMerkleTree.clear();\n+    vMerkleTree.reserve(vtx.size() * 2 + 16); // Safe upper bound for the number of total nodes.\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n         vMerkleTree.push_back(tx.GetHash());\n     int j = 0;\n+    bool mutated = false;\n     for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n     {\n         for (int i = 0; i < nSize; i += 2)\n         {\n             int i2 = std::min(i+1, nSize-1);\n+            if (i2 == i + 1 && i2 + 1 == nSize && vMerkleTree[j+i] == vMerkleTree[j+i2]) {\n+                // Two identical hashes at the end of the list at a particular level.\n+                mutated = true;\n+            }\n             vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                        BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n         }\n         j += nSize;\n     }\n+    if (fMutated) {\n+        *fMutated = mutated;\n+    }\n     return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n }\n "
      },
      {
        "sha": "de41b8621b78998f71cc69b822881456306ae0f5",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/584a358997e52a87e8c5402269c7fb3784ed2065/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/584a358997e52a87e8c5402269c7fb3784ed2065/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=584a358997e52a87e8c5402269c7fb3784ed2065",
        "patch": "@@ -528,7 +528,11 @@ class CBlock : public CBlockHeader\n         return block;\n     }\n \n-    uint256 BuildMerkleTree() const;\n+    // Build the in-memory merkle tree for this block and return the merkle root.\n+    // If non-NULL, *mutated is set to whether mutation was detected in the merkle\n+    // tree (a duplication of transactions in the block leading to an identical\n+    // merkle root).\n+    uint256 BuildMerkleTree(bool* mutated = NULL) const;\n \n     std::vector<uint256> GetMerkleBranch(int nIndex) const;\n     static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex);"
      },
      {
        "sha": "d79644e638f14dc0c7bca8b02b26beb781c73552",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/584a358997e52a87e8c5402269c7fb3784ed2065/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/584a358997e52a87e8c5402269c7fb3784ed2065/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=584a358997e52a87e8c5402269c7fb3784ed2065",
        "patch": "@@ -2289,13 +2289,12 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         if (!CheckTransaction(tx, state))\n             return error(\"CheckBlock() : CheckTransaction failed\");\n \n-    // Check for duplicate txids. This is caught by ConnectInputs(),\n-    // but catching it earlier avoids a potential DoS attack:\n-    set<uint256> uniqueTx;\n-    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        uniqueTx.insert(tx.GetHash());\n-    }\n-    if (uniqueTx.size() != block.vtx.size())\n+    // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n+    // of transactions in a block without affecting the merkle root of a block,\n+    // while still invalidating it.\n+    bool mutated;\n+    uint256 hashMerkleRoot2 = block.BuildMerkleTree(&mutated);\n+    if (mutated)\n         return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n                          REJECT_INVALID, \"bad-txns-duplicate\", true);\n \n@@ -2309,7 +2308,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n     // Check merkle root\n-    if (fCheckMerkleRoot && block.hashMerkleRoot != block.BuildMerkleTree())\n+    if (fCheckMerkleRoot && block.hashMerkleRoot != hashMerkleRoot2)\n         return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n                          REJECT_INVALID, \"bad-txnmrklroot\", true);\n "
      }
    ]
  }
]