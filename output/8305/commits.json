[
  {
    "sha": "96fa95361f68dd8169fa60e73290afae47445299",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NmZhOTUzNjFmNjhkZDgxNjlmYTYwZTczMjkwYWZhZTQ3NDQ1Mjk5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-07-07T01:18:38Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-07-12T17:12:40Z"
      },
      "message": "Improve handling of unconnecting headers\n\nWhen processing a headers message that looks like a block announcement,\nsend peer a getheaders if the headers message won't connect.\n\nApply DoS points after too many consecutive unconnecting headers messages.",
      "tree": {
        "sha": "0cbfc0a694054e7cda668148f2d5508109f5ff3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0cbfc0a694054e7cda668148f2d5508109f5ff3e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96fa95361f68dd8169fa60e73290afae47445299",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96fa95361f68dd8169fa60e73290afae47445299",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/96fa95361f68dd8169fa60e73290afae47445299",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96fa95361f68dd8169fa60e73290afae47445299/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b978701ba1822140452d35f037ce776fdcba0175",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b978701ba1822140452d35f037ce776fdcba0175",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b978701ba1822140452d35f037ce776fdcba0175"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 40,
      "deletions": 1
    },
    "files": [
      {
        "sha": "dd71ee551028b7196bea8b7b49efe5b9367cd6dd",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 1,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96fa95361f68dd8169fa60e73290afae47445299/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96fa95361f68dd8169fa60e73290afae47445299/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=96fa95361f68dd8169fa60e73290afae47445299",
        "patch": "@@ -276,6 +276,8 @@ struct CNodeState {\n     CBlockIndex *pindexLastCommonBlock;\n     //! The best header we have sent our peer.\n     CBlockIndex *pindexBestHeaderSent;\n+    //! Length of current-streak of unconnecting headers announcements\n+    int nUnconnectingHeaders;\n     //! Whether we've started headers synchronization with this peer.\n     bool fSyncStarted;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n@@ -304,6 +306,7 @@ struct CNodeState {\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = NULL;\n         pindexBestHeaderSent = NULL;\n+        nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n         nStallingSince = 0;\n         nDownloadingSince = 0;\n@@ -5773,6 +5776,35 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // If this looks like it could be a block announcement (nCount <\n+        // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n+        // don't connect:\n+        // - Send a getheaders message in response to try to connect the chain.\n+        // - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that\n+        //   don't connect before giving DoS points\n+        // - Once a headers message is received that is valid and does connect,\n+        //   nUnconnectingHeaders gets reset back to 0.\n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+            nodestate->nUnconnectingHeaders++;\n+            pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            LogPrint(\"net\", \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n+                    headers[0].GetHash().ToString(),\n+                    headers[0].hashPrevBlock.ToString(),\n+                    pindexBestHeader->nHeight,\n+                    pfrom->id, nodestate->nUnconnectingHeaders);\n+            // Set hashLastUnknownBlock for this peer, so that if we\n+            // eventually get the headers - even from a different peer -\n+            // we can use this peer to download.\n+            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n+\n+            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n+                Misbehaving(pfrom->GetId(), 20);\n+            }\n+            return true;\n+        }\n+\n         CBlockIndex *pindexLast = NULL;\n         BOOST_FOREACH(const CBlockHeader& header, headers) {\n             CValidationState state;\n@@ -5790,6 +5822,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n         }\n \n+        if (nodestate->nUnconnectingHeaders > 0) {\n+            LogPrint(\"net\", \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+        }\n+        nodestate->nUnconnectingHeaders = 0;\n+\n         assert(pindexLast);\n         UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n \n@@ -5802,7 +5839,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n-        CNodeState *nodestate = State(pfrom->GetId());\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {"
      },
      {
        "sha": "65ae2488f909583c0c82a31228e89f5fd6367b7a",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96fa95361f68dd8169fa60e73290afae47445299/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96fa95361f68dd8169fa60e73290afae47445299/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=96fa95361f68dd8169fa60e73290afae47445299",
        "patch": "@@ -138,6 +138,9 @@ static const bool DEFAULT_FEEFILTER = true;\n /** Maximum number of headers to announce when relaying blocks with headers message.*/\n static const unsigned int MAX_BLOCKS_TO_ANNOUNCE = 8;\n \n+/** Maximum number of unconnecting headers announcements before DoS score */\n+static const int MAX_UNCONNECTING_HEADERS = 10;\n+\n static const bool DEFAULT_PEERBLOOMFILTERS = true;\n \n struct BlockHasher"
      }
    ]
  },
  {
    "sha": "e91cf4b210db72ed020612a04b55e9715d8f9831",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTFjZjRiMjEwZGI3MmVkMDIwNjEyYTA0YjU1ZTk3MTVkOGY5ODMx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-07-07T01:19:32Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-07-12T17:27:01Z"
      },
      "message": "Add test for handling of unconnecting headers",
      "tree": {
        "sha": "e5f3a272031ae6f075b9d3b7325a8c3275f0633f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e5f3a272031ae6f075b9d3b7325a8c3275f0633f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e91cf4b210db72ed020612a04b55e9715d8f9831",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e91cf4b210db72ed020612a04b55e9715d8f9831",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e91cf4b210db72ed020612a04b55e9715d8f9831",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e91cf4b210db72ed020612a04b55e9715d8f9831/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "96fa95361f68dd8169fa60e73290afae47445299",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96fa95361f68dd8169fa60e73290afae47445299",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/96fa95361f68dd8169fa60e73290afae47445299"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 105,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c3f3180b6bca38eafcc150fcc843ec97a47b2512",
        "filename": "qa/rpc-tests/sendheaders.py",
        "status": "modified",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e91cf4b210db72ed020612a04b55e9715d8f9831/qa/rpc-tests/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e91cf4b210db72ed020612a04b55e9715d8f9831/qa/rpc-tests/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sendheaders.py?ref=e91cf4b210db72ed020612a04b55e9715d8f9831",
        "patch": "@@ -63,6 +63,21 @@\n    Expect: getdata request for 14 more blocks.\n f. Announce 1 more header that builds on that fork.\n    Expect: no response.\n+\n+Part 5: Test handling of headers that don't connect.\n+a. Repeat 10 times:\n+   1. Announce a header that doesn't connect.\n+      Expect: getheaders message\n+   2. Send headers chain.\n+      Expect: getdata for the missing blocks, tip update.\n+b. Then send 9 more headers that don't connect.\n+   Expect: getheaders message each time.\n+c. Announce a header that does connect.\n+   Expect: no response.\n+d. Announce 49 headers that don't connect.\n+   Expect: getheaders message each time.\n+e. Announce one more that doesn't connect.\n+   Expect: disconnect.\n '''\n \n class BaseNode(NodeConnCB):\n@@ -77,6 +92,8 @@ def __init__(self):\n         self.last_getdata = None\n         self.sleep_time = 0.05\n         self.block_announced = False\n+        self.last_getheaders = None\n+        self.disconnected = False\n \n     def clear_last_announcement(self):\n         with mininode_lock:\n@@ -127,6 +144,12 @@ def on_getdata(self, conn, message):\n     def on_pong(self, conn, message):\n         self.last_pong = message\n \n+    def on_getheaders(self, conn, message):\n+        self.last_getheaders = message\n+\n+    def on_close(self, conn):\n+        self.disconnected = True\n+\n     # Test whether the last announcement we received had the\n     # right header or the right inv\n     # inv and headers should be lists of block hashes\n@@ -178,6 +201,11 @@ def wait_for_block(self, blockhash, timeout=60):\n         self.sync(test_function, timeout)\n         return\n \n+    def wait_for_getheaders(self, timeout=60):\n+        test_function = lambda: self.last_getheaders != None\n+        self.sync(test_function, timeout)\n+        return\n+\n     def wait_for_getdata(self, hash_list, timeout=60):\n         if hash_list == []:\n             return\n@@ -186,6 +214,11 @@ def wait_for_getdata(self, hash_list, timeout=60):\n         self.sync(test_function, timeout)\n         return\n \n+    def wait_for_disconnect(self, timeout=60):\n+        test_function = lambda: self.disconnected\n+        self.sync(test_function, timeout)\n+        return\n+\n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n         headers_message.headers = [ CBlockHeader(b) for b in new_blocks ]\n@@ -510,6 +543,78 @@ def run_test(self):\n \n         print(\"Part 4: success!\")\n \n+        # Now deliver all those blocks we announced.\n+        [ test_node.send_message(msg_block(x)) for x in blocks ]\n+\n+        print(\"Part 5: Testing handling of unconnecting headers\")\n+        # First we test that receipt of an unconnecting header doesn't prevent\n+        # chain sync.\n+        for i in range(10):\n+            test_node.last_getdata = None\n+            blocks = []\n+            # Create two more blocks.\n+            for j in range(2):\n+                blocks.append(create_block(tip, create_coinbase(height), block_time))\n+                blocks[-1].solve()\n+                tip = blocks[-1].sha256\n+                block_time += 1\n+                height += 1\n+            # Send the header of the second block -> this won't connect.\n+            with mininode_lock:\n+                test_node.last_getheaders = None\n+            test_node.send_header_for_blocks([blocks[1]])\n+            test_node.wait_for_getheaders(timeout=1)\n+            test_node.send_header_for_blocks(blocks)\n+            test_node.wait_for_getdata([x.sha256 for x in blocks])\n+            [ test_node.send_message(msg_block(x)) for x in blocks ]\n+            test_node.sync_with_ping()\n+            assert_equal(int(self.nodes[0].getbestblockhash(), 16), blocks[1].sha256)\n+\n+        blocks = []\n+        # Now we test that if we repeatedly don't send connecting headers, we\n+        # don't go into an infinite loop trying to get them to connect.\n+        MAX_UNCONNECTING_HEADERS = 10\n+        for j in range(MAX_UNCONNECTING_HEADERS+1):\n+            blocks.append(create_block(tip, create_coinbase(height), block_time))\n+            blocks[-1].solve()\n+            tip = blocks[-1].sha256\n+            block_time += 1\n+            height += 1\n+\n+        for i in range(1, MAX_UNCONNECTING_HEADERS):\n+            # Send a header that doesn't connect, check that we get a getheaders.\n+            with mininode_lock:\n+                test_node.last_getheaders = None\n+            test_node.send_header_for_blocks([blocks[i]])\n+            test_node.wait_for_getheaders(timeout=1)\n+\n+        # Next header will connect, should re-set our count:\n+        test_node.send_header_for_blocks([blocks[0]])\n+\n+        # Remove the first two entries (blocks[1] would connect):\n+        blocks = blocks[2:]\n+\n+        # Now try to see how many unconnecting headers we can send\n+        # before we get disconnected.  Should be 5*MAX_UNCONNECTING_HEADERS\n+        for i in range(5*MAX_UNCONNECTING_HEADERS - 1):\n+            # Send a header that doesn't connect, check that we get a getheaders.\n+            with mininode_lock:\n+                test_node.last_getheaders = None\n+            test_node.send_header_for_blocks([blocks[i%len(blocks)]])\n+            test_node.wait_for_getheaders(timeout=1)\n+\n+        # Eventually this stops working.\n+        with mininode_lock:\n+            self.last_getheaders = None\n+        test_node.send_header_for_blocks([blocks[-1]])\n+\n+        # Should get disconnected\n+        test_node.wait_for_disconnect()\n+        with mininode_lock:\n+            self.last_getheaders = True\n+\n+        print(\"Part 5: success!\")\n+\n         # Finally, check that the inv node never received a getdata request,\n         # throughout the test\n         assert_equal(inv_node.last_getdata, None)"
      }
    ]
  }
]