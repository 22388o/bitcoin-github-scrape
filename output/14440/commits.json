[
  {
    "sha": "fa8703ff874bf6adcbe25b0635388c153ac23b05",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTg3MDNmZjg3NGJmNmFkY2JlMjViMDYzNTM4OGMxNTNhYzIzYjA1",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-10-09T07:38:58Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-10-09T07:37:39Z"
      },
      "message": "test: Inline scriptnum10 header",
      "tree": {
        "sha": "debd5c99ea7d481fabb4c42324a9bb6decd0e9d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/debd5c99ea7d481fabb4c42324a9bb6decd0e9d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa8703ff874bf6adcbe25b0635388c153ac23b05",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbvFrDAAoJEM4rdWl+aaVI3mUMAKk0wkvv4daVpkuYG22vF767\nebL2BQUqQNlGb5/jr7BCTwgAil3jfjAFYfogq6KDjK0/o3Go3Duqnq+7rZQ3FzoN\nnbeDc7G1sCOU8lzDlmczr0h96oPH+bN7Y+eqy3zkrglD+EyiddLf3HF4mlEG6w6h\nVtIHOhi8MSoLE1CKUm7VhRtlfvCoBsZtRwWCI85npY/ubpJCAbr4Rf44Qcvj5amh\nBXOVQF7+rewrgrm3km9SVS4+fXY43cfydqflhEtG7O+ZzYJPjlVlp/Xd9P7RgGri\n4EUM08uZKpBEMGmQmCxJVu2CGTZlnEqM4ph76+Vc5NTY4tLVBlWqwHhf9SHTG5ez\nVsfu/+GJdHGS8/DzeobHof7W5n5h3SKN7HbMiA+EvXe1oBqcJbt50hyrQ/riGNdb\nUjeNwj7oBNUb2V8oE3nkj32IO+cl0FyEYIicb4NRSu5y8GBzcelwbxihX952pIs2\nygI0PYMZK7epZp4283wdVZTPGuSoSX6kM4H5SL0Uyw==\n=ii3/\n-----END PGP SIGNATURE-----",
        "payload": "tree debd5c99ea7d481fabb4c42324a9bb6decd0e9d9\nparent a89896fadb119100592bbc60e6ba3933c60d6eeb\nauthor MarcoFalke <falke.marco@gmail.com> 1539070738 -0300\ncommitter MarcoFalke <falke.marco@gmail.com> 1539070659 -0300\n\ntest: Inline scriptnum10 header\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa8703ff874bf6adcbe25b0635388c153ac23b05",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa8703ff874bf6adcbe25b0635388c153ac23b05",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa8703ff874bf6adcbe25b0635388c153ac23b05/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a89896fadb119100592bbc60e6ba3933c60d6eeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a89896fadb119100592bbc60e6ba3933c60d6eeb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a89896fadb119100592bbc60e6ba3933c60d6eeb"
      }
    ],
    "stats": {
      "total": 357,
      "additions": 172,
      "deletions": 185
    },
    "files": [
      {
        "sha": "91c7aa35b2ded493b7f0a09c3edf3a54f92429f8",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa8703ff874bf6adcbe25b0635388c153ac23b05/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa8703ff874bf6adcbe25b0635388c153ac23b05/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=fa8703ff874bf6adcbe25b0635388c153ac23b05",
        "patch": "@@ -30,7 +30,6 @@ BITCOIN_TEST_SUITE = \\\n # test_bitcoin binary #\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n-  test/scriptnum10.h \\\n   test/addrman_tests.cpp \\\n   test/amount_tests.cpp \\\n   test/allocator_tests.cpp \\"
      },
      {
        "sha": "e763b642755d26de5a82a3b7d32159a2755cbec0",
        "filename": "src/test/scriptnum10.h",
        "status": "removed",
        "additions": 0,
        "deletions": 183,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a89896fadb119100592bbc60e6ba3933c60d6eeb/src/test/scriptnum10.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a89896fadb119100592bbc60e6ba3933c60d6eeb/src/test/scriptnum10.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum10.h?ref=a89896fadb119100592bbc60e6ba3933c60d6eeb",
        "patch": "@@ -1,183 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2018 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_TEST_SCRIPTNUM10_H\n-#define BITCOIN_TEST_SCRIPTNUM10_H\n-\n-#include <algorithm>\n-#include <limits>\n-#include <stdexcept>\n-#include <stdint.h>\n-#include <string>\n-#include <vector>\n-#include <assert.h>\n-\n-class scriptnum10_error : public std::runtime_error\n-{\n-public:\n-    explicit scriptnum10_error(const std::string& str) : std::runtime_error(str) {}\n-};\n-\n-class CScriptNum10\n-{\n-/**\n- * The ScriptNum implementation from Bitcoin Core 0.10.0, for cross-comparison.\n- */\n-public:\n-\n-    explicit CScriptNum10(const int64_t& n)\n-    {\n-        m_value = n;\n-    }\n-\n-    static const size_t nDefaultMaxNumSize = 4;\n-\n-    explicit CScriptNum10(const std::vector<unsigned char>& vch, bool fRequireMinimal,\n-                        const size_t nMaxNumSize = nDefaultMaxNumSize)\n-    {\n-        if (vch.size() > nMaxNumSize) {\n-            throw scriptnum10_error(\"script number overflow\");\n-        }\n-        if (fRequireMinimal && vch.size() > 0) {\n-            // Check that the number is encoded with the minimum possible\n-            // number of bytes.\n-            //\n-            // If the most-significant-byte - excluding the sign bit - is zero\n-            // then we're not minimal. Note how this test also rejects the\n-            // negative-zero encoding, 0x80.\n-            if ((vch.back() & 0x7f) == 0) {\n-                // One exception: if there's more than one byte and the most\n-                // significant bit of the second-most-significant-byte is set\n-                // it would conflict with the sign bit. An example of this case\n-                // is +-255, which encode to 0xff00 and 0xff80 respectively.\n-                // (big-endian).\n-                if (vch.size() <= 1 || (vch[vch.size() - 2] & 0x80) == 0) {\n-                    throw scriptnum10_error(\"non-minimally encoded script number\");\n-                }\n-            }\n-        }\n-        m_value = set_vch(vch);\n-    }\n-\n-    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n-    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n-    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n-    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n-    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n-    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n-\n-    inline bool operator==(const CScriptNum10& rhs) const { return operator==(rhs.m_value); }\n-    inline bool operator!=(const CScriptNum10& rhs) const { return operator!=(rhs.m_value); }\n-    inline bool operator<=(const CScriptNum10& rhs) const { return operator<=(rhs.m_value); }\n-    inline bool operator< (const CScriptNum10& rhs) const { return operator< (rhs.m_value); }\n-    inline bool operator>=(const CScriptNum10& rhs) const { return operator>=(rhs.m_value); }\n-    inline bool operator> (const CScriptNum10& rhs) const { return operator> (rhs.m_value); }\n-\n-    inline CScriptNum10 operator+(   const int64_t& rhs)    const { return CScriptNum10(m_value + rhs);}\n-    inline CScriptNum10 operator-(   const int64_t& rhs)    const { return CScriptNum10(m_value - rhs);}\n-    inline CScriptNum10 operator+(   const CScriptNum10& rhs) const { return operator+(rhs.m_value);   }\n-    inline CScriptNum10 operator-(   const CScriptNum10& rhs) const { return operator-(rhs.m_value);   }\n-\n-    inline CScriptNum10& operator+=( const CScriptNum10& rhs)       { return operator+=(rhs.m_value);  }\n-    inline CScriptNum10& operator-=( const CScriptNum10& rhs)       { return operator-=(rhs.m_value);  }\n-\n-    inline CScriptNum10 operator-()                         const\n-    {\n-        assert(m_value != std::numeric_limits<int64_t>::min());\n-        return CScriptNum10(-m_value);\n-    }\n-\n-    inline CScriptNum10& operator=( const int64_t& rhs)\n-    {\n-        m_value = rhs;\n-        return *this;\n-    }\n-\n-    inline CScriptNum10& operator+=( const int64_t& rhs)\n-    {\n-        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n-                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n-        m_value += rhs;\n-        return *this;\n-    }\n-\n-    inline CScriptNum10& operator-=( const int64_t& rhs)\n-    {\n-        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n-                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n-        m_value -= rhs;\n-        return *this;\n-    }\n-\n-    int getint() const\n-    {\n-        if (m_value > std::numeric_limits<int>::max())\n-            return std::numeric_limits<int>::max();\n-        else if (m_value < std::numeric_limits<int>::min())\n-            return std::numeric_limits<int>::min();\n-        return m_value;\n-    }\n-\n-    std::vector<unsigned char> getvch() const\n-    {\n-        return serialize(m_value);\n-    }\n-\n-    static std::vector<unsigned char> serialize(const int64_t& value)\n-    {\n-        if(value == 0)\n-            return std::vector<unsigned char>();\n-\n-        std::vector<unsigned char> result;\n-        const bool neg = value < 0;\n-        uint64_t absvalue = neg ? -value : value;\n-\n-        while(absvalue)\n-        {\n-            result.push_back(absvalue & 0xff);\n-            absvalue >>= 8;\n-        }\n-\n-//    - If the most significant byte is >= 0x80 and the value is positive, push a\n-//    new zero-byte to make the significant byte < 0x80 again.\n-\n-//    - If the most significant byte is >= 0x80 and the value is negative, push a\n-//    new 0x80 byte that will be popped off when converting to an integral.\n-\n-//    - If the most significant byte is < 0x80 and the value is negative, add\n-//    0x80 to it, since it will be subtracted and interpreted as a negative when\n-//    converting to an integral.\n-\n-        if (result.back() & 0x80)\n-            result.push_back(neg ? 0x80 : 0);\n-        else if (neg)\n-            result.back() |= 0x80;\n-\n-        return result;\n-    }\n-\n-private:\n-    static int64_t set_vch(const std::vector<unsigned char>& vch)\n-    {\n-      if (vch.empty())\n-          return 0;\n-\n-      int64_t result = 0;\n-      for (size_t i = 0; i != vch.size(); ++i)\n-          result |= static_cast<int64_t>(vch[i]) << 8*i;\n-\n-      // If the input vector's most significant byte is 0x80, remove it from\n-      // the result's msb and return a negative.\n-      if (vch.back() & 0x80)\n-          return -((int64_t)(result & ~(0x80ULL << (8 * (vch.size() - 1)))));\n-\n-      return result;\n-    }\n-\n-    int64_t m_value;\n-};\n-\n-\n-#endif // BITCOIN_TEST_BIGNUM_H"
      },
      {
        "sha": "52d9b31151efd895905f230aceff4eb61021a5d6",
        "filename": "src/test/scriptnum_tests.cpp",
        "status": "modified",
        "additions": 172,
        "deletions": 1,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa8703ff874bf6adcbe25b0635388c153ac23b05/src/test/scriptnum_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa8703ff874bf6adcbe25b0635388c153ac23b05/src/test/scriptnum_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scriptnum_tests.cpp?ref=fa8703ff874bf6adcbe25b0635388c153ac23b05",
        "patch": "@@ -2,13 +2,184 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <test/scriptnum10.h>\n #include <script/script.h>\n #include <test/test_bitcoin.h>\n \n #include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <assert.h>\n #include <limits.h>\n+#include <stdexcept>\n #include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+\n+class scriptnum10_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum10_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum10\n+{\n+/**\n+ * The ScriptNum implementation from Bitcoin Core 0.10.0, for cross-comparison.\n+ */\n+public:\n+\n+    explicit CScriptNum10(const int64_t& n)\n+    {\n+        m_value = n;\n+    }\n+\n+    static const size_t nDefaultMaxNumSize = 4;\n+\n+    explicit CScriptNum10(const std::vector<unsigned char>& vch, bool fRequireMinimal,\n+                        const size_t nMaxNumSize = nDefaultMaxNumSize)\n+    {\n+        if (vch.size() > nMaxNumSize) {\n+            throw scriptnum10_error(\"script number overflow\");\n+        }\n+        if (fRequireMinimal && vch.size() > 0) {\n+            // Check that the number is encoded with the minimum possible\n+            // number of bytes.\n+            //\n+            // If the most-significant-byte - excluding the sign bit - is zero\n+            // then we're not minimal. Note how this test also rejects the\n+            // negative-zero encoding, 0x80.\n+            if ((vch.back() & 0x7f) == 0) {\n+                // One exception: if there's more than one byte and the most\n+                // significant bit of the second-most-significant-byte is set\n+                // it would conflict with the sign bit. An example of this case\n+                // is +-255, which encode to 0xff00 and 0xff80 respectively.\n+                // (big-endian).\n+                if (vch.size() <= 1 || (vch[vch.size() - 2] & 0x80) == 0) {\n+                    throw scriptnum10_error(\"non-minimally encoded script number\");\n+                }\n+            }\n+        }\n+        m_value = set_vch(vch);\n+    }\n+\n+    inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+    inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+    inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+    inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+    inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+    inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+    inline bool operator==(const CScriptNum10& rhs) const { return operator==(rhs.m_value); }\n+    inline bool operator!=(const CScriptNum10& rhs) const { return operator!=(rhs.m_value); }\n+    inline bool operator<=(const CScriptNum10& rhs) const { return operator<=(rhs.m_value); }\n+    inline bool operator< (const CScriptNum10& rhs) const { return operator< (rhs.m_value); }\n+    inline bool operator>=(const CScriptNum10& rhs) const { return operator>=(rhs.m_value); }\n+    inline bool operator> (const CScriptNum10& rhs) const { return operator> (rhs.m_value); }\n+\n+    inline CScriptNum10 operator+(   const int64_t& rhs)    const { return CScriptNum10(m_value + rhs);}\n+    inline CScriptNum10 operator-(   const int64_t& rhs)    const { return CScriptNum10(m_value - rhs);}\n+    inline CScriptNum10 operator+(   const CScriptNum10& rhs) const { return operator+(rhs.m_value);   }\n+    inline CScriptNum10 operator-(   const CScriptNum10& rhs) const { return operator-(rhs.m_value);   }\n+\n+    inline CScriptNum10& operator+=( const CScriptNum10& rhs)       { return operator+=(rhs.m_value);  }\n+    inline CScriptNum10& operator-=( const CScriptNum10& rhs)       { return operator-=(rhs.m_value);  }\n+\n+    inline CScriptNum10 operator-()                         const\n+    {\n+        assert(m_value != std::numeric_limits<int64_t>::min());\n+        return CScriptNum10(-m_value);\n+    }\n+\n+    inline CScriptNum10& operator=( const int64_t& rhs)\n+    {\n+        m_value = rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum10& operator+=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) ||\n+                           (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs));\n+        m_value += rhs;\n+        return *this;\n+    }\n+\n+    inline CScriptNum10& operator-=( const int64_t& rhs)\n+    {\n+        assert(rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) ||\n+                           (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs));\n+        m_value -= rhs;\n+        return *this;\n+    }\n+\n+    int getint() const\n+    {\n+        if (m_value > std::numeric_limits<int>::max())\n+            return std::numeric_limits<int>::max();\n+        else if (m_value < std::numeric_limits<int>::min())\n+            return std::numeric_limits<int>::min();\n+        return m_value;\n+    }\n+\n+    std::vector<unsigned char> getvch() const\n+    {\n+        return serialize(m_value);\n+    }\n+\n+    static std::vector<unsigned char> serialize(const int64_t& value)\n+    {\n+        if(value == 0)\n+            return std::vector<unsigned char>();\n+\n+        std::vector<unsigned char> result;\n+        const bool neg = value < 0;\n+        uint64_t absvalue = neg ? -value : value;\n+\n+        while(absvalue)\n+        {\n+            result.push_back(absvalue & 0xff);\n+            absvalue >>= 8;\n+        }\n+\n+//    - If the most significant byte is >= 0x80 and the value is positive, push a\n+//    new zero-byte to make the significant byte < 0x80 again.\n+\n+//    - If the most significant byte is >= 0x80 and the value is negative, push a\n+//    new 0x80 byte that will be popped off when converting to an integral.\n+\n+//    - If the most significant byte is < 0x80 and the value is negative, add\n+//    0x80 to it, since it will be subtracted and interpreted as a negative when\n+//    converting to an integral.\n+\n+        if (result.back() & 0x80)\n+            result.push_back(neg ? 0x80 : 0);\n+        else if (neg)\n+            result.back() |= 0x80;\n+\n+        return result;\n+    }\n+\n+private:\n+    static int64_t set_vch(const std::vector<unsigned char>& vch)\n+    {\n+      if (vch.empty())\n+          return 0;\n+\n+      int64_t result = 0;\n+      for (size_t i = 0; i != vch.size(); ++i)\n+          result |= static_cast<int64_t>(vch[i]) << 8*i;\n+\n+      // If the input vector's most significant byte is 0x80, remove it from\n+      // the result's msb and return a negative.\n+      if (vch.back() & 0x80)\n+          return -((int64_t)(result & ~(0x80ULL << (8 * (vch.size() - 1)))));\n+\n+      return result;\n+    }\n+\n+    int64_t m_value;\n+};\n \n BOOST_FIXTURE_TEST_SUITE(scriptnum_tests, BasicTestingSetup)\n "
      }
    ]
  }
]